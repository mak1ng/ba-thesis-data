[comment] [EOL] from typing import Any , List [EOL] import argparse [EOL] import subprocess [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import re [EOL] import os [EOL] import sys [EOL] import glob [EOL] import logging [EOL] import argparse [EOL] import subprocess [EOL] from pathlib import Path [EOL] from datetime import datetime [EOL] from packaging . version import Version , InvalidVersion [EOL] [EOL] import api [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CHANGES_TEMPLATE = [string] [EOL] [EOL] [EOL] def bail ( message , * args ) : [EOL] [docstring] [EOL] _LOGGER . error ( message . format ( args ) ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def sanity_check ( ) : [EOL] [docstring] [EOL] if not os . path . exists ( [string] ) : [EOL] bail ( [string] ) [EOL] [EOL] if not os . getenv ( [string] ) : [EOL] bail ( [string] ) [EOL] [EOL] [EOL] def call ( cmd , * args , show_output = False ) : [EOL] [docstring] [EOL] result = subprocess . run ( cmd . format ( * args ) , shell = True , check = True , stdout = subprocess . PIPE if not show_output else None , ) [EOL] return None if show_output else result . stdout . decode ( [string] ) [EOL] [EOL] [EOL] def verify_dist ( ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] if os . path . exists ( [string] ) : [EOL] content = glob . glob ( [string] ) [EOL] if content : [EOL] for filename in content : [EOL] _LOGGER . debug ( [string] , filename ) [EOL] os . unlink ( filename ) [EOL] [EOL] if glob . glob ( [string] ) : [EOL] bail ( [string] ) [EOL] [EOL] [EOL] def create_branch ( version ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] if call ( [string] ) != [string] : [EOL] bail ( [string] ) [EOL] [EOL] branch_name = [string] + version . replace ( [string] , [string] ) [EOL] _LOGGER . info ( [string] , branch_name ) [EOL] call ( [string] , branch_name ) [EOL] [EOL] [EOL] def install_dependencies ( ) : [EOL] [docstring] [EOL] for package in [ [string] , [string] ] : [EOL] _LOGGER . info ( [string] , package ) [EOL] call ( [string] , package , show_output = False ) [EOL] [EOL] [EOL] def update_version ( version ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , version ) [EOL] [EOL] output = Path ( [string] ) . read_text ( ) [EOL] split = version . split ( [string] ) [EOL] for i , component in enumerate ( [ [string] , [string] , [string] ] ) : [EOL] output = re . sub ( [string] + component + [string] , [string] + split [ i ] + [string] , output ) [EOL] [EOL] with open ( [string] , [string] ) as wh : [EOL] wh . write ( output ) [EOL] [EOL] [EOL] def generate_outputs ( ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] call ( [string] , show_output = False ) [EOL] [EOL] [EOL] def insert_changes ( version ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] changes = Path ( [string] ) . read_text ( ) . split ( [string] ) [EOL] [EOL] if changes [ [number] ] . startswith ( [string] + version + [string] ) : [EOL] _LOGGER . info ( [string] ) [EOL] else : [EOL] version_str = [string] . format ( version , datetime . now ( ) . strftime ( [string] ) ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] message = call ( [string] ) [EOL] commit_sha = message . split ( [string] ) [ [number] ] . split ( [string] ) [ [number] ] [EOL] [EOL] _LOGGER . info ( [string] , commit_sha ) [EOL] all_changes = call ( [string] , commit_sha ) [EOL] [EOL] with open ( [string] , [string] ) as fw : [EOL] fw . write ( CHANGES_TEMPLATE . format ( version = version_str , all_changes = all_changes . rstrip ( ) ) ) [EOL] fw . write ( [string] . join ( changes [ [number] : ] ) ) [EOL] [EOL] [EOL] def verify_changes ( version ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] changes = Path ( [string] ) . read_text ( ) [EOL] if version not in changes : [EOL] bail ( [string] , version ) [EOL] [EOL] if [string] in changes : [EOL] bail ( [string] ) [EOL] [EOL] [EOL] def verify_and_create_commit ( version ) : [EOL] [docstring] [EOL] version_regex = [string] + version + [string] [EOL] if re . findall ( version_regex , call ( [string] ) ) : [EOL] bail ( [string] ) [EOL] [EOL] if [string] not in call ( [string] ) : [EOL] bail ( [string] ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] call ( [string] , version ) [EOL] [EOL] expected_files = [ [string] , [string] ] [EOL] content = call ( [string] , show_output = False ) [EOL] for filename in expected_files : [EOL] if [string] . format ( filename ) not in content : [EOL] bail ( [string] , filename ) [EOL] [EOL] [EOL] def generate_api_docs ( ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] ) [EOL] api . generate ( ) [EOL] call ( [string] , show_output = False ) [EOL] [EOL] [EOL] def create_tag ( version ) : [EOL] [docstring] [EOL] if version . is_prerelease : [EOL] _LOGGER . info ( [string] ) [EOL] else : [EOL] _LOGGER . info ( [string] , version ) [EOL] call ( [string] , version ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] [EOL] group = parser . add_mutually_exclusive_group ( required = True ) [EOL] group . add_argument ( [string] , default = False , action = [string] , dest = [string] , help = [string] , ) [EOL] group . add_argument ( [string] , default = False , action = [string] , dest = [string] , help = [string] , ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] try : [EOL] version = str ( Version ( args . version ) ) [EOL] except InvalidVersion : [EOL] _LOGGER . error ( [string] ) [EOL] return [number] [EOL] [EOL] sanity_check ( ) [EOL] [EOL] if args . prepare_release : [EOL] _LOGGER . info ( [string] , version ) [EOL] if not args . skip_branch : [EOL] create_branch ( version ) [EOL] if not args . skip_dependencies : [EOL] install_dependencies ( ) [EOL] if not args . skip_update_version : [EOL] update_version ( version ) [EOL] if not args . skip_changes : [EOL] insert_changes ( version ) [EOL] _LOGGER . info ( [string] ) [EOL] elif args . make_release : [EOL] _LOGGER . info ( [string] , version ) [EOL] if not args . skip_verify_changes : [EOL] verify_changes ( version ) [EOL] if not args . skip_api : [EOL] generate_api_docs ( ) [EOL] if not args . skip_commit : [EOL] verify_and_create_commit ( version ) [EOL] if not args . skip_outputs : [EOL] verify_dist ( ) [EOL] generate_outputs ( ) [EOL] if not args . skip_tag : [EOL] create_tag ( Version ( args . version ) ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Tuple , Dict [EOL] import typing [EOL] [docstring] [EOL] from pyatv import interface [EOL] [EOL] FEATURE_TEMPLATE = [string] [EOL] [EOL] [EOL] ENUM_VALUE_TEMPLATE = [string] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] features = interface . _ALL_FEATURES [EOL] enum_values = [string] . join ( ENUM_VALUE_TEMPLATE . format ( name = tmp [ [number] ] , index = index , doc = tmp [ [number] ] ) for index , tmp in features . items ( ) ) [EOL] print ( FEATURE_TEMPLATE . format ( enum = enum_values ) ) [EOL] [EOL] print ( [string] , max ( features . keys ( ) ) + [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Any , Dict , List [EOL] import argparse [EOL] import typing [EOL] import tests [EOL] import logging [EOL] import asyncio [EOL] [docstring] [EOL] import os [EOL] import sys [EOL] import asyncio [EOL] import logging [EOL] import argparse [EOL] from ipaddress import IPv4Address [EOL] [EOL] from zeroconf import Zeroconf [EOL] [EOL] from pyatv . const import Protocol [EOL] from pyatv . support import mdns [EOL] [EOL] sys . path . insert ( [number] , os . path . dirname ( os . path . realpath ( __file__ ) ) + [string] ) [comment] [EOL] [EOL] from tests . fake_device import FakeAppleTV [comment] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEVICE_NAME = [string] [EOL] AIRPLAY_IDENTIFIER = [string] [EOL] [EOL] SERVER_IDENTIFIER = [string] [EOL] [EOL] HSGID = [string] [EOL] PAIRING_GUID = [string] [EOL] SESSION_ID = [number] [EOL] [EOL] [EOL] async def _alter_playing ( usecase ) : [EOL] while True : [EOL] try : [EOL] logging . debug ( [string] ) [EOL] usecase . example_video ( ) [EOL] await asyncio . sleep ( [number] ) [EOL] usecase . example_music ( ) [EOL] await asyncio . sleep ( [number] ) [EOL] usecase . nothing_playing ( ) [EOL] await asyncio . sleep ( [number] ) [EOL] except asyncio . CancelledError : [EOL] break [EOL] except Exception : [EOL] logging . exception ( [string] ) [EOL] [EOL] [EOL] async def publish_mrp_zeroconf ( loop , zconf , address , port ) : [EOL] [docstring] [EOL] props = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : False , [string] : DEVICE_NAME , [string] : SERVER_IDENTIFIER , [string] : [string] , [string] : AIRPLAY_IDENTIFIER , } [EOL] return await mdns . publish ( loop , mdns . Service ( [string] , DEVICE_NAME , IPv4Address ( address ) , port , props ) , zconf , ) [EOL] [EOL] [EOL] async def publish_dmap_zeroconf ( loop , zconf , address , port ) : [EOL] [docstring] [EOL] props = { [string] : [string] , [string] : [string] , [string] : HSGID , [string] : DEVICE_NAME , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] return await mdns . publish ( loop , mdns . Service ( [string] , DEVICE_NAME , IPv4Address ( address ) , port , props ) , zconf , ) [EOL] [EOL] [EOL] async def publish_airplay_zeroconf ( loop , zconf , address , port ) : [EOL] [docstring] [EOL] props = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] return await mdns . publish ( loop , mdns . Service ( [string] , DEVICE_NAME , IPv4Address ( address ) , port , props ) , zconf , ) [EOL] [EOL] [EOL] async def appstart ( loop ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , default = False , action = [string] , help = [string] ) [EOL] [EOL] protocols = parser . add_argument_group ( [string] ) [EOL] protocols . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] protocols . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] protocols . add_argument ( [string] , default = False , action = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if not ( args . mrp or args . dmap or args . airplay ) : [EOL] parser . error ( [string] ) [EOL] [EOL] level = logging . DEBUG if args . debug else logging . WARNING [EOL] logging . basicConfig ( level = level , stream = sys . stdout , datefmt = [string] , format = [string] , ) [EOL] [EOL] tasks = [ ] [EOL] unpublishers = [ ] [EOL] zconf = Zeroconf ( ) [EOL] fake_atv = FakeAppleTV ( loop , test_mode = False ) [EOL] if args . mrp : [EOL] _ , usecase = fake_atv . add_service ( Protocol . MRP ) [EOL] if args . demo : [EOL] tasks . append ( asyncio . ensure_future ( _alter_playing ( usecase ) ) ) [EOL] [EOL] if args . dmap : [EOL] _ , usecase = fake_atv . add_service ( Protocol . DMAP , hsgid = HSGID , pairing_guid = PAIRING_GUID , session_id = SESSION_ID ) [EOL] if args . demo : [EOL] tasks . append ( asyncio . ensure_future ( _alter_playing ( usecase ) ) ) [EOL] [EOL] if args . airplay : [EOL] _ , usecase = fake_atv . add_service ( Protocol . AirPlay ) [EOL] [EOL] await fake_atv . start ( ) [EOL] [EOL] if args . mrp : [EOL] unpublishers . append ( await publish_mrp_zeroconf ( loop , zconf , args . local_ip , fake_atv . get_port ( Protocol . MRP ) ) ) [EOL] [EOL] if args . dmap : [EOL] unpublishers . append ( await publish_dmap_zeroconf ( loop , zconf , args . local_ip , fake_atv . get_port ( Protocol . DMAP ) ) ) [EOL] [EOL] if args . airplay : [EOL] unpublishers . append ( await publish_airplay_zeroconf ( loop , zconf , args . local_ip , fake_atv . get_port ( Protocol . AirPlay ) ) ) [EOL] [EOL] print ( [string] ) [EOL] await loop . run_in_executor ( None , sys . stdin . readline ) [EOL] [EOL] await fake_atv . stop ( ) [EOL] [EOL] for task in tasks : [EOL] task . cancel ( ) [EOL] [EOL] for unpublisher in unpublishers : [EOL] await unpublisher ( ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] loop = asyncio . get_event_loop ( ) [EOL] return loop . run_until_complete ( appstart ( loop ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] import os [EOL] import argparse [EOL] import warnings [EOL] from difflib import unified_diff [EOL] from pathlib import Path [EOL] [EOL] import pdoc [EOL] [EOL] warnings . filterwarnings ( [string] ) [EOL] pdoc . tpl_lookup . directories . insert ( [number] , os . path . join ( [string] , [string] ) ) [EOL] [EOL] [EOL] def _filter_func ( doc ) : [EOL] for exclude in [ [string] , [string] , [string] , [string] , [string] , ] : [EOL] if doc . refname . startswith ( [string] + exclude ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def _api_modules ( ) : [EOL] def _recursive_htmls ( mod ) : [EOL] yield mod . name , mod . html ( ) [EOL] for submod in mod . submodules ( ) : [EOL] yield from _recursive_htmls ( submod ) [EOL] [EOL] modules = [ [string] ] [EOL] context = pdoc . Context ( ) [EOL] [EOL] modules = [ pdoc . Module ( mod , context = context , docfilter = _filter_func ) for mod in modules ] [EOL] pdoc . link_inheritance ( context ) [EOL] [EOL] for mod in modules : [EOL] for module_name , html in _recursive_htmls ( mod ) : [EOL] split = module_name . split ( [string] ) [EOL] split [ - [number] ] = split [ - [number] ] + [string] [EOL] output_file = os . path . join ( [string] , [string] , * split ) [EOL] yield output_file , html [EOL] [EOL] [EOL] def generate ( ) : [EOL] [docstring] [EOL] for output_file , html in _api_modules ( ) : [EOL] print ( [string] , output_file ) [EOL] with open ( output_file , [string] ) as fh : [EOL] fh . write ( html . encode ( [string] ) ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def verify ( ) : [EOL] [docstring] [EOL] return_value = [number] [EOL] for output_file , html in _api_modules ( ) : [EOL] print ( [string] , output_file ) [EOL] expected_output = Path ( output_file ) . read_text ( encoding = [string] ) [EOL] if html != expected_output : [EOL] print ( [string] , file = sys . stderr , ) [EOL] print ( [string] . join ( unified_diff ( expected_output . splitlines ( [number] ) , html . splitlines ( [number] ) ) ) , file = sys . stderr , ) [EOL] return_value = [number] [EOL] return return_value [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] if not os . path . exists ( [string] ) : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , choices = [ [string] , [string] ] , help = [string] ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . command == [string] : [EOL] return generate ( ) [EOL] elif args . command == [string] : [EOL] return verify ( ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Type , List , Set , Dict , Optional , Any , Tuple [EOL] import subprocess [EOL] import argparse [EOL] import typing [EOL] import os [EOL] import scripts [EOL] import cryptography [EOL] import requests [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] import glob [EOL] import stat [EOL] import difflib [EOL] import zipfile [EOL] import requests [EOL] import binascii [EOL] import argparse [EOL] import subprocess [EOL] from io import BytesIO [EOL] from collections import namedtuple [EOL] [EOL] import cryptography [EOL] from google . protobuf . text_format import MessageToString [EOL] from cryptography . hazmat . primitives . ciphers . aead import ChaCha20Poly1305 [EOL] [EOL] [EOL] PROTOBUF_VERSION = [string] [EOL] [EOL] [comment] [EOL] REUSED_MESSAGES = { [string] : [string] } [EOL] [EOL] BASE_PATH = os . path . join ( [string] , [string] , [string] ) [EOL] OUTPUT_TEMPLATE = [string] [EOL] [EOL] MessageInfo = namedtuple ( [string] , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] def _protobuf_url ( ) : [EOL] BASE_URL = ( [string] + [string] ) [EOL] PLATFORMS = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] platform = PLATFORMS . get ( sys . platform ) [EOL] if not platform : [EOL] print ( [string] + sys . platform , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] return BASE_URL . format ( version = PROTOBUF_VERSION , platform = platform ) [EOL] [EOL] [EOL] def _download_protoc ( force = False ) : [EOL] if os . path . exists ( protoc_path ( ) ) and not force : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] url = _protobuf_url ( ) [EOL] [EOL] print ( [string] , url ) [EOL] [EOL] resp = requests . get ( url ) [EOL] with zipfile . ZipFile ( BytesIO ( resp . content ) ) as zip_file : [EOL] for zip_info in zip_file . infolist ( ) : [EOL] if zip_info . filename . startswith ( [string] ) : [EOL] print ( [string] , zip_info . filename ) [EOL] zip_file . extract ( zip_info ) [EOL] break [EOL] [EOL] if not os . path . exists ( protoc_path ( ) ) : [EOL] print ( protoc_path ( ) , [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] st = os . stat ( protoc_path ( ) ) [EOL] os . chmod ( protoc_path ( ) , st . st_mode | stat . S_IEXEC ) [EOL] [EOL] [EOL] def _verify_protoc_version ( ) : [EOL] try : [EOL] ret = subprocess . run ( [ protoc_path ( ) , [string] ] , stdout = subprocess . PIPE , stderr = subprocess . STDOUT , ) [EOL] installed_version = ret . stdout . decode ( [string] ) . split ( [string] ) [ [number] ] . rstrip ( ) [EOL] if installed_version != PROTOBUF_VERSION : [EOL] print ( [string] , PROTOBUF_VERSION , [string] , installed_version , file = sys . stderr , ) [EOL] sys . exit ( [number] ) [EOL] except FileNotFoundError : [EOL] print ( [string] , file = sys . stderr , ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def protoc_path ( ) : [EOL] [docstring] [EOL] binary = [string] + ( [string] if sys . platform == [string] else [string] ) [EOL] return os . path . join ( [string] , binary ) [EOL] [EOL] [EOL] def extract_message_info ( ) : [EOL] [docstring] [EOL] filename = os . path . join ( BASE_PATH , [string] ) [EOL] [EOL] with open ( filename , [string] ) as file : [EOL] types_found = False [EOL] [EOL] for line in file : [EOL] stripped = line . lstrip ( ) . rstrip ( ) [EOL] [EOL] [comment] [EOL] if stripped == [string] : [EOL] types_found = True [EOL] continue [EOL] elif types_found and stripped == [string] : [EOL] break [EOL] elif not types_found : [EOL] continue [EOL] [EOL] constant = stripped . split ( [string] ) [ [number] ] [EOL] title = constant . title ( ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [comment] [EOL] accessor = title [ [number] ] . lower ( ) + title [ [number] : ] [EOL] [EOL] if not os . path . exists ( os . path . join ( BASE_PATH , title + [string] ) ) : [EOL] continue [EOL] [EOL] yield MessageInfo ( title + [string] , title , accessor , constant ) [EOL] [EOL] [EOL] def extract_unreferenced_messages ( ) : [EOL] [docstring] [EOL] for filename in os . listdir ( BASE_PATH ) : [EOL] tmp = os . path . splitext ( filename ) [EOL] if tmp [ [number] ] != [string] or tmp [ [number] ] == [string] : [EOL] continue [EOL] [EOL] with open ( os . path . join ( BASE_PATH , filename ) ) as file : [EOL] for line in file : [EOL] if line . startswith ( [string] ) : [EOL] yield tmp [ [number] ] + [string] , line . split ( [string] ) [ [number] ] [EOL] [EOL] [EOL] def generate_module_code ( ) : [EOL] [docstring] [EOL] message_names = set ( ) [EOL] packages = [ ] [EOL] messages = [ ] [EOL] extensions = [ ] [EOL] constants = [ ] [EOL] [EOL] [comment] [EOL] for info in extract_message_info ( ) : [EOL] message_names . add ( info . title ) [EOL] packages . append ( [string] + info . module ) [EOL] messages . append ( [string] . format ( info . module , info . title ) ) [EOL] extensions . append ( [string] . format ( info . const , info . module , info . accessor ) ) [EOL] constants . append ( [string] . format ( info . const ) ) [EOL] [EOL] reused = REUSED_MESSAGES . get ( info . const ) [EOL] if reused : [EOL] extensions . append ( [string] . format ( reused , info . module , info . accessor ) ) [EOL] constants . append ( [string] . format ( reused ) ) [EOL] [EOL] [comment] [EOL] for module_name , message_name in extract_unreferenced_messages ( ) : [EOL] if message_name not in message_names : [EOL] message_names . add ( message_name ) [EOL] messages . append ( [string] . format ( module_name , message_name ) ) [EOL] [EOL] return OUTPUT_TEMPLATE . format ( packages = [string] . join ( sorted ( packages ) ) , messages = [string] . join ( sorted ( messages ) ) , extensions = [string] . join ( sorted ( extensions ) ) , constants = [string] . join ( sorted ( constants ) ) , ) [EOL] [EOL] [EOL] def update_auto_generated_code ( ) : [EOL] [docstring] [EOL] proto_files = glob . glob ( os . path . join ( BASE_PATH , [string] ) ) [EOL] subprocess . run ( [ protoc_path ( ) , [string] , [string] , [string] ] + proto_files ) [EOL] [EOL] module_code = generate_module_code ( ) [EOL] with open ( os . path . join ( BASE_PATH , [string] ) , [string] ) as fh : [EOL] fh . write ( module_code ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def verify_generated_code ( ) : [EOL] [docstring] [EOL] generated_code = generate_module_code ( ) . splitlines ( True ) [EOL] [EOL] with open ( os . path . join ( BASE_PATH , [string] ) , [string] ) as fh : [EOL] actual = fh . readlines ( ) [EOL] [EOL] diff = list ( difflib . unified_diff ( actual , generated_code , fromfile = [string] , tofile = [string] ) ) [EOL] if diff : [EOL] print ( [string] , file = sys . stderr ) [EOL] print ( [number] * [string] , file = sys . stderr ) [EOL] print ( [string] . join ( diff ) , file = sys . stderr ) [EOL] print ( [number] * [string] , file = sys . stderr ) [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] print ( [string] ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _print_single_message ( data , unknown_fields ) : [EOL] from pyatv . mrp . protobuf import ProtocolMessage [EOL] [EOL] parsed = ProtocolMessage ( ) [EOL] parsed . ParseFromString ( data ) [EOL] output = MessageToString ( parsed , print_unknown_fields = unknown_fields ) [EOL] print ( output ) [EOL] [EOL] [EOL] def decode_and_print_message ( args ) : [EOL] [docstring] [EOL] from pyatv . mrp import variant [EOL] [EOL] buf = binascii . unhexlify ( args . message ) [EOL] if not args . stream : [EOL] buf = variant . write_variant ( len ( buf ) ) + buf [EOL] [EOL] while buf : [EOL] length , raw = variant . read_variant ( buf ) [EOL] data = raw [ : length ] [EOL] buf = raw [ length : ] [EOL] _print_single_message ( data , args . unknown_fields ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def _decrypt_chacha20poly1305 ( data , nounce , key ) : [EOL] [docstring] [EOL] data = binascii . unhexlify ( data ) [EOL] input_key = binascii . unhexlify ( key ) [EOL] input_nonce = [string] + nounce . to_bytes ( length = [number] , byteorder = [string] ) [EOL] chacha = ChaCha20Poly1305 ( input_key ) [EOL] try : [EOL] print ( [string] . format ( input_key , input_nonce ) ) [EOL] decrypted_data = chacha . decrypt ( input_nonce , data , None ) [EOL] print ( [string] [string] . format ( binascii . hexlify ( input_nonce ) . decode ( ) , binascii . hexlify ( input_key ) . decode ( ) , binascii . hexlify ( decrypted_data ) . decode ( ) , ) ) [EOL] _print_single_message ( decrypted_data , True ) [EOL] return True [EOL] except cryptography . exceptions . InvalidTag : [EOL] pass [EOL] [EOL] return False [EOL] [EOL] [EOL] def decrypt_and_print_message ( args ) : [EOL] [docstring] [EOL] for key in args . keys : [EOL] for nounce in range ( args . nounce_lower , args . nounce_upper ) : [EOL] if _decrypt_chacha20poly1305 ( args . message , nounce , key ) : [EOL] return [number] [EOL] return [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] if not os . path . exists ( [string] ) : [EOL] print ( [string] , file = sys . stderr ) [EOL] return [number] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] [EOL] subparsers = parser . add_subparsers ( help = [string] , dest = [string] ) [EOL] subparsers . add_parser ( [string] , help = [string] ) [EOL] subparsers . add_parser ( [string] , help = [string] ) [EOL] [EOL] decode = subparsers . add_parser ( [string] , help = [string] ) [EOL] decode . add_argument ( [string] , help = [string] ) [EOL] decode . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] decode . add_argument ( [string] , [string] , action = [string] , help = [string] , ) [EOL] [EOL] decrypt = subparsers . add_parser ( [string] , help = [string] ) [EOL] decrypt . add_argument ( [string] , help = [string] ) [EOL] decrypt . add_argument ( [string] , nargs = [string] , help = [string] ) [EOL] decrypt . add_argument ( [string] , [string] , type = int , default = [number] , help = [string] , ) [EOL] decrypt . add_argument ( [string] , [string] , type = int , default = [number] , help = [string] , ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] if not args . command : [EOL] parser . error ( [string] ) [EOL] return [number] [EOL] [EOL] if args . command == [string] : [EOL] if args . download : [EOL] _download_protoc ( args . force ) [EOL] _verify_protoc_version ( ) [EOL] return update_auto_generated_code ( ) [EOL] elif args . command == [string] : [EOL] if args . download : [EOL] _download_protoc ( args . force ) [EOL] _verify_protoc_version ( ) [EOL] return verify_generated_code ( ) [EOL] elif args . command == [string] : [EOL] return decode_and_print_message ( args ) [EOL] elif args . command == [string] : [EOL] return decrypt_and_print_message ( args ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[scripts.protobuf.MessageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[scripts.protobuf.MessageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import tests [EOL] import logging [EOL] import typing [EOL] import asyncio [EOL] import logging [EOL] [EOL] import pytest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class KnockServer ( asyncio . Protocol ) : [EOL] def __init__ ( self , port ) : [EOL] self . got_knock = False [EOL] self . count = [number] [EOL] self . port = port [EOL] [EOL] def connection_made ( self , transport ) : [EOL] own = transport . get_extra_info ( [string] ) [EOL] peername = transport . get_extra_info ( [string] ) [EOL] _LOGGER . debug ( [string] , * own , * peername ) [EOL] self . transport = transport [EOL] [EOL] def connection_lost ( self , exc ) : [EOL] self . got_knock = True [EOL] self . count += [number] [EOL] self . transport = None [EOL] [EOL] def data_received ( self , data ) : [EOL] assert False , [string] [EOL] [EOL] [EOL] async def create_knock_server ( port , loop ) : [EOL] server = KnockServer ( port ) [EOL] return await loop . create_server ( lambda : server , [string] , port ) , server [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tests [EOL] [docstring] [EOL] from zeroconf import ServiceInfo [EOL] [EOL] [EOL] class ServiceBrowserStub : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , zeroconf , service_type , listener ) : [EOL] [docstring] [EOL] for service in zeroconf . services : [EOL] if service . type == service_type : [EOL] listener . add_service ( zeroconf , service_type , service . name ) [EOL] [EOL] [EOL] class ZeroconfStub : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , services ) : [EOL] [docstring] [EOL] self . services = services [EOL] self . registered_services = [ ] [EOL] [EOL] def get_service_info ( self , service_type , service_name ) : [EOL] [docstring] [EOL] for service in self . services : [EOL] if service . name == service_name : [EOL] return service [EOL] [EOL] def register_service ( self , service ) : [EOL] [docstring] [EOL] self . registered_services . append ( service ) [EOL] [EOL] def unregister_service ( self , service ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def close ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def stub ( module , * services ) : [EOL] [docstring] [EOL] instance = ZeroconfStub ( list ( services ) ) [EOL] module . Zeroconf = lambda : instance [EOL] module . ServiceBrowser = ServiceBrowserStub [EOL] return instance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import pyatv [EOL] [docstring] [EOL] [EOL] import binascii [EOL] [EOL] from aiohttp import ClientSession [EOL] from aiohttp . test_utils import AioHTTPTestCase , unittest_run_loop [EOL] [EOL] from pyatv . const import Protocol [EOL] from pyatv . airplay import srp [EOL] from pyatv . airplay . auth import DeviceAuthenticator , AuthenticationVerifier [EOL] from pyatv . exceptions import AuthenticationError [EOL] from pyatv . support . net import HttpSession [EOL] from tests . fake_device import FakeAppleTV [EOL] from tests . fake_device . airplay import ( DEVICE_IDENTIFIER , DEVICE_AUTH_KEY , DEVICE_PIN , ) [EOL] [EOL] [EOL] INVALID_AUTH_KEY = binascii . unhexlify ( [string] * [number] ) [EOL] [EOL] [EOL] class AirPlayAuthTest ( AioHTTPTestCase ) : [EOL] async def setUpAsync ( self ) : [EOL] self . session = ClientSession ( ) [EOL] [EOL] async def tearDownAsync ( self ) : [EOL] await self . session . close ( ) [EOL] [EOL] async def get_application ( self , loop = None ) : [EOL] self . fake_atv = FakeAppleTV ( self . loop ) [EOL] self . fake_atv . add_service ( Protocol . AirPlay ) [EOL] return self . fake_atv . app [EOL] [EOL] @ unittest_run_loop async def test_verify_invalid ( self ) : [EOL] http = HttpSession ( self . session , [string] . format ( self . server . port ) ) [EOL] handler = srp . SRPAuthHandler ( ) [EOL] handler . initialize ( INVALID_AUTH_KEY ) [EOL] [EOL] verifier = AuthenticationVerifier ( http , handler ) [EOL] with self . assertRaises ( AuthenticationError ) : [EOL] await verifier . verify_authed ( ) [EOL] [EOL] @ unittest_run_loop async def test_verify_authenticated ( self ) : [EOL] http = HttpSession ( self . session , [string] . format ( self . server . port ) ) [EOL] handler = srp . SRPAuthHandler ( ) [EOL] handler . initialize ( binascii . unhexlify ( DEVICE_AUTH_KEY ) ) [EOL] [EOL] verifier = AuthenticationVerifier ( http , handler ) [EOL] self . assertTrue ( ( await verifier . verify_authed ( ) ) ) [EOL] [EOL] @ unittest_run_loop async def test_auth_failed ( self ) : [EOL] http = HttpSession ( self . session , [string] . format ( self . server . port ) ) [EOL] handler = srp . SRPAuthHandler ( ) [EOL] handler . initialize ( INVALID_AUTH_KEY ) [EOL] [EOL] authenticator = DeviceAuthenticator ( http , handler ) [EOL] await authenticator . start_authentication ( ) [EOL] with self . assertRaises ( AuthenticationError ) : [EOL] await authenticator . finish_authentication ( DEVICE_IDENTIFIER , DEVICE_PIN ) [EOL] [EOL] @ unittest_run_loop async def test_auth_successful ( self ) : [EOL] http = HttpSession ( self . session , [string] . format ( self . server . port ) ) [EOL] handler = srp . SRPAuthHandler ( ) [EOL] handler . initialize ( binascii . unhexlify ( DEVICE_AUTH_KEY ) ) [EOL] [EOL] authenticator = DeviceAuthenticator ( http , handler ) [EOL] await authenticator . start_authentication ( ) [EOL] self . assertTrue ( ( await authenticator . finish_authentication ( DEVICE_IDENTIFIER , DEVICE_PIN ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 $builtins.bytes$ 0 0 0 $pyatv.airplay.auth.AuthenticationVerifier$ 0 0 0 $pyatv.support.net.HttpSession$ 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.AuthenticationVerifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.AuthenticationVerifier$ 0 0 0 $pyatv.support.net.HttpSession$ 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.AuthenticationVerifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 $builtins.bytes$ 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 $pyatv.support.net.HttpSession$ 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 $pyatv.support.net.HttpSession$ 0 $pyatv.airplay.srp.SRPAuthHandler$ 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 0 0 0 0 0 0 0 0 $pyatv.airplay.auth.DeviceAuthenticator$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import binascii [EOL] from unittest . mock import patch [EOL] [EOL] from aiohttp . test_utils import AioHTTPTestCase , unittest_run_loop [EOL] [EOL] from pyatv import pair , exceptions [EOL] from pyatv . const import Protocol [EOL] from pyatv . conf import AirPlayService , AppleTV [EOL] from tests . fake_device import FakeAppleTV [EOL] from tests . fake_device . airplay import ( DEVICE_CREDENTIALS , DEVICE_PIN , DEVICE_IDENTIFIER , DEVICE_AUTH_KEY , ) [EOL] [EOL] [EOL] def predetermined_key ( num ) : [EOL] [docstring] [EOL] if num == [number] : [EOL] return binascii . unhexlify ( DEVICE_IDENTIFIER ) [EOL] return binascii . unhexlify ( DEVICE_AUTH_KEY ) [EOL] [EOL] [EOL] class PairFunctionalTest ( AioHTTPTestCase ) : [EOL] def setUp ( self ) : [EOL] AioHTTPTestCase . setUp ( self ) [EOL] self . pairing = None [EOL] [EOL] self . service = AirPlayService ( [string] , port = self . server . port ) [EOL] self . conf = AppleTV ( [string] , [string] ) [EOL] self . conf . add_service ( self . service ) [EOL] [EOL] async def tearDownAsync ( self ) : [EOL] await self . pairing . close ( ) [EOL] await super ( ) . tearDownAsync ( ) [EOL] [EOL] async def get_application ( self , loop = None ) : [EOL] self . fake_atv = FakeAppleTV ( self . loop ) [EOL] _ , self . usecase = self . fake_atv . add_service ( Protocol . AirPlay ) [EOL] return self . fake_atv . app [EOL] [EOL] async def do_pairing ( self , pin = DEVICE_PIN ) : [EOL] self . usecase . airplay_require_authentication ( ) [EOL] [EOL] self . pairing = await pair ( self . conf , Protocol . AirPlay , self . loop ) [EOL] [EOL] self . assertTrue ( self . pairing . device_provides_pin ) [EOL] [EOL] await self . pairing . begin ( ) [EOL] if pin : [EOL] self . pairing . pin ( pin ) [EOL] [EOL] self . assertFalse ( self . pairing . has_paired ) [EOL] [EOL] await self . pairing . finish ( ) [EOL] self . assertTrue ( self . pairing . has_paired ) [EOL] self . assertEqual ( self . service . credentials , DEVICE_CREDENTIALS ) [EOL] [EOL] @ unittest_run_loop async def test_pairing_exception_invalid_pin ( self ) : [EOL] with self . assertRaises ( exceptions . PairingError ) : [EOL] await self . do_pairing ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_pairing_exception_no_pin ( self ) : [EOL] with self . assertRaises ( exceptions . PairingError ) : [EOL] await self . do_pairing ( None ) [EOL] [EOL] @ patch ( [string] ) @ unittest_run_loop async def test_pairing_with_device_new_credentials ( self , rand_func ) : [EOL] rand_func . side_effect = predetermined_key [EOL] await self . do_pairing ( ) [EOL] [EOL] @ unittest_run_loop async def test_pairing_with_device_existing_credentials ( self ) : [EOL] self . conf . get_service ( Protocol . AirPlay ) . credentials = DEVICE_CREDENTIALS [EOL] await self . do_pairing ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pyatv [EOL] [docstring] [EOL] [EOL] from aiohttp import ClientSession [EOL] from aiohttp . test_utils import AioHTTPTestCase , unittest_run_loop [EOL] [EOL] from pyatv import exceptions , net [EOL] from pyatv . const import Protocol [EOL] from pyatv . airplay import player [EOL] from tests . fake_device import FakeAppleTV [EOL] from tests . utils import stub_sleep , unstub_sleep [EOL] [EOL] [EOL] STREAM = [string] [EOL] START_POSITION = [number] [EOL] [EOL] [EOL] class AirPlayPlayerTest ( AioHTTPTestCase ) : [EOL] async def setUpAsync ( self ) : [EOL] await AioHTTPTestCase . setUpAsync ( self ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] stub_sleep ( self . fake_asyncio_sleep ) [EOL] self . no_of_sleeps = [number] [EOL] [EOL] self . session = ClientSession ( ) [EOL] http = net . HttpSession ( self . session , [string] . format ( self . server . port ) ) [EOL] self . player = player . AirPlayPlayer ( self . loop , http ) [EOL] [EOL] async def tearDownAsync ( self ) : [EOL] unstub_sleep ( ) [EOL] await self . session . close ( ) [EOL] await AioHTTPTestCase . tearDownAsync ( self ) [EOL] [EOL] async def get_application ( self , loop = None ) : [EOL] self . fake_atv = FakeAppleTV ( self . loop ) [EOL] self . state , self . usecase = self . fake_atv . add_service ( Protocol . AirPlay ) [EOL] return self . fake_atv . app [EOL] [EOL] async def fake_asyncio_sleep ( self , time , loop = None ) : [EOL] self . no_of_sleeps += [number] [EOL] [EOL] @ unittest_run_loop async def test_play_video ( self ) : [EOL] self . usecase . airplay_playback_idle ( ) [EOL] self . usecase . airplay_playback_playing ( ) [EOL] self . usecase . airplay_playback_idle ( ) [EOL] [EOL] await self . player . play_url ( STREAM , position = START_POSITION ) [EOL] [EOL] self . assertEqual ( self . state . last_airplay_url , STREAM ) [EOL] self . assertEqual ( self . state . last_airplay_start , START_POSITION ) [EOL] self . assertIsNotNone ( self . state . last_airplay_uuid ) [EOL] self . assertEqual ( self . no_of_sleeps , [number] ) [comment] [EOL] [EOL] @ unittest_run_loop async def test_play_video_no_permission ( self ) : [EOL] self . usecase . airplay_playback_playing_no_permission ( ) [EOL] [EOL] with self . assertRaises ( exceptions . NoCredentialsError ) : [EOL] await self . player . play_url ( STREAM , position = START_POSITION ) [EOL] [EOL] @ unittest_run_loop async def test_play_with_retries ( self ) : [EOL] self . usecase . airplay_play_failure ( [number] ) [EOL] self . usecase . airplay_playback_playing ( ) [EOL] self . usecase . airplay_playback_idle ( ) [EOL] [EOL] await self . player . play_url ( STREAM , position = START_POSITION ) [EOL] [EOL] self . assertEqual ( self . state . play_count , [number] ) [comment] [EOL] [EOL] @ unittest_run_loop async def test_play_with_too_many_retries ( self ) : [EOL] self . usecase . airplay_play_failure ( [number] ) [EOL] self . usecase . airplay_playback_playing ( ) [EOL] self . usecase . airplay_playback_idle ( ) [EOL] [EOL] with self . assertRaises ( exceptions . PlaybackError ) : [EOL] await self . player . play_url ( STREAM , position = START_POSITION ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.net.HttpSession$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0
	0
from typing import Any , Dict [EOL] import pyatv [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ipaddress [EOL] [EOL] import pytest [EOL] from unittest . mock import MagicMock [EOL] [EOL] from pyatv import conf [EOL] from pyatv . dmap import pairing , parser , tag_definitions [EOL] from pyatv . support import net [EOL] from tests import zeroconf_stub , utils [EOL] [EOL] [EOL] REMOTE_NAME = [string] [EOL] [EOL] [comment] [EOL] PIN_CODE = [number] [EOL] PAIRING_GUID = [string] [EOL] PAIRING_CODE = [string] [EOL] [EOL] [comment] [EOL] PIN_CODE2 = [number] [EOL] PAIRING_GUID2 = [string] [EOL] PAIRING_CODE2 = [string] [EOL] [EOL] [comment] [EOL] PIN_CODE3 = [number] [EOL] PAIRING_GUID3 = [string] [EOL] PAIRING_CODE3 = [string] [EOL] [EOL] [comment] [EOL] RANDOM_128_BITS = [number] [EOL] RANDOM_PAIRING_GUID = [string] [EOL] RANDOM_PAIRING_CODE = [string] [EOL] [EOL] [EOL] def pairing_url ( zeroconf , pairing_code ) : [EOL] service = zeroconf . registered_services [ [number] ] [EOL] return ( f" [string] { service . port } [string] " + f" [string] { pairing_code } [string] " ) [EOL] [EOL] [EOL] @ pytest . fixture def mock_random ( ) : [EOL] pairing . random . getrandbits = lambda x : RANDOM_128_BITS [EOL] [EOL] [EOL] @ pytest . fixture async def mock_pairing ( event_loop ) : [EOL] obj = MagicMock ( ) [EOL] [EOL] service = conf . DmapService ( None , None ) [EOL] config = conf . AppleTV ( [string] , [string] ) [EOL] config . add_service ( service ) [EOL] zeroconf = zeroconf_stub . stub ( pairing ) [EOL] [EOL] async def _start ( pin_code = PIN_CODE , pairing_guid = PAIRING_GUID , name = REMOTE_NAME ) : [EOL] options = { [string] : zeroconf } [EOL] if pairing_guid : [EOL] options [ [string] ] = pairing_guid [EOL] if name : [EOL] options [ [string] ] = name [EOL] [EOL] obj . pairing = pairing . DmapPairingHandler ( config , await net . create_session ( ) , event_loop , ** options ) [EOL] await obj . pairing . begin ( ) [EOL] obj . pairing . pin ( pin_code ) [EOL] return obj . pairing , zeroconf , service [EOL] [EOL] yield _start [EOL] await obj . pairing . finish ( ) [EOL] await obj . pairing . close ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_zeroconf_service_published ( mock_pairing ) : [EOL] _ , zeroconf , service = await mock_pairing ( ) [EOL] [EOL] assert len ( zeroconf . registered_services ) == [number] , [string] [EOL] [EOL] service = zeroconf . registered_services [ [number] ] [EOL] assert service . properties [ [string] ] == REMOTE_NAME , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_succesful_pairing ( mock_pairing ) : [EOL] pairing , zeroconf , service = await mock_pairing ( ) [EOL] [EOL] url = pairing_url ( zeroconf , PAIRING_CODE ) [EOL] data , _ = await utils . simple_get ( url ) [EOL] [EOL] await pairing . finish ( ) [EOL] [EOL] [comment] [EOL] parsed = parser . parse ( data , tag_definitions . lookup_tag ) [EOL] assert parser . first ( parsed , [string] , [string] ) == [number] [EOL] assert parser . first ( parsed , [string] , [string] ) == REMOTE_NAME [EOL] assert parser . first ( parsed , [string] , [string] ) == [string] [EOL] [EOL] assert service . credentials == PAIRING_GUID [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_successful_pairing_random_pairing_guid_generated ( mock_random , mock_pairing ) : [EOL] pairing , zeroconf , service = await mock_pairing ( pairing_guid = None ) [EOL] [EOL] url = pairing_url ( zeroconf , RANDOM_PAIRING_CODE ) [EOL] await utils . simple_get ( url ) [EOL] [EOL] await pairing . finish ( ) [EOL] [EOL] assert service . credentials == RANDOM_PAIRING_GUID [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_succesful_pairing_with_any_pin ( mock_pairing ) : [EOL] _ , zeroconf , _ = await mock_pairing ( pin_code = None ) [EOL] [EOL] url = pairing_url ( zeroconf , [string] ) [EOL] _ , status = await utils . simple_get ( url ) [EOL] [EOL] assert status == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_succesful_pairing_with_pin_leadering_zeros ( mock_pairing ) : [EOL] _ , zeroconf , _ = await mock_pairing ( pin_code = PIN_CODE3 , pairing_guid = PAIRING_GUID3 ) [EOL] [EOL] url = pairing_url ( zeroconf , PAIRING_CODE3 ) [EOL] _ , status = await utils . simple_get ( url ) [EOL] [EOL] assert status == [number] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_pair_custom_pairing_guid ( mock_pairing ) : [EOL] pairing , zeroconf , service = await mock_pairing ( pin_code = PIN_CODE2 , pairing_guid = PAIRING_GUID2 ) [EOL] [EOL] url = pairing_url ( zeroconf , PAIRING_CODE2 ) [EOL] data , _ = await utils . simple_get ( url ) [EOL] [EOL] await pairing . finish ( ) [EOL] [EOL] [comment] [EOL] parsed = parser . parse ( data , tag_definitions . lookup_tag ) [EOL] assert parser . first ( parsed , [string] , [string] ) == int ( PAIRING_GUID2 , [number] ) [EOL] [EOL] assert service . credentials == PAIRING_GUID2 [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_failed_pairing ( mock_pairing ) : [EOL] _ , zeroconf , _ = await mock_pairing ( ) [EOL] [EOL] url = pairing_url ( zeroconf , [string] ) [EOL] data , status = await utils . simple_get ( url ) [EOL] [EOL] assert status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import pyatv [EOL] import typing [EOL] [docstring] [EOL] [EOL] import unittest [EOL] import plistlib [EOL] [EOL] from pyatv import exceptions [EOL] from pyatv . dmap import tags , parser [EOL] [EOL] TEST_TAGS = { [string] : parser . DmapTag ( tags . read_uint , [string] ) , [string] : parser . DmapTag ( tags . read_uint , [string] ) , [string] : parser . DmapTag ( tags . read_uint , [string] ) , [string] : parser . DmapTag ( tags . read_uint , [string] ) , [string] : parser . DmapTag ( tags . read_bool , [string] ) , [string] : parser . DmapTag ( tags . read_bool , [string] ) , [string] : parser . DmapTag ( tags . read_str , [string] ) , [string] : parser . DmapTag ( tags . read_str , [string] ) , [string] : parser . DmapTag ( [string] , [string] ) , [string] : parser . DmapTag ( [string] , [string] ) , [string] : parser . DmapTag ( tags . read_ignore , [string] ) , [string] : parser . DmapTag ( tags . read_bplist , [string] ) , [string] : parser . DmapTag ( tags . read_bytes , [string] ) , } [EOL] [EOL] [EOL] def lookup_tag ( name ) : [EOL] return TEST_TAGS [ name ] [EOL] [EOL] [EOL] class ParserTest ( unittest . TestCase ) : [EOL] def test_parse_uint_of_various_lengths ( self ) : [EOL] in_data = ( tags . uint8_tag ( [string] , [number] ) + tags . uint16_tag ( [string] , [number] ) + tags . uint32_tag ( [string] , [number] ) + tags . uint64_tag ( [string] , [number] ) ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] self . assertEqual ( [number] , parser . first ( parsed , [string] ) ) [EOL] self . assertEqual ( [number] , parser . first ( parsed , [string] ) ) [EOL] self . assertEqual ( [number] , parser . first ( parsed , [string] ) ) [EOL] self . assertEqual ( [number] , parser . first ( parsed , [string] ) ) [EOL] [EOL] def test_parse_bool ( self ) : [EOL] in_data = tags . bool_tag ( [string] , True ) + tags . bool_tag ( [string] , False ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] self . assertTrue ( parser . first ( parsed , [string] ) ) [EOL] self . assertFalse ( parser . first ( parsed , [string] ) ) [EOL] [EOL] def test_parse_strings ( self ) : [EOL] in_data = tags . string_tag ( [string] , [string] ) + tags . string_tag ( [string] , [string] ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] self . assertEqual ( [string] , parser . first ( parsed , [string] ) ) [EOL] self . assertEqual ( [string] , parser . first ( parsed , [string] ) ) [EOL] [EOL] def test_parse_binary_plist ( self ) : [EOL] data = { [string] : [string] } [EOL] in_data = tags . raw_tag ( [string] , plistlib . dumps ( data , fmt = plistlib . FMT_BINARY ) ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] self . assertEqual ( data , parser . first ( parsed , [string] ) ) [EOL] [EOL] def test_parse_bytes ( self ) : [EOL] in_data = tags . raw_tag ( [string] , [string] ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] self . assertEqual ( [string] , parser . first ( parsed , [string] ) ) [EOL] [EOL] def test_parse_value_in_container ( self ) : [EOL] in_data = tags . container_tag ( [string] , tags . uint8_tag ( [string] , [number] ) + tags . uint16_tag ( [string] , [number] ) ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , len ( parsed ) ) [EOL] inner = parser . first ( parsed , [string] ) [EOL] self . assertEqual ( [number] , len ( inner ) ) [EOL] self . assertEqual ( [number] , parser . first ( inner , [string] ) ) [EOL] self . assertEqual ( [number] , parser . first ( inner , [string] ) ) [EOL] [EOL] def test_extract_simplified_container ( self ) : [EOL] elem = tags . uint8_tag ( [string] , [number] ) [EOL] inner = tags . container_tag ( [string] , elem ) [EOL] in_data = tags . container_tag ( [string] , inner ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( [number] , parser . first ( parsed , [string] , [string] , [string] ) ) [EOL] [EOL] def test_ignore_value ( self ) : [EOL] elem = tags . uint8_tag ( [string] , [number] ) [EOL] parsed = parser . parse ( elem , lookup_tag ) [EOL] self . assertEqual ( parser . first ( parsed , [string] ) , None ) [EOL] [EOL] def test_simple_pprint ( self ) : [EOL] elem = tags . uint8_tag ( [string] , [number] ) [EOL] inner = tags . container_tag ( [string] , elem ) [EOL] in_data = tags . container_tag ( [string] , inner ) [EOL] parsed = parser . parse ( in_data , lookup_tag ) [EOL] self . assertEqual ( parser . pprint ( parsed , lookup_tag ) , [string] + [string] + [string] , ) [EOL] [EOL] def test_print_invalid_input_raises_exception ( self ) : [EOL] with self . assertRaises ( exceptions . InvalidDmapDataError ) : [EOL] parser . pprint ( [string] , lookup_tag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pyatv.dmap.parser.DmapTag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pyatv.dmap.parser.DmapTag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pyatv [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import ipaddress [EOL] [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] [EOL] from pyatv import connect , exceptions [EOL] from pyatv . conf import AirPlayService , DmapService , AppleTV [EOL] from pyatv . const import ( Protocol , ShuffleState , RepeatState , PowerState , OperatingSystem , FeatureState , FeatureName , InputAction , ) [EOL] from pyatv . dmap import pairing [EOL] from tests . fake_device import FakeAppleTV [EOL] from tests . fake_device . airplay import DEVICE_CREDENTIALS [EOL] from tests import zeroconf_stub , common_functional_tests [EOL] from tests . common_functional_tests import DummyDeviceListener [EOL] from tests . utils import until [EOL] [EOL] HSGID = [string] [EOL] PAIRING_GUID = [string] [EOL] SESSION_ID = [number] [EOL] REMOTE_NAME = [string] [EOL] PIN_CODE = [number] [EOL] [EOL] ARTWORK_BYTES = [string] [EOL] ARTWORK_MIMETYPE = [string] [EOL] AIRPLAY_STREAM = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] PAIRINGCODE = [string] [EOL] [EOL] SKIP_TIME = [number] [EOL] [EOL] [EOL] class DummyPushListener : [EOL] @ staticmethod def playstatus_update ( updater , playstatus ) : [EOL] updater . stop ( ) [EOL] [EOL] @ staticmethod def playstatus_error ( updater , exception ) : [EOL] pass [EOL] [EOL] [EOL] class DMAPFunctionalTest ( common_functional_tests . CommonFunctionalTests ) : [EOL] async def setUpAsync ( self ) : [EOL] await super ( ) . setUpAsync ( ) [EOL] self . atv = await self . get_connected_device ( HSGID ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . atv . close ( ) [EOL] super ( ) . tearDown ( ) [EOL] [EOL] async def get_application ( self , loop = None ) : [EOL] self . fake_atv = FakeAppleTV ( self . loop ) [EOL] self . state , self . usecase = self . fake_atv . add_service ( Protocol . DMAP , hsgid = HSGID , pairing_guid = PAIRING_GUID , session_id = SESSION_ID ) [EOL] self . airplay_state , self . airplay_usecase = self . fake_atv . add_service ( Protocol . AirPlay ) [EOL] return self . fake_atv . app [EOL] [EOL] async def get_connected_device ( self , hsgid ) : [EOL] self . dmap_service = DmapService ( [string] , hsgid , port = self . server . port ) [EOL] self . airplay_service = AirPlayService ( [string] , self . server . port , DEVICE_CREDENTIALS ) [EOL] self . conf = AppleTV ( ipaddress . IPv4Address ( [string] ) , [string] ) [EOL] self . conf . add_service ( self . dmap_service ) [EOL] self . conf . add_service ( self . airplay_service ) [EOL] return await connect ( self . conf , self . loop ) [EOL] [EOL] @ unittest_run_loop async def test_app_not_supported ( self ) : [EOL] with self . assertRaises ( exceptions . NotSupportedError ) : [EOL] self . atv . metadata . app [EOL] [EOL] @ unittest_run_loop async def test_connect_failed ( self ) : [EOL] [comment] [EOL] self . usecase . make_login_fail ( ) [EOL] self . usecase . make_login_fail ( ) [EOL] [EOL] with self . assertRaises ( exceptions . AuthenticationError ) : [EOL] await self . atv . connect ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ unittest_run_loop async def test_relogin_if_session_expired ( self ) : [EOL] await self . atv . connect ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . usecase . example_video ( ) [EOL] self . usecase . force_relogin ( [number] ) [EOL] self . usecase . artwork_no_permission ( ) [EOL] self . usecase . change_artwork ( ARTWORK_BYTES , ARTWORK_MIMETYPE ) [EOL] [EOL] artwork = await self . atv . metadata . artwork ( ) [EOL] self . assertEqual ( artwork . bytes , ARTWORK_BYTES ) [EOL] [EOL] @ unittest_run_loop async def test_metadata_artwork_size ( self ) : [EOL] self . usecase . example_video ( ) [EOL] self . usecase . change_artwork ( ARTWORK_BYTES , ARTWORK_MIMETYPE ) [EOL] await self . playing ( title = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] artwork = await self . atv . metadata . artwork ( width = [number] , height = [number] ) [EOL] self . assertIsNotNone ( artwork ) [EOL] self . assertEqual ( artwork . width , - [number] ) [EOL] self . assertEqual ( artwork . height , - [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . state . last_artwork_width , [number] ) [EOL] self . assertEqual ( self . state . last_artwork_height , [number] ) [EOL] [EOL] @ unittest_run_loop async def test_login_with_pairing_guid_succeed ( self ) : [EOL] self . atv . close ( ) [EOL] self . atv = await self . get_connected_device ( PAIRING_GUID ) [EOL] await self . atv . connect ( ) [EOL] [EOL] @ unittest_run_loop async def test_connection_lost ( self ) : [EOL] self . usecase . server_closes_connection ( ) [EOL] [EOL] device_listener = DummyDeviceListener ( ) [EOL] push_listener = DummyPushListener ( ) [EOL] self . atv . listener = device_listener [EOL] self . atv . push_updater . listener = push_listener [EOL] self . atv . push_updater . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] await asyncio . wait_for ( device_listener . lost_sem . acquire ( ) , timeout = [number] ) [EOL] [EOL] @ unittest_run_loop async def test_button_unsupported_raises ( self ) : [EOL] buttons = [ [string] , [string] , [string] ] [EOL] for button in buttons : [EOL] with self . assertRaises ( exceptions . NotSupportedError ) : [EOL] await getattr ( self . atv . remote_control , button ) ( ) [EOL] [EOL] @ unittest_run_loop async def test_button_top_menu ( self ) : [EOL] await self . atv . remote_control . top_menu ( ) [EOL] await self . waitForButtonPress ( [string] , InputAction . SingleTap ) [EOL] [EOL] @ unittest_run_loop async def test_button_play_pause ( self ) : [EOL] await self . atv . remote_control . play_pause ( ) [EOL] await until ( lambda : self . state . last_button_pressed == [string] ) [EOL] [EOL] @ unittest_run_loop async def test_shuffle_state_albums ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . usecase . example_video ( shuffle = ShuffleState . Albums ) [EOL] playing = await self . playing ( shuffle = ShuffleState . Songs ) [EOL] self . assertEqual ( playing . shuffle , ShuffleState . Songs ) [EOL] [EOL] @ unittest_run_loop async def test_set_shuffle_albums ( self ) : [EOL] self . usecase . example_video ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] await self . atv . remote_control . set_shuffle ( ShuffleState . Albums ) [EOL] playing = await self . playing ( shuffle = ShuffleState . Songs ) [EOL] self . assertEqual ( playing . shuffle , ShuffleState . Songs ) [EOL] [EOL] @ unittest_run_loop async def test_play_url_no_service ( self ) : [EOL] conf = AppleTV ( [string] , [string] ) [EOL] conf . add_service ( self . dmap_service ) [EOL] [EOL] atv = await connect ( conf , self . loop ) [EOL] [EOL] with self . assertRaises ( exceptions . NotSupportedError ) : [EOL] await atv . stream . play_url ( [string] ) [EOL] [EOL] atv . close ( ) [EOL] [EOL] @ unittest_run_loop async def test_unsupported_power_state ( self ) : [EOL] [EOL] [comment] [EOL] self . assertEqual ( self . atv . power . power_state , PowerState . Unknown ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( exceptions . NotSupportedError ) : [EOL] await self . atv . power . turn_on ( ) [EOL] [EOL] [comment] [EOL] with self . assertRaises ( exceptions . NotSupportedError ) : [EOL] await self . atv . power . turn_off ( ) [EOL] [EOL] @ unittest_run_loop async def test_basic_device_info ( self ) : [EOL] self . assertEqual ( self . atv . device_info . operating_system , OperatingSystem . Legacy ) [EOL] [EOL] @ unittest_run_loop async def test_always_available_features ( self ) : [EOL] self . assertFeatures ( FeatureState . Available , FeatureName . Down , FeatureName . Left , FeatureName . Menu , FeatureName . Right , FeatureName . Select , FeatureName . TopMenu , FeatureName . Up , ) [EOL] [EOL] @ unittest_run_loop async def test_unsupported_features ( self ) : [EOL] self . assertFeatures ( FeatureState . Unsupported , FeatureName . Home , FeatureName . HomeHold , FeatureName . Suspend , FeatureName . WakeUp , FeatureName . PowerState , FeatureName . TurnOn , FeatureName . TurnOff , FeatureName . App , ) [EOL] [EOL] @ unittest_run_loop async def test_always_unknown_features ( self ) : [EOL] self . assertFeatures ( FeatureState . Unknown , FeatureName . Artwork , FeatureName . Next , FeatureName . Pause , FeatureName . Play , FeatureName . PlayPause , FeatureName . Previous , FeatureName . SetPosition , FeatureName . SetRepeat , FeatureName . SetShuffle , FeatureName . Stop , FeatureName . SkipForward , FeatureName . SkipBackward , ) [EOL] [EOL] @ unittest_run_loop async def test_features_shuffle_repeat ( self ) : [EOL] self . usecase . nothing_playing ( ) [EOL] await self . playing ( ) [EOL] [EOL] self . assertFeatures ( FeatureState . Unavailable , FeatureName . Shuffle , FeatureName . Repeat , ) [EOL] [EOL] self . usecase . example_music ( shuffle = ShuffleState . Albums , repeat = RepeatState . Track ) [EOL] await self . playing ( title = [string] ) [EOL] [EOL] self . assertFeatures ( FeatureState . Available , FeatureName . Shuffle , FeatureName . Repeat , ) [EOL] [EOL] @ unittest_run_loop async def test_skip_forward_backward ( self ) : [EOL] self . usecase . example_video ( ) [EOL] [EOL] prev_position = ( await self . playing ( title = [string] ) ) . position [EOL] [EOL] await self . atv . remote_control . skip_forward ( ) [EOL] metadata = await self . playing ( ) [EOL] self . assertEqual ( metadata . position , prev_position + SKIP_TIME ) [EOL] prev_position = metadata . position [EOL] [EOL] await self . atv . remote_control . skip_backward ( ) [EOL] metadata = await self . playing ( ) [EOL] self . assertEqual ( metadata . position , prev_position - SKIP_TIME ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.common_functional_tests.DummyDeviceListener$ 0 0 0 0 0 $tests.dmap.test_dmap_functional.DummyPushListener$ 0 0 0 0 0 0 0 0 0 0 0 $tests.common_functional_tests.DummyDeviceListener$ 0 0 0 0 0 0 0 0 0 $tests.dmap.test_dmap_functional.DummyPushListener$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.common_functional_tests.DummyDeviceListener$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.conf.AppleTV$ 0 0 0 0 0 0 0 0 $pyatv.conf.AppleTV$ 0 0 0 0 0 0 0 0 0 $pyatv.interface.AppleTV$ 0 0 0 0 $pyatv.conf.AppleTV$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.interface.AppleTV$ 0 0 0 0 0 0 0 0 0 $pyatv.interface.AppleTV$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0
[docstring] [EOL] [EOL] import unittest [EOL] [EOL] from pyatv import exceptions [EOL] from pyatv . dmap . daap import media_kind , playstate , ms_to_s [EOL] from pyatv . const import MediaType , DeviceState [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] MEDIA_KIND_UNKNOWN = [number] [EOL] MEDIA_KIND_UNKNOWN2 = [number] [comment] [EOL] MEDIA_KIND_SONG = [number] [EOL] MEDIA_KIND_MOVIE = [number] [EOL] MEDIA_KIND_PODCAST = [number] [EOL] MEDIA_KIND_AUDIOBOOK = [number] [EOL] MEDIA_KIND_PDFBOOKLET = [number] [EOL] MEDIA_KIND_MUSICVIDEO = [number] [EOL] MEDIA_KIND_TVSHOW = [number] [EOL] MEDIA_KIND_INTERACTIVEBOOKLET = [number] [EOL] MEDIA_KIND_COACHEDAUDIO = [number] [EOL] MEDIA_KIND_VIDEOPASS = [number] [EOL] MEDIA_KIND_HOMEVIDEO = [number] [EOL] MEDIA_KIND_FUTUREVIDEO = [number] [EOL] MEDIA_KIND_RINGTONE = [number] [EOL] MEDIA_KIND_DIGITALBOOKLET = [number] [EOL] MEDIA_KIND_IOSAPPLICATION = [number] [EOL] MEDIA_KIND_VOICEMEMO = [number] [EOL] MEDIA_KIND_ITUNESU = [number] [EOL] MEDIA_KIND_BOOK = [number] [EOL] MEDIA_KIND_PDFBOOK = [number] [EOL] MEDIA_KIND_ALERTTONE = [number] [EOL] MEDIA_KIND_MUSICVIDEO2 = [number] [EOL] MEDIA_KIND_PODCAST2 = [number] [EOL] MEDIA_KIND_TVSHOW2 = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] PLAY_STATE_IDLE = [number] [EOL] PLAY_STATE_LOADING = [number] [comment] [EOL] PLAY_STATE_STOPPED = [number] [EOL] PLAY_STATE_PAUSED = [number] [EOL] PLAY_STATE_PLAYING = [number] [EOL] PLAY_STATE_FORWARD = [number] [EOL] PLAY_STATE_BACKWARD = [number] [EOL] [EOL] [EOL] class ConvertTest ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [EOL] def test_unknown_media_kind ( self ) : [EOL] self . assertEqual ( MediaType . Unknown , media_kind ( MEDIA_KIND_UNKNOWN ) ) [EOL] self . assertEqual ( MediaType . Unknown , media_kind ( MEDIA_KIND_UNKNOWN2 ) ) [EOL] [EOL] def test_video_media_kinds ( self ) : [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_MOVIE ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_MUSICVIDEO ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_MUSICVIDEO2 ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_VIDEOPASS ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_HOMEVIDEO ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_FUTUREVIDEO ) ) [EOL] self . assertEqual ( MediaType . Video , media_kind ( MEDIA_KIND_ITUNESU ) ) [EOL] [EOL] def test_music_media_kinds ( self ) : [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_SONG ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_PODCAST ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_PODCAST2 ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_COACHEDAUDIO ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_RINGTONE ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_VOICEMEMO ) ) [EOL] self . assertEqual ( MediaType . Music , media_kind ( MEDIA_KIND_ALERTTONE ) ) [EOL] [EOL] def test_tv_kinds ( self ) : [EOL] self . assertEqual ( MediaType . TV , media_kind ( MEDIA_KIND_TVSHOW ) ) [EOL] self . assertEqual ( MediaType . TV , media_kind ( MEDIA_KIND_TVSHOW2 ) ) [EOL] [EOL] def test_unknown_media_kind_throws ( self ) : [EOL] with self . assertRaises ( exceptions . UnknownMediaKindError ) : [EOL] media_kind ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_device_state_no_media ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( DeviceState . Idle , playstate ( None ) ) [EOL] [EOL] def test_regular_playstates ( self ) : [EOL] self . assertEqual ( DeviceState . Idle , playstate ( PLAY_STATE_IDLE ) ) [EOL] self . assertEqual ( DeviceState . Loading , playstate ( PLAY_STATE_LOADING ) ) [EOL] self . assertEqual ( DeviceState . Stopped , playstate ( PLAY_STATE_STOPPED ) ) [EOL] self . assertEqual ( DeviceState . Paused , playstate ( PLAY_STATE_PAUSED ) ) [EOL] self . assertEqual ( DeviceState . Playing , playstate ( PLAY_STATE_PLAYING ) ) [EOL] self . assertEqual ( DeviceState . Seeking , playstate ( PLAY_STATE_FORWARD ) ) [EOL] self . assertEqual ( DeviceState . Seeking , playstate ( PLAY_STATE_BACKWARD ) ) [EOL] [EOL] def test_unknown_playstate_throws ( self ) : [EOL] with self . assertRaises ( exceptions . UnknownPlayStateError ) : [EOL] playstate ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_no_time_returns_zero ( self ) : [EOL] self . assertEqual ( [number] , ms_to_s ( None ) ) [EOL] [EOL] def test_time_in_seconds ( self ) : [EOL] self . assertEqual ( [number] , ms_to_s ( [number] ) ) [EOL] self . assertEqual ( [number] , ms_to_s ( [number] ) ) [EOL] self . assertEqual ( [number] , ms_to_s ( [number] ) ) [EOL] [EOL] def test_invalid_time ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . assertEqual ( [number] , ms_to_s ( [number] ** [number] - [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import _importlib_modulespec [EOL] [docstring] [EOL] [EOL] import sys [EOL] from importlib import import_module [EOL] [EOL] from contextlib import contextmanager [EOL] from io import StringIO [EOL] [EOL] from unittest . mock import patch [EOL] [EOL] from aiohttp . test_utils import AioHTTPTestCase [EOL] [EOL] import pyatv [EOL] from pyatv . const import Protocol [EOL] from tests import fake_udns [EOL] from tests . utils import stub_sleep , unstub_sleep , faketime [EOL] from tests . fake_device import FakeAppleTV [EOL] [EOL] [EOL] IP_1 = [string] [EOL] IP_2 = [string] [EOL] DMAP_ID = [string] [EOL] MRP_ID = [string] [EOL] AIRPLAY_ID = [string] [EOL] [EOL] [EOL] @ contextmanager def capture_output ( argv , inputs ) : [EOL] new_out , new_err , new_in = StringIO ( ) , StringIO ( ) , StringIO ( inputs ) [EOL] old_out , old_err , old_in = sys . stdout , sys . stderr , sys . stdin [EOL] old_argv = sys . argv [EOL] try : [EOL] sys . stdout , sys . stderr , sys . stdin = new_out , new_err , new_in [EOL] sys . argv = argv [EOL] yield sys . stdout , sys . stderr [EOL] finally : [EOL] sys . stdout , sys . stderr , sys . stdin = old_out , old_err , old_in [EOL] sys . argv = old_argv [EOL] [EOL] [EOL] class ScriptTest ( AioHTTPTestCase ) : [EOL] async def setUpAsync ( self ) : [EOL] await AioHTTPTestCase . setUpAsync ( self ) [EOL] stub_sleep ( ) [EOL] self . setup_environment ( ) [EOL] await self . fake_udns . start ( ) [EOL] self . stdout = None [EOL] self . stderr = None [EOL] self . retcode = None [EOL] self . inputs = [ ] [EOL] [EOL] def tearDown ( self ) : [EOL] unstub_sleep ( ) [EOL] AioHTTPTestCase . tearDown ( self ) [EOL] [EOL] def setup_environment ( self ) : [EOL] airplay_port = self . server . port [EOL] [EOL] self . fake_udns . add_service ( fake_udns . homesharing_service ( DMAP_ID , [string] , [string] , address = IP_1 ) ) [EOL] [EOL] self . fake_udns . add_service ( fake_udns . mrp_service ( [string] , [string] , MRP_ID , address = IP_2 , port = self . fake_atv . get_port ( Protocol . MRP ) , ) ) [EOL] self . fake_udns . add_service ( fake_udns . airplay_service ( [string] , AIRPLAY_ID , address = IP_2 , port = airplay_port ) ) [EOL] [EOL] self . airplay_usecase . airplay_playback_playing ( ) [EOL] self . airplay_usecase . airplay_playback_idle ( ) [EOL] [EOL] async def get_application ( self , loop = None ) : [EOL] self . fake_udns = fake_udns . FakeUdns ( self . loop ) [EOL] self . fake_udns . ip_filter = IP_2 [EOL] self . fake_atv = FakeAppleTV ( self . loop ) [EOL] self . state , self . usecase = self . fake_atv . add_service ( Protocol . MRP ) [EOL] self . airplay_state , self . airplay_usecase = self . fake_atv . add_service ( Protocol . AirPlay ) [EOL] return self . fake_atv . app [EOL] [EOL] def user_input ( self , text ) : [EOL] self . inputs . append ( text ) [EOL] [EOL] def has_output ( self , * strings ) : [EOL] for string in strings : [EOL] self . assertIn ( string , self . stdout ) [EOL] [EOL] def has_error ( self , * strings ) : [EOL] for string in strings : [EOL] self . assertIn ( string , self . stderr ) [EOL] [EOL] def exit ( self , code ) : [EOL] self . assertEqual ( self . retcode , code ) [EOL] [EOL] async def run_script ( self , script , * args ) : [EOL] argv = [ script ] + list ( args ) [EOL] inputs = [string] . join ( self . inputs ) + [string] [EOL] with capture_output ( argv , inputs ) as ( out , err ) : [EOL] udns_port = str ( self . fake_udns . port ) [EOL] with patch . dict ( [string] , { [string] : udns_port } ) : [EOL] with fake_udns . stub_multicast ( self . fake_udns , self . loop ) : [EOL] with faketime ( [string] , [number] ) : [EOL] [comment] [EOL] with patch ( [string] ) as mock_knock : [EOL] [EOL] async def _no_action ( * args ) : [EOL] pass [EOL] [EOL] mock_knock . side_effect = _no_action [EOL] [EOL] module = import_module ( f" [string] { script }" ) [EOL] self . retcode = await module . appstart ( self . loop ) [EOL] self . stdout = out . getvalue ( ) [EOL] self . stderr = err . getvalue ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import logging [EOL] [EOL] from deepdiff import DeepDiff [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] [EOL] from pyatv . const import Protocol [EOL] from tests . scripts . script_env import IP_1 , IP_2 , DMAP_ID , MRP_ID , ScriptTest [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] HASH = [string] [EOL] [EOL] [EOL] class AtvscriptTest ( ScriptTest ) : [EOL] async def atvscript ( self , * args ) : [EOL] return await self . run_script ( [string] , * args ) [EOL] [EOL] def assertJsonOutput ( self , expected ) : [EOL] _LOGGER . debug ( [string] , self . stdout ) [EOL] _LOGGER . debug ( [string] , expected ) [EOL] [EOL] actual = json . loads ( self . stdout ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . assertIn ( [string] , actual ) [EOL] del actual [ [string] ] [EOL] [EOL] self . assertEqual ( DeepDiff ( actual , expected , ignore_order = True ) , { } ) [EOL] [EOL] @ unittest_run_loop async def test_scan_devices ( self ) : [EOL] await self . atvscript ( [string] ) [EOL] self . assertJsonOutput ( { [string] : [string] , [string] : [ { [string] : [string] , [string] : IP_1 , [string] : DMAP_ID , [string] : [ { [string] : [string] , [string] : [number] } ] , } , { [string] : [string] , [string] : IP_2 , [string] : MRP_ID , [string] : [ { [string] : [string] , [string] : self . fake_atv . get_port ( Protocol . MRP ) , } , { [string] : [string] , [string] : self . server . port } , ] , } , ] , } , ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_mrp_idle ( self ) : [EOL] await self . atvscript ( [string] , MRP_ID , [string] ) [EOL] self . assertJsonOutput ( { [string] : [string] , [string] : HASH , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : None , } ) [EOL] self . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from aiohttp . test_utils import unittest_run_loop [EOL] [EOL] from pyatv . const import Protocol [EOL] from pyatv . mrp . server_auth import CLIENT_CREDENTIALS [EOL] from tests . fake_device . airplay import DEVICE_PIN , DEVICE_CREDENTIALS [EOL] from tests . scripts . script_env import IP_1 , IP_2 , DMAP_ID , MRP_ID , AIRPLAY_ID , ScriptTest [EOL] [EOL] [EOL] class AtvremoteTest ( ScriptTest ) : [EOL] async def atvremote ( self , * args ) : [EOL] return await self . run_script ( [string] , * args ) [EOL] [EOL] @ unittest_run_loop async def test_scan_devices ( self ) : [EOL] await self . atvremote ( [string] ) [EOL] self . has_output ( [string] , [string] , IP_1 , IP_2 , MRP_ID , AIRPLAY_ID , DMAP_ID ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_scan_hosts ( self ) : [EOL] await self . atvremote ( [string] , [string] , [string] ) [EOL] self . has_output ( [string] , IP_2 , MRP_ID , AIRPLAY_ID ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_pair_airplay ( self ) : [EOL] self . user_input ( str ( DEVICE_PIN ) ) [EOL] await self . atvremote ( [string] , IP_2 , [string] , [string] , [string] , MRP_ID , [string] , DEVICE_CREDENTIALS , [string] , ) [EOL] self . has_output ( [string] , [string] , DEVICE_CREDENTIALS ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_airplay_play_url ( self ) : [EOL] self . user_input ( str ( DEVICE_PIN ) ) [EOL] await self . atvremote ( [string] , MRP_ID , [string] , DEVICE_CREDENTIALS , [string] , ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_mrp_idle ( self ) : [EOL] await self . atvremote ( [string] , MRP_ID , [string] ) [EOL] self . has_output ( [string] , [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_device_info ( self ) : [EOL] await self . atvremote ( [string] , MRP_ID , [string] ) [EOL] self . has_output ( [string] , AIRPLAY_ID ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_mrp_auth ( self ) : [EOL] await self . atvremote ( [string] , MRP_ID , [string] , CLIENT_CREDENTIALS , [string] ) [EOL] self . assertTrue ( self . state . has_authenticated ) [EOL] self . has_output ( [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_mrp_auth_error ( self ) : [EOL] await self . atvremote ( [string] , MRP_ID , [string] , [string] , [string] ) [EOL] self . assertFalse ( self . state . has_authenticated ) [EOL] self . has_error ( [string] ) [EOL] self . exit ( [number] ) [EOL] [EOL] @ unittest_run_loop async def test_manual_connect ( self ) : [EOL] self . user_input ( str ( DEVICE_PIN ) ) [EOL] await self . atvremote ( [string] , IP_2 , [string] , [string] , [string] , str ( self . fake_atv . get_port ( Protocol . MRP ) ) , [string] , MRP_ID , [string] , [string] , ) [EOL] self . has_output ( [string] , [string] ) [EOL] self . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional [EOL] import pyatv [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import struct [EOL] from ipaddress import IPv4Address [EOL] from typing import Optional , Dict [EOL] from pyatv . support import mdns [EOL] [EOL] DEFAULT_QCLASS = [number] [EOL] DEFAULT_TTL = [number] [EOL] [EOL] [EOL] def answer ( qname , full_name ) : [EOL] return mdns . DnsResource ( qname , mdns . QTYPE_PTR , DEFAULT_QCLASS , DEFAULT_TTL , [number] , full_name ) [EOL] [EOL] [EOL] def resource ( qname , qtype , rd ) : [EOL] return mdns . DnsResource ( qname , qtype , DEFAULT_QCLASS , DEFAULT_TTL , len ( rd ) , rd ) [EOL] [EOL] [EOL] def properties ( properties ) : [EOL] rd = [string] [EOL] for k , v in properties . items ( ) : [EOL] encoded = k + [string] + v [EOL] rd += bytes ( [ len ( encoded ) ] ) + encoded [EOL] return rd [EOL] [EOL] [EOL] def get_qtype ( messages , qtype ) : [EOL] for message in messages : [EOL] if message . qtype == qtype : [EOL] return message [EOL] return None [EOL] [EOL] [EOL] def add_service ( message , service_type , service_name , address , port , properties , ) : [EOL] if service_name is None : [EOL] return message [EOL] [EOL] if address : [EOL] message . resources . append ( resource ( service_name + [string] , mdns . QTYPE_A , address ) ) [EOL] [EOL] [comment] [EOL] if service_type is None : [EOL] return message [EOL] [EOL] message . answers . append ( answer ( service_type , service_name + [string] + service_type ) ) [EOL] [EOL] message . resources . append ( resource ( service_name + [string] + service_type , mdns . QTYPE_SRV , { [string] : [number] , [string] : [number] , [string] : port , [string] : service_name + [string] , } , ) ) [EOL] [EOL] if properties : [EOL] message . resources . append ( resource ( service_name + [string] + service_type , mdns . QTYPE_TXT , { k . encode ( [string] ) : v . encode ( [string] ) for k , v in properties . items ( ) } , ) ) [EOL] [EOL] return message [EOL] [EOL] [EOL] def assert_service ( message , service_type , service_name , address , port , properties , ) : [EOL] assert message . type == service_type [EOL] assert message . name == service_name [EOL] assert message . address == ( IPv4Address ( address ) if address else None ) [EOL] assert message . port == port [EOL] assert message . properties == properties [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pyatv.support.mdns.DnsResource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] from pyatv . const import DeviceModel [EOL] from pyatv . support . device_info import lookup_model , lookup_internal_name , lookup_version [EOL] [EOL] [EOL] def test_lookup_existing_model ( ) : [EOL] assert lookup_model ( [string] ) == DeviceModel . Gen4K [EOL] [EOL] [EOL] def test_lookup_missing_model ( ) : [EOL] assert lookup_model ( [string] ) == DeviceModel . Unknown [EOL] [EOL] [EOL] def test_lookup_existing_internal_name ( ) : [EOL] assert lookup_internal_name ( [string] ) == DeviceModel . Gen4K [EOL] [EOL] [EOL] def test_lookup_missing_internal_name ( ) : [EOL] assert lookup_internal_name ( [string] ) == DeviceModel . Unknown [EOL] [EOL] [EOL] def test_lookup_existing_version ( ) : [EOL] assert lookup_version ( [string] ) == [string] [EOL] [EOL] [EOL] def test_lookup_bad_version ( ) : [EOL] assert not lookup_version ( None ) [EOL] assert not lookup_version ( [string] ) [EOL] [EOL] [EOL] def test_lookup_guess_major_version ( ) : [EOL] assert lookup_version ( [string] ) == [string] [EOL] assert lookup_version ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pyatv [EOL] [docstring] [EOL] [EOL] import unittest [EOL] [EOL] from pyatv . support . cache import Cache [EOL] [EOL] ID1 = [string] [EOL] ID2 = [string] [EOL] ID3 = [string] [EOL] DATA1 = [number] [EOL] DATA2 = [number] [EOL] DATA3 = [number] [EOL] [EOL] [EOL] class CacheTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . cache = Cache ( limit = [number] ) [EOL] [EOL] def test_cache_is_empty ( self ) : [EOL] self . assertTrue ( self . cache . empty ( ) ) [EOL] [EOL] def test_put_get_item ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . assertEqual ( self . cache . get ( ID1 ) , DATA1 ) [EOL] [EOL] def test_put_get_multiple ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . cache . put ( ID2 , DATA2 ) [EOL] [EOL] self . assertEqual ( self . cache . get ( ID1 ) , DATA1 ) [EOL] self . assertEqual ( self . cache . get ( ID2 ) , DATA2 ) [EOL] [EOL] def test_cache_not_empty ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . assertFalse ( self . cache . empty ( ) ) [EOL] [EOL] def test_cache_has_item ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] [EOL] self . assertTrue ( ID1 in self . cache ) [EOL] self . assertFalse ( ID2 in self . cache ) [EOL] [EOL] def test_cache_size ( self ) : [EOL] self . assertEqual ( len ( self . cache ) , [number] ) [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . assertEqual ( len ( self . cache ) , [number] ) [EOL] [EOL] def test_put_same_identifier_replaces_data ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . cache . put ( ID1 , DATA2 ) [EOL] self . assertEqual ( self . cache . get ( ID1 ) , DATA2 ) [EOL] self . assertEqual ( len ( self . cache ) , [number] ) [EOL] [EOL] def test_put_removes_oldest ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . cache . put ( ID2 , DATA2 ) [EOL] self . cache . put ( ID3 , DATA3 ) [EOL] [EOL] self . assertEqual ( len ( self . cache ) , [number] ) [EOL] self . assertNotIn ( ID1 , self . cache ) [EOL] self . assertIn ( ID2 , self . cache ) [EOL] self . assertIn ( ID3 , self . cache ) [EOL] [EOL] def test_get_makes_data_newer ( self ) : [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . cache . put ( ID2 , DATA2 ) [EOL] self . cache . get ( ID1 ) [EOL] self . cache . put ( ID3 , DATA3 ) [EOL] [EOL] self . assertEqual ( len ( self . cache ) , [number] ) [EOL] self . assertIn ( ID1 , self . cache ) [EOL] self . assertNotIn ( ID2 , self . cache ) [EOL] self . assertIn ( ID3 , self . cache ) [EOL] [EOL] def test_get_latest_identifier ( self ) : [EOL] self . assertEqual ( self . cache . latest ( ) , None ) [EOL] [EOL] self . cache . put ( ID1 , DATA1 ) [EOL] self . assertEqual ( self . cache . latest ( ) , ID1 ) [EOL] [EOL] self . cache . put ( ID2 , DATA2 ) [EOL] self . assertEqual ( self . cache . latest ( ) , ID2 ) [EOL] [EOL] self . cache . get ( ID1 ) [EOL] self . assertEqual ( self . cache . latest ( ) , ID1 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.cache.Cache$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Optional , List [EOL] import pyatv [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] from pyatv . support . mdns import Response , Service [EOL] from pyatv . support . scan import ( HOMESHARING_SERVICE , DEVICE_SERVICE , MEDIAREMOTE_SERVICE , AIRPLAY_SERVICE , get_unique_identifiers , ) [EOL] [EOL] [EOL] HS = Service ( HOMESHARING_SERVICE , [string] , None , [number] , { [string] : [string] } ) [EOL] DEVICE = Service ( DEVICE_SERVICE , [string] , None , [number] , { } ) [EOL] MRP = Service ( MEDIAREMOTE_SERVICE , [string] , None , [number] , { [string] : [string] } ) [EOL] AIRPLAY = Service ( AIRPLAY_SERVICE , [string] , None , [number] , { [string] : [string] } ) [EOL] [EOL] [EOL] @ pytest . fixture def response ( ) : [EOL] yield Response ( [ ] , False , None ) [EOL] [EOL] [EOL] def test_unique_identifier_empty ( response ) : [EOL] assert len ( list ( get_unique_identifiers ( response ) ) ) == [number] [EOL] [EOL] [EOL] def test_unique_identifier_home_sharing ( response ) : [EOL] response . services . append ( HS ) [EOL] [EOL] identifiers = list ( get_unique_identifiers ( response ) ) [EOL] assert len ( identifiers ) == [number] [EOL] assert [string] in identifiers [EOL] [EOL] [EOL] def test_unique_identifier_device ( response ) : [EOL] response . services . append ( DEVICE ) [EOL] [EOL] identifiers = list ( get_unique_identifiers ( response ) ) [EOL] assert len ( identifiers ) == [number] [EOL] assert [string] in identifiers [EOL] [EOL] [EOL] def test_unique_identifier_mrp ( response ) : [EOL] response . services . append ( MRP ) [EOL] [EOL] identifiers = list ( get_unique_identifiers ( response ) ) [EOL] assert len ( identifiers ) == [number] [EOL] assert [string] in identifiers [EOL] [EOL] [EOL] def test_unique_identifier_airplay ( response ) : [EOL] response . services . append ( AIRPLAY ) [EOL] [EOL] identifiers = list ( get_unique_identifiers ( response ) ) [EOL] assert len ( identifiers ) == [number] [EOL] assert [string] in identifiers [EOL] [EOL] [EOL] def test_unique_identifier_multiple ( response ) : [EOL] response . services . append ( HS ) [EOL] response . services . append ( DEVICE ) [EOL] response . services . append ( MRP ) [EOL] response . services . append ( AIRPLAY ) [EOL] [EOL] identifiers = list ( get_unique_identifiers ( response ) ) [EOL] assert len ( identifiers ) == [number] [EOL] assert [string] in identifiers [EOL] assert [string] in identifiers [EOL] assert [string] in identifiers [EOL] assert [string] in identifiers [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 $pyatv.support.mdns.Service$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import OrderedDict , Dict , List [EOL] import pyatv [EOL] import collections [EOL] import typing [EOL] [docstring] [EOL] [EOL] from collections import OrderedDict [EOL] from pyatv . support . hap_tlv8 import ( TlvValue , ErrorCode , Method , State , read_tlv , write_tlv , stringify , ) [EOL] [EOL] SINGLE_KEY_IN = { [number] : [string] } [EOL] SINGLE_KEY_OUT = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] DOUBLE_KEY_IN = OrderedDict ( [ ( [number] , [string] ) , ( [number] , [string] ) ] ) [EOL] DOUBLE_KEY_OUT = [string] [EOL] [EOL] LARGE_KEY_IN = { [number] : [string] * [number] } [EOL] LARGE_KEY_OUT = [string] + [string] * [number] + [string] [EOL] [EOL] [EOL] def test_write_single_key ( ) : [EOL] assert write_tlv ( SINGLE_KEY_IN ) == SINGLE_KEY_OUT [EOL] [EOL] [EOL] def test_write_two_keys ( ) : [EOL] assert write_tlv ( DOUBLE_KEY_IN ) == DOUBLE_KEY_OUT [EOL] [EOL] [EOL] def test_write_key_larger_than_255_bytes ( ) : [EOL] [comment] [EOL] [comment] [EOL] assert write_tlv ( LARGE_KEY_IN ) == LARGE_KEY_OUT [EOL] [EOL] [EOL] def test_read_single_key ( ) : [EOL] assert read_tlv ( SINGLE_KEY_OUT ) == SINGLE_KEY_IN [EOL] [EOL] [EOL] def test_read_two_keys ( ) : [EOL] assert read_tlv ( DOUBLE_KEY_OUT ) == DOUBLE_KEY_IN [EOL] [EOL] [EOL] def test_read_key_larger_than_255_bytes ( ) : [EOL] assert read_tlv ( LARGE_KEY_OUT ) == LARGE_KEY_IN [EOL] [EOL] [EOL] def test_stringify_method ( ) : [EOL] assert stringify ( { TlvValue . Method : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . Method : [string] } ) == [string] [EOL] [EOL] [EOL] def test_stringify_seqno ( ) : [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . SeqNo : [string] } ) == [string] [EOL] [EOL] [EOL] def test_stringify_error ( ) : [EOL] assert stringify ( { TlvValue . Error : [string] } ) == [string] [EOL] assert stringify ( { TlvValue . Error : [string] } ) == [string] [EOL] [EOL] [EOL] def test_stringify_backoff ( ) : [EOL] assert stringify ( { TlvValue . BackOff : [string] } ) == [string] [EOL] [EOL] [EOL] def test_stringify_remainging_short ( ) : [EOL] values = [ TlvValue . Identifier , TlvValue . Salt , TlvValue . PublicKey , TlvValue . Proof , TlvValue . EncryptedData , TlvValue . Certificate , TlvValue . Signature , TlvValue . Permissions , TlvValue . FragmentData , TlvValue . FragmentLast , ] [EOL] [EOL] for value in values : [EOL] assert stringify ( { value : [string] } ) == f"{ value . name } [string] " [EOL] [EOL] [EOL] def test_stringify_multiple ( ) : [EOL] assert ( stringify ( { TlvValue . Method : [string] , TlvValue . SeqNo : [string] , TlvValue . Error : [string] , TlvValue . BackOff : [string] , } ) == [string] ) [EOL] [EOL] [EOL] def test_stringify_unknown_values ( ) : [EOL] assert ( stringify ( { TlvValue . Method : [string] , TlvValue . SeqNo : [string] , TlvValue . Error : [string] , [number] : [string] , } ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.int,builtins.bytes]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $collections.OrderedDict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Dict[builtins.int,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from ipaddress import ip_address [EOL] import pytest [EOL] [EOL] from pyatv . support . net import unused_port [EOL] from pyatv . support . knock import knock , knocker [EOL] [EOL] from tests . fake_knock import create_knock_server [EOL] from tests . utils import until [EOL] [EOL] LOCALHOST = ip_address ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_single_port_knock ( event_loop , knock_server ) : [EOL] server = await knock_server ( ) [EOL] await knock ( LOCALHOST , [ server . port ] , event_loop ) [EOL] await until ( lambda : server . got_knock ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_multi_port_knock ( event_loop , knock_server ) : [EOL] server1 = await knock_server ( ) [EOL] server2 = await knock_server ( ) [EOL] await knock ( LOCALHOST , [ server1 . port , server2 . port ] , event_loop ) [EOL] await until ( lambda : server1 . got_knock ) [EOL] await until ( lambda : server2 . got_knock ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_continuous_knocking ( event_loop , knock_server ) : [EOL] server = await knock_server ( ) [EOL] await knocker ( LOCALHOST , [ server . port ] , event_loop , timeout = [number] ) [EOL] await until ( lambda : server . count == [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Optional , Any , Tuple , Literal [EOL] import pyatv [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] from typing import Tuple [EOL] from ipaddress import IPv4Address [EOL] [EOL] import pytest [EOL] [EOL] from pyatv . support import mdns , net [EOL] from tests import fake_udns [EOL] from tests . support import dns_utils [EOL] [EOL] [EOL] SERVICE_NAME = [string] [EOL] MEDIAREMOTE_SERVICE = [string] [EOL] DEVICE_INFO_SERVICE = [string] [EOL] [EOL] [EOL] TEST_SERVICES = dict ( [ fake_udns . mrp_service ( SERVICE_NAME , SERVICE_NAME , [string] , address = [string] , port = [number] ) , ] ) [EOL] [EOL] [EOL] def get_response_for_service ( service , ) : [EOL] req = mdns . create_request ( [ service ] ) [EOL] resp = fake_udns . create_response ( req , TEST_SERVICES ) [EOL] return mdns . DnsMessage ( ) . unpack ( resp . pack ( ) ) , TEST_SERVICES . get ( service ) [EOL] [EOL] [EOL] def test_qname_with_label ( ) : [EOL] [comment] [EOL] message = [string] + [string] + [string] [EOL] ptr = message [ [number] : ] [EOL] ret , rest = mdns . qname_decode ( ptr , message ) [EOL] assert ret == [string] [EOL] assert rest == [string] [EOL] [EOL] [EOL] def test_non_existing_service ( ) : [EOL] resp , _ = get_response_for_service ( [string] ) [EOL] assert len ( resp . questions ) == [number] [EOL] assert len ( resp . answers ) == [number] [EOL] assert len ( resp . resources ) == [number] [EOL] [EOL] [EOL] def test_service_has_expected_responses ( ) : [EOL] resp , _ = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] assert len ( resp . questions ) == [number] [EOL] assert len ( resp . answers ) == [number] [EOL] assert len ( resp . resources ) == [number] [EOL] [EOL] [EOL] def test_service_has_valid_question ( ) : [EOL] resp , _ = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] question = resp . questions [ [number] ] [EOL] assert question . qname == MEDIAREMOTE_SERVICE [EOL] assert question . qtype == mdns . QTYPE_PTR [EOL] assert question . qclass == [number] [EOL] [EOL] [EOL] def test_service_has_valid_answer ( ) : [EOL] resp , data = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] answer = resp . answers [ [number] ] [EOL] assert answer . qname == MEDIAREMOTE_SERVICE [EOL] assert answer . qtype == mdns . QTYPE_PTR [EOL] assert answer . qclass == dns_utils . DEFAULT_QCLASS [EOL] assert answer . ttl == dns_utils . DEFAULT_TTL [EOL] assert answer . rd == data . name + [string] + MEDIAREMOTE_SERVICE [EOL] [EOL] [EOL] def test_service_has_valid_srv_resource ( ) : [EOL] resp , data = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] [EOL] srv = dns_utils . get_qtype ( resp . resources , mdns . QTYPE_SRV ) [EOL] assert srv . qname == data . name + [string] + MEDIAREMOTE_SERVICE [EOL] assert srv . qtype == mdns . QTYPE_SRV [EOL] assert srv . qclass == dns_utils . DEFAULT_QCLASS [EOL] assert srv . ttl == dns_utils . DEFAULT_TTL [EOL] [EOL] rd = srv . rd [EOL] assert rd [ [string] ] == [number] [EOL] assert rd [ [string] ] == [number] [EOL] assert rd [ [string] ] == data . port [EOL] assert rd [ [string] ] == data . name + [string] [EOL] [EOL] [EOL] def test_service_has_valid_txt_resource ( ) : [EOL] resp , data = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] [EOL] srv = dns_utils . get_qtype ( resp . resources , mdns . QTYPE_TXT ) [EOL] assert srv . qname == data . name + [string] + MEDIAREMOTE_SERVICE [EOL] assert srv . qtype == mdns . QTYPE_TXT [EOL] assert srv . qclass == dns_utils . DEFAULT_QCLASS [EOL] assert srv . ttl == dns_utils . DEFAULT_TTL [EOL] [EOL] rd = srv . rd [EOL] assert len ( rd ) == len ( data . properties ) [EOL] for k , v in data . properties . items ( ) : [EOL] assert rd [ k ] == v [EOL] [EOL] [EOL] def test_service_has_valid_a_resource ( ) : [EOL] resp , data = get_response_for_service ( MEDIAREMOTE_SERVICE ) [EOL] [EOL] srv = dns_utils . get_qtype ( resp . resources , mdns . QTYPE_A ) [EOL] assert srv . qname == data . name + [string] [EOL] assert srv . qtype == mdns . QTYPE_A [EOL] assert srv . qclass == dns_utils . DEFAULT_QCLASS [EOL] assert srv . ttl == dns_utils . DEFAULT_TTL [EOL] assert srv . rd == [string] [EOL] [EOL] [EOL] def test_authority ( ) : [EOL] msg = mdns . DnsMessage ( ) [EOL] msg . authorities . append ( dns_utils . resource ( [string] , mdns . QTYPE_A , [string] ) ) [EOL] [EOL] unpacked = mdns . DnsMessage ( ) . unpack ( msg . pack ( ) ) [EOL] assert len ( unpacked . authorities ) == [number] [EOL] [EOL] record = unpacked . authorities [ [number] ] [EOL] assert record . qname == [string] [EOL] assert record . qtype == mdns . QTYPE_A [EOL] assert record . qclass == dns_utils . DEFAULT_QCLASS [EOL] assert record . ttl == dns_utils . DEFAULT_TTL [EOL] assert record . rd == [string] [EOL] [EOL] [EOL] def test_parse_empty_service ( ) : [EOL] assert mdns . parse_services ( mdns . DnsMessage ( ) ) == [ ] [EOL] [EOL] [EOL] def test_parse_no_service_type ( ) : [EOL] service_params = ( None , [string] , None , [number] , { } ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] [EOL] [EOL] def test_parse_no_service_name ( ) : [EOL] service_params = ( [string] , None , None , [number] , { } ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] [EOL] [EOL] def test_parse_with_name_and_type ( ) : [EOL] service_params = ( [string] , [string] , None , [number] , { } ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] dns_utils . assert_service ( parsed [ [number] ] , * service_params ) [EOL] [EOL] [EOL] def test_parse_with_port_and_address ( ) : [EOL] service_params = ( [string] , [string] , [string] , [number] , { } ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] dns_utils . assert_service ( parsed [ [number] ] , * service_params ) [EOL] [EOL] [EOL] def test_parse_single_service ( ) : [EOL] service_params = ( [string] , [string] , [string] , [number] , { [string] : [string] } ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] dns_utils . assert_service ( parsed [ [number] ] , * service_params ) [EOL] [EOL] [EOL] def test_parse_double_service ( ) : [EOL] service1_params = ( [string] , [string] , [string] , [number] , { [string] : [string] } ) [EOL] service2_params = ( [string] , [string] , [string] , [number] , { [string] : [string] } , ) [EOL] message = dns_utils . add_service ( mdns . DnsMessage ( ) , * service1_params ) [EOL] message = dns_utils . add_service ( message , * service2_params ) [EOL] [EOL] parsed = mdns . parse_services ( message ) [EOL] assert len ( parsed ) == [number] [EOL] dns_utils . assert_service ( parsed [ [number] ] , * service1_params ) [EOL] dns_utils . assert_service ( parsed [ [number] ] , * service2_params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[pyatv.support.mdns.DnsMessage,tests.fake_udns.FakeDnsService]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import asyncio [EOL] import logging [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] import pytest [EOL] [EOL] from pyatv import exceptions [EOL] from pyatv . support import error_handler , log_binary , log_protobuf [EOL] from pyatv . mrp . protobuf import ProtocolMessage [EOL] [EOL] [EOL] class DummyException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def logger_fixture ( ) : [EOL] logger = MagicMock ( ) [EOL] logger . return_value = True [EOL] yield logger [EOL] [EOL] [EOL] @ pytest . fixture def message ( ) : [EOL] msg = ProtocolMessage ( ) [EOL] msg . identifier = [string] [EOL] yield msg [EOL] [EOL] [EOL] async def doraise ( exception ) : [EOL] raise exception ( ) [EOL] [EOL] [EOL] [comment] [EOL] def _debug_string ( logger ) : [EOL] call_args = logger . debug . call_args [ [number] ] [EOL] formatting = call_args [ [number] ] [EOL] args = call_args [ [number] : ] [EOL] return formatting % args [EOL] [EOL] [EOL] async def test_error_handler_return_value ( ) : [EOL] async def _returns ( ) : [EOL] return [number] [EOL] [EOL] assert await error_handler ( _returns , DummyException ) == [number] [EOL] [EOL] [EOL] async def test_error_handleroserror ( ) : [EOL] with pytest . raises ( exceptions . ConnectionFailedError ) : [EOL] await error_handler ( doraise , DummyException , OSError ) [EOL] [EOL] [EOL] async def test_error_handler_timeout ( ) : [EOL] with pytest . raises ( exceptions . ConnectionFailedError ) : [EOL] await error_handler ( doraise , DummyException , asyncio . TimeoutError ) [EOL] [EOL] [EOL] async def test_error_handler_backoff ( ) : [EOL] with pytest . raises ( exceptions . BackOffError ) : [EOL] await error_handler ( doraise , DummyException , exceptions . BackOffError ) [EOL] [EOL] [EOL] async def test_error_handler_no_credentials ( ) : [EOL] with pytest . raises ( exceptions . NoCredentialsError ) : [EOL] await error_handler ( doraise , DummyException , exceptions . NoCredentialsError ) [EOL] [EOL] [EOL] async def test_error_handler_other_exception ( ) : [EOL] with pytest . raises ( DummyException ) : [EOL] await error_handler ( doraise , DummyException , Exception ) [EOL] [EOL] [EOL] def test_log_binary_no_log_if_not_debug ( logger ) : [EOL] logger . isEnabledFor . return_value = False [EOL] log_binary ( logger , [string] ) [EOL] logger . isEnabledFor . assert_called_with ( logging . DEBUG ) [EOL] [EOL] [EOL] def test_log_binary_no_log_if_not_custom_level ( logger ) : [EOL] logger . isEnabledFor . return_value = False [EOL] log_binary ( logger , [string] , level = logging . INFO ) [EOL] logger . isEnabledFor . assert_called_with ( logging . INFO ) [EOL] [EOL] [EOL] def test_log_binary_log_no_args_if_enabled ( logger ) : [EOL] log_binary ( logger , [string] ) [EOL] assert _debug_string ( logger ) == [string] [EOL] [EOL] [EOL] def test_log_binary_log_empty_value_if_enabled ( logger ) : [EOL] log_binary ( logger , [string] , test = None ) [EOL] assert _debug_string ( logger ) == [string] [EOL] [EOL] [EOL] def test_log_binary_log_single_arg_if_enabled ( logger ) : [EOL] log_binary ( logger , [string] , test = [string] ) [EOL] assert _debug_string ( logger ) == [string] [EOL] [EOL] [EOL] def test_log_binary_log_multiple_args_if_enabled ( logger ) : [EOL] log_binary ( logger , [string] , test = [string] , dummy = [string] ) [EOL] assert _debug_string ( logger ) == [string] [EOL] [EOL] [EOL] def test_log_binary_log_limit_output ( logger ) : [EOL] log_binary ( logger , [string] , a = [string] * [number] , b = [string] * [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert len ( _debug_string ( logger ) ) == [number] [EOL] [EOL] [EOL] def test_protobuf_no_log_if_not_debug ( logger , message ) : [EOL] logger . isEnabledFor . return_value = False [EOL] log_protobuf ( logger , [string] , message ) [EOL] logger . isEnabledFor . assert_called_with ( logging . DEBUG ) [EOL] [EOL] [EOL] def test_protobuf_log_message ( logger , message ) : [EOL] log_protobuf ( logger , [string] , message ) [EOL] assert _debug_string ( logger ) == [string] [EOL] [EOL] [EOL] def test_protobuf_log_limit_message_max_length ( logger , message ) : [EOL] message . identifier = [string] * [number] [EOL] log_protobuf ( logger , [string] , message ) [EOL] assert len ( _debug_string ( logger ) ) == [number] [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { [string] : [string] } ) def test_protobuf_log_with_length_override ( logger , message ) : [EOL] log_protobuf ( logger , [string] , message ) [EOL] assert _debug_string ( logger ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict , List [EOL] import typing [EOL] import ipaddress [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Dict , List [EOL] from ipaddress import IPv4Address , ip_address [EOL] from unittest . mock import patch [EOL] [EOL] import pytest [EOL] import netifaces [EOL] [EOL] from pyatv . support . net import get_private_addresses [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def mock_address ( ) : [EOL] addresses = { } [EOL] [EOL] def _add ( interface , address ) : [EOL] addresses . setdefault ( interface , [ ] ) . append ( address ) [EOL] [EOL] def _ifaddresses ( interface ) : [EOL] iface_addresses = addresses . get ( interface ) [EOL] if not iface_addresses : [EOL] return { } [EOL] [EOL] inet_addresses = [ { [string] : str ( addr ) , [string] : [string] } for addr in iface_addresses ] [EOL] return { netifaces . AF_INET : inet_addresses } [EOL] [EOL] with patch ( [string] ) as mock_interfaces : [EOL] with patch ( [string] ) as mock_ifaddr : [EOL] mock_interfaces . side_effect = lambda : list ( addresses . keys ( ) ) [EOL] mock_ifaddr . side_effect = _ifaddresses [EOL] yield _add [EOL] [EOL] [EOL] def test_no_address ( ) : [EOL] assert get_private_addresses ( ) == [ ] [EOL] [EOL] [EOL] def test_private_addresses ( mock_address ) : [EOL] mock_address ( [string] , [string] ) [EOL] mock_address ( [string] , [string] ) [EOL] mock_address ( [string] , [string] ) [EOL] [EOL] assert get_private_addresses ( ) == [ ip_address ( [string] ) , ip_address ( [string] ) , ip_address ( [string] ) , ] [EOL] [EOL] [EOL] def test_public_addresses ( mock_address ) : [EOL] mock_address ( [string] , [string] ) [EOL] mock_address ( [string] , [string] ) [EOL] assert get_private_addresses ( ) == [ ] [EOL] [EOL] [EOL] def test_localhost ( mock_address ) : [EOL] mock_address ( [string] , [string] ) [EOL] assert get_private_addresses ( ) == [ IPv4Address ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0