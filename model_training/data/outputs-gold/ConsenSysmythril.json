from typing import Any [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] [EOL] from mythril . mythril import MythrilDisassembler [EOL] from mythril . solidity . soliditycontract import SolidityContract [EOL] from tests import BaseTestCase [EOL] [EOL] TEST_FILES = Path ( __file__ ) . parent / [string] [EOL] [EOL] [EOL] class SolidityContractTest ( BaseTestCase ) : [EOL] def test_get_source_info_without_name_gets_latest_contract_info ( self ) : [EOL] input_file = TEST_FILES / [string] [EOL] contract = SolidityContract ( str ( input_file ) ) [EOL] [EOL] code_info = contract . get_source_info ( [number] ) [EOL] [EOL] self . assertEqual ( code_info . filename , str ( input_file ) ) [EOL] self . assertEqual ( code_info . lineno , [number] ) [EOL] self . assertEqual ( code_info . code , [string] ) [EOL] [EOL] def test_get_source_info_with_contract_name_specified ( self ) : [EOL] input_file = TEST_FILES / [string] [EOL] contract = SolidityContract ( str ( input_file ) , name = [string] ) [EOL] [EOL] code_info = contract . get_source_info ( [number] ) [EOL] [EOL] self . assertEqual ( code_info . filename , str ( input_file ) ) [EOL] self . assertEqual ( code_info . lineno , [number] ) [EOL] self . assertEqual ( code_info . code , [string] ) [EOL] [EOL] def test_get_source_info_with_contract_name_specified_constructor ( self ) : [EOL] input_file = TEST_FILES / [string] [EOL] contract = SolidityContract ( str ( input_file ) , name = [string] ) [EOL] [EOL] code_info = contract . get_source_info ( [number] , constructor = True ) [EOL] [EOL] self . assertEqual ( code_info . filename , str ( input_file ) ) [EOL] self . assertEqual ( code_info . lineno , [number] ) [EOL] self . assertEqual ( code_info . code , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $pathlib.Path$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import mythril [EOL] [docstring] [EOL] from mythril . mythril import MythrilAnalyzer , MythrilDisassembler [EOL] from mythril . ethereum import util [EOL] from mythril . solidity . soliditycontract import EVMContract [EOL] from tests import TESTDATA_INPUTS [EOL] [EOL] [EOL] def test_generate_graph ( ) : [EOL] for input_file in TESTDATA_INPUTS . iterdir ( ) : [EOL] if input_file . name != [string] : [EOL] continue [EOL] contract = EVMContract ( input_file . read_text ( ) ) [EOL] disassembler = MythrilDisassembler ( ) [EOL] [EOL] disassembler . contracts . append ( contract ) [EOL] analyzer = MythrilAnalyzer ( disassembler = disassembler , strategy = [string] , execution_timeout = [number] , max_depth = [number] , address = ( util . get_indexed_address ( [number] ) ) , solver_timeout = [number] , ) [EOL] [EOL] analyzer . graph_html ( transaction_count = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import mythril [EOL] from mythril . mythril import MythrilAnalyzer , MythrilDisassembler [EOL] from mythril . ethereum import util [EOL] from mythril . solidity . soliditycontract import EVMContract [EOL] from tests import TESTDATA_INPUTS [EOL] [EOL] [EOL] def test_statespace_dump ( ) : [EOL] for input_file in TESTDATA_INPUTS . iterdir ( ) : [EOL] if input_file . name not in ( [string] , [string] ) : [EOL] [comment] [EOL] continue [EOL] contract = EVMContract ( input_file . read_text ( ) ) [EOL] disassembler = MythrilDisassembler ( ) [EOL] disassembler . contracts . append ( contract ) [EOL] analyzer = MythrilAnalyzer ( disassembler = disassembler , strategy = [string] , execution_timeout = [number] , max_depth = [number] , address = ( util . get_indexed_address ( [number] ) ) , solver_timeout = [number] , ) [EOL] [EOL] analyzer . dump_statespace ( contract = contract ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from subprocess import check_output [EOL] from tests import BaseTestCase , TESTDATA , PROJECT_DIR , TESTS_DIR [EOL] from mock import patch [EOL] [EOL] MYTH = str ( PROJECT_DIR / [string] ) [EOL] [EOL] [EOL] def output_of ( command ) : [EOL] [docstring] [EOL] return check_output ( command , shell = True ) . decode ( [string] ) [EOL] [EOL] [EOL] class CommandLineToolTestCase ( BaseTestCase ) : [EOL] def test_disassemble_code_correctly ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_disassemble_solidity_file_correctly ( self ) : [EOL] solidity_file = str ( TESTDATA / [string] / [string] ) [EOL] command = [string] . format ( MYTH , solidity_file ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_hash_a_function_correctly ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_failure_json ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] print ( output_of ( command ) ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_failure_text ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] assert output_of ( command ) == [string] [EOL] [EOL] def test_failure_jsonv2 ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] self . assertIn ( [string] [string] , output_of ( command ) ) [EOL] [EOL] def test_analyze ( self ) : [EOL] solidity_file = str ( TESTDATA / [string] / [string] ) [EOL] command = [string] . format ( MYTH , solidity_file ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_analyze_bytecode ( self ) : [EOL] solidity_file = str ( TESTDATA / [string] / [string] ) [EOL] command = [string] . format ( MYTH , solidity_file ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_invalid_args_iprof ( self ) : [EOL] solidity_file = str ( TESTDATA / [string] / [string] ) [EOL] command = [string] . format ( MYTH , solidity_file ) [EOL] self . assertIn ( [string] , output_of ( command ) ) [EOL] [EOL] def test_only_epic ( self ) : [EOL] command = [string] . format ( MYTH ) [EOL] [comment] [EOL] output_of ( command ) [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import pathlib [EOL] from pathlib import Path [EOL] from mythril . solidity . soliditycontract import SolidityContract [EOL] [EOL] [comment] [EOL] root = Path ( __file__ ) . parent [EOL] input = root / [string] [EOL] output = root / [string] [EOL] [EOL] for contract in input . iterdir ( ) : [EOL] sol = SolidityContract ( str ( contract ) ) [EOL] code = sol . code [EOL] [EOL] output_file = output / [string] . format ( contract . name ) [EOL] output_file . write_text ( code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import pytest [EOL] from mythril . mythril import MythrilConfig , MythrilDisassembler [EOL] from mythril . exceptions import CriticalError [EOL] [EOL] storage_test = [ ( [ [string] , [string] ] , [ [string] , [string] , [string] , ] , ) , ( [ [string] , [string] , [string] , [string] ] , [ [string] [string] , [string] [string] , ] , ) , ( [ [string] , [string] , [string] ] , [ [string] [string] ] , ) , ( [ [string] , [string] , [string] ] , [ [string] [string] ] , ) , ] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def test_solc_install ( ) : [EOL] MythrilDisassembler ( eth = None , solc_version = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.List[builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] import mythril [EOL] import pytest [EOL] from mock import patch [EOL] [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . smt import symbol_factory [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . account import Account [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import MessageCallTransaction [EOL] from mythril . laser . ethereum . call import SymbolicCalldata [EOL] from mythril . laser . ethereum . transaction import TransactionStartSignal [EOL] [EOL] from mythril . laser . ethereum . evm_exceptions import WriteProtection [EOL] [EOL] [EOL] def get_global_state ( ) : [EOL] active_account = Account ( [string] , code = Disassembly ( [string] ) ) [EOL] environment = Environment ( active_account , None , SymbolicCalldata ( [string] ) , None , None , None ) [EOL] world_state = WorldState ( ) [EOL] world_state . put_account ( active_account ) [EOL] state = GlobalState ( world_state , environment , None , MachineState ( gas_limit = [number] ) ) [EOL] state . transaction_stack . append ( ( MessageCallTransaction ( world_state = world_state , gas_limit = [number] ) , None ) ) [EOL] return state [EOL] [EOL] [EOL] @ patch ( [string] , return_value = ( [string] , Account ( code = Disassembly ( code = [string] ) , address = [string] ) , [number] , [number] , [number] , [number] , [number] , ) , ) def test_staticcall ( f1 ) : [EOL] [comment] [EOL] state = get_global_state ( ) [EOL] state . mstate . stack = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionStartSignal ) as ts : [EOL] instruction . evaluate ( state ) [EOL] assert ts . value . transaction . static [EOL] assert ts . value . transaction . initial_global_state ( ) . environment . static [EOL] [EOL] [EOL] test_data = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , test_data ) def test_staticness ( input ) : [EOL] [comment] [EOL] state = get_global_state ( ) [EOL] state . environment . static = True [EOL] state . mstate . stack = [ ] [EOL] instruction = Instruction ( input , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( WriteProtection ) : [EOL] instruction . evaluate ( state ) [EOL] [EOL] [EOL] test_data_call = ( ( [number] , True ) , ( [number] , False ) ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , test_data_call ) @ patch ( [string] ) def test_staticness_call_concrete ( f1 , input , success ) : [EOL] [comment] [EOL] state = get_global_state ( ) [EOL] state . environment . static = True [EOL] state . mstate . stack = [ [number] ] * [number] [EOL] code = Disassembly ( code = [string] ) [EOL] f1 . return_value = ( [string] , Account ( code = code , address = [string] ) , [number] , input , [number] , [number] , [number] ) [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] if success : [EOL] with pytest . raises ( TransactionStartSignal ) as ts : [EOL] instruction . evaluate ( state ) [EOL] assert ts . value . transaction . static [EOL] else : [EOL] with pytest . raises ( WriteProtection ) : [EOL] instruction . evaluate ( state ) [EOL] [EOL] [EOL] @ patch ( [string] ) def test_staticness_call_symbolic ( f1 ) : [EOL] [comment] [EOL] state = get_global_state ( ) [EOL] state . environment . static = True [EOL] state . mstate . stack = [ [number] ] * [number] [EOL] call_value = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] code = Disassembly ( code = [string] ) [EOL] f1 . return_value = ( [string] , Account ( code = code , address = [string] ) , [number] , call_value , [number] , [number] , [number] ) [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionStartSignal ) as ts : [EOL] instruction . evaluate ( state ) [EOL] [EOL] assert ts . value . transaction . static [EOL] assert ts . value . global_state . world_state . constraints [ - [number] ] == ( call_value == [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.bool],typing.Tuple[builtins.int,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.bool],typing.Tuple[builtins.int,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import mythril [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . account import Account [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import MessageCallTransaction [EOL] [EOL] [EOL] def test_codecopy_concrete ( ) : [EOL] [comment] [EOL] world_state = WorldState ( ) [EOL] account = world_state . create_account ( balance = [number] , address = [number] ) [EOL] account . code = Disassembly ( [string] ) [EOL] environment = Environment ( account , None , None , None , None , None ) [EOL] og_state = GlobalState ( world_state , environment , None , MachineState ( gas_limit = [number] ) ) [EOL] og_state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] [EOL] og_state . mstate . stack = [ [number] , [number] , [number] ] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] new_state = instruction . evaluate ( og_state ) [ [number] ] [EOL] [EOL] [comment] [EOL] assert new_state . mstate . memory [ [number] ] == [number] [EOL] assert new_state . mstate . memory [ [number] ] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import mythril [EOL] import pytest [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import ( MessageCallTransaction , TransactionStartSignal , ) [EOL] from mythril . laser . smt import symbol_factory [EOL] from mythril . laser . ethereum . state . calldata import ConcreteCalldata [EOL] from mythril . support . support_utils import get_code_hash [EOL] [EOL] last_state = None [EOL] created_contract_account = None [EOL] [EOL] [EOL] def generate_salted_address ( code_str , salt , caller ) : [EOL] addr = hex ( caller . value ) [ [number] : ] [EOL] addr = [string] * ( [number] - len ( addr ) ) + addr [EOL] [EOL] salt = hex ( salt . value ) [ [number] : ] [EOL] salt = [string] * ( [number] - len ( salt ) ) + salt [EOL] [EOL] contract_address = int ( get_code_hash ( [string] + addr + salt + get_code_hash ( code_str ) [ [number] : ] ) [ [number] : ] , [number] ) [EOL] return contract_address [EOL] [EOL] [EOL] def test_create2 ( ) : [EOL] world_state = WorldState ( ) [EOL] account = world_state . create_account ( balance = [number] , address = [number] ) [EOL] account . code = Disassembly ( [string] ) [EOL] environment = Environment ( account , None , None , None , None , None ) [EOL] og_state = GlobalState ( world_state , environment , None , MachineState ( gas_limit = [number] ) ) [EOL] code_raw = [ ] [EOL] code = [string] [EOL] for i in range ( len ( code ) // [number] ) : [EOL] code_raw . append ( int ( code [ [number] * i : [number] * ( i + [number] ) ] , [number] ) ) [EOL] calldata = ConcreteCalldata ( [string] , code_raw ) [EOL] environment . calldata = calldata [EOL] og_state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] value = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] salt = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] og_state . mstate . stack = [ salt , symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecVal ( [number] , [number] ) , value , ] [EOL] og_state . mstate . memory . extend ( [number] ) [EOL] og_state . mstate . memory [ [number] : [number] ] = [ [number] ] * [number] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [comment] [EOL] with pytest . raises ( TransactionStartSignal ) as t : [EOL] _ = instruction . evaluate ( og_state ) [ [number] ] [EOL] assert t . value . transaction . call_value == value [EOL] assert t . value . transaction . code . bytecode == code [EOL] assert t . value . transaction . callee_account . address == generate_salted_address ( code , salt , account . address ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import mythril [EOL] import pytest [EOL] [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import ( MessageCallTransaction , TransactionStartSignal , ) [EOL] from mythril . laser . ethereum . state . calldata import ConcreteCalldata [EOL] [EOL] [EOL] last_state = None [EOL] created_contract_account = None [EOL] [EOL] [EOL] def test_create ( ) : [EOL] world_state = WorldState ( ) [EOL] account = world_state . create_account ( balance = [number] , address = [number] ) [EOL] account . code = Disassembly ( [string] ) [EOL] environment = Environment ( account , None , None , None , None , None ) [EOL] og_state = GlobalState ( world_state , environment , None , MachineState ( gas_limit = [number] ) ) [EOL] code_raw = [ ] [EOL] code = [string] [EOL] for i in range ( len ( code ) // [number] ) : [EOL] code_raw . append ( int ( code [ [number] * i : [number] * ( i + [number] ) ] , [number] ) ) [EOL] calldata = ConcreteCalldata ( [string] , code_raw ) [EOL] environment . calldata = calldata [EOL] og_state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] value = [number] [EOL] og_state . mstate . stack = [ [number] , [number] , value ] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] og_state . mstate . memory . extend ( [number] ) [EOL] og_state . mstate . memory [ [number] : [number] ] = [ [number] ] * [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TransactionStartSignal ) as t : [EOL] _ = instruction . evaluate ( og_state ) [ [number] ] [EOL] [EOL] assert t . value . transaction . call_value == value [EOL] assert t . value . transaction . code . bytecode == code [EOL] assert ( t . value . transaction . callee_account . address == world_state . _generate_new_address ( account . address . value ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import mythril [EOL] from mythril . laser . smt import symbol_factory [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import MessageCallTransaction [EOL] [EOL] [EOL] def test_extcodecopy ( ) : [EOL] [comment] [EOL] new_world_state = WorldState ( ) [EOL] new_account = new_world_state . create_account ( balance = [number] , address = [number] ) [EOL] new_account . code = Disassembly ( [string] ) [EOL] ext_account = new_world_state . create_account ( balance = [number] , address = [number] ) [EOL] ext_account . code = Disassembly ( [string] ) [EOL] [EOL] new_environment = Environment ( new_account , None , None , None , None , None ) [EOL] state = GlobalState ( new_world_state , new_environment , None , MachineState ( gas_limit = [number] ) ) [EOL] state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] [EOL] state . mstate . stack = [ [number] , [number] , [number] , [number] ] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] new_state = instruction . evaluate ( state ) [ [number] ] [EOL] [comment] [EOL] assert new_state . mstate . memory [ [number] : [number] ] == [ [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_extcodecopy_fail ( ) : [EOL] [comment] [EOL] new_world_state = WorldState ( ) [EOL] new_account = new_world_state . create_account ( balance = [number] , address = [number] ) [EOL] new_account . code = Disassembly ( [string] ) [EOL] new_environment = Environment ( new_account , None , None , None , None , None ) [EOL] state = GlobalState ( new_world_state , new_environment , None , MachineState ( gas_limit = [number] ) ) [EOL] state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] [EOL] state . mstate . stack = [ [number] , [number] , [number] , symbol_factory . BitVecSym ( [string] , [number] ) ] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [comment] [EOL] new_state = instruction . evaluate ( state ) [ [number] ] [EOL] [EOL] [comment] [EOL] assert new_state . mstate . stack == [ ] [EOL] assert new_state . mstate . memory . _memory == state . mstate . memory . _memory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import mythril [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . account import Account [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] from mythril . laser . ethereum . transaction . transaction_models import MessageCallTransaction [EOL] [EOL] from mythril . support . support_utils import get_code_hash [EOL] [EOL] from mythril . laser . smt import symbol_factory [EOL] [EOL] [comment] [EOL] world_state = WorldState ( ) [EOL] account = world_state . create_account ( balance = [number] , address = [number] ) [EOL] account . code = Disassembly ( [string] ) [EOL] world_state . create_account ( balance = [number] , address = [number] ) [EOL] environment = Environment ( account , None , None , None , None , None ) [EOL] og_state = GlobalState ( world_state , environment , None , MachineState ( gas_limit = [number] ) ) [EOL] og_state . transaction_stack . append ( ( MessageCallTransaction ( world_state = WorldState ( ) , gas_limit = [number] ) , None ) ) [EOL] [EOL] instruction = Instruction ( [string] , dynamic_loader = None ) [EOL] [EOL] [EOL] def test_extcodehash_no_account ( ) : [EOL] [EOL] [comment] [EOL] og_state . mstate . stack = [ symbol_factory . BitVecVal ( [number] , [number] ) ] [EOL] new_state = instruction . evaluate ( og_state ) [ [number] ] [EOL] assert new_state . mstate . stack [ - [number] ] == [number] [EOL] [EOL] [EOL] def test_extcodehash_no_code ( ) : [EOL] [EOL] [comment] [EOL] og_state . mstate . stack = [ symbol_factory . BitVecVal ( [number] , [number] ) ] [EOL] new_state = instruction . evaluate ( og_state ) [ [number] ] [EOL] assert hex ( new_state . mstate . stack [ - [number] ] . value ) == get_code_hash ( [string] ) [EOL] [EOL] [EOL] def test_extcodehash_return_hash ( ) : [EOL] [comment] [EOL] og_state . mstate . stack = [ symbol_factory . BitVecVal ( [number] , [number] ) ] [EOL] new_state = instruction . evaluate ( og_state ) [ [number] ] [EOL] assert hex ( new_state . mstate . stack [ - [number] ] . value ) == get_code_hash ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.account.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 0 0 0 0 $mythril.laser.ethereum.state.account.Account$ 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.account.Account$ 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $mythril.laser.ethereum.state.account.Account$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.world_state.WorldState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple , Dict , List , Any , Union [EOL] import typing [EOL] import builtins [EOL] from mythril . disassembler . asm import * [EOL] import pytest [EOL] [EOL] valid_names = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , valid_names ) def test_get_opcode ( operation_name , hex_value ) : [EOL] [comment] [EOL] return_value = get_opcode_from_name ( operation_name ) [EOL] [comment] [EOL] assert return_value == hex_value [EOL] [EOL] [EOL] def test_get_unknown_opcode ( ) : [EOL] operation_name = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) : [EOL] get_opcode_from_name ( operation_name ) [EOL] [EOL] [EOL] sequence_match_test_data = [ ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , False , ) , ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , True , ) , ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , False , ) , ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , False , ) , ( ( [ [string] , [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , True , ) , ( ( [ [string] , [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , True , ) , ( ( [ [string] , [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [number] , False , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , sequence_match_test_data ) def test_is_sequence_match ( pattern , instruction_list , index , expected_result ) : [EOL] [comment] [EOL] return_value = is_sequence_match ( pattern , instruction_list , index ) [EOL] [comment] [EOL] assert return_value == expected_result [EOL] [EOL] [EOL] find_sequence_match_test_data = [ ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } ] , [ ] , ) , ( ( [ [string] ] , [ [string] ] ) , [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] , [ [number] , [number] ] , ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , find_sequence_match_test_data ) def test_find_op_code_sequence ( pattern , instruction_list , expected_result ) : [EOL] [comment] [EOL] return_value = list ( find_op_code_sequence ( pattern , instruction_list ) ) [EOL] [EOL] [comment] [EOL] assert return_value == expected_result [EOL] [EOL] [EOL] def test_disassemble ( ) : [EOL] [comment] [EOL] instruction_list = disassemble ( [string] ) [EOL] [EOL] [comment] [EOL] assert instruction_list [ [number] ] [ [string] ] == [string] [EOL] assert instruction_list [ [number] ] [ [string] ] == [string] [EOL] assert instruction_list [ [number] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from mythril . interfaces . cli import main [EOL] import pytest [EOL] import json [EOL] [EOL] import sys [EOL] [EOL] [EOL] def test_version_opt ( capsys ) : [EOL] [comment] [EOL] [comment] [EOL] sys . argv = [ [string] , [string] ] [EOL] with pytest . raises ( SystemExit ) as pytest_wrapped_e : [EOL] main ( ) [EOL] assert pytest_wrapped_e . type == SystemExit [EOL] captured = capsys . readouterr ( ) [EOL] assert captured . out . find ( [string] ) >= [number] [EOL] [EOL] [comment] [EOL] sys . argv = [ [string] , [string] , [string] , [string] ] [EOL] with pytest . raises ( SystemExit ) as pytest_wrapped_e : [EOL] main ( ) [EOL] assert pytest_wrapped_e . type == SystemExit [EOL] captured = capsys . readouterr ( ) [EOL] d = json . loads ( captured . out ) [EOL] assert isinstance ( d , dict ) [EOL] assert d [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from mythril . laser . smt import Solver , symbol_factory , And [EOL] from mythril . laser . ethereum . keccak_function_manager import keccak_function_manager [EOL] import z3 [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecVal ( [number] , [number] ) , z3 . unsat ) , ( symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecVal ( [number] , [number] ) , z3 . unsat ) , ( symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecVal ( [number] , [number] ) , z3 . sat ) , ( symbol_factory . BitVecSym ( [string] , [number] ) , symbol_factory . BitVecSym ( [string] , [number] ) , z3 . sat , ) , ( symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecSym ( [string] , [number] ) , z3 . sat , ) , ( symbol_factory . BitVecVal ( [number] , [number] ) , symbol_factory . BitVecSym ( [string] , [number] ) , z3 . unsat , ) , ] , ) def test_keccak_basic ( input1 , input2 , expected ) : [EOL] s = Solver ( ) [EOL] [EOL] o1 , c1 = keccak_function_manager . create_keccak ( input1 ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( input2 ) [EOL] s . add ( And ( c1 , c2 ) ) [EOL] [EOL] s . add ( o1 == o2 ) [EOL] assert s . check ( ) == expected [EOL] [EOL] [EOL] def test_keccak_symbol_and_val ( ) : [EOL] [docstring] [EOL] s = Solver ( ) [EOL] hundred = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] n = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] o1 , c1 = keccak_function_manager . create_keccak ( hundred ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( n ) [EOL] s . add ( And ( c1 , c2 ) ) [EOL] s . add ( o1 == o2 ) [EOL] s . add ( n == symbol_factory . BitVecVal ( [number] , [number] ) ) [EOL] assert s . check ( ) == z3 . unsat [EOL] [EOL] [EOL] def test_keccak_complex_eq ( ) : [EOL] [docstring] [EOL] s = Solver ( ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] o1 , c1 = keccak_function_manager . create_keccak ( a ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( b ) [EOL] s . add ( And ( c1 , c2 ) ) [EOL] two = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] o1 = two * o1 [EOL] o2 = two * o2 [EOL] o1 , c1 = keccak_function_manager . create_keccak ( o1 ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( o2 ) [EOL] [EOL] s . add ( And ( c1 , c2 ) ) [EOL] s . add ( o1 == o2 ) [EOL] s . add ( a != b ) [EOL] [EOL] assert s . check ( ) == z3 . unsat [EOL] [EOL] [EOL] def test_keccak_complex_eq2 ( ) : [EOL] [docstring] [EOL] s = Solver ( ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] o1 , c1 = keccak_function_manager . create_keccak ( a ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( b ) [EOL] s . add ( And ( c1 , c2 ) ) [EOL] two = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] o1 = two * o1 [EOL] o2 = two * o2 [EOL] o1 , c1 = keccak_function_manager . create_keccak ( o1 ) [EOL] o2 , c2 = keccak_function_manager . create_keccak ( o2 ) [EOL] [EOL] s . add ( And ( c1 , c2 ) ) [EOL] s . add ( o1 == o2 ) [EOL] [EOL] assert s . check ( ) == z3 . sat [EOL] [EOL] [EOL] def test_keccak_simple_number ( ) : [EOL] [docstring] [EOL] s = Solver ( ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] ten = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] o , c = keccak_function_manager . create_keccak ( a ) [EOL] [EOL] s . add ( c ) [EOL] s . add ( ten == o ) [EOL] [EOL] assert s . check ( ) == z3 . unsat [EOL] [EOL] [EOL] def test_keccak_other_num ( ) : [EOL] [docstring] [EOL] s = Solver ( ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] o , c = keccak_function_manager . create_keccak ( a ) [EOL] two = symbol_factory . BitVecVal ( [number] , [number] ) [EOL] o = two * o [EOL] s . add ( c ) [EOL] o , c = keccak_function_manager . create_keccak ( o ) [EOL] s . add ( c ) [EOL] s . add ( b == o ) [EOL] [EOL] assert s . check ( ) == z3 . sat [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from mock import patch [EOL] from eth_utils import decode_hex [EOL] from mythril . laser . ethereum . natives import ec_add [EOL] from py_ecc . optimized_bn128 import FQ [EOL] [EOL] VECTOR_A = decode_hex ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] [EOL] def test_ec_add_sanity ( ) : [EOL] assert ec_add ( VECTOR_A ) == [ ] [EOL] [EOL] [EOL] @ patch ( [string] , return_value = [number] ) @ patch ( [string] , return_value = [number] ) @ patch ( [string] ) def test_ec_add ( f1 , f2 , f3 ) : [EOL] FQ . fielf_modulus = [number] [EOL] a = FQ ( val = [number] ) [EOL] f1 . return_value = ( a , a ) [EOL] assert ec_add ( VECTOR_A ) == ( [ [number] ] * [number] + [ [number] ] ) * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from mythril . laser . ethereum . natives import blake2b_fcompress [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ) , ) def test_blake2 ( input_hex , expected_result ) : [EOL] input_hex = bytearray . fromhex ( input_hex ) [EOL] assert blake2b_fcompress ( input_hex ) == list ( bytearray . fromhex ( expected_result ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from mythril . disassembler . disassembly import Disassembly [EOL] from mythril . laser . ethereum . state . environment import Environment [EOL] from mythril . laser . ethereum . state . account import Account [EOL] from mythril . laser . ethereum . state . machine_state import MachineState [EOL] from mythril . laser . ethereum . state . global_state import GlobalState [EOL] from mythril . laser . ethereum . state . world_state import WorldState [EOL] from mythril . support . loader import DynLoader [EOL] from mythril . ethereum . interface . rpc . client import EthJsonRpc [EOL] from mythril . laser . ethereum . instructions import Instruction [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import mythril [EOL] import pytest [EOL] [EOL] from mythril . laser . ethereum . state . machine_state import MachineStack [EOL] from mythril . laser . ethereum . evm_exceptions import * [EOL] from tests import BaseTestCase [EOL] [EOL] [EOL] class MachineStackTest ( BaseTestCase ) : [EOL] @ staticmethod def test_mstack_constructor ( ) : [EOL] mstack = MachineStack ( [ [number] , [number] ] ) [EOL] assert mstack == [ [number] , [number] ] [EOL] [EOL] @ staticmethod def test_mstack_append_single_element ( ) : [EOL] mstack = MachineStack ( ) [EOL] [EOL] mstack . append ( [number] ) [EOL] [EOL] assert mstack == [ [number] ] [EOL] [EOL] @ staticmethod def test_mstack_append_multiple_elements ( ) : [EOL] [EOL] mstack = MachineStack ( ) [EOL] [EOL] for i in range ( mstack . STACK_LIMIT ) : [EOL] mstack . append ( [number] ) [EOL] [EOL] with pytest . raises ( StackOverflowException ) : [EOL] mstack . append ( [number] ) [EOL] [EOL] @ staticmethod def test_mstack_pop ( ) : [EOL] mstack = MachineStack ( [ [number] ] ) [EOL] [EOL] assert mstack . pop ( ) == [number] [EOL] [EOL] with pytest . raises ( StackUnderflowException ) : [EOL] mstack . pop ( ) [EOL] [EOL] @ staticmethod def test_mstack_no_support_add ( ) : [EOL] mstack = MachineStack ( [ [number] , [number] ] ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] mstack + [ [number] ] [EOL] [EOL] @ staticmethod def test_mstack_no_support_iadd ( ) : [EOL] mstack = MachineStack ( ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] mstack += mstack [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0 $mythril.laser.ethereum.state.machine_state.MachineStack$ 0
	0
import pytest [EOL] from mythril . laser . ethereum . strategy . extensions . bounded_loops import ( BoundedLoopsStrategy , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ [number] , [number] , [number] , [number] ] , [number] ) , ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , ( [ [number] , [number] , [number] , [number] ] , [number] ) , ( [ [number] , [number] , [number] ] * [number] , [number] ) , ( [ [number] , [number] , [number] ] + list ( range ( [number] , [number] ) ) * [number] , [number] ) , ( [ [number] , [number] , [number] ] , [number] ) , ( [ [number] ] * [number] , [number] ) , ] , ) def test_loop_count ( trace , count ) : [EOL] assert count == BoundedLoopsStrategy . get_loop_count ( trace ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Any [EOL] import typing [EOL] import mythril [EOL] from mythril . laser . smt . solver . independence_solver import ( _get_expr_variables , DependenceBucket , DependenceMap , IndependenceSolver , ) [EOL] from mythril . laser . smt import symbol_factory [EOL] [EOL] import z3 [EOL] [EOL] [EOL] def test_get_expr_variables ( ) : [EOL] [comment] [EOL] x = z3 . Bool ( [string] ) [EOL] y = z3 . BitVec ( [string] , [number] ) [EOL] z = z3 . BitVec ( [string] , [number] ) [EOL] b = z3 . BitVec ( [string] , [number] ) [EOL] expression = z3 . If ( x , y , z + b ) [EOL] [EOL] [comment] [EOL] variables = list ( map ( str , _get_expr_variables ( expression ) ) ) [EOL] [EOL] [comment] [EOL] assert str ( x ) in variables [EOL] assert str ( y ) in variables [EOL] assert str ( z ) in variables [EOL] assert str ( b ) in variables [EOL] [EOL] [EOL] def test_get_expr_variables_num ( ) : [EOL] [comment] [EOL] b = z3 . BitVec ( [string] , [number] ) [EOL] expression = b + z3 . BitVecVal ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] variables = _get_expr_variables ( expression ) [EOL] [EOL] [comment] [EOL] assert [ b ] == variables [EOL] [EOL] [EOL] def test_create_bucket ( ) : [EOL] [comment] [EOL] x = z3 . Bool ( [string] ) [EOL] [EOL] [comment] [EOL] bucket = DependenceBucket ( [ x ] , [ x ] ) [EOL] [EOL] [comment] [EOL] assert [ x ] == bucket . variables [EOL] assert [ x ] == bucket . conditions [EOL] [EOL] [EOL] def test_dependence_map ( ) : [EOL] [comment] [EOL] x = z3 . BitVec ( [string] , [number] ) [EOL] y = z3 . BitVec ( [string] , [number] ) [EOL] z = z3 . BitVec ( [string] , [number] ) [EOL] a = z3 . BitVec ( [string] , [number] ) [EOL] b = z3 . BitVec ( [string] , [number] ) [EOL] [EOL] conditions = [ x > y , y == z , a == b ] [EOL] [EOL] dependence_map = DependenceMap ( ) [EOL] [EOL] [comment] [EOL] for condition in conditions : [EOL] dependence_map . add_condition ( condition ) [EOL] [EOL] [comment] [EOL] assert [number] == len ( dependence_map . buckets ) [EOL] [EOL] assert x in dependence_map . buckets [ [number] ] . variables [EOL] assert y in dependence_map . buckets [ [number] ] . variables [EOL] assert z in dependence_map . buckets [ [number] ] . variables [EOL] assert len ( set ( dependence_map . buckets [ [number] ] . variables ) ) == [number] [EOL] [EOL] assert conditions [ [number] ] in dependence_map . buckets [ [number] ] . conditions [EOL] assert conditions [ [number] ] in dependence_map . buckets [ [number] ] . conditions [EOL] [EOL] assert a in dependence_map . buckets [ [number] ] . variables [EOL] assert b in dependence_map . buckets [ [number] ] . variables [EOL] assert len ( set ( dependence_map . buckets [ [number] ] . variables ) ) == [number] [EOL] [EOL] assert conditions [ [number] ] in dependence_map . buckets [ [number] ] . conditions [EOL] [EOL] [EOL] def test_Independence_solver_unsat ( ) : [EOL] [comment] [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] y = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] z = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] [EOL] conditions = [ x > y , y == z , y != z , a == b ] [EOL] [EOL] solver = IndependenceSolver ( ) [EOL] [EOL] [comment] [EOL] solver . add ( * conditions ) [EOL] result = solver . check ( ) [EOL] [EOL] [comment] [EOL] assert z3 . unsat == result [EOL] [EOL] [EOL] def test_independence_solver_unsat_in_second_bucket ( ) : [EOL] [comment] [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] y = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] z = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] [EOL] conditions = [ x > y , y == z , a == b , a != b ] [EOL] [EOL] solver = IndependenceSolver ( ) [EOL] [EOL] [comment] [EOL] solver . add ( * conditions ) [EOL] result = solver . check ( ) [EOL] [EOL] [comment] [EOL] assert z3 . unsat == result [EOL] [EOL] [EOL] def test_independence_solver_sat ( ) : [EOL] [comment] [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] y = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] z = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] a = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] b = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] [EOL] conditions = [ x > y , y == z , a == b ] [EOL] [EOL] solver = IndependenceSolver ( ) [EOL] [EOL] [comment] [EOL] solver . add ( * conditions ) [EOL] result = solver . check ( ) [EOL] [EOL] [comment] [EOL] assert z3 . sat == result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from mythril . laser . smt import Solver , symbol_factory [EOL] import z3 [EOL] [EOL] [EOL] def test_decls ( ) : [EOL] [comment] [EOL] solver = Solver ( ) [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] expression = x == symbol_factory . BitVecVal ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] solver . add ( expression ) [EOL] result = solver . check ( ) [EOL] model = solver . model ( ) [EOL] [EOL] decls = model . decls ( ) [EOL] [EOL] [comment] [EOL] assert z3 . sat == result [EOL] assert x . raw . decl ( ) in decls [EOL] [EOL] [EOL] def test_get_item ( ) : [EOL] [comment] [EOL] solver = Solver ( ) [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] expression = x == symbol_factory . BitVecVal ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] solver . add ( expression ) [EOL] result = solver . check ( ) [EOL] model = solver . model ( ) [EOL] [EOL] x_concrete = model [ x . raw . decl ( ) ] [EOL] [EOL] [comment] [EOL] assert z3 . sat == result [EOL] assert [number] == x_concrete [EOL] [EOL] [EOL] def test_as_long ( ) : [EOL] [comment] [EOL] solver = Solver ( ) [EOL] x = symbol_factory . BitVecSym ( [string] , [number] ) [EOL] expression = x == symbol_factory . BitVecVal ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] solver . add ( expression ) [EOL] result = solver . check ( ) [EOL] model = solver . model ( ) [EOL] [EOL] x_concrete = model . eval ( x . raw ) . as_long ( ) [EOL] [EOL] [comment] [EOL] assert z3 . sat == result [EOL] assert [number] == x_concrete [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import mythril [EOL] from mythril . plugin import MythrilPluginLoader , MythrilPlugin [EOL] from mythril . plugin . loader import UnsupportedPluginType [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_typecheck_load ( ) : [EOL] [comment] [EOL] loader = MythrilPluginLoader ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] loader . load ( None ) [EOL] [EOL] [EOL] def test_unsupported_plugin_type ( ) : [EOL] [comment] [EOL] loader = MythrilPluginLoader ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( UnsupportedPluginType ) : [EOL] loader . load ( MythrilPlugin ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import mythril [EOL] from mythril . plugin . interface import MythrilCLIPlugin , MythrilPlugin [EOL] [EOL] [EOL] def test_construct_cli_plugin ( ) : [EOL] _ = MythrilCLIPlugin ( ) [EOL] [EOL] [EOL] def test_construct_mythril_plugin ( ) : [EOL] _ = MythrilPlugin [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0