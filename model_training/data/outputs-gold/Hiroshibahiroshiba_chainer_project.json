from typing import Any , List , Dict [EOL] import datetime [EOL] import builtins [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import copy [EOL] import datetime [EOL] import hashlib [EOL] import json [EOL] import subprocess [EOL] from pathlib import Path [EOL] from typing import Any , Dict [EOL] [EOL] base_command_default = [string] + [string] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , type = Path ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , default = base_command_default ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] recipe = json . load ( open ( args . recipe_json_path , encoding = [string] ) ) [EOL] recipe_each = recipe [ [string] ] [EOL] recipe_all = recipe [ [string] ] [EOL] base_config = json . load ( open ( args . base_config_json_path , encoding = [string] ) ) [EOL] [EOL] [EOL] def put_config_value ( config , recipe_key , value ) : [EOL] key_tree = recipe_key . split ( [string] ) [EOL] target = config [EOL] for key in key_tree [ : - [number] ] : [EOL] target = target [ key ] [EOL] [EOL] target [ key_tree [ - [number] ] ] = value [EOL] [EOL] [EOL] def make_key_chain ( key_chain , value , dist ) : [EOL] if not isinstance ( value , dict ) : [EOL] dist [ [string] . join ( key_chain ) ] = value [EOL] else : [EOL] for key in value . keys ( ) : [EOL] make_key_chain ( key_chain + [ key ] , value [ key ] , dist ) [EOL] [EOL] [EOL] def replace_name ( config ) : [EOL] _format = { } [EOL] make_key_chain ( [ ] , config , _format ) [EOL] [EOL] now = datetime . datetime . now ( ) [EOL] _format [ [string] ] = now . strftime ( [string] ) [EOL] _format [ [string] ] = hashlib . md5 ( bytes ( str ( now ) , [string] ) ) . hexdigest ( ) [ : [number] ] [EOL] [EOL] config [ [string] ] [ [string] ] = config [ [string] ] [ [string] ] . format ( ** _format ) [EOL] [EOL] [EOL] num_task = min ( len ( list ( value ) ) for value in recipe_each . values ( ) ) [EOL] command_list = [ ] [EOL] [EOL] for i in range ( num_task ) : [EOL] config = copy . deepcopy ( base_config ) [EOL] [EOL] for recipe_key in recipe_all . keys ( ) : [EOL] put_config_value ( config , recipe_key , recipe_all [ recipe_key ] ) [EOL] [EOL] for recipe_key in recipe_each . keys ( ) : [EOL] put_config_value ( config , recipe_key , recipe_each [ recipe_key ] [ i ] ) [EOL] [EOL] made_recipe_path = [string] . format ( datetime . datetime . now ( ) . strftime ( [string] ) , i ) [EOL] with open ( made_recipe_path , [string] , encoding = [string] ) as f : [EOL] json . dump ( config , f , indent = [number] , sort_keys = True , ensure_ascii = False ) [EOL] [EOL] replace_name ( config ) [EOL] [EOL] dist = { } [EOL] make_key_chain ( [ ] , config , dist ) [EOL] [EOL] dist [ [string] ] = args . output_dir / config [ [string] ] [ [string] ] [EOL] dist [ [string] ] = args . python_file_path [EOL] dist [ [string] ] = made_recipe_path [EOL] dist [ [string] ] = config [ [string] ] [ [string] ] [EOL] [EOL] command = args . base_command . format ( ** dist ) [EOL] command_list += [ command ] [EOL] [EOL] print ( config [ [string] ] [ [string] ] ) [EOL] [EOL] for command in command_list : [EOL] subprocess . check_output ( command , shell = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from setuptools import find_packages , setup [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( ) , url = [string] , author = [string] , author_email = [string] , install_requires = [ [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , List , Any [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import re [EOL] from pathlib import Path [EOL] [EOL] import fire [EOL] import numpy [EOL] [EOL] from project_name . config import create_from_json as create_config [EOL] from project_name . utility import save_arguments [EOL] [EOL] [EOL] def _extract_number ( f ) : [EOL] s = re . findall ( [string] , str ( f ) ) [EOL] return int ( s [ - [number] ] ) if s else - [number] [EOL] [EOL] [EOL] def _get_predictor_model_path ( model_dir , iteration = None , prefix = [string] , ) : [EOL] if iteration is None : [EOL] paths = model_dir . glob ( prefix + [string] ) [EOL] model_path = list ( sorted ( paths , key = _extract_number ) ) [ - [number] ] [EOL] else : [EOL] model_path = model_dir / ( prefix + [string] . format ( iteration ) ) [EOL] return model_path [EOL] [EOL] [EOL] def generate ( model_dir_path , model_iteration , model_config_path , output_dir_path = [string] , gpu = None , ) : [EOL] model_dir = Path ( model_dir_path ) [EOL] output_dir = Path ( output_dir_path ) [EOL] [EOL] output_dir . mkdir ( exist_ok = True ) [EOL] [EOL] output = output_dir / model_dir . name [EOL] output . mkdir ( exist_ok = True ) [EOL] [EOL] save_arguments ( generate , locals ( ) , output / [string] ) [EOL] [EOL] config = create_config ( model_config_path ) [EOL] model_path = _get_predictor_model_path ( model_dir = model_dir , iteration = model_iteration , ) [EOL] [EOL] data_list = [ ] [EOL] numpy . random . RandomState ( config . dataset . seed ) . shuffle ( data_list ) [EOL] texts = data_list [ : config . dataset . num_test ] [EOL] [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] fire . Fire ( generate ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . chainer_extension_utility import TensorBoardReport [EOL]	0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import project_name [EOL] import typing [EOL] import functools [EOL] from functools import partial [EOL] from typing import Any , List [EOL] [EOL] import chainer [EOL] import numpy [EOL] [EOL] from project_name . config import DatasetConfig [EOL] [EOL] [EOL] class SampleDataset ( chainer . dataset . DatasetMixin ) : [EOL] def __init__ ( self , data_list , ) : [EOL] self . data_list = data_list [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . data_list ) [EOL] [EOL] def get_example ( self , i ) : [EOL] return dict ( input = self . data_list [ i ] [ [string] ] , target = self . data_list [ i ] [ [string] ] , ) [EOL] [EOL] [EOL] def create ( config ) : [EOL] data_list = [ ] [EOL] numpy . random . RandomState ( config . seed ) . shuffle ( data_list ) [EOL] [EOL] num_test = config . num_test [EOL] trains = data_list [ num_test : ] [EOL] tests = data_list [ : num_test ] [EOL] evals = trains [ : num_test ] [EOL] [EOL] _Dataset = partial ( SampleDataset , data_list = data_list , ) [EOL] return { [string] : _Dataset ( trains ) , [string] : _Dataset ( tests ) , [string] : _Dataset ( evals ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Callable , Any , NamedTuple [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import inspect [EOL] import json [EOL] from pathlib import Path [EOL] from typing import Any , Callable , Dict , NamedTuple [EOL] [EOL] [EOL] def namedtuple_to_dict ( o ) : [EOL] return { k : v if not hasattr ( v , [string] ) else namedtuple_to_dict ( v ) for k , v in o . _asdict ( ) . items ( ) } [EOL] [EOL] [EOL] class JSONEncoder ( json . JSONEncoder ) : [EOL] def default ( self , o ) : [EOL] if isinstance ( o , Path ) : [EOL] return str ( o ) [EOL] if hasattr ( o , [string] ) : [EOL] return o . _asdict ( ) [EOL] return json . JSONEncoder . default ( self , o ) [EOL] [EOL] [EOL] def save_arguments ( func , arguments , path ) : [EOL] args = inspect . getfullargspec ( func ) . args [EOL] obj = { k : v for k , v in arguments . items ( ) if k in args } [EOL] json . dump ( obj , path . open ( [string] ) , indent = [number] , sort_keys = True , cls = JSONEncoder ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from pathlib import Path [EOL] from typing import Any , Dict , List , NamedTuple , Optional , Union [EOL] [EOL] from project_name . utility import JSONEncoder , namedtuple_to_dict [EOL] [EOL] [EOL] class DatasetConfig ( NamedTuple ) : [EOL] seed = ... [EOL] num_test = ... [EOL] [EOL] [EOL] class NetworkConfig ( NamedTuple ) : [EOL] pass [EOL] [EOL] [EOL] class ModelConfig ( NamedTuple ) : [EOL] pass [EOL] [EOL] [EOL] class TrainConfig ( NamedTuple ) : [EOL] batchsize = ... [EOL] gpu = ... [EOL] log_iteration = ... [EOL] snapshot_iteration = ... [EOL] stop_iteration = ... [EOL] optimizer = ... [EOL] optimizer_gradient_clipping = ... [EOL] linear_shift = ... [EOL] [EOL] [EOL] class ProjectConfig ( NamedTuple ) : [EOL] name = ... [EOL] tags = ... [EOL] [EOL] [EOL] class Config ( NamedTuple ) : [EOL] dataset = ... [EOL] network = ... [EOL] model = ... [EOL] train = ... [EOL] project = ... [EOL] [EOL] def save_as_json ( self , path ) : [EOL] d = namedtuple_to_dict ( self ) [EOL] json . dump ( d , open ( path , [string] ) , indent = [number] , sort_keys = True , cls = JSONEncoder ) [EOL] [EOL] [EOL] def create_from_json ( s ) : [EOL] return create ( json . load ( open ( s ) ) ) [EOL] [EOL] [EOL] def create ( d ) : [EOL] backward_compatible ( d ) [EOL] return Config ( dataset = DatasetConfig ( seed = d [ [string] ] [ [string] ] , num_test = d [ [string] ] [ [string] ] , ) , network = NetworkConfig ( ) , model = ModelConfig ( ) , train = TrainConfig ( batchsize = d [ [string] ] [ [string] ] , gpu = d [ [string] ] [ [string] ] , log_iteration = d [ [string] ] [ [string] ] , snapshot_iteration = d [ [string] ] [ [string] ] , stop_iteration = d [ [string] ] [ [string] ] , optimizer = d [ [string] ] [ [string] ] , optimizer_gradient_clipping = d [ [string] ] [ [string] ] , linear_shift = d [ [string] ] [ [string] ] , ) , project = ProjectConfig ( name = d [ [string] ] [ [string] ] , tags = d [ [string] ] [ [string] ] , ) ) [EOL] [EOL] [EOL] def backward_compatible ( d ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.float$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $DatasetConfig$ 0 0 0 $NetworkConfig$ 0 0 0 $ModelConfig$ 0 0 0 $TrainConfig$ 0 0 0 $ProjectConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import project_name [EOL] import chainer [EOL] import typing [EOL] import chainer [EOL] import chainer . functions as F [EOL] from chainer import Chain [EOL] [EOL] from project_name . config import ModelConfig , NetworkConfig [EOL] from project_name . network import SampleNetwork [EOL] [EOL] [EOL] def create_predictor ( config ) : [EOL] predictor = SampleNetwork ( ) [EOL] return predictor [EOL] [EOL] [EOL] class Model ( Chain ) : [EOL] def __init__ ( self , model_config , predictor ) : [EOL] super ( ) . __init__ ( ) [EOL] self . model_config = model_config [EOL] with self . init_scope ( ) : [EOL] self . predictor = predictor [EOL] [EOL] def __call__ ( self , input , target , ) : [EOL] output = self . predictor ( input ) [EOL] loss = F . softmax_cross_entropy ( output , target ) [EOL] [EOL] chainer . report ( dict ( loss = loss , ) , self ) [EOL] return loss [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $project_name.config.ModelConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $project_name.config.ModelConfig$ 0 $project_name.config.ModelConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $chainer.Variable$ 0 $chainer.Variable$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $chainer.Variable$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $chainer.Variable$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0
import pathlib [EOL] import builtins [EOL] import project_name [EOL] from pathlib import Path [EOL] [EOL] import chainer [EOL] from chainer import cuda [EOL] [EOL] from project_name . config import Config [EOL] from project_name . model import create_predictor [EOL] [EOL] [EOL] class Generator ( object ) : [EOL] def __init__ ( self , config , model_path , gpu = None , ) : [EOL] self . config = config [EOL] self . model_path = model_path [EOL] self . gpu = gpu [EOL] [EOL] self . predictor = predictor = create_predictor ( config . network ) [EOL] chainer . serializers . load_npz ( str ( model_path ) , predictor ) [EOL] [EOL] if self . gpu is not None : [EOL] predictor . to_gpu ( self . gpu ) [EOL] cuda . get_device_from_id ( self . gpu ) . use ( ) [EOL] [EOL] chainer . global_config . train = False [EOL] chainer . global_config . enable_backprop = False [EOL] [EOL] def generate ( self , ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $project_name.config.Config$ 0 $pathlib.Path$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $project_name.config.Config$ 0 $project_name.config.Config$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $project_name.config.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union [EOL] import numpy [EOL] import chainer [EOL] import typing [EOL] from typing import Union [EOL] [EOL] import chainer [EOL] import numpy [EOL] [EOL] [EOL] class SampleNetwork ( chainer . Chain ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] with self . init_scope ( ) : [EOL] pass [EOL] [EOL] def __call__ ( self , xs ) : [EOL] [docstring] [EOL] return xs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[chainer.Variable,numpy.ndarray]$ 0 0 0 0 0 0 $typing.Union[chainer.Variable,numpy.ndarray]$ 0