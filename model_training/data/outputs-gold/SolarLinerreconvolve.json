from bin import setup [EOL] from bin . create import CreateCommand [EOL] from bin . process import ProcessCommand [EOL] [EOL] [EOL] def run ( ) : [EOL] args , logger , command = setup ( [ CreateCommand ( ) , ProcessCommand ( ) ] ) [EOL] return command . run ( args ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] exit ( run ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] from lib import __version__ [EOL] [EOL] setup ( name = [string] , version = __version__ , author = [string] , author_email = [string] , description = [string] , long_description = open ( [string] ) . read ( ) , url = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , install_requires = [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import numpy [EOL] import builtins [EOL] import json [EOL] import math [EOL] import os [EOL] [EOL] import numpy as np [EOL] import scipy . signal as sig [EOL] from scipy . io import wavfile [EOL] [EOL] [EOL] class Probe : [EOL] def __init__ ( self , sample_rate ) : [EOL] if sample_rate < [number] : [EOL] raise ValueError ( [string] ) [EOL] self . sample_rate = sample_rate [EOL] [EOL] def generate ( self , amplitude = [number] , length = [number] ) : [EOL] w1 = [number] [EOL] w2 = self . sample_rate / [number] [EOL] t = np . linspace ( [number] , length , np . ceil ( self . sample_rate * length ) ) [EOL] K = [number] * math . pi * ( w1 * length ) / np . log ( w2 / w1 ) [EOL] L = length / np . log ( w2 / w1 ) [EOL] amp = amplitude * np . subtract ( [number] , np . exp ( - [number] * t ) ) [ - [number] : : - [number] ] [EOL] return np . sin ( K * ( np . exp ( t / L ) - [number] ) ) * amp [EOL] [EOL] def process ( self , generated , recorded ) : [EOL] w1 = [number] [EOL] w2 = self . sample_rate / [number] [EOL] [EOL] sweep_smplen = int ( generated . size ) [EOL] k_end = [number] ** ( ( - [number] * np . log2 ( w2 / w1 ) ) / [number] ) [EOL] k = np . log ( k_end ) / sweep_smplen [EOL] [EOL] attenuation = np . exp ( np . arange ( sweep_smplen ) * k ) [EOL] divisor = generated [ - [number] : : - [number] ] * attenuation [EOL] [EOL] if len ( np . shape ( recorded ) ) == [number] : [EOL] impulse_out = sig . wiener ( sig . fftconvolve ( recorded , divisor ) ) [ sweep_smplen : ] [EOL] sample_max = np . max ( np . abs ( impulse_out ) ) [EOL] return np . float32 ( impulse_out ) / sample_max [EOL] elif len ( np . shape ( recorded ) ) == [number] : [EOL] reshaped_record = np . array ( list ( zip ( * recorded ) ) ) [EOL] impulse_out = list ( ) [EOL] for x in reshaped_record : [EOL] impulse_out . append ( sig . wiener ( sig . fftconvolve ( x , divisor ) ) [ sweep_smplen : ] ) [EOL] sample_max = np . max ( np . abs ( impulse_out ) ) [EOL] return np . float32 ( np . array ( list ( zip ( * impulse_out ) ) ) / sample_max ) [EOL] else : [EOL] raise ValueError ( f" [string] { np . shape ( recorded ) }" ) [EOL] [EOL] def write ( self , filename , arr ) : [EOL] scaled = np . float32 ( arr ) [EOL] wavfile . write ( filename , self . sample_rate , scaled ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $numpy.ndarray$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $numpy.ndarray$ 0 0 0 $typing.Any$ 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0
from typing import Tuple [EOL] import typing [EOL] __version__ = ( [number] , [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import argparse [EOL] import abc [EOL] from argparse import ArgumentParser , Namespace [EOL] import logging [EOL] import sys [EOL] from typing import Dict , List , Optional , Type [EOL] [EOL] from reconvolve import __version__ [EOL] [EOL] [EOL] class BaseCommand ( abc . ABC ) : [EOL] [docstring] [EOL] name = ... [EOL] description = ... [EOL] [EOL] @ abc . abstractmethod def setup ( self , parser ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ abc . abstractmethod def run ( self , args ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ classmethod def get_name ( cls ) : [EOL] if [string] in cls . __dict__ and cls . name is not None : [EOL] return cls . name [EOL] return cls . __class__ . __name__ [EOL] [EOL] @ classmethod def get_description ( cls ) : [EOL] if [string] in cls . __dict__ and cls . description is not None : [EOL] return cls . description [EOL] return cls . __doc__ [EOL] [EOL] [EOL] def setup_parser ( ) : [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , version = f" [string] { [string] . join ( str ( v ) for v in __version__ ) }" ) [EOL] [EOL] return parser [EOL] [EOL] [EOL] def setup_logging ( verbosity = logging . ERROR ) : [EOL] logger = logging . getLogger ( [string] ) [EOL] sh = logging . StreamHandler ( ) [EOL] sh . setLevel ( verbosity ) [EOL] logger . addHandler ( sh ) [EOL] logger . setLevel ( verbosity ) [EOL] [EOL] [EOL] def setup ( commands ) : [EOL] parser = setup_parser ( ) [EOL] subparsers = parser . add_subparsers ( title = [string] , help = [string] ) [EOL] cmd_dict = dict ( ) [EOL] for cmd in commands : [EOL] name = cmd . get_name ( ) [EOL] subparser = subparsers . add_parser ( name , help = cmd . get_description ( ) ) [EOL] subparser . set_defaults ( command_name = name ) [EOL] cmd . setup ( subparser ) [EOL] cmd_dict [ name ] = cmd [EOL] [EOL] args = parser . parse_args ( ) [EOL] verbosity = logging . ERROR - args . v * [number] [EOL] logger = setup_logging ( args . v ) [EOL] if [string] not in args : [EOL] print ( [string] , file = sys . stderr ) [EOL] parser . print_usage ( sys . stderr ) [EOL] exit ( [number] ) [EOL] return args , logger , cmd_dict [ args . command_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import reconvolve [EOL] import argparse [EOL] from argparse import ArgumentParser , Namespace , FileType [EOL] import logging [EOL] [EOL] import numpy as np [EOL] import scipy . signal as sig [EOL] from scipy . io import wavfile [EOL] [EOL] from reconvolve . probe import Probe [EOL] from . import BaseCommand [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ProcessCommand ( BaseCommand ) : [EOL] name = [string] [EOL] description = [string] [EOL] [EOL] def setup ( self , parser ) : [EOL] parser . add_argument ( [string] , type = FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = FileType ( [string] ) , help = [string] ) [EOL] parser . add_argument ( [string] , type = FileType ( [string] ) , help = [string] ) [EOL] [EOL] def run ( self , args ) : [EOL] sweep_rate , sweep_in = wavfile . read ( args . sweep ) [EOL] record_rate , record_in = wavfile . read ( args . record ) [EOL] [EOL] if sweep_rate != record_rate : [EOL] raise ValueError ( [string] ) [EOL] [EOL] try : [EOL] p = Probe ( sweep_rate ) [EOL] result = p . process ( np . float32 ( sweep_in ) , np . float32 ( record_in ) ) [EOL] p . write ( args . output , result ) [EOL] return [number] [EOL] except ValueError as e : [EOL] logger . critical ( f" [string] { str ( e ) }" ) [EOL] return [number] [EOL] except : [EOL] logger . critical ( [string] ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $reconvolve.probe.Probe$ 0 0 0 0 0 0 $typing.Any$ 0 $reconvolve.probe.Probe$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $reconvolve.probe.Probe$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import reconvolve [EOL] import argparse [EOL] from argparse import ArgumentParser , Namespace [EOL] import logging [EOL] [EOL] from . import BaseCommand [EOL] from reconvolve . probe import Probe [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class CreateCommand ( BaseCommand ) : [EOL] name = [string] [EOL] description = [string] [EOL] def setup ( self , parser ) : [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = float , nargs = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = float , nargs = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = int ( [number] ) , help = [string] ) [EOL] [EOL] def run ( self , args ) : [EOL] logger . debug ( repr ( args . __dict__ ) ) [EOL] p = Probe ( args . samplerate ) [EOL] array = p . generate ( args . amplitude , args . length ) [EOL] p . write ( args . file , array ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $reconvolve.probe.Probe$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 $reconvolve.probe.Probe$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $reconvolve.probe.Probe$ 0 0 0 $argparse.Namespace$ 0 0 0 $typing.Any$ 0 0 0 0 0