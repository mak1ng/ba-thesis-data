import pymysql [EOL] from __future__ import print_function [EOL] [EOL] import os [EOL] import pymysql . cursors [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] RDS_ENDPOINT = [string] [EOL] USER = [string] [EOL] PASS = [string] [EOL] DB_NAME = [string] [EOL] [EOL] [EOL] def get_conn ( ) : [EOL] conn = pymysql . connect ( host = RDS_ENDPOINT , user = USER , password = PASS , db = DB_NAME , cursorclass = pymysql . cursors . DictCursor ) [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] if pymysql . connections : [EOL] print ( [string] ) [EOL] get_conn ( ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] import json [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] print ( json . dumps ( event ) ) [EOL] return { [string] : event [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] from __future__ import print_function [EOL] [EOL] import boto3 [EOL] import json [EOL] import logging [EOL] [EOL] from base64 import b64decode [EOL] from urllib2 import Request , urlopen , URLError , HTTPError [EOL] [EOL] [EOL] ENCRYPTED_HOOK_URL = [string] [EOL] SLACK_CHANNEL = [string] [EOL] [EOL] HOOK_URL = [string] + boto3 . client ( [string] ) . decrypt ( CiphertextBlob = b64decode ( ENCRYPTED_HOOK_URL ) ) [ [string] ] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] logger . info ( [string] + str ( event ) ) [EOL] message = json . loads ( event [ [string] ] [ [number] ] [ [string] ] [ [string] ] ) [EOL] logger . info ( [string] + str ( message ) ) [EOL] [EOL] alarm_name = message [ [string] ] [EOL] [comment] [EOL] new_state = message [ [string] ] [EOL] reason = message [ [string] ] [EOL] [EOL] slack_message = { [string] : SLACK_CHANNEL , [string] : [string] % ( alarm_name , new_state , reason ) } [EOL] [EOL] req = Request ( HOOK_URL , json . dumps ( slack_message ) ) [EOL] try : [EOL] response = urlopen ( req ) [EOL] response . read ( ) [EOL] logger . info ( [string] , slack_message [ [string] ] ) [EOL] except HTTPError as e : [EOL] logger . error ( [string] , e . code , e . reason ) [EOL] except URLError as e : [EOL] logger . error ( [string] , e . reason ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] import boto3 [EOL] import logging [EOL] [EOL] SPOT_FLEET_REQUEST_ID = os . environ [ [string] ] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def lambda_handler ( event , context ) : [EOL] client = boto3 . client ( [string] ) [EOL] resp = client . modify_spot_fleet_request ( SpotFleetRequestId = SPOT_FLEET_REQUEST_ID , TargetCapacity = [number] ) [EOL] logger . info ( resp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import logging [EOL] import logging [EOL] import requests [EOL] [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] logger . info ( [string] , event , context ) [EOL] [EOL] url = [string] [EOL] [EOL] raw = requests . get ( url ) [EOL] logger . info ( [string] , raw ) [EOL] result = raw . json ( ) [EOL] [EOL] logger . info ( [string] , result [ [string] ] ) [EOL] [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event ) [EOL] [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] import boto3 [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] [EOL] if event [ [string] ] [ [number] ] [ [string] ] != [string] : [EOL] return [EOL] [EOL] client . start_execution ( stateMachineArn = os . environ [ [string] ] , input = json . dumps ( { [string] : event [ [string] ] [ [number] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] import boto3 [EOL] [EOL] client = boto3 . resource ( [string] ) . Table ( os . environ [ [string] ] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] [EOL] iterator = event [ [string] ] [EOL] [EOL] result = client . get_item ( Key = { [string] : event [ [string] ] } ) [EOL] print ( result ) [EOL] [EOL] if not result . get ( [string] ) : [EOL] return { [string] : False } [EOL] [EOL] index = iterator [ [string] ] [EOL] step = iterator [ [string] ] [EOL] count = iterator [ [string] ] [EOL] index += step [EOL] [EOL] if index <= count : [EOL] continue_ = True [EOL] else : [EOL] continue_ = False [EOL] [EOL] return { [string] : index , [string] : step , [string] : count , [string] : continue_ } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event ) [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import cfnresponse [EOL] import boto3 [EOL] import json [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] if event [ [string] ] == [string] : [EOL] cfnresponse . send ( event , context , cfnresponse . SUCCESS , { } ) [EOL] function_name = event [ [string] ] [ [string] ] [EOL] try : [EOL] code_sha256 = client . get_function ( FunctionName = function_name ) [ [string] ] [ [string] ] [EOL] except Exception as e : [EOL] print ( e ) [EOL] cfnresponse . send ( event , context , cfnresponse . FAILED , { } ) [EOL] else : [EOL] try : [EOL] resp = client . publish_version ( FunctionName = function_name , CodeSha256 = code_sha256 ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] cfnresponse . send ( event , context , cfnresponse . FAILED , { } ) [EOL] else : [EOL] response_data = { [string] : json . dumps ( resp ) } [EOL] cfnresponse . send ( event , context , cfnresponse . SUCCESS , response_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List , Union [EOL] import typing [EOL] import datetime [EOL] from datetime import datetime [EOL] import boto3 [EOL] [EOL] FAILURE = [number] [EOL] SUCCESS = [number] [EOL] cw = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] metric_data = [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] } ] , [string] : datetime . utcnow ( ) , [string] : float ( FAILURE ) , [string] : [string] } ] [EOL] cw . put_metric_data ( Namespace = [string] , MetricData = metric_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( [string] . format ( event ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import inject [EOL] [EOL] from func1 import Func1 [EOL] import config [EOL] [EOL] inject . configure ( config . cloud ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] return Func1 ( event , context ) . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import boto3 [EOL] [EOL] [EOL] def cloud ( binder ) : [EOL] binder . bind ( boto3 . resource ( [string] ) , boto3 . resource ( [string] ) ) [EOL] [EOL] [EOL] def localhost ( binder ) : [EOL] binder . bind ( boto3 . resource ( [string] ) , boto3 . resource ( [string] , endpoint_url = [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import inject [EOL] import sam [EOL] import logging [EOL] import typing [EOL] import threading [EOL] [docstring] [EOL] __version__ = [string] [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] __url__ = [string] [EOL] [EOL] import logging [EOL] import threading [EOL] import inspect [EOL] import sys [EOL] from functools import wraps [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] _INJECTOR = None [comment] [EOL] _INJECTOR_LOCK = threading . RLock ( ) [comment] [EOL] _BINDING_LOCK = threading . RLock ( ) [comment] [EOL] [EOL] [EOL] def configure ( config = None ) : [EOL] [docstring] [EOL] global _INJECTOR [EOL] [EOL] with _INJECTOR_LOCK : [EOL] if _INJECTOR : [EOL] raise InjectorException ( [string] ) [EOL] [EOL] _INJECTOR = Injector ( config ) [EOL] logger . debug ( [string] , config ) [EOL] return _INJECTOR [EOL] [EOL] [EOL] def configure_once ( config = None ) : [EOL] [docstring] [EOL] with _INJECTOR_LOCK : [EOL] if _INJECTOR : [EOL] return _INJECTOR [EOL] [EOL] return configure ( config ) [EOL] [EOL] [EOL] def clear_and_configure ( config = None ) : [EOL] [docstring] [EOL] with _INJECTOR_LOCK : [EOL] clear ( ) [EOL] return configure ( config ) [EOL] [EOL] [EOL] def is_configured ( ) : [EOL] [docstring] [EOL] with _INJECTOR_LOCK : [EOL] return _INJECTOR is not None [EOL] [EOL] [EOL] def clear ( ) : [EOL] [docstring] [EOL] global _INJECTOR [EOL] [EOL] with _INJECTOR_LOCK : [EOL] if _INJECTOR is None : [EOL] return [EOL] [EOL] _INJECTOR = None [EOL] logger . debug ( [string] ) [EOL] [EOL] [EOL] def instance ( cls ) : [EOL] [docstring] [EOL] return get_injector_or_die ( ) . get_instance ( cls ) [EOL] [EOL] [EOL] def attr ( cls ) : [EOL] [docstring] [EOL] return _AttributeInjection ( cls ) [EOL] [EOL] [EOL] def param ( name , cls = None ) : [EOL] [docstring] [EOL] return _ParameterInjection ( name , cls ) [EOL] [EOL] [EOL] def params ( ** args_to_classes ) : [EOL] [docstring] [EOL] return _ParametersInjection ( ** args_to_classes ) [EOL] [EOL] [EOL] def get_injector ( ) : [EOL] [docstring] [EOL] return _INJECTOR [EOL] [EOL] [EOL] def get_injector_or_die ( ) : [EOL] [docstring] [EOL] injector = _INJECTOR [EOL] if not injector : [EOL] raise InjectorException ( [string] ) [EOL] [EOL] return injector [EOL] [EOL] [EOL] class Binder ( object ) : [EOL] def __init__ ( self ) : [EOL] self . _bindings = { } [EOL] [EOL] def install ( self , config ) : [EOL] [docstring] [EOL] config ( self ) [EOL] return self [EOL] [EOL] def bind ( self , cls , instance ) : [EOL] [docstring] [EOL] self . _check_class ( cls ) [EOL] self . _bindings [ cls ] = lambda : instance [EOL] logger . debug ( [string] , cls , instance ) [EOL] return self [EOL] [EOL] def bind_to_constructor ( self , cls , constructor ) : [EOL] [docstring] [EOL] self . _check_class ( cls ) [EOL] if constructor is None : [EOL] raise InjectorException ( [string] % cls ) [EOL] [EOL] self . _bindings [ cls ] = _ConstructorBinding ( constructor ) [EOL] logger . debug ( [string] , cls , constructor ) [EOL] return self [EOL] [EOL] def bind_to_provider ( self , cls , provider ) : [EOL] [docstring] [EOL] self . _check_class ( cls ) [EOL] if provider is None : [EOL] raise InjectorException ( [string] % cls ) [EOL] [EOL] self . _bindings [ cls ] = provider [EOL] logger . debug ( [string] , cls , provider ) [EOL] return self [EOL] [EOL] def _check_class ( self , cls ) : [EOL] if cls is None : [EOL] raise InjectorException ( [string] ) [EOL] [EOL] if cls in self . _bindings : [EOL] raise InjectorException ( [string] % cls ) [EOL] [EOL] [EOL] class Injector ( object ) : [EOL] def __init__ ( self , config = None ) : [EOL] if config : [EOL] binder = Binder ( ) [EOL] config ( binder ) [EOL] self . _bindings = dict ( binder . _bindings ) [EOL] else : [EOL] self . _bindings = { } [EOL] [EOL] def get_instance ( self , cls ) : [EOL] [docstring] [EOL] binding = self . _bindings . get ( cls ) [EOL] if binding : [EOL] return binding ( ) [EOL] [EOL] [comment] [EOL] with _BINDING_LOCK : [EOL] binding = self . _bindings . get ( cls ) [EOL] if binding : [EOL] return binding ( ) [EOL] [EOL] if not callable ( cls ) : [EOL] raise InjectorException ( [string] % cls ) [EOL] [EOL] instance = cls ( ) [EOL] self . _bindings [ cls ] = lambda : instance [EOL] [EOL] logger . debug ( [string] , cls , instance ) [EOL] return instance [EOL] [EOL] [EOL] class InjectorException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class _ConstructorBinding ( object ) : [EOL] def __init__ ( self , constructor ) : [EOL] self . _constructor = constructor [EOL] self . _created = False [EOL] self . _instance = None [EOL] [EOL] def __call__ ( self ) : [EOL] if self . _created : [EOL] return self . _instance [EOL] [EOL] with _BINDING_LOCK : [EOL] if self . _created : [EOL] return self . _instance [EOL] [EOL] self . _instance = self . _constructor ( ) [EOL] self . _created = True [EOL] [EOL] return self . _instance [EOL] [EOL] [EOL] class _AttributeInjection ( object ) : [EOL] def __init__ ( self , cls ) : [EOL] self . _cls = cls [EOL] [EOL] def __get__ ( self , obj , owner ) : [EOL] return instance ( self . _cls ) [EOL] [EOL] [EOL] class _ParameterInjection ( object ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , name , cls = None ) : [EOL] self . _name = name [EOL] self . _cls = cls [EOL] [EOL] def __call__ ( self , func ) : [EOL] @ wraps ( func ) def injection_wrapper ( * args , ** kwargs ) : [EOL] if not self . _name in kwargs : [EOL] kwargs [ self . _name ] = instance ( self . _cls or self . _name ) [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return injection_wrapper [EOL] [EOL] [EOL] class _ParametersInjection ( object ) : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . _params = kwargs [EOL] [EOL] def __call__ ( self , func ) : [EOL] if sys . version_info . major == [number] : [EOL] arg_names = inspect . getargspec ( func ) . args [EOL] else : [EOL] arg_names = inspect . getfullargspec ( func ) . args [EOL] params = self . _params [EOL] [EOL] @ wraps ( func ) def injection_wrapper ( * args , ** kwargs ) : [EOL] [comment] [EOL] additional_args = [ ] [EOL] [EOL] [comment] [EOL] i = len ( args ) [EOL] while i < len ( arg_names ) : [EOL] arg_name = arg_names [ i ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if arg_name not in params or arg_name in kwargs : [EOL] break [EOL] [EOL] [comment] [EOL] additional_args . append ( instance ( params [ arg_name ] ) ) [EOL] i += [number] [EOL] [EOL] if additional_args : [EOL] args += tuple ( additional_args ) [EOL] [EOL] [comment] [EOL] used_args = arg_names [ : i ] [EOL] for name , cls in params . items ( ) : [EOL] if not name in kwargs and not name in used_args : [EOL] kwargs [ name ] = instance ( cls ) [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return injection_wrapper [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $threading._RLock$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $threading._RLock$ 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aws-sam.di-python-inject.src.handlers.func.inject.Binder$ 0 0 0 0 0 0 0 $aws-sam.di-python-inject.src.handlers.func.inject.Binder$ 0 0 0 0 0 0 0 0 $aws-sam.di-python-inject.src.handlers.func.inject.Binder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $threading._RLock$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $threading._RLock$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Dict [EOL] import inject [EOL] import typing [EOL] import sam [EOL] import os [EOL] import uuid [EOL] [EOL] import boto3 [EOL] import inject [EOL] [EOL] [EOL] class Func1 ( object ) : [EOL] dynamodb = inject . attr ( boto3 . resource ( [string] ) ) [EOL] [EOL] def __init__ ( self , event , context ) : [EOL] self . event = event [EOL] self . context = context [EOL] self . table_name = os . getenv ( [string] ) [EOL] [EOL] def _put_item ( self ) : [EOL] item = { [string] : str ( uuid . uuid4 ( ) ) } [EOL] return self . dynamodb . Table ( self . table_name ) . put_item ( Item = item ) [EOL] [EOL] def main ( self ) : [EOL] return self . _put_item ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( Func1 ( { } , { } ) . main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import boto3 [EOL] import pytest [EOL] [EOL] from func1 import Func1 [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_injected_dynamodb ( monkeypatch ) : [EOL] dynamodb = boto3 . resource ( [string] , endpoint_url = [string] ) . Table ( [string] ) [EOL] monkeypatch . setenv ( [string] , [string] ) [EOL] Func1 ( { } , { } ) . main ( ) [EOL] [EOL] assert dynamodb . scan ( ) . get ( [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import boto3 [EOL] import inject [EOL] import pytest [EOL] [EOL] import config [EOL] [EOL] [EOL] def pytest_runtest_setup ( item ) : [EOL] inject . clear_and_configure ( config . localhost ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def dynamodb ( ) : [EOL] return inject . instance ( boto3 . resource ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def create_table ( dynamodb , request ) : [EOL] dynamodb . create_table ( TableName = [string] , AttributeDefinitions = [ { [string] : [string] , [string] : [string] } ] , KeySchema = [ { [string] : [string] , [string] : [string] } ] , ProvisionedThroughput = { [string] : [number] , [string] : [number] } ) [EOL] [EOL] def delete_table ( ) : [EOL] dynamodb . Table ( [string] ) . delete ( ) [EOL] request . addfinalizer ( delete_table ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
def hello ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from datetime import datetime [EOL] import sys [EOL] import os [EOL] sys . path . append ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) ) [EOL] import pytz [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] return str ( datetime . now ( pytz . utc ) . astimezone ( pytz . timezone ( os . environ [ [string] ] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] from datetime import datetime [EOL] import sys [EOL] import os [EOL] sys . path . append ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) ) [EOL] import pytz [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( pytz . timezone ( [string] ) . localize ( datetime . now ( ) ) ) [EOL] print ( event ) [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import os [EOL] [EOL] import boto3 [EOL] from boto3 . dynamodb . conditions import Key [EOL] [EOL] dynamodb = boto3 . resource ( [string] ) [EOL] [EOL] [EOL] def emit ( flag ) : [EOL] dict_ = { [string] : flag } [EOL] print ( dict_ ) [EOL] [EOL] return dict_ [EOL] [EOL] [EOL] def item_exists ( device_id ) : [EOL] table_name = os . environ [ [string] ] [EOL] params = { [string] : Key ( [string] ) . eq ( device_id ) } [EOL] [EOL] resp = dynamodb . Table ( table_name ) . query ( ** params ) [ [string] ] [EOL] [EOL] if resp : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] flag = False [EOL] [EOL] try : [EOL] flag = item_exists ( event [ [string] ] ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] finally : [EOL] return emit ( flag ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event )	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import datetime [EOL] from __future__ import print_function [EOL] import datetime [EOL] import boto3 [EOL] import time [EOL] import os [EOL] [EOL] lambda_name = os . environ [ [string] ] [EOL] log_group_name = [string] + lambda_name [EOL] s3_bucket_name = os . environ [ [string] ] [EOL] s3_prefix = lambda_name + [string] + str ( datetime . date . today ( ) - datetime . timedelta ( days = [number] ) ) [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def get_from_timestamp ( ) : [EOL] today = datetime . date . today ( ) [EOL] yesterday = datetime . datetime . combine ( today - datetime . timedelta ( days = [number] ) , datetime . time ( [number] , [number] , [number] ) ) [EOL] timestamp = time . mktime ( yesterday . timetuple ( ) ) [EOL] return int ( timestamp ) [EOL] [EOL] [EOL] def get_to_timestamp ( from_ts ) : [EOL] return from_ts + ( [number] * [number] * [number] ) - [number] [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] from_ts = get_from_timestamp ( ) [EOL] to_ts = get_to_timestamp ( from_ts ) [EOL] print ( [string] . format ( from_ts , to_ts ) ) [EOL] [EOL] response = client . create_export_task ( logGroupName = log_group_name , fromTime = from_ts * [number] , to = to_ts * [number] , destination = s3_bucket_name , destinationPrefix = s3_prefix ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0
def hello ( event , context ) : [EOL] return event [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pynamodb [EOL] from pynamodb . models import Model [EOL] from pynamodb . attributes import UnicodeAttribute [EOL] [EOL] [EOL] class UserModel1 ( Model ) : [EOL] [docstring] [EOL] class Meta : [EOL] table_name = [string] [EOL] host = [string] [EOL] region = [string] [EOL] email = UnicodeAttribute ( hash_key = True ) [EOL] first_name = UnicodeAttribute ( ) [EOL] last_name = UnicodeAttribute ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] UserModel1 . create_table ( read_capacity_units = [number] , write_capacity_units = [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $pynamodb.attributes.UnicodeAttribute$ 0 0 0 0 0 0 0 0 $pynamodb.attributes.UnicodeAttribute$ 0 0 0 0 0 $pynamodb.attributes.UnicodeAttribute$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from user2 import UserModel2 [EOL] [EOL] [EOL] def main ( ) : [EOL] UserModel2 ( last_name = [string] , first_name = [string] , email = [string] ) . save ( ) [EOL] UserModel2 ( last_name = [string] , first_name = [string] , email = [string] ) . save ( ) [EOL] [EOL] print ( UserModel2 . count ( [string] ) ) [EOL] print ( UserModel2 . count ( [string] , UserModel2 . first_name . startswith ( [string] ) ) ) [EOL] [EOL] for item in UserModel2 . query ( [string] , UserModel2 . first_name . startswith ( [string] ) ) : [EOL] print ( item . attribute_values ) [EOL] [EOL] for item in UserModel2 . query ( [string] , UserModel2 . first_name . startswith ( [string] ) | UserModel2 . email . contains ( [string] ) ) : [EOL] print ( item . attribute_values ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import user1 [EOL] from user1 import UserModel1 [EOL] [EOL] [EOL] def main ( ) : [EOL] user = UserModel1 ( [string] , first_name = [string] , last_name = [string] ) [EOL] user . save ( ) [EOL] print ( UserModel1 . count ( ) ) [EOL] print ( user . email ) [EOL] user . email = [string] [EOL] user . save ( ) [EOL] print ( user . email ) [EOL] user . refresh ( ) [EOL] print ( user . attribute_values ) [EOL] user . delete ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from datetime import datetime [EOL] import pytz [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] return str ( datetime . now ( pytz . utc ) . astimezone ( pytz . timezone ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] print ( event ) [EOL] raise Exception [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] import boto3 [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] print ( event ) [EOL] job_id = event [ [string] ] [ [string] ] [EOL] client . put_job_success_result ( jobId = job_id ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import pymysql [EOL] import typing [EOL] from __future__ import print_function [EOL] import json [EOL] import sys [EOL] import os [EOL] sys . path . append ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) ) [EOL] import pymysql [EOL] [EOL] [EOL] def response ( body ) : [EOL] resp = { } [EOL] resp [ [string] ] = [number] [EOL] resp [ [string] ] = json . dumps ( body ) [EOL] [EOL] return resp [EOL] [EOL] [EOL] def create ( event , context ) : [EOL] body = { } [EOL] conn = pymysql . connect ( host = os . environ [ [string] ] , user = os . environ [ [string] ] , password = os . environ [ [string] ] , db = os . environ [ [string] ] , charset = [string] , cursorclass = pymysql . cursors . DictCursor ) [EOL] try : [EOL] with conn . cursor ( ) as cursor : [EOL] cursor . execute ( [string] , ( [string] . format ( event [ [string] ] ) , event [ [string] ] ) ) [EOL] conn . commit ( ) [EOL] finally : [EOL] conn . close ( ) [EOL] return response ( body ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Tuple , Union [EOL] import pymysql [EOL] import typing [EOL] from __future__ import print_function [EOL] import json [EOL] import sys [EOL] import os [EOL] sys . path . append ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) ) [EOL] import pymysql [EOL] [EOL] [EOL] def response ( result ) : [EOL] resp = { } [EOL] resp [ [string] ] = [number] [EOL] resp [ [string] ] = json . dumps ( result ) [EOL] [EOL] return resp [EOL] [EOL] [EOL] def user ( event , context ) : [EOL] print ( event ) [EOL] conn = pymysql . connect ( host = os . environ [ [string] ] , user = os . environ [ [string] ] , password = os . environ [ [string] ] , db = os . environ [ [string] ] , charset = [string] , cursorclass = pymysql . cursors . DictCursor ) [EOL] try : [EOL] with conn . cursor ( ) as cursor : [EOL] cursor . execute ( [string] , ( int ( event [ [string] ] ) ) ) [EOL] result = cursor . fetchone ( ) [EOL] print ( result ) [EOL] finally : [EOL] conn . close ( ) [EOL] return response ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import boto3 [EOL] import urllib [EOL] [EOL] S3 = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] bucket = event [ [string] ] [ [number] ] [ [string] ] [ [string] ] [ [string] ] [EOL] key = urllib . unquote_plus ( event [ [string] ] [ [number] ] [ [string] ] [ [string] ] [ [string] ] ) . decode ( [string] ) [EOL] [EOL] try : [EOL] response = S3 . put_object ( Bucket = bucket , Key = key , ServerSideEncryption = [string] ) [EOL] print ( response ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import boto3 [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( logging . INFO ) [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def lambda_handler ( event , context ) : [EOL] try : [EOL] client = boto3 . client ( [string] ) [EOL] imageID = event [ [string] ] [ [string] ] [ [string] ] [EOL] logger . info ( [string] + imageID ) [EOL] [EOL] response = client . describe_snapshots ( Filters = [ { [string] : [string] , [string] : [ [string] + imageID + [string] , ] } ] ) [EOL] [EOL] for snapshot in response [ [string] ] : [EOL] client . delete_snapshot ( SnapshotId = snapshot [ [string] ] ) [EOL] [EOL] logger . info ( [string] + snapshot [ [string] ] + [string] + snapshot [ [string] ] ) [EOL] [EOL] except Exception as e : [EOL] logger . info ( e ) [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0
import dynamodb [EOL] import pprint [EOL] from __future__ import print_function [EOL] import os [EOL] import boto3 [EOL] import pprint [EOL] [EOL] from boto3 . dynamodb . conditions import Key , Attr [EOL] [EOL] pp = pprint . PrettyPrinter ( ) [EOL] [EOL] [EOL] class DynamoDB ( object ) : [EOL] [EOL] def __init__ ( self , table_name ) : [EOL] self . client = boto3 . resource ( [string] ) [EOL] self . table = self . client . Table ( table_name ) [EOL] [EOL] def describe_table ( self ) : [EOL] return self . client . describe_table ( TableName = self . table_name ) [EOL] [EOL] def scan ( self ) : [EOL] return self . table . scan ( ) [EOL] [EOL] def query ( self ) : [EOL] return self . table . query ( KeyConditionExpression = Key ( [string] ) . eq ( [string] ) ) [EOL] [EOL] def get_item ( self , key ) : [EOL] return self . table . get_item ( Key = key ) [EOL] [EOL] def update_item ( self , key ) : [EOL] return self . table . update_item ( Key = key ) [EOL] [EOL] def put_item ( self , item ) : [EOL] return self . table . put_item ( Item = item ) [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] dynamodb = DynamoDB ( os . environ [ [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pp . pprint ( dynamodb . scan ( ) ) [EOL] pp . pprint ( dynamodb . get_item ( { [string] : [string] , [string] : [string] } ) ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pprint.PrettyPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pprint.PrettyPrinter$ 0 0 0 0 0 0 0 0 0 0 $pprint.PrettyPrinter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import serverless [EOL] import typing [EOL] import base64 [EOL] [EOL] [EOL] class Firehose ( object ) : [EOL] def __init__ ( self , event , context ) : [EOL] self . event = event [EOL] self . context = context [EOL] [EOL] def transform ( self ) : [EOL] output = [ ] [EOL] [EOL] for record in self . event [ [string] ] : [EOL] print ( record [ [string] ] ) [EOL] payload = base64 . b64decode ( record [ [string] ] ) [EOL] [EOL] output_record = { [string] : record [ [string] ] , [string] : [string] , [string] : base64 . b64encode ( payload ) . decode ( [string] ) } [EOL] output . append ( output_record ) [EOL] [EOL] print ( [string] . format ( len ( self . event [ [string] ] ) ) ) [EOL] [EOL] return { [string] : output } [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] firehose = Firehose ( event , context ) [EOL] return firehose . transform ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import sys [EOL] import pathlib [EOL] [EOL] sys . path . append ( str ( pathlib . Path ( __file__ ) . parent . parent . resolve ( ) ) ) [EOL] [EOL] from index import Firehose [EOL] [EOL] [EOL] def test_transform ( event ) : [EOL] [EOL] firehose = Firehose ( event , { } ) [EOL] response = firehose . transform ( ) [EOL] [EOL] for i , record in enumerate ( response . get ( [string] ) ) : [EOL] assert record . get ( [string] ) == event [ [string] ] [ i ] [ [string] ] [EOL] assert record . get ( [string] ) == [string] [EOL] assert record . get ( [string] ) == event [ [string] ] [ i ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import json [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def event ( ) : [EOL] event_path = str ( pathlib . Path ( __file__ ) . parent . joinpath ( [string] ) . resolve ( ) ) [EOL] with open ( event_path , mode = [string] ) as f : [EOL] return json . loads ( f . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import serverless [EOL] import typing [EOL] import os [EOL] import base64 [EOL] [EOL] import boto3 [EOL] import botocore [EOL] [EOL] [EOL] class Stream ( object ) : [EOL] def __init__ ( self , event , context , client ) : [EOL] self . event = event [EOL] self . context = context [EOL] self . client = client [EOL] self . bucket = os . environ . get ( [string] ) [EOL] [EOL] def put_object ( self ) : [EOL] try : [EOL] for record in self . event . get ( [string] ) : [EOL] response = self . client . put_object ( Bucket = self . bucket , Key = self . format_key ( record [ [string] ] [ [string] ] ) , Body = self . b64decode_with_newline ( record [ [string] ] [ [string] ] ) ) [EOL] except botocore . exceptions . ClientError as e : [EOL] print ( e ) [EOL] return { [string] : e . message } [EOL] else : [EOL] print ( response ) [EOL] return response [EOL] [EOL] def format_key ( self , key ) : [EOL] return [string] . format ( key ) [EOL] [EOL] def b64decode_with_newline ( self , data ) : [EOL] return base64 . b64decode ( [string] . format ( data ) ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] client = boto3 . client ( [string] ) [EOL] stream = Stream ( event , context , client ) [EOL] return stream . put_object ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] import base64 [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] sys . path . append ( str ( pathlib . Path ( __file__ ) . parent . parent . resolve ( ) ) ) [EOL] [EOL] from index import Stream [EOL] [EOL] BUCKET_NAME = [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_put_object ( client , event , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , BUCKET_NAME ) [EOL] [EOL] stream = Stream ( event , { } , client ) [EOL] response = stream . put_object ( ) [EOL] [EOL] assert response . get ( [string] ) . get ( [string] ) == [number] [EOL] [EOL] [EOL] def test_get_object ( client , event , monkeypatch ) : [EOL] monkeypatch . setenv ( [string] , BUCKET_NAME ) [EOL] [EOL] for record in event . get ( [string] ) : [EOL] event_base64_decoded = base64 . b64decode ( record [ [string] ] [ [string] ] ) [EOL] key_formatted = [string] . format ( record [ [string] ] [ [string] ] ) [EOL] [EOL] response = client . get_object ( Bucket = os . environ . get ( [string] ) , Key = key_formatted ) [EOL] body = response . get ( [string] ) . read ( ) [EOL] [EOL] assert body == event_base64_decoded [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] import pathlib [EOL] [EOL] import boto3 [EOL] import pytest [EOL] [EOL] BUCKET_NAME = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def client ( ) : [EOL] client = boto3 . client ( [string] , aws_access_key_id = [string] , aws_secret_access_key = [string] , region_name = [string] , endpoint_url = [string] ) [EOL] [EOL] return client [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def create_bucket ( client , request ) : [EOL] def fin ( ) : [EOL] objects = client . list_objects_v2 ( Bucket = BUCKET_NAME ) [EOL] for obj in objects . get ( [string] ) : [EOL] client . delete_object ( Bucket = BUCKET_NAME , Key = obj . get ( [string] ) ) [EOL] else : [EOL] client . delete_bucket ( Bucket = BUCKET_NAME ) [EOL] request . addfinalizer ( fin ) [EOL] client . create_bucket ( Bucket = BUCKET_NAME ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def event ( ) : [EOL] event_path = str ( pathlib . Path ( __file__ ) . parent . joinpath ( [string] ) . resolve ( ) ) [EOL] with open ( event_path , mode = [string] ) as f : [EOL] return json . loads ( f . read ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] import uuid [EOL] [EOL] import boto3 [EOL] [EOL] CLIENT = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] while True : [EOL] response = CLIENT . put_records ( Records = records ( ) , StreamName = stream ( ) ) [EOL] [EOL] print ( response ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def stream ( ) : [EOL] return CLIENT . list_streams ( ) . get ( [string] ) [ [number] ] [EOL] [EOL] [EOL] def records ( ) : [EOL] return [ { [string] : payload ( ) , [string] : [string] } for i in range ( [number] ) ] [EOL] [EOL] [EOL] def payload ( ) : [EOL] return [string] . format ( [string] , uuid . uuid4 ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] import json [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] print ( event ) [EOL] [comment] [EOL] raise Exception ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class TestException ( Exception ) : [EOL] def __init__ ( self , msg ) : [EOL] self . msg = msg [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self . msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import os [EOL] import json [EOL] import boto3 [EOL] import botocore [EOL] [EOL] dynamodb = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def put_item ( number ) : [EOL] return dynamodb . put_item ( TableName = os . environ [ [string] ] , Item = { [string] : { [string] : number } } ) [EOL] [EOL] [EOL] def create ( event , context ) : [EOL] print ( event ) [EOL] response = { } [EOL] response [ [string] ] = [number] [EOL] response [ [string] ] = { [string] : [string] } [EOL] try : [EOL] if event [ [string] ] : [EOL] resp = put_item ( event [ [string] ] . split ( [string] ) [ - [number] ] ) [EOL] else : [EOL] resp = put_item ( event [ [string] ] . split ( [string] ) [ - [number] ] ) [EOL] except botocore . exceptions . ClientError as e : [EOL] response [ [string] ] = json . dumps ( e . response [ [string] ] ) [EOL] else : [EOL] response [ [string] ] = json . dumps ( resp [ [string] ] ) [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] [EOL] def generate_policy ( principal_id , effect , resource ) : [EOL] return { [string] : principal_id , [string] : { [string] : [string] , [string] : [ { [string] : [string] , [string] : effect , [string] : resource } ] } } [EOL] [EOL] [EOL] def authorizerFunc ( event , context ) : [EOL] print ( event ) [EOL] token = event [ [string] ] [EOL] [EOL] if token == [string] : [EOL] return generate_policy ( [string] , [string] , event [ [string] ] ) [EOL] elif token == [string] : [EOL] return generate_policy ( [string] , [string] , event [ [string] ] ) [EOL] elif token == [string] : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import os [EOL] import json [EOL] import boto3 [EOL] import botocore [EOL] [EOL] dynamodb = boto3 . client ( [string] ) [EOL] TABLE_NAME = os . environ [ [string] ] [EOL] [EOL] [EOL] def put_item ( body ) : [EOL] return dynamodb . put_item ( TableName = TABLE_NAME , Item = { [string] : { [string] : body [ [string] ] } , [string] : { [string] : body [ [string] ] } } ) [EOL] [EOL] [EOL] def get_item ( user_id , user_name ) : [EOL] return dynamodb . get_item ( TableName = TABLE_NAME , Key = { [string] : { [string] : user_id } , [string] : { [string] : user_name } } ) [EOL] [EOL] [EOL] def create ( event , context ) : [EOL] print ( event ) [EOL] response = { } [EOL] response [ [string] ] = [number] [EOL] response [ [string] ] = { [string] : [string] } [EOL] try : [EOL] resp = put_item ( event [ [string] ] ) [EOL] except botocore . exceptions . ClientError as e : [EOL] response [ [string] ] = json . dumps ( e . response [ [string] ] ) [EOL] else : [EOL] response [ [string] ] = json . dumps ( resp [ [string] ] ) [EOL] [EOL] return response [EOL] [EOL] [EOL] def detail ( event , context ) : [EOL] print ( event ) [EOL] response = { } [EOL] response [ [string] ] = [number] [EOL] response [ [string] ] = { [string] : [string] } [EOL] try : [EOL] resp = get_item ( event [ [string] ] [ [string] ] , event [ [string] ] [ [string] ] ) [EOL] except botocore . exceptions . ClientError as e : [EOL] response [ [string] ] = json . dumps ( e . response [ [string] ] ) [EOL] else : [EOL] response [ [string] ] = json . dumps ( resp ) [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import json [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] print ( event ) [EOL] response = { } [EOL] response [ [string] ] = [number] [EOL] response [ [string] ] = { [string] : [string] } [EOL] response [ [string] ] = json . dumps ( { [string] : event } ) [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import json [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] if [string] in event and event [ [string] ] == [string] : [EOL] print ( event ) [EOL] return event [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL] [EOL] [comment] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import json [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def fail ( event , context ) : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] [EOL] [EOL] def fail ( event , context ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def invoked ( event , context ) : [EOL] print ( [string] . format ( event ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] from warrant import Cognito [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] cognito_pool_id = os . environ [ [string] ] [EOL] cognito_client_id = os . environ [ [string] ] [EOL] username = event [ [string] ] [EOL] password = event [ [string] ] [EOL] [EOL] cognito = Cognito ( cognito_pool_id , cognito_client_id , user_pool_region = os . environ [ [string] ] , username = username ) [EOL] [EOL] try : [EOL] cognito . authenticate ( password = password ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] raise Exception [EOL] else : [EOL] return cognito . id_token [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def handler ( event , context ) : [EOL] return { [string] : int ( event [ [string] ] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import json [EOL] [EOL] def hello ( event , context ) : [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL] [EOL] [comment] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import random [EOL] def lambda_handler ( event , context ) : [EOL] return { [string] : random . choice ( [ [number] , [number] , [number] ] ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [comment] [EOL] import json [EOL] import boto3 [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] client = boto3 . client ( [string] ) [EOL] [EOL] [EOL] def handler ( event , context ) : [EOL] print ( event ) [EOL] return json . dumps ( event ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import json [EOL] [EOL] def hello ( event , context ) : [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL] [EOL] [comment] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import requirements [EOL] from PIL import Image [EOL] import urllib2 [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] url = [string] [EOL] image_path = [string] [EOL] [EOL] with open ( image_path , [string] ) as f : [EOL] f . write ( urllib2 . urlopen ( url ) . read ( ) ) [EOL] [EOL] return Image . open ( image_path ) . filename [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from datetime import datetime [EOL] import requirements [EOL] import pytz [EOL] [EOL] [EOL] def hello ( event , context ) : [EOL] return str ( datetime . now ( pytz . utc ) . astimezone ( pytz . timezone ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict [EOL] import typing [EOL] import json [EOL] [EOL] def hello ( event , context ) : [EOL] body = { [string] : [string] , [string] : event } [EOL] [EOL] response = { [string] : [number] , [string] : json . dumps ( body ) } [EOL] [EOL] return response [EOL] [EOL] [comment] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] import os [EOL] import boto3 [EOL] [EOL] TOPIC_ARN = os . environ [ [string] ] [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] client = boto3 . client ( [string] ) [EOL] req = { } [EOL] req . update ( { [string] : TOPIC_ARN , [string] : [string] , [string] : [string] } ) [EOL] print ( client . publish ( ** req ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] import re [EOL] import requests [EOL] [EOL] CHECK_URL = [string] [EOL] [EOL] [EOL] def handle ( event , context ) : [EOL] lambda_ip = re . findall ( [string] , requests . get ( CHECK_URL , verify = False ) . content ) [ [number] ] [EOL] print ( lambda_ip ) [EOL] return { [string] : lambda_ip } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0