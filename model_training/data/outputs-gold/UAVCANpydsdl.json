[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] import setuptools [EOL] [EOL] if int ( setuptools . __version__ . split ( [string] ) [ [number] ] ) < [number] : [EOL] print ( [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] setuptools . setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , Tuple , List , Dict [EOL] import typing [EOL] import pathlib [EOL] import sys [EOL] import pathlib [EOL] import datetime [EOL] [EOL] [EOL] GITHUB_USER_REPO = [string] , [string] [EOL] [EOL] DESCRIPTION = [string] [EOL] [EOL] DOC_ROOT = pathlib . Path ( __file__ ) . absolute ( ) . parent [EOL] REPOSITORY_ROOT = DOC_ROOT . parent [EOL] [EOL] sys . path . insert ( [number] , str ( REPOSITORY_ROOT ) ) [EOL] import pydsdl [EOL] assert [string] not in pydsdl . __file__ , [string] [EOL] [EOL] PACKAGE_ROOT = pathlib . Path ( pydsdl . __file__ ) . absolute ( ) . parent [EOL] [EOL] EXTERNAL_LINKS = { [string] : [string] , [string] : [string] , } [EOL] [EOL] project = [string] [EOL] [comment] [EOL] copyright = str ( datetime . datetime . now ( ) . year ) + [string] [EOL] author = [string] [EOL] [EOL] version = [string] . join ( map ( str , pydsdl . __version_info__ ) ) [EOL] release = pydsdl . __version__ [comment] [EOL] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] sys . path . append ( str ( DOC_ROOT ) ) [comment] [EOL] [EOL] templates_path = [ ] [EOL] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] source_suffix = [ [string] ] [EOL] [EOL] master_doc = [string] [EOL] [EOL] autoclass_content = [string] [EOL] autodoc_member_order = [string] [EOL] autodoc_inherit_docstrings = False [EOL] autodoc_default_options = { [string] : True , [string] : True , [string] : True , [string] : True , [string] : True , [string] : [string] , [string] : [string] [string] , } [EOL] [EOL] todo_include_todos = True [EOL] [EOL] graphviz_output_format = [string] [EOL] [EOL] inheritance_graph_attrs = { [string] : [string] , [string] : [string] , } [EOL] inheritance_node_attrs = { [string] : [string] , [string] : [string] , } [EOL] inheritance_edge_attrs = { [string] : inheritance_node_attrs [ [string] ] , } [EOL] [EOL] intersphinx_mapping = { [string] : ( [string] , None ) , } [EOL] [EOL] pygments_style = [string] [EOL] [EOL] html_favicon = [string] [EOL] html_theme = [string] [EOL] html_theme_options = { [string] : True , [string] : [string] , [string] : True , [string] : - [number] , } [EOL] html_context = { } [EOL] html_static_path = [ [string] ] [EOL] html_css_files = [ [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.str,None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import itertools [EOL] import pydsdl [EOL] [EOL] [EOL] def children ( ty ) : [EOL] for t in ty . __subclasses__ ( ) : [EOL] yield t [EOL] yield from children ( t ) [EOL] [EOL] [EOL] T = getattr ( pydsdl , sys . argv [ [number] ] ) [EOL] for t in itertools . chain ( [ T ] , children ( pydsdl . Any ) ) : [EOL] print ( [string] , [string] . join ( [ t . __module__ , t . __name__ ] ) ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import sys [EOL] import pydsdl [EOL] [EOL] [EOL] def children ( ty ) : [EOL] for t in ty . __subclasses__ ( ) : [EOL] yield t [EOL] yield from children ( t ) [EOL] [EOL] [EOL] T = getattr ( pydsdl , sys . argv [ [number] ] ) [EOL] print ( [string] , [string] . join ( [string] . join ( [ t . __module__ , t . __name__ ] ) for t in children ( T ) ) ) [EOL] print ( [string] ) [EOL] print ( [string] , [string] . join ( [ T . __module__ , T . __name__ ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
from six import text_type , python_2_unicode_compatible [EOL] [EOL] from parsimonious . utils import StrAndRepr [EOL] [EOL] [EOL] @ python_2_unicode_compatible class ParseError ( StrAndRepr , Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , text , pos = - [number] , expr = None ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . text = text [EOL] self . pos = pos [EOL] self . expr = expr [EOL] [EOL] def __str__ ( self ) : [EOL] rule_name = ( ( [string] % self . expr . name ) if self . expr . name else [EOL] text_type ( self . expr ) ) [EOL] return [string] % ( rule_name , self . text [ self . pos : self . pos + [number] ] , self . line ( ) , self . column ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def line ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] return self . text . count ( [string] , [number] , self . pos ) + [number] [EOL] [EOL] def column ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] try : [EOL] return self . pos - self . text . rindex ( [string] , [number] , self . pos ) [EOL] except ValueError : [EOL] return self . pos + [number] [EOL] [EOL] [EOL] @ python_2_unicode_compatible class IncompleteParseError ( ParseError ) : [EOL] [docstring] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . expr . name , self . text [ self . pos : self . pos + [number] ] , self . line ( ) , self . column ( ) ) [EOL] [EOL] [EOL] class VisitationError ( Exception ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __init__ ( self , exc , exc_class , node ) : [EOL] [docstring] [EOL] self . original_class = exc_class [EOL] super ( VisitationError , self ) . __init__ ( [string] [string] [string] % ( exc_class . __name__ , exc , node . prettily ( error = node ) ) ) [EOL] [EOL] [EOL] class BadGrammar ( StrAndRepr , Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] @ python_2_unicode_compatible class UndefinedLabel ( BadGrammar ) : [EOL] [docstring] [EOL] def __init__ ( self , label ) : [EOL] self . label = label [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % self . label [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Type , Any [EOL] import typing [EOL] import pydsdl [EOL] [docstring] [EOL] [comment] [EOL] from inspect import isfunction [EOL] from sys import version_info , exc_info [EOL] [EOL] from six import reraise , python_2_unicode_compatible , with_metaclass , iteritems [EOL] [EOL] from parsimonious . exceptions import VisitationError , UndefinedLabel [EOL] [EOL] [EOL] @ python_2_unicode_compatible class Node ( object ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] __slots__ = [ [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] def __init__ ( self , expr , full_text , start , end , children = None ) : [EOL] self . expr = expr [EOL] self . full_text = full_text [EOL] self . start = start [EOL] self . end = end [EOL] self . children = children or [ ] [EOL] [EOL] @ property def expr_name ( self ) : [EOL] [comment] [EOL] return self . expr . name [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] return iter ( self . children ) [EOL] [EOL] @ property def text ( self ) : [EOL] [docstring] [EOL] return self . full_text [ self . start : self . end ] [EOL] [EOL] [comment] [EOL] [EOL] def prettily ( self , error = None ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] def indent ( text ) : [EOL] return [string] . join ( ( [string] + line ) for line in text . splitlines ( ) ) [EOL] ret = [ [string] % ( self . __class__ . __name__ , ( [string] % self . expr_name ) if self . expr_name else [string] , self . text , [string] if error is self else [string] ) ] [EOL] for n in self : [EOL] ret . append ( indent ( n . prettily ( error = error ) ) ) [EOL] return [string] . join ( ret ) [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] return self . prettily ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] if not isinstance ( other , Node ) : [EOL] return NotImplemented [EOL] [EOL] return ( self . expr == other . expr and self . full_text == other . full_text and self . start == other . start and self . end == other . end and self . children == other . children ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __repr__ ( self , top_level = True ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] ret = [ [string] % self . full_text ] if top_level else [ ] [EOL] ret . append ( [string] % ( self . __class__ . __name__ , self . expr , self . start , self . end , ( [string] % [string] . join ( [ c . __repr__ ( top_level = False ) for c in self . children ] ) ) [EOL] if self . children else [string] ) ) [EOL] return [string] . join ( ret ) [EOL] [EOL] [EOL] class RegexNode ( Node ) : [EOL] [docstring] [EOL] __slots__ = [ [string] ] [EOL] [EOL] [EOL] class RuleDecoratorMeta ( type ) : [EOL] def __new__ ( metaclass , name , bases , namespace ) : [EOL] def unvisit ( name ) : [EOL] [docstring] [EOL] return name [ [number] : ] if name . startswith ( [string] ) else name [EOL] [EOL] methods = [ v for k , v in iteritems ( namespace ) if hasattr ( v , [string] ) and isfunction ( v ) ] [EOL] if methods : [EOL] from parsimonious . grammar import Grammar [comment] [EOL] [EOL] methods . sort ( key = ( lambda x : x . func_code . co_firstlineno ) [EOL] if version_info [ [number] ] < [number] else [EOL] ( lambda x : x . __code__ . co_firstlineno ) ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] namespace [ [string] ] = Grammar ( [string] . join ( [string] . format ( name = unvisit ( m . __name__ ) , expr = m . _rule ) for m in methods ) ) [EOL] return super ( RuleDecoratorMeta , metaclass ) . __new__ ( metaclass , name , bases , namespace ) [EOL] [EOL] [EOL] class NodeVisitor ( with_metaclass ( RuleDecoratorMeta , object ) ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] grammar = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] unwrapped_exceptions = ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def visit ( self , node ) : [EOL] [docstring] [EOL] method = getattr ( self , [string] + node . expr_name , self . generic_visit ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] return method ( node , [ self . visit ( n ) for n in node ] ) [EOL] except ( VisitationError , UndefinedLabel ) : [EOL] [comment] [EOL] raise [EOL] except self . unwrapped_exceptions : [EOL] raise [EOL] except Exception : [EOL] [comment] [EOL] [comment] [EOL] exc_class , exc , tb = exc_info ( ) [EOL] reraise ( VisitationError , VisitationError ( exc , exc_class , node ) , tb ) [EOL] [EOL] def generic_visit ( self , node , visited_children ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] % node . expr . as_rule ( ) ) [EOL] [EOL] [comment] [EOL] [EOL] def parse ( self , text , pos = [number] ) : [EOL] [docstring] [EOL] return self . _parse_or_match ( text , pos , [string] ) [EOL] [EOL] def match ( self , text , pos = [number] ) : [EOL] [docstring] [EOL] return self . _parse_or_match ( text , pos , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] def lift_child ( self , node , children ) : [EOL] [docstring] [EOL] first_child , = children [EOL] return first_child [EOL] [EOL] [comment] [EOL] [EOL] def _parse_or_match ( self , text , pos , method_name ) : [EOL] [docstring] [EOL] if not self . grammar : [EOL] raise RuntimeError ( [string] [string] [string] [string] . format ( cls = self . __class__ . __name__ , method = method_name ) ) [EOL] return self . visit ( getattr ( self . grammar , method_name ) ( text , pos = pos ) ) [EOL] [EOL] [EOL] def rule ( rule_string ) : [EOL] [docstring] [EOL] def decorator ( method ) : [EOL] method . _rule = rule_string [comment] [EOL] return method [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from parsimonious . exceptions import ( ParseError , IncompleteParseError , VisitationError , UndefinedLabel , BadGrammar ) [EOL] from parsimonious . grammar import Grammar , TokenGrammar [EOL] from parsimonious . nodes import NodeVisitor , VisitationError , rule [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from inspect import getargspec [EOL] import re [EOL] [EOL] from six import integer_types , python_2_unicode_compatible [EOL] from six . moves import range [EOL] [EOL] from parsimonious . exceptions import ParseError , IncompleteParseError [EOL] from parsimonious . nodes import Node , RegexNode [EOL] from parsimonious . utils import StrAndRepr [EOL] [EOL] MARKER = object ( ) [EOL] [EOL] [EOL] def expression ( callable , rule_name , grammar ) : [EOL] [docstring] [EOL] num_args = len ( getargspec ( callable ) . args ) [EOL] if num_args == [number] : [EOL] is_simple = True [EOL] elif num_args == [number] : [EOL] is_simple = False [EOL] else : [EOL] raise RuntimeError ( [string] [string] % num_args ) [EOL] [EOL] class AdHocExpression ( Expression ) : [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] result = ( callable ( text , pos ) if is_simple else [EOL] callable ( text , pos , cache , error , grammar ) ) [EOL] [EOL] if isinstance ( result , integer_types ) : [EOL] end , children = result , None [EOL] elif isinstance ( result , tuple ) : [EOL] end , children = result [EOL] else : [EOL] [comment] [EOL] return result [EOL] return Node ( self , text , pos , end , children = children ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] % callable . __name__ [EOL] [EOL] return AdHocExpression ( name = rule_name ) [EOL] [EOL] [EOL] @ python_2_unicode_compatible class Expression ( StrAndRepr ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , name = [string] ) : [EOL] self . name = name [EOL] self . identity_tuple = ( self . name , ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . identity_tuple ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return isinstance ( other , self . __class__ ) and self . identity_tuple == other . identity_tuple [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not ( self == other ) [EOL] [EOL] def parse ( self , text , pos = [number] ) : [EOL] [docstring] [EOL] node = self . match ( text , pos = pos ) [EOL] if node . end < len ( text ) : [EOL] raise IncompleteParseError ( text , node . end , self ) [EOL] return node [EOL] [EOL] def match ( self , text , pos = [number] ) : [EOL] [docstring] [EOL] error = ParseError ( text ) [EOL] node = self . match_core ( text , pos , { } , error ) [EOL] if node is None : [EOL] raise error [EOL] return node [EOL] [EOL] def match_core ( self , text , pos , cache , error ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] expr_id = id ( self ) [EOL] node = cache . get ( ( expr_id , pos ) , MARKER ) [comment] [EOL] if node is MARKER : [EOL] node = cache [ ( expr_id , pos ) ] = self . _uncached_match ( text , pos , cache , error ) [EOL] [EOL] [comment] [EOL] if node is None and pos >= error . pos and ( self . name or getattr ( error . expr , [string] , None ) is None ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] error . expr = self [EOL] error . pos = pos [EOL] [EOL] return node [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . __class__ . __name__ , self . as_rule ( ) ) [EOL] [EOL] def as_rule ( self ) : [EOL] [docstring] [EOL] rhs = self . _as_rhs ( ) . strip ( ) [EOL] if rhs . startswith ( [string] ) and rhs . endswith ( [string] ) : [EOL] rhs = rhs [ [number] : - [number] ] [EOL] [EOL] return ( [string] % ( self . name , rhs ) ) if self . name else rhs [EOL] [EOL] def _unicode_members ( self ) : [EOL] [docstring] [EOL] return [ ( m . name or m . _as_rhs ( ) ) for m in self . members ] [EOL] [EOL] def _as_rhs ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Literal ( Expression ) : [EOL] [docstring] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , literal , name = [string] ) : [EOL] super ( Literal , self ) . __init__ ( name ) [EOL] self . literal = literal [EOL] self . identity_tuple = ( name , literal ) [EOL] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] if text . startswith ( self . literal , pos ) : [EOL] return Node ( self , text , pos , pos + len ( self . literal ) ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] [comment] [EOL] return [string] % self . literal [EOL] [EOL] [EOL] class TokenMatcher ( Literal ) : [EOL] [docstring] [EOL] def _uncached_match ( self , token_list , pos , cache , error ) : [EOL] if token_list [ pos ] . type == self . literal : [EOL] return Node ( self , token_list , pos , pos + [number] ) [EOL] [EOL] [EOL] class Regex ( Expression ) : [EOL] [docstring] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , pattern , name = [string] , ignore_case = False , locale = False , multiline = False , dot_all = False , unicode = False , verbose = False ) : [EOL] super ( Regex , self ) . __init__ ( name ) [EOL] self . re = re . compile ( pattern , ( ignore_case and re . I ) | ( locale and re . L ) | ( multiline and re . M ) | ( dot_all and re . S ) | ( unicode and re . U ) | ( verbose and re . X ) ) [EOL] self . identity_tuple = ( self . name , self . re ) [EOL] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] [docstring] [EOL] m = self . re . match ( text , pos ) [EOL] if m is not None : [EOL] span = m . span ( ) [EOL] node = RegexNode ( self , text , pos , pos + span [ [number] ] - span [ [number] ] ) [EOL] node . match = m [comment] [EOL] return node [EOL] [EOL] def _regex_flags_from_bits ( self , bits ) : [EOL] [docstring] [EOL] flags = [string] [EOL] return [string] . join ( flags [ i - [number] ] if ( [number] << i ) & bits else [string] for i in range ( [number] , len ( flags ) + [number] ) ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] [comment] [EOL] return [string] % ( self . re . pattern , self . _regex_flags_from_bits ( self . re . flags ) ) [EOL] [EOL] [EOL] class Compound ( Expression ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , * members , ** kwargs ) : [EOL] [docstring] [EOL] super ( Compound , self ) . __init__ ( kwargs . get ( [string] , [string] ) ) [EOL] self . members = members [EOL] [EOL] def __hash__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return hash ( ( self . __class__ , self . name ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( isinstance ( other , self . __class__ ) and self . name == other . name and self . members == other . members ) [EOL] [EOL] [EOL] class Sequence ( Compound ) : [EOL] [docstring] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] new_pos = pos [EOL] length_of_sequence = [number] [EOL] children = [ ] [EOL] for m in self . members : [EOL] node = m . match_core ( text , new_pos , cache , error ) [EOL] if node is None : [EOL] return None [EOL] children . append ( node ) [EOL] length = node . end - node . start [EOL] new_pos += length [EOL] length_of_sequence += length [EOL] [comment] [EOL] return Node ( self , text , pos , pos + length_of_sequence , children ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] . format ( [string] . join ( self . _unicode_members ( ) ) ) [EOL] [EOL] [EOL] class OneOf ( Compound ) : [EOL] [docstring] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] for m in self . members : [EOL] node = m . match_core ( text , pos , cache , error ) [EOL] if node is not None : [EOL] [comment] [EOL] return Node ( self , text , pos , node . end , children = [ node ] ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] . format ( [string] . join ( self . _unicode_members ( ) ) ) [EOL] [EOL] [EOL] class Lookahead ( Compound ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] node = self . members [ [number] ] . match_core ( text , pos , cache , error ) [EOL] if node is not None : [EOL] return Node ( self , text , pos , pos ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] % self . _unicode_members ( ) [ [number] ] [EOL] [EOL] [EOL] class Not ( Compound ) : [EOL] [docstring] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] [comment] [EOL] [comment] [EOL] node = self . members [ [number] ] . match_core ( text , pos , cache , error ) [EOL] if node is None : [EOL] return Node ( self , text , pos , pos ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return [string] % self . _unicode_members ( ) [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class Optional ( Compound ) : [EOL] [docstring] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] node = self . members [ [number] ] . match_core ( text , pos , cache , error ) [EOL] return ( Node ( self , text , pos , pos ) if node is None else [EOL] Node ( self , text , pos , node . end , children = [ node ] ) ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] % self . _unicode_members ( ) [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] class ZeroOrMore ( Compound ) : [EOL] [docstring] [EOL] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] new_pos = pos [EOL] children = [ ] [EOL] while True : [EOL] node = self . members [ [number] ] . match_core ( text , new_pos , cache , error ) [EOL] if node is None or not ( node . end - node . start ) : [EOL] [comment] [EOL] return Node ( self , text , pos , new_pos , children ) [EOL] children . append ( node ) [EOL] new_pos += node . end - node . start [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] % self . _unicode_members ( ) [ [number] ] [EOL] [EOL] [EOL] class OneOrMore ( Compound ) : [EOL] [docstring] [EOL] __slots__ = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __init__ ( self , member , name = [string] , min = [number] ) : [EOL] super ( OneOrMore , self ) . __init__ ( member , name = name ) [EOL] self . min = min [EOL] [EOL] def _uncached_match ( self , text , pos , cache , error ) : [EOL] new_pos = pos [EOL] children = [ ] [EOL] while True : [EOL] node = self . members [ [number] ] . match_core ( text , new_pos , cache , error ) [EOL] if node is None : [EOL] break [EOL] children . append ( node ) [EOL] length = node . end - node . start [EOL] if length == [number] : [comment] [EOL] break [EOL] new_pos += length [EOL] if len ( children ) >= self . min : [EOL] return Node ( self , text , pos , new_pos , children ) [EOL] [EOL] def _as_rhs ( self ) : [EOL] return [string] % self . _unicode_members ( ) [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ast [EOL] [EOL] from six import python_2_unicode_compatible [EOL] [EOL] [EOL] class StrAndRepr ( object ) : [EOL] [docstring] [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] def evaluate_string ( string ) : [EOL] [docstring] [EOL] return ast . literal_eval ( string ) [EOL] [EOL] [EOL] @ python_2_unicode_compatible class Token ( StrAndRepr ) : [EOL] [docstring] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , type ) : [EOL] self . type = type [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . type , ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . type == other . type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0