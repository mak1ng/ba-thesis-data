	0
[docstring] [EOL] [EOL] import sys [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] sys . _called_from_test = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
bind = [string] [EOL] timeout = [number] [EOL] graceful_timeout = [number] [EOL]	$builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from unittest import TestCase [EOL] [EOL] [EOL] class TestDummy ( TestCase ) : [EOL] [docstring] [EOL] def test_dummy ( self ) : [EOL] self . assertEqual ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL]	0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import flask [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] from flask import Flask , jsonify [EOL] from flask_cors import CORS [EOL] from typing import Tuple [EOL] [EOL] [comment] [EOL] [comment] [EOL] LOGGING_FORMAT = [string] [EOL] logging . basicConfig ( format = LOGGING_FORMAT , level = logging . INFO ) [EOL] [EOL] from controllers . api . api_controller import api_controller [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . path . append ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def create_app ( ) : [EOL] [docstring] [EOL] app = Flask ( __name__ ) [EOL] app . url_map . strict_slashes = False [EOL] app . config [ [string] ] = False [EOL] CORS ( app , resources = { [string] : { [string] : [ [string] ] } } ) [EOL] [EOL] return app [EOL] [EOL] [EOL] app = create_app ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] app . register_blueprint ( api_controller ) [EOL] [EOL] [EOL] @ app . errorhandler ( Exception ) def server_error ( exception ) : [EOL] [docstring] [EOL] logging . exception ( [string] ) [EOL] [EOL] response = jsonify ( { [string] : [string] . format ( str ( exception ) ) , [string] : [string] } ) [EOL] [EOL] return response , [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] app . run ( host = [string] , port = [number] , debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] from utils . NestableBlueprint import NestableBlueprint [EOL] from . v1 . v1_controller import v1_controller [EOL] [EOL] api_controller = NestableBlueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] api_controller . register_blueprint ( v1_controller ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from utils . NestableBlueprint import NestableBlueprint [EOL] [EOL] v1_controller = NestableBlueprint ( [string] , __name__ , url_prefix = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Callable , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] from functools import wraps [EOL] from time import time [EOL] from typing import Callable [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def log_execution_time ( log_message ) : [EOL] [docstring] [EOL] [EOL] def decorator ( function_being_decorated ) : [EOL] @ wraps ( function_being_decorated ) def wrapper ( * args , ** kwargs ) : [EOL] start_time = time ( ) [EOL] [EOL] result = function_being_decorated ( * args , ** kwargs ) [EOL] [EOL] elapsed_time = [string] % ( time ( ) - start_time ) [EOL] logger . info ( [string] . format ( log_message , elapsed_time ) ) [EOL] [EOL] return result [EOL] [EOL] return wrapper [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] import os [EOL] from typing import List [EOL] from kubails . utils . service_helpers import call_command [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] VALUES_FOLDER = [string] [EOL] TEMPLATES_FOLDER = [string] [EOL] [EOL] [EOL] class Helm : [EOL] def __init__ ( self , helm_folder , base_values_file ) : [EOL] self . helm_folder = helm_folder [EOL] self . values_folder = os . path . join ( helm_folder , VALUES_FOLDER ) [EOL] self . base_values_file = base_values_file [EOL] [EOL] self . base_command = [ [string] ] [EOL] [EOL] def template ( self , output_dir , value_files = [ ] , template_files = [ ] , string_vars = [ ] ) : [EOL] command = self . base_command + [ [string] , [string] , output_dir , [string] , self . base_values_file ] [EOL] [EOL] for value_file in value_files : [EOL] command . extend ( [ [string] , os . path . join ( self . values_folder , value_file ) ] ) [EOL] [EOL] for template_file in template_files : [EOL] command . extend ( [ [string] , os . path . join ( TEMPLATES_FOLDER , template_file ) ] ) [EOL] [EOL] for string_var in string_vars : [EOL] command . extend ( [ [string] , string_var ] ) [EOL] [EOL] command . append ( self . helm_folder ) [EOL] [EOL] return call_command ( command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
import kubails [EOL] from parameterized import parameterized [EOL] from unittest import TestCase [EOL] from . import terraform [EOL] [EOL] [EOL] class TestTerraform ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . terraform = terraform . Terraform ( ) [EOL] self . maxDiff = None [EOL] [EOL] @ parameterized . expand ( [ ( True , [string] ) , ( [string] , [string] ) , ( [number] , [string] ) , ( { [string] : [string] } , [string] ) , ( { [string] : [ [string] ] } , [string] ) , ( { [string] : [number] } , [string] ) , ( { [string] : True , [string] : False } , [string] ) , ( { [string] : [string] , [string] : [ [string] , [number] ] , [string] : [number] } , [string] ) , ( [ [string] ] , [string] ) , ( [ [number] ] , [string] ) , ( [ { [string] : [string] , [string] : [string] } ] , [string] ) , ( [ [string] , [number] , { [string] : [string] } ] , [string] ) , ( [ None ] , [string] ) ] ) def test_can_stringify_value ( self , input_value , expected_string ) : [EOL] string = self . terraform . _stringify_value ( input_value ) [EOL] self . assertEqual ( string , expected_string ) [EOL] [EOL] def test_can_not_stringify_value ( self ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] self . terraform . _stringify_value ( self . terraform ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kubails.external_services.terraform.Terraform$ 0 $kubails.external_services.terraform.Terraform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import json [EOL] import logging [EOL] import os [EOL] import shutil [EOL] from functools import reduce [EOL] from typing import Dict , List [EOL] from kubails . utils . service_helpers import ( call_command , get_command_output , get_codebase_folder , get_resources_subfolder , STDERR_INTO_OUTPUT ) [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] BUILDER_IMAGE = [string] [EOL] BUILDER_FOLDER = [string] [EOL] [EOL] [EOL] class GoogleCloud : [EOL] def __init__ ( self , project_id , project_region , project_zone ) : [EOL] self . project_id = project_id [EOL] self . project_region = project_region [EOL] self . project_zone = project_zone [EOL] [EOL] self . base_command = [ [string] , [string] , self . project_id ] [EOL] [EOL] def set_project ( self ) : [EOL] logger . info ( [string] . format ( self . project_id ) ) [EOL] [EOL] command = [ [string] , [string] , [string] , [string] , self . project_id ] [EOL] return call_command ( command ) [EOL] [EOL] def deploy_builder_image ( self ) : [EOL] print ( ) [EOL] logger . info ( [string] ) [EOL] print ( ) [EOL] [EOL] root_folder = get_codebase_folder ( ) [EOL] root_kubails_folder = os . path . join ( root_folder , [string] ) [EOL] [EOL] builder_folder = get_resources_subfolder ( BUILDER_FOLDER ) [EOL] builder_kubails_folder = os . path . join ( builder_folder , [string] ) [EOL] cloudbuild_config = os . path . join ( builder_folder , [string] ) [EOL] [EOL] if os . path . exists ( builder_kubails_folder ) : [EOL] shutil . rmtree ( builder_kubails_folder ) [EOL] [EOL] shutil . copytree ( root_folder , root_kubails_folder ) [EOL] shutil . move ( os . path . join ( root_folder , [string] ) , builder_folder ) [EOL] [EOL] command = self . base_command + [ [string] , [string] , builder_folder , [string] . format ( cloudbuild_config ) , [string] ] [EOL] [EOL] result = False [EOL] [EOL] try : [EOL] result = call_command ( command ) [EOL] finally : [EOL] shutil . rmtree ( builder_kubails_folder ) [EOL] [EOL] return result [EOL] [EOL] def delete_builder_image ( self ) : [EOL] print ( ) [EOL] logger . info ( [string] ) [EOL] print ( ) [EOL] [EOL] command = self . base_command + [ [string] , [string] , [string] , [string] , [string] . format ( self . project_id , BUILDER_IMAGE ) , [string] ] [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def create_service_account ( self , service_account , project_title ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( service_account ) ) [EOL] print ( ) [EOL] [EOL] command = self . base_command + [ [string] , [string] , [string] , service_account , [string] , [string] . format ( project_title ) ] [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def delete_service_account ( self , service_account ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( service_account ) ) [EOL] print ( ) [EOL] [EOL] full_service_account = self . _format_full_service_account ( service_account ) [EOL] command = self . base_command + [ [string] , [string] , [string] , [string] , full_service_account ] [EOL] return call_command ( command ) [EOL] [EOL] def create_key_for_service_account ( self , service_account , key_folder = [string] ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( service_account ) ) [EOL] print ( ) [EOL] [EOL] key_file = self . _format_service_account_key ( service_account , key_folder ) [EOL] [EOL] if os . path . isfile ( key_file ) : [EOL] logger . info ( [string] . format ( service_account ) ) [EOL] return True [EOL] [EOL] full_service_account = self . _format_full_service_account ( service_account ) [EOL] [EOL] command = self . base_command + [ [string] , [string] , [string] , [string] , key_file , [string] , full_service_account ] [EOL] [EOL] key_created = call_command ( command ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if not key_created : [EOL] os . remove ( key_file ) [EOL] [EOL] return key_created [EOL] [EOL] def delete_key_for_service_account ( self , service_account , key_folder = [string] ) : [EOL] key_file = self . _format_service_account_key ( service_account , key_folder ) [EOL] [EOL] if not os . path . isfile ( key_file ) : [EOL] logger . info ( [string] . format ( service_account ) ) [EOL] return True [EOL] [EOL] try : [EOL] with open ( key_file , [string] ) as f : [EOL] key_file_json = json . load ( f ) [EOL] [EOL] key_id = key_file_json [ [string] ] [EOL] except KeyError as e : [EOL] logger . error ( [string] . format ( key_file ) ) [EOL] return False [EOL] [EOL] full_service_account = self . _format_full_service_account ( service_account ) [EOL] [EOL] command = self . base_command + [ [string] , [string] , [string] , [string] , key_id , [string] , full_service_account , [string] ] [EOL] [EOL] os . remove ( key_file ) [EOL] return call_command ( command ) [EOL] [EOL] def enable_apis ( self , apis_to_enable ) : [EOL] print ( ) [EOL] logger . info ( [string] ) [EOL] print ( ) [EOL] [EOL] def log_and_call_api_command ( acc , command ) : [EOL] [comment] [EOL] logger . info ( [string] . format ( command [ - [number] ] ) ) [EOL] [EOL] return call_command ( command ) and acc [EOL] [EOL] commands = list ( map ( lambda api : self . base_command + [ [string] , [string] , api ] , apis_to_enable ) ) [EOL] return reduce ( log_and_call_api_command , commands , True ) [EOL] [EOL] def create_bucket ( self , bucket_name ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( bucket_name ) ) [EOL] print ( ) [EOL] [EOL] command = [ [string] , [string] , [string] . format ( bucket_name ) ] [EOL] return call_command ( command ) [EOL] [EOL] def delete_bucket ( self , bucket_name ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( bucket_name ) ) [EOL] print ( ) [EOL] [EOL] command = [ [string] , [string] , [string] , [string] . format ( bucket_name ) ] [EOL] return call_command ( command ) [EOL] [EOL] def does_bucket_exist_in_project ( self , bucket_name ) : [EOL] command = [ [string] , [string] ] [EOL] result = get_command_output ( command ) . split ( [string] ) [EOL] [EOL] [comment] [EOL] bucket_names = list ( map ( lambda x : x . replace ( [string] , [string] ) . replace ( [string] , [string] ) , result ) ) [EOL] [EOL] return bucket_name in bucket_names [EOL] [EOL] def does_bucket_exist_in_another_project ( self , bucket_name ) : [EOL] command = [ [string] , [string] , [string] . format ( bucket_name ) ] [EOL] result = get_command_output ( command , stderr_redirect = STDERR_INTO_OUTPUT ) [EOL] [EOL] return [string] in result [EOL] [EOL] def add_role_to_service_account ( self , service_account , role ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( service_account , role ) ) [EOL] print ( ) [EOL] [EOL] full_service_account = self . _format_full_service_account ( service_account ) [EOL] return self . add_role_to_entity ( [string] , full_service_account , role ) [EOL] [EOL] def add_role_to_current_user ( self , role ) : [EOL] user = self . get_current_user_email ( ) [EOL] print ( ) [EOL] logger . info ( [string] . format ( user , role ) ) [EOL] print ( ) [EOL] [EOL] return self . add_role_to_entity ( [string] , user , role ) [EOL] [EOL] def delete_role_from_service_account ( self , service_account , role ) : [EOL] print ( ) [EOL] logger . info ( [string] . format ( role , service_account ) ) [EOL] print ( ) [EOL] [EOL] full_service_account = self . _format_full_service_account ( service_account ) [EOL] return self . delete_role_from_entity ( [string] , full_service_account , role ) [EOL] [EOL] def add_role_to_entity ( self , entity_type , entity , role ) : [EOL] command = self . base_command + [ [string] , [string] , self . project_id , [string] , [string] . format ( entity_type , entity ) , [string] , role ] [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def delete_role_from_entity ( self , entity_type , entity , role ) : [EOL] command = self . base_command + [ [string] , [string] , self . project_id , [string] , [string] , [string] . format ( entity_type , entity ) , [string] , role ] [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def authenticate_cluster ( self , cluster ) : [EOL] command = self . base_command + [ [string] , [string] , [string] , [string] , self . project_zone , cluster ] [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def kms_encrypt ( self , input_file , encrypted_file , keyring , key ) : [EOL] command = self . base_command + [ [string] , [string] , [string] , encrypted_file , [string] , input_file , [string] , self . project_region , [string] , keyring , [string] , key ] [EOL] [EOL] return call_command ( command , shell = True ) [EOL] [EOL] def kms_decrypt ( self , encrypted_file , decrypted_file , keyring , key ) : [EOL] command = self . base_command + [ [string] , [string] , [string] , encrypted_file , [string] , decrypted_file , [string] , self . project_region , [string] , keyring , [string] , key ] [EOL] [EOL] return call_command ( command , shell = True ) [EOL] [EOL] def deploy_function ( self , name , source , entrypoint = None , trigger = [string] , env_vars = None ) : [EOL] command = self . base_command + [ [string] , [string] , name , [string] , source , [string] , [string] ] [EOL] [EOL] if entrypoint : [EOL] command . extend ( [ [string] , entrypoint ] ) [EOL] [EOL] if trigger == [string] : [EOL] command . append ( [string] ) [EOL] else : [EOL] [comment] [EOL] command . extend ( [ [string] , trigger , [string] ] ) [EOL] [EOL] if env_vars : [EOL] stringified_env_vars = [string] . join ( [ [string] . format ( k , v ) for k , v in env_vars . items ( ) ] ) [EOL] command . extend ( [ [string] , stringified_env_vars ] ) [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def get_current_user_email ( self ) : [EOL] command = self . base_command + [ [string] , [string] , [string] ] [EOL] return get_command_output ( command ) [EOL] [EOL] def get_project_number ( self ) : [EOL] command = self . base_command + [ [string] , [string] , self . project_id , [string] ] [EOL] return get_command_output ( command , shell = True ) [EOL] [EOL] def get_cloud_build_service_account ( self ) : [EOL] project_number = self . get_project_number ( ) [EOL] return [string] . format ( project_number ) [EOL] [EOL] def _format_full_service_account ( self , service_account ) : [EOL] return [string] . format ( service_account , self . project_id ) [EOL] [EOL] def _format_service_account_key ( self , service_account , key_folder ) : [EOL] return os . path . join ( key_folder , [string] . format ( service_account ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.bool$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] from parameterized import parameterized [EOL] from unittest import TestCase [EOL] from . import dependency_checker [EOL] [EOL] [EOL] dependencies_whitelist = [ [string] , [string] ] [EOL] [EOL] [EOL] class MockClass : [EOL] def __init__ ( self ) : [EOL] self . terraform = { } [EOL] self . gcloud = { } [EOL] self . not_a_service = { } [EOL] [EOL] def mock_method ( self ) : [EOL] self . gcloud . authenticate_cluster ( ) [EOL] self . not_a_service . do_a_thing ( ) [EOL] [EOL] def mock_method_with_private_calls ( self ) : [EOL] self . _mock_private_method ( ) [EOL] self . gcloud . authenticate_cluster ( ) [EOL] [EOL] def mock_method_with_nested_private_calls ( self ) : [EOL] self . _mock_private_method_with_private_method ( ) [EOL] [EOL] def _mock_private_method ( self ) : [EOL] self . terraform . get_cluster_name ( ) [EOL] [EOL] def _mock_private_method_with_private_method ( self ) : [EOL] self . _mock_private_method ( ) [EOL] [EOL] [EOL] class TestTerraform ( TestCase ) : [EOL] @ parameterized . expand ( [ ( MockClass , MockClass . mock_method , dependencies_whitelist , [ [string] ] ) , ( MockClass , MockClass . mock_method_with_private_calls , dependencies_whitelist , [ [string] , [string] ] ) , ( MockClass , MockClass . mock_method_with_nested_private_calls , dependencies_whitelist , [ [string] ] ) ] ) def test_can_get_method_dependencies ( self , cls , func , whitelist , expected_result ) : [EOL] result = dependency_checker . _get_method_dependencies ( cls , func , whitelist ) [EOL] self . assertEqual ( result , expected_result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
from typing import Union , List , Dict [EOL] import typing [EOL] import logging [EOL] import requests [EOL] import builtins [EOL] import json [EOL] import logging [EOL] import requests [EOL] from typing import Dict , List [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Slack : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] def send_message ( self , webhook , title , fields , color ) : [EOL] data = { [string] : [ { [string] : title , [string] : fields , [string] : color } ] } [EOL] [EOL] response = requests . post ( webhook , data = json . dumps ( data ) , headers = { [string] : [string] } ) [EOL] [EOL] if response . status_code != [number] : [EOL] logger . error ( [string] . format ( response . content ) ) [EOL] return False [EOL] else : [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,builtins.str]],builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import click [EOL] import logging [EOL] import os [EOL] import yaml [EOL] from typing import Any , Dict , List [EOL] from kubails . utils . service_helpers import call_command [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] COMPOSE_FILE = [string] [EOL] [EOL] [EOL] [comment] [EOL] def yaml_represent_none ( self , data ) : [EOL] return self . represent_scalar ( [string] , [string] ) [EOL] [EOL] [EOL] yaml . add_representer ( type ( None ) , yaml_represent_none ) [EOL] [EOL] [EOL] class DockerCompose : [EOL] def __init__ ( self , project_name = [string] , compose_folder = [string] ) : [EOL] self . compose_file_location = os . path . join ( compose_folder , COMPOSE_FILE ) [EOL] self . base_command = [ [string] , [string] , project_name , [string] , self . compose_file_location ] [EOL] [EOL] def up ( self , services ) : [EOL] command = self . base_command + [ [string] , [string] ] + services [EOL] return call_command ( command ) [EOL] [EOL] def down ( self ) : [EOL] command = self . base_command + [ [string] , [string] ] [EOL] return call_command ( command ) [EOL] [EOL] def add_service_config ( self , new_service_config ) : [EOL] config = self . _read_config ( ) [EOL] config . setdefault ( [string] , { } ) [EOL] [EOL] if not config [ [string] ] : [EOL] config [ [string] ] = { } [EOL] [EOL] self . _fix_conflicting_ports ( config [ [string] ] , new_service_config ) [EOL] config [ [string] ] . update ( new_service_config ) [EOL] [EOL] self . _write_config ( config ) [EOL] [EOL] def add_volume_config ( self , new_volume ) : [EOL] config = self . _read_config ( ) [EOL] config . setdefault ( [string] , { } ) [EOL] [EOL] if not config [ [string] ] : [EOL] config [ [string] ] = { } [EOL] [EOL] config [ [string] ] . update ( new_volume ) [EOL] [EOL] self . _write_config ( config ) [EOL] [EOL] def _read_config ( self ) : [EOL] with open ( self . compose_file_location , [string] ) as f : [EOL] try : [EOL] return yaml . safe_load ( f ) [EOL] except yaml . YAMLError as e : [EOL] logger . exception ( [string] + str ( e ) ) [EOL] raise click . Abort ( ) [EOL] [EOL] def _write_config ( self , config ) : [EOL] with open ( self . compose_file_location , [string] ) as f : [EOL] try : [EOL] yaml . dump ( config , f , default_flow_style = False , explicit_start = False , indent = [number] ) [EOL] except yaml . YAMLError as e : [EOL] logger . exception ( [string] + str ( e ) ) [EOL] raise click . Abort ( ) [EOL] [EOL] def _fix_conflicting_ports ( self , services_config , new_service_config ) : [EOL] existing_ports = self . _get_all_service_ports ( services_config ) [EOL] [EOL] for name , config in new_service_config . items ( ) : [EOL] if [string] in config : [EOL] fixed_ports = [ ] [EOL] [EOL] for ports in config [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] split_ports = ports . split ( [string] ) [EOL] host_port = split_ports [ [number] ] [EOL] container_port = split_ports [ [number] ] [EOL] [EOL] [comment] [EOL] while host_port in existing_ports : [EOL] host_port = str ( int ( host_port ) + [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] existing_ports . append ( host_port ) [EOL] [EOL] fixed_ports . append ( [string] . format ( host_port , container_port ) ) [EOL] [EOL] new_service_config [ name ] [ [string] ] = fixed_ports [EOL] [EOL] def _get_all_service_ports ( self , services_config ) : [EOL] all_ports = [ ] [EOL] [EOL] for config in services_config . values ( ) : [EOL] if [string] in config : [EOL] for ports in config [ [string] ] : [EOL] all_ports . append ( ports . split ( [string] ) [ [number] ] ) [EOL] [EOL] return all_ports [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Callable , List , Any , Optional , Dict [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import click [EOL] import logging [EOL] import os [EOL] from functools import reduce [EOL] from numbers import Number [EOL] from typing import Any , Callable , Dict , List [EOL] from kubails . utils . service_helpers import call_command , get_command_output [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] TERRAFORM_FOLDER = [string] [EOL] [EOL] [EOL] class Terraform : [EOL] def __init__ ( self , variables = { } , root_folder = [string] ) : [EOL] self . root_folder = root_folder [EOL] self . variables = variables [EOL] self . base_command = [ [string] ] [EOL] [EOL] def init ( self ) : [EOL] print ( ) [EOL] logger . info ( [string] ) [EOL] print ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return self . run_command ( [string] , with_vars = False ) [EOL] [EOL] def deploy ( self ) : [EOL] print ( ) [EOL] logger . info ( [string] ) [EOL] print ( ) [EOL] [EOL] return self . run_command ( [string] ) [EOL] [EOL] def destroy ( self ) : [EOL] state = self . get_state ( ) [EOL] state_without_kms = list ( filter ( lambda x : [string] not in x , state ) ) [EOL] [EOL] targets = list ( map ( lambda x : [string] . format ( x ) , state_without_kms ) ) [EOL] [EOL] if not targets : [EOL] logger . info ( [string] ) [EOL] return True [EOL] else : [EOL] logger . info ( [string] ) [EOL] return self . run_command ( [string] , targets + [ [string] ] ) [EOL] [EOL] def destroy_cluster ( self ) : [EOL] return self . run_command ( [string] , [ [string] , [string] ] ) [EOL] [EOL] def cluster_deployed ( self ) : [EOL] return reduce ( lambda acc , state : acc or [string] in state , self . get_state ( ) , False ) [EOL] [EOL] def get_cluster_name ( self ) : [EOL] return self . get_output ( [string] ) [EOL] [EOL] def get_public_ip ( self ) : [EOL] return self . get_output ( [string] ) [EOL] [EOL] def get_name_servers ( self ) : [EOL] return self . get_output ( [string] ) [EOL] [EOL] def get_kms_key_name ( self ) : [EOL] return self . get_output ( [string] ) [EOL] [EOL] def get_kms_key_ring_name ( self ) : [EOL] return self . get_output ( [string] ) [EOL] [EOL] def get_state ( self ) : [EOL] get_state_command = self . base_command + [ [string] , [string] ] [EOL] return self . _run_terraform_command ( get_state_command , call_function = get_command_output ) . split ( [string] ) [EOL] [EOL] def get_output ( self , output ) : [EOL] command = self . base_command + [ [string] , output ] [EOL] result = self . _run_terraform_command ( command , get_command_output ) [EOL] [EOL] if not result : [EOL] logger . error ( [string] [string] . format ( output ) ) [EOL] [EOL] raise click . Abort ( ) [EOL] [EOL] return result [EOL] [EOL] def run_command ( self , subcommand , arguments = [ ] , with_vars = True ) : [EOL] command = self . base_command + [ subcommand ] + arguments [EOL] var_options = self . _convert_config_to_var_options ( self . variables ) if self . variables and with_vars else None [EOL] [EOL] return self . _run_terraform_command ( command , env_vars = var_options ) [EOL] [EOL] def _run_terraform_command ( self , command , call_function = call_command , env_vars = None ) : [EOL] [docstring] [EOL] current_dir = os . getcwd ( ) [EOL] os . chdir ( os . path . join ( self . root_folder , TERRAFORM_FOLDER ) ) [EOL] [EOL] result = call_function ( command , shell = True , env = env_vars ) [EOL] os . chdir ( current_dir ) [EOL] [EOL] return result [EOL] [EOL] def _convert_config_to_var_options ( self , config ) : [EOL] var_options = { } [EOL] [EOL] for key , value in config . items ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] var_options [ [string] . format ( key ) ] = self . _stringify_value ( value ) [EOL] [EOL] return var_options [EOL] [EOL] def _stringify_value ( self , value , top_level = True ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if isinstance ( value , dict ) : [EOL] return self . _stringify_dict ( value ) [EOL] elif isinstance ( value , list ) : [EOL] return self . _stringify_list ( value ) [EOL] elif isinstance ( value , bool ) : [EOL] [comment] [EOL] stringified_value = str ( value ) . lower ( ) [EOL] [EOL] return [string] . format ( stringified_value ) if not top_level else stringified_value [EOL] elif isinstance ( value , str ) or isinstance ( value , Number ) : [EOL] return [string] . format ( value ) if not top_level else [string] . format ( value ) [EOL] elif value is None : [EOL] return [string] [EOL] else : [EOL] raise ValueError ( [string] . format ( value ) ) [EOL] [EOL] def _stringify_dict ( self , dict_to_convert ) : [EOL] return [string] . format ( reduce ( lambda acc , pair : [string] . format ( acc , pair [ [number] ] , self . _stringify_value ( pair [ [number] ] , top_level = False ) ) , dict_to_convert . items ( ) , [string] ) [ [number] : ] ) [comment] [EOL] [EOL] def _stringify_list ( self , list_to_convert ) : [EOL] return [string] . format ( reduce ( lambda acc , item : [string] . format ( acc , self . _stringify_value ( item , top_level = False ) ) , list_to_convert , [string] ) [ [number] : ] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Callable[...,typing.Any]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] from typing import List [EOL] from kubails . utils . service_helpers import call_command [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Docker : [EOL] def __init__ ( self ) : [EOL] self . base_command = [ [string] ] [EOL] [EOL] def build ( self , context , tags = [ ] , cache_image = None ) : [EOL] command = self . base_command + [ [string] ] [EOL] [EOL] for tag in tags : [EOL] command . extend ( [ [string] , tag ] ) [EOL] [EOL] if cache_image : [EOL] command . extend ( [ [string] , cache_image ] ) [EOL] [EOL] command . append ( context ) [EOL] [EOL] if cache_image and not self . pull ( cache_image ) : [EOL] logger . info ( [string] . format ( cache_image ) ) [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def pull ( self , image ) : [EOL] command = self . base_command + [ [string] , image ] [EOL] return call_command ( command ) [EOL] [EOL] def push ( self , image ) : [EOL] command = self . base_command + [ [string] , image ] [EOL] return call_command ( command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
	0
from typing import List [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] from typing import List [EOL] from kubails . utils . service_helpers import call_command , get_command_output [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Git : [EOL] def __init__ ( self ) : [EOL] self . base_command = [ [string] ] [EOL] [EOL] def fetch ( self , remote , prune = False , unshallow = False ) : [EOL] command = self . base_command + [ [string] , remote ] [EOL] [EOL] if prune : [EOL] command . append ( [string] ) [EOL] [EOL] if unshallow : [EOL] command . append ( [string] ) [EOL] [EOL] return call_command ( command ) [EOL] [EOL] def get_remote_branches ( self ) : [EOL] command = self . base_command + [ [string] , [string] ] [EOL] result = get_command_output ( command ) [EOL] [EOL] cleaned_branches = list ( map ( lambda x : x . strip ( ) . lower ( ) . replace ( [string] , [string] ) , result . split ( [string] ) ) ) [EOL] filtered_branches = list ( filter ( None , cleaned_branches ) ) [EOL] return sorted ( filtered_branches ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
from typing import List , Dict [EOL] import typing [EOL] import kubails [EOL] from parameterized import parameterized [EOL] from unittest import TestCase [EOL] from . import docker_compose [EOL] [EOL] [EOL] mock_services_config = { [string] : { [string] : [ [string] ] } , [string] : { [string] : [ [string] ] } } [EOL] [EOL] no_conflicting_ports = { [string] : { [string] : [ [string] ] } } [EOL] [EOL] one_conflicting_port = { [string] : { [string] : [ [string] ] } } [EOL] fixed_one_conflicting_port = { [string] : { [string] : [ [string] ] } } [EOL] [EOL] two_conflicting_port = { [string] : { [string] : [ [string] , [string] ] } } [EOL] fixed_two_conflicting_port = { [string] : { [string] : [ [string] , [string] ] } } [EOL] [EOL] consecutive_conflicting_ports = { [string] : { [string] : [ [string] , [string] ] } } [EOL] fixed_consecutive_conflicting_ports = { [string] : { [string] : [ [string] , [string] ] } } [EOL] [EOL] [EOL] class TestDockerCompose ( TestCase ) : [EOL] def setUp ( self ) : [EOL] self . docker_compose = docker_compose . DockerCompose ( ) [EOL] [EOL] @ parameterized . expand ( [ ( mock_services_config , no_conflicting_ports , no_conflicting_ports ) , ( mock_services_config , one_conflicting_port , fixed_one_conflicting_port ) , ( mock_services_config , two_conflicting_port , fixed_two_conflicting_port ) , ( mock_services_config , consecutive_conflicting_ports , fixed_consecutive_conflicting_ports ) ] ) def test_can_fix_conflicting_ports ( self , services_config , new_service_config , fixed_service_config ) : [EOL] self . docker_compose . _fix_conflicting_ports ( services_config , new_service_config ) [EOL] self . assertEqual ( new_service_config , fixed_service_config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kubails.external_services.docker_compose.DockerCompose$ 0 $kubails.external_services.docker_compose.DockerCompose$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import logging [EOL] import os [EOL] import sys [EOL] from logging . handlers import RotatingFileHandler [EOL] [EOL] [EOL] LOG_MAX_SIZE = [number] [comment] [EOL] LOG_BACKUP_COUNT = [number] [EOL] PROJECT_NAME = [string] [EOL] [EOL] [EOL] def create_logger ( ) : [EOL] log_folder = os . path . join ( os . path . expanduser ( [string] ) , [string] . format ( PROJECT_NAME ) ) [EOL] log_file = os . path . join ( log_folder , [string] . format ( PROJECT_NAME ) ) [EOL] [EOL] [comment] [EOL] if not hasattr ( sys , [string] ) and not os . path . exists ( log_folder ) : [comment] [EOL] os . makedirs ( log_folder ) [EOL] [EOL] logger = logging . getLogger ( [string] ) [comment] [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] console_formatter = logging . Formatter ( [string] ) [EOL] [EOL] console_handler = logging . StreamHandler ( ) [EOL] console_handler . setLevel ( logging . INFO ) [EOL] console_handler . setFormatter ( console_formatter ) [EOL] [EOL] logger . addHandler ( console_handler ) [EOL] [EOL] [comment] [EOL] if not hasattr ( sys , [string] ) : [comment] [EOL] file_formatter = logging . Formatter ( [string] ) [EOL] [EOL] file_handler = RotatingFileHandler ( log_file , maxBytes = LOG_MAX_SIZE , backupCount = LOG_BACKUP_COUNT ) [EOL] file_handler . setLevel ( logging . DEBUG ) [EOL] file_handler . setFormatter ( file_formatter ) [EOL] [EOL] logger . addHandler ( file_handler ) [EOL] [EOL] return logger [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from parameterized import parameterized [EOL] from unittest import TestCase [EOL] from . import service_helpers [EOL] [EOL] [EOL] class TestServiceHelpers ( TestCase ) : [EOL] @ parameterized . expand ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , ] ) def test_can_sanitize_name ( self , name , expected ) : [EOL] result = service_helpers . sanitize_name ( name ) [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from unittest import TestCase [EOL] [EOL] [EOL] class CustomTestCase ( TestCase ) : [EOL] def assert_result_ok ( self , result ) : [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL] [EOL] def assert_result_bad ( self , result ) : [EOL] self . assertEqual ( result . exit_code , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Type , List , Any , Sequence , Optional , Union , Dict , Tuple [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import re [EOL] import inspect [EOL] import logging [EOL] import os [EOL] import shlex [EOL] import subprocess [EOL] from typing import Callable , Dict , List , Sequence , Tuple , Union [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] OptionKeyType = str [EOL] OptionValueType = Union [ str , bool , Sequence [ str ] ] [EOL] OptionsType = List [ Tuple [ OptionKeyType , OptionValueType ] ] [EOL] OptionsMapType = Dict [ OptionKeyType , Callable [ [ OptionValueType ] , str ] ] [EOL] [EOL] STDERR_INTO_OUTPUT = [string] [EOL] STDERR_SUPPRESS = [string] [EOL] STDERR_DISPLAY = [string] [EOL] [EOL] STDERR_OPTIONS = { STDERR_INTO_OUTPUT : subprocess . STDOUT , STDERR_SUPPRESS : subprocess . DEVNULL , STDERR_DISPLAY : None } [EOL] [EOL] [EOL] def get_command_output ( command , shell = False , stderr_redirect = STDERR_SUPPRESS , ** kwargs ) : [EOL] [docstring] [EOL] logger . debug ( [string] . format ( [string] . join ( command ) ) ) [EOL] [EOL] try : [EOL] stderr_option = STDERR_OPTIONS . get ( stderr_redirect , subprocess . STDOUT ) [EOL] out = subprocess . check_output ( _format_command ( command , shell ) , stderr = stderr_option , shell = shell , ** kwargs ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cleaned_out = out . decode ( [string] ) . rstrip ( ) . strip ( [string] ) [EOL] logger . debug ( [string] + cleaned_out ) [EOL] [EOL] if cleaned_out == [string] : [comment] [EOL] return [string] [EOL] else : [EOL] return cleaned_out [EOL] except subprocess . CalledProcessError as e : [comment] [EOL] out = e . output . decode ( [string] ) . rstrip ( ) [EOL] [EOL] logger . debug ( [string] [string] . format ( str ( e ) , out ) ) [EOL] logger . debug ( [string] , exc_info = True ) [EOL] [EOL] return out if stderr_redirect == STDERR_INTO_OUTPUT else [string] [EOL] except Exception as e : [comment] [EOL] logger . debug ( [string] . format ( str ( e ) ) ) [EOL] logger . debug ( [string] , exc_info = True ) [EOL] [EOL] return [string] [EOL] [EOL] [EOL] def call_command ( command , shell = False , ** kwargs ) : [EOL] [docstring] [EOL] log_command ( command ) [EOL] exit_code = subprocess . call ( _format_command ( command , shell ) , shell = shell , ** kwargs ) [EOL] logger . debug ( [string] . format ( exit_code ) ) [EOL] [EOL] return not bool ( exit_code ) [EOL] [EOL] [EOL] def log_command ( command ) : [EOL] [docstring] [EOL] logger . debug ( [string] + [string] . join ( command ) ) [EOL] [EOL] [EOL] def escape_value ( value ) : [EOL] [docstring] [EOL] if isinstance ( value , str ) : [EOL] return shlex . quote ( value ) [EOL] elif isinstance ( value , Sequence ) : [EOL] return [ shlex . quote ( v ) for v in value ] [EOL] else : [EOL] return value [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def sanitize_name ( branch_name ) : [EOL] [comment] [EOL] return re . sub ( [string] , [string] , branch_name . lower ( ) ) [EOL] [EOL] [EOL] def get_codebase_folder ( ) : [EOL] return os . path . dirname ( os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) ) [EOL] [EOL] [EOL] def get_codebase_subfolder ( folder ) : [EOL] current_dir = os . path . dirname ( os . path . abspath ( inspect . getfile ( inspect . currentframe ( ) ) ) ) [EOL] return os . path . join ( os . path . dirname ( current_dir ) , folder ) [EOL] [EOL] [EOL] def get_resources_subfolder ( folder ) : [EOL] return os . path . join ( get_codebase_subfolder ( [string] ) , folder ) [EOL] [EOL] [EOL] def _format_command ( command , shell = False ) : [EOL] [docstring] [EOL] return command if not shell else [string] . join ( command ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Sequence[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable [EOL] import typing [EOL] import builtins [EOL] from functools import wraps [EOL] from typing import Callable [EOL] [EOL] [EOL] def log_command_args_factory ( logger , message ) : [EOL] [docstring] [EOL] def decorator ( func ) : [EOL] @ wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] logger . debug ( [string] , message . format ( func . __name__ ) , args , kwargs ) [EOL] [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from cookiecutter . main import cookiecutter [EOL] from kubails . utils . service_helpers import get_resources_subfolder [EOL] [EOL] [EOL] TEMPLATES_FOLDER = get_resources_subfolder ( [string] ) [EOL] PRIMARY_TEMPLATE = [string] [EOL] [EOL] [EOL] class Templater : [EOL] @ staticmethod def template_primary ( ) : [EOL] cookiecutter ( os . path . join ( TEMPLATES_FOLDER , PRIMARY_TEMPLATE ) ) [EOL] [EOL] @ staticmethod def template_service ( service_type , title , name , output_dir ) : [EOL] context = { [string] : title , [string] : name } [EOL] [EOL] cookiecutter ( os . path . join ( TEMPLATES_FOLDER , service_type ) , no_input = True , extra_context = context , output_dir = output_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 $builtins.str$ 0 0
	0
from typing import List [EOL] import typing [EOL] import kubails [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] from functools import reduce [EOL] from typing import List [EOL] from kubails . external_services import dependency_checker , git , kubectl [EOL] from kubails . utils . service_helpers import sanitize_name [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ dependency_checker . check_dependencies ( ) class KubeGitSyncer : [EOL] def __init__ ( self ) : [EOL] self . git = git . Git ( ) [EOL] self . kubectl = kubectl . Kubectl ( ) [EOL] [EOL] def cleanup_namespaces ( self ) : [EOL] [comment] [EOL] [comment] [EOL] self . git . fetch ( [string] , prune = True ) [EOL] self . git . fetch ( [string] , prune = True , unshallow = True ) [EOL] [EOL] remote_branches = self . git . get_remote_branches ( ) [EOL] existing_namespaces = self . kubectl . get_namespaces ( [ [string] ] ) [EOL] [EOL] unused_namespaces = _get_unused_namespaces ( remote_branches , existing_namespaces ) [EOL] [EOL] return reduce ( lambda acc , namespace : acc and self . kubectl . delete_namespace ( namespace ) , unused_namespaces , True ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def _get_unused_namespaces ( remote_branches , existing_namespaces ) : [EOL] [comment] [EOL] [comment] [EOL] remote_branches = list ( map ( sanitize_name , remote_branches ) ) [EOL] unused_namespaces = [ n for n in existing_namespaces if n not in remote_branches ] [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( str ( remote_branches ) ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( str ( existing_namespaces ) ) [EOL] [EOL] logger . info ( [string] ) [EOL] logger . info ( str ( unused_namespaces ) ) [EOL] [EOL] return unused_namespaces [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kubails.external_services.git.Git$ 0 $kubails.external_services.git.Git$ 0 0 0 0 0 0 0 $kubails.external_services.kubectl.Kubectl$ 0 $kubails.external_services.kubectl.Kubectl$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from parameterized import parameterized [EOL] from unittest import TestCase [EOL] from . import kube_git_syncer [EOL] [EOL] [EOL] class TestKubeGitSyncer ( TestCase ) : [EOL] @ parameterized . expand ( [ [ [ [string] ] , [ [string] , [string] ] , [ [string] ] ] , [ [ [string] , [string] ] , [ [string] , [string] ] , [ ] ] , [ [ [string] ] , [ [string] , [string] ] , [ [string] ] ] ] ) def test_can_get_unused_namespaces ( self , remote_branches , existing_namespaces , expected ) : [EOL] result = kube_git_syncer . _get_unused_namespaces ( remote_branches , existing_namespaces ) [EOL] self . assertEqual ( result , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] import os [EOL] import yaml [EOL] from typing import Any , Dict [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ManifestManager : [EOL] def __init__ ( self , manifests_folder = [string] , static_folder = [string] , generated_folder = [string] ) : [EOL] self . manifests_folder = manifests_folder [EOL] self . static_folder = static_folder [EOL] self . generated_folder = generated_folder [EOL] [EOL] def load_static_manifest ( self , manifest_location ) : [EOL] return self . load_manifest ( self . static_manifest_location ( manifest_location ) ) [EOL] [EOL] def load_manifest ( self , manifest_location ) : [EOL] with open ( manifest_location , [string] ) as f : [EOL] try : [EOL] return yaml . safe_load ( f ) [EOL] except yaml . YAMLError as e : [EOL] logger . exception ( str ( e ) ) [EOL] return None [EOL] [EOL] def write_static_manifest ( self , manifest , manifest_location ) : [EOL] return self . write_manifest ( manifest , self . static_manifest_location ( manifest_location ) ) [EOL] [EOL] def write_manifest ( self , manifest , manifest_location ) : [EOL] with open ( manifest_location , [string] ) as f : [EOL] try : [EOL] yaml . dump ( manifest , f , Dumper = IgnoreAliasesDumper , default_flow_style = False , explicit_start = True ) [EOL] return True [EOL] except yaml . YAMLError as e : [EOL] logger . exception ( str ( e ) ) [EOL] return False [EOL] [EOL] def static_manifest_location ( self , manifest_location ) : [EOL] return os . path . join ( self . manifests_folder , self . static_folder , manifest_location ) [EOL] [EOL] def generated_manifest_location ( self , manifest_location ) : [EOL] return os . path . join ( self . manifests_folder , self . generated_folder , manifest_location ) [EOL] [EOL] [EOL] class IgnoreAliasesDumper ( yaml . Dumper ) : [EOL] def ignore_aliases ( self , data ) : [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0