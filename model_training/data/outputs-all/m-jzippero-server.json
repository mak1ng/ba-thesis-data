from typing import Any [EOL] import typing [EOL] import builtins [EOL] import bcrypt [EOL] import sys [EOL] import base64 [EOL] [EOL] [EOL] def hash_password ( password ) : [EOL] password_bytes = bytes ( password , [string] ) [EOL] hashed = bcrypt . hashpw ( password_bytes , bcrypt . gensalt ( ) ) [EOL] base_64_hashed = base64 . b64encode ( hashed ) . decode ( [string] ) [EOL] return base_64_hashed [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) != [number] : [EOL] print ( [string] ) [EOL] else : [EOL] print ( hash_password ( sys . argv [ [number] ] ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import package_management [EOL] import security [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from logging . handlers import RotatingFileHandler [EOL] [EOL] from tornado import ioloop , web [EOL] [EOL] from handlers . add_packages_handler import AddPackagesHandler [EOL] from handlers . get_packages_handler import GetPackagesHandler [EOL] from handlers . hello_handler import HelloHandler [EOL] from handlers . package_info_handler import PackageInfoHandler [EOL] from package_management . package_manager import PackageManager [EOL] from package_management . paths_util import PathsUtil [EOL] from security . privilege_validator import PrivilegeValidator [EOL] from utils import load_config [EOL] import os [EOL] [EOL] config = load_config . load_config ( ) [EOL] [EOL] [EOL] def setup_logging ( ) : [EOL] logger = logging . getLogger ( ) [EOL] formatter = logging . Formatter ( [string] ) [EOL] [EOL] logger . setLevel ( logging . DEBUG ) [EOL] [EOL] logs_folder = config [ [string] ] [EOL] os . makedirs ( logs_folder , exist_ok = True ) [EOL] [EOL] file_handler = RotatingFileHandler ( os . path . join ( logs_folder , [string] ) , maxBytes = [number] * [number] * [number] , backupCount = [number] ) [EOL] [EOL] file_handler . formatter = formatter [EOL] [EOL] logger . addHandler ( file_handler ) [EOL] [EOL] stream_handler = logging . StreamHandler ( ) [EOL] stream_handler . formatter = formatter [EOL] [EOL] logger . addHandler ( stream_handler ) [EOL] [EOL] [EOL] def create_tornado_app ( ) : [EOL] data_folder = config [ [string] ] [ [string] ] [EOL] privilege_validator = PrivilegeValidator ( ) [EOL] privilege_validator . load_keys ( config [ [string] ] ) [EOL] [EOL] paths_util = PathsUtil ( data_folder ) [EOL] package_manager = PackageManager ( data_folder , paths_util ) [EOL] package_manager . scan ( ) [EOL] [EOL] return web . Application ( [ ( [string] , HelloHandler , { [string] : privilege_validator } ) , ( [string] , PackageInfoHandler , { [string] : package_manager , [string] : privilege_validator } ) , ( [string] , AddPackagesHandler , { [string] : package_manager , [string] : privilege_validator } ) , ( [string] , GetPackagesHandler , { [string] : package_manager , [string] : privilege_validator } ) ] ) [EOL] [EOL] [EOL] async def started_callback ( port ) : [EOL] logging . info ( f' [string] { port }' ) [EOL] [EOL] [EOL] def start_server ( ) : [EOL] app = create_tornado_app ( ) [EOL] port = config [ [string] ] [ [string] ] [EOL] app . listen ( port = port ) [EOL] ioloop . IOLoop . current ( ) . add_callback ( started_callback , port ) [EOL] ioloop . IOLoop . current ( ) . start ( ) [EOL] [EOL] [EOL] def main ( ) : [EOL] setup_logging ( ) [EOL] start_server ( ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import builtins [EOL] import errors [EOL] from typing import Optional [EOL] [EOL] from errors . error_codes import ErrorCodes [EOL] from package_management . utils import fullname [EOL] [EOL] [EOL] class ZipperoError ( Exception ) : [EOL] error_code = ErrorCodes . GENERAL [EOL] message = [string] [EOL] status_code = [number] [EOL] [EOL] def to_json ( self ) : [EOL] return { [string] : self . error_code . value , [string] : self . message } [EOL] [EOL] [EOL] class PackageAlreadyExistsError ( ZipperoError ) : [EOL] package_name = ... [EOL] package_version = ... [EOL] status_code = [number] [EOL] error_code = ErrorCodes . PACKAGE_ALREADY_EXISTS [EOL] [EOL] def __init__ ( self , package_name , package_version ) : [EOL] self . package_version = package_version [EOL] self . package_name = package_name [EOL] self . message = f' [string] { fullname ( package_name , package_version ) } [string] ' [EOL] [EOL] [EOL] class PackageDoesntExistError ( ZipperoError ) : [EOL] package_name = ... [EOL] package_version = ... [EOL] status_code = [number] [EOL] error_code = ErrorCodes . PACKAGE_DOESNT_EXIST [EOL] [EOL] def __init__ ( self , package_name , package_version ) : [EOL] self . package_name = package_name [EOL] self . package_version = package_version [EOL] self . message = f' [string] { fullname ( package_name , package_version ) } [string] ' [EOL] [EOL] [EOL] class UnauthorizedError ( ZipperoError ) : [EOL] def __init__ ( self , message = [string] ) : [EOL] self . message = message [EOL] [EOL] error_code = ErrorCodes . UNAUTHORIZED [EOL] message = [string] [EOL] status_code = [number] [EOL] [EOL] [EOL] class TestError ( ZipperoError ) : [EOL] test_message = ... [EOL] [EOL] [EOL] class MaliciousDataError ( ZipperoError ) : [EOL] error_code = ErrorCodes . MALICIOUS_DATA [EOL] status_code = [number] [EOL] message = [string] [EOL] [EOL] [EOL] class InvalidNameError ( ZipperoError ) : [EOL] def __init__ ( self , name ) : [EOL] self . message = f' [string] { name } [string] ' [EOL] [EOL] error_code = ErrorCodes . INVALID_NAME [EOL] status_code = [number] [EOL] [EOL] [EOL] class InvalidVersionError ( ZipperoError ) : [EOL] def __init__ ( self , version ) : [EOL] self . message = f' [string] { version } [string] ' [EOL] [EOL] error_code = ErrorCodes . INVALID_VERSION [EOL] status_code = [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
	0
from enum import Enum , unique [EOL] [EOL] [EOL] @ unique class ErrorCodes ( Enum ) : [EOL] GENERAL = [number] [EOL] PACKAGE_ALREADY_EXISTS = [number] [EOL] PACKAGE_DOESNT_EXIST = [number] [EOL] MALICIOUS_DATA = [number] [EOL] UNAUTHORIZED = [number] [EOL] INVALID_NAME = [number] [EOL] INVALID_VERSION = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Dict [EOL] import package_management [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from distutils . version import StrictVersion [EOL] from typing import List , Dict [EOL] [EOL] import package_management . data_paths as data_paths [EOL] from package_management . model import PackageInfo [EOL] [EOL] [EOL] def list_versions_in_package_folder ( package_folder ) : [EOL] version_dirs = os . listdir ( package_folder ) [EOL] return version_dirs [EOL] [EOL] [EOL] def build_package_info ( name , versions ) : [EOL] return PackageInfo ( name , versions ) [EOL] [EOL] [EOL] def scan_data_directory ( data_dir_path ) : [EOL] packages_path = data_paths . get_packages_path ( data_dir_path ) [EOL] package_folders = os . listdir ( packages_path ) [EOL] [EOL] packages_dict = { package_name : list_versions_in_package_folder ( os . path . join ( data_dir_path , data_paths . packages , package_name ) ) for package_name in package_folders } [EOL] [EOL] package_info_dicts = { name : build_package_info ( name = name , versions = versions ) for ( name , versions ) in packages_dict . items ( ) } [EOL] [EOL] for k , info in package_info_dicts . items ( ) : [EOL] info . versions . sort ( key = StrictVersion ) [EOL] [EOL] return package_info_dicts [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Any , Dict [EOL] import package_management [EOL] import typing [EOL] import builtins [EOL] import threading [EOL] import copy [EOL] import json [EOL] import logging [EOL] import os [EOL] import shutil [EOL] from distutils . version import StrictVersion [EOL] from threading import Lock [EOL] from typing import List , Dict , Optional [EOL] from zipfile import ZipFile [EOL] [EOL] import aiofiles [EOL] from tornado . ioloop import IOLoop [EOL] [EOL] from package_management . constants import zpspec_filename , package_name_key , version_key [EOL] from package_management . data_scanning import scan_data_directory [EOL] from errors . errors import PackageAlreadyExistsError , PackageDoesntExistError , MaliciousDataError [EOL] from package_management . model import PackageMetadata , PackageInfo [EOL] from package_management . package_validation import validate_package_name , validate_package_version [EOL] from package_management . paths_util import PathsUtil [EOL] from package_management . utils import fullname [EOL] [EOL] read_chunk_size = [number] * [number] * [number] [EOL] [EOL] [EOL] def packages_metadata_from_versions ( name , semvers ) : [EOL] return [ PackageMetadata ( name = name , semver = semver ) for semver in semvers ] [EOL] [EOL] [EOL] def parse_zpfile ( temp_file_path ) : [EOL] with ZipFile ( temp_file_path ) as zip_file : [EOL] print ( zip_file . namelist ( ) ) [EOL] zpspec_contents = zip_file . read ( zpspec_filename ) [EOL] json_dict = json . loads ( zpspec_contents , encoding = [string] ) [EOL] return json_dict [EOL] [EOL] [EOL] class PackageManager : [EOL] _paths_util = ... [EOL] _data_dir_path = ... [EOL] _package_infos = ... [EOL] _packages_in_processing_fullnames = ... [EOL] _package_infos_lock = ... [EOL] [EOL] def __init__ ( self , data_dir_path , paths_util ) : [EOL] self . _paths_util = paths_util [EOL] self . _data_dir_path = data_dir_path [EOL] self . _packages_in_processing_fullnames = [ ] [EOL] self . _package_infos_lock = Lock ( ) [EOL] [EOL] def scan ( self ) : [EOL] package_infos = scan_data_directory ( self . _data_dir_path ) [EOL] [comment] [EOL] self . _package_infos = package_infos [EOL] [EOL] def query ( self , name ) : [EOL] if name is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if name in self . _package_infos : [EOL] package_info = self . _package_infos [ name ] [EOL] return package_info [EOL] else : [EOL] return None [EOL] [EOL] def add_package_sync ( self , temp_file_path ) : [EOL] json_dict = parse_zpfile ( temp_file_path ) [EOL] [EOL] name = json_dict [ package_name_key ] [EOL] version = json_dict [ version_key ] [EOL] [EOL] validate_package_name ( name ) [EOL] validate_package_version ( version ) [EOL] [EOL] package_version_dir_path = self . _paths_util . get_package_version_dir_path ( name , version ) [EOL] package_version_file_path = self . _paths_util . get_package_version_file_path ( name , version ) [EOL] package_version_zpspec_path = self . _paths_util . get_package_version_zpspec_path ( name , version ) [EOL] [EOL] if not self . _paths_util . paths_are_valid ( [ package_version_dir_path , package_version_file_path , package_version_zpspec_path ] ) : [EOL] logging . error ( f' [string] { package_version_dir_path } [string] ' ) [EOL] raise MaliciousDataError ( ) [EOL] [EOL] self . _add_fullname_to_in_processing_or_raise_exception ( name , version ) [EOL] [EOL] try : [EOL] try : [EOL] os . makedirs ( package_version_dir_path , exist_ok = False ) [EOL] except OSError as err : [EOL] raise PackageAlreadyExistsError ( package_name = name , package_version = version ) [EOL] [EOL] shutil . move ( temp_file_path , package_version_file_path ) [EOL] [comment] [EOL] with open ( package_version_zpspec_path , mode = [string] ) as zpspec_file : [EOL] json . dump ( json_dict , zpspec_file ) [EOL] [EOL] with self . _package_infos_lock : [EOL] self . _add_version_to_package_info ( name , version ) [EOL] [EOL] logging . info ( f' [string] { fullname ( name , version ) }' ) [EOL] [EOL] finally : [EOL] with self . _package_infos_lock : [EOL] self . _packages_in_processing_fullnames . remove ( fullname ( name , version ) ) [EOL] [EOL] def _add_version_to_package_info ( self , name , version ) : [EOL] package_infos_clone = copy . deepcopy ( self . _package_infos ) [EOL] [EOL] if name not in self . _package_infos : [EOL] package_infos_clone [ name ] = PackageInfo ( name = name , versions = [ ] ) [EOL] [EOL] package_infos_clone [ name ] . versions . append ( version ) [EOL] package_infos_clone [ name ] . versions . sort ( key = StrictVersion ) [EOL] self . _package_infos = package_infos_clone [EOL] [EOL] def _add_fullname_to_in_processing_or_raise_exception ( self , name , version ) : [EOL] with self . _package_infos_lock : [EOL] if name in self . _package_infos and version in self . _package_infos [ name ] . versions : [EOL] raise PackageAlreadyExistsError ( package_name = name , package_version = version ) [EOL] [EOL] if fullname ( name , version ) in self . _packages_in_processing_fullnames : [EOL] raise PackageAlreadyExistsError ( package_name = name , package_version = version ) [EOL] [EOL] self . _packages_in_processing_fullnames . append ( fullname ( name , version ) ) [EOL] [EOL] async def add_package ( self , temp_file_path ) : [EOL] return await IOLoop . current ( ) . run_in_executor ( None , self . add_package_sync , temp_file_path ) [EOL] [EOL] async def read_package ( self , name , version ) : [EOL] if name is None or version is None : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] package_info = self . query ( name = name ) [EOL] [EOL] if ( package_info is None ) or ( version not in package_info . versions ) : [EOL] raise PackageDoesntExistError ( name , version ) [EOL] [EOL] package_file_path = self . _paths_util . get_package_version_file_path ( name , version ) [EOL] [EOL] if not self . _paths_util . path_is_valid ( package_file_path ) : [EOL] logging . error ( f' [string] { package_file_path } [string] ' ) [EOL] raise MaliciousDataError ( ) [EOL] [EOL] try : [EOL] async with aiofiles . open ( package_file_path , mode = [string] ) as file : [EOL] while True : [EOL] chunk_bytes = await file . read ( read_chunk_size ) [EOL] if len ( chunk_bytes ) > [number] : [EOL] yield chunk_bytes [EOL] else : [EOL] return [EOL] except OSError as oserr : [EOL] logging . exception ( f' [string] { package_file_path } [string] ' ) [EOL] raise PackageDoesntExistError ( name , version ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $package_management.paths_util.PathsUtil$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $package_management.paths_util.PathsUtil$ 0 0 0 0 0 $package_management.paths_util.PathsUtil$ 0 $package_management.paths_util.PathsUtil$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $package_management.model.PackageInfo$ 0 0 0 0 0 $builtins.str$ 0 0 0 $package_management.model.PackageInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 $typing.Dict[builtins.str,package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from dataclasses import dataclass , asdict [EOL] from typing import List , Dict , Optional [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class PackageMetadata : [EOL] name = ... [EOL] semver = ... [EOL] [EOL] def as_dict ( self ) : [EOL] d = asdict ( self ) [EOL] return d [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class PackageInfo : [EOL] name = ... [EOL] versions = ... [EOL] [EOL] def as_dict ( self ) : [EOL] return asdict ( self ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] [EOL] packages = [string] [EOL] [EOL] [EOL] def get_packages_path ( data_directory ) : [EOL] return os . path . join ( data_directory , packages )	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
import builtins [EOL] def fullname ( name , version ) : [EOL] return f'{ name } [string] { version }' [EOL] [EOL] [EOL] def parse_fullname ( fullname ) : [EOL] if not [string] in fullname : [EOL] raise ValueError ( f' [string] { fullname } [string] ' ) [EOL] [EOL] [ name , version ] = fullname . split ( [string] ) [EOL] return ( name , version ) [EOL] [EOL] [EOL] def package_link ( protocol , host , name , version ) : [EOL] return f'{ protocol } [string] { host } [string] { name } [string] { version }'	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
zpspec_filename = [string] [EOL] package_name_key = [string] [EOL] version_key = [string]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
	0
from typing import Optional , Match [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] from errors . errors import InvalidNameError , InvalidVersionError [EOL] [EOL] version_regex = [string] [EOL] name_regex = [string] [EOL] [EOL] [EOL] def validate_package_name ( name ) : [EOL] m = re . match ( name_regex , name ) [EOL] if m is None : [EOL] raise InvalidNameError ( name ) [EOL] [EOL] [EOL] def validate_package_version ( version ) : [EOL] m = re . match ( version_regex , version ) [EOL] if m is None : [EOL] raise InvalidVersionError ( version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import pathlib [EOL] from typing import List [EOL] [EOL] from package_management import data_paths [EOL] from package_management . constants import zpspec_filename [EOL] [EOL] [EOL] class PathsUtil : [EOL] _data_dir_path = ... [EOL] [EOL] def __init__ ( self , data_dir_path ) : [EOL] self . _data_dir_path = data_dir_path [EOL] [EOL] def get_package_version_zpspec_path ( self , name , version ) : [EOL] return os . path . join ( self . get_package_version_dir_path ( name , version ) , zpspec_filename ) [EOL] [EOL] def get_package_version_file_path ( self , name , version ) : [EOL] return os . path . join ( self . get_package_version_dir_path ( name , version ) , f'{ name } [string] ' ) [EOL] [EOL] def get_package_version_dir_path ( self , name , version ) : [EOL] return os . path . join ( self . _data_dir_path , data_paths . packages , name , version ) [EOL] [EOL] def path_is_valid ( self , path ) : [EOL] pathlib_path_to_validate = pathlib . Path ( os . path . abspath ( path ) ) [EOL] pathlib_data_dir = pathlib . Path ( os . path . abspath ( os . path . join ( self . _data_dir_path , data_paths . packages ) ) ) [EOL] [EOL] return pathlib_data_dir in pathlib_path_to_validate . parents [EOL] [EOL] def paths_are_valid ( self , paths ) : [EOL] for path in paths : [EOL] if not self . path_is_valid ( path ) : [EOL] return False [EOL] return True [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def wrap_in_envelope ( response_dict ) : [EOL] return { [string] : response_dict } [EOL] [EOL] def test ( ) : [EOL] return [string] [EOL] [EOL] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Type , Any [EOL] import typing [EOL] import aiofiles [EOL] import package_management [EOL] import handlers [EOL] import security [EOL] import builtins [EOL] import logging [EOL] from time import time [EOL] from typing import Optional [EOL] [EOL] import aiofiles [EOL] import tornado [EOL] from aiofiles . base import AiofilesContextManager [EOL] from tornado . web import RequestHandler [EOL] import tempfile [EOL] [EOL] from errors . errors import PackageAlreadyExistsError , ZipperoError [EOL] from handlers . zippero_base_handler import ZipperoBaseHandler [EOL] from package_management . package_manager import PackageManager [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from security . privilege_validator import PrivilegeValidator [EOL] [EOL] [EOL] def create_new_tempfile ( ) : [EOL] with tempfile . NamedTemporaryFile ( delete = False ) as tmp : [EOL] return tmp . name [EOL] [EOL] [EOL] @ tornado . web . stream_request_body class AddPackagesHandler ( ZipperoBaseHandler ) : [EOL] _privilege_validator = ... [EOL] _package_manager = ... [EOL] _file = ... [EOL] _temp_file_path = None [EOL] _start_time = None [EOL] [EOL] def initialize ( self , package_manager , privilege_validator ) : [EOL] self . _package_manager = package_manager [EOL] self . _privilege_validator = privilege_validator [EOL] [EOL] async def prepare ( self ) : [EOL] self . _privilege_validator . assure_readwrite_access ( self . request ) [EOL] [EOL] self . request . connection . set_max_body_size ( [number] ** [number] ) [EOL] content_type = self . request . headers . get ( [string] ) [EOL] print ( content_type ) [EOL] self . _start_time = time ( ) [EOL] self . _temp_file_path = create_new_tempfile ( ) [EOL] self . _file = await aiofiles . open ( self . _temp_file_path , [string] ) [EOL] [EOL] async def data_received ( self , chunk ) : [EOL] try : [EOL] await self . _file . write ( chunk ) [EOL] except : [EOL] await self . _file . close ( ) [EOL] self . _file = None [EOL] raise [EOL] [EOL] async def post ( self ) : [EOL] if self . _file : [EOL] await self . _file . close ( ) [EOL] [EOL] logging . info ( f' [string] { ( time ( ) - self . _start_time ) } [string] ' ) [EOL] [EOL] if not self . _temp_file_path : [EOL] self . set_status ( [number] ) [EOL] self . write ( [string] ) [EOL] logging . info ( [string] ) [EOL] try : [EOL] self . clear ( ) [EOL] temp_file_path = self . _temp_file_path [EOL] await self . _package_manager . add_package ( temp_file_path ) [EOL] self . set_status ( [number] ) [EOL] except Exception as ex : [EOL] ZipperoBaseHandler . write_error_response ( self , type ( ex ) , ex ) [EOL] finally : [EOL] self . finish ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 $aiofiles.base.AiofilesContextManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $aiofiles.base.AiofilesContextManager[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiofiles.base.AiofilesContextManager[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $aiofiles.base.AiofilesContextManager[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $aiofiles.base.AiofilesContextManager[typing.Any,typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import traceback [EOL] [EOL] from tornado . web import RequestHandler [EOL] [EOL] from errors . error_codes import ErrorCodes [EOL] from errors . errors import ZipperoError [EOL] [EOL] [EOL] class ZipperoBaseHandler ( RequestHandler ) : [EOL] def write_generic_error ( self ) : [EOL] self . set_status ( [number] ) [EOL] self . write ( { [string] : ErrorCodes . GENERAL . value , [string] : [string] } ) [EOL] [EOL] def write_error_response ( self , type , err ) : [EOL] self . set_header ( [string] , [string] ) [EOL] [EOL] if issubclass ( type , ZipperoError ) : [EOL] logging . error ( f' [string] { err . error_code . value } [string] { err . error_code . name } [string] ' ) [EOL] [EOL] self . set_status ( status_code = err . status_code ) [EOL] self . write ( err . to_json ( ) ) [EOL] else : [EOL] self . write_generic_error ( ) [EOL] [EOL] def write_error ( self , status_code , ** kwargs ) : [EOL] if [string] in kwargs : [EOL] ( type , value , _ ) = exc_info = kwargs [ [string] ] [EOL] [EOL] self . write_error_response ( type , value ) [EOL] else : [EOL] self . write_generic_error ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import package_management [EOL] import security [EOL] from tornado . web import RequestHandler [EOL] [EOL] from handlers . zippero_base_handler import ZipperoBaseHandler [EOL] from package_management . package_manager import PackageManager [EOL] from security . privilege_validator import PrivilegeValidator [EOL] [EOL] [EOL] async def generator ( ) : [EOL] for i in range ( [number] ) : [EOL] yield f' [string] { i } [string] ' [EOL] [EOL] class GetPackagesHandler ( ZipperoBaseHandler ) : [EOL] _privilege_validator = ... [EOL] _package_manager = ... [EOL] [EOL] def initialize ( self , package_manager , privilege_validator ) : [EOL] self . _package_manager = package_manager [EOL] self . _privilege_validator = privilege_validator [EOL] [EOL] async def get ( self , name , version ) : [EOL] self . _privilege_validator . assure_readonly_access ( self . request ) [EOL] [EOL] async for chunk_bytes in self . _package_manager . read_package ( name , version ) : [EOL] self . add_header ( [string] , [string] ) [EOL] self . write ( chunk_bytes ) [EOL] [EOL] self . finish ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Any , Dict [EOL] import security [EOL] import typing [EOL] from jsonschema import validate [EOL] from tornado import escape [EOL] from tornado . web import HTTPError [EOL] [EOL] from errors import errors [EOL] from handlers . zippero_base_handler import ZipperoBaseHandler [EOL] from errors . errors import TestError , UnauthorizedError [EOL] from security . privilege_validator import PrivilegeValidator [EOL] [EOL] global_repo = [ { [string] : [number] , [string] : [string] } ] [EOL] [EOL] last_id = [number] [EOL] [EOL] schema = { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } } [EOL] [EOL] class HelloHandler ( ZipperoBaseHandler ) : [EOL] _privilege_validator = ... [EOL] [EOL] def initialize ( self , privilege_validator ) : [EOL] self . _privilege_validator = privilege_validator [EOL] [EOL] async def get ( self ) : [EOL] self . _privilege_validator . assure_readwrite_access ( self . request ) [EOL] [EOL] raise errors . PackageAlreadyExistsError ( [string] , [string] ) [EOL] [EOL] host = self . request . headers . get ( [string] ) [EOL] self . write ( host ) [EOL] [EOL] async def post ( self ) : [EOL] body = self . request . body [EOL] payload = escape . json_decode ( body ) [EOL] [EOL] validate ( payload , schema ) [EOL] [EOL] global_repo . append ( payload )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],builtins.str]]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]$ 0 0 0 $typing.Any$ 0
	0
from typing import Optional , Any [EOL] import package_management [EOL] import security [EOL] import typing [EOL] from tornado . web import RequestHandler [EOL] [EOL] from errors . errors import PackageDoesntExistError [EOL] from handlers . handler_utils import wrap_in_envelope [EOL] from handlers . zippero_base_handler import ZipperoBaseHandler [EOL] from package_management . package_manager import PackageManager [EOL] from package_management . utils import package_link [EOL] from security . privilege_validator import PrivilegeValidator [EOL] [EOL] [EOL] class PackageInfoHandler ( ZipperoBaseHandler ) : [EOL] _privilege_validator = ... [EOL] _package_manager = ... [EOL] [EOL] def initialize ( self , package_manager , privilege_validator ) : [EOL] self . _package_manager = package_manager [EOL] self . _privilege_validator = privilege_validator [EOL] [EOL] async def get ( self , package_name ) : [EOL] self . _privilege_validator . assure_readonly_access ( self . request ) [EOL] [EOL] package_info = self . _package_manager . query ( name = package_name ) [EOL] [EOL] if package_info is not None : [EOL] package_info_dict = self . make_package_info_dict ( package_info ) [EOL] self . finish ( wrap_in_envelope ( package_info_dict ) ) [EOL] else : [EOL] raise PackageDoesntExistError ( package_name , [string] ) [EOL] [EOL] def make_package_info_dict ( self , package_info ) : [EOL] package_info_dict = package_info . as_dict ( ) [EOL] host = self . request . headers . get ( [string] ) [EOL] package_info_dict [ [string] ] = { version : package_link ( self . request . protocol , host , package_info . name , version ) for version in package_info . versions } [EOL] [EOL] return package_info_dict [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 0 0 0 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 $package_management.package_manager.PackageManager$ 0 0 0 0 0 $security.privilege_validator.PrivilegeValidator$ 0 $security.privilege_validator.PrivilegeValidator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[package_management.model.PackageInfo]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import sys [EOL] import json [EOL] [EOL] [EOL] def load_config ( ) : [EOL] if len ( sys . argv ) == [number] : [EOL] path = sys . argv [ [number] ] [EOL] [EOL] try : [EOL] with open ( path , [string] ) as content_file : [EOL] content = json . loads ( content_file . read ( ) ) [EOL] return content [EOL] except : [EOL] logging . exception ( [string] ) [EOL] else : [EOL] logging . error ( [string] ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0