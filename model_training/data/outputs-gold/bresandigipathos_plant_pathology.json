BASE_URL = [string] [EOL] ENDPOINT_ITEMS = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment]	0
from digipathos . cli . browser import init_interactive_mode [EOL] [EOL] [EOL] def run ( ) : [EOL] init_interactive_mode ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Union , Any , Dict [EOL] import digipathos [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import sys [EOL] from abc import ABC , abstractmethod [EOL] from typing import Dict , List [EOL] [EOL] from terminaltables import AsciiTable [EOL] [EOL] from digipathos . data . data_loader import DataLoader [EOL] from digipathos . data . dataset import Dataset [EOL] [EOL] [EOL] class Command ( ABC ) : [EOL] def __init__ ( self , desc , command , lang , require_args = False , args_description = None , arg_type = str ) : [EOL] self . desc = desc [EOL] self . command = command [EOL] self . require_args = require_args [EOL] self . args_description = args_description [EOL] self . arg_type = arg_type [EOL] self . lang = lang [EOL] [EOL] if args_description : [EOL] self . require_args = True [EOL] [EOL] def execute ( self , * args ) : [EOL] if self . require_args : [EOL] casted_arg = self . arg_type ( args [ [number] ] ) [EOL] self . print_pretty ( self . command ( casted_arg ) ) [EOL] else : [EOL] self . print_pretty ( self . command ( ) ) [EOL] [EOL] input ( [string] ) [EOL] [comment] [EOL] [EOL] @ abstractmethod def print_pretty ( self , command_response ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] def cls ( ) : [EOL] os . system ( [string] if os . name == [string] else [string] ) [EOL] [EOL] [EOL] class ListDatasets ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] dataset_ids = [ [string] ] [EOL] dataset_crops = [ [string] ] [EOL] dataset_disorders = [ [string] ] [EOL] [EOL] for dataset_id , dataset in command_response . items ( ) : [EOL] dataset_ids . append ( dataset_id ) [EOL] dataset_crops . append ( dataset . get_crop_name ( lang = self . lang ) ) [EOL] dataset_disorders . append ( dataset . get_disorder_name ( lang = self . lang ) ) [EOL] [EOL] output = [ dataset_ids , dataset_crops , dataset_disorders ] [EOL] transpose_and_print ( output ) [EOL] [EOL] [EOL] class ListCrops ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] datasets_crops = [ [string] ] [EOL] for name in command_response . keys ( ) : [EOL] datasets_crops . append ( name ) [EOL] [EOL] output = [ datasets_crops ] [EOL] transpose_and_print ( output ) [EOL] [EOL] [EOL] class ListDatasetsFromCrop ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] dataset_ids = [ [string] ] [EOL] dataset_disorders = [ [string] ] [EOL] [EOL] for dataset in command_response : [EOL] dataset_ids . append ( dataset . get_id ( ) ) [EOL] dataset_disorders . append ( dataset . get_disorder_name ( lang = self . lang ) ) [EOL] [EOL] output = [ dataset_ids , dataset_disorders ] [EOL] transpose_and_print ( output ) [EOL] [EOL] [EOL] class DownloadDataset ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] pass [EOL] [EOL] [EOL] class DownloadAllDatasets ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] pass [EOL] [EOL] [EOL] class DownloadAllDatasetsFromCrop ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] pass [EOL] [EOL] [EOL] class Exit ( Command ) : [EOL] def print_pretty ( self , command_response ) : [EOL] pass [EOL] [EOL] [EOL] def transpose_and_print ( data ) : [EOL] output = list ( map ( list , zip ( * data ) ) ) [EOL] print ( AsciiTable ( output ) . table ) [EOL] [EOL] [EOL] def get_commands ( data_loader ) : [EOL] commands = { [number] : Exit ( desc = [string] , command = sys . exit , lang = data_loader . lang ) , [number] : ListDatasets ( desc = [string] , command = data_loader . get_datasets , lang = data_loader . lang ) , [number] : ListCrops ( desc = [string] , command = data_loader . get_crops , lang = data_loader . lang ) , [number] : ListDatasetsFromCrop ( desc = [string] , command = data_loader . get_datasets_from_crop , require_args = True , args_description = [string] , lang = data_loader . lang ) , [number] : DownloadDataset ( desc = [string] , command = data_loader . download_dataset , require_args = True , args_description = [string] , arg_type = int , lang = data_loader . lang ) , [number] : DownloadAllDatasets ( desc = [string] , command = data_loader . download_all_datasets , lang = data_loader . lang ) , [number] : DownloadAllDatasetsFromCrop ( desc = [string] , command = data_loader . download_datasets_from_crop , arg_type = str , args_description = [string] , lang = data_loader . lang ) } [EOL] [EOL] return commands [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any , List [EOL] import digipathos [EOL] import typing [EOL] from digipathos . cli . command import transpose_and_print , Command , get_commands [EOL] from digipathos . data . data_loader import DataLoader [EOL] [EOL] DEFAULT_LANGUAGE = [string] [EOL] [EOL] print ( [string] ) [EOL] data_loader = DataLoader ( auto_fetch = True , lang = DEFAULT_LANGUAGE ) [EOL] commands = get_commands ( data_loader ) [EOL] [EOL] [EOL] def print_header ( ) : [EOL] header = [string] [EOL] [EOL] print ( header ) [EOL] [EOL] [EOL] def init_interactive_mode ( ) : [EOL] while True : [EOL] try : [EOL] print_header ( ) [EOL] command = read_command ( ) [EOL] if command . require_args : [EOL] arg = input ( [string] % command . args_description ) [EOL] [EOL] if arg : [EOL] run_command_with_argument ( command , arg ) [EOL] else : [EOL] print ( [string] ) [EOL] else : [EOL] command . execute ( ) [EOL] except Exception : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def run_command_with_argument ( command , arg ) : [EOL] try : [EOL] command . execute ( arg ) [EOL] except Exception as e : [EOL] print ( [string] , e ) [EOL] [EOL] [EOL] def read_command ( ) : [EOL] command_ids = [ [string] ] [EOL] command_names = [ [string] ] [EOL] for command_id , command in commands . items ( ) : [EOL] command_ids . append ( command_id ) [EOL] command_names . append ( command . desc ) [EOL] [EOL] commands_list = [ command_ids , command_names ] [EOL] [EOL] transpose_and_print ( commands_list ) [EOL] [EOL] try : [EOL] command_id = int ( input ( [string] ) ) [EOL] command = commands [ command_id ] [EOL] return command [EOL] except Exception : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] init_interactive_mode ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.cli.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import digipathos [EOL] import builtins [EOL] import os [EOL] import urllib [EOL] [EOL] from digipathos . data . dataset import Dataset [EOL] [EOL] [EOL] def download_dataset ( dataset , output_dir , verbose = True ) : [EOL] [docstring] [EOL] if not os . path . exists ( output_dir ) : [EOL] os . makedirs ( output_dir , exist_ok = True ) [EOL] [EOL] file_path = os . path . join ( output_dir , [string] % ( dataset . id , dataset . extension . lower ( ) ) ) [EOL] [EOL] if verbose : [EOL] print ( [string] % file_path ) [EOL] [EOL] urllib . request . urlretrieve ( dataset . url , file_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List , Any , Dict [EOL] import datetime [EOL] import requests [EOL] import builtins [EOL] import digipathos [EOL] import typing [EOL] from abc import ABC , abstractmethod [EOL] from datetime import datetime [EOL] from typing import List , Dict [EOL] [EOL] import requests [EOL] [EOL] from digipathos . constants import BASE_URL , ENDPOINT_ITEMS [EOL] from digipathos . data . dataset import Dataset [EOL] [EOL] [EOL] class DigipathosRepository ( ABC ) : [EOL] def __init__ ( self , lang = [string] ) : [EOL] self . __items = { } [EOL] self . __crops = { } [EOL] self . lang = lang [EOL] self . last_time_fetched = None [EOL] [EOL] @ abstractmethod def load_datasets ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def load_crops ( self ) : [EOL] if not self . __items : [EOL] self . __items = self . load_datasets ( ) [EOL] [EOL] crops = { } [EOL] [EOL] for item_id , dataset in self . __items . items ( ) : [EOL] crop_name = dataset . get_crop_name ( lang = self . lang ) [EOL] if crop_name not in crops : [EOL] crops [ crop_name ] = [ dataset ] [EOL] else : [EOL] crops [ crop_name ] . append ( dataset ) [EOL] [EOL] self . __crops = crops [EOL] [EOL] return crops [EOL] [EOL] def load_items_from_crop ( self , crop_name ) : [EOL] if not self . __items : [EOL] self . __items = self . load_datasets ( ) [EOL] [EOL] if not self . __crops : [EOL] self . __crops = self . load_crops ( ) [EOL] [EOL] if crop_name not in self . __crops : [EOL] raise ValueError ( [string] % crop_name ) [EOL] [EOL] return self . __crops [ crop_name ] [EOL] [EOL] def load_item ( self , item_id ) : [EOL] if not self . __items : [EOL] self . __items = self . load_datasets ( ) [EOL] [EOL] return self . __items [ item_id ] [EOL] [EOL] [EOL] class DigipathosRemoteApi ( DigipathosRepository ) : [EOL] THRESHOLD_CACHE = [number] [EOL] [EOL] def load_datasets ( self ) : [EOL] [EOL] if self . last_time_fetched : [EOL] interval = datetime . now ( ) - self . last_time_fetched [EOL] [EOL] if interval . seconds > self . THRESHOLD_CACHE : [EOL] self . __items = self . fetch_data_from_remote ( ) [EOL] else : [comment] [EOL] self . __items = self . fetch_data_from_remote ( ) [EOL] [EOL] self . last_time_fetched = datetime . now ( ) [EOL] [EOL] return self . __items [EOL] [EOL] def fetch_data_from_remote ( self ) : [EOL] url = BASE_URL + ENDPOINT_ITEMS [EOL] resp = requests . get ( url = url ) [EOL] data = resp . json ( ) [EOL] [EOL] json_items = data [ [string] ] [EOL] items = { } [EOL] [EOL] for item in json_items : [EOL] item = Dataset . make_from_json_dict ( item ) [EOL] item_id = item . get_id ( ) [EOL] [EOL] items [ item_id ] = item [EOL] [EOL] return items [EOL] [EOL] [EOL] class DigipathosMockedApi ( DigipathosRepository ) : [EOL] def load_datasets ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import digipathos [EOL] import builtins [EOL] import typing [EOL] import os [EOL] from typing import List , Dict [EOL] [EOL] from digipathos . data . dataset import Dataset [EOL] from digipathos . data . repository import DigipathosRemoteApi [EOL] from digipathos . utils import download_utils [EOL] [EOL] [EOL] class DataLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , artifacts_path = [string] , lang = [string] , auto_fetch = True ) : [EOL] [docstring] [EOL] self . artifacts_path = artifacts_path [EOL] self . lang = lang [EOL] self . repository = DigipathosRemoteApi ( self . lang ) [EOL] [EOL] if auto_fetch : [EOL] self . items = self . repository . load_datasets ( ) [EOL] self . crops = self . repository . load_crops ( ) [EOL] [EOL] def get_datasets ( self ) : [EOL] [docstring] [EOL] return self . repository . load_datasets ( ) [EOL] [EOL] def get_crops ( self ) : [EOL] [docstring] [EOL] return self . repository . load_crops ( ) [EOL] [EOL] def get_datasets_from_crop ( self , crop_name ) : [EOL] [docstring] [EOL] return self . repository . load_items_from_crop ( crop_name ) [EOL] [EOL] def get_dataset ( self , dataset_id ) : [EOL] [docstring] [EOL] return self . repository . load_item ( dataset_id ) [EOL] [EOL] def download_dataset ( self , dataset_id ) : [EOL] [docstring] [EOL] item = self . repository . load_item ( dataset_id ) [EOL] download_utils . download_dataset ( item , self . artifacts_path ) [EOL] [EOL] def download_all_datasets ( self ) : [EOL] [docstring] [EOL] datasets = self . repository . load_datasets ( ) [EOL] [EOL] for dataset in datasets : [EOL] download_utils . download_dataset ( dataset , self . artifacts_path ) [EOL] [EOL] def download_datasets_from_crop ( self , crop_name ) : [EOL] [docstring] [EOL] items = self . repository . load_items_from_crop ( crop_name ) [EOL] [EOL] output_path = os . path . join ( self . artifacts_path , crop_name ) [EOL] [EOL] for item in items : [EOL] download_utils . download_dataset ( item , output_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $digipathos.data.repository.DigipathosRemoteApi$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.repository.DigipathosRemoteApi$ 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.repository.DigipathosRemoteApi$ 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
	0
from typing import List , Dict [EOL] import digipathos [EOL] import typing [EOL] import os [EOL] import shutil [EOL] import unittest [EOL] from os . path import exists [EOL] [EOL] from digipathos . data . data_loader import DataLoader [EOL] [EOL] [EOL] class TestDataLoader ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . data_loader = DataLoader ( lang = [string] ) [EOL] [EOL] def test_load_items ( self ) : [EOL] items = self . data_loader . get_datasets ( ) [EOL] self . assertIsNotNone ( items ) [EOL] [EOL] def test_load_crops ( self ) : [EOL] families = self . data_loader . get_crops ( ) [EOL] self . assertIsNotNone ( families ) [EOL] [EOL] def test_load_datasets_from_crop ( self ) : [EOL] families = self . data_loader . get_datasets_from_crop ( [string] ) [EOL] self . assertIsNotNone ( families ) [EOL] [EOL] def test_load_datasets_from_crop_invalid ( self ) : [EOL] self . assertRaises ( ValueError , self . data_loader . get_datasets_from_crop , [string] ) [EOL] [EOL] def test_get_dataset ( self ) : [EOL] item = self . data_loader . get_dataset ( [number] ) [EOL] self . assertIsNotNone ( item ) [EOL] [EOL] def test_download_dataset ( self ) : [EOL] self . data_loader . download_dataset ( [number] ) [EOL] [EOL] output = os . path . join ( self . data_loader . artifacts_path , [string] ) [EOL] self . assertTrue ( exists ( output ) ) [EOL] [EOL] shutil . rmtree ( self . data_loader . artifacts_path ) [EOL] [EOL] def test_download_datasets_from_crop ( self ) : [EOL] self . data_loader . download_datasets_from_crop ( [string] ) [EOL] output = os . path . join ( self . data_loader . artifacts_path , [string] ) [EOL] count_dirs = len ( os . listdir ( output ) ) [EOL] self . assertTrue ( count_dirs > [number] ) [EOL] [EOL] shutil . rmtree ( self . data_loader . artifacts_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.data_loader.DataLoader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[digipathos.data.dataset.Dataset]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import digipathos [EOL] import typing [EOL] import unittest [EOL] [EOL] from digipathos . constants import BASE_URL [EOL] from digipathos . data . dataset import Dataset [EOL] [EOL] [EOL] class TestDataset ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . dataset = Dataset ( full_name = [string] , url = [string] , extension = [string] , size = [number] ) [EOL] [EOL] def test_name_english ( self ) : [EOL] expected_name = [string] [EOL] self . assertEqual ( self . dataset . get_crop_name ( ) , expected_name ) [EOL] [EOL] def test_name_portuguese ( self ) : [EOL] expected_name = [string] [EOL] self . assertEqual ( self . dataset . get_crop_name ( lang = [string] ) , expected_name ) [EOL] [EOL] def test_name_invalid_lang ( self ) : [EOL] ex = [string] [EOL] self . assertRaises ( ValueError , self . dataset . get_crop_name , lang = ex ) [EOL] [EOL] def test_disorder_invalid_lang ( self ) : [EOL] lang = [string] [EOL] self . assertRaises ( ValueError , self . dataset . get_disorder_name , lang = lang ) [EOL] [EOL] def test_disorder_english ( self ) : [EOL] expected_disorder = [string] [EOL] self . assertTrue ( self . dataset . get_disorder_name ( ) , expected_disorder ) [EOL] [EOL] def test_disorder_portuguese ( self ) : [EOL] expected_disorder = [string] [EOL] self . assertTrue ( self . dataset . get_disorder_name ( lang = [string] ) , expected_disorder ) [EOL] [EOL] def test_id ( self ) : [EOL] expected_id = [number] [EOL] self . assertEqual ( self . dataset . get_id ( ) , expected_id ) [EOL] [EOL] def test_init_from_json ( self ) : [EOL] item = { } [EOL] item [ [string] ] = [string] [EOL] item [ [string] ] = [string] [EOL] item [ [string] ] = [string] [EOL] item [ [string] ] = [number] [EOL] [EOL] full_url = BASE_URL + item [ [string] ] [EOL] other_dataset = Dataset . make_from_json_dict ( item = item ) [EOL] [EOL] self . assertEqual ( other_dataset . url , full_url ) [EOL] self . assertEqual ( other_dataset . full_name , item [ [string] ] ) [EOL] self . assertEqual ( other_dataset . extension , item [ [string] ] ) [EOL] self . assertEqual ( other_dataset . size , item [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $digipathos.data.dataset.Dataset$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0
	0
import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from digipathos . cli import browser [EOL] [EOL] [EOL] class CliTests ( unittest . TestCase ) : [EOL] [EOL] @ patch ( [string] , return_value = [string] ) def test_invalid_command_throws_exception ( self , mock_input ) : [EOL] with self . assertRaises ( Exception ) as e : [EOL] browser . read_command ( ) [EOL] self . assertEqual ( e . message , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0