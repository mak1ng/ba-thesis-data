[comment] [EOL] import autorecurse_path [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] from autorecurse . cli import main [EOL] main ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import builtins [EOL] import autorecurse_path [EOL] import os [EOL] import sys [EOL] import unittest [EOL] [EOL] [EOL] def script_dir ( ) : [EOL] return os . path . realpath ( sys . path [ [number] ] ) [EOL] [EOL] [EOL] def test_suite ( ) : [EOL] return unittest . defaultTestLoader . discover ( os . path . join ( script_dir ( ) , [string] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . TextTestRunner ( ) . run ( test_suite ( ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] import sys [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def script_dir ( ) : [EOL] return os . path . realpath ( sys . path [ [number] ] ) [EOL] [EOL] [EOL] def autorecurse_path ( ) : [EOL] return os . path . join ( script_dir ( ) , [string] ) [EOL] [EOL] [EOL] if autorecurse_path ( ) not in sys . path : [EOL] sys . path . append ( autorecurse_path ( ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import find_packages , setup [EOL] [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , author = [string] , package_dir = { [string] : [string] } , packages = find_packages ( [string] ) , install_requires = [ [string] ] , package_data = { [string] : [ [string] ] } , zip_safe = False , entry_points = { [string] : [ [string] ] } ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Type [EOL] import typing [EOL] import python3 [EOL] from autorecurse . lib . file import * [EOL] import os [EOL] import shutil [EOL] import unittest [EOL] [EOL] [EOL] class TestUniqueFileCreator ( unittest . TestCase ) : [EOL] [EOL] SUBDIR_REL = os . path . normpath ( [string] ) [EOL] SUBDIR_ABS = os . path . realpath ( os . path . join ( os . getcwd ( ) , SUBDIR_REL ) ) [EOL] [EOL] def setUp ( self ) : [EOL] self . tearDown ( ) [EOL] os . makedirs ( TestUniqueFileCreator . SUBDIR_REL ) [EOL] [EOL] def tearDown ( self ) : [EOL] if os . path . isdir ( TestUniqueFileCreator . SUBDIR_REL ) : [EOL] shutil . rmtree ( TestUniqueFileCreator . SUBDIR_REL ) [EOL] [EOL] def test_operation ( self ) : [EOL] file_creator_1 = self . _new_file_creator ( ) [EOL] file_creator_1 . create_file ( ) [EOL] self . assertIs ( os . path . isfile ( file_creator_1 . file_path ) , True ) [EOL] self . assertEqual ( os . path . dirname ( file_creator_1 . file_path ) , TestUniqueFileCreator . SUBDIR_ABS ) [EOL] file_creator_2 = self . _new_file_creator ( ) [EOL] file_creator_2 . create_file ( ) [EOL] self . assertIs ( os . path . isfile ( file_creator_2 . file_path ) , True ) [EOL] self . assertEqual ( os . path . dirname ( file_creator_2 . file_path ) , TestUniqueFileCreator . SUBDIR_ABS ) [EOL] with open ( file_creator_1 . file_path , [string] , encoding = [string] ) as file : [EOL] file . write ( [string] ) [EOL] with open ( file_creator_2 . file_path , [string] , encoding = [string] ) as file : [EOL] file . write ( [string] ) [EOL] with open ( file_creator_1 . file_path , [string] , encoding = [string] ) as file : [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] with open ( file_creator_2 . file_path , [string] , encoding = [string] ) as file : [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] [EOL] def _new_file_creator ( self ) : [EOL] file_creator = UniqueFileCreator . make ( ) [EOL] file_creator . file_name_prefix = [string] [EOL] file_creator . file_name_suffix = [string] [EOL] file_creator . directory = TestUniqueFileCreator . SUBDIR_REL [EOL] return file_creator [EOL] [EOL] [EOL] class TestFileLifetimeManager ( unittest . TestCase ) : [EOL] [EOL] SUBDIR_REL = os . path . normpath ( [string] ) [EOL] SUBDIR_ABS = os . path . realpath ( os . path . join ( os . getcwd ( ) , SUBDIR_REL ) ) [EOL] [EOL] def setUp ( self ) : [EOL] self . tearDown ( ) [EOL] os . makedirs ( TestFileLifetimeManager . SUBDIR_REL ) [EOL] [EOL] def tearDown ( self ) : [EOL] if os . path . isdir ( TestFileLifetimeManager . SUBDIR_REL ) : [EOL] shutil . rmtree ( TestFileLifetimeManager . SUBDIR_REL ) [EOL] [EOL] def test_operation ( self ) : [EOL] file_creator = self . _new_file_creator ( ) [EOL] with FileLifetimeManager . make ( file_creator ) as file_manager : [EOL] self . assertIs ( os . path . isfile ( file_creator . file_path ) , True ) [EOL] self . assertEqual ( os . path . dirname ( file_creator . file_path ) , TestFileLifetimeManager . SUBDIR_ABS ) [EOL] with file_manager . open_file ( [string] , encoding = [string] ) as file : [EOL] file . write ( [string] ) [EOL] with file_manager . open_file ( [string] , encoding = [string] ) as file : [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] line = file . readline ( ) [EOL] self . assertEqual ( line , [string] ) [EOL] self . assertIs ( os . path . isfile ( file_creator . file_path ) , False ) [EOL] [EOL] def _new_file_creator ( self ) : [EOL] file_creator = UniqueFileCreator . make ( ) [EOL] file_creator . file_name_prefix = [string] [EOL] file_creator . file_name_suffix = [string] [EOL] file_creator . directory = TestFileLifetimeManager . SUBDIR_REL [EOL] return file_creator [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
	0
from typing import Any , Type , Dict [EOL] import typing [EOL] import python3 [EOL] from argparse import ArgumentError [EOL] from autorecurse . common . storage import DefaultDirectoryMapping , DictionaryDirectoryMapping [EOL] from autorecurse . gnumake . storage import DirectoryEnum [EOL] from autorecurse . gnumake . implementation import * [EOL] import unittest [EOL] import os [EOL] [EOL] [EOL] class TestGnuMake ( unittest . TestCase ) : [EOL] [EOL] CWD = os . path . realpath ( os . getcwd ( ) ) [EOL] [EOL] def setUp ( self ) : [EOL] mapping_dict = { } [EOL] mapping_dict [ DirectoryEnum . NESTED_RULE ] = [string] [EOL] mapping_dict [ DirectoryEnum . TARGET_LISTING ] = [string] [EOL] mapping_dict [ DirectoryEnum . TMP ] = [string] [EOL] mapping = DictionaryDirectoryMapping . make ( mapping_dict ) [EOL] try : [EOL] DefaultDirectoryMapping . make ( ) [EOL] except Exception : [EOL] DefaultDirectoryMapping . set ( mapping ) [EOL] [EOL] def test_nested_makefiles ( self ) : [EOL] gnu = GnuMake . make ( ) [EOL] with gnu . nested_makefiles ( [string] ) as it : [EOL] self . assertIs ( it . is_at_start , True ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestGnuMake . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestGnuMake . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestGnuMake . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] def test_execution_directory ( self ) : [EOL] gnu = GnuMake . make ( ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , TestGnuMake . CWD ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , TestGnuMake . CWD ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , [string] ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , [string] ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , [string] ) [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , os . path . join ( TestGnuMake . CWD , [string] ) ) [EOL] with self . assertRaises ( ArgumentError ) : [EOL] self . assertEqual ( gnu . execution_directory ( [string] . split ( ) ) , [string] ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_target_listing_file ( self ) : [EOL] makefile_path = os . path . join ( TestGnuMake . CWD , [string] ) [EOL] makefile = Makefile . make ( makefile_path ) [EOL] gnu = GnuMake . make ( ) [EOL] gnu . update_target_listing_file ( makefile ) [EOL] [EOL] @ unittest . skip ( [string] ) def test_nested_rule_file ( self ) : [EOL] gnu = GnuMake . make ( ) [EOL] makefile_path = os . path . join ( TestGnuMake . CWD , [string] ) [EOL] makefile = Makefile . make ( makefile_path ) [EOL] gnu . update_target_listing_file ( makefile ) [EOL] makefile_path = os . path . join ( TestGnuMake . CWD , [string] ) [EOL] makefile = Makefile . make ( makefile_path ) [EOL] gnu . update_target_listing_file ( makefile ) [EOL] makefile_path = os . path . join ( TestGnuMake . CWD , [string] ) [EOL] makefile = Makefile . make ( makefile_path ) [EOL] gnu . update_target_listing_file ( makefile ) [EOL] execution_directory = os . path . join ( TestGnuMake . CWD , [string] ) [EOL] gnu . update_nested_rule_file ( execution_directory ) [EOL] [EOL] [EOL] class TestTargetListingTargetReader ( unittest . TestCase ) : [EOL] [EOL] def test_target_iterator ( self ) : [EOL] target_reader = TargetListingTargetReader . make ( [string] ) [EOL] makefile = Makefile . make ( [string] ) [EOL] with target_reader . target_iterator ( makefile ) as target_iterator : [EOL] self . assertIs ( target_iterator . is_at_start , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] target = target_iterator . current_item [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] self . assertIs ( target . file , makefile ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] target = target_iterator . current_item [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] self . assertIs ( target . file , makefile ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] target = target_iterator . current_item [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] self . assertIs ( target . file , makefile ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] target = target_iterator . current_item [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] self . assertIs ( target . file , makefile ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] target = target_iterator . current_item [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] self . assertIs ( target . file , makefile ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] target_iterator . move_to_next ( ) [EOL] self . assertIs ( target_iterator . is_at_end , True ) [EOL] [EOL] [EOL] class TestNestedMakefileLocator ( unittest . TestCase ) : [EOL] [EOL] CWD = os . path . realpath ( os . getcwd ( ) ) [EOL] [EOL] def test_with_results ( self ) : [EOL] locator = NestedMakefileLocator . make ( ) [EOL] locator . set_filename_priorities ( [ [string] , [string] , [string] ] ) [EOL] with locator . makefile_iterator ( [string] ) as it : [EOL] self . assertIs ( it . is_at_start , True ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestNestedMakefileLocator . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestNestedMakefileLocator . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] makefile = it . current_item [EOL] self . assertEqual ( makefile . exec_path , os . path . join ( TestNestedMakefileLocator . CWD , [string] ) ) [EOL] self . assertEqual ( makefile . file_path , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] def test_without_results ( self ) : [EOL] locator = NestedMakefileLocator . make ( ) [EOL] with locator . makefile_iterator ( [string] ) as it : [EOL] self . assertIs ( it . is_at_start , True ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from autorecurse . gnumake . parse import * [EOL] from antlr4 . InputStream import InputStream [EOL] from antlr4 import CommonTokenStream [EOL] import unittest [EOL] import os [EOL] [EOL] [EOL] class TestParseContextTargetBuilder ( unittest . TestCase ) : [EOL] [EOL] def test_basic_operation ( self ) : [EOL] string = [string] [EOL] [EOL] input_ = InputStream ( string ) [EOL] lexer = MakefileRuleLexer ( input_ ) [EOL] token_stream = CommonTokenStream ( lexer ) [EOL] parser = MakefileRuleParser ( token_stream ) [EOL] [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] target = ParseContextTargetBuilder . make ( ) . build_target ( ctx , [number] ) [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] target = ParseContextTargetBuilder . make ( ) . build_target ( ctx , [number] ) [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] target = ParseContextTargetBuilder . make ( ) . build_target ( ctx , [number] ) [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] target = ParseContextTargetBuilder . make ( ) . build_target ( ctx , [number] ) [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] target = ParseContextTargetBuilder . make ( ) . build_target ( ctx , [number] ) [EOL] self . assertEqual ( target . path , [string] ) [EOL] it = target . prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . order_only_prerequisites [EOL] it . move_to_next ( ) [EOL] self . assertEqual ( it . current_item , [string] ) [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] it = target . recipe_lines [EOL] it . move_to_next ( ) [EOL] self . assertIs ( it . is_at_end , True ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from autorecurse . gnumake . grammar . filter import * [EOL] import unittest [EOL] [EOL] [EOL] class TestFileSectionFilter ( unittest . TestCase ) : [EOL] [EOL] def test_content ( self ) : [EOL] obj = FileSectionFilter . make ( ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , True ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , True ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] obj . current_item = Line . make ( [string] ) [EOL] self . assertIs ( obj . condition , False ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from autorecurse . gnumake . grammar import TargetParagraphLexer [EOL] from antlr4 . InputStream import InputStream [EOL] from antlr4 import Token [EOL] import unittest [EOL] [EOL] [EOL] class TestTargetParagraphLexer ( unittest . TestCase ) : [EOL] [EOL] def test_basic_operation ( self ) : [EOL] not_a_target = [string] [EOL] phony = [string] [EOL] target1 = [string] [EOL] target2 = [string] [EOL] string = [string] . join ( [ not_a_target , phony , target1 , not_a_target , target2 ] ) [EOL] input_ = InputStream ( string ) [EOL] lexer = TargetParagraphLexer ( input_ ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] . join ( [ target1 , [string] ] ) ) [EOL] self . assertEqual ( token . type , TargetParagraphLexer . TARGET_PARAGRAPH ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , target2 ) [EOL] self . assertEqual ( token . type , TargetParagraphLexer . TARGET_PARAGRAPH ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , Token . EOF ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from autorecurse . gnumake . grammar import MakefileRuleLexer [EOL] from antlr4 . InputStream import InputStream [EOL] from antlr4 import Token [EOL] import unittest [EOL] [EOL] [EOL] class TestMakefileRuleLexer ( unittest . TestCase ) : [EOL] [EOL] def test_basic_operation ( self ) : [EOL] string = [string] [EOL] input_ = InputStream ( string ) [EOL] lexer = MakefileRuleLexer ( input_ ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . EOL ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . COLON ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . PIPE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . EOL ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . COLON ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . COLON ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . PIPE ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . COLON ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . IDENTIFIER ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . COLON ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , MakefileRuleLexer . RECIPE_LINE ) [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , Token . EOF ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from autorecurse . gnumake . grammar import MakefileRuleLexer , MakefileRuleParser [EOL] from antlr4 import CommonTokenStream , Token [EOL] from antlr4 . InputStream import InputStream [EOL] from antlr4 . error . Errors import ParseCancellationException [EOL] import unittest [EOL] [EOL] [EOL] class TestMakefileRuleParser ( unittest . TestCase ) : [EOL] [EOL] def test_basic_operation ( self ) : [EOL] string = [string] [EOL] input_ = InputStream ( string ) [EOL] lexer = MakefileRuleLexer ( input_ ) [EOL] token_stream = CommonTokenStream ( lexer ) [EOL] parser = MakefileRuleParser ( token_stream ) [EOL] with self . assertRaises ( ParseCancellationException ) : [EOL] parser . makefileRule ( ) [comment] [EOL] token_stream . consume ( ) [comment] [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . orderOnlyPrerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . orderOnlyPrerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . orderOnlyPrerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . prerequisite ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . recipe ( ) . RECIPE_LINE ( ) [ [number] ] . symbol . text , [string] ) [EOL] ctx = parser . makefileRule ( ) [EOL] self . assertIsNone ( ctx . exception ) [EOL] self . assertEqual ( len ( ctx . target ( ) ) , [number] ) [EOL] self . assertEqual ( ctx . target ( ) [ [number] ] . IDENTIFIER ( ) . symbol . text , [string] ) [EOL] self . assertEqual ( len ( ctx . prerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . orderOnlyPrerequisite ( ) ) , [number] ) [EOL] self . assertEqual ( len ( ctx . recipe ( ) . RECIPE_LINE ( ) ) , [number] ) [EOL] with self . assertRaises ( ParseCancellationException ) : [EOL] parser . makefileRule ( ) [comment] [EOL] token = lexer . nextToken ( ) [EOL] self . assertEqual ( token . text , [string] ) [EOL] self . assertEqual ( token . type , Token . EOF ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
import builtins [EOL] import python3 [EOL] import sys [EOL] [EOL] [EOL] _sys_int_wrap_increment = sys . maxsize + sys . maxsize + [number] [EOL] _sys_max_int = sys . maxsize [EOL] _sys_min_int = [number] - sys . maxsize - [number] [EOL] [EOL] [EOL] def _wrap_to_sys_int ( value ) : [EOL] if [number] <= value : [comment] [EOL] if value <= _sys_max_int : [comment] [EOL] return int ( value ) [EOL] else : [comment] [EOL] num = ( value - _sys_max_int ) // _sys_int_wrap_increment [EOL] if num <= [number] : [EOL] num = [number] [EOL] return _wrap_to_sys_int ( value - ( _sys_int_wrap_increment * num ) ) [EOL] else : [comment] [EOL] if _sys_min_int <= value : [comment] [EOL] return int ( value ) [EOL] else : [comment] [EOL] num = ( _sys_min_int - value ) // _sys_int_wrap_increment [EOL] if num <= [number] : [EOL] num = [number] [EOL] return _wrap_to_sys_int ( value + ( _sys_int_wrap_increment * num ) ) [EOL] [EOL] [EOL] class HashCombiner : [EOL] [EOL] @ staticmethod def make ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return HashCombiner . make_with_seed_and_factor ( [number] , [number] ) [EOL] [EOL] @ staticmethod def make_with_seed_and_factor ( seed , factor ) : [EOL] instance = HashCombiner ( ) [EOL] HashCombiner . _setup_with_seed_and_factor ( instance , seed , factor ) [EOL] return instance [EOL] [EOL] @ staticmethod def _setup_with_seed_and_factor ( instance , seed , factor ) : [EOL] instance . _value = seed [EOL] instance . _factor = factor [EOL] [EOL] @ property def value ( self ) : [EOL] return self . _value [EOL] [EOL] @ value . setter def value ( self , value ) : [EOL] self . _value = value [EOL] [EOL] @ property def factor ( self ) : [EOL] return self . _factor [EOL] [EOL] @ factor . setter def factor ( self , value ) : [EOL] self . _factor = value [EOL] [EOL] def put ( self , field ) : [EOL] self . value = _wrap_to_sys_int ( ( self . value * self . factor ) + hash ( field ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'HashCombiner'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'HashCombiner'$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $python3.src.autorecurse.lib.hash.HashCombiner$ 0 0 0 0 0 0 0 0 0 $python3.src.autorecurse.lib.hash.HashCombiner$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $python3.src.autorecurse.lib.hash.HashCombiner$ 0 0 0 0 0 0 0 $'HashCombiner'$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $'HashCombiner'$ 0 0 0 $builtins.int$ 0 $'HashCombiner'$ 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0
	0
	0
import builtins [EOL] from argparse import ArgumentParser , ArgumentError [EOL] [EOL] [EOL] class ThrowingArgumentParser ( ArgumentParser ) : [EOL] [EOL] def error ( self , message ) : [EOL] raise ArgumentError ( None , message ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import autorecurse [EOL] import antlr4 [EOL] import builtins [EOL] import python3 [EOL] import typing [EOL] from antlr4 import BailErrorStrategy , DiagnosticErrorListener , InputStream , Lexer , Parser , RecognitionException , Token [EOL] from antlr4 . BufferedTokenStream import TokenStream [EOL] from antlr4 . CommonTokenFactory import CommonTokenFactory [EOL] from antlr4 . Token import CommonToken [EOL] from typing import cast [EOL] import autorecurse . lib . antlr4 . abstract as abstract [EOL] [EOL] [EOL] class CustomTokenFactory ( CommonTokenFactory ) : [EOL] [EOL] _INSTANCE = None [EOL] [EOL] @ staticmethod def make ( ) : [EOL] if CustomTokenFactory . _INSTANCE is None : [EOL] CustomTokenFactory . _INSTANCE = CustomTokenFactory ( ) [EOL] return CustomTokenFactory . _INSTANCE [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( True ) [EOL] [EOL] def create ( self , source , type , text , channel , start , stop , line , column ) : [EOL] token = super ( ) . create ( source , type , text , channel , start , stop , line , column ) [EOL] if ( token . type == Token . EOF ) and ( token . _text == [string] ) : [EOL] token . text = [string] [EOL] return token [EOL] [EOL] [EOL] class CustomLexer ( Lexer , abstract . TokenSource ) : [EOL] [EOL] def __init__ ( self , input ) : [EOL] super ( ) . __init__ ( cast ( InputStream , input ) ) [EOL] self . addErrorListener ( DiagnosticErrorListener ( ) ) [EOL] self . _factory = CustomTokenFactory . make ( ) [EOL] [EOL] def recover ( self , ex ) : [EOL] raise ex [EOL] [EOL] [EOL] class CustomParser ( Parser ) : [EOL] [EOL] def __init__ ( self , input ) : [EOL] super ( ) . __init__ ( cast ( TokenStream , input ) ) [EOL] self . addErrorListener ( DiagnosticErrorListener ( ) ) [EOL] self . _errHandler = BailErrorStrategy ( ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'CustomTokenFactory'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $antlr4.Token.CommonToken$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $autorecurse.lib.antlr4.abstract.CharStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $autorecurse.lib.antlr4.abstract.CharStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $antlr4.RecognitionException$ 0 0 0 0 $antlr4.RecognitionException$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $autorecurse.lib.antlr4.abstract.TokenStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $autorecurse.lib.antlr4.abstract.TokenStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] import antlr4 [EOL] from antlr4 . Token import Token [EOL] from abc import ABCMeta , abstractmethod [EOL] from io import StringIO [EOL] from typing import cast , Tuple [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] class IntStream ( metaclass = ABCMeta ) : [EOL] [EOL] EOF = - [number] [EOL] UNKNOWN_SOURCE_NAME = [string] [EOL] [EOL] @ property @ abstractmethod def index ( self ) : [EOL] pass [EOL] [EOL] @ property @ abstractmethod def size ( self ) : [EOL] pass [EOL] [EOL] def getSourceName ( self ) : [EOL] return IntStream . UNKNOWN_SOURCE_NAME [EOL] [EOL] @ abstractmethod def mark ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def release ( self , marker ) : [EOL] pass [EOL] [EOL] @ abstractmethod def LA ( self , offset ) : [EOL] pass [EOL] [EOL] @ abstractmethod def consume ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def seek ( self , index ) : [EOL] pass [EOL] [EOL] [EOL] class CharStream ( IntStream ) : [EOL] [EOL] @ abstractmethod def getText ( self , start , stop ) : [EOL] pass [EOL] [EOL] [EOL] class TokenStream ( IntStream ) : [EOL] [EOL] @ abstractmethod def get ( self , index ) : [EOL] pass [EOL] [EOL] def getText ( self , interval = None ) : [EOL] if interval is not None : [EOL] index = interval [ [number] ] [EOL] stop_index = interval [ [number] ] + [number] [EOL] with StringIO ( ) as strbuffer : [EOL] while index != stop_index : [EOL] strbuffer . write ( self . get ( index ) . text ) [EOL] index = index + [number] [EOL] return cast ( StringIO , strbuffer ) . getvalue ( ) [EOL] else : [EOL] return self . getText ( ( [number] , self . _total_stream_size ) ) [EOL] [EOL] @ abstractmethod def LT ( self , offset ) : [EOL] pass [EOL] [EOL] @ property @ abstractmethod def _total_stream_size ( self ) : [EOL] pass [EOL] [EOL] [EOL] class TokenSource ( metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def nextToken ( self ) : [EOL] pass [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $antlr4.Token.Token$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 $builtins.int$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $antlr4.Token.Token$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $antlr4.Token.Token$ 0 0 0 0 0 0 0 0 0
import builtins [EOL] import os [EOL] import sys [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def autorecurse_path ( ) : [EOL] root_build_util = os . path . realpath ( sys . path [ [number] ] ) [EOL] root = os . path . dirname ( os . path . dirname ( root_build_util ) ) [EOL] return os . path . join ( root , [string] , [string] ) [EOL] [EOL] [EOL] if autorecurse_path ( ) not in sys . path : [EOL] sys . path . append ( autorecurse_path ( ) ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0