from typing import Any , Optional , Match [EOL] import typing [EOL] import re [EOL] [EOL] from setuptools import find_packages , setup [comment] [EOL] [EOL] with open ( [string] ) as f : [EOL] match = re . search ( [string] , f . read ( ) ) [EOL] assert match [EOL] version = match . group ( [number] ) [EOL] [EOL] with open ( [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = version , description = ( [string] [string] ) , long_description = readme , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , packages = find_packages ( exclude = ( [string] , ) ) , package_data = { [string] : [ [string] , [string] ] } , python_requires = [string] , install_requires = [ [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] } , scripts = [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Sequence , Generator , List [EOL] import builtins [EOL] import argparse [EOL] import rflx [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import pathlib [EOL] import sys [EOL] from typing import Sequence [EOL] [EOL] import tests . models [EOL] from rflx . generator import Generator [EOL] from rflx . parser import Parser [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] logging . disable ( logging . NOTSET ) [EOL] [EOL] [EOL] MODELS = [ tests . models . EXPRESSION_MODEL , tests . models . ENUMERATION_MODEL , tests . models . ARRAYS_MODEL , tests . models . DERIVATION_MODEL , tests . models . NULL_MODEL , tests . models . TLV_MODEL , tests . models . NULL_MESSAGE_IN_TLV_MESSAGE_MODEL , ] [EOL] [EOL] SPECIFICATION_FILES = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def main ( argv ) : [EOL] arg_parser = argparse . ArgumentParser ( ) [EOL] arg_parser . add_argument ( [string] , metavar = [string] , help = [string] , type = pathlib . Path ) [EOL] args = arg_parser . parse_args ( argv [ [number] : ] ) [EOL] [EOL] parser = Parser ( ) [EOL] for f in SPECIFICATION_FILES : [EOL] parser . parse ( pathlib . Path ( f ) ) [EOL] [EOL] generator = Generator ( [string] , reproducible = True ) [EOL] generator . generate ( parser . create_model ( ) ) [EOL] for model in MODELS : [EOL] generator . generate ( model ) [EOL] generator . write_units ( args . directory ) [EOL] generator . write_library_files ( args . directory ) [EOL] generator . write_top_level_package ( args . directory ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.model.model.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.model.model.Model]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import pkg_resources [EOL] import builtins [EOL] import sys [EOL] [EOL] from pkg_resources import DistributionNotFound , get_distribution [EOL] [EOL] [EOL] def check_dependencies ( ) : [EOL] result = True [EOL] [EOL] requirements = get_distribution ( [string] ) . requires ( extras = ( [string] , ) ) [EOL] for r in requirements : [EOL] try : [EOL] pkg = get_distribution ( r . name ) [comment] [EOL] if r . specifier and not r . specifier . contains ( pkg . version ) : [comment] [EOL] print ( f"{ r . name } [string] { pkg . version } [string] { r . specifier }" ) [EOL] result = False [EOL] except DistributionNotFound : [EOL] print ( f"{ r . name } [string] " ) [comment] [EOL] result = False [EOL] [EOL] return result [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if not check_dependencies ( ) : [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Union , Any , Counter [EOL] import pathlib [EOL] import rflx [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import pydotplus [EOL] import collections [EOL] import logging [EOL] from copy import copy [EOL] from math import sqrt [EOL] from pathlib import Path [EOL] from typing import Counter , Union [EOL] [EOL] from pydotplus import Dot , Edge , Node [EOL] [EOL] from rflx . expression import TRUE , UNDEFINED [EOL] from rflx . identifier import ID [EOL] from rflx . model import FINAL , INITIAL , Link , Message , Session , State [EOL] from rflx . statement import Assignment [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Graph : [EOL] def __init__ ( self , data ) : [EOL] self . __data = copy ( data ) [EOL] if isinstance ( self . __data , Session ) : [EOL] self . __degree = { s . name . name : len ( s . transitions ) for s in self . __data . states } [EOL] for s in self . __data . states : [EOL] for p in self . __data . states : [EOL] for t in p . transitions : [EOL] if t . target == s . name : [EOL] self . __degree [ s . name . name ] += [number] [EOL] [EOL] def __target_size ( self , link ) : [EOL] assert isinstance ( self . __data , Message ) [EOL] return str ( self . __data . field_size ( link . target ) ) [EOL] [EOL] def __edge_label ( self , link ) : [EOL] return [string] . format ( cond = str ( link . condition ) if link . condition != TRUE else [string] , sep1 = [string] if link . condition == TRUE or link . length == UNDEFINED else [string] , length = str ( link . length ) if link . length != UNDEFINED else self . __target_size ( link ) , sep2 = [string] if link . first == UNDEFINED else [string] , first = str ( link . first ) if link . first != UNDEFINED else [string] , ) [EOL] [EOL] @ property def get ( self ) : [EOL] if isinstance ( self . __data , Message ) : [EOL] return self . __get_message [EOL] if isinstance ( self . __data , Session ) : [EOL] return self . __get_session [EOL] raise NotImplementedError ( f" [string] { type ( self . __data ) . __name__ }" ) [EOL] [EOL] @ classmethod def __graph_with_defaults ( cls , name ) : [EOL] [docstring] [EOL] [EOL] result = Dot ( graph_name = f' [string] { name } [string] ' ) [EOL] result . set_graph_defaults ( splines = [string] , ranksep = [string] , pad = [string] , truecolor = [string] , bgcolor = [string] ) [EOL] result . set_edge_defaults ( fontname = [string] , fontcolor = [string] , color = [string] , penwidth = [string] ) [EOL] result . set_node_defaults ( fontname = [string] , fontcolor = [string] , color = [string] , fillcolor = [string] , width = [string] , style = [string] , shape = [string] , ) [EOL] return result [EOL] [EOL] def __add_state ( self , state , result , variables ) : [EOL] [EOL] assert isinstance ( self . __data , Session ) [EOL] [EOL] height = sqrt ( self . __degree [ state . name . name ] + [number] ) [EOL] width = [number] * sqrt ( self . __degree [ state . name . name ] + [number] ) [EOL] variables_read = collections . Counter ( ) [EOL] variables_write = collections . Counter ( ) [EOL] [EOL] if state . name == self . __data . initial : [EOL] result . add_node ( Node ( name = str ( state . name . name ) , fillcolor = [string] , fontcolor = [string] , width = f"{ width : [string] }" , height = f"{ height : [string] }" , ) ) [EOL] elif state . name == self . __data . final : [EOL] result . add_node ( Node ( name = str ( state . name . name ) , fillcolor = [string] , width = f"{ width : [string] }" , height = f"{ height : [string] }" , ) ) [EOL] else : [EOL] result . add_node ( Node ( name = str ( state . name . name ) , width = f"{ width : [string] }" , height = f"{ height : [string] }" ) ) [EOL] [EOL] for index , t in enumerate ( state . transitions ) : [EOL] label = ( f"{ state . name . name } [string] { t . target . name } [string] { index } [string] { t . condition }" [EOL] if t . condition != TRUE [EOL] else [string] ) [EOL] result . add_edge ( Edge ( src = str ( state . name . name ) , dst = str ( t . target . name ) , tooltip = label ) ) [EOL] variables_read . update ( [ v . identifier for v in t . condition . variables ( ) if v . identifier not in state . declarations ] ) [EOL] [EOL] for index , a in enumerate ( state . actions ) : [EOL] if a . name not in state . declarations : [EOL] variables_write . update ( [ a . name ] ) [EOL] if isinstance ( a , Assignment ) : [EOL] variables_read . update ( [ v . identifier for v in a . expression . variables ( ) if v . identifier not in state . declarations ] ) [EOL] [EOL] for v in variables_read : [EOL] result . add_edge ( Edge ( src = str ( v ) , dst = str ( state . name . name ) , tooltip = f"{ state . name . name } [string] { v }" ) ) [EOL] for v in variables_write : [EOL] result . add_edge ( Edge ( src = str ( state . name . name ) , dst = str ( v ) , tooltip = f"{ state . name . name } [string] { v }" ) ) [EOL] [EOL] variables . update ( variables_read ) [EOL] variables . update ( variables_write ) [EOL] [EOL] @ property def __get_session ( self ) : [EOL] [docstring] [EOL] [EOL] assert isinstance ( self . __data , Session ) [EOL] [EOL] variables = collections . Counter ( ) [EOL] result = self . __graph_with_defaults ( [string] ) [EOL] for s in self . __data . states : [EOL] self . __add_state ( s , result , variables ) [EOL] [EOL] for v , d in variables . items ( ) : [EOL] height = sqrt ( d + [number] ) [EOL] width = [number] * height [EOL] result . add_node ( Node ( name = str ( v ) , fillcolor = [string] , width = f"{ width : [string] }" , height = f"{ height : [string] }" ) ) [EOL] [EOL] return result [EOL] [EOL] @ property def __get_message ( self ) : [EOL] [docstring] [EOL] [EOL] assert isinstance ( self . __data , Message ) [EOL] [EOL] if not self . __data . structure : [EOL] self . __data . structure = [ Link ( INITIAL , FINAL ) ] [EOL] [EOL] result = self . __graph_with_defaults ( self . __data . full_name ) [EOL] result . add_node ( Node ( name = [string] , fillcolor = [string] , shape = [string] , width = [string] , label = [string] ) ) [EOL] for f in self . __data . fields : [EOL] result . add_node ( Node ( name = f . name ) ) [EOL] for i , l in enumerate ( self . __data . structure ) : [EOL] intermediate_node = f" [string] { i }" [EOL] result . add_node ( Node ( name = intermediate_node , label = self . __edge_label ( l ) , style = [string] , fontname = [string] , fontcolor = [string] , color = [string] , penwidth = [string] , width = [string] , height = [string] , ) ) [EOL] result . add_edge ( Edge ( src = l . source . name , dst = intermediate_node , arrowhead = [string] ) ) [EOL] result . add_edge ( Edge ( src = intermediate_node , dst = l . target . name , minlen = [string] ) ) [EOL] result . add_node ( Node ( name = [string] , fillcolor = [string] , shape = [string] , width = [string] , label = [string] ) ) [EOL] return result [EOL] [EOL] def write ( self , filename , fmt = [string] ) : [EOL] log . info ( [string] , filename ) [EOL] [EOL] with open ( filename , [string] ) as f : [EOL] self . get . write ( f , format = fmt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[rflx.model.Session,rflx.model.Message]$ 0 0 0 0 0 0 0 0 0 $typing.Union[rflx.model.Session,rflx.model.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Link$ 0 0 0 0 $rflx.model.Link$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $rflx.model.State$ 0 $pydotplus.Dot$ 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 $builtins.str$ 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 $typing.Counter[rflx.identifier.ID]$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pydotplus.Dot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Sequence , Any , List , Mapping [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from abc import abstractmethod [EOL] from typing import TYPE_CHECKING , Mapping , Sequence [EOL] [EOL] from rflx . common import Base [EOL] from rflx . error import Location [EOL] from rflx . identifier import ID , StrID [EOL] [EOL] if TYPE_CHECKING : [EOL] from rflx . expression import Expr [EOL] [EOL] [EOL] class Declaration ( Base ) : [EOL] def __init__ ( self , identifier , location = None ) : [EOL] self . __identifier = ID ( identifier ) [EOL] self . location = location [EOL] self . __refcount = [number] [EOL] [EOL] def reference ( self ) : [EOL] self . __refcount += [number] [EOL] [EOL] @ property def identifier ( self ) : [EOL] return self . __identifier [EOL] [EOL] @ property def is_referenced ( self ) : [EOL] return self . __refcount > [number] [EOL] [EOL] @ abstractmethod def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class VariableDeclaration ( Declaration ) : [EOL] def __init__ ( self , identifier , type_name = None , expression = None , location = None , ) : [EOL] super ( ) . __init__ ( identifier , location ) [EOL] self . __type_name = ID ( type_name ) if type_name else None [EOL] self . __expression = expression [EOL] [EOL] def __str__ ( self ) : [EOL] expression = f" [string] { self . __expression }" if self . __expression else [string] [EOL] return f"{ self . identifier } [string] { self . __type_name }{ expression }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] if self . __expression : [EOL] self . __expression . validate ( declarations ) [EOL] [EOL] [EOL] class PrivateDeclaration ( Declaration ) : [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . identifier } [string] " [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL] [EOL] [EOL] class Argument ( Base ) : [EOL] def __init__ ( self , name , type_name ) : [EOL] super ( ) . __init__ ( ) [EOL] self . __name = ID ( name ) [EOL] self . __type_name = ID ( type_name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . __name } [string] { self . __type_name }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL] [EOL] [EOL] class SubprogramDeclaration ( Declaration ) : [EOL] def __init__ ( self , identifier , arguments , return_type , location = None , ) : [EOL] super ( ) . __init__ ( identifier , location ) [EOL] self . __arguments = arguments [EOL] self . __return_type = ID ( return_type ) [EOL] [EOL] def __str__ ( self ) : [EOL] arguments = ( [string] + [string] . join ( map ( str , self . __arguments ) ) + [string] ) if self . __arguments else [string] [EOL] return f" [string] { self . identifier }{ arguments } [string] { self . __return_type }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] for a in self . __arguments : [EOL] a . validate ( declarations ) [EOL] [EOL] [EOL] class RenamingDeclaration ( Declaration ) : [EOL] def __init__ ( self , identifier , type_name , expression , location = None ) : [EOL] super ( ) . __init__ ( identifier , location ) [EOL] self . __type_name = ID ( type_name ) [EOL] self . __expression = expression [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . identifier } [string] { self . __type_name } [string] { self . __expression }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . __expression . validate ( declarations ) [EOL] [EOL] [EOL] class ChannelDeclaration ( Declaration ) : [EOL] def __init__ ( self , identifier , readable = False , writable = False , location = None , ) : [EOL] assert readable or writable [EOL] super ( ) . __init__ ( identifier , location ) [EOL] self . __readable = readable [EOL] self . __writable = writable [EOL] [EOL] def __str__ ( self ) : [EOL] aspects = [ ] [EOL] if self . __readable : [EOL] aspects . append ( [string] ) [EOL] if self . __writable : [EOL] aspects . append ( [string] ) [EOL] with_aspects = [string] + [string] . join ( aspects ) [EOL] return f"{ self . identifier } [string] { with_aspects }" [EOL] [EOL] @ property def readable ( self ) : [EOL] return self . __readable [EOL] [EOL] @ property def writable ( self ) : [EOL] return self . __writable [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.identifier.StrID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $typing.Sequence[Argument]$ 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 $typing.Sequence[rflx.declaration.Argument]$ 0 $typing.Sequence[Argument]$ 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.identifier.StrID$ 0 $"Expr"$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 $rflx.expression.Expr$ 0 $"Expr"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,"Declaration"]$ 0 0 0 0 0
[comment] [EOL] from typing import Union , Type , Mapping , List , Sequence , Dict , Optional , Any , Tuple , Iterator , Callable [EOL] import z3 [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] import operator [EOL] from abc import abstractmethod [EOL] from enum import Enum [EOL] from sys import intern [EOL] from typing import Callable , List , Mapping , Optional , Sequence , Tuple , Union [EOL] [EOL] import z3 [EOL] [EOL] import rflx . ada as ada [EOL] import rflx . typing_ as rty [EOL] from rflx . common import Base , indent , indent_next , unique [EOL] from rflx . contract import DBC , invariant , require [EOL] from rflx . declaration import ChannelDeclaration , Declaration , VariableDeclaration [EOL] from rflx . error import Location , RecordFluxError , Severity , Subsystem , fail [EOL] from rflx . identifier import ID , StrID [EOL] [EOL] [EOL] class Precedence ( Enum ) : [EOL] undefined = [number] [EOL] boolean_operator = [number] [EOL] relational_operator = [number] [EOL] binary_adding_operator = [number] [EOL] unary_adding_operator = [number] [EOL] multiplying_operator = [number] [EOL] highest_precedence_operator = [number] [EOL] literal = [number] [EOL] [EOL] [EOL] class ProofResult ( Enum ) : [EOL] sat = z3 . sat [EOL] unsat = z3 . unsat [EOL] unknown = z3 . unknown [EOL] [EOL] [EOL] class Proof : [EOL] def __init__ ( self , expr , facts = None ) : [EOL] self . __expr = expr [EOL] self . __facts = facts or [ ] [EOL] self . __result = ProofResult . unsat [EOL] [EOL] solver = z3 . Solver ( ) [EOL] solver . add ( self . __expr . z3expr ( ) ) [EOL] for f in self . __facts : [EOL] solver . add ( f . z3expr ( ) ) [EOL] [EOL] self . __result = ProofResult ( solver . check ( ) ) [EOL] [EOL] @ property def result ( self ) : [EOL] return self . __result [EOL] [EOL] @ property def error ( self ) : [EOL] assert self . __result == ProofResult . unsat [EOL] solver = z3 . Solver ( ) [EOL] solver . set ( unsat_core = True ) [EOL] facts = { f" [string] { index }" : fact for index , fact in enumerate ( self . __facts ) } [EOL] for name , fact in facts . items ( ) : [EOL] solver . assert_and_track ( fact . z3expr ( ) , name ) [EOL] [EOL] solver . assert_and_track ( self . __expr . z3expr ( ) , [string] ) [EOL] facts [ [string] ] = self . __expr [EOL] result = solver . check ( ) [EOL] assert result == z3 . unsat , f" [string] { result } [string] " [EOL] return [ ( [string] . join ( str ( facts [ str ( fact ) ] ) . replace ( [string] , [string] ) . split ( ) ) , facts [ fact ] . location ) for fact in sorted ( [ str ( h ) for h in solver . unsat_core ( ) ] ) ] [EOL] [EOL] [EOL] class Expr ( DBC , Base ) : [EOL] _str = ... [EOL] [EOL] def __init__ ( self , type_ = rty . Undefined ( ) , location = None , error = None , ) : [EOL] self . type_ = type_ [EOL] self . location = location [EOL] self . error = error or RecordFluxError ( ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return str ( self ) == str ( other ) [EOL] return NotImplemented [EOL] [EOL] def __str__ ( self ) : [EOL] try : [EOL] return self . _str [EOL] except AttributeError : [EOL] self . _update_str ( ) [EOL] return self . _str [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . __class__ . __name__ ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __le__ ( self , other ) : [EOL] if isinstance ( other , Expr ) : [EOL] return self == other [EOL] return NotImplemented [EOL] [EOL] def __gt__ ( self , other ) : [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __ge__ ( self , other ) : [EOL] if isinstance ( other , Expr ) : [EOL] return self == other [EOL] return NotImplemented [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item == self [EOL] [EOL] @ abstractmethod def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def _update_str ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abstractmethod def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [comment] [EOL] def variables ( self ) : [EOL] return [ ] [EOL] [EOL] def findall ( self , match ) : [EOL] return [ self ] if match ( self ) else [ ] [EOL] [EOL] @ require ( lambda func , mapping : ( func and mapping is None ) or ( not func and mapping is not None ) ) def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] return func ( self ) [EOL] [EOL] @ abstractmethod def simplified ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def parenthesized ( self , expr ) : [EOL] if expr . precedence . value <= self . precedence . value : [EOL] return [string] + indent_next ( str ( expr ) , [number] ) + [string] [EOL] return str ( expr ) [EOL] [EOL] @ abstractmethod def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def check ( self , facts = None ) : [EOL] return Proof ( self , facts ) [EOL] [EOL] @ abstractmethod def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class BooleanLiteral ( Expr ) : [EOL] _str = ... [EOL] [EOL] def __init__ ( self , location = None ) : [EOL] super ( ) . __init__ ( rty . BOOLEAN , location ) [EOL] self . _update_str ( ) [EOL] [EOL] @ abstractmethod def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] def simplified ( self ) : [EOL] return self [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL] [EOL] [EOL] class BooleanTrue ( BooleanLiteral ) : [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] def __neg__ ( self ) : [EOL] return FALSE [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . TRUE [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . BoolVal ( True ) [EOL] [EOL] [EOL] TRUE = BooleanTrue ( ) [EOL] [EOL] [EOL] class BooleanFalse ( BooleanLiteral ) : [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] def __neg__ ( self ) : [EOL] return TRUE [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . FALSE [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . BoolVal ( False ) [EOL] [EOL] [EOL] FALSE = BooleanFalse ( ) [EOL] [EOL] [EOL] class Not ( Expr ) : [EOL] def __init__ ( self , expr ) : [EOL] super ( ) . __init__ ( rty . BOOLEAN ) [EOL] self . expr = expr [EOL] [EOL] check_type ( self . error , expr , rty . BOOLEAN ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f" [string] { self . parenthesized ( self . expr ) }" ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . expr [EOL] [EOL] def variables ( self ) : [EOL] return self . expr . variables ( ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . highest_precedence_operator [EOL] [EOL] def simplified ( self ) : [EOL] for relation , inverse_relation in [ ( Less , GreaterEqual ) , ( LessEqual , Greater ) , ( Equal , NotEqual ) , ( GreaterEqual , Less ) , ( Greater , LessEqual ) , ( NotEqual , Equal ) , ] : [EOL] if isinstance ( self . expr , relation ) : [EOL] return inverse_relation ( self . expr . left . simplified ( ) , self . expr . right . simplified ( ) ) [EOL] return self . __class__ ( self . expr . simplified ( ) ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Not ( self . expr . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] z3expr = self . expr . z3expr ( ) [EOL] if isinstance ( z3expr , z3 . BoolRef ) : [EOL] return z3 . Not ( z3expr ) [EOL] raise TypeError [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . expr . validate ( declarations ) [EOL] [EOL] [EOL] class BinExpr ( Expr ) : [EOL] def __init__ ( self , left , right , type_ = rty . Undefined ( ) , location = None ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f" [string] { self . __class__ . __name__ } [string] " + [string] . join ( indent ( repr ( t ) , [number] ) for t in [ self . left , self . right ] ) + [string] ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f"{ self . parenthesized ( self . left ) }{ self . symbol }{ self . parenthesized ( self . right ) }" ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( - self . left , self . right ) [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item == self or item in ( self . left , self . right ) [EOL] [EOL] @ property @ abstractmethod def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def variables ( self ) : [EOL] return list ( unique ( self . left . variables ( ) + self . right . variables ( ) ) ) [EOL] [EOL] def findall ( self , match ) : [EOL] return [ * ( [ self ] if match ( self ) else [ ] ) , * self . left . findall ( match ) , * self . right . findall ( match ) , ] [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , BinExpr ) : [EOL] return expr . __class__ ( expr . left . substituted ( func ) , expr . right . substituted ( func ) , location = expr . location ) [EOL] return expr [EOL] [EOL] def simplified ( self ) : [EOL] return self . __class__ ( self . left . simplified ( ) , self . right . simplified ( ) ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . left . validate ( declarations ) [EOL] self . right . validate ( declarations ) [EOL] [EOL] @ property @ abstractmethod def symbol ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class AssExpr ( Expr ) : [EOL] def __init__ ( self , * terms , location = None ) : [EOL] super ( ) . __init__ ( rty . Undefined ( ) , location ) [EOL] self . terms = list ( terms ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( f" [string] { self . __class__ . __name__ } [string] " + [string] . join ( indent ( repr ( t ) , [number] ) for t in self . terms ) + [string] ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( self . symbol . join ( map ( self . parenthesized , self . terms ) ) [EOL] if self . terms [EOL] else str ( self . neutral_element ( ) ) ) [EOL] [EOL] @ abstractmethod def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item == self or any ( item in term for term in self . terms ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , AssExpr ) : [EOL] if len ( self . terms ) == len ( other . terms ) : [EOL] lt = [ x < y for x , y in zip ( self . terms , other . terms ) ] [EOL] eq = [ x == y for x , y in zip ( self . terms , other . terms ) ] [EOL] return any ( lt ) and all ( map ( ( lambda x : x [ [number] ] or x [ [number] ] ) , zip ( lt , eq ) ) ) [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __le__ ( self , other ) : [EOL] if isinstance ( other , AssExpr ) : [EOL] if len ( self . terms ) == len ( other . terms ) : [EOL] return all ( [ x <= y for x , y in zip ( self . terms , other . terms ) ] ) [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __gt__ ( self , other ) : [EOL] if isinstance ( other , AssExpr ) : [EOL] if len ( self . terms ) == len ( other . terms ) : [EOL] gt = [ x > y for x , y in zip ( self . terms , other . terms ) ] [EOL] eq = [ x == y for x , y in zip ( self . terms , other . terms ) ] [EOL] return any ( gt ) and all ( map ( ( lambda x : x [ [number] ] or x [ [number] ] ) , zip ( gt , eq ) ) ) [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __ge__ ( self , other ) : [EOL] if isinstance ( other , AssExpr ) : [EOL] if len ( self . terms ) == len ( other . terms ) : [EOL] return all ( [ x >= y for x , y in zip ( self . terms , other . terms ) ] ) [EOL] return False [EOL] return NotImplemented [EOL] [EOL] @ property @ abstractmethod def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def variables ( self ) : [EOL] return list ( unique ( [ v for t in self . terms for v in t . variables ( ) ] ) ) [EOL] [EOL] def findall ( self , match ) : [EOL] return [ * ( [ self ] if match ( self ) else [ ] ) , * [ m for t in self . terms for m in t . findall ( match ) ] , ] [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , AssExpr ) : [EOL] return expr . __class__ ( * [ t . substituted ( func ) for t in expr . terms ] , location = expr . location ) [EOL] return expr [EOL] [EOL] def simplified ( self ) : [EOL] terms = [ ] [EOL] all_terms = list ( self . terms ) [EOL] total = self . neutral_element ( ) [EOL] for term in all_terms : [EOL] t = term . simplified ( ) [EOL] if isinstance ( t , Number ) : [EOL] total = self . operation ( total , t . value ) [EOL] elif isinstance ( t , BooleanTrue ) : [EOL] total = self . operation ( total , [number] ) [EOL] elif isinstance ( t , BooleanFalse ) : [EOL] total = self . operation ( total , [number] ) [EOL] elif isinstance ( t , type ( self ) ) : [EOL] all_terms += t . terms [EOL] else : [EOL] terms . append ( t ) [EOL] boolean = isinstance ( self , ( And , Or ) ) [EOL] if not terms : [EOL] if boolean : [EOL] return TRUE if total else FALSE [EOL] return Number ( total ) [EOL] if total != self . neutral_element ( ) : [EOL] if boolean : [EOL] terms . append ( TRUE if total else FALSE ) [EOL] else : [EOL] terms . append ( Number ( total ) ) [EOL] if len ( terms ) == [number] : [EOL] return terms [ [number] ] [EOL] return self . __class__ ( * terms , location = self . location ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] for term in self . terms : [EOL] term . validate ( declarations ) [EOL] [EOL] @ abstractmethod def operation ( self , left , right ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def neutral_element ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abstractmethod def symbol ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class BoolAssExpr ( AssExpr ) : [EOL] def __init__ ( self , * terms , location = None ) : [EOL] super ( ) . __init__ ( * terms , location = location ) [EOL] self . type_ = rty . BOOLEAN [EOL] [EOL] for t in terms : [EOL] check_type ( self . error , t , rty . BOOLEAN ) [EOL] [EOL] def _update_str ( self ) : [EOL] if not self . terms : [EOL] self . _str = str ( TRUE ) [EOL] return [EOL] self . _str = [string] [EOL] for i , t in reversed ( list ( enumerate ( self . terms ) ) ) : [EOL] if i == [number] : [EOL] self . _str = self . parenthesized ( t ) + self . _str [EOL] else : [EOL] self . _str = ( [string] + str ( self . symbol ) [ [number] : ] + indent_next ( self . parenthesized ( t ) , len ( self . symbol ) - [number] ) + self . _str ) [EOL] self . _str = intern ( self . _str ) [EOL] [EOL] @ abstractmethod def operation ( self , left , right ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def neutral_element ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abstractmethod def symbol ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class And ( BoolAssExpr ) : [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . boolean_operator [EOL] [EOL] def simplified ( self ) : [EOL] simplified_expr = super ( ) . simplified ( ) [EOL] if isinstance ( simplified_expr , And ) and FALSE in simplified_expr . terms : [EOL] return FALSE [EOL] return simplified_expr [EOL] [EOL] def operation ( self , left , right ) : [EOL] return left and right [EOL] [EOL] def neutral_element ( self ) : [EOL] return [number] [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . And ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] def z3expr ( self ) : [EOL] z3exprs = [ t . z3expr ( ) for t in self . terms ] [EOL] boolexprs = [ t for t in z3exprs if isinstance ( t , z3 . BoolRef ) ] [EOL] assert len ( z3exprs ) == len ( boolexprs ) [EOL] return z3 . And ( * boolexprs ) [EOL] [EOL] [EOL] class AndThen ( And ) : [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . AndThen ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] [EOL] class Or ( BoolAssExpr ) : [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . boolean_operator [EOL] [EOL] def simplified ( self ) : [EOL] simplified_expr = super ( ) . simplified ( ) [EOL] if isinstance ( simplified_expr , Or ) and TRUE in simplified_expr . terms : [EOL] return TRUE [EOL] return simplified_expr [EOL] [EOL] def operation ( self , left , right ) : [EOL] return left or right [EOL] [EOL] def neutral_element ( self ) : [EOL] return [number] [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Or ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] def z3expr ( self ) : [EOL] z3exprs = [ t . z3expr ( ) for t in self . terms ] [EOL] boolexprs = [ t for t in z3exprs if isinstance ( t , z3 . BoolRef ) ] [EOL] assert len ( z3exprs ) == len ( boolexprs ) [EOL] return z3 . Or ( * boolexprs ) [EOL] [EOL] [EOL] class OrElse ( Or ) : [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . OrElse ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] [EOL] class Number ( Expr ) : [EOL] def __init__ ( self , value , base = [number] , location = None ) : [EOL] super ( ) . __init__ ( rty . UniversalInteger ( rty . Bounds ( value , value ) ) , location ) [EOL] self . value = value [EOL] self . base = base [EOL] [EOL] def _update_str ( self ) : [EOL] value = self . value if self . value >= [number] else - self . value [EOL] if self . base == [number] : [EOL] self . _str = [string] . format ( value ) [EOL] elif self . base == [number] : [EOL] self . _str = [string] . format ( value ) [EOL] elif self . base == [number] : [EOL] self . _str = [string] . format ( value ) [EOL] elif self . base == [number] : [EOL] self . _str = [string] . format ( value ) [EOL] elif self . base == [number] : [EOL] self . _str = [string] . format ( value ) [EOL] else : [EOL] raise NotImplementedError ( f" [string] { self . base }" ) [EOL] self . _str = intern ( f" [string] { self . _str } [string] " if self . value < [number] else self . _str ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] def __int__ ( self ) : [EOL] return self . value [EOL] [EOL] def __neg__ ( self ) : [EOL] return Number ( - self . value ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return Number ( self . value + other . value ) [EOL] return NotImplemented [EOL] [EOL] def __sub__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return Number ( self . value - other . value ) [EOL] return NotImplemented [EOL] [EOL] def __mul__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return Number ( self . value * other . value ) [EOL] return NotImplemented [EOL] [EOL] def __floordiv__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] if self . value % other . value == [number] : [EOL] return Number ( self . value // other . value ) [EOL] return Div ( Number ( self . value ) , Number ( other . value ) ) [EOL] return NotImplemented [EOL] [EOL] def __pow__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return Number ( self . value ** other . value ) [EOL] return NotImplemented [EOL] [EOL] def __mod__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return Number ( self . value % other . value ) [EOL] return NotImplemented [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return self . value == other . value [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return self . value < other . value [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __le__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return self . value <= other . value [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __gt__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return self . value > other . value [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] def __ge__ ( self , other ) : [EOL] if isinstance ( other , Number ) : [EOL] return self . value >= other . value [EOL] if isinstance ( other , Expr ) : [EOL] return False [EOL] return NotImplemented [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] def simplified ( self ) : [EOL] return self [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Number ( self . value , self . base ) [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . IntVal ( self . value ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL] [EOL] [EOL] class MathAssExpr ( AssExpr ) : [EOL] def __init__ ( self , * terms , location = None ) : [EOL] super ( ) . __init__ ( * terms , location = location ) [EOL] common_type = rty . common_type ( [ t . type_ for t in terms ] ) [EOL] self . type_ = common_type if common_type != rty . Undefined ( ) else rty . UndefinedInteger ( ) [EOL] [EOL] for t in terms : [EOL] check_type ( self . error , t , rty . AnyInteger ( ) ) [EOL] [EOL] [EOL] class Add ( MathAssExpr ) : [EOL] def _update_str ( self ) : [EOL] if not self . terms : [EOL] self . _str = intern ( str ( self . neutral_element ( ) ) ) [EOL] return [EOL] self . _str = str ( self . terms [ [number] ] ) [EOL] for t in self . terms [ [number] : ] : [EOL] if ( isinstance ( t , Number ) and t . value < [number] ) or ( isinstance ( t , Name ) and t . negative ) : [EOL] self . _str += f" [string] { self . parenthesized ( - t ) }" [EOL] else : [EOL] self . _str += f"{ self . symbol }{ self . parenthesized ( t ) }" [EOL] self . _str = intern ( self . _str ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return Add ( * [ - term for term in self . terms ] ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . binary_adding_operator [EOL] [EOL] def operation ( self , left , right ) : [EOL] return left + right [EOL] [EOL] def simplified ( self ) : [EOL] expr = super ( ) . simplified ( ) [EOL] if not isinstance ( expr , Add ) : [EOL] return expr [EOL] terms = [ ] [EOL] for term in reversed ( expr . terms ) : [EOL] complement = False [EOL] for other in terms : [EOL] if other == - term : [EOL] terms . remove ( other ) [EOL] complement = True [EOL] break [EOL] if not complement : [EOL] terms . insert ( [number] , term ) [EOL] if len ( terms ) == [number] : [EOL] return terms [ [number] ] [EOL] return Add ( * terms , location = self . location ) [EOL] [EOL] def neutral_element ( self ) : [EOL] return [number] [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Add ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] def z3expr ( self ) : [EOL] terms = [ t for t in map ( lambda e : e . z3expr ( ) , self . terms ) if isinstance ( t , z3 . ArithRef ) ] [EOL] assert len ( terms ) == len ( self . terms ) , [string] [EOL] return z3 . Sum ( * terms ) [EOL] [EOL] [EOL] class Mul ( MathAssExpr ) : [EOL] def __neg__ ( self ) : [EOL] return Mul ( * list ( self . terms ) + [ Number ( - [number] ) ] ) . simplified ( ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . multiplying_operator [EOL] [EOL] def operation ( self , left , right ) : [EOL] return left * right [EOL] [EOL] def neutral_element ( self ) : [EOL] return [number] [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Mul ( * [ t . ada_expr ( ) for t in self . terms ] ) [EOL] [EOL] def z3expr ( self ) : [EOL] terms = [ t for t in map ( lambda e : e . z3expr ( ) , self . terms ) if isinstance ( t , z3 . ArithRef ) ] [EOL] assert len ( terms ) == len ( self . terms ) , [string] [EOL] return z3 . Product ( * terms ) [EOL] [EOL] [EOL] class MathBinExpr ( BinExpr ) : [EOL] def __init__ ( self , left , right , location = None ) : [EOL] super ( ) . __init__ ( left , right , rty . common_type ( [ left . type_ , right . type_ ] ) , location ) [EOL] [EOL] for e in [ left , right ] : [EOL] check_type ( self . error , e , rty . AnyInteger ( ) ) [EOL] [EOL] [EOL] class Sub ( MathBinExpr ) : [EOL] @ property def precedence ( self ) : [EOL] return Precedence . binary_adding_operator [EOL] [EOL] def simplified ( self ) : [EOL] left = self . left . simplified ( ) [EOL] right = self . right . simplified ( ) [EOL] if isinstance ( left , Number ) and isinstance ( right , Number ) : [EOL] return left - right [EOL] return Add ( left , - right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Sub ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left - right [EOL] [EOL] [EOL] class Div ( MathBinExpr ) : [EOL] @ property def precedence ( self ) : [EOL] return Precedence . multiplying_operator [EOL] [EOL] def simplified ( self ) : [EOL] left = self . left . simplified ( ) [EOL] right = self . right . simplified ( ) [EOL] if isinstance ( left , Number ) and isinstance ( right , Number ) : [EOL] return left // right [EOL] return Div ( left , right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Div ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left / right [EOL] [EOL] [EOL] class Pow ( MathBinExpr ) : [EOL] @ property def precedence ( self ) : [EOL] return Precedence . highest_precedence_operator [EOL] [EOL] def simplified ( self ) : [EOL] left = self . left . simplified ( ) [EOL] right = self . right . simplified ( ) [EOL] if isinstance ( left , Number ) and isinstance ( right , Number ) : [EOL] return left ** right [EOL] return Pow ( left , right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Pow ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left ** right [EOL] [EOL] [EOL] class Mod ( MathBinExpr ) : [EOL] @ property def precedence ( self ) : [EOL] return Precedence . multiplying_operator [EOL] [EOL] def simplified ( self ) : [EOL] left = self . left . simplified ( ) [EOL] right = self . right . simplified ( ) [EOL] if isinstance ( left , Number ) and isinstance ( right , Number ) : [EOL] return left % right [EOL] return Mod ( left , right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Mod ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left % right [EOL] [EOL] [EOL] class Name ( Expr ) : [EOL] def __init__ ( self , negative = False , immutable = False , type_ = rty . Undefined ( ) , location = None , ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . negative = negative [EOL] self . immutable = immutable [EOL] self . _update_str ( ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f" [string] { self . representation } [string] " if self . negative else self . representation ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] @ property @ abstractmethod def representation ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] if self . immutable : [EOL] return self [EOL] func = substitution ( mapping or { } , func ) [EOL] return - func ( - self ) if self . negative else func ( self ) [EOL] [EOL] def simplified ( self ) : [EOL] return self [EOL] [EOL] @ abstractmethod def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Variable ( Name ) : [EOL] def __init__ ( self , identifier , negative = False , immutable = False , type_ = rty . Undefined ( ) , location = None , ) : [EOL] self . identifier = ID ( identifier ) [EOL] super ( ) . __init__ ( negative , immutable , type_ , location ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return self . negative == other . negative and self . identifier == other . identifier [EOL] return NotImplemented [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . identifier ) [EOL] [EOL] @ property def name ( self ) : [EOL] return str ( self . identifier ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . identifier , not self . negative , self . immutable , self . type_ , self . location ) [EOL] [EOL] @ property def representation ( self ) : [EOL] return str ( self . name ) [EOL] [EOL] def variables ( self ) : [EOL] return [ self ] [EOL] [EOL] def validate ( self , declarations ) : [EOL] builtin_types = map ( ID , [ [string] , [string] , [string] ] ) [EOL] if self . identifier in builtin_types : [EOL] return [EOL] if self . identifier not in declarations : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location ) [EOL] declarations [ self . identifier ] . reference ( ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Variable ( ada . ID ( self . identifier ) , self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] if self . negative : [EOL] return - z3 . Int ( self . name ) [EOL] return z3 . Int ( self . name ) [EOL] [EOL] [EOL] class Attribute ( Name ) : [EOL] def __init__ ( self , prefix , negative = False ) : [EOL] if isinstance ( prefix , ID ) : [EOL] prefix = Variable ( prefix , location = prefix . location ) [EOL] if isinstance ( prefix , str ) : [EOL] prefix = Variable ( prefix ) [EOL] [EOL] self . prefix = prefix [EOL] super ( ) . __init__ ( negative , location = prefix . location ) [EOL] self . _init_type ( ) [EOL] check_type ( self . error , self . prefix , rty . Any ( ) ) [EOL] [EOL] @ abstractmethod def _init_type ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def representation ( self ) : [EOL] return f"{ self . prefix } [string] { self . __class__ . __name__ }" [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . prefix , not self . negative ) [EOL] [EOL] def findall ( self , match ) : [EOL] return [ self ] if match ( self ) else self . prefix . findall ( match ) [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( - self if self . negative else self ) [EOL] if isinstance ( expr , Attribute ) : [EOL] expr = expr . __class__ ( expr . prefix . substituted ( func ) ) [EOL] return - expr if self . negative else expr [EOL] [EOL] def simplified ( self ) : [EOL] expr = self . __class__ ( self . prefix . simplified ( ) ) [EOL] return - expr if self . negative else expr [EOL] [EOL] def variables ( self ) : [EOL] return self . prefix . variables ( ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return getattr ( ada , self . __class__ . __name__ ) ( self . prefix . ada_expr ( ) , self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] if not isinstance ( self . prefix , Variable ) : [EOL] raise TypeError [EOL] name = f"{ self . prefix } [string] { self . __class__ . __name__ }" [EOL] if self . negative : [EOL] return - z3 . Int ( name ) [EOL] return z3 . Int ( name ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . prefix . validate ( declarations ) [EOL] [EOL] [EOL] class Size ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . UniversalInteger ( ) [EOL] [EOL] [EOL] class Length ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . UniversalInteger ( ) [EOL] [EOL] [EOL] class First ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . UniversalInteger ( ) [EOL] [EOL] [EOL] class Last ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . UniversalInteger ( ) [EOL] [EOL] [EOL] class ValidChecksum ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . BOOLEAN [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . BoolVal ( True ) [EOL] [EOL] @ property def representation ( self ) : [EOL] return f"{ self . prefix } [string] " [EOL] [EOL] [EOL] class Valid ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . BOOLEAN [EOL] [EOL] [EOL] class Present ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . BOOLEAN [EOL] [EOL] [EOL] class Head ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . Undefined ( ) [EOL] [EOL] [EOL] class Opaque ( Attribute ) : [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . Aggregate ( rty . UniversalInteger ( rty . Bounds ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] class Val ( Attribute ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , prefix , expression , negative = False ) : [EOL] self . expression = expression [EOL] super ( ) . __init__ ( prefix ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . prefix , self . expression , not self . negative ) [EOL] [EOL] def _init_type ( self ) : [EOL] self . type_ = rty . Any ( ) [EOL] [EOL] def variables ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def findall ( self , match ) : [EOL] raise NotImplementedError [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] return self [EOL] [EOL] def simplified ( self ) : [EOL] return self [EOL] [EOL] @ property def representation ( self ) : [EOL] return f"{ self . prefix } [string] { self . __class__ . __name__ } [string] { self . expression } [string] " [EOL] [EOL] def ada_expr ( self ) : [EOL] return getattr ( ada , self . __class__ . __name__ ) ( self . prefix . ada_expr ( ) , self . expression . ada_expr ( ) , self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] @ invariant ( lambda self : len ( self . elements ) > [number] ) class Indexed ( Name ) : [EOL] def __init__ ( self , prefix , * elements , negative = False ) : [EOL] self . prefix = prefix [EOL] self . elements = list ( elements ) [EOL] super ( ) . __init__ ( negative ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . prefix , * self . elements , negative = not self . negative ) [EOL] [EOL] @ property def representation ( self ) : [EOL] return f"{ self . prefix } [string] " + [string] . join ( map ( str , self . elements ) ) + [string] [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Indexed ( self . prefix . ada_expr ( ) , * [ e . ada_expr ( ) for e in self . elements ] , negative = self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Selected ( Name ) : [EOL] def __init__ ( self , prefix , selector_name , negative = False , immutable = False , type_ = rty . Undefined ( ) , location = None , ) : [EOL] self . prefix = prefix [EOL] self . selector_name = ID ( selector_name ) [EOL] super ( ) . __init__ ( negative , immutable , type_ , location ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . prefix , self . selector_name , not self . negative ) [EOL] [EOL] @ property def representation ( self ) : [EOL] return f"{ self . prefix } [string] { self . selector_name }" [EOL] [EOL] def variables ( self ) : [EOL] return self . prefix . variables ( ) [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] assert isinstance ( expr , Selected ) [EOL] return expr . __class__ ( expr . prefix . substituted ( func ) , expr . selector_name , location = expr . location ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Selected ( self . prefix . ada_expr ( ) , ada . ID ( self . selector_name ) , self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . prefix . validate ( declarations ) [EOL] [EOL] [EOL] class Call ( Name ) : [EOL] def __init__ ( self , name , args = None , negative = False , immutable = False , type_ = rty . Undefined ( ) , location = None , ) : [EOL] self . name = ID ( name ) [EOL] self . args = args or [ ] [EOL] super ( ) . __init__ ( negative , immutable , type_ , location ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return self . __class__ ( self . name , self . args , not self . negative ) [EOL] [EOL] @ property def representation ( self ) : [EOL] args = [string] . join ( map ( str , self . args ) ) [EOL] if args : [EOL] args = f" [string] { args } [string] " [EOL] call = f"{ self . name }{ args }" [EOL] return call [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Call ( ada . ID ( self . name ) , [ a . ada_expr ( ) for a in self . args ] , self . negative ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def __validate_channel ( self , declarations , error ) : [EOL] if len ( self . args ) < [number] : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] channel_id = self . args [ [number] ] [EOL] if not isinstance ( channel_id , Variable ) : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] assert isinstance ( channel_id , Variable ) [EOL] if channel_id . identifier not in declarations : [EOL] fail ( f' [string] { channel_id } [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] [EOL] assert isinstance ( channel_id , Variable ) [EOL] channel = declarations [ channel_id . identifier ] [EOL] if not isinstance ( channel , ChannelDeclaration ) : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] [EOL] assert isinstance ( channel , ChannelDeclaration ) [EOL] channel . reference ( ) [EOL] if self . name in map ( ID , [ [string] , [string] ] ) and not channel . writable : [EOL] error . append ( f' [string] { channel_id } [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] if self . name in map ( ID , [ [string] , [string] , [string] ] ) and not channel . readable : [EOL] error . append ( f' [string] { channel_id } [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] for a in self . args [ [number] : ] : [EOL] a . validate ( declarations ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] error = RecordFluxError ( ) [EOL] if self . name in map ( ID , [ [string] , [string] , [string] , [string] ] ) : [EOL] self . __validate_channel ( declarations , error ) [EOL] else : [EOL] if self . name not in map ( ID , [ [string] , [string] ] ) : [EOL] if self . name not in declarations : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] declarations [ self . name ] . reference ( ) [EOL] for a in self . args : [EOL] try : [EOL] a . validate ( declarations ) [EOL] except RecordFluxError as e : [EOL] error . extend ( e ) [EOL] error . propagate ( ) [EOL] [EOL] def variables ( self ) : [EOL] result = [ ] [EOL] for t in self . args : [EOL] result . extend ( t . variables ( ) ) [EOL] return result [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] assert isinstance ( expr , Call ) [EOL] return expr . __class__ ( expr . name , [ a . substituted ( func ) for a in expr . args ] , expr . negative , expr . immutable , expr . type_ , expr . location , ) [EOL] [EOL] [EOL] class UndefinedExpr ( Name ) : [EOL] @ property def representation ( self ) : [EOL] return [string] [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] UNDEFINED = UndefinedExpr ( ) [EOL] [EOL] [EOL] @ invariant ( lambda self : len ( self . elements ) > [number] ) class Aggregate ( Expr ) : [EOL] def __init__ ( self , * elements , location = None ) : [EOL] super ( ) . __init__ ( rty . Aggregate ( rty . common_type ( [ e . type_ for e in elements ] ) ) , location ) [EOL] self . elements = list ( elements ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( [string] + [string] . join ( map ( str , self . elements ) ) + [string] ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , self . __class__ ) : [EOL] return expr . __class__ ( * [ e . substituted ( func ) for e in expr . elements ] , location = expr . location ) [EOL] return expr [EOL] [EOL] def simplified ( self ) : [EOL] return self . __class__ ( * [ e . simplified ( ) for e in self . elements ] ) [EOL] [EOL] @ property def length ( self ) : [EOL] return Number ( len ( self . elements ) ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Aggregate ( * [ e . ada_expr ( ) for e in self . elements ] ) [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . BoolVal ( False ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class String ( Aggregate ) : [EOL] def __init__ ( self , data , location = None ) : [EOL] super ( ) . __init__ ( * [ Number ( ord ( d ) ) for d in data ] , location = location ) [EOL] self . data = data [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f' [string] { self . data } [string] ' ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] return func ( self ) [EOL] [EOL] def simplified ( self ) : [EOL] return self [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . String ( self . data ) [EOL] [EOL] def z3expr ( self ) : [EOL] return z3 . BoolVal ( False ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] pass [EOL] [EOL] [EOL] class Relation ( BinExpr ) : [EOL] def __init__ ( self , left , right , location = None ) : [EOL] super ( ) . __init__ ( left , right , rty . BOOLEAN , location ) [EOL] self . _check_type ( ) [EOL] [EOL] @ abstractmethod def _check_type ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def _simplified ( self , relation_operator ) : [EOL] left = self . left . simplified ( ) [EOL] right = self . right . simplified ( ) [EOL] if relation_operator in [ operator . eq , operator . le , operator . ge ] and left == right : [EOL] return TRUE [EOL] if isinstance ( left , Number ) and isinstance ( right , Number ) : [EOL] return TRUE if relation_operator ( left , right ) else FALSE [EOL] return self . __class__ ( left , right ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . relational_operator [EOL] [EOL] [EOL] class Less ( Relation ) : [EOL] def _check_type ( self ) : [EOL] for e in [ self . left , self . right ] : [EOL] check_type ( self . error , e , rty . AnyInteger ( ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return GreaterEqual ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . lt ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Less ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left < right [EOL] [EOL] [EOL] class LessEqual ( Relation ) : [EOL] def _check_type ( self ) : [EOL] for e in [ self . left , self . right ] : [EOL] check_type ( self . error , e , rty . AnyInteger ( ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return Greater ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . le ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . LessEqual ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left <= right [EOL] [EOL] [EOL] class Equal ( Relation ) : [EOL] def _check_type ( self ) : [EOL] check_type ( self . error , self . left , rty . Any ( ) ) [EOL] check_type ( self . error , self . right , self . left . type_ ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return NotEqual ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . eq ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Equal ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] result = left == right [EOL] assert isinstance ( result , z3 . BoolRef ) [EOL] return result [EOL] [EOL] [EOL] class GreaterEqual ( Relation ) : [EOL] def _check_type ( self ) : [EOL] for e in [ self . left , self . right ] : [EOL] check_type ( self . error , e , rty . AnyInteger ( ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return Less ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . ge ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . GreaterEqual ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left >= right [EOL] [EOL] [EOL] class Greater ( Relation ) : [EOL] def _check_type ( self ) : [EOL] for e in [ self . left , self . right ] : [EOL] check_type ( self . error , e , rty . AnyInteger ( ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return LessEqual ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . gt ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Greater ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] assert isinstance ( left , z3 . ArithRef ) and isinstance ( right , z3 . ArithRef ) [EOL] return left > right [EOL] [EOL] [EOL] class NotEqual ( Relation ) : [EOL] def _check_type ( self ) : [EOL] check_type ( self . error , self . left , rty . Any ( ) ) [EOL] check_type ( self . error , self . right , self . left . type_ ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return Equal ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def simplified ( self ) : [EOL] return self . _simplified ( operator . ne ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . NotEqual ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] left = self . left . z3expr ( ) [EOL] right = self . right . z3expr ( ) [EOL] result = left != right [EOL] assert isinstance ( result , z3 . BoolRef ) [EOL] return result [EOL] [EOL] [EOL] class In ( Relation ) : [EOL] def _check_type ( self ) : [EOL] check_type ( self . error , self . right , rty . Aggregate ( self . left . type_ ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return NotIn ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . In ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class NotIn ( Relation ) : [EOL] def _check_type ( self ) : [EOL] check_type ( self . error , self . right , rty . Aggregate ( self . left . type_ ) ) [EOL] [EOL] def __neg__ ( self ) : [EOL] return In ( self . left , self . right ) [EOL] [EOL] @ property def symbol ( self ) : [EOL] return [string] [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . NotIn ( self . left . ada_expr ( ) , self . right . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class QuantifiedExpression ( Expr ) : [EOL] def __init__ ( self , parameter_name , iterable , predicate , location = None , ) : [EOL] super ( ) . __init__ ( rty . BOOLEAN , location ) [EOL] self . parameter_name = ID ( parameter_name ) [EOL] self . iterable = iterable [EOL] self . predicate = predicate [EOL] [EOL] check_type ( self . error , iterable , rty . Aggregate ( rty . Any ( ) ) ) [EOL] check_type ( self . error , predicate , rty . BOOLEAN ) [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f" [string] { self . quantifier } [string] { self . parameter_name } [string] { self . keyword } [string] { self . iterable } [string] " + indent ( str ( self . predicate ) , [number] ) + [string] ) [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] @ property @ abstractmethod def quantifier ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property @ abstractmethod def keyword ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def variables ( self ) : [EOL] return list ( unique ( v for v in self . iterable . variables ( ) + self . predicate . variables ( ) if v . identifier != self . parameter_name ) ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return getattr ( ada , self . __class__ . __name__ ) ( self . parameter_name , self . iterable . ada_expr ( ) , self . predicate . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] assert isinstance ( expr , QuantifiedExpression ) [EOL] return expr . __class__ ( expr . parameter_name , expr . iterable . substituted ( func ) , expr . predicate . substituted ( func ) , location = expr . location , ) [EOL] [EOL] def simplified ( self ) : [EOL] return self . __class__ ( self . parameter_name , self . iterable . simplified ( ) , self . predicate . simplified ( ) ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] quantifier = { self . parameter_name : VariableDeclaration ( self . parameter_name ) } [EOL] self . iterable . validate ( { ** declarations , ** quantifier } ) [EOL] self . predicate . validate ( { ** declarations , ** quantifier } ) [EOL] [EOL] [EOL] class ForAllOf ( QuantifiedExpression ) : [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def quantifier ( self ) : [EOL] return [string] [EOL] [EOL] @ property def keyword ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ForAllIn ( QuantifiedExpression ) : [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def quantifier ( self ) : [EOL] return [string] [EOL] [EOL] @ property def keyword ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ForSomeIn ( QuantifiedExpression ) : [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def quantifier ( self ) : [EOL] return [string] [EOL] [EOL] @ property def keyword ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] class ValueRange ( Expr ) : [EOL] def __init__ ( self , lower , upper , type_ = rty . Undefined ( ) , location = None ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . lower = lower [EOL] self . upper = upper [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f"{ self . lower } [string] { self . upper }" ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , self . __class__ ) : [EOL] return self . __class__ ( self . lower . substituted ( func ) , self . upper . substituted ( func ) , ) [EOL] return expr [EOL] [EOL] def simplified ( self ) : [EOL] return self . __class__ ( self . lower . simplified ( ) , self . upper . simplified ( ) ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . ValueRange ( self . lower . ada_expr ( ) , self . upper . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Conversion ( Expr ) : [EOL] def __init__ ( self , name , argument , type_ = rty . Undefined ( ) , location = None , ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . name = ID ( name ) [EOL] self . argument = argument [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f"{ self . name } [string] { self . argument } [string] " ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] return Precedence . literal [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , Conversion ) : [EOL] return expr . __class__ ( self . name , self . argument . substituted ( func ) , location = expr . location ) [EOL] return expr [EOL] [EOL] def simplified ( self ) : [EOL] return Conversion ( self . name , self . argument . simplified ( ) , self . type_ , self . location ) [EOL] [EOL] def ada_expr ( self ) : [EOL] return ada . Conversion ( ada . ID ( self . name ) , self . argument . ada_expr ( ) ) [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] def variables ( self ) : [EOL] return self . argument . variables ( ) [EOL] [EOL] [EOL] class Comprehension ( Expr ) : [EOL] def __init__ ( self , iterator , array , selector , condition , type_ = rty . Undefined ( ) , location = None , ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . iterator = ID ( iterator ) [EOL] self . array = array [EOL] self . selector = selector [EOL] self . condition = condition [EOL] [EOL] def _update_str ( self ) : [EOL] self . _str = intern ( f" [string] { self . iterator } [string] { self . array } [string] { self . selector } [string] { self . condition } [string] " ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def simplified ( self ) : [EOL] return Comprehension ( self . iterator , self . array . simplified ( ) , self . selector . simplified ( ) , self . condition . simplified ( ) , self . type_ , self . location , ) [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , Comprehension ) : [EOL] return expr . __class__ ( expr . iterator , expr . array . substituted ( func ) , expr . selector . substituted ( func ) , expr . condition . substituted ( func ) , expr . type_ , expr . location , ) [EOL] return expr [EOL] [EOL] @ property def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] decls = { ** declarations , self . iterator : VariableDeclaration ( self . iterator ) , } [EOL] self . array . validate ( decls ) [EOL] self . selector . validate ( decls ) [EOL] self . condition . validate ( decls ) [EOL] [EOL] def variables ( self ) : [EOL] return [ v for v in self . array . variables ( ) + self . selector . variables ( ) + self . condition . variables ( ) if v . identifier != self . iterator ] [EOL] [EOL] [EOL] class MessageAggregate ( Expr ) : [EOL] def __init__ ( self , name , data , type_ = rty . Undefined ( ) , location = None , ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . name = ID ( name ) [EOL] self . data = { ID ( k ) : v for k , v in data . items ( ) } [EOL] [EOL] def _update_str ( self ) : [EOL] data = ( [string] . join ( f"{ k } [string] { self . data [ k ] }" for k in self . data ) if self . data else [string] ) [EOL] self . _str = intern ( f"{ self . name } [string] { data } [string] " ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def simplified ( self ) : [EOL] return MessageAggregate ( self . name , { k : self . data [ k ] . simplified ( ) for k in self . data } , self . type_ , self . location ) [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] func = substitution ( mapping or { } , func ) [EOL] expr = func ( self ) [EOL] if isinstance ( expr , MessageAggregate ) : [EOL] return expr . __class__ ( expr . name , { k : expr . data [ k ] . substituted ( func ) for k in expr . data } , expr . type_ , location = expr . location , ) [EOL] return expr [EOL] [EOL] @ property def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def validate ( self , declarations ) : [EOL] for k in self . data : [EOL] self . data [ k ] . validate ( declarations ) [EOL] [EOL] def variables ( self ) : [EOL] result = [ ] [EOL] for v in self . data . values ( ) : [EOL] result . extend ( v . variables ( ) ) [EOL] return result [EOL] [EOL] [EOL] class Binding ( Expr ) : [EOL] def __init__ ( self , expr , data , type_ = rty . Undefined ( ) , location = None , ) : [EOL] super ( ) . __init__ ( type_ , location ) [EOL] self . expr = expr [EOL] self . data = { ID ( k ) : v for k , v in data . items ( ) } [EOL] [EOL] def _update_str ( self ) : [EOL] data = [string] . join ( [string] . format ( k = k , v = self . data [ k ] ) for k in self . data ) [EOL] self . _str = intern ( f"{ self . expr } [string] { indent_next ( data , [number] ) }" ) [EOL] [EOL] def __neg__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def simplified ( self ) : [EOL] facts = { Variable ( k ) : self . data [ k ] . simplified ( ) for k in self . data } [EOL] return self . expr . substituted ( mapping = facts ) . simplified ( ) [EOL] [EOL] def substituted ( self , func = None , mapping = None ) : [EOL] raise NotImplementedError [EOL] [EOL] @ property def precedence ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def ada_expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def z3expr ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def variables ( self ) : [EOL] return self . simplified ( ) . variables ( ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . simplified ( ) . validate ( declarations ) [EOL] [EOL] [EOL] def substitution ( mapping , func = None ) : [EOL] if func : [EOL] return func [EOL] return lambda expression : ( mapping [ expression ] [EOL] if isinstance ( expression , Name ) and expression in mapping [EOL] else expression ) [EOL] [EOL] [EOL] def check_type ( error , expression , expected ) : [EOL] if expression . type_ == rty . Undefined ( ) : [EOL] details = f' [string] { expression . name } [string] ' if isinstance ( expression , Variable ) else [string] [EOL] error . append ( f" [string] { details }" , Subsystem . MODEL , Severity . ERROR , expression . location , ) [EOL] return [EOL] [EOL] if expected != rty . Undefined ( ) and not expression . type_ . is_compatible ( expected ) : [EOL] error . append ( f" [string] { expected }" , Subsystem . MODEL , Severity . ERROR , expression . location , ) [EOL] error . append ( f" [string] { expression . type_ }" , Subsystem . MODEL , Severity . INFO , expression . location , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Expr$ 0 0 0 $typing.Callable[[rflx.expression.Expr],rflx.expression.Expr]$ 0 0 0 $typing.Mapping[Name,Expr]$ 0 0 0 0 0 $typing.Callable[[rflx.expression.Expr],rflx.expression.Expr]$ 0 0 0 $typing.Mapping[Name,Expr]$ 0 0 0 0 $typing.Callable[[rflx.expression.Expr],rflx.expression.Expr]$ 0 0 $rflx.expression.Expr$ 0 $typing.Callable[[rflx.expression.Expr],rflx.expression.Expr]$ 0 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 0 0 0 $typing.Callable[[rflx.expression.Expr],rflx.expression.Expr]$ 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 $Precedence$ 0 0 0 0 0 0 0 0 0 0 $rflx.ada.Expr$ 0 0 0 0 0 0 0 0 0 0 $z3.ExprRef$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 $typing.List["Variable"]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $rflx.expression.Expr$ 0 0 0 $rflx.typing_.Type$ 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.typing_.Type$ 0 $rflx.error.Location$ 0 0 0 0 $rflx.expression.Expr$ 0 $rflx.expression.Expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $Expr$ 0 0 0 0 0 0 0 0 0 0 $Expr$ 0 0 0 0 0 $typing.Mapping[Name,Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[Name,Expr]$ 0 0 0 0 0 0 0 0 $Expr$ 0 0 0 $typing.Callable[[Expr],Expr]$ 0 0 0 $typing.Mapping[Name,Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 $Precedence$ 0 0 0 0 0 0 0 0 0 0 $rflx.ada.Expr$ 0 0 0 0 0 0 0 0 0 0 $z3.ExprRef$ 0 0 0 0 0 0 0 0 0 0 $typing.List["Variable"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Union , Any , Optional [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Optional , Sequence , Union [EOL] [EOL] from rflx . error import Location [EOL] [EOL] [EOL] class ID : [EOL] def __init__ ( self , identifier , location = None ) : [EOL] self . _parts = ... [EOL] self . location = location [EOL] [EOL] if isinstance ( identifier , str ) : [EOL] self . _parts = identifier . split ( self . _separator ) [EOL] elif isinstance ( identifier , list ) : [EOL] self . _parts = identifier [EOL] elif isinstance ( identifier , ID ) : [EOL] self . _parts = list ( identifier . parts ) [EOL] self . location = location or identifier . location [EOL] else : [EOL] assert False , f' [string] { type ( identifier ) . __name__ } [string] ' [EOL] [EOL] assert self . _parts , [string] [EOL] assert [string] not in self . _parts , [string] [EOL] for c in [ [string] , [string] , [string] ] : [EOL] assert all ( c not in part for part in self . _parts ) , f' [string] { c } [string] ' [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return self . parts == other . parts [EOL] return NotImplemented [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , self . __class__ ) : [EOL] return str ( self ) < str ( other ) [EOL] return NotImplemented [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( tuple ( self . parts ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self } [string] ' [EOL] [EOL] def __str__ ( self ) : [EOL] return self . _separator . join ( self . parts ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] if isinstance ( other , ( str , ID ) ) : [EOL] return self . __class__ ( f"{ self }{ other }" , self . __location ( other ) ) [EOL] return NotImplemented [EOL] [EOL] def __radd__ ( self , other ) : [EOL] if isinstance ( other , ( str , ID ) ) : [EOL] return self . __class__ ( f"{ other }{ self }" , self . __location ( other ) ) [EOL] return NotImplemented [EOL] [EOL] def __mul__ ( self , other ) : [EOL] if isinstance ( other , ( str , ID ) ) : [EOL] if str ( other ) == [string] : [EOL] return self . __class__ ( self , self . __location ( other ) ) [EOL] return self . __class__ ( f"{ self }{ self . _separator }{ other }" , self . __location ( other ) ) [EOL] return NotImplemented [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] if isinstance ( other , ( str , ID ) ) : [EOL] if str ( other ) == [string] : [EOL] return self . __class__ ( self , self . __location ( other ) ) [EOL] return self . __class__ ( f"{ other }{ self . _separator }{ self }" , self . __location ( other ) ) [EOL] return NotImplemented [EOL] [EOL] def __location ( self , other ) : [EOL] if isinstance ( other , str ) : [EOL] return self . location [EOL] if isinstance ( other , ID ) : [EOL] if self . location is None and other . location is None : [EOL] return None [EOL] if self . location is None : [EOL] return other . location [EOL] return self . location [EOL] raise NotImplementedError [EOL] [EOL] @ property def parts ( self ) : [EOL] return self . _parts [EOL] [EOL] @ property def name ( self ) : [EOL] return self . __class__ ( self . _parts [ - [number] ] ) [EOL] [EOL] @ property def parent ( self ) : [EOL] return self . __class__ ( self . _parts [ : - [number] ] ) [EOL] [EOL] @ property def _separator ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] StrID = Union [ str , ID ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 $rflx.error.Location$ 0 $rflx.error.Location$ 0 0 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 $rflx.error.Location$ 0 $rflx.error.Location$ 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.Sequence[builtins.str],"ID"]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $typing.Optional[rflx.error.Location]$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ID"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
from typing import Sequence , Mapping [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Mapping , Sequence [EOL] [EOL] from rflx . common import Base [EOL] from rflx . declaration import Declaration [EOL] from rflx . error import Location , RecordFluxError , Severity , Subsystem , fail [EOL] from rflx . expression import Expr [EOL] from rflx . identifier import ID , StrID [EOL] [EOL] [EOL] class Statement ( Base ) : [EOL] def __init__ ( self , name , location = None ) : [EOL] self . name = ID ( name ) [EOL] self . location = location [EOL] self . error = RecordFluxError ( ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Assignment ( Statement ) : [EOL] def __init__ ( self , name , expression , location = None ) : [EOL] super ( ) . __init__ ( name , location ) [EOL] self . expression = expression [EOL] [EOL] def __str__ ( self ) : [EOL] return f"{ self . name } [string] { self . expression }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] if self . name not in declarations : [EOL] self . error . append ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] else : [EOL] declarations [ self . name ] . reference ( ) [EOL] try : [EOL] self . expression . validate ( declarations ) [EOL] except RecordFluxError as e : [EOL] self . error . extend ( e ) [EOL] self . error . propagate ( ) [EOL] [EOL] [EOL] class Erase ( Statement ) : [EOL] def __str__ ( self ) : [EOL] return f"{ self . name } [string] " [EOL] [EOL] def validate ( self , declarations ) : [EOL] if self . name not in declarations : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] declarations [ self . name ] . reference ( ) [EOL] [EOL] [EOL] class AttributeStatement ( Statement ) : [EOL] def __init__ ( self , name , attribute , parameters , location = None ) : [EOL] super ( ) . __init__ ( name , location ) [EOL] self . attribute = attribute [EOL] self . parameters = parameters [EOL] [EOL] def __str__ ( self ) : [EOL] parameters = [string] . join ( str ( p ) for p in self . parameters ) [EOL] return f"{ self . name } [string] { self . attribute }" + ( f" [string] { parameters } [string] " if parameters else [string] ) [EOL] [EOL] [EOL] class ListAttributeStatement ( AttributeStatement ) : [EOL] def __init__ ( self , name , parameter , location = None ) : [EOL] super ( ) . __init__ ( name , self . __class__ . __name__ , [ parameter ] , location ) [EOL] [EOL] [EOL] class Append ( ListAttributeStatement ) : [EOL] pass [EOL] [EOL] [EOL] class Extend ( ListAttributeStatement ) : [EOL] pass [EOL] [EOL] [EOL] class Reset ( AttributeStatement ) : [EOL] def __init__ ( self , name , location = None ) : [EOL] super ( ) . __init__ ( name , self . __class__ . __name__ , [ ] , location ) [EOL] [EOL] def validate ( self , declarations ) : [EOL] if self . name not in declarations : [EOL] fail ( f' [string] { self . name } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] declarations [ self . name ] . reference ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.ID$ 0 0 0 0 $rflx.error.Location$ 0 $rflx.error.Location$ 0 0 0 $rflx.error.RecordFluxError$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $rflx.identifier.StrID$ 0 $rflx.expression.Expr$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 $rflx.expression.Expr$ 0 $rflx.expression.Expr$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $rflx.identifier.StrID$ 0 $builtins.str$ 0 $typing.Sequence[rflx.expression.Expr]$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Sequence[rflx.expression.Expr]$ 0 $typing.Sequence[rflx.expression.Expr]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $rflx.identifier.StrID$ 0 $rflx.expression.Expr$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $rflx.identifier.StrID$ 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.StrID$ 0 0 0 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 $None$ 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.identifier.ID,rflx.declaration.Declaration]$ 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Callable , Optional [EOL] import reprlib [EOL] import typing [EOL] import builtins [EOL] if __debug__ : [EOL] [EOL] [comment] [EOL] from icontract import DBC , DBCMeta , ViolationError , ensure , invariant , require , snapshot [EOL] [EOL] else : [EOL] [EOL] import abc [EOL] import reprlib [EOL] from typing import Any , Callable , Optional , Union [EOL] [EOL] class DBCMeta ( abc . ABCMeta ) : [comment] [EOL] pass [EOL] [EOL] class DBC ( metaclass = DBCMeta ) : [comment] [EOL] pass [EOL] [EOL] class ViolationError ( AssertionError ) : [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] def require ( condition , description = None , a_repr = None , enabled = __debug__ , error = None , ) : [EOL] return lambda x : x [EOL] [EOL] def snapshot ( capture , name = None , enabled = __debug__ ) : [EOL] return lambda x : x [EOL] [EOL] def ensure ( condition , description = None , a_repr = None , enabled = __debug__ , error = None , ) : [EOL] return lambda x : x [EOL] [EOL] def invariant ( condition , description = None , a_repr = None , enabled = __debug__ , error = None , ) : [EOL] return lambda x : x [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Type , Mapping , List , Deque , Set , Dict , Any , Tuple [EOL] import pathlib [EOL] import rflx [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import ast [EOL] import logging [EOL] from collections import deque [EOL] from pathlib import Path [EOL] from typing import Deque , Dict , List , Mapping , Set , Tuple [EOL] [EOL] from pyparsing import ParseException , ParseFatalException [EOL] [EOL] from rflx . error import ( RecordFluxError , Severity , Subsystem , fail , parser_location , pop_source , push_source , ) [EOL] from rflx . expression import UNDEFINED [EOL] from rflx . identifier import ID [EOL] from rflx . model import ( BUILTIN_TYPES , FINAL , INITIAL , INTERNAL_TYPES , Array , DerivedMessage , Enumeration , Field , Link , Message , Model , Refinement , Scalar , Session , Type , UnprovenDerivedMessage , UnprovenMessage , is_builtin_type , qualified_type_name , ) [EOL] [EOL] from . import grammar [EOL] from . ast import ( ArraySpec , Component , DerivationSpec , MessageSpec , PackageSpec , RefinementSpec , Specification , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Parser : [EOL] def __init__ ( self , skip_verification = False ) : [EOL] self . skip_verification = skip_verification [EOL] self . __specifications = deque ( ) [EOL] self . __evaluated_specifications = set ( ) [EOL] self . __types = { ** BUILTIN_TYPES , ** INTERNAL_TYPES } [EOL] self . __sessions = { } [EOL] [EOL] def parse ( self , specfile ) : [EOL] self . __parse ( specfile ) [EOL] [EOL] def __parse ( self , specfile , transitions = None ) : [EOL] error = RecordFluxError ( ) [EOL] log . info ( [string] , specfile ) [EOL] [EOL] if not transitions : [EOL] transitions = [ ] [EOL] [EOL] with open ( specfile , [string] ) as filehandle : [EOL] push_source ( specfile ) [EOL] try : [EOL] for specification in grammar . unit ( ) . parseFile ( filehandle ) : [EOL] check_naming ( error , specification . package , specfile . name ) [EOL] self . __specifications . appendleft ( specification ) [EOL] for item in specification . context . items : [EOL] transition = ( specification . package . identifier , item ) [EOL] if transition in transitions : [EOL] error . append ( f' [string] { transitions [ [number] ] [ [number] ] } [string] ' , Subsystem . PARSER , Severity . ERROR , transitions [ [number] ] [ [number] ] . location , ) [EOL] error . extend ( [ ( f' [string] { i } [string] ' , Subsystem . PARSER , Severity . INFO , i . location , ) for _ , i in transitions [ [number] : ] ] ) [EOL] continue [EOL] transitions . append ( transition ) [EOL] self . __parse ( specfile . parent / f"{ str ( item ) . lower ( ) } [string] " , transitions ) [EOL] except ( ParseException , ParseFatalException ) as e : [EOL] error . append ( e . msg , Subsystem . PARSER , Severity . ERROR , parser_location ( e . loc , e . loc , e . pstr , specfile ) , ) [EOL] finally : [EOL] pop_source ( ) [EOL] [EOL] error . propagate ( ) [EOL] [EOL] def parse_string ( self , string ) : [EOL] error = RecordFluxError ( ) [EOL] try : [EOL] for specification in grammar . unit ( ) . parseString ( string ) : [EOL] self . __specifications . appendleft ( specification ) [EOL] check_naming ( error , specification . package ) [EOL] except ( ParseException , ParseFatalException ) as e : [EOL] error . append ( e . msg , Subsystem . PARSER , Severity . ERROR , parser_location ( e . loc , e . loc , e . pstr ) , ) [EOL] error . propagate ( ) [EOL] [EOL] def create_model ( self ) : [EOL] error = RecordFluxError ( ) [EOL] for specification in self . __specifications : [EOL] if specification . package . identifier in self . __evaluated_specifications : [EOL] continue [EOL] self . __evaluated_specifications . add ( specification . package . identifier ) [EOL] try : [EOL] self . __evaluate_specification ( specification ) [EOL] except RecordFluxError as e : [EOL] error . extend ( e ) [EOL] try : [EOL] result = Model ( list ( self . __types . values ( ) ) , list ( self . __sessions . values ( ) ) ) [EOL] except RecordFluxError as e : [EOL] error . extend ( e ) [EOL] error . propagate ( ) [EOL] return result [EOL] [EOL] @ property def specifications ( self ) : [EOL] return { str ( s . package . identifier ) : s for s in self . __specifications } [EOL] [EOL] def __evaluate_specification ( self , specification ) : [EOL] log . info ( [string] , specification . package . identifier ) [EOL] [EOL] error = RecordFluxError ( ) [EOL] self . __evaluate_types ( specification , error ) [EOL] self . __evaluate_sessions ( specification , error ) [EOL] error . propagate ( ) [EOL] [EOL] def __evaluate_types ( self , spec , error ) : [EOL] for t in spec . package . types : [EOL] t . identifier = ID ( spec . package . identifier , t . identifier . location ) * t . name [EOL] [EOL] if t . identifier in self . __types : [EOL] error . append ( f' [string] { t . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , t . location , ) [EOL] error . append ( f' [string] { t . identifier } [string] ' , Subsystem . PARSER , Severity . INFO , self . __types [ t . identifier ] . location , ) [EOL] continue [EOL] [EOL] new_type = ... [EOL] [EOL] try : [EOL] if isinstance ( t , Scalar ) : [EOL] new_type = t [EOL] [EOL] elif isinstance ( t , ArraySpec ) : [EOL] new_type = create_array ( t , self . __types ) [EOL] [EOL] elif isinstance ( t , MessageSpec ) : [EOL] new_type = create_message ( t , self . __types , self . skip_verification ) [EOL] [EOL] elif isinstance ( t , DerivationSpec ) : [EOL] new_type = create_derived_message ( t , self . __types ) [EOL] [EOL] elif isinstance ( t , RefinementSpec ) : [EOL] new_type = create_refinement ( t , self . __types ) [EOL] [EOL] else : [EOL] raise NotImplementedError ( f' [string] { type ( t ) . __name__ } [string] ' ) [EOL] [EOL] self . __types [ t . identifier ] = new_type [EOL] error . extend ( new_type . error ) [EOL] [EOL] except RecordFluxError as e : [EOL] error . extend ( e ) [EOL] [EOL] def __evaluate_sessions ( self , spec , error ) : [EOL] for s in spec . package . sessions : [EOL] s . identifier = ID ( spec . package . identifier , s . identifier . location ) * s . identifier . name [EOL] [EOL] if s . identifier in self . __types or s . identifier in self . __sessions : [EOL] error . append ( f' [string] { s . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , s . location , ) [EOL] error . append ( f' [string] { s . identifier } [string] ' , Subsystem . PARSER , Severity . INFO , self . __types [ s . identifier ] . location [EOL] if s . identifier in self . __types [EOL] else self . __sessions [ s . identifier ] . location , ) [EOL] continue [EOL] [EOL] self . __sessions [ s . identifier ] = s [EOL] [EOL] [EOL] def message_types ( types ) : [EOL] return { n : m for n , m in types . items ( ) if isinstance ( m , Message ) } [EOL] [EOL] [EOL] def create_array ( array , types ) : [EOL] array . element_type . identifier = ID ( array . element_type . full_name . replace ( [string] , str ( array . package ) ) , array . location ) [EOL] [EOL] if array . element_type . identifier in types : [EOL] element_type = types [ array . element_type . identifier ] [EOL] else : [EOL] fail ( f' [string] { array . element_type . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , array . element_type . location , ) [EOL] [EOL] return Array ( array . identifier , element_type , array . location ) [EOL] [EOL] [EOL] def create_message ( message , types , skip_verification = False ) : [EOL] components = list ( message . components ) [EOL] [EOL] if components and components [ [number] ] . name : [EOL] components . insert ( [number] , Component ( ) ) [EOL] [EOL] field_types = { } [EOL] [EOL] error = RecordFluxError ( ) [EOL] [EOL] for component in components : [EOL] if component . name and component . type_name : [EOL] type_name = qualified_type_name ( component . type_name , message . package ) [EOL] if type_name not in types : [EOL] continue [EOL] field_types [ Field ( component . name ) ] = types [ type_name ] [EOL] [EOL] structure = [ ] [EOL] [EOL] for i , component in enumerate ( components ) : [EOL] if not component . name : [EOL] error . extend ( [ ( [string] , Subsystem . PARSER , Severity . ERROR , then . first . location , ) for then in component . thens if then . first != UNDEFINED ] ) [EOL] [EOL] source_node = Field ( component . name ) if component . name else INITIAL [EOL] [EOL] if not component . thens : [EOL] name = components [ i + [number] ] . name if i + [number] < len ( components ) else None [EOL] target_node = Field ( name ) if name else FINAL [EOL] structure . append ( Link ( source_node , target_node ) ) [EOL] [EOL] for then in component . thens : [EOL] target_node = Field ( then . name ) if then . name else FINAL [EOL] if then . name and target_node not in field_types . keys ( ) : [EOL] error . append ( f' [string] { then . name } [string] ' , Subsystem . PARSER , Severity . ERROR , then . name . location if then . name else None , ) [EOL] continue [EOL] structure . append ( Link ( source_node , target_node , then . condition , then . length , then . first , then . location ) ) [EOL] [EOL] return ( UnprovenMessage ( message . identifier , structure , field_types , message . aspects , message . location , error ) . merged ( ) . proven ( skip_verification ) ) [EOL] [EOL] [EOL] def create_derived_message ( derivation , types ) : [EOL] base_name = qualified_type_name ( derivation . base , derivation . package ) [EOL] messages = message_types ( types ) [EOL] error = RecordFluxError ( ) [EOL] [EOL] if base_name not in types : [EOL] fail ( f' [string] { base_name } [string] ' , Subsystem . PARSER , Severity . ERROR , derivation . location , ) [EOL] [EOL] if base_name not in messages : [EOL] error . append ( f' [string] { derivation . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , derivation . location , ) [EOL] error . append ( f' [string] { base_name } [string] ' , Subsystem . PARSER , Severity . INFO , types [ base_name ] . location , ) [EOL] error . propagate ( ) [EOL] [EOL] base = messages [ base_name ] [EOL] [EOL] if isinstance ( base , DerivedMessage ) : [EOL] error . append ( f' [string] { derivation . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , derivation . location , ) [EOL] error . append ( f' [string] { base_name } [string] ' , Subsystem . PARSER , Severity . INFO , base . location ) [EOL] error . propagate ( ) [EOL] [EOL] return ( UnprovenDerivedMessage ( derivation . identifier , base , location = derivation . location ) . merged ( ) . proven ( ) ) [EOL] [EOL] [EOL] def create_refinement ( refinement , types ) : [EOL] messages = message_types ( types ) [EOL] [EOL] refinement . pdu = qualified_type_name ( refinement . pdu , refinement . package ) [EOL] if refinement . pdu not in messages : [EOL] fail ( f' [string] { refinement . pdu } [string] ' , Subsystem . PARSER , Severity . ERROR , refinement . location , ) [EOL] [EOL] pdu = messages [ refinement . pdu ] [EOL] [EOL] error = RecordFluxError ( ) [EOL] for variable in refinement . condition . variables ( ) : [EOL] literals = [ l for e in pdu . types . values ( ) if isinstance ( e , Enumeration ) for l in e . literals . keys ( ) ] + [ e . package * l for e in types . values ( ) if isinstance ( e , Enumeration ) for l in e . literals . keys ( ) ] [EOL] [EOL] if Field ( str ( variable . name ) ) not in pdu . fields and variable . identifier not in literals : [EOL] error . append ( f' [string] { variable . identifier } [string] ' f' [string] { refinement . pdu } [string] ' , Subsystem . PARSER , Severity . ERROR , variable . location , ) [EOL] [EOL] refinement . sdu = qualified_type_name ( refinement . sdu , refinement . package ) [EOL] if refinement . sdu not in messages : [EOL] error . append ( f' [string] { refinement . sdu } [string] { refinement . pdu } [string] ' , Subsystem . PARSER , Severity . ERROR , refinement . sdu . location , ) [EOL] error . propagate ( ) [EOL] [EOL] sdu = messages [ refinement . sdu ] [EOL] [EOL] result = Refinement ( refinement . package , pdu , Field ( refinement . field ) , sdu , refinement . condition , refinement . location , ) [EOL] [EOL] result . error . extend ( error ) [EOL] if result in types . values ( ) : [EOL] result . error . append ( f' [string] { refinement . sdu } [string] ' , Subsystem . PARSER , Severity . ERROR , refinement . location , ) [EOL] result . error . append ( [string] , Subsystem . PARSER , Severity . INFO , types [ result . identifier ] . location , ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def check_naming ( error , package , filename = None ) : [EOL] if str ( package . identifier ) . startswith ( [string] ) : [EOL] error . append ( f' [string] { package . identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , package . identifier . location , ) [EOL] if package . identifier != package . end_identifier : [EOL] error . append ( f' [string] { package . end_identifier } [string] ' , Subsystem . PARSER , Severity . ERROR , package . end_identifier . location , ) [EOL] error . append ( f' [string] { package . identifier } [string] ' , Subsystem . PARSER , Severity . INFO , package . identifier . location , ) [EOL] if filename : [EOL] expected_filename = f"{ str ( package . identifier ) . lower ( ) } [string] " [EOL] if filename != expected_filename : [EOL] error . append ( f' [string] { package . identifier } [string] ' f' [string] { expected_filename } [string] ' , Subsystem . PARSER , Severity . ERROR , package . identifier . location , ) [EOL] for t in package . types : [EOL] if is_builtin_type ( t . identifier . name ) : [EOL] error . append ( f' [string] { t . identifier . name } [string] ' , Subsystem . MODEL , Severity . ERROR , t . location , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] RESERVED_WORDS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . parser import Parser [comment] [EOL]	0 0 0 0 0 0 0
from typing import Sequence , Type , Mapping [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Mapping , Sequence [EOL] [EOL] import rflx . expression as expr [EOL] from rflx . ada import ( ID , TRUE , Add , Aggregate , And , AndThen , Assignment , Call , CallStatement , CaseStatement , Constrained , Div , Equal , Expr , ExpressionFunctionDeclaration , ForAllIn , FormalSubprogramDeclaration , FunctionSpecification , GenericProcedureInstantiation , GreaterEqual , If , In , Indexed , InOutParameter , Last , LessEqual , Mod , NamedAggregate , Not , NullStatement , Number , ObjectDeclaration , Old , Or , OutParameter , Parameter , Postcondition , Precondition , ProcedureSpecification , Range , Selected , Size , Slice , Subprogram , SubprogramBody , SubprogramDeclaration , UnitPart , Variable , ) [EOL] from rflx . common import unique [EOL] from rflx . model import BUILTINS_PACKAGE , FINAL , Enumeration , Field , Message , Opaque , Scalar , Type [EOL] [EOL] from . import common , const [EOL] [EOL] [EOL] class GeneratorGenerator : [EOL] def __init__ ( self , prefix = [string] ) : [EOL] self . prefix = prefix [EOL] [EOL] def insert_function ( self , type_name ) : [EOL] return GenericProcedureInstantiation ( [string] , ProcedureSpecification ( const . TYPES * [string] , [ Parameter ( [ [string] ] , type_name ) , InOutParameter ( [ [string] ] , const . TYPES_BYTES ) , Parameter ( [ [string] ] , const . TYPES_OFFSET ) , ] , ) , [ common . prefixed_type_name ( type_name , self . prefix ) ] , ) [EOL] [EOL] def create_internal_functions ( self , message , scalar_fields ) : [EOL] return UnitPart ( [ ] , [ SubprogramBody ( ProcedureSpecification ( [string] , [ InOutParameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) , OutParameter ( [ [string] , [string] ] , const . TYPES_BIT_INDEX ) , ] , ) , [ * common . field_bit_location_declarations ( Variable ( [string] ) ) , * common . field_byte_location_declarations ( ) , * unique ( self . insert_function ( common . full_base_type_name ( t ) ) for t in message . types . values ( ) if isinstance ( t , Scalar ) ) , ] , [ Assignment ( [string] , Variable ( [string] ) ) , Assignment ( [string] , Variable ( [string] ) ) , CaseStatement ( Variable ( [string] ) , [ ( Variable ( f . affixed_name ) , [ CallStatement ( [string] , [ Variable ( f" [string] { f . name } [string] " ) , Slice ( Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , Variable ( [string] ) , ] , ) [EOL] if f in scalar_fields [EOL] else NullStatement ( ) ] , ) for f in message . all_fields ] , ) , ] , [ Precondition ( AndThen ( Not ( Constrained ( [string] ) ) , Call ( [string] , [ Variable ( [string] ) ] ) , In ( Variable ( [string] ) , Range ( [string] ) ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , common . sufficient_space_for_field_condition ( Variable ( [string] ) ) , ForAllIn ( [string] , Range ( [string] ) , If ( [ ( Call ( [string] , [ Indexed ( Variable ( [string] ) , Variable ( [string] ) , ) ] , ) , LessEqual ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) , ) , [string] , ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] , ) , ) , ) ] ) , ) , ) ) , Postcondition ( And ( Call ( [string] , [ Variable ( [string] ) ] ) , Equal ( Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , Equal ( Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , GreaterEqual ( Variable ( [string] ) , Variable ( [string] ) ) , LessEqual ( Variable ( [string] ) , Add ( Variable ( [string] ) , Number ( [number] ) ) ) , LessEqual ( Call ( const . TYPES_BYTE_INDEX , [ Variable ( [string] ) ] ) , Variable ( [string] ) , ) , ForAllIn ( [string] , Range ( [string] ) , If ( [ ( Call ( [string] , [ Indexed ( Variable ( [string] ) , Variable ( [string] ) , ) ] , ) , LessEqual ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) , ) , [string] , ) , Variable ( [string] ) , ) , ) ] ) , ) , * [ Equal ( e , Old ( e ) ) for e in [ Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ] ] , ) ) , ] , ) ] [EOL] if scalar_fields [EOL] else [ ] , ) [EOL] [EOL] def create_scalar_setter_procedures ( self , message , scalar_fields ) : [EOL] def specification ( field , field_type ) : [EOL] if field_type . package == BUILTINS_PACKAGE : [EOL] type_name = ID ( field_type . name ) [EOL] elif isinstance ( field_type , Enumeration ) and field_type . always_valid : [EOL] type_name = common . prefixed_type_name ( common . full_enum_name ( field_type ) , self . prefix ) [EOL] else : [EOL] type_name = common . prefixed_type_name ( ID ( field_type . identifier ) , self . prefix ) [EOL] [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ InOutParameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , type_name ) ] , ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ( f , t ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , Call ( [string] , [ Variable ( [string] ) , Aggregate ( Variable ( f . affixed_name ) , Call ( [string] , [ Variable ( [string] ) ] ) , ) , ] , ) , Call ( [string] , [ Call ( [string] , [ Variable ( [string] ) ] ) ] ) [EOL] if not isinstance ( t , Enumeration ) [EOL] else TRUE , common . sufficient_space_for_field_condition ( Variable ( f . affixed_name ) ) , ) ) , Postcondition ( And ( Call ( [string] , [ Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , Equal ( Call ( f" [string] { f . name }" , [ Variable ( [string] ) ] ) , Aggregate ( TRUE , Variable ( [string] ) ) [EOL] if isinstance ( t , Enumeration ) and t . always_valid [EOL] else Variable ( [string] ) , ) , * self . setter_postconditions ( message , f ) , * [ Equal ( Call ( [string] , [ Variable ( [string] ) , Variable ( p . affixed_name ) , ] , ) , Old ( Call ( [string] , [ Variable ( [string] ) , Variable ( p . affixed_name ) , ] , ) ) , ) for p in message . predecessors ( f ) ] , ) ) , ] , ) for f , t in scalar_fields . items ( ) ] , [ SubprogramBody ( specification ( f , t ) , [ ObjectDeclaration ( [ [string] ] , [string] , Aggregate ( Variable ( f . affixed_name ) , Call ( [string] , [ Variable ( [string] ) ] ) , ) , True , ) , ObjectDeclaration ( [ [string] , [string] ] , const . TYPES_BIT_INDEX ) , ] , [ CallStatement ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , CallStatement ( [string] , [ Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ] , ) , Assignment ( [string] , Aggregate ( Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , ) , Assignment ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , Selected ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) , ) , [string] , ) , ) , ) , ) , Assignment ( Indexed ( Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( f . affixed_name ) ) , ) , ) , ] , ) for f , t in scalar_fields . items ( ) ] , ) [EOL] [EOL] def create_composite_setter_empty_procedures ( self , message ) : [EOL] def specification ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name } [string] " , [ InOutParameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ * [ SubprogramDeclaration ( specification ( f ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , * self . unbounded_composite_setter_preconditions ( message , f ) , Equal ( Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) , ] , ) , Number ( [number] ) , ) , ) ) , Postcondition ( And ( * self . composite_setter_postconditions ( message , f ) ) ) , ] , ) for f , t in message . types . items ( ) if message . is_possibly_empty ( f ) ] , ] , [ SubprogramBody ( specification ( f ) , [ ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , True , ) , ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , True , ) , ] , [ CallStatement ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , Assignment ( [string] , Aggregate ( Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , ) , Assignment ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , NamedAggregate ( ( [string] , Variable ( f . affixed_name ) ) ) , ) , ( [string] , Selected ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) , ) , [string] , ) , ) , ) , ) , Assignment ( Indexed ( Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( f . affixed_name ) ) , ) , ) , ] , ) for f , t in message . types . items ( ) if message . is_possibly_empty ( f ) ] , ) [EOL] [EOL] def create_composite_setter_procedures ( self , message ) : [EOL] def specification ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ InOutParameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] def specification_bounded ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ InOutParameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , const . TYPES_BIT_LENGTH ) ] , ) [EOL] [EOL] def formal_parameters ( field ) : [EOL] return [ FormalSubprogramDeclaration ( ProcedureSpecification ( f" [string] { field . name }" , [ OutParameter ( [ field . name ] , const . TYPES_BYTES ) ] , ) ) , FormalSubprogramDeclaration ( FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , const . TYPES_LENGTH ) ] , ) ) , ] [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ( f ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , * self . unbounded_composite_setter_preconditions ( message , f ) , Call ( [string] , [ Call ( const . TYPES_LENGTH , [ Div ( Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) , ] , ) , Size ( const . TYPES_BYTE ) , ) , ] , ) , ] , ) , ) ) , Postcondition ( And ( * self . composite_setter_postconditions ( message , f ) , ) ) , ] , formal_parameters ( f ) , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and unbounded_setter_required ( message , f ) ] + [ SubprogramDeclaration ( specification_bounded ( f ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , * self . bounded_composite_setter_preconditions ( message , f ) , Call ( [string] , [ Call ( const . TYPES_LENGTH , [ Div ( Variable ( [string] ) , Size ( const . TYPES_BYTE ) ) ] , ) ] , ) , ) ) , Postcondition ( And ( * self . composite_setter_postconditions ( message , f ) , ) ) , ] , formal_parameters ( f ) , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and bounded_setter_required ( message , f ) ] , [ SubprogramBody ( specification ( f ) , [ * common . field_bit_location_declarations ( Variable ( f . affixed_name ) ) , ExpressionFunctionDeclaration ( FunctionSpecification ( [string] , const . TYPES_INDEX ) , Call ( const . TYPES_BYTE_INDEX , [ Variable ( [string] ) ] ) , ) , ExpressionFunctionDeclaration ( FunctionSpecification ( [string] , const . TYPES_INDEX ) , Call ( const . TYPES_BYTE_INDEX , [ Variable ( [string] ) ] ) , ) , ] , [ CallStatement ( f" [string] { f . name }" , [ Variable ( [string] ) ] ) , CallStatement ( f" [string] { f . name }" , [ Slice ( Selected ( Variable ( [string] ) , [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , ] , ) , ] , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and unbounded_setter_required ( message , f ) ] + [ SubprogramBody ( specification_bounded ( f ) , [ ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , True , ) , ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Add ( Variable ( [string] ) , Variable ( [string] ) , - Number ( [number] ) ) , True , ) , ExpressionFunctionDeclaration ( FunctionSpecification ( [string] , const . TYPES_INDEX ) , Call ( const . TYPES_BYTE_INDEX , [ Variable ( [string] ) ] ) , ) , ExpressionFunctionDeclaration ( FunctionSpecification ( [string] , const . TYPES_INDEX ) , Call ( const . TYPES_BYTE_INDEX , [ Variable ( [string] ) ] ) , ) , ] , [ CallStatement ( f" [string] { f . name }" , [ Variable ( [string] ) , Variable ( [string] ) ] ) , CallStatement ( f" [string] { f . name }" , [ Slice ( Selected ( Variable ( [string] ) , [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , ] , ) , ] , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and bounded_setter_required ( message , f ) ] , ) [EOL] [EOL] def create_composite_initialize_procedures ( self , message ) : [EOL] def specification ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ InOutParameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] def specification_bounded ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ InOutParameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , const . TYPES_BIT_LENGTH ) ] , ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ( f ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , * self . unbounded_composite_setter_preconditions ( message , f ) , ) ) , Postcondition ( And ( * self . composite_setter_postconditions ( message , f ) , ) ) , ] , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and unbounded_setter_required ( message , f ) ] + [ SubprogramDeclaration ( specification_bounded ( f ) , [ Precondition ( AndThen ( * self . setter_preconditions ( f ) , * self . bounded_composite_setter_preconditions ( message , f ) , ) ) , Postcondition ( And ( * self . composite_setter_postconditions ( message , f ) ) ) , ] , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and bounded_setter_required ( message , f ) ] , [ SubprogramBody ( specification ( f ) , common . field_bit_location_declarations ( Variable ( f . affixed_name ) ) , common . initialize_field_statements ( message , f , self . prefix ) , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and unbounded_setter_required ( message , f ) ] + [ SubprogramBody ( specification_bounded ( f ) , [ ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , True , ) , ObjectDeclaration ( [ [string] ] , const . TYPES_BIT_INDEX , Add ( Variable ( [string] ) , Variable ( [string] ) , - Number ( [number] ) ) , True , ) , ] , common . initialize_field_statements ( message , f , self . prefix ) , ) for f , t in message . types . items ( ) if isinstance ( t , Opaque ) and bounded_setter_required ( message , f ) ] , ) [EOL] [EOL] @ staticmethod def setter_preconditions ( field ) : [EOL] return [ Not ( Constrained ( [string] ) ) , Call ( [string] , [ Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] ) , LessEqual ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] ) , Div ( Last ( const . TYPES_BIT_INDEX ) , Number ( [number] ) ) , ) , ] [EOL] [EOL] @ staticmethod def setter_postconditions ( message , field ) : [EOL] return [ * [ Call ( [string] , [ Variable ( [string] ) , Variable ( p . affixed_name ) ] ) for p in message . successors ( field ) if p != FINAL ] , * common . valid_path_to_next_field_condition ( message , field ) , * [ Equal ( e , Old ( e ) ) for e in [ Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , ] + [ Call ( f" [string] { p . name }" , [ Variable ( [string] ) ] ) for p in message . definite_predecessors ( field ) if isinstance ( message . types [ p ] , Scalar ) ] ] , ] [EOL] [EOL] def composite_setter_postconditions ( self , message , field ) : [EOL] return [ Call ( [string] , [ Variable ( [string] ) ] ) , * self . setter_postconditions ( message , field ) , Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] ) , ] [EOL] [EOL] @ staticmethod def unbounded_composite_setter_preconditions ( message , field ) : [EOL] return [ Call ( [string] , [ Variable ( [string] ) , NamedAggregate ( ( [string] , Variable ( field . affixed_name ) ) ) , ] + ( [ Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) ] [EOL] if common . length_dependent_condition ( message ) [EOL] else [ ] ) , ) , common . sufficient_space_for_field_condition ( Variable ( field . affixed_name ) ) , Equal ( Mod ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Size ( const . TYPES_BYTE ) , ) , Number ( [number] ) , ) , Equal ( Mod ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Size ( const . TYPES_BYTE ) , ) , Number ( [number] ) , ) , ] [EOL] [EOL] @ staticmethod def bounded_composite_setter_preconditions ( message , field ) : [EOL] return [ Call ( [string] , [ Variable ( [string] ) , NamedAggregate ( ( [string] , Variable ( field . affixed_name ) ) ) , ] + ( [ Variable ( [string] ) ] if common . length_dependent_condition ( message ) else [ ] ) , ) , GreaterEqual ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Variable ( [string] ) , ) , LessEqual ( Add ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Variable ( [string] ) , ) , Div ( Last ( const . TYPES_BIT_INDEX ) , Number ( [number] ) ) , ) , Or ( * [ And ( * [ Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) for field in message . fields if expr . Variable ( field . name ) in l . condition . variables ( ) ] , l . condition . substituted ( mapping = { expr . Variable ( field . name ) : expr . Call ( f" [string] { field . name }" , [ expr . Variable ( [string] ) ] ) for field in message . fields if expr . Variable ( field . name ) in l . condition . variables ( ) } ) . ada_expr ( ) , ) for l in message . incoming ( field ) if expr . Last ( [string] ) in l . length ] ) , Equal ( Mod ( Call ( [string] , [ Variable ( [string] ) , Variable ( field . affixed_name ) ] , ) , Size ( const . TYPES_BYTE ) , ) , Number ( [number] ) , ) , Equal ( Mod ( Variable ( [string] ) , Size ( const . TYPES_BYTE ) ) , Number ( [number] ) , ) , ] [EOL] [EOL] [EOL] def unbounded_setter_required ( message , field ) : [EOL] return any ( True for l in message . incoming ( field ) if expr . Length ( [string] ) not in l . length and expr . Last ( [string] ) not in l . length ) [EOL] [EOL] [EOL] def bounded_setter_required ( message , field ) : [EOL] return any ( True for l in message . incoming ( field ) if expr . Length ( [string] ) in l . length or expr . Last ( [string] ) in l . length ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $rflx.ada.Subprogram$ 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 $rflx.model.Type$ 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 $rflx.model.Type$ 0 0 0 0 $rflx.model.Type$ 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.FormalSubprogramDeclaration]$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 $rflx.model.Field$ 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 0 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 $rflx.model.Message$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 $rflx.model.Field$ 0 $rflx.model.Message$ 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 $rflx.model.Message$ 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import rflx [EOL] import rflx . ada as ada [EOL] from rflx . common import file_name [EOL] [EOL] REFINEMENT_PACKAGE = ada . ID ( [string] ) [EOL] [EOL] ARITHMETIC_PACKAGE = ada . ID ( [string] ) [EOL] BUILTIN_TYPES_CONVERSIONS_PACKAGE = ada . ID ( [string] ) [EOL] BUILTIN_TYPES_PACKAGE = ada . ID ( [string] ) [EOL] GENERIC_TYPES_PACKAGE = ada . ID ( [string] ) [EOL] MESSAGE_SEQUENCE_PACKAGE = ada . ID ( [string] ) [EOL] SCALAR_SEQUENCE_PACKAGE = ada . ID ( [string] ) [EOL] TYPES_PACKAGE = ada . ID ( [string] ) [EOL] [EOL] LIBRARY_FILES = [ file_name ( str ( p ) ) + [string] for p in [ ARITHMETIC_PACKAGE , BUILTIN_TYPES_CONVERSIONS_PACKAGE , BUILTIN_TYPES_PACKAGE , GENERIC_TYPES_PACKAGE , MESSAGE_SEQUENCE_PACKAGE , SCALAR_SEQUENCE_PACKAGE , TYPES_PACKAGE , ] ] + [ file_name ( str ( p ) ) + [string] for p in [ ARITHMETIC_PACKAGE , GENERIC_TYPES_PACKAGE , MESSAGE_SEQUENCE_PACKAGE , SCALAR_SEQUENCE_PACKAGE , ] ] [EOL] [EOL] TEMPLATE_DIR = ( [string] , [string] ) [EOL] [EOL] TYPES = ada . ID ( [string] ) [EOL] TYPES_BYTE = TYPES * [string] [EOL] TYPES_BYTES = TYPES * [string] [EOL] TYPES_BYTES_PTR = TYPES * [string] [EOL] TYPES_INDEX = TYPES * [string] [EOL] TYPES_LENGTH = TYPES * [string] [EOL] TYPES_BIT_INDEX = TYPES * [string] [EOL] TYPES_BIT_LENGTH = TYPES * [string] [EOL] TYPES_BYTE_INDEX = TYPES * [string] [EOL] TYPES_FIRST_BIT_INDEX = TYPES * [string] [EOL] TYPES_LAST_BIT_INDEX = TYPES * [string] [EOL] TYPES_OFFSET = TYPES * [string] [EOL] TYPES_UNREACHABLE_BIT_LENGTH = TYPES * [string] [EOL] TYPES_U64 = TYPES * [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0 $rflx.ada.ID$ 0 $rflx.ada.ID$ 0 0 0
from . core import Generator [comment] [EOL]	0 0 0 0 0 0 0
from typing import Type , List , Sequence , Mapping , Tuple [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import List , Mapping , Sequence , Tuple [EOL] [EOL] import rflx . expression as expr [EOL] from rflx . ada import ( FALSE , ID , TRUE , Add , And , AndThen , Assignment , Call , CallStatement , Case , Equal , Expr , ExpressionFunctionDeclaration , FormalSubprogramDeclaration , FunctionSpecification , GenericFunctionInstantiation , If , IfStatement , Indexed , InOutParameter , Less , NamedAggregate , Number , ObjectDeclaration , Old , Or , Parameter , Postcondition , PragmaStatement , Precondition , ProcedureSpecification , Result , ReturnStatement , Selected , Slice , Subprogram , SubprogramBody , SubprogramDeclaration , UnitPart , Variable , ) [EOL] from rflx . common import unique [EOL] from rflx . model import BUILTINS_PACKAGE , FINAL , INITIAL , Composite , Field , Message , Scalar , Type [EOL] [EOL] from . import common , const [EOL] [EOL] [EOL] class ParserGenerator : [EOL] def __init__ ( self , prefix = [string] ) : [EOL] self . prefix = prefix [EOL] [EOL] def extract_function ( self , type_name ) : [EOL] return GenericFunctionInstantiation ( [string] , FunctionSpecification ( const . TYPES * [string] , type_name , [ Parameter ( [ [string] ] , const . TYPES_BYTES ) , Parameter ( [ [string] ] , const . TYPES_OFFSET ) , ] , ) , [ common . prefixed_type_name ( type_name , self . prefix ) ] , ) [EOL] [EOL] def create_internal_functions ( self , message , scalar_fields , composite_fields , ) : [EOL] def result ( field , message ) : [EOL] aggregate = [ ( [string] , Variable ( field . affixed_name ) ) ] [EOL] if field in message . fields and isinstance ( message . types [ field ] , Scalar ) : [EOL] aggregate . append ( ( f"{ field . name } [string] " , Call ( [string] , [ Slice ( Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) , ) , Variable ( [string] ) , ] , ) , ) ) [EOL] return NamedAggregate ( * aggregate ) [EOL] [EOL] return UnitPart ( [ ] , [ ExpressionFunctionDeclaration ( FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) ] ) , Case ( Variable ( [string] ) , [ ( Variable ( f . affixed_name ) , TRUE if f in composite_fields else FALSE , ) for f in message . fields ] , ) , ) , SubprogramBody ( FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] , ) , [ * common . field_bit_location_declarations ( Variable ( [string] ) ) , * common . field_byte_location_declarations ( ) , * unique ( self . extract_function ( common . full_base_type_name ( t ) ) for t in message . types . values ( ) if isinstance ( t , Scalar ) ) , ] [EOL] if scalar_fields [EOL] else [ ] , [ ReturnStatement ( Case ( Variable ( [string] ) , [ ( Variable ( f . affixed_name ) , result ( f , message ) ) for f in message . fields ] , ) ) ] , [ Precondition ( AndThen ( Call ( [string] , [ Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) ) , Postcondition ( Equal ( Selected ( Result ( [string] ) , [string] ) , Variable ( [string] ) , ) ) , ] , ) , ] , ) [EOL] [EOL] def create_verify_procedure ( self , message , context_invariant ) : [EOL] specification = ProcedureSpecification ( [string] , [ InOutParameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] valid_field_condition = And ( Call ( [string] , [ Variable ( [string] ) ] , ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) , * ( [ Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) ] [EOL] if common . length_dependent_condition ( message ) [EOL] else [ ] ) , ] , ) , ) [EOL] [EOL] set_cursors_statements = [ IfStatement ( [ ( Call ( [string] , [ Variable ( [string] ) ] ) , [ Assignment ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , ( [string] , Variable ( [string] ) ) , ( [string] , Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] , ) , ) , ) , ) ] , ) ] , [ Assignment ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) ) , ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) ) , ( [string] , Variable ( [string] ) ) , ( [string] , Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , ) , ) , ) ] , ) , PragmaStatement ( [string] , [ common . message_structure_invariant ( message , self . prefix ) ] ) , IfStatement ( [ ( Equal ( Variable ( [string] ) , Variable ( f . affixed_name ) ) , [ Assignment ( Indexed ( Variable ( [string] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( [string] ) ) , ) , ) ] , ) for f in message . fields ] ) , ] [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification , [ Postcondition ( And ( Equal ( Call ( [string] , [ Variable ( [string] ) ] ) , Old ( Call ( [string] , [ Variable ( [string] ) ] ) ) , ) , * context_invariant , ) ) , ] , ) ] , [ SubprogramBody ( specification , [ ObjectDeclaration ( [ [string] ] , [string] ) ] , [ IfStatement ( [ ( AndThen ( Call ( [string] , [ Variable ( [string] ) ] ) , Call ( [string] , [ Indexed ( Variable ( [string] ) , Variable ( [string] ) ) ] , ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , [ IfStatement ( [ ( Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] , ) , [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] , ) , ) , IfStatement ( [ ( valid_field_condition , set_cursors_statements , ) ] , [ Assignment ( Indexed ( Variable ( [string] ) , Variable ( [string] ) , ) , NamedAggregate ( ( [string] , Variable ( [string] ) , ) , ( [string] , Variable ( FINAL . affixed_name , ) , ) , ) , ) ] , ) , ] , ) ] , [ Assignment ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , NamedAggregate ( ( [string] , Variable ( [string] ) ) , ( [string] , Variable ( FINAL . affixed_name ) , ) , ) , ) ] , ) ] , ) ] , ) ] , ) ] , ) [EOL] [EOL] @ staticmethod def create_verify_message_procedure ( message , context_invariant ) : [EOL] specification = ProcedureSpecification ( [string] , [ InOutParameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification , [ Postcondition ( And ( Equal ( Call ( [string] , [ Variable ( [string] ) ] ) , Old ( Call ( [string] , [ Variable ( [string] ) ] ) ) , ) , * context_invariant , ) ) , ] , ) ] , [ SubprogramBody ( specification , [ ] , [ CallStatement ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] ) for f in message . fields ] , ) ] , ) [EOL] [EOL] @ staticmethod def create_present_function ( ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ) ] , [ ExpressionFunctionDeclaration ( specification , AndThen ( Call ( [string] , [ Indexed ( Variable ( [string] ) , Variable ( [string] ) ) ] ) , Less ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Add ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Number ( [number] ) , ) , ) , ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_structural_valid_function ( ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] , ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ) ] , [ ExpressionFunctionDeclaration ( specification , And ( Or ( * [ Equal ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Variable ( s ) , ) for s in ( [string] , [string] ) ] ) ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_valid_function ( ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification , [ Postcondition ( If ( [ ( Result ( [string] ) , And ( Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] , ) , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) , ) ] ) ) , ] , ) ] , [ ExpressionFunctionDeclaration ( specification , AndThen ( Equal ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Variable ( [string] ) , ) , Less ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Add ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Number ( [number] ) , ) , ) , ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_incomplete_function ( ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ) ] , [ ExpressionFunctionDeclaration ( specification , Equal ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Variable ( [string] ) , ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_invalid_function ( ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) , Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ) ] , [ ExpressionFunctionDeclaration ( specification , Or ( Equal ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Variable ( [string] ) , ) , Equal ( Selected ( Indexed ( Variable ( [string] ) , Variable ( [string] ) ) , [string] ) , Variable ( [string] ) , ) , ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_structural_valid_message_function ( message ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification , [ Precondition ( Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) ] , [ ExpressionFunctionDeclaration ( specification , valid_message_condition ( message , structural = True ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_valid_message_function ( message ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification , [ Precondition ( Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) ] , [ ExpressionFunctionDeclaration ( specification , valid_message_condition ( message ) , ) ] , ) [EOL] [EOL] @ staticmethod def create_incomplete_message_function ( message ) : [EOL] specification = FunctionSpecification ( [string] , [string] , [ Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ) ] , [ ExpressionFunctionDeclaration ( specification , Or ( * [ Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) for f in message . fields ] ) , ) ] , ) [EOL] [EOL] def create_scalar_accessor_functions ( self , scalar_fields ) : [EOL] def specification ( field , field_type ) : [EOL] if field_type . package == BUILTINS_PACKAGE : [EOL] type_name = ID ( field_type . name ) [EOL] else : [EOL] type_name = self . prefix * ID ( field_type . identifier ) [EOL] [EOL] return FunctionSpecification ( f" [string] { field . name }" , type_name , [ Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] def result ( field ) : [EOL] return Call ( [string] , [ Selected ( Indexed ( Variable ( [string] ) , Variable ( field . affixed_name ) ) , f" [string] { field . name } [string] " , ) ] , ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ( f , t ) , [ Precondition ( Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] ) , ) ] , ) for f , t in scalar_fields . items ( ) ] , [ ExpressionFunctionDeclaration ( specification ( f , t ) , result ( f ) ) for f , t in scalar_fields . items ( ) ] , ) [EOL] [EOL] @ staticmethod def create_composite_accessor_procedures ( composite_fields ) : [EOL] def specification ( field ) : [EOL] return ProcedureSpecification ( f" [string] { field . name }" , [ Parameter ( [ [string] ] , [string] ) ] ) [EOL] [EOL] return UnitPart ( [ SubprogramDeclaration ( specification ( f ) , [ Precondition ( And ( Call ( [string] , [ Variable ( [string] ) ] ) , Call ( [string] , [ Variable ( [string] ) , Variable ( f . affixed_name ) ] , ) , ) ) ] , [ FormalSubprogramDeclaration ( ProcedureSpecification ( f" [string] { f . name }" , [ Parameter ( [ f . name ] , const . TYPES_BYTES ) ] ) ) ] , ) for f in composite_fields ] , [ SubprogramBody ( specification ( f ) , [ ObjectDeclaration ( [ [string] ] , const . TYPES_INDEX , Call ( const . TYPES_BYTE_INDEX , [ Selected ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) , ) , [string] , ) ] , ) , True , ) , ObjectDeclaration ( [ [string] ] , const . TYPES_INDEX , Call ( const . TYPES_BYTE_INDEX , [ Selected ( Indexed ( Variable ( [string] ) , Variable ( f . affixed_name ) , ) , [string] , ) ] , ) , True , ) , ] , [ CallStatement ( f" [string] { f . name }" , [ Slice ( Variable ( [string] ) , Variable ( [string] ) , Variable ( [string] ) ) ] , ) ] , ) for f in composite_fields ] , ) [EOL] [EOL] [EOL] def valid_message_condition ( message , field = INITIAL , structural = False ) : [EOL] def condition ( message , field , structural ) : [EOL] return expr . Or ( * [ l . condition [EOL] if l . target == FINAL [EOL] else expr . AndThen ( expr . Call ( [string] [EOL] if structural and isinstance ( message . types [ l . target ] , Composite ) [EOL] else [string] , [ expr . Variable ( [string] ) , expr . Variable ( l . target . affixed_name , immutable = True ) , ] , ) , l . condition , condition ( message , l . target , structural ) , ) for l in message . outgoing ( field ) ] ) [EOL] [EOL] return ( condition ( message , field , structural ) . substituted ( common . substitution ( message ) ) . simplified ( ) . ada_expr ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.Subprogram$ 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.ID$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 $typing.Mapping[rflx.model.Field,rflx.model.Type]$ 0 $typing.Sequence[rflx.model.Field]$ 0 0 0 0 0 $rflx.ada.Expr$ 0 $rflx.model.Field$ 0 $rflx.model.Message$ 0 0 0 $typing.List[typing.Tuple[builtins.str,rflx.ada.Expr]]$ 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 $rflx.model.Field$ 0 $rflx.model.Message$ 0 0 0 0 0 $rflx.model.Message$ 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,rflx.ada.Expr]]$ 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,rflx.ada.Expr]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.model.Field]$ 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $rflx.model.Message$ 0 $typing.Sequence[rflx.ada.Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 $rflx.model.Message$ 0 $typing.Sequence[rflx.ada.Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.ada.Expr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 $rflx.model.Type$ 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Type$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.Expr$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[rflx.model.Field,rflx.model.Scalar]$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.ada.UnitPart$ 0 $typing.Sequence[rflx.model.Field]$ 0 0 0 0 $rflx.ada.ProcedureSpecification$ 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 $rflx.model.Field$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.model.Field]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.model.Field]$ 0 0 0 0 0 0 0 $rflx.ada.Expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.expression.Expr$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . const import BUILTINS_PACKAGE , INTERNAL_PACKAGE [comment] [EOL] from . message import ( FINAL , INITIAL , AbstractMessage , DerivedMessage , Field , Link , Message , Refinement , UnprovenDerivedMessage , UnprovenMessage , ) [EOL] from . model import Model [comment] [EOL] from . session import Session , State , Transition [comment] [EOL] from . type_ import ( BOOLEAN , BUILTIN_LITERALS , BUILTIN_TYPES , INTERNAL_TYPES , OPAQUE , Array , Composite , Enumeration , Integer , ModularInteger , Opaque , RangeInteger , Scalar , Type , is_builtin_type , is_internal_type , qualified_type_name , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Dict , List [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Dict , List , Sequence [EOL] [EOL] from rflx import declaration as decl , expression as expr , statement as stmt [EOL] from rflx . common import Base , indent , indent_next , verbose_repr [EOL] from rflx . error import Location , RecordFluxError , Severity , Subsystem [EOL] from rflx . identifier import ID , StrID [EOL] [EOL] [EOL] class Transition ( Base ) : [EOL] def __init__ ( self , target , condition = expr . TRUE , description = None , location = None , ) : [EOL] self . target = ID ( target ) [EOL] self . condition = condition [EOL] self . location = location [EOL] self . description = description [EOL] [EOL] def __repr__ ( self ) : [EOL] return verbose_repr ( self , [ [string] , [string] , [string] ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] with_aspects = f' [string] { self . description } [string] ' if self . description else [string] [EOL] if_condition = ( f" [string] { indent_next ( str ( self . condition ) , [number] ) }" if self . condition != expr . TRUE else [string] ) [EOL] return f" [string] { self . target }{ with_aspects }{ if_condition }" [EOL] [EOL] def validate ( self , declarations ) : [EOL] self . condition . simplified ( ) . validate ( declarations ) [EOL] [EOL] [EOL] class State ( Base ) : [EOL] def __init__ ( self , name , transitions = None , actions = None , declarations = None , location = None , ) : [EOL] self . __name = ID ( name ) [EOL] self . __transitions = transitions or [ ] [EOL] self . __actions = actions or [ ] [EOL] self . declarations = { d . identifier : d for d in declarations } if declarations else { } [EOL] self . location = location [EOL] [EOL] def __repr__ ( self ) : [EOL] return verbose_repr ( self , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] if not self . declarations and not self . actions and not self . transitions : [EOL] return f" [string] { self . name } [string] " [EOL] declarations = [string] . join ( f"{ d } [string] " for d in self . declarations . values ( ) ) [EOL] actions = [string] . join ( f"{ a } [string] " for a in self . actions ) [EOL] transitions = [string] . join ( f"{ p }" for p in self . transitions ) [EOL] return ( f" [string] { self . name } [string] { indent ( declarations , [number] ) } [string] { indent ( actions , [number] ) }" f" [string] { indent ( transitions , [number] ) } [string] { self . name }" ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . __name [EOL] [EOL] @ property def transitions ( self ) : [EOL] return self . __transitions or [ ] [EOL] [EOL] @ property def actions ( self ) : [EOL] return self . __actions [EOL] [EOL] [EOL] class Session ( Base ) : [EOL] [comment] [EOL] def __init__ ( self , identifier , initial , final , states , declarations , parameters = None , location = None , ) : [EOL] self . identifier = ID ( identifier ) [EOL] self . initial = ID ( initial ) [EOL] self . final = ID ( final ) [EOL] self . states = states [EOL] self . declarations = { d . identifier : d for d in declarations } [EOL] self . parameters = { p . identifier : p for p in parameters } if parameters else { } [EOL] self . location = location [EOL] self . error = RecordFluxError ( ) [EOL] [EOL] if not states : [EOL] self . error . append ( [string] , Subsystem . MODEL , Severity . ERROR , location , ) [EOL] self . __validate_state_existence ( ) [EOL] self . __validate_duplicate_states ( ) [EOL] self . __validate_state_reachability ( ) [EOL] self . __validate_conditions ( ) [EOL] self . __validate_actions ( ) [EOL] self . __validate_declarations ( ) [EOL] self . error . propagate ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return verbose_repr ( self , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def __str__ ( self ) : [EOL] parameters = [string] . join ( f"{ p } [string] " for p in self . parameters . values ( ) ) [EOL] declarations = [string] . join ( f"{ d } [string] " for d in self . declarations . values ( ) ) [EOL] states = [string] . join ( f"{ s } [string] " for s in self . states ) [EOL] return ( f" [string] { indent ( parameters , [number] ) } [string] { self . identifier . name } [string] " f" [string] { self . initial } [string] { self . final } [string] " f" [string] { indent ( declarations , [number] ) } [string] { indent ( states , [number] ) } [string] { self . identifier . name }" ) [EOL] [EOL] def __validate_conditions ( self ) : [EOL] for s in self . states : [EOL] declarations = s . declarations [EOL] for t in s . transitions : [EOL] try : [EOL] t . validate ( { ** self . parameters , ** self . declarations , ** declarations } ) [EOL] except RecordFluxError as e : [EOL] self . error . extend ( e ) [EOL] [EOL] def __validate_actions ( self ) : [EOL] for s in self . states : [EOL] declarations = s . declarations [EOL] for index , a in enumerate ( s . actions ) : [EOL] try : [EOL] a . validate ( { ** self . parameters , ** self . declarations , ** declarations } ) [EOL] except RecordFluxError as e : [EOL] self . error . append ( f" [string] { index } [string] { s . name }" , Subsystem . MODEL , Severity . ERROR , a . location , ) [EOL] self . error . extend ( e ) [EOL] [EOL] def __validate_state_existence ( self ) : [EOL] state_names = [ s . name for s in self . states ] [EOL] if self . initial not in state_names : [EOL] self . error . append ( f' [string] { self . initial } [string] { self . identifier } [string] ' , Subsystem . MODEL , Severity . ERROR , self . initial . location , ) [EOL] if self . final not in state_names : [EOL] self . error . append ( f' [string] { self . final } [string] { self . identifier } [string] ' , Subsystem . MODEL , Severity . ERROR , self . final . location , ) [EOL] for s in self . states : [EOL] for t in s . transitions : [EOL] if t . target not in state_names : [EOL] self . error . append ( f' [string] { s . name } [string] ' f' [string] { t . target } [string] { self . identifier } [string] ' , Subsystem . MODEL , Severity . ERROR , t . target . location , ) [EOL] [EOL] def __validate_duplicate_states ( self ) : [EOL] state_names = [ s . name for s in self . states ] [EOL] seen = { } [EOL] duplicates = [ ] [EOL] for n in state_names : [EOL] if n not in seen : [EOL] seen [ n ] = [number] [EOL] else : [EOL] duplicates . append ( n . name ) [EOL] seen [ n ] += [number] [EOL] [EOL] if duplicates : [EOL] self . error . append ( f' [string] { [string] . join ( map ( str , sorted ( duplicates ) ) ) }' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] [EOL] def __validate_state_reachability ( self ) : [EOL] inputs = { } [EOL] for s in self . states : [EOL] for t in s . transitions : [EOL] if t . target in inputs : [EOL] inputs [ t . target ] . append ( s . name ) [EOL] else : [EOL] inputs [ t . target ] = [ s . name ] [EOL] unreachable = [ str ( s . name ) for s in self . states if s . name != self . initial and s . name not in inputs ] [EOL] if unreachable : [EOL] self . error . append ( f' [string] { [string] . join ( unreachable ) }' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] [EOL] detached = [ str ( s . name ) for s in self . states if s . name != self . final and not s . transitions ] [EOL] if detached : [EOL] self . error . append ( f' [string] { [string] . join ( detached ) }' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] [EOL] @ staticmethod def __entity_name ( declaration ) : [EOL] if isinstance ( declaration , decl . SubprogramDeclaration ) : [EOL] return [string] [EOL] if isinstance ( declaration , decl . VariableDeclaration ) : [EOL] return [string] [EOL] if isinstance ( declaration , decl . RenamingDeclaration ) : [EOL] return [string] [EOL] if isinstance ( declaration , decl . ChannelDeclaration ) : [EOL] return [string] [EOL] if isinstance ( declaration , decl . PrivateDeclaration ) : [EOL] return [string] [EOL] assert False , f" [string] { type ( decl ) . __name__ }" [EOL] [EOL] def __validate_declarations ( self ) : [EOL] for s in self . states : [EOL] for k , d in s . declarations . items ( ) : [EOL] if k in self . declarations : [EOL] self . error . append ( f' [string] { k } [string] ' f" [string] { s . name . name }" , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] if not s . declarations [ k ] . is_referenced : [EOL] self . error . append ( f' [string] { k } [string] { s . name . name }' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] d . validate ( { ** self . parameters , ** self . declarations } ) [EOL] for k , d in self . declarations . items ( ) : [EOL] if str ( k ) . upper ( ) in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] self . error . append ( f'{ self . __entity_name ( d ) } [string] { k } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL] try : [EOL] d . validate ( { ** self . parameters , ** self . declarations } ) [EOL] except RecordFluxError as e : [EOL] self . error . extend ( e ) [EOL] for k , d in self . declarations . items ( ) : [EOL] [comment] [EOL] if isinstance ( d , decl . PrivateDeclaration ) : [EOL] continue [EOL] if not d . is_referenced : [EOL] self . error . append ( f' [string] { self . __entity_name ( d ) } [string] { k } [string] ' , Subsystem . MODEL , Severity . ERROR , self . location , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 $rflx.identifier.ID$ 0 $rflx.identifier.ID$ 0 $typing.Sequence[rflx.model.session.State]$ 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.ID$ 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.ID$ 0 0 0 0 $rflx.identifier.ID$ 0 0 0 $rflx.identifier.ID$ 0 0 0 0 $typing.Sequence[rflx.model.session.State]$ 0 $typing.Sequence[rflx.model.session.State]$ 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.error.Location$ 0 $rflx.error.Location$ 0 0 0 $rflx.error.RecordFluxError$ 0 0 0 0 0 0 0 0 $typing.Sequence[rflx.model.session.State]$ 0 0 0 0 $rflx.error.RecordFluxError$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.error.Location$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.error.RecordFluxError$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,builtins.int]$ 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,builtins.int]$ 0 0 $typing.Dict[rflx.identifier.ID,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[rflx.identifier.ID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,typing.List[rflx.identifier.ID]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,typing.List[rflx.identifier.ID]]$ 0 0 $typing.Dict[rflx.identifier.ID,typing.List[rflx.identifier.ID]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,typing.List[rflx.identifier.ID]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[rflx.identifier.ID,typing.List[rflx.identifier.ID]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.declaration.Declaration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import rflx [EOL] from rflx . identifier import ID [EOL] [EOL] BUILTINS_PACKAGE = ID ( [string] ) [EOL] INTERNAL_PACKAGE = ID ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 0 0 0 $rflx.identifier.ID$ 0 0 0 0 0 0
from typing import Sequence , Union [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Sequence , Union [EOL] [EOL] [EOL] class Bitstring : [EOL] def __init__ ( self , bits = [string] ) : [EOL] if not self . valid_bitstring ( bits ) : [EOL] raise ValueError ( [string] ) [EOL] self . _bits = bits [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Bitstring ( self . _bits + other . _bits ) [EOL] [EOL] def __iadd__ ( self , other ) : [EOL] self . _bits += other . _bits [EOL] return self [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] if isinstance ( key , slice ) and isinstance ( key . stop , int ) and len ( self . _bits ) < key . stop : [EOL] raise IndexError [EOL] return Bitstring ( self . _bits [ key ] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _bits } [string] ' [EOL] [EOL] def __str__ ( self ) : [EOL] return self . _bits [EOL] [EOL] def __int__ ( self ) : [EOL] return int ( self . _bits , [number] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , Bitstring ) : [EOL] return NotImplemented [EOL] return self . _bits == other . _bits [EOL] [EOL] def __bytes__ ( self ) : [EOL] return [string] . join ( [ int ( self . _bits [ i : i + [number] ] , [number] ) . to_bytes ( [number] , [string] ) for i in range ( [number] , len ( self . _bits ) , [number] ) ] ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _bits ) [EOL] [EOL] @ classmethod def from_bytes ( cls , msg ) : [EOL] return cls ( format ( int . from_bytes ( msg , [string] ) , f" [string] { len ( msg ) * [number] } [string] " ) ) [EOL] [EOL] @ staticmethod def valid_bitstring ( bitstring ) : [EOL] return all ( ( bit in [ [string] , [string] ] for bit in bitstring ) ) [EOL] [EOL] @ staticmethod def join ( iterable ) : [EOL] joined_bitstring = Bitstring ( ) [EOL] for i in iterable : [EOL] joined_bitstring += i [EOL] [EOL] return joined_bitstring [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $"Bitstring"$ 0 0 0 $"Bitstring"$ 0 0 0 0 0 0 0 0 0 0 $"Bitstring"$ 0 0 0 0 0 0 $"Bitstring"$ 0 0 0 $"Bitstring"$ 0 0 0 0 0 0 0 $"Bitstring"$ 0 0 0 0 0 0 0 0 $"Bitstring"$ 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.slice]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Bitstring"$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"Bitstring"$ 0 $typing.Sequence["Bitstring"]$ 0 0 0 $rflx.pyrflx.bitstring.Bitstring$ 0 0 0 0 0 0 0 0 $typing.Sequence["Bitstring"]$ 0 0 $rflx.pyrflx.bitstring.Bitstring$ 0 0 0 0 0 $rflx.pyrflx.bitstring.Bitstring$ 0
from . bitstring import Bitstring [comment] [EOL] from . package import Package [comment] [EOL] from . pyrflx import PyRFLX [comment] [EOL] from . typevalue import ( ArrayValue , EnumValue , IntegerValue , MessageValue , NotInitializedError , OpaqueValue , TypeValue , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] def internet_checksum ( checksum_bytes ) : [EOL] def add_ones_complement ( num1 , num2 ) : [EOL] mod = [number] << [number] [EOL] result = num1 + num2 [EOL] return result if result < mod else ( result + [number] ) % mod [EOL] [EOL] message_in_sixteen_bit_chunks = [ int . from_bytes ( checksum_bytes [ i : i + [number] ] , [string] ) for i in range ( [number] , len ( checksum_bytes ) , [number] ) ] [EOL] intermediary_result = message_in_sixteen_bit_chunks [ [number] ] [EOL] for i in range ( [number] , len ( message_in_sixteen_bit_chunks ) ) : [EOL] intermediary_result = add_ones_complement ( intermediary_result , message_in_sixteen_bit_chunks [ i ] ) [EOL] [EOL] return intermediary_result ^ [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Dict [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Dict , Iterator [EOL] [EOL] from rflx . common import Base [EOL] from rflx . pyrflx . typevalue import MessageValue [EOL] [EOL] [EOL] class Package ( Base ) : [EOL] def __init__ ( self , name ) : [EOL] self . __name = name [EOL] self . __messages = { } [EOL] [EOL] @ property def name ( self ) : [EOL] return self . __name [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . __messages [ key ] . clone ( ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] self . __messages [ key ] = value [EOL] [EOL] def __iter__ ( self ) : [EOL] return self . __messages . values ( ) . __iter__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,rflx.pyrflx.typevalue.MessageValue]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.typevalue.MessageValue$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $rflx.pyrflx.typevalue.MessageValue$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $rflx.pyrflx.typevalue.MessageValue$ 0 0 0 $typing.Iterator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Set , List [EOL] import rflx [EOL] import builtins [EOL] import package [EOL] import typing [EOL] import logging [EOL] import logging [EOL] from pathlib import Path [EOL] from typing import Dict , Iterator , List [EOL] [EOL] from rflx . parser import Parser [EOL] from rflx . pyrflx . typevalue import MessageValue [EOL] [EOL] from . package import Package [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PyRFLX : [EOL] def __init__ ( self , files , skip_model_verification = False , skip_message_verification = False , ) : [EOL] parser = Parser ( skip_model_verification ) [EOL] self . __packages = { } [EOL] [EOL] for f in files : [EOL] if not Path ( f ) . is_file ( ) : [EOL] raise FileNotFoundError ( f' [string] { f } [string] ' ) [EOL] parser . parse ( Path ( f ) ) [EOL] model = parser . create_model ( ) [EOL] packages = set ( str ( m . package ) for m in model . messages ) [EOL] for p in packages : [EOL] self . __packages [ p ] = Package ( p ) [EOL] for m in [ x for x in model . messages if str ( x . package ) == p ] : [EOL] self . __packages [ p ] [ str ( m . name ) ] = MessageValue ( m , model . refinements , skip_message_verification ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . __packages [ key ] [EOL] [EOL] def __iter__ ( self ) : [EOL] return self . __packages . values ( ) . __iter__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 0 0 0 0 $package.Package$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Iterator[package.Package]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pathlib [EOL] import typing [EOL] from pathlib import Path [EOL] from typing import Any [EOL] [EOL] import pkg_resources [EOL] import pytest [EOL] [EOL] import rflx . parser [EOL] from rflx import cli [EOL] from rflx . error import Location , Severity , Subsystem , fail [EOL] [EOL] [EOL] def raise_model_error ( ) : [EOL] fail ( [string] , Subsystem . MODEL , Severity . ERROR , Location ( ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] def test_main_noarg ( ) : [EOL] with pytest . raises ( SystemExit , match = [string] ) : [EOL] cli . main ( [ [string] ] ) [EOL] [EOL] [EOL] def test_main_help ( ) : [EOL] with pytest . raises ( SystemExit ) : [EOL] cli . main ( [ [string] , [string] ] ) [EOL] [EOL] [EOL] def test_main_check ( ) : [EOL] assert cli . main ( [ [string] , [string] , [string] ] ) == [number] [EOL] [EOL] [EOL] def test_main_check_quiet ( ) : [EOL] assert cli . main ( [ [string] , [string] , [string] , [string] ] ) == [number] [EOL] assert cli . main ( [ [string] , [string] , [string] , [string] ] ) == [number] [EOL] [EOL] [EOL] def test_main_check_parser_error ( ) : [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_check_model_error_parse ( monkeypatch ) : [EOL] monkeypatch . setattr ( cli , [string] , lambda x : raise_model_error ( ) ) [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_check_model_error_create_model ( monkeypatch ) : [EOL] monkeypatch . setattr ( rflx . parser . Parser , [string] , lambda x : raise_model_error ( ) ) [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_check_non_existent_file ( ) : [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_generate ( tmp_path ) : [EOL] assert cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) == [number] [EOL] top_level_package = Path ( tmp_path ) / ( cli . DEFAULT_PREFIX . lower ( ) + [string] ) [EOL] assert top_level_package . exists ( ) [EOL] [EOL] [EOL] def test_main_generate_no_library_files ( tmp_path ) : [EOL] assert ( cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] , [string] , [string] , [string] ] ) == [number] ) [EOL] assert len ( list ( tmp_path . glob ( [string] ) ) ) == [number] [EOL] [EOL] [EOL] def test_main_generate_prefix ( tmp_path ) : [EOL] for prefix in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] assert ( cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] , prefix , [string] ] ) == [number] ) [EOL] top_level_package = Path ( tmp_path ) / ( prefix . replace ( [string] , [string] ) . lower ( ) + [string] ) [EOL] assert not top_level_package . exists ( ) [EOL] [EOL] [EOL] def test_main_generate_invalid_prefix ( tmp_path ) : [EOL] for prefix in [ [string] , [string] , [string] , [string] ] : [EOL] assert rf' [string] { prefix } [string] ' in str ( cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] , prefix , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_generate_no_output_files ( tmp_path ) : [EOL] assert cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) == [number] [EOL] [EOL] [EOL] def test_main_generate_non_existent_directory ( ) : [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_generate_missing_template_directory ( monkeypatch , tmp_path ) : [EOL] monkeypatch . setattr ( pkg_resources , [string] , lambda * x : [string] ) [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) [EOL] [EOL] [EOL] def test_main_generate_missing_template_files ( monkeypatch , tmp_path ) : [EOL] monkeypatch . setattr ( pkg_resources , [string] , lambda * x : tmp_path ) [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) [EOL] [EOL] [EOL] def test_main_graph ( tmp_path ) : [EOL] assert cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) == [number] [EOL] [EOL] [EOL] def test_main_graph_non_existent_file ( tmp_path ) : [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_graph_non_existent_files ( tmp_path ) : [EOL] assert ( [string] [string] in str ( cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] , [string] ] ) ) ) [EOL] [EOL] [EOL] def test_main_graph_non_existent_directory ( ) : [EOL] assert [string] in str ( cli . main ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_main_graph_no_output_files ( tmp_path ) : [EOL] assert cli . main ( [ [string] , [string] , [string] , str ( tmp_path ) , [string] ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import re [EOL] from typing import Any , Sequence [EOL] [EOL] import hypothesis [EOL] import pytest [EOL] [EOL] from rflx . expression import Expr [EOL] [EOL] hypothesis . settings . register_profile ( [string] , max_examples = [number] , verbosity = hypothesis . Verbosity . verbose ) [EOL] hypothesis . settings . register_profile ( [string] , deadline = None , max_examples = [number] , verbosity = hypothesis . Verbosity . verbose ) [EOL] [EOL] hypothesis . settings . load_profile ( os . environ . get ( [string] , [string] ) ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] config . addinivalue_line ( [string] , [string] ) [EOL] config . addinivalue_line ( [string] , [string] ) [EOL] [EOL] [EOL] def pytest_collection_modifyitems ( config , items ) : [EOL] markexpr = config . getoption ( [string] ) [EOL] for marker in [ [string] , [string] ] : [EOL] if marker not in markexpr . split ( [string] ) : [EOL] for item in items : [EOL] if any ( m . name == marker for m in item . own_markers ) : [EOL] item . add_marker ( pytest . mark . skip ( reason = [string] ) ) [EOL] [EOL] [EOL] def pytest_assertrepr_compare ( op , left , right ) : [EOL] if isinstance ( left , Expr ) and isinstance ( right , Expr ) and op == [string] : [EOL] return [ [string] , [string] , * [ f" [string] { l }" for l in ( [string] + repr ( left ) ) . split ( [string] ) ] , * [ f" [string] { l }" for l in ( [string] + repr ( right ) ) . split ( [string] ) ] , [string] , [string] + re . sub ( [string] , [string] , str ( left ) ) , [string] + re . sub ( [string] , [string] , str ( right ) ) , ] [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] [EOL] from rflx . declaration import ( Argument , ChannelDeclaration , PrivateDeclaration , RenamingDeclaration , SubprogramDeclaration , VariableDeclaration , ) [EOL] from rflx . error import RecordFluxError [EOL] from rflx . expression import ( FALSE , TRUE , Binding , Call , Comprehension , Equal , ForAllIn , Length , MessageAggregate , Not , Number , Opaque , Selected , Valid , Variable , ) [EOL] from rflx . identifier import ID [EOL] from rflx . model import Session , State , Transition [EOL] from rflx . statement import Assignment , Erase , Reset [EOL] [EOL] [EOL] def test_undeclared_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_declared_variable ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_declared_local_variable ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , Variable ( [string] ) ) , ) ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_undeclared_local_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Variable ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , Variable ( [string] ) ) , ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_declared_local_variable_valid ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Valid ( Variable ( [string] ) ) , TRUE ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_declared_local_variable_field ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Selected ( Variable ( [string] ) , [string] ) , TRUE ) , ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_assignment_to_undeclared_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , FALSE ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_assignment_from_undeclared_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Variable ( [string] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_erasure_of_undeclared_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Erase ( [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_reset_of_undeclared_list ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Reset ( [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_call_to_undeclared_function ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_read ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = False ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_write ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) , TRUE ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = False , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_call ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) , TRUE ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_data_available ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_read_without_arguments ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_read_undeclared_channel ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_read_invalid_channel_type ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_write_invalid_channel_mode ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = False ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_data_available_invalid_channel_mode ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = False , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_read_invalid_channel_mode ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = False , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_call_channel_not_readable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = False , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_call_to_builtin_call_channel_not_writable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = False ) , ] , ) [EOL] [EOL] [EOL] def test_subprogram_call ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , ChannelDeclaration ( [string] , readable = True , writable = True ) , ] , ) [EOL] [EOL] [EOL] def test_undeclared_variable_in_subprogram_call ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , SubprogramDeclaration ( [string] , [ ] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_function_declaration_is_no_builtin_read ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ SubprogramDeclaration ( [string] , [ ] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_function_declaration_is_no_builtin_write ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ChannelDeclaration ( [string] , readable = True , writable = False ) ] , ) [EOL] [EOL] [EOL] def test_function_declaration_is_no_builtin_call ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_function_declaration_is_no_builtin_data_available ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ RenamingDeclaration ( [string] , [string] , Variable ( [string] ) ) , VariableDeclaration ( [string] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_local_variable_shadows_global ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_unused_global_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_unused_local_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_renames_references_undefined_variable ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ RenamingDeclaration ( [string] , [string] , Variable ( [string] ) ) ] , ) [EOL] [EOL] [EOL] def test_binding_as_subprogram_parameter ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Binding ( Call ( [string] , [ Length ( Variable ( [string] ) ) ] ) , { [string] : Variable ( [string] ) } , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , VariableDeclaration ( [string] , [string] ) , SubprogramDeclaration ( [string] , [ ] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_for_all ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = ForAllIn ( [string] , Variable ( [string] ) , Equal ( Selected ( Variable ( [string] ) , [string] ) , Number ( [number] ) ) , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_append_list_attribute ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , VariableDeclaration ( [string] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_extend_list_attribute ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , Call ( [string] , [ Variable ( [string] ) , Variable ( [string] ) ] ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , VariableDeclaration ( [string] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_aggregate_with_undefined_parameter ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , actions = [ Assignment ( [string] , MessageAggregate ( [string] , { [string] : Variable ( [string] ) , [string] : Variable ( [string] ) } , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_comprehension ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , actions = [ Assignment ( [string] , Comprehension ( [string] , Variable ( [string] ) , Selected ( Variable ( [string] ) , [string] ) , Equal ( Selected ( Variable ( [string] ) , [string] ) , TRUE ) , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] [EOL] [EOL] def test_assignment_opaque_subprogram_undef_parameter ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , actions = [ Assignment ( [string] , Opaque ( Call ( [string] , [ Variable ( [string] ) ] ) , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , SubprogramDeclaration ( [string] , [ Argument ( [string] , [string] ) ] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_assignment_opaque_subprogram_result ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , actions = [ Assignment ( [string] , Opaque ( Call ( [string] , [ Variable ( [string] ) ] ) , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , SubprogramDeclaration ( [string] , [ Argument ( [string] , [string] ) ] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_assignment_opaque_subprogram_binding ( ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , actions = [ Assignment ( [string] , Binding ( Opaque ( Call ( [string] , [ Variable ( [string] ) ] ) ) , { [string] : Variable ( [string] ) } , ) , ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) , SubprogramDeclaration ( [string] , [ Argument ( [string] , [string] ) ] , [string] ) , ] , ) [EOL] [EOL] [EOL] def test_private_declaration_is_no_builtin_write ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ PrivateDeclaration ( [string] ) ] , ) [EOL] [EOL] [EOL] def test_duplicate_states ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , declarations = [ ] ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_invalid_channel_id_type ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] ) ) : [EOL] Call ( [string] , [ Number ( [number] ) ] ) . validate ( { } ) [EOL] [EOL] [EOL] def test_validate_not ( ) : [EOL] Not ( TRUE ) . validate ( { } ) [EOL] [EOL] [EOL] def test_validate_builtin_validate ( ) : [EOL] Variable ( [string] ) . validate ( { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [EOL] import pytest [EOL] [EOL] logging . disable ( logging . CRITICAL ) [EOL] [EOL] pytest . register_assert_rewrite ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] import rflx [EOL] import builtins [EOL] from pathlib import Path [EOL] from tempfile import TemporaryDirectory [EOL] [EOL] from rflx . expression import ( FALSE , TRUE , Equal , Greater , Less , Number , Pow , Variable , VariableDeclaration , ) [EOL] from rflx . graph import Graph [EOL] from rflx . identifier import ID [EOL] from rflx . model import ( FINAL , INITIAL , Field , Link , Message , ModularInteger , Session , State , Transition , ) [EOL] from rflx . statement import Assignment , Erase [EOL] [EOL] [EOL] def assert_graph ( graph , expected ) : [EOL] with TemporaryDirectory ( ) as directory : [EOL] path = Path ( directory ) / Path ( [string] ) [EOL] graph . write ( path , fmt = [string] ) [EOL] with open ( path ) as f : [EOL] assert f . read ( ) . split ( ) == expected . split ( ) [EOL] [EOL] [EOL] def test_graph_object ( ) : [EOL] f_type = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] m = Message ( [string] , structure = [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , FINAL ) ] , types = { Field ( [string] ) : f_type } , ) [EOL] g = Graph ( m ) . get [EOL] assert [ ( e . get_source ( ) , e . get_destination ( ) ) for e in g . get_edges ( ) ] == [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] assert [ n . get_name ( ) for n in g . get_nodes ( ) ] == [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] def test_empty_message_graph ( ) : [EOL] m = Message ( [string] , [ ] , { } ) [EOL] expected = [string] [EOL] [EOL] assert_graph ( Graph ( m ) , expected ) [EOL] [EOL] [EOL] def test_dot_graph ( ) : [EOL] f_type = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] m = Message ( [string] , structure = [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , FINAL ) ] , types = { Field ( [string] ) : f_type } , ) [EOL] expected = [string] [EOL] [EOL] assert_graph ( Graph ( m ) , expected ) [EOL] [EOL] [EOL] def test_dot_graph_with_condition ( ) : [EOL] f_type = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] m = Message ( [string] , structure = [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , FINAL , Greater ( Variable ( [string] ) , Number ( [number] ) ) ) , ] , types = { Field ( [string] ) : f_type } , ) [EOL] expected = [string] [EOL] [EOL] assert_graph ( Graph ( m ) , expected ) [EOL] [EOL] [EOL] def test_dot_graph_with_double_edge ( ) : [EOL] f_type = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] m = Message ( [string] , structure = [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , FINAL , Greater ( Variable ( [string] ) , Number ( [number] ) ) ) , Link ( Field ( [string] ) , FINAL , Less ( Variable ( [string] ) , Number ( [number] ) ) ) , ] , types = { Field ( [string] ) : f_type } , ) [EOL] expected = [string] [EOL] [EOL] assert_graph ( Graph ( m ) , expected ) [EOL] [EOL] [EOL] def test_session_graph ( ) : [EOL] s = Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) , condition = Equal ( Variable ( [string] ) , TRUE ) ) , Transition ( target = ID ( [string] ) ) , ] , ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , actions = [ Assignment ( [string] , FALSE ) , Erase ( [string] ) ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ VariableDeclaration ( [string] , [string] ) ] , ) [EOL] expected = [string] [EOL] [EOL] assert_graph ( Graph ( s ) , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Generator [EOL] import pathlib [EOL] import argparse [EOL] import rflx [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import argparse [EOL] import cProfile [EOL] import sys [EOL] from pathlib import Path [EOL] from time import perf_counter [EOL] from typing import Generator [EOL] [EOL] from tqdm import tqdm [comment] [EOL] [EOL] from rflx . pyrflx import PyRFLX [EOL] [EOL] [EOL] class Benchmark : [EOL] def __init__ ( self , specdir ) : [EOL] print ( [string] ) [EOL] start = perf_counter ( ) [EOL] self . __pyrflx = PyRFLX ( [ str ( specdir / [string] ) , str ( specdir / [string] ) ] , True , True ) [EOL] self . __ipv4 = self . __pyrflx [ [string] ] [EOL] self . __icmp = self . __pyrflx [ [string] ] [EOL] print ( f" [string] { perf_counter ( ) - start } [string] " ) [EOL] [EOL] def generate ( self , count = [number] ** [number] ) : [EOL] if count > [number] ** [number] : [EOL] raise ValueError [EOL] for ident in range ( [number] , count ) : [EOL] msg = self . __icmp [ [string] ] [EOL] pkt = self . __ipv4 [ [string] ] [EOL] msg . set ( [string] , [string] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , ident ) [EOL] msg . set ( [string] , bytes ( [number] ) ) [EOL] [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] + len ( msg . bytestring ) ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [ ] ) [EOL] pkt . set ( [string] , msg . bytestring ) [EOL] yield pkt . bytestring [EOL] [EOL] def run ( self ) : [EOL] i = [number] [EOL] start = perf_counter ( ) [EOL] for _ in tqdm ( self . generate ( ) ) : [EOL] if i % [number] == [number] : [EOL] if perf_counter ( ) - start > [number] : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] start = perf_counter ( ) [EOL] i += [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , type = Path , help = [string] ) [EOL] args = parser . parse_args ( sys . argv [ [number] : ] ) [EOL] benchmark = Benchmark ( args . specdir ) [EOL] if args . profile : [EOL] print ( [string] ) [EOL] [EOL] def run ( ) : [EOL] for _ in benchmark . generate ( [number] ) : [EOL] pass [EOL] [EOL] cProfile . run ( [string] , args . outfile ) [EOL] else : [EOL] benchmark . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Generator[builtins.bytes,None,None]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $tests.benchmark.Benchmark$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $tests.benchmark.Benchmark$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $tests.benchmark.Benchmark$ 0 0 0 0 0
import subprocess [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_icmp_socket ( ) : [EOL] subprocess . run ( [ [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] @ pytest . mark . root def test_ping_python ( ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] @ pytest . mark . root def test_ping_spark ( ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import rflx [EOL] from rflx . expression import ( Aggregate , And , Div , Equal , First , GreaterEqual , Last , Length , LessEqual , Mul , NotEqual , Number , Pow , Sub , Variable , ) [EOL] from rflx . model import ( FINAL , INITIAL , Array , DerivedMessage , Enumeration , Field , Link , Message , Model , ModularInteger , Opaque , RangeInteger , Refinement , ) [EOL] [EOL] NULL_MESSAGE = Message ( [string] , [ ] , { } ) [EOL] NULL_MODEL = Model ( [ NULL_MESSAGE ] ) [EOL] [EOL] TLV_TAG = Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False ) [EOL] TLV_LENGTH = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] TLV_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , Equal ( Variable ( [string] ) , Variable ( [string] ) ) ) , Link ( Field ( [string] ) , FINAL , Equal ( Variable ( [string] ) , Variable ( [string] ) ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Mul ( Variable ( [string] ) , Number ( [number] ) ) ) , Link ( Field ( [string] ) , FINAL ) , ] , { Field ( [string] ) : TLV_TAG , Field ( [string] ) : TLV_LENGTH , Field ( [string] ) : Opaque ( ) } , ) [EOL] TLV_MODEL = Model ( [ TLV_TAG , TLV_LENGTH , TLV_MESSAGE ] ) [EOL] [EOL] NULL_MESSAGE_IN_TLV_MESSAGE = Refinement ( [string] , TLV_MESSAGE , Field ( [string] ) , NULL_MESSAGE ) [EOL] NULL_MESSAGE_IN_TLV_MESSAGE_MODEL = Model ( [ TLV_TAG , TLV_LENGTH , TLV_MESSAGE , NULL_MESSAGE , NULL_MESSAGE_IN_TLV_MESSAGE ] ) [EOL] [EOL] ETHERNET_ADDRESS = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] ETHERNET_TYPE_LENGTH = RangeInteger ( [string] , Number ( [number] ) , Sub ( Pow ( Number ( [number] ) , Number ( [number] ) ) , Number ( [number] ) ) , Number ( [number] ) ) [EOL] ETHERNET_TPID = RangeInteger ( [string] , Number ( [number] , [number] ) , Number ( [number] , [number] ) , Number ( [number] ) ) [EOL] ETHERNET_TCI = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] ETHERNET_FRAME = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , Equal ( Variable ( [string] ) , Number ( [number] , [number] ) ) , first = First ( [string] ) , ) , Link ( Field ( [string] ) , Field ( [string] ) , NotEqual ( Variable ( [string] ) , Number ( [number] , [number] ) ) , first = First ( [string] ) , ) , Link ( Field ( [string] ) , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , LessEqual ( Variable ( [string] ) , Number ( [number] ) ) , Mul ( Variable ( [string] ) , Number ( [number] ) ) , ) , Link ( Field ( [string] ) , Field ( [string] ) , GreaterEqual ( Variable ( [string] ) , Number ( [number] ) ) , Sub ( Last ( [string] ) , Last ( [string] ) ) , ) , Link ( Field ( [string] ) , FINAL , And ( GreaterEqual ( Div ( Length ( [string] ) , Number ( [number] ) ) , Number ( [number] ) ) , LessEqual ( Div ( Length ( [string] ) , Number ( [number] ) ) , Number ( [number] ) ) , ) , ) , ] , { Field ( [string] ) : ETHERNET_ADDRESS , Field ( [string] ) : ETHERNET_ADDRESS , Field ( [string] ) : ETHERNET_TYPE_LENGTH , Field ( [string] ) : ETHERNET_TPID , Field ( [string] ) : ETHERNET_TCI , Field ( [string] ) : ETHERNET_TYPE_LENGTH , Field ( [string] ) : Opaque ( ) , } , ) [EOL] ETHERNET_MODEL = Model ( [ ETHERNET_ADDRESS , ETHERNET_TYPE_LENGTH , ETHERNET_TPID , ETHERNET_TCI , ETHERNET_FRAME ] ) [EOL] [EOL] ENUMERATION_PRIORITY = Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , True , ) [EOL] ENUMERATION_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , FINAL ) ] , { Field ( [string] ) : ENUMERATION_PRIORITY } , ) [EOL] ENUMERATION_MODEL = Model ( [ ENUMERATION_PRIORITY , ENUMERATION_MESSAGE ] ) [EOL] [EOL] ARRAYS_LENGTH = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] ARRAYS_MODULAR_INTEGER = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] ARRAYS_MODULAR_VECTOR = Array ( [string] , ARRAYS_MODULAR_INTEGER ) [EOL] ARRAYS_RANGE_INTEGER = RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Number ( [number] ) ) [EOL] ARRAYS_RANGE_VECTOR = Array ( [string] , ARRAYS_RANGE_INTEGER ) [EOL] ARRAYS_ENUMERATION = Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , ) [EOL] ARRAYS_ENUMERATION_VECTOR = Array ( [string] , ARRAYS_ENUMERATION ) [EOL] ARRAYS_AV_ENUMERATION = Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , True , ) [EOL] ARRAYS_AV_ENUMERATION_VECTOR = Array ( [string] , ARRAYS_AV_ENUMERATION ) [EOL] ARRAYS_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Mul ( Variable ( [string] ) , Number ( [number] ) ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Number ( [number] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Number ( [number] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Number ( [number] ) ) , Link ( Field ( [string] ) , FINAL ) , ] , { Field ( [string] ) : ARRAYS_LENGTH , Field ( [string] ) : ARRAYS_MODULAR_VECTOR , Field ( [string] ) : ARRAYS_RANGE_VECTOR , Field ( [string] ) : ARRAYS_ENUMERATION_VECTOR , Field ( [string] ) : ARRAYS_AV_ENUMERATION_VECTOR , } , ) [EOL] ARRAYS_INNER_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Mul ( Variable ( [string] ) , Number ( [number] ) ) ) , Link ( Field ( [string] ) , FINAL ) , ] , { Field ( [string] ) : ARRAYS_LENGTH , Field ( [string] ) : Opaque ( ) } , ) [EOL] ARRAYS_INNER_MESSAGES = Array ( [string] , ARRAYS_INNER_MESSAGE ) [EOL] ARRAYS_MESSAGES_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) ) , Link ( Field ( [string] ) , Field ( [string] ) , length = Mul ( Variable ( [string] ) , Number ( [number] ) ) ) , Link ( Field ( [string] ) , FINAL ) , ] , { Field ( [string] ) : ARRAYS_LENGTH , Field ( [string] ) : ARRAYS_INNER_MESSAGES } , ) [EOL] ARRAYS_MODEL = Model ( [ ARRAYS_LENGTH , ARRAYS_MODULAR_INTEGER , ARRAYS_MODULAR_VECTOR , ARRAYS_RANGE_INTEGER , ARRAYS_RANGE_VECTOR , ARRAYS_ENUMERATION , ARRAYS_ENUMERATION_VECTOR , ARRAYS_AV_ENUMERATION , ARRAYS_AV_ENUMERATION_VECTOR , ARRAYS_MESSAGE , ARRAYS_INNER_MESSAGE , ARRAYS_INNER_MESSAGES , ARRAYS_MESSAGES_MESSAGE , ] ) [EOL] [EOL] EXPRESSION_MESSAGE = Message ( [string] , [ Link ( INITIAL , Field ( [string] ) , length = Number ( [number] ) ) , Link ( Field ( [string] ) , FINAL , Equal ( Variable ( [string] ) , Aggregate ( Number ( [number] ) , Number ( [number] ) ) ) ) , ] , { Field ( [string] ) : Opaque ( ) } , ) [EOL] EXPRESSION_MODEL = Model ( [ EXPRESSION_MESSAGE ] ) [EOL] [EOL] DERIVATION_MESSAGE = DerivedMessage ( [string] , ARRAYS_MESSAGE ) [EOL] DERIVATION_MODEL = Model ( [ * ARRAYS_MODEL . types , DERIVATION_MESSAGE ] ) [EOL] [EOL] MODULAR_INTEGER = ModularInteger ( [string] , Number ( [number] ) ) [EOL] RANGE_INTEGER = RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Number ( [number] ) ) [EOL] ENUMERATION = Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.type_.Enumeration$ 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.message.Message$ 0 0 0 0 $rflx.model.message.Refinement$ 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 $rflx.model.message.Message$ 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.type_.Enumeration$ 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.message.Message$ 0 $rflx.model.message.Message$ 0 $rflx.model.message.Refinement$ 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.type_.RangeInteger$ 0 $rflx.model.type_.RangeInteger$ 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.message.Message$ 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.type_.Enumeration$ 0 $rflx.model.message.Message$ 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 $rflx.model.type_.Array$ 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.type_.ModularInteger$ 0 $rflx.model.type_.Array$ 0 $rflx.model.type_.RangeInteger$ 0 $rflx.model.type_.Array$ 0 $rflx.model.type_.Enumeration$ 0 $rflx.model.type_.Array$ 0 $rflx.model.type_.Enumeration$ 0 $rflx.model.type_.Array$ 0 $rflx.model.message.Message$ 0 $rflx.model.type_.Array$ 0 $rflx.model.type_.Array$ 0 $rflx.model.message.Message$ 0 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 0 $rflx.model.message.Message$ 0 0 0 0 $rflx.model.message.DerivedMessage$ 0 0 0 0 0 $rflx.model.message.Message$ 0 0 $rflx.model.model.Model$ 0 0 0 0 0 $rflx.model.model.Model$ 0 0 0 $rflx.model.message.DerivedMessage$ 0 0 0 0 $rflx.model.type_.ModularInteger$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.RangeInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.model.type_.Enumeration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Type [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] import typing as ty [EOL] [EOL] import pytest [EOL] [EOL] from rflx . typing_ import ( Aggregate , Any , AnyInteger , Bounds , Composite , Enumeration , Integer , Message , Type , Undefined , UndefinedInteger , UniversalInteger , common_type , ) [EOL] [EOL] [EOL] def test_bounds_contains ( ) : [EOL] assert [number] not in Bounds ( None , None ) [EOL] assert [number] in Bounds ( [number] , [number] ) [EOL] assert [number] not in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) not in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) not in Bounds ( [number] , [number] ) [EOL] assert Bounds ( [number] , [number] ) not in Bounds ( None , None ) [EOL] assert Bounds ( None , None ) not in Bounds ( [number] , [number] ) [EOL] assert [string] not in Bounds ( [number] , [number] ) [EOL] [EOL] [EOL] def test_bounds_str ( ) : [EOL] assert str ( Bounds ( None , None ) ) == [string] [EOL] assert str ( Bounds ( [number] , [number] ) ) == [string] [EOL] assert str ( Bounds ( [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Enumeration ( [string] ) , Any ( ) , Enumeration ( [string] ) ) , ( Enumeration ( [string] ) , Enumeration ( [string] ) , Enumeration ( [string] ) ) , ( Enumeration ( [string] ) , Undefined ( ) , Undefined ( ) ) , ( Enumeration ( [string] ) , Enumeration ( [string] ) , Undefined ( ) ) , ( Enumeration ( [string] ) , Integer ( [string] ) , Undefined ( ) ) , ] , ) def test_enumeration_common_type ( enumeration , other , expected ) : [EOL] assert enumeration . common_type ( other ) == expected [EOL] assert other . common_type ( enumeration ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Enumeration ( [string] ) , Any ( ) , True ) , ( Enumeration ( [string] ) , Enumeration ( [string] ) , True ) , ( Enumeration ( [string] ) , Undefined ( ) , False ) , ( Enumeration ( [string] ) , Enumeration ( [string] ) , False ) , ( Enumeration ( [string] ) , Integer ( [string] ) , False ) , ] , ) def test_enumeration_is_compatible ( enumeration , other , expected ) : [EOL] assert enumeration . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( enumeration ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( AnyInteger ( ) , Any ( ) , AnyInteger ( ) ) , ( AnyInteger ( ) , AnyInteger ( ) , AnyInteger ( ) ) , ( AnyInteger ( ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( AnyInteger ( ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , ) , ( AnyInteger ( ) , UndefinedInteger ( ) , UndefinedInteger ( ) , ) , ( AnyInteger ( ) , Undefined ( ) , Undefined ( ) ) , ( AnyInteger ( ) , Enumeration ( [string] ) , Undefined ( ) ) , ] , ) def test_any_integer_common_type ( any_integer , other , expected ) : [EOL] assert any_integer . common_type ( other ) == expected [EOL] assert other . common_type ( any_integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( AnyInteger ( ) , Any ( ) , True ) , ( AnyInteger ( ) , AnyInteger ( ) , True ) , ( AnyInteger ( ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , True , ) , ( AnyInteger ( ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , True , ) , ( AnyInteger ( ) , UndefinedInteger ( ) , True , ) , ( AnyInteger ( ) , Undefined ( ) , False ) , ( AnyInteger ( ) , Enumeration ( [string] ) , False ) , ] , ) def test_any_integer_is_compatible ( any_integer , other , expected ) : [EOL] assert any_integer . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( any_integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( UndefinedInteger ( ) , Any ( ) , UndefinedInteger ( ) ) , ( UndefinedInteger ( ) , AnyInteger ( ) , UndefinedInteger ( ) ) , ( UndefinedInteger ( ) , UndefinedInteger ( ) , UndefinedInteger ( ) ) , ( UndefinedInteger ( ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , UndefinedInteger ( ) , ) , ( UndefinedInteger ( ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , UndefinedInteger ( ) , ) , ( UndefinedInteger ( ) , Undefined ( ) , Undefined ( ) ) , ( UndefinedInteger ( ) , Enumeration ( [string] ) , Undefined ( ) ) , ] , ) def test_undefined_integer_common_type ( undefined_integer , other , expected ) : [EOL] assert undefined_integer . common_type ( other ) == expected [EOL] assert other . common_type ( undefined_integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( UndefinedInteger ( ) , Any ( ) , True ) , ( UndefinedInteger ( ) , AnyInteger ( ) , True ) , ( UndefinedInteger ( ) , UndefinedInteger ( ) , True ) , ( UndefinedInteger ( ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , True , ) , ( UndefinedInteger ( ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , True , ) , ( UndefinedInteger ( ) , Undefined ( ) , False ) , ( UndefinedInteger ( ) , Enumeration ( [string] ) , False ) , ] , ) def test_undefined_integer_is_compatible ( undefined_integer , other , expected ) : [EOL] assert undefined_integer . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( undefined_integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Integer ( [string] ) , Any ( ) , Integer ( [string] ) ) , ( Integer ( [string] ) , AnyInteger ( ) , Integer ( [string] ) ) , ( Integer ( [string] ) , Integer ( [string] ) , Integer ( [string] ) ) , ( Integer ( [string] ) , UniversalInteger ( ) , Integer ( [string] ) ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Any ( ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( Integer ( [string] ) , Integer ( [string] ) , UndefinedInteger ( ) , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , UndefinedInteger ( ) , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , UndefinedInteger ( ) , ) , ( Integer ( [string] ) , Undefined ( ) , Undefined ( ) ) , ( Integer ( [string] ) , Enumeration ( [string] ) , Undefined ( ) ) , ] , ) def test_integer_common_type ( integer , other , expected ) : [EOL] assert integer . common_type ( other ) == expected [EOL] assert other . common_type ( integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Integer ( [string] ) , Any ( ) , True ) , ( Integer ( [string] ) , AnyInteger ( ) , True ) , ( Integer ( [string] ) , Integer ( [string] ) , True ) , ( Integer ( [string] ) , UniversalInteger ( ) , True ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Any ( ) , True , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , True , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , True , ) , ( Integer ( [string] ) , Integer ( [string] ) , True , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , True , ) , ( Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , True , ) , ( Integer ( [string] ) , Undefined ( ) , False ) , ( Integer ( [string] ) , Enumeration ( [string] ) , False ) , ] , ) def test_integer_is_compatible ( integer , other , expected ) : [EOL] assert integer . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( integer ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Aggregate ( Integer ( [string] ) ) , Any ( ) , Aggregate ( Integer ( [string] ) ) , ) , ( Aggregate ( Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , ) , ( Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UndefinedInteger ( ) ) , ) , ( Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UndefinedInteger ( ) ) , ) , ( Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , ) , ( Aggregate ( Integer ( [string] ) ) , Undefined ( ) , Undefined ( ) , ) , ] , ) def test_aggregate_common_type ( aggregate , other , expected ) : [EOL] assert aggregate . common_type ( other ) == expected [EOL] assert other . common_type ( aggregate ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Aggregate ( Integer ( [string] ) ) , Any ( ) , True , ) , ( Aggregate ( Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , True , ) , ( Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , True , ) , ( Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , True , ) , ( Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , True , ) , ( Aggregate ( Integer ( [string] ) ) , Undefined ( ) , False , ) , ] , ) def test_aggregate_is_compatible ( aggregate , other , expected ) : [EOL] assert aggregate . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( aggregate ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Composite ( [string] , Integer ( [string] ) ) , Any ( ) , Composite ( [string] , Integer ( [string] ) ) , ) , ( Composite ( [string] , Integer ( [string] ) ) , Composite ( [string] , Integer ( [string] ) ) , Composite ( [string] , Integer ( [string] ) ) , ) , ( Composite ( [string] , Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , Composite ( [string] , Integer ( [string] ) ) , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , ) , ( Composite ( [string] , Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , Undefined ( ) , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Undefined ( ) , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Undefined ( ) , ) , ( Composite ( [string] , Integer ( [string] ) ) , Undefined ( ) , Undefined ( ) , ) , ] , ) def test_composite_common_type ( composite , other , expected ) : [EOL] assert composite . common_type ( other ) == expected [EOL] assert other . common_type ( composite ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Composite ( [string] , Integer ( [string] ) ) , Any ( ) , True , ) , ( Composite ( [string] , Integer ( [string] ) ) , Composite ( [string] , Integer ( [string] ) ) , True , ) , ( Composite ( [string] , Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , True , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , True , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , True , ) , ( Composite ( [string] , Integer ( [string] ) ) , Aggregate ( Integer ( [string] ) ) , False , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , False , ) , ( Composite ( [string] , Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , False , ) , ( Composite ( [string] , Integer ( [string] ) ) , Undefined ( ) , False , ) , ] , ) def test_composite_is_compatible ( composite , other , expected ) : [EOL] assert composite . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( composite ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Message ( [string] ) , Any ( ) , Message ( [string] ) ) , ( Message ( [string] ) , Message ( [string] ) , Message ( [string] ) ) , ( Message ( [string] ) , Message ( [string] ) , Undefined ( ) ) , ( Message ( [string] ) , Undefined ( ) , Undefined ( ) ) , ( Message ( [string] ) , Enumeration ( [string] ) , Undefined ( ) ) , ] , ) def test_message_common_type ( message , other , expected ) : [EOL] assert message . common_type ( other ) == expected [EOL] assert other . common_type ( message ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( Message ( [string] ) , Any ( ) , True ) , ( Message ( [string] ) , Message ( [string] ) , True ) , ( Message ( [string] ) , Message ( [string] ) , False ) , ( Message ( [string] ) , Undefined ( ) , False ) , ( Message ( [string] ) , Enumeration ( [string] ) , False ) , ] , ) def test_message_is_compatible ( message , other , expected ) : [EOL] assert message . is_compatible ( other ) == expected [EOL] assert other . is_compatible ( message ) == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [ ] , Any ( ) , ) , ( [ Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , ] , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( [ UniversalInteger ( Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , ] , Integer ( [string] , Bounds ( [number] , [number] ) ) , ) , ( [ UniversalInteger ( Bounds ( [number] , [number] ) ) , Integer ( [string] , Bounds ( [number] , [number] ) ) , UniversalInteger ( Bounds ( [number] , [number] ) ) , ] , UndefinedInteger ( ) , ) , ( [ Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( Integer ( [string] , Bounds ( [number] , [number] ) ) ) , ] , Aggregate ( UndefinedInteger ( ) ) , ) , ( [ Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , ] , Aggregate ( UniversalInteger ( Bounds ( [number] , [number] ) ) ) , ) , ] , ) def test_common_type ( types , expected ) : [EOL] assert common_type ( types ) == expected [EOL] assert common_type ( list ( reversed ( types ) ) ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import rflx . ada as ada [EOL] from tests . utils import assert_equal , multilinestr [EOL] [EOL] [EOL] def test_id_str ( ) : [EOL] assert str ( ada . ID ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_id_add ( ) : [EOL] assert ada . ID ( [string] ) + ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) + ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] [EOL] [EOL] def test_id_add_str ( ) : [EOL] assert [string] + ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) + [string] == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) + [string] == ada . ID ( [string] ) [EOL] assert [string] + ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] [EOL] [EOL] def test_id_mul_id ( ) : [EOL] assert ada . ID ( [string] ) * ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) * ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] [EOL] [EOL] def test_id_mul_str ( ) : [EOL] assert [string] * ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) * [string] == ada . ID ( [string] ) [EOL] assert [string] * ada . ID ( [string] ) == ada . ID ( [string] ) [EOL] assert ada . ID ( [string] ) * [string] == ada . ID ( [string] ) [EOL] [EOL] [EOL] def test_bool_expr_str ( ) : [EOL] assert_equal ( str ( ada . And ( ada . Variable ( [string] ) , ada . Or ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) , ada . Variable ( [string] ) ) ) , multilinestr ( [string] ) , ) [EOL] assert_equal ( str ( ada . AndThen ( ada . Variable ( [string] ) , ada . OrElse ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) , ada . Variable ( [string] ) , ) ) , multilinestr ( [string] ) , ) [EOL] [EOL] [EOL] def test_and_str ( ) : [EOL] assert str ( ada . And ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_and_then_str ( ) : [EOL] assert str ( ada . AndThen ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_or_str ( ) : [EOL] assert str ( ada . Or ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_or_else_str ( ) : [EOL] assert str ( ada . OrElse ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_add_str ( ) : [EOL] assert str ( ada . Add ( ada . Number ( [number] ) , ada . Call ( [string] , [ ] ) ) ) == [string] [EOL] assert str ( ada . Add ( ada . Number ( [number] ) , - ada . Call ( [string] , [ ] ) ) ) == [string] [EOL] [EOL] [EOL] def test_attribute ( ) : [EOL] assert isinstance ( ada . Range ( [string] ) , ada . Attribute ) [EOL] assert isinstance ( ada . Old ( [string] ) , ada . Attribute ) [EOL] assert isinstance ( ada . Result ( [string] ) , ada . Attribute ) [EOL] assert isinstance ( ada . Constrained ( [string] ) , ada . Attribute ) [EOL] [EOL] [EOL] def test_attribute_str ( ) : [EOL] assert str ( ada . First ( [string] ) ) == [string] [EOL] assert str ( - ada . First ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_attribute_expression_str ( ) : [EOL] assert str ( ada . Val ( [string] , ada . Number ( [number] ) ) ) == [string] [EOL] [EOL] [EOL] def test_indexed_str ( ) : [EOL] assert str ( ada . Indexed ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] assert str ( - ada . Indexed ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_aggregate_str ( ) : [EOL] assert str ( ada . Aggregate ( ada . Number ( [number] ) ) ) == [string] [EOL] assert str ( ada . Aggregate ( ada . Number ( [number] ) , ada . Number ( [number] ) ) ) == [string] [EOL] [EOL] [EOL] def test_in_str ( ) : [EOL] assert str ( ada . In ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_not_in_str ( ) : [EOL] assert str ( ada . NotIn ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_if_str ( ) : [EOL] assert_equal ( str ( ada . If ( [ ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) ] , ada . Number ( [number] ) , ) ) , multilinestr ( [string] ) , ) [EOL] [EOL] [EOL] def test_case_str ( ) : [EOL] assert_equal ( str ( ada . Case ( ada . Variable ( [string] ) , [ ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ] , ) ) , multilinestr ( [string] ) , ) [EOL] [EOL] [EOL] def test_quantified_expression_str ( ) : [EOL] assert ( str ( ada . ForAllOf ( [string] , ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] ) [EOL] assert ( str ( ada . ForAllIn ( [string] , ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] ) [EOL] assert ( str ( ada . ForSomeIn ( [string] , ada . Variable ( [string] ) , ada . Variable ( [string] ) ) ) == [string] ) [EOL] [EOL] [EOL] def test_number_str ( ) : [EOL] assert str ( ada . Number ( [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_long ( ) : [EOL] assert str ( ada . Number ( [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_neg_long ( ) : [EOL] assert str ( ada . Number ( - [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_hex ( ) : [EOL] assert str ( ada . Number ( [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_neg_hex ( ) : [EOL] assert str ( ada . Number ( - [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_dec ( ) : [EOL] assert str ( ada . Number ( [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_oct ( ) : [EOL] assert str ( ada . Number ( [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_neg_oct ( ) : [EOL] assert str ( ada . Number ( - [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_number_str_bin ( ) : [EOL] assert str ( ada . Number ( [number] , [number] ) ) == [string] [EOL] [EOL] [EOL] def test_string_str ( ) : [EOL] assert str ( ada . String ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_expr_str ( ) : [EOL] assert_equal ( str ( ada . And ( ada . If ( [ ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) ] , ada . Number ( [number] ) , ) , ada . Variable ( [string] ) , ada . Or ( ada . Variable ( [string] ) , ada . Variable ( [string] ) ) , ada . Variable ( [string] ) , ) ) , multilinestr ( [string] ) , ) [EOL] assert_equal ( str ( ada . ForAllOf ( [string] , ada . Variable ( [string] ) , ada . If ( [ ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) , ( ada . Variable ( [string] ) , ada . Number ( [number] ) ) ] , ada . Number ( [number] ) , ) , ) ) , multilinestr ( [string] ) , ) [EOL] assert str ( ada . Equal ( ada . String ( [string] ) , ada . Variable ( [string] ) ) ) == [string] [EOL] [EOL] [EOL] def test_call_str ( ) : [EOL] assert str ( ada . Call ( [string] , [ ] ) ) == [string] [EOL] assert str ( ada . Call ( [string] , [ ada . Variable ( [string] ) , ada . Variable ( [string] ) ] ) ) == [string] [EOL] assert str ( - ada . Call ( [string] , [ ] ) ) == [string] [EOL] [EOL] [EOL] def test_conversion_str ( ) : [EOL] assert str ( ada . Conversion ( [string] , ada . Variable ( [string] ) ) ) == [string] [EOL] assert str ( ada . Not ( ada . Conversion ( [string] , ada . Variable ( [string] ) ) ) ) == [string] [EOL] [EOL] [EOL] def test_import ( ) : [EOL] assert str ( ada . Import ( ) ) == [string] [EOL] [EOL] [EOL] def test_subtype ( ) : [EOL] assert str ( ada . Subtype ( [string] , [string] ) ) == [string] [EOL] [EOL] [EOL] def test_range_subtype ( ) : [EOL] assert ( str ( ada . RangeSubtype ( [string] , [string] , ada . Number ( [number] ) , ada . Number ( [number] ) ) ) == [string] ) [EOL] [EOL] [EOL] def test_derived_type ( ) : [EOL] assert str ( ada . DerivedType ( [string] , [string] ) ) == [string] [EOL] [EOL] [EOL] def test_private_type ( ) : [EOL] assert str ( ada . PrivateType ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_discrete_type ( ) : [EOL] assert str ( ada . DiscreteType ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_array_type ( ) : [EOL] assert str ( ada . ArrayType ( [string] , [string] , [string] ) ) == [string] [EOL] [EOL] [EOL] def test_unconstrained_array_type ( ) : [EOL] assert str ( ada . UnconstrainedArrayType ( [string] , [string] , [string] ) ) == [string] [EOL] [EOL] [EOL] def test_access_type ( ) : [EOL] assert str ( ada . AccessType ( [string] , [string] ) ) == [string] [EOL] [EOL] [EOL] def test_subprogram_renaming_declaration ( ) : [EOL] assert ( str ( ada . SubprogramRenamingDeclaration ( ada . ProcedureSpecification ( [string] ) , [string] ) ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] from rflx . identifier import ID [EOL] [EOL] [EOL] def test_id_constructor ( ) : [EOL] assert ID ( [ [string] ] ) == ID ( [string] ) [EOL] assert ID ( [ [string] , [string] ] ) == ID ( [string] ) [EOL] assert ID ( [ [string] , [string] , [string] ] ) == ID ( [string] ) [EOL] assert ID ( ID ( [string] ) ) == ID ( [string] ) [EOL] assert ID ( ID ( [string] ) ) == ID ( [string] ) [EOL] assert ID ( ID ( [string] ) ) == ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_type ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [number] ) [comment] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_empty ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [ ] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_empty_string ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_empty_part ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_empty_first_part ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_empty_last_part ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_whitespace ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_invalid_colon ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) [EOL] [EOL] [EOL] def test_id_str ( ) : [EOL] assert str ( ID ( [string] ) ) == [string] [EOL] [EOL] [EOL] def test_id_add ( ) : [EOL] assert ID ( [string] ) + ID ( [string] ) == ID ( [string] ) [EOL] assert ID ( [string] ) + ID ( [string] ) == ID ( [string] ) [EOL] [EOL] [EOL] def test_id_add_str ( ) : [EOL] assert [string] + ID ( [string] ) == ID ( [string] ) [EOL] assert ID ( [string] ) + [string] == ID ( [string] ) [EOL] assert ID ( [string] ) + [string] == ID ( [string] ) [EOL] assert [string] + ID ( [string] ) == ID ( [string] ) [EOL] [EOL] [EOL] def test_id_mul_id ( ) : [EOL] assert ID ( [string] ) * ID ( [string] ) == ID ( [string] ) [EOL] assert ID ( [string] ) * ID ( [string] ) == ID ( [string] ) [EOL] [EOL] [EOL] def test_id_mul_str ( ) : [EOL] assert [string] * ID ( [string] ) == ID ( [string] ) [EOL] assert ID ( [string] ) * [string] == ID ( [string] ) [EOL] assert [string] * ID ( [string] ) == ID ( [string] ) [EOL] assert ID ( [string] ) * [string] == ID ( [string] ) [EOL] [EOL] [EOL] def test_id_name ( ) : [EOL] assert ID ( [string] ) . name == ID ( [string] ) [EOL] [EOL] [EOL] def test_id_parent ( ) : [EOL] assert ID ( [string] ) . parent == ID ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( not __debug__ , reason = [string] ) def test_id_parent_error ( ) : [EOL] with pytest . raises ( AssertionError , match = [string] ) : [EOL] ID ( [string] ) . parent [comment] [EOL] [EOL] [EOL] def test_id_sorted ( ) : [EOL] assert sorted ( [ ID ( [string] ) , ID ( [string] ) ] ) == [ ID ( [string] ) , ID ( [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] import rflx . declaration as decl [EOL] import rflx . expression as expr [EOL] import rflx . statement as stmt [EOL] from rflx . error import RecordFluxError [EOL] from rflx . identifier import ID [EOL] from rflx . model import Session , State , Transition [EOL] from tests . utils import assert_equal , multilinestr [EOL] [EOL] [EOL] def test_str ( ) : [EOL] assert_equal ( str ( Session ( [string] , [string] , [string] , [ State ( [string] , declarations = [ decl . VariableDeclaration ( [string] , [string] , expr . Variable ( [string] ) ) ] , actions = [ stmt . Assignment ( [string] , expr . Number ( [number] ) ) ] , transitions = [ Transition ( [string] , condition = expr . Equal ( expr . Variable ( [string] ) , expr . Number ( [number] ) ) ) , Transition ( [string] ) , ] , ) , State ( [string] ) , ] , [ decl . VariableDeclaration ( [string] , [string] , expr . Number ( [number] ) ) ] , [ decl . ChannelDeclaration ( [string] , readable = True , writable = True ) , decl . PrivateDeclaration ( [string] ) , decl . SubprogramDeclaration ( [string] , [ ] , [string] ) , ] , ) ) , multilinestr ( [string] ) , ) [EOL] [EOL] [EOL] def test_empty_states ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_invalid_initial ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_invalid_final ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] [string] [string] [string] ) , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_invalid_target_state ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] [string] , ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) , Transition ( target = ID ( [string] ) ) , ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_duplicate_state ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_multiple_duplicate_states ( ) : [EOL] with pytest . raises ( RecordFluxError , match = ( [string] ) ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_unreachable_state ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_multiple_unreachable_states ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , ) , State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) ] , ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_detached_state ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) , Transition ( target = ID ( [string] ) ) ] , ) , State ( name = ID ( [string] ) ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL] [EOL] [EOL] def test_multiple_detached_states ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Session ( identifier = [string] , initial = ID ( [string] ) , final = ID ( [string] ) , states = [ State ( name = ID ( [string] ) , transitions = [ Transition ( target = ID ( [string] ) ) , Transition ( target = ID ( [string] ) ) , Transition ( target = ID ( [string] ) ) , ] , ) , State ( name = ID ( [string] ) ) , State ( name = ID ( [string] ) ) , State ( name = ID ( [string] ) ) , ] , declarations = [ ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence , Type [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] from typing import Sequence [EOL] [EOL] import pytest [EOL] [EOL] import rflx . typing_ as rty [EOL] from rflx . error import Location , RecordFluxError [EOL] from rflx . expression import Add , Number , Pow , Sub , Variable [EOL] from rflx . identifier import ID [EOL] from rflx . model import ( BOOLEAN , BUILTIN_TYPES , OPAQUE , Array , Enumeration , Message , Model , ModularInteger , RangeInteger , Type , ) [EOL] from tests . models import MODULAR_INTEGER [EOL] from tests . utils import assert_equal , assert_type_model_error [EOL] [EOL] [EOL] def assert_model_error ( types , regex ) : [EOL] with pytest . raises ( RecordFluxError , match = regex ) : [EOL] Model ( [ * BUILTIN_TYPES . values ( ) , * types ] ) [EOL] [EOL] [EOL] def test_type_name ( ) : [EOL] t = ModularInteger ( [string] , Number ( [number] ) ) [EOL] assert t . name == [string] [EOL] assert t . package == ID ( [string] ) [EOL] assert_type_model_error ( ModularInteger ( [string] , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] assert_type_model_error ( ModularInteger ( [string] , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_type_type ( ) : [EOL] class NewType ( Type ) : [EOL] pass [EOL] [EOL] assert NewType ( [string] ) . type_ == rty . Undefined ( ) [EOL] [EOL] [EOL] def test_modular_size ( ) : [EOL] assert ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) . size == Number ( [number] ) [EOL] assert ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) . size_expr == Number ( [number] ) [EOL] [EOL] [EOL] def test_modular_first ( ) : [EOL] mod = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] assert mod . first == Number ( [number] ) [EOL] [EOL] [EOL] def test_modular_last ( ) : [EOL] mod = ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) ) [EOL] assert mod . last == Number ( [number] ** [number] - [number] ) [EOL] [EOL] [EOL] def test_modular_invalid_modulus_power_of_two ( ) : [EOL] assert_type_model_error ( ModularInteger ( [string] , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_modular_invalid_modulus_variable ( ) : [EOL] assert_type_model_error ( ModularInteger ( [string] , Pow ( Number ( [number] ) , Variable ( [string] ) ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_modular_invalid_modulus_limit ( ) : [EOL] assert_type_model_error ( ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_size ( ) : [EOL] assert_equal ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Pow ( Number ( [number] ) , Number ( [number] ) ) ) . size , Number ( [number] ) , ) [EOL] assert_equal ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Pow ( Number ( [number] ) , Number ( [number] ) ) ) . size_expr , Pow ( Number ( [number] ) , Number ( [number] ) ) , ) [EOL] [EOL] [EOL] def test_range_first ( ) : [EOL] integer = RangeInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) , Sub ( Pow ( Number ( [number] ) , Number ( [number] ) ) , Number ( [number] ) ) , Number ( [number] ) ) [EOL] assert integer . first == Number ( [number] ) [EOL] assert integer . first_expr == Pow ( Number ( [number] ) , Number ( [number] ) ) [EOL] [EOL] [EOL] def test_range_last ( ) : [EOL] integer = RangeInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) , Sub ( Pow ( Number ( [number] ) , Number ( [number] ) ) , Number ( [number] ) ) , Number ( [number] ) ) [EOL] assert integer . last == Number ( [number] ** [number] - [number] ) [EOL] assert integer . last_expr == Sub ( Pow ( Number ( [number] ) , Number ( [number] ) ) , Number ( [number] ) ) [EOL] [EOL] [EOL] def test_range_invalid_first_variable ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Add ( Number ( [number] ) , Variable ( [string] ) ) , Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_last_variable ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Add ( Number ( [number] ) , Variable ( [string] ) ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_last_exceeds_limit ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Pow ( Number ( [number] ) , Number ( [number] ) ) , Number ( [number] ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_first_negative ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( - [number] ) , Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_range ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_size_variable ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Add ( Number ( [number] ) , Variable ( [string] ) ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_size_too_small ( ) : [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_range_invalid_size_exceeds_limit ( ) : [EOL] [comment] [EOL] assert_type_model_error ( RangeInteger ( [string] , Number ( [number] ) , Number ( [number] ) , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_enumeration_size ( ) : [EOL] assert_equal ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Pow ( Number ( [number] ) , Number ( [number] ) ) , False , Location ( ( [number] , [number] ) ) ) . size , Number ( [number] ) , ) [EOL] assert_equal ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Pow ( Number ( [number] ) , Number ( [number] ) ) , False , Location ( ( [number] , [number] ) ) ) . size_expr , Pow ( Number ( [number] ) , Number ( [number] ) ) , ) [EOL] [EOL] [EOL] def test_enumeration_invalid_size_variable ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Add ( Number ( [number] ) , Variable ( [string] ) ) , False , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_enumeration_invalid_literal_value ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ** [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) ) , [string] [string] , ) [EOL] [EOL] [EOL] def test_enumeration_invalid_size_too_small ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_enumeration_invalid_size_exceeds_limit ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_enumeration_invalid_always_valid_aspect ( ) : [EOL] with pytest . raises ( RecordFluxError , match = [string] ) : [EOL] Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , True ) . error . propagate ( ) [EOL] [EOL] [EOL] def test_enumeration_invalid_literal ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( ( [number] , [number] ) ) ) ) , [string] , ) [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) ) , [string] , ) [EOL] [EOL] [EOL] def test_array_invalid_element_type ( ) : [EOL] assert_type_model_error ( Array ( [string] , Array ( [string] , MODULAR_INTEGER , Location ( ( [number] , [number] ) ) ) , Location ( ( [number] , [number] ) ) ) , [string] [string] , ) [EOL] assert_type_model_error ( Array ( [string] , Message ( [string] , [ ] , { } , location = Location ( ( [number] , [number] ) ) ) , Location ( ( [number] , [number] ) ) ) , [string] [string] , ) [EOL] assert_type_model_error ( Array ( [string] , OPAQUE , Location ( ( [number] , [number] ) ) ) , [string] [string] , ) [EOL] [EOL] [EOL] def test_array_unsupported_element_type ( ) : [EOL] assert_type_model_error ( Array ( [string] , ModularInteger ( [string] , Pow ( Number ( [number] ) , Number ( [number] ) ) , Location ( ( [number] , [number] ) ) ) , Location ( ( [number] , [number] ) ) , ) , [string] [string] , ) [EOL] assert_type_model_error ( Array ( [string] , BOOLEAN , Location ( ( [number] , [number] ) ) ) , [string] [string] , ) [EOL] [EOL] [EOL] def test_invalid_enumeration_type_duplicate_elements ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) ] , Number ( [number] ) , False , ) , [string] [string] , ) [EOL] [EOL] [EOL] def test_invalid_enumeration_type_multiple_duplicate_elements ( ) : [EOL] assert_type_model_error ( Enumeration ( [string] , [ ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ] , Number ( [number] ) , False , ) , [string] [string] [string] [string] , ) [EOL] [EOL] [EOL] def test_conflicting_literal_builtin_type ( ) : [EOL] assert_model_error ( [ Enumeration ( [string] , [ ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ] , Number ( [number] ) , False , ) , ] , [string] [string] , ) [EOL] [EOL] [EOL] def test_name_conflict_between_literal_and_type ( ) : [EOL] assert_model_error ( [ Enumeration ( [string] , [ ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) , ] , Number ( [number] ) , False , ) , ModularInteger ( [string] , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , ModularInteger ( [string] , Number ( [number] ) , Location ( ( [number] , [number] ) ) ) , ] , [string] [string] [string] [string] , ) [EOL] [EOL] [EOL] def test_invalid_enumeration_type_builtin_literals ( ) : [EOL] assert_model_error ( [ Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) , ) , ] , [string] [string] [string] , ) [EOL] [EOL] [EOL] def test_invalid_enumeration_type_identical_literals ( ) : [EOL] assert_model_error ( [ Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( ID ( [string] , Location ( ( [number] , [number] ) ) ) , Number ( [number] ) ) ] , Number ( [number] ) , False , ) , Enumeration ( [string] , [ ( [string] , Number ( [number] ) ) , ( [string] , Number ( [number] ) ) ] , Number ( [number] ) , False , Location ( ( [number] , [number] ) ) , ) , ] , [string] [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import rflx [EOL] import math [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] from hypothesis import HealthCheck , given , settings [EOL] [EOL] from rflx . model import Model [EOL] from tests import utils [EOL] from tests . property import strategies [EOL] [EOL] [EOL] @ given ( strategies . models ( ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . too_slow ] , max_examples = math . ceil ( settings . default . max_examples / [number] ) , ) def test_code_compilation ( tmp_path_factory , model ) : [EOL] utils . assert_compilable_code ( model , tmp_path_factory . mktemp ( [string] ) ) [EOL] [EOL] [EOL] @ pytest . mark . verification @ given ( strategies . models ( ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . too_slow ] , max_examples = math . ceil ( settings . default . max_examples / [number] ) , ) def test_code_verification ( tmp_path_factory , model ) : [EOL] utils . assert_provable_code ( model , tmp_path_factory . mktemp ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import rflx [EOL] import math [EOL] [EOL] from hypothesis import HealthCheck , given , settings , strategies as st [EOL] [EOL] import rflx . expression as expr [EOL] from rflx . model import Model [EOL] from rflx . parser import Parser , grammar [EOL] from tests . property import strategies [EOL] [EOL] [EOL] @ given ( strategies . mathematical_expressions ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . filter_too_much , HealthCheck . too_slow ] ) def test_parsing_mathematical_expressions ( expression ) : [EOL] parsed_expression = grammar . mathematical_expression ( ) . parseString ( str ( expression ) , parseAll = True ) [ [number] ] [EOL] assert parsed_expression == expression [EOL] [EOL] [EOL] @ given ( strategies . boolean_expressions ( st . one_of ( strategies . aggregates ( strategies . numbers ( ) ) | strategies . strings ( ) | strategies . mathematical_expressions ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) ) ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . filter_too_much , HealthCheck . too_slow ] ) def test_parsing_boolean_expressions ( expression ) : [EOL] parsed_expression = grammar . boolean_expression ( ) . parseString ( str ( expression ) , parseAll = True ) [ [number] ] [EOL] assert parsed_expression == expression [EOL] [EOL] [EOL] @ given ( st . one_of ( strategies . mathematical_expressions ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) , strategies . boolean_expressions ( st . one_of ( strategies . aggregates ( strategies . numbers ( ) ) | strategies . strings ( ) | strategies . mathematical_expressions ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) ) ) , strategies . calls ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) , strategies . quantified_expressions ( st . one_of ( strategies . numbers ( ) | strategies . variables ( strategies . identifiers ( ) ) | strategies . attributes ( strategies . identifiers ( ) ) ) ) , ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . filter_too_much , HealthCheck . too_slow ] ) def test_parsing_expressions ( expression ) : [EOL] parsed_expression = grammar . expression ( ) . parseString ( str ( expression ) , parseAll = True ) [ [number] ] [EOL] assert parsed_expression == expression [EOL] [EOL] [EOL] @ given ( strategies . models ( ) ) @ settings ( deadline = None , suppress_health_check = [ HealthCheck . too_slow ] , max_examples = math . ceil ( settings . default . max_examples / [number] ) , ) def test_parsing_model ( model ) : [EOL] parser = Parser ( ) [EOL] parser . parse_string ( f""" [string] { model } [string] """ ) [EOL] parsed_model = parser . create_model ( ) [EOL] assert parsed_model . types == model . types [EOL] assert parsed_model == model [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import examples [EOL] import socket [EOL] import typing [EOL] import rflx [EOL] import socket [EOL] import sys [EOL] [EOL] from rflx . pyrflx import MessageValue , PyRFLX [EOL] [EOL] [EOL] class ICMPSocket : [EOL] def __init__ ( self ) : [EOL] pyrflx = PyRFLX ( [ [string] ] ) [EOL] self . package_icmp = pyrflx [ [string] ] [EOL] self . icmp_data = ( [string] [string] [string] ) [EOL] [EOL] def send_icmp_request ( self ) : [EOL] icmp_request = self . __create_msg ( ) [EOL] try : [EOL] icmp_socket = socket . socket ( family = socket . AF_INET , type = socket . SOCK_DGRAM , proto = socket . IPPROTO_ICMP ) [EOL] except OSError as e : [EOL] sys . exit ( f" [string] { e }" ) [EOL] try : [EOL] icmp_socket . sendto ( icmp_request . bytestring , ( [string] , [number] ) ) [EOL] except InterruptedError as e : [EOL] icmp_socket . close ( ) [EOL] sys . exit ( f" [string] { e }" ) [EOL] echo = icmp_socket . recv ( [number] ) [EOL] print ( f" [string] { icmp_request . bytestring . hex ( ) }" ) [EOL] print ( f" [string] { echo . hex ( ) }" ) [EOL] if echo [ [number] : ] == self . icmp_data : [EOL] print ( [string] ) [EOL] [EOL] def __create_msg ( self ) : [EOL] icmp = self . package_icmp [ [string] ] [EOL] icmp . set ( [string] , [string] ) [EOL] icmp . set ( [string] , [number] ) [EOL] icmp . set ( [string] , [number] ) [EOL] icmp . set ( [string] , [number] ) [EOL] icmp . set ( [string] , [number] ) [EOL] icmp . set ( [string] , self . icmp_data ) [EOL] return icmp [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] SOCKET = ICMPSocket ( ) [EOL] SOCKET . send_icmp_request ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $rflx.pyrflx.MessageValue$ 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 $rflx.pyrflx.MessageValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.MessageValue$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.MessageValue$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $examples.icmp_socket.ICMPSocket$ 0 0 0 0 0 $examples.icmp_socket.ICMPSocket$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Sequence , Union , Any , List [EOL] import socket [EOL] import typing [EOL] import rflx [EOL] import builtins [EOL] import ipaddress [EOL] import socket [EOL] import sys [EOL] import time [EOL] [EOL] from rflx . pyrflx import MessageValue , PyRFLX [EOL] [EOL] PYRFLX = PyRFLX ( [ [string] ] , True ) [EOL] ICMP = PYRFLX [ [string] ] [EOL] IP = PYRFLX [ [string] ] [EOL] [EOL] ICMP_DATA = bytes ( list ( range ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] def ping ( target ) : [EOL] target_ip = socket . gethostbyname ( target ) [EOL] [EOL] print ( f" [string] { target } [string] { target_ip } [string] " ) [EOL] [EOL] sock_out = socket . socket ( socket . AF_INET , socket . SOCK_RAW , socket . IPPROTO_RAW ) [EOL] sock_in = socket . socket ( socket . AF_INET , socket . SOCK_RAW , socket . IPPROTO_ICMP ) [EOL] [EOL] seq = [number] [EOL] while True : [EOL] sock_out . sendto ( create_request ( [number] , int ( ipaddress . IPv4Address ( target_ip ) ) , seq ) , ( target , [number] ) , ) [EOL] [EOL] packet = parse_reply ( sock_in . recv ( [number] ) ) [EOL] packet_src = str ( ipaddress . IPv4Address ( packet . get ( [string] ) ) ) [EOL] if packet_src != target_ip : [EOL] continue [EOL] [EOL] reply = packet . get ( [string] ) [EOL] assert isinstance ( reply , MessageValue ) [EOL] [EOL] reply_seq = str ( reply . get ( [string] ) ) [EOL] print ( f"{ int ( reply . size ) // [number] } [string] { packet_src } [string] { reply_seq }" , flush = True ) [EOL] [EOL] if reply . get ( [string] ) != [string] : [EOL] print ( [string] ) [EOL] if reply . get ( [string] ) != ICMP_DATA : [EOL] print ( [string] ) [EOL] [EOL] time . sleep ( [number] ) [EOL] seq = ( seq + [number] ) % [number] ** [number] [EOL] [EOL] [EOL] def create_request ( src , dst , seq ) : [EOL] msg = ICMP [ [string] ] [EOL] msg . set ( [string] , [string] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , [number] ) [EOL] msg . set ( [string] , seq ) [EOL] msg . set ( [string] , ICMP_DATA ) [EOL] msg . set ( [string] , icmp_checksum ( msg . bytestring ) ) [EOL] [EOL] pkt = IP [ [string] ] [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] + len ( msg . bytestring ) ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , [string] ) [EOL] pkt . set ( [string] , [number] ) [EOL] pkt . set ( [string] , src ) [EOL] pkt . set ( [string] , dst ) [EOL] pkt . set ( [string] , [ ] ) [EOL] pkt . set ( [string] , msg . bytestring ) [EOL] [EOL] return pkt . bytestring [EOL] [EOL] [EOL] def parse_reply ( message ) : [EOL] pkt = IP [ [string] ] [EOL] pkt . parse ( message ) [EOL] return pkt [EOL] [EOL] [EOL] def icmp_checksum ( message ) : [EOL] def add_ones_complement ( num1 , num2 ) : [EOL] mod = [number] << [number] [EOL] result = num1 + num2 [EOL] return result if result < mod else ( result + [number] ) % mod [EOL] [EOL] chunks = [ int . from_bytes ( message [ i : i + [number] ] , [string] ) for i in range ( [number] , len ( message ) , [number] ) ] [EOL] intermediary_result = chunks [ [number] ] [EOL] for i in range ( [number] , len ( chunks ) ) : [EOL] intermediary_result = add_ones_complement ( intermediary_result , chunks [ i ] ) [EOL] [EOL] return intermediary_result ^ [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] sys . exit ( [string] ) [EOL] ping ( sys . argv [ [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.package.Package$ 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 $rflx.pyrflx.package.Package$ 0 $rflx.pyrflx.pyrflx.PyRFLX$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.package.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.package.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $rflx.pyrflx.MessageValue$ 0 0 0 0 0 0 0 $rflx.pyrflx.package.Package$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] import re [EOL] [EOL] import GPS [EOL] import highlighter . common as hl [EOL] from gi . repository import Gdk , Gtk [EOL] [EOL] try : [EOL] from gs_utils import hook [EOL] except ImportError : [EOL] from gps_utils import hook [EOL] [EOL] XML = [string] [EOL] [EOL] GPS . parse_xml ( XML ) [EOL] [EOL] [comment] [EOL] recordflux_keywords = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] recordflux_literals = [ [string] , [string] , ] [EOL] [EOL] tag_aspect = hl . existing_style ( [string] , [string] ) [EOL] [EOL] hl_type = hl . simple ( [string] , tag = hl . tag_type ) [EOL] type_region = hl . region ( [string] , [string] , highlighter = ( hl_type , ) , tag = hl . tag_default ) [EOL] string_literal = hl . region ( [string] , [string] , matchall = False , tag = hl . tag_string ) [EOL] [EOL] hl . register_highlighter ( language = [string] , spec = ( hl . simple ( [string] , tag = hl . tag_comment ) , type_region , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . simple ( [string] , tag = tag_aspect ) , hl . words ( recordflux_keywords , tag = hl . tag_keyword ) , hl . words ( recordflux_literals , tag = hl . tag_keyword ) , hl . simple ( [string] , tag = hl . tag_number ) , hl . simple ( [string] , tag = hl . tag_number ) , hl . words ( ( [string] ) , tag = tag_aspect ) , string_literal , ) , ) [EOL] [EOL] [EOL] @ hook ( [string] ) def __on_gps_started ( ) : [EOL] GPS . FileTemplate . register ( alias_name = [string] , label = [string] , unit_param = [string] , language = [string] , is_impl = False , ) [EOL] [EOL] [EOL] message_re = re . compile ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] generic_message_re = re . compile ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [EOL] def to_importance ( severity ) : [EOL] if severity == [string] : [EOL] return GPS . Message . Importance . HIGH [EOL] if severity == [string] : [EOL] return GPS . Message . Importance . MEDIUM [EOL] if severity == [string] : [EOL] return GPS . Message . Importance . INFORMATIONAL [EOL] [EOL] [EOL] def parse_output ( output ) : [EOL] for m in GPS . Message . list ( ) : [EOL] m . remove ( ) [EOL] message = None [EOL] for l in output . splitlines ( ) : [EOL] result = message_re . match ( l ) [EOL] if result : [EOL] data = result . groupdict ( ) [EOL] if data [ [string] ] != [string] : [EOL] message = GPS . Message ( category = [string] , file = GPS . File ( data [ [string] ] ) , line = int ( data [ [string] ] ) , column = int ( data [ [string] ] ) , text = [string] . format ( ** data ) , importance = to_importance ( data [ [string] ] ) , ) [EOL] elif message : [EOL] data [ [string] ] = os . path . basename ( data [ [string] ] ) [EOL] message . create_nested_message ( file = GPS . File ( data [ [string] ] ) , line = int ( data [ [string] ] ) , column = int ( data [ [string] ] ) , text = [string] . format ( ** data ) , ) [EOL] continue [EOL] [EOL] result = generic_message_re . match ( l ) [EOL] if result : [EOL] data = result . groupdict ( ) [EOL] message = GPS . Message ( category = [string] , file = GPS . File ( data [ [string] ] ) , line = [number] , column = [number] , text = [string] . format ( ** data ) , importance = to_importance ( data [ [string] ] ) , ) [EOL] [EOL] [EOL] def get_source_files ( ) : [EOL] files = ( GPS . current_context ( ) . project ( ) . sources ( ) [EOL] if GPS . current_context ( ) . project ( ) [EOL] else GPS . current_context ( ) . files ( ) ) [EOL] [EOL] if files : [EOL] return [ s . name ( ) for s in files if s . language ( ) == [string] ] [EOL] [EOL] raise GPS . Exception ( [string] ) [EOL] [EOL] [EOL] def run ( files , mode , options = None ) : [EOL] assert mode == [string] or mode == [string] or mode == [string] [EOL] options = options or [ ] [EOL] [EOL] GPS . MDI . save_all ( force = True ) [EOL] GPS . Locations . remove_category ( [string] ) [EOL] [EOL] return [string] . format ( mode = mode , files = [string] . join ( files ) , options = [string] . join ( options ) ) [EOL] [EOL] [EOL] def check_all ( filenames = None ) : [EOL] filenames = filenames or get_source_files ( ) [EOL] return run ( filenames , mode = [string] ) [EOL] [EOL] [EOL] def check ( filename ) : [EOL] return check_all ( [ filename ] ) [EOL] [EOL] [EOL] def output_dir ( ) : [EOL] output_dir = GPS . Project . root ( ) . get_attribute_as_string ( [string] , [string] ) [EOL] assert output_dir , [string] [EOL] create_missing = GPS . Project . root ( ) . get_attribute_as_string ( [string] ) [EOL] if create_missing and create_missing . lower ( ) == [string] : [EOL] if os . path . exists ( output_dir ) : [EOL] assert os . path . isdir ( output_dir ) [EOL] else : [EOL] os . makedirs ( output_dir ) [EOL] return output_dir [EOL] [EOL] [EOL] def generate_all ( filenames = None ) : [EOL] filenames = filenames or get_source_files ( ) [EOL] return run ( filenames , mode = [string] , options = [ [string] , output_dir ( ) ] ) [EOL] [EOL] [EOL] def generate ( filename ) : [EOL] return generate_all ( [ filename ] ) [EOL] [EOL] [EOL] def graph ( filename , unverified = False ) : [EOL] options = [ [string] , output_dir ( ) ] [EOL] if unverified : [EOL] options . append ( [string] ) [EOL] return run ( [ filename ] , mode = [string] , options = options ) [EOL] [EOL] [EOL] def get_message_name ( locations , name , line , column ) : [EOL] for message , pos in locations [ name ] . items ( ) : [EOL] if line > pos [ [string] ] [ [string] ] and line < pos [ [string] ] [ [string] ] : [EOL] return message [EOL] if line == pos [ [string] ] [ [string] ] and column >= pos [ [string] ] [ [string] ] : [EOL] return message [EOL] if line == pos [ [string] ] [ [string] ] and column <= pos [ [string] ] [ [string] ] : [EOL] return message [EOL] return None [EOL] [EOL] [EOL] def display_message_graph ( filename ) : [EOL] with open ( output_dir ( ) + [string] , [string] ) as f : [EOL] locations = json . load ( f ) [EOL] loc = GPS . EditorBuffer . get ( ) . current_view ( ) . cursor ( ) [EOL] column = loc . column ( ) [EOL] line = loc . line ( ) [EOL] name = GPS . File ( filename ) . base_name ( ) [EOL] message_name = get_message_name ( locations , name , line , column ) [EOL] if not message_name : [EOL] GPS . MDI . dialog ( [string] . format ( name = name , line = line , column = column ) , [string] , ) [EOL] return [EOL] [EOL] scrolled_window = Gtk . ScrolledWindow ( ) [EOL] scrolled_window . set_border_width ( [number] ) [EOL] scrolled_window . set_policy ( Gtk . PolicyType . ALWAYS , Gtk . PolicyType . ALWAYS ) [EOL] scrolled_window . override_background_color ( Gtk . StateType . NORMAL , Gdk . RGBA ( ) ) [EOL] graph = Gtk . Image ( ) [EOL] graph . set_from_file ( output_dir ( ) + [string] + message_name + [string] ) [EOL] scrolled_window . add_with_viewport ( graph ) [EOL] GPS . MDI . add ( scrolled_window , [string] , message_name , group = GPS . MDI . GROUP_GRAPHS , position = GPS . MDI . POSITION_AUTOMATIC , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0