from invoke import task [EOL] [EOL] [EOL] @ task def test ( ctx ) : [EOL] ctx . run ( [string] ) [EOL] ctx . run ( [string] ) [EOL] ctx . run ( [string] ) [EOL] ctx . run ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] from pathlib import Path [EOL] from typing import Dict [EOL] [EOL] from setuptools import setup , find_packages [EOL] [EOL] root_path = Path ( __file__ ) . absolute ( ) . parent [EOL] [EOL] [EOL] def _get_long_description ( ) : [EOL] readme_path = root_path / [string] [EOL] return readme_path . read_text ( ) [EOL] [EOL] [EOL] def get_project_info ( ) : [EOL] proj_info = { } [EOL] proj_info_path = root_path / [string] / [string] [EOL] exec ( proj_info_path . read_text ( ) , proj_info ) [EOL] return proj_info [EOL] [EOL] [EOL] project_info = get_project_info ( ) [EOL] [EOL] [EOL] setup ( name = [string] , version = project_info [ [string] ] , description = [string] , long_description = _get_long_description ( ) , long_description_content_type = [string] , python_requires = [string] , author = project_info [ [string] ] , author_email = project_info [ [string] ] , url = [string] , packages = find_packages ( exclude = [ [string] , [string] ] ) , install_requires = [ [string] , [string] ] , classifiers = [ [string] , [string] , [string] , [string] , ] , keywords = [string] , project_urls = { [string] : [string] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from fireclass . document import ( Document , initialize_with_firestore_client , FirestoreClientNotConfigured , DocumentNotFound , DocumentNotCreatedInDatabase , DocumentAlreadyCreatedInDatabase , FirestoreOperator , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__version__ = [string] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Any , Type , Iterator , TypeVar , Optional [EOL] import google [EOL] import dataclasses [EOL] import builtins [EOL] import typing [EOL] from abc import ABC [EOL] import dataclasses [EOL] from typing import TypeVar , Type , Any , Optional , Iterator , Union [EOL] [EOL] from google . cloud import firestore , firestore_v1 [EOL] from google . cloud . firestore_v1 . proto . write_pb2 import WriteResult [EOL] from google . protobuf . timestamp_pb2 import Timestamp [EOL] from typing_extensions import Literal [EOL] [EOL] from fireclass . values_conversion import convert_value_to_firestore , convert_value_from_firestore [EOL] [EOL] _firestore_client = None [EOL] [EOL] [EOL] def initialize_with_firestore_client ( db ) : [EOL] global _firestore_client [EOL] _firestore_client = db [EOL] [EOL] [EOL] def _discard_firestore_client ( ) : [EOL] [docstring] [EOL] global _firestore_client [EOL] _firestore_client = None [EOL] [EOL] [EOL] class FirestoreClientNotConfigured ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def _get_firestore_client ( ) : [EOL] if _firestore_client is None : [EOL] raise FirestoreClientNotConfigured ( f" [string] " f" [string] { initialize_with_firestore_client . __name__ } [string] " ) [EOL] return _firestore_client [EOL] [EOL] [EOL] class DocumentNotFound ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class DocumentNotCreatedInDatabase ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class DocumentAlreadyCreatedInDatabase ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] FirestoreOperator = Literal [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] _DocumentSubclassTypeVar = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] class _DocumentQuery : [EOL] def __init__ ( self , document_cls , firestore_query ) : [EOL] self . _document_cls = document_cls [EOL] self . _firestore_query = firestore_query [EOL] [EOL] def limit ( self , count ) : [EOL] new_query = self . _firestore_query . limit ( count ) [EOL] return _DocumentQuery ( self . _document_cls , new_query ) [EOL] [EOL] def stream ( self , transaction = None ) : [EOL] for firestore_document in self . _firestore_query . stream ( transaction ) : [EOL] yield self . _document_cls . _from_firestore_document ( firestore_document ) [EOL] [EOL] def where ( self , field_path , op_string , value ) : [EOL] [comment] [EOL] [comment] [EOL] final_value = _validate_and_convert_value_to_firestore ( self . _document_cls , field_path , value ) [EOL] return _DocumentQuery ( self . _document_cls , self . _firestore_query . where ( field_path , op_string , final_value ) ) [EOL] [EOL] [EOL] @ dataclasses . dataclass class Document ( ABC ) : [EOL] def __post_init__ ( self ) : [EOL] self . _id = None [comment] [EOL] [EOL] @ property def id ( self ) : [EOL] return self . _id [EOL] [EOL] def create ( self , document_id = None ) : [EOL] if self . id is not None : [EOL] raise DocumentAlreadyCreatedInDatabase ( ) [EOL] document_ref = self . _collection ( ) . document ( document_id ) [EOL] encoded_dict = convert_value_to_firestore ( dataclasses . asdict ( self ) ) [EOL] write_result = document_ref . create ( encoded_dict ) [EOL] self . _id = document_ref . id [EOL] return write_result [EOL] [EOL] def update ( self ) : [EOL] if self . id is None : [EOL] raise DocumentNotCreatedInDatabase ( ) [EOL] document_ref = self . _collection ( ) . document ( self . id ) [EOL] encoded_dict = convert_value_to_firestore ( dataclasses . asdict ( self ) ) [EOL] write_result = document_ref . update ( encoded_dict ) [EOL] self . _id = document_ref . id [EOL] return write_result [EOL] [EOL] def delete ( self ) : [EOL] if self . id is None : [EOL] raise DocumentNotCreatedInDatabase ( ) [EOL] return self . delete_document ( self . id ) [EOL] [EOL] @ classmethod def _find_field ( cls , field_name ) : [EOL] corresponding_field = None [EOL] for defined_field in dataclasses . fields ( cls ) : [EOL] if defined_field . name == field_name : [EOL] corresponding_field = defined_field [EOL] [EOL] if not corresponding_field : [EOL] raise TypeError ( f" [string] { field_name } [string] { cls . __name__ } [string] " ) [EOL] [EOL] return corresponding_field [EOL] [EOL] @ classmethod def _from_firestore_document ( cls , firestore_document ) : [EOL] [docstring] [EOL] decoded_dict = { } [EOL] for field_name , value in firestore_document . to_dict ( ) . items ( ) : [EOL] field_description = cls . _find_field ( field_name ) [EOL] decoded_dict [ field_name ] = convert_value_from_firestore ( value , field_description ) [EOL] [EOL] document = cls ( ** decoded_dict ) [comment] [EOL] document . _id = firestore_document . id [EOL] return document [EOL] [EOL] @ classmethod def _collection ( cls ) : [EOL] return _get_firestore_client ( ) . collection ( cls . __name__ ) [EOL] [EOL] @ classmethod def get_document ( cls , document_id ) : [EOL] firestore_document = cls . _collection ( ) . document ( document_id ) . get ( ) [EOL] if not firestore_document or not firestore_document . exists : [EOL] raise DocumentNotFound ( ) [EOL] return cls . _from_firestore_document ( firestore_document ) [EOL] [EOL] @ classmethod def delete_document ( cls , document_id ) : [EOL] return cls . _collection ( ) . document ( document_id ) . delete ( ) [EOL] [EOL] @ classmethod def stream ( cls ) : [EOL] for firestore_document in cls . _collection ( ) . stream ( ) : [EOL] yield cls . _from_firestore_document ( firestore_document ) [EOL] [EOL] @ classmethod def where ( cls , field_path , op_string , value ) : [EOL] final_value = _validate_and_convert_value_to_firestore ( cls , field_path , value ) [EOL] return _DocumentQuery ( cls , cls . _collection ( ) . where ( field_path , op_string , final_value ) ) [EOL] [EOL] [EOL] def _validate_and_convert_value_to_firestore ( document_cls , field_path , value ) : [EOL] [comment] [EOL] [comment] [EOL] corresponding_field = document_cls . _find_field ( field_path ) [EOL] [EOL] [comment] [EOL] should_raise_type_error = False [EOL] if hasattr ( corresponding_field . type , [string] ) and corresponding_field . type . __origin__ == Union : [EOL] [comment] [EOL] if corresponding_field . type . __args__ [ [number] ] != type ( None ) : [comment] [EOL] [comment] [EOL] raise TypeError ( f" [string] { corresponding_field . name } [string] { corresponding_field . type }" ) [EOL] [EOL] if corresponding_field . type . __args__ [ [number] ] != type ( value ) and value is not None : [EOL] [comment] [EOL] should_raise_type_error = True [EOL] [EOL] elif corresponding_field . type != type ( value ) : [EOL] should_raise_type_error = True [EOL] [EOL] if should_raise_type_error : [EOL] raise TypeError ( f" [string] { value } [string] { type ( value ) } [string] " f" [string] { corresponding_field . name } [string] { corresponding_field . type } [string] " ) [EOL] [EOL] [comment] [EOL] final_value = convert_value_to_firestore ( value ) [EOL] return final_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $google.cloud.firestore.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $google.cloud.firestore._v1.Query$ 0 0 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 $google.cloud.firestore._v1.Query$ 0 0 0 $"_DocumentQuery"$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Iterator[_DocumentSubclassTypeVar]$ 0 0 0 $typing.Optional[google.cloud.firestore._v1.Transaction]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[google.cloud.firestore._v1.Transaction]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"_DocumentQuery"$ 0 0 0 $builtins.str$ 0 $FirestoreOperator$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $FirestoreOperator$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $google.cloud.firestore_v1.proto.write_pb2.WriteResult$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $google.cloud.firestore_v1.proto.write_pb2.WriteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $google.protobuf.timestamp_pb2.Timestamp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dataclasses.Field$ 0 0 0 $builtins.str$ 0 0 0 $dataclasses.Field[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $dataclasses.Field[typing.Any]$ 0 0 0 0 0 0 $dataclasses.Field[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $dataclasses.Field[typing.Any]$ 0 0 0 0 0 $_DocumentSubclassTypeVar$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $google.cloud.firestore._v1.DocumentSnapshot$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $google.cloud.firestore._v1.DocumentSnapshot$ 0 0 0 0 0 0 0 0 0 0 $dataclasses.Field[typing.Any]$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $dataclasses.Field[typing.Any]$ 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $google.cloud.firestore._v1.DocumentSnapshot$ 0 0 0 0 0 0 0 0 0 0 $google.cloud.firestore._v1.CollectionReference$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 0 $_DocumentSubclassTypeVar$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $google.protobuf.timestamp_pb2.Timestamp$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $builtins.str$ 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[_DocumentSubclassTypeVar]$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 0 0 0 $_DocumentQuery$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $builtins.str$ 0 $FirestoreOperator$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 $typing.Type[_DocumentSubclassTypeVar]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $FirestoreOperator$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Dict , Union [EOL] import dataclasses [EOL] import enum [EOL] import builtins [EOL] import typing [EOL] import dataclasses [EOL] from enum import Enum [EOL] from functools import singledispatch [EOL] from typing import Union , Any , Optional [EOL] [EOL] [EOL] @ singledispatch def convert_value_from_firestore ( field_value , field_description ) : [EOL] [docstring] [EOL] return field_value [EOL] [EOL] [EOL] @ convert_value_from_firestore . register def _bool ( field_value , field_description ) : [EOL] if field_description . type in [ bool , Optional [ bool ] ] : [EOL] return field_value [EOL] else : [EOL] raise TypeError ( f" [string] { field_value } [string] { field_description . name } [string] " ) [EOL] [EOL] [EOL] @ convert_value_from_firestore . register def _str_to_enum ( field_value , field_description ) : [EOL] [docstring] [EOL] if field_description . type == str : [EOL] return field_value [EOL] elif field_description . type == Optional [ str ] : [EOL] [comment] [EOL] return field_value [EOL] elif issubclass ( field_description . type , Enum ) : [EOL] enum_sub_cls = field_description . type [EOL] return enum_sub_cls ( field_value ) [EOL] else : [EOL] raise TypeError ( f" [string] { field_value } [string] { field_description . name } [string] " ) [EOL] [EOL] [EOL] @ convert_value_from_firestore . register def _int_to_enum ( field_value , field_description ) : [EOL] [docstring] [EOL] enum_cls = None [EOL] [EOL] if field_description . type == int : [EOL] return field_value [EOL] elif hasattr ( field_description . type , [string] ) and field_description . type . __origin__ == Union : [EOL] [comment] [EOL] if field_description . type . __args__ == Optional [ int ] . __args__ : [comment] [EOL] [comment] [EOL] return field_value [EOL] elif issubclass ( field_description . type . __args__ [ [number] ] , Enum ) : [EOL] [comment] [EOL] enum_cls = field_description . type . __args__ [ [number] ] [EOL] [EOL] elif issubclass ( field_description . type , Enum ) : [EOL] [comment] [EOL] enum_cls = field_description . type [EOL] [EOL] if enum_cls : [EOL] [comment] [EOL] return enum_cls ( field_value ) [EOL] [EOL] raise TypeError ( f" [string] { field_value } [string] { field_description . name } [string] " ) [EOL] [EOL] [EOL] @ singledispatch def convert_value_to_firestore ( field_value ) : [EOL] [docstring] [EOL] return field_value [EOL] [EOL] [EOL] @ convert_value_to_firestore . register def _dict_to ( field_value ) : [EOL] encoded_value = { } [EOL] for key , value in field_value . items ( ) : [EOL] encoded_value [ key ] = convert_value_to_firestore ( value ) [EOL] return encoded_value [EOL] [EOL] [EOL] @ convert_value_to_firestore . register def _list_to ( field_value ) : [EOL] return [ convert_value_to_firestore ( value ) for value in field_value ] [EOL] [EOL] [EOL] @ convert_value_to_firestore . register def _enum_to ( field_value ) : [EOL] return field_value . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,enum.Enum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,enum.Enum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0