import requests [EOL] import os , requests , logging [EOL] [EOL] hostname = os . environ [ [string] ] [EOL] response = requests . get ( hostname ) [EOL] status = response . status_code [EOL] [EOL] if status == [number] : [EOL] logging . info ( [string] ) [EOL] else : [EOL] logging . warning ( [string] + str ( status ) ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 $requests.models.Response$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
from typing import List [EOL] import typing [EOL] import crypto [EOL] import builtins [EOL] import json [EOL] import pickle [EOL] from bot . redis import redis [EOL] import unicodedata [EOL] from datetime import datetime [EOL] from crypto . CryptoTrader import User [EOL] from typing import Dict , List [EOL] [EOL] def get_users ( prefix ) : [EOL] return [ User . from_json ( redis . get ( account ) ) for account in redis . keys ( [string] . format ( prefix ) ) ] [EOL] [EOL] def get_ifs ( prefix ) : [EOL] for user in get_users ( prefix ) : [EOL] print ( user . ifs ) [EOL] [EOL] get_ifs ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Iterator , Any [EOL] import typing [EOL] import redis [EOL] import bot [EOL] import builtins [EOL] from dataclasses import dataclass [EOL] from typing import Callable , Dict , List , Optional [EOL] from redis import from_url , StrictRedis [EOL] from . config import SLACK_TOKEN [EOL] from . users import getUser [EOL] import time [EOL] from slackclient import SlackClient [EOL] [EOL] [EOL] @ dataclass class Bot : [EOL] name = ... [EOL] icon_emoji = ... [EOL] [EOL] [EOL] class SlackBot ( SlackClient ) : [EOL] [EOL] def __init__ ( self , token , bot , db ) : [EOL] super ( ) . __init__ ( token ) [EOL] if ( not self . rtm_connect ( ) ) : [EOL] raise IOError ( [string] ) [EOL] self . bot = bot [EOL] self . db = db [EOL] self . _triggers = { } [EOL] [EOL] def postMessage ( self , channel , message , thread ) : [EOL] self . api_call ( [string] , channel = channel , text = message , thread_ts = thread , username = self . bot . name , icon_emoji = self . bot . icon_emoji ) [EOL] [EOL] def register ( self , trigger , callback , condition ) : [EOL] [comment] [EOL] maybeCallback = _MaybeCallback ( callback , condition ) [EOL] self . _triggers . setdefault ( trigger , [ maybeCallback ] ) [EOL] [EOL] def notify ( self , command ) : [EOL] [comment] [EOL] for mc in ( self . _triggers . get ( command . trigger , [ ] ) ) : [EOL] if mc . condition ( command . event ) : [EOL] mc . callback ( command ) [EOL] [EOL] def listen ( self ) : [EOL] [comment] [EOL] while True : [EOL] try : [EOL] events = filter ( lambda e : e . get ( [string] ) == [string] and [string] in e , self . rtm_read ( ) ) [EOL] for event in events : [EOL] command = self . _messageEventToCommand ( event ) [EOL] if command : [EOL] self . notify ( command ) [comment] [EOL] time . sleep ( [number] ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] print ( [string] ) [EOL] self . rtm_connect ( ) [EOL] [EOL] def _messageEventToCommand ( self , event ) : [EOL] for trigger in self . _triggers . keys ( ) : [EOL] if event [ [string] ] . lower ( ) . startswith ( trigger . lower ( ) ) : [EOL] args = event [ [string] ] [ len ( trigger ) : ] . strip ( ) . lower ( ) . split ( ) [EOL] return Command ( trigger , args , Event ( event . get ( [string] ) , event . get ( [string] ) , event . get ( [string] ) , event . get ( [string] ) , event . get ( [string] ) , event . get ( [string] ) , event . get ( [string] ) ) ) [EOL] [EOL] return None [EOL] [EOL] [EOL] @ dataclass class Event : [EOL] type = ... [EOL] subtype = ... [EOL] channel = ... [EOL] user_id = ... [EOL] text = ... [EOL] ts = ... [EOL] thread = ... [EOL] [EOL] [EOL] @ dataclass class Command : [EOL] trigger = ... [EOL] args = ... [EOL] event = ... [EOL] [EOL] @ property def user_name ( self ) : [EOL] return getUser ( self . event . user_id ) [ [string] ] [EOL] [EOL] @ property def channel ( self ) : [EOL] return self . event . channel [EOL] [EOL] @ property def thread ( self ) : [EOL] return self . event . thread [EOL] [EOL] def log ( self ) : [EOL] print ( [string] . format ( trigger = self . trigger , args = self . args , event = self . event ) ) [EOL] [EOL] [EOL] def threaded ( event ) : [EOL] return allMessageEvents ( event ) and event . thread is not None [EOL] [EOL] [EOL] def messageEvents ( event ) : [EOL] return allMessageEvents ( event ) and event . thread is None [EOL] [EOL] [EOL] def allMessageEvents ( event ) : [EOL] return ( event . type == [string] and event . subtype is None and event . text is not None ) [EOL] [EOL] [EOL] class _MaybeCallback ( object ) : [EOL] def __init__ ( self , callback , condition ) : [EOL] self . callback = callback [EOL] self . condition = condition [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Bot$ 0 $redis.client.Redis[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Bot$ 0 $Bot$ 0 0 0 $redis.client.Redis[typing.Any]$ 0 $redis.client.Redis[typing.Any]$ 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $bot.Bot._MaybeCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $bot.Bot._MaybeCallback$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $Event$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] from . config import SLACK_TOKEN [EOL] from slackclient import SlackClient [EOL] from typing import Dict [EOL] [EOL] slack = SlackClient ( SLACK_TOKEN ) [EOL] [EOL] _USER_CACHE = { } [EOL] [EOL] [EOL] def getUser ( user_id ) : [EOL] [comment] [EOL] [comment] [EOL] if not _USER_CACHE . get ( user_id ) : [EOL] _USER_CACHE [ user_id ] = slack . api_call ( [string] , user = user_id ) [ [string] ] [EOL] return _USER_CACHE [ user_id ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.object]$ 0 0 0 0
import builtins [EOL] from typing import Literal , Optional , Union [EOL] import typing_extensions [EOL] import typing [EOL] import os [EOL] [EOL] SLACK_TOKEN = os . getenv ( [string] ) [EOL] [EOL] REDIS_URL = os . getenv ( [string] ) [EOL] REDIS_HOST = os . getenv ( [string] , [string] ) [EOL] REDIS_PORT = int ( os . getenv ( [string] , [number] ) ) [EOL] REDIS_DB = int ( os . getenv ( [string] , [number] ) ) [EOL] REDIS_PASSWORD = os . getenv ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0
	0
import redis [EOL] from redis import from_url , StrictRedis [EOL] from . config import ( REDIS_HOST , REDIS_PORT , REDIS_DB , REDIS_PASSWORD , REDIS_URL ) [EOL] [EOL] redis = from_url ( REDIS_URL , db = REDIS_DB ) if REDIS_URL else ( StrictRedis ( host = REDIS_HOST , port = REDIS_PORT , db = REDIS_DB , password = REDIS_PASSWORD ) ) [EOL]	0 $redis.StrictRedis$ 0 0 $redis.StrictRedis$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $redis.StrictRedis$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import jinja2 [EOL] import typing [EOL] import pathlib [EOL] import builtins [EOL] import codecs [EOL] from jinja2 import ( Environment , PackageLoader , FileSystemLoader , select_autoescape ) [EOL] import os [EOL] import subprocess [EOL] import tempfile [EOL] from pathlib import Path [EOL] [EOL] MODULE_DIR = Path ( __file__ ) . parent . resolve ( ) [EOL] [EOL] WK_PATH = os . getenv ( [string] , str ( MODULE_DIR / [string] / [string] ) ) [EOL] [EOL] DFT_CACHE_DIR = Path ( tempfile . gettempdir ( ) ) / [string] [EOL] [EOL] env = Environment ( loader = FileSystemLoader ( str ( MODULE_DIR / [string] ) ) , autoescape = select_autoescape ( [ [string] ] ) ) [EOL] [EOL] [EOL] def getCryptoLeaderboardPng ( rows ) : [EOL] template = env . get_template ( [string] ) [EOL] html = template . render ( rows = rows ) [EOL] return generate_png ( html ) [EOL] [EOL] [EOL] def getCryptoTopPng ( rows ) : [EOL] template = env . get_template ( [string] ) [EOL] html = template . render ( rows = rows ) [EOL] return generate_png ( html ) [EOL] [EOL] [EOL] def execute_wk ( input ) : [EOL] [docstring] [EOL] return subprocess . run ( [string] . format ( path = WK_PATH ) , input = input , shell = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] [EOL] [EOL] def generate_png ( html ) : [EOL] p = execute_wk ( html . encode ( ) ) [EOL] png_content = p . stdout [EOL] if p . returncode != [number] : [EOL] print ( p . stderr ) [EOL] raise RuntimeError ( [string] ) [EOL] return png_content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
import builtins [EOL] from typing import List , Any , Match , Dict , Optional , Type [EOL] import arbitrage [EOL] import typing [EOL] import bot [EOL] import redis [EOL] from bot . Bot import Bot , Command , SlackBot [EOL] from redis import StrictRedis [EOL] from requests import get [EOL] from collections import namedtuple [EOL] from datetime import datetime [EOL] from pytz import timezone , utc [EOL] import time [EOL] import re [EOL] import os [EOL] [EOL] class ArbitrageBot ( SlackBot ) : [EOL] BOT_REFRESH_TIME = [number] * [number] [comment] [EOL] HAX_TIME = [number] * [number] * [number] [comment] [EOL] HAX_BUFFER = [number] [comment] [EOL] HAX_CASH = [number] [comment] [EOL] BOT_NAME = [string] [EOL] BOT_CHANNEL = [string] [comment] [EOL] [EOL] def __init__ ( self , token , bot , db ) : [EOL] super ( ) . __init__ ( token , bot , db ) [EOL] self . hax_cash = ArbitrageBot . HAX_CASH [EOL] self . coinList = list ( _pollCmc ( ) ) [EOL] [EOL] def onPredict ( self , cmd ) : [EOL] [comment] [EOL] args , channel , thread = cmd . args , cmd . channel , cmd . thread [EOL] if cmd . user_name . lower ( ) != [string] : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] print ( [string] ) [EOL] return [EOL] self . haxUntil = time . time ( ) + ArbitrageBot . HAX_TIME [EOL] print ( [string] . format ( _get_time_str ( self . haxUntil ) ) ) [EOL] [comment] [EOL] [comment] [EOL] self . botPriceHash , self . nextBotUpdateTime = self . _pollCryptoBot ( channel , thread , self . coinList ) [EOL] if args [ [number] ] is not None : [EOL] try : [EOL] self . hax_cash = float ( args [ [number] ] ) [EOL] except : [EOL] print ( [string] . format ( ArbitrageBot . HAX_CASH ) ) [EOL] self . _doHax ( channel , thread ) [EOL] [EOL] def _doHax ( self , channel , thread ) : [EOL] totalGainz = [number] [EOL] opportunities = [number] [EOL] while True : [EOL] if time . time ( ) > self . haxUntil : [EOL] self . _kaha_msg ( channel , thread , [string] . format ( totalGainz , opportunities ) ) [EOL] print ( [string] ) [EOL] break [EOL] [EOL] nextCheck = self . nextBotUpdateTime - ArbitrageBot . HAX_BUFFER [EOL] print ( [string] . format ( _get_time_str ( nextCheck ) ) ) [EOL] _sleep_until ( nextCheck ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] coinDict = _pollCmc ( ) [EOL] self . coinList = list ( coinDict . keys ( ) ) [EOL] [EOL] bestGainz = [number] [EOL] for coin in self . coinList : [EOL] if not coin in coinDict or not coin in self . botPriceHash : [EOL] continue [EOL] if coinDict [ coin ] . rank >= [number] : [EOL] continue [EOL] gainz = coinDict [ coin ] . price / self . botPriceHash [ coin ] [EOL] if gainz > bestGainz : [EOL] bestGainz = gainz [EOL] bestCoin = coin [EOL] [EOL] if bestGainz > [number] : [EOL] opportunities += [number] [EOL] print ( [string] . format ( bestCoin , ( bestGainz - [number] ) * [number] ) ) [EOL] buyAmt = round ( self . hax_cash / self . botPriceHash [ bestCoin ] , [number] ) [EOL] print ( [string] . format ( self . hax_cash , buyAmt ) ) [EOL] self . _kaha_msg ( channel , thread , [string] . format ( bestCoin , buyAmt ) ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] _sleep_until ( self . nextBotUpdateTime + [number] ) [EOL] self . botPriceHash , self . nextBotUpdateTime = self . _pollCryptoBot ( channel , thread , self . coinList ) [EOL] [EOL] if bestGainz > [number] : [EOL] profit = buyAmt * self . botPriceHash [ bestCoin ] - self . hax_cash [EOL] totalGainz += profit [EOL] self . hax_cash = buyAmt * self . botPriceHash [ bestCoin ] [EOL] self . _kaha_msg ( channel , thread , [string] . format ( bestCoin , buyAmt ) ) [EOL] print ( [string] . format ( profit ) ) [EOL] [EOL] def _pollCryptoBot ( self , errChannel , errThread , coinList ) : [EOL] [comment] [EOL] self . api_call ( [string] , channel = ArbitrageBot . BOT_CHANNEL , text = [string] . format ( [string] . join ( coinList ) ) , thread_ts = None , as_user = [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] timeout = time . time ( ) + [number] [EOL] while True : [EOL] events = list ( filter ( lambda e : e . get ( [string] ) == [string] and e . get ( [string] ) == ArbitrageBot . BOT_CHANNEL and e . get ( [string] ) == ArbitrageBot . BOT_NAME , self . rtm_read ( ) ) ) [EOL] if len ( events ) > [number] : [EOL] botPriceHash = { } [EOL] prices = events [ [number] ] . get ( [string] ) . replace ( [string] , [string] ) [EOL] for coinAndPrice in prices . split ( [string] ) : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] m = re . search ( [string] , coinAndPrice ) [EOL] coin = m . group ( [number] ) . lower ( ) [EOL] price = float ( m . group ( [number] ) ) [EOL] botPriceHash [ coin ] = price [EOL] except : [EOL] print ( [string] . format ( coinAndPrice ) ) [EOL] nextBotUpdateTime = time . time ( ) + ArbitrageBot . BOT_REFRESH_TIME [EOL] return [ botPriceHash , nextBotUpdateTime ] [EOL] if time . time ( ) > timeout : [EOL] print ( [string] . format ( ArbitrageBot . BOT_NAME ) ) [EOL] self . postMessage ( errChannel , [string] . format ( ArbitrageBot . BOT_NAME ) , errThread ) [EOL] return [ self . botPriceHash , self . nextBotUpdateTime + ArbitrageBot . BOT_REFRESH_TIME ] [EOL] time . sleep ( [number] ) [EOL] [EOL] def _kaha_msg ( self , channel , thread , msg ) : [EOL] self . api_call ( [string] , token = os . getenv ( [string] ) , channel = channel , text = msg , thread_ts = thread , as_user = [string] ) [EOL] [EOL] def _mono ( str ) : [EOL] return [string] . format ( str = str ) [EOL] [EOL] def _get_time_str ( call_time ) : [EOL] return datetime . fromtimestamp ( call_time , tz = utc ) . astimezone ( timezone ( [string] ) ) . strftime ( [string] ) [EOL] [EOL] def _sleep_until ( timestamp ) : [EOL] t = time . time ( ) [EOL] if timestamp > t : [EOL] time . sleep ( timestamp - t ) [EOL] [EOL] def _pollCmc ( ) : [EOL] [comment] [EOL] resp = get ( [string] ) . json ( ) [EOL] coinDict = { } [EOL] coinInfo = namedtuple ( [string] , [string] ) [EOL] for coin in resp [ [string] ] : [EOL] try : [EOL] name = coin [ [string] ] . lower ( ) [EOL] price = coin [ [string] ] [ [string] ] [ [string] ] [EOL] rank = coin [ [string] ] [EOL] updateTime = coin [ [string] ] [EOL] coinDict [ name ] = coinInfo ( price , updateTime , rank ) [EOL] except : [EOL] print ( [string] . format ( str ( coin ) ) ) [EOL] return coinDict [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $bot.Bot.Bot$ 0 $redis.StrictRedis$ 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Bot$ 0 $redis.StrictRedis$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.float$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import requests [EOL] import urllib . parse [EOL] [EOL] import requests [EOL] [EOL] [EOL] def shorten_url ( url ) : [EOL] r = requests . get ( [string] . format ( urllib . parse . quote ( url ) ) ) [EOL] r . raise_for_status ( ) [EOL] return r . text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import requests [EOL] import requests [EOL] [EOL] [EOL] def upload_analysis ( pgn_string ) : [EOL] [docstring] [EOL] [EOL] r = requests . post ( [string] , data = { [string] : pgn_string } , timeout = [number] ) [EOL] r . raise_for_status ( ) [EOL] return r . request . url [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Literal , Optional , Union , Type [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] import bot [EOL] import chessbot [EOL] from bot . Bot import SlackBot , Command [EOL] from . ai import getMove [EOL] from . analysis import upload_analysis [EOL] from . board import TarraschBoard , TarraschNoBoardException [EOL] from chess import SQUARE_NAMES [EOL] from prettytable import PrettyTable [EOL] [EOL] import json [EOL] import time [EOL] [EOL] COOLDOWN_SECONDS = [number] [EOL] MP = [string] [EOL] [EOL] [EOL] class ChessBot ( SlackBot ) : [EOL] def __init__ ( self , token , bot , db ) : [EOL] super ( ) . __init__ ( token , bot , db ) [EOL] self . STARTUP_STATE = { } [EOL] [EOL] def onStart ( self , cmd ) : [EOL] [docstring] [EOL] channel , thread = cmd . channel , cmd . thread [EOL] try : [EOL] board = TarraschBoard . from_backend ( channel , thread ) [EOL] except TarraschNoBoardException : [EOL] board = None [EOL] [EOL] if board : [EOL] return self . postMessage ( channel , [string] . format ( board . white_user , board . black_user ) , thread ) [EOL] self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] = { } [EOL] self . postMessage ( channel , ( [string] + [string] ) . format ( MP ) , thread ) [EOL] [EOL] def onClaim ( self , cmd ) : [EOL] [docstring] [EOL] args , channel , thread , user_name = ( cmd . args , cmd . channel , cmd . thread , cmd . user_name ) [EOL] if TarraschBoard . getDbKey ( channel , thread ) not in self . STARTUP_STATE : [EOL] return self . postMessage ( channel , [string] . format ( MP ) , thread ) [EOL] [EOL] color = args [ [number] ] . lower ( ) [EOL] ai = args [ [number] ] if len ( args ) > [number] else None [comment] [EOL] if color not in [ [string] , [string] ] : [EOL] return self . postMessage ( channel , ( [string] + [string] ) . format ( MP , MP ) , thread ) [EOL] [EOL] [comment] [EOL] if ai == [string] : [EOL] user_name = [string] [EOL] [EOL] self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] [ color ] = user_name [EOL] self . postMessage ( channel , [string] . format ( user_name , color ) , thread ) [EOL] [EOL] if [string] in self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] and [string] in self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] : [EOL] self . _start_game ( cmd , self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] [ [string] ] , self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] [ [string] ] ) [EOL] del self . STARTUP_STATE [ TarraschBoard . getDbKey ( channel , thread ) ] [EOL] [EOL] def _start_game ( self , cmd , white_user , black_user ) : [EOL] channel , thread = cmd . channel , cmd . thread [EOL] board = TarraschBoard ( channel , thread , white_user , black_user ) [EOL] board . save ( ) [EOL] self . _render ( cmd , board ) [EOL] [EOL] def _render ( self , cmd , board = None ) : [EOL] channel , thread = cmd . channel , cmd . thread [EOL] if not board : [EOL] board = TarraschBoard . from_backend ( channel , thread ) [EOL] self . postMessage ( channel , board . get_url ( shorten = True ) , thread ) [EOL] color = [string] if board . turn else [string] [EOL] user = board . white_user if color == [string] else board . black_user [EOL] if not board . is_game_over ( ) : [EOL] message = [string] [EOL] if board . move_stack : [EOL] last_move = board . move_stack [ - [number] ] [EOL] from_square , to_square = ( SQUARE_NAMES [ last_move . from_square ] , SQUARE_NAMES [ last_move . to_square ] ) [EOL] message += [string] . format ( from_square , to_square ) [EOL] message += [string] . format ( user , color ) [EOL] if board . is_check ( ) : [EOL] message += [string] [EOL] self . postMessage ( channel , message , thread ) [EOL] [EOL] def onBoard ( self , cmd ) : [EOL] [docstring] [EOL] self . _render ( cmd ) [EOL] [EOL] def onMove ( self , cmd ) : [EOL] [docstring] [EOL] args , channel , thread , user_name = ( cmd . args , cmd . channel , cmd . thread , cmd . user_name ) [EOL] board = TarraschBoard . from_backend ( channel , thread ) [EOL] if user_name != board . current_turn_username : [comment] [EOL] return [EOL] if len ( args ) == [number] : [EOL] return [EOL] time_until_can_move = COOLDOWN_SECONDS - ( time . time ( ) - board . last_move_time ) [EOL] if time_until_can_move > [number] : [EOL] return self . postMessage ( channel , [string] . format ( _humanize ( time_until_can_move ) ) , thread ) [EOL] [EOL] move = args [ [number] ] [EOL] try : [EOL] board . push_san ( move ) [EOL] if board . black_user == [string] : [EOL] board . push ( getMove ( board ) ) [EOL] except ValueError : [EOL] return self . postMessage ( channel , [string] , thread ) [EOL] board . save ( last_move_time = time . time ( ) ) [EOL] self . _render ( cmd , board = board ) [EOL] if board . is_game_over ( ) : [EOL] self . _handle_game_over ( cmd , board ) [EOL] [EOL] def onTakeback ( self , cmd ) : [EOL] [docstring] [EOL] channel , thread , user_name = ( cmd . channel , cmd . thread , cmd . user_name ) [EOL] board = TarraschBoard . from_backend ( channel , thread ) [EOL] if user_name != board . current_turn_username : [EOL] return self . postMessage ( channel , [string] . format ( board . current_turn_username ) , thread ) [EOL] board . pop ( ) [EOL] board . save ( ) [EOL] self . _render ( cmd , board ) [EOL] [EOL] def onForfeit ( self , cmd ) : [EOL] [docstring] [EOL] channel , thread = cmd . channel , cmd . thread [EOL] board = TarraschBoard . from_backend ( channel , thread ) [EOL] if board . turn : [EOL] self . _handle_game_over ( cmd , board , [string] ) [EOL] else : [EOL] self . _handle_game_over ( cmd , board , [string] ) [EOL] [EOL] def onRecord ( self , cmd ) : [EOL] [docstring] [EOL] channel , thread , user_name = ( cmd . channel , cmd . thread , cmd . user_name ) [EOL] record = self . db . get ( user_name ) [EOL] if not record : [EOL] return self . postMessage ( channel , [string] . format ( user_name ) , thread ) [EOL] record = json . loads ( str ( record ) ) [EOL] table = PrettyTable ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] for opponent , results in record . iteritems ( ) : [EOL] table . add_row ( [ opponent , results [ [string] ] + results [ [string] ] + results [ [string] ] , results [ [string] ] , results [ [string] ] , results [ [string] ] ] ) [EOL] table_string = table . get_string ( sortby = [string] , reversesort = True ) [EOL] self . postMessage ( channel , [string] . format ( user_name , table_string ) , thread ) [EOL] [EOL] def onLeaderboard ( self , cmd ) : [EOL] [docstring] [EOL] channel , thread = cmd . channel , cmd . thread [EOL] table = PrettyTable ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] if self . db . scard ( [string] ) == [number] : [EOL] return self . postMessage ( channel , [string] , thread ) [EOL] for player in self . db . smembers ( [string] ) : [EOL] record = self . db . get ( player ) [EOL] if not record : [EOL] continue [EOL] record = json . loads ( str ( record ) ) [EOL] wins , losses , draws = [number] , [number] , [number] [EOL] for _ , results in record . iteritems ( ) : [EOL] wins += results [ [string] ] [EOL] losses += results [ [string] ] [EOL] draws += results [ [string] ] [EOL] table . add_row ( [ player , wins + losses + draws , wins , losses , draws ] ) [EOL] table_string = table . get_string ( sortby = [string] , reversesort = True ) [EOL] self . postMessage ( channel , [string] . format ( table_string ) , thread ) [EOL] [EOL] def onHelp ( self , cmd ) : [EOL] if cmd . thread is None : [EOL] self . postMessage ( cmd . channel , [string] , cmd . thread ) [EOL] return [EOL] [EOL] help_string = [string] + [string] [EOL] channel , thread = cmd . channel , cmd . thread [EOL] for command in sorted ( self . COMMANDS . keys ( ) ) : [EOL] if command == [string] : [EOL] continue [EOL] help_string += [string] . format ( command , self . COMMANDS [ command ] . __doc__ ) [EOL] help_string += [string] [EOL] self . postMessage ( channel , help_string , thread ) [EOL] [EOL] def _update_records ( self , white_user , black_user , result ) : [EOL] white_result = [string] if result == [string] else [string] [EOL] black_result = [string] if result == [string] else [string] [EOL] if result == [string] : [EOL] white_result , black_result = [string] , [string] [EOL] self . _update_record ( white_user , black_user , white_result ) [EOL] self . _update_record ( black_user , white_user , black_result ) [EOL] self . db . sadd ( [string] , white_user ) [EOL] self . db . sadd ( [string] , black_user ) [EOL] [EOL] def _update_record ( self , user , against , result ) : [EOL] record = json . loads ( str ( self . db . get ( user ) or { } ) ) [EOL] if against not in record : [EOL] record [ against ] = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] record [ against ] [ result ] += [number] [EOL] self . db . set ( user , json . dumps ( record ) ) [EOL] [EOL] def _handle_game_over ( self , cmd , board , result = None ) : [EOL] channel , thread = cmd . channel , cmd . thread [EOL] if not result : [EOL] if board . result ( ) == [string] : [EOL] result = [string] [EOL] elif board . result ( ) == [string] : [EOL] result = [string] [EOL] elif board . result ( ) == [string] : [EOL] raise ValueError ( [string] + [string] ) [EOL] else : [EOL] result = [string] [EOL] if board . white_user != board . black_user : [EOL] self . _update_records ( board . white_user , board . black_user , result ) [EOL] [EOL] [comment] [EOL] try : [EOL] url = upload_analysis ( board . get_pgn ( ) ) [EOL] message = [string] . format ( url ) [EOL] except Exception : [EOL] message = [string] [EOL] self . postMessage ( channel , message , thread ) [EOL] [EOL] board . kill ( ) [EOL] if result != [string] : [EOL] winner = board . white_user if result == [string] else board . black_user [EOL] color = [string] if result == [string] else [string] [EOL] self . postMessage ( channel , [string] . format ( winner , color , MP ) , thread ) [EOL] else : [EOL] self . postMessage ( channel , [string] . format ( MP ) , thread ) [EOL] [EOL] COMMANDS = { [string] : onStart , [string] : onClaim , [string] : onBoard , [string] : onMove , [string] : onTakeback , [string] : onForfeit , [string] : onRecord , [string] : onLeaderboard , [string] : onHelp , } [EOL] [EOL] [EOL] def _humanize ( seconds ) : [EOL] if seconds < [number] : [EOL] return [string] . format ( int ( round ( seconds ) ) ) [EOL] elif seconds < [number] * [number] * [number] : [EOL] return [string] . format ( int ( round ( seconds / [number] ) ) ) [EOL] elif seconds < [number] * [number] * [number] : [EOL] return [string] . format ( int ( round ( seconds / ( [number] * [number] ) ) ) ) [EOL] return [string] . format ( int ( round ( seconds / ( [number] * [number] * [number] ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,typing_extensions.Literal]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import chess [EOL] import typing [EOL] import chess [EOL] from random import choice [EOL] from chess import Board , Move [EOL] [EOL] board = chess . Board ( ) [EOL] [EOL] [EOL] def getMove ( board ) : [EOL] [comment] [EOL] return choice ( list ( board . legal_moves ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $chess.Move$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import chessbot [EOL] import random [EOL] import pickle [EOL] import datetime [EOL] [EOL] from chess import Board , SQUARES_180 , pgn [EOL] [EOL] from bot . redis import redis as db [EOL] from . shortener import shorten_url [EOL] [EOL] [EOL] class TarraschNoBoardException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class TarraschBoard ( Board ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , channel , thread , white_user , black_user , * args , ** kwargs ) : [EOL] super ( TarraschBoard , self ) . __init__ ( * args , ** kwargs ) [EOL] self . channel = channel [EOL] self . thread = thread [EOL] self . white_user = white_user [EOL] self . black_user = black_user [EOL] self . last_move_time = [number] [EOL] [EOL] @ staticmethod def getDbKey ( channel , thread ) : [EOL] return channel + [string] + thread [EOL] [EOL] @ classmethod def from_backend ( cls , channel , thread ) : [EOL] [docstring] [EOL] record = db . get ( TarraschBoard . getDbKey ( channel , thread ) ) [EOL] if not record : [EOL] raise TarraschNoBoardException ( [string] . format ( channel , thread ) ) [EOL] payload = pickle . loads ( record ) [EOL] board = cls ( channel , thread , payload [ [string] ] , payload [ [string] ] ) [EOL] board . last_move_time = payload [ [string] ] or [number] [EOL] [comment] [EOL] board . set_fen ( payload [ [string] ] ) [EOL] [comment] [EOL] board . move_stack = payload [ [string] ] [EOL] board . stack = payload [ [string] ] [EOL] return board [EOL] [EOL] def save ( self , last_move_time = None ) : [EOL] payload = { [string] : self . fen ( ) , [string] : self . white_user , [string] : self . black_user , [string] : last_move_time , [string] : self . move_stack , [string] : self . stack } [EOL] db . set ( self . _getDbKey ( ) , pickle . dumps ( payload ) ) [EOL] [EOL] def _getDbKey ( self ) : [EOL] return TarraschBoard . getDbKey ( self . channel , self . thread ) [EOL] [EOL] def kill ( self ) : [EOL] db . delete ( self . _getDbKey ( ) ) [EOL] [EOL] def get_url ( self , shorten = False ) : [EOL] render_string = [string] [EOL] for square in SQUARES_180 : [EOL] piece = self . piece_at ( square ) [EOL] if piece : [EOL] render_string += piece . symbol ( ) [EOL] else : [EOL] render_string += [string] [EOL] [comment] [EOL] url = [string] + [string] . format ( render_string , random . randint ( [number] , [number] ) ) [EOL] if shorten : [EOL] url = shorten_url ( url ) [EOL] return url [EOL] [EOL] @ property def current_turn_username ( self ) : [EOL] return self . white_user if self . turn else self . black_user [EOL] [EOL] def get_pgn ( self ) : [EOL] [docstring] [EOL] root = pgn . Game ( ) [EOL] root . headers [ [string] ] = [string] [EOL] root . headers [ [string] ] = datetime . datetime . utcnow ( ) . strftime ( [string] ) [EOL] root . headers [ [string] ] = self . white_user [EOL] root . headers [ [string] ] = self . black_user [EOL] [EOL] next = root [EOL] for move in self . move_stack : [EOL] next = next . add_main_variation ( move ) [EOL] [EOL] return root . __str__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $chessbot.board.TarraschBoard$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $chessbot.board.TarraschBoard$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $chessbot.board.TarraschBoard$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $chessbot.board.TarraschBoard$ 0 0 0 $typing.Any$ 0 0 0 0 $chessbot.board.TarraschBoard$ 0 0 0 $typing.Any$ 0 0 0 0 0 $chessbot.board.TarraschBoard$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] from json import JSONDecoder [EOL] [EOL] [EOL] class FastJsonDecoder ( JSONDecoder ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] JSONDecoder . __init__ ( self , object_hook = self . hook , * args , ** kwargs ) [EOL] [EOL] def jsonToClass ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def hook ( self , obj ) : [EOL] for keys , C in self . jsonToClass ( ) . items ( ) : [EOL] if set ( keys ) == set ( obj . keys ( ) ) : [EOL] args = [ ] [EOL] for key in list ( keys ) : [EOL] args . append ( obj [ key ] ) [EOL] return C ( * args ) [EOL] return obj [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0
from typing import List , Any , Set , Dict , Union , Optional [EOL] import crypto [EOL] import typing [EOL] import CryptoTrader [EOL] import builtins [EOL] import bot [EOL] from . CryptoTrader import ( CryptoTrader , Alert , Buy , Sell , User , InsufficientFundsError , InsufficientCoinsError ) [EOL] from bot . Bot import Bot , Command , SlackBot [EOL] from typing import Dict , List , Union , Optional [EOL] import threading [EOL] [EOL] [EOL] class CryptoBot ( SlackBot ) : [EOL] [EOL] def __init__ ( self , token , bot , trader ) : [EOL] super ( ) . __init__ ( token , bot , None ) [EOL] self . trader = trader [EOL] self . lastLeaderboard = None [EOL] self . lastTopCoins = None [EOL] self . poll_and_execute_ifs ( ) [EOL] [EOL] def poll_and_execute_ifs ( self ) : [EOL] [comment] [EOL] [comment] [EOL] threading . Timer ( [number] * [number] , self . poll_and_execute_ifs ) . start ( ) [EOL] [EOL] [comment] [EOL] prices = self . trader . api . getPrices ( ) [EOL] for user in self . trader . getAllUsers ( ) : [EOL] self . execute_ifs ( user , prices ) [EOL] [EOL] def execute_ifs ( self , user , prices ) : [EOL] idx = [number] [EOL] ifs = user . ifs [EOL] while idx < len ( ifs ) : [EOL] try : [EOL] i = ifs [ idx ] [EOL] if not i . meets_condition ( prices ) : [EOL] print ( [string] . format ( user . user_name , i . id , i . condition . render ( ) ) ) [EOL] else : [EOL] print ( [string] . format ( user . user_name , i . id , i . condition . render ( ) ) ) [EOL] if i . action [ [string] ] == [string] : [comment] [EOL] self . api_call ( [string] , channel = [string] . format ( user . user_name ) , text = [string] . format ( i . action [ [string] ] ) , username = self . bot . name , icon_emoji = self . bot . icon_emoji ) [EOL] [EOL] elif i . action [ [string] ] == [string] : [comment] [EOL] coin = i . action [ [string] ] [comment] [EOL] fromQty = user . portfolio . get ( coin , [number] ) [EOL] buyQty = i . action [ [string] ] [EOL] toQty = fromQty + buyQty [comment] [EOL] fromUSD = [string] . format ( user . balance ) [EOL] self . trader . buy ( user . user_name , coin , buyQty ) [EOL] db_user = self . trader . _getUser ( user . user_name ) [EOL] user . portfolio = db_user . portfolio [EOL] user . balance = db_user . balance [EOL] toUSD = [string] . format ( user . balance ) [EOL] msg = [string] . format ( i . render ( ) , user . user_name , fromUSD , toUSD , coin , fromQty , toQty ) [EOL] self . api_call ( [string] , channel = [string] , text = _mono ( msg ) , username = self . bot . name , icon_emoji = self . bot . icon_emoji ) [EOL] self . _onLeaderboard ( [string] , None ) [EOL] elif i . action [ [string] ] == [string] : [comment] [EOL] coin = i . action [ [string] ] [comment] [EOL] fromQty = user . portfolio . get ( coin , [number] ) [EOL] sellQty = i . action [ [string] ] [comment] [EOL] toQty = fromQty - sellQty [EOL] fromUSD = [string] . format ( user . balance ) [EOL] self . trader . sell ( user . user_name , coin , sellQty ) [EOL] db_user = self . trader . _getUser ( user . user_name ) [EOL] user . portfolio = db_user . portfolio [EOL] user . balance = db_user . balance [EOL] toUSD = [string] . format ( user . balance ) [EOL] msg = [string] . format ( i . render ( ) , user . user_name , fromUSD , toUSD , coin , fromQty , toQty ) [EOL] self . api_call ( [string] , channel = [string] , text = _mono ( msg ) , username = self . bot . name , icon_emoji = self . bot . icon_emoji ) [EOL] self . _onLeaderboard ( [string] , None ) [EOL] [comment] [EOL] del ( ifs [ idx ] ) [EOL] except Exception as e : [EOL] i = ifs [ idx ] [EOL] self . api_call ( [string] , channel = [string] . format ( user . user_name ) , text = [string] . format ( i . condition , i . action , str ( e ) ) , username = self . bot . name , icon_emoji = self . bot . icon_emoji ) [EOL] idx = idx + [number] [EOL] self . trader . _setUser ( user ) [EOL] [EOL] def deleteFileUploads ( self , file ) : [EOL] try : [EOL] result = self . api_call ( [string] , file = file ) [EOL] print ( result ) [EOL] self . fileUploads = [ ] [EOL] except : [EOL] print ( [string] ) [EOL] [EOL] def onHelp ( self , cmd ) : [EOL] [comment] [EOL] channel , thread = cmd . channel , cmd . thread [EOL] msg = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . postMessage ( channel , _mono ( msg ) , thread ) [EOL] [EOL] def onPing ( self , cmd ) : [EOL] channel , thread = cmd . channel , cmd . thread [EOL] self . postMessage ( channel , [string] , thread ) [EOL] [EOL] def onNewUser ( self , cmd ) : [EOL] [comment] [EOL] user_name , args , channel , thread = ( cmd . user_name , cmd . args , cmd . channel , cmd . thread ) [EOL] [comment] [EOL] self . trader . create_user ( user_name ) [EOL] self . onLeaderboard ( cmd ) [EOL] [EOL] def onUserQuit ( self , cmd ) : [EOL] [comment] [EOL] user_name , args , channel , thread = ( cmd . user_name , cmd . args , cmd . channel , cmd . thread ) [EOL] [comment] [EOL] self . trader . delete_user ( user_name ) [EOL] self . onLeaderboard ( cmd ) [EOL] [EOL] def displayIfs ( self , user_name , channel , thread ) : [EOL] ifs = self . trader . _getUser ( user_name ) . ifs [EOL] if len ( ifs ) == [number] : [EOL] msg = [string] . format ( user_name ) [EOL] else : [EOL] msg = [string] . join ( [ i . render ( ) for i in ifs ] ) [EOL] msg = [string] . format ( user_name , msg ) [EOL] self . postMessage ( channel , _mono ( msg ) , thread ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def onIf ( self , cmd ) : [EOL] user_name , args , channel , thread = ( cmd . user_name , cmd . args , cmd . channel , cmd . thread ) [EOL] [EOL] print ( args ) [EOL] [EOL] [comment] [EOL] if len ( args ) == [number] : [EOL] self . displayIfs ( user_name , channel , thread ) [EOL] [EOL] [comment] [EOL] elif args [ [number] ] == [string] : [EOL] try : [EOL] id = int ( args [ [number] ] ) [EOL] self . trader . deleteIf ( user_name , id ) [EOL] self . displayIfs ( user_name , channel , thread ) [EOL] except Exception as e : [EOL] print ( e ) [EOL] self . postMessage ( channel , [string] , thread ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] try : [EOL] coin = args [ [number] ] [EOL] comparator = args [ [number] ] [EOL] amount = float ( args [ [number] ] ) [EOL] action = args [ [number] ] [EOL] if action == [string] : [EOL] try : [EOL] self . trader . setAlertIf ( user_name , coin , comparator , amount ) [EOL] self . displayIfs ( user_name , channel , thread ) [EOL] except Exception as e : [EOL] self . postMessage ( channel , _mono ( str ( e ) ) , thread ) [EOL] return [EOL] elif action == [string] : [EOL] try : [EOL] buyCoin = args [ [number] ] [EOL] buyQty = args [ [number] ] [EOL] self . trader . setBuyIf ( user_name , coin , comparator , amount , buyCoin , buyQty ) [EOL] self . displayIfs ( user_name , channel , thread ) [EOL] except Exception as e : [EOL] self . postMessage ( channel , _mono ( str ( e ) ) , thread ) [EOL] return [EOL] elif action == [string] : [EOL] try : [EOL] sellCoin = args [ [number] ] [EOL] sellQty = args [ [number] ] [EOL] self . trader . setSellIf ( user_name , coin , comparator , amount , sellCoin , sellQty ) [EOL] self . displayIfs ( user_name , channel , thread ) [EOL] except Exception as e : [EOL] self . postMessage ( channel , _mono ( str ( e ) ) , thread ) [EOL] return [EOL] except Exception as e : [EOL] print ( e ) [EOL] msg = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] self . postMessage ( channel , _mono ( msg ) , thread ) [EOL] [EOL] def onBuy ( self , cmd ) : [EOL] [comment] [EOL] user_name , args , channel , thread = ( cmd . user_name , cmd . args , cmd . channel , cmd . thread ) [EOL] try : [EOL] ticker = args [ [number] ] . lower ( ) [EOL] quantity = float ( args [ [number] ] ) [EOL] except : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] return [EOL] try : [EOL] self . trader . buy ( user_name , ticker , quantity ) [EOL] self . postMessage ( channel , [string] . format ( u = user_name , t = ticker , q = quantity ) , thread ) [EOL] self . onLeaderboard ( cmd ) [EOL] except InsufficientFundsError : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] except : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] [EOL] def onSell ( self , cmd ) : [EOL] [comment] [EOL] user_name , args , channel , thread = ( cmd . user_name , cmd . args , cmd . channel , cmd . thread ) [EOL] try : [EOL] ticker = args [ [number] ] . lower ( ) [EOL] quantity = float ( args [ [number] ] ) [EOL] except : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] return [EOL] try : [EOL] self . trader . sell ( user_name , ticker , quantity ) [EOL] self . postMessage ( channel , [string] . format ( u = user_name , t = ticker , q = quantity ) , thread ) [EOL] self . onLeaderboard ( cmd ) [EOL] except InsufficientCoinsError : [EOL] self . postMessage ( channel , [string] . format ( u = user_name , t = ticker , q = quantity ) , thread ) [EOL] except : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] [EOL] def _onLeaderboard ( self , channel , thread ) : [EOL] png = self . trader . leaderboard ( ) [EOL] try : [EOL] if self . lastLeaderboard : [EOL] self . api_call ( [string] , file = self . lastLeaderboard ) [EOL] self . lastLeaderboard = None [EOL] response = self . api_call ( [string] , channels = [ channel ] , filename = [string] , file = png ) [EOL] self . lastLeaderboard = response [ [string] ] [ [string] ] [EOL] except : [EOL] self . postMessage ( channel , [string] , thread ) [EOL] [EOL] def onLeaderboard ( self , cmd ) : [EOL] [comment] [EOL] channel , thread = ( cmd . channel , cmd . thread ) [EOL] self . _onLeaderboard ( channel , thread ) [EOL] [EOL] def onPrices ( self , cmd ) : [EOL] [comment] [EOL] [comment] [EOL] tickers , channel , thread = cmd . args , cmd . channel , cmd . thread [EOL] res = { ticker + [string] + str ( price ) for ticker , price in self . trader . api . getPrices ( ) . items ( ) if ticker . lower ( ) in map ( lambda t : t . lower ( ) , tickers ) } [EOL] self . postMessage ( channel , _mono ( [string] . join ( res ) ) , thread ) [EOL] [EOL] def onTopCoins ( self , cmd ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] args , channel , thread = cmd . args , cmd . channel , cmd . thread [EOL] try : [EOL] numCoins = int ( args [ [number] ] ) if args else [number] [EOL] numCoins = numCoins if numCoins <= [number] else [number] [EOL] png = self . trader . topCoins ( numCoins ) [EOL] [EOL] if self . lastTopCoins : [EOL] self . api_call ( [string] , file = self . lastTopCoins ) [EOL] self . lastTopCoins = None [EOL] response = self . api_call ( [string] , channels = [ channel ] , filename = [string] , file = png ) [EOL] self . lastTopCoins = response [ [string] ] [ [string] ] [EOL] except : [EOL] self . postMessage [EOL] ( channel , [string] , thread ) [EOL] [EOL] [EOL] def _mono ( str ) : [EOL] return [string] . format ( str = str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[crypto.CryptoTrader.If]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[crypto.CryptoTrader.If]$ 0 0 0 0 $typing.List[crypto.CryptoTrader.If]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[crypto.CryptoTrader.If]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.float$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 $bot.Bot.Command$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import psycopg2 [EOL] [EOL] conn = psycopg2 . connect ( [string] ) [EOL] [EOL] [EOL] def sql ( command , data = ( ) ) : [EOL] with conn : [EOL] with conn . cursor ( ) as curs : [EOL] curs . execute ( command ) [EOL] return curs . fetchall ( ) [EOL] [EOL] [EOL] def insert ( command , data = ( ) ) : [EOL] with conn : [EOL] with conn . cursor ( ) as curs : [EOL] curs . execute ( command , data ) [EOL] return curs . statusmessage [EOL] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from dataclasses import dataclass [EOL] from typing import Dict , List [EOL] from . decoders import FastJsonDecoder [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Quote : [EOL] price = ... [EOL] volume_24h = ... [EOL] percent_change_1h = ... [EOL] percent_change_24h = ... [EOL] percent_change_7d = ... [EOL] market_cap = ... [EOL] last_updated = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Listing : [EOL] id = ... [EOL] name = ... [EOL] symbol = ... [EOL] slug = ... [EOL] circulating_supply = ... [EOL] total_supply = ... [EOL] max_supply = ... [EOL] date_added = ... [EOL] num_market_pairs = ... [EOL] tags = ... [EOL] platform = ... [EOL] cmc_rank = ... [EOL] last_updated = ... [EOL] quote = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Status : [EOL] timestamp = ... [EOL] error_code = ... [EOL] error_message = ... [EOL] elapsed = ... [EOL] credit_count = ... [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Listings : [EOL] status = ... [EOL] data = ... [EOL] [EOL] [EOL] class ListingsDecoder ( FastJsonDecoder ) : [EOL] def jsonToClass ( self ) : [EOL] return { ( [string] , [string] , [string] , [string] , [string] ) : Status , ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : Listing , ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : Quote , ( [string] , [string] ) : Listings } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,Quote]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Status$ 0 0 0 $typing.List[Listing]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Literal , Tuple , Dict , Union , Type [EOL] import crypto [EOL] import typing [EOL] import models [EOL] import requests [EOL] import builtins [EOL] import typing_extensions [EOL] from requests import request , Response [EOL] from json import loads , JSONDecoder [EOL] from . models import Listings , Listing , ListingsDecoder [EOL] from typing import Dict , List , Tuple [EOL] import os [EOL] import time [EOL] [EOL] CMC_API_KEY = os . getenv ( [string] , [string] ) [EOL] if CMC_API_KEY == [string] : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] def current_time_ms ( ) : [EOL] return int ( round ( time . time ( ) * [number] ) ) [EOL] [EOL] [EOL] class CachedGet : [EOL] [EOL] def __init__ ( self , cache_time_ms ) : [EOL] self . cache = { } [EOL] self . cache_time_ms = cache_time_ms [EOL] self . total_api_calls = [number] [EOL] [EOL] def _isOld ( self , t ) : [EOL] return current_time_ms ( ) - t > self . cache_time_ms [EOL] [EOL] def _needsCacheRefresh ( self , url ) : [EOL] [comment] [EOL] [EOL] isNotInCache = url not in self . cache . keys ( ) [EOL] isStaleInCache = ( url in self . cache . keys ( ) and self . _isOld ( self . cache [ url ] [ [number] ] ) ) [EOL] [EOL] return isNotInCache or isStaleInCache [EOL] [EOL] def request ( self , method , url , headers , params ) : [EOL] if self . _needsCacheRefresh ( url ) : [EOL] print ( [string] . format ( url = url ) ) [EOL] resp = request ( method , url , headers = headers , params = params ) [EOL] self . total_api_calls = self . total_api_calls + [number] [EOL] print ( [string] . format ( n = self . total_api_calls ) ) [EOL] self . cache [ url ] = ( resp , current_time_ms ( ) ) [EOL] return resp [EOL] else : [EOL] return self . cache [ url ] [ [number] ] [EOL] [EOL] [EOL] class CoinMarketCapApi : [EOL] [EOL] URL = [string] [EOL] REFRESH_TIME_MS = [number] * [number] * [number] [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] self . getter = CachedGet ( CoinMarketCapApi . REFRESH_TIME_MS ) [EOL] [EOL] def getListings ( self ) : [EOL] resp = self . getter . request ( [string] , CoinMarketCapApi . URL . format ( resource = [string] ) , { [string] : CMC_API_KEY , } , { [string] : [string] , [string] : [string] } ) [EOL] return loads ( resp . text , cls = ListingsDecoder ) [EOL] [EOL] def getPrices ( self ) : [EOL] return { listing . symbol . lower ( ) : listing . quote [ [string] ] . price for listing in self . getListings ( ) . data } [EOL] [EOL] def getTopNListings ( self , n ) : [EOL] listings = self . getListings ( ) . data [EOL] sortedListings = sorted ( listings , key = lambda l : l . cmc_rank ) [ [number] : n ] [EOL] return sortedListings [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $crypto.CoinMarketCap.CachedGet$ 0 0 0 0 0 0 0 0 0 0 $models.Listings$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[models.Listing]$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[crypto.models.Listing]$ 0 0 0 0 0 0 0 0 0 $typing.List[crypto.models.Listing]$ 0 0 0 $typing.List[crypto.models.Listing]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[crypto.models.Listing]$ 0