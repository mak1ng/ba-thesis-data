from typing import Any , List , Iterator [EOL] import builtins [EOL] import typing [EOL] import proto [EOL] import os [EOL] from copy import deepcopy [EOL] from random import shuffle [EOL] from typing import Iterator , List [EOL] [EOL] from io_util import read_message_from_file , write_message_to_file [EOL] from proto . cards_pb2 import Card , DeckOfCards [EOL] [EOL] _DECKS_DIRECTORY = [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class Deck ( object ) : [EOL] [EOL] def __init__ ( self , cards ) : [EOL] self . _cards = cards [EOL] [EOL] @ property def cards ( self ) : [EOL] return self . _cards [EOL] [EOL] @ property def size ( self ) : [EOL] return len ( self . _cards ) [EOL] [EOL] def deal ( self ) : [EOL] cards = deepcopy ( self . _cards ) [EOL] shuffle ( cards ) [EOL] for card in cards : [EOL] yield card [EOL] [EOL] def __repr__ ( self ) : [EOL] card_strs = [ ] [EOL] for card in self . _cards : [EOL] card_strs . append ( [string] . format ( card . label , card . suit , card . rank ) ) [EOL] return [string] . join ( card_strs ) [EOL] [EOL] [EOL] def _deck_path ( deck_name ) : [EOL] return os . path . join ( _DECKS_DIRECTORY , deck_name ) [EOL] [EOL] [EOL] def serialize_deck ( deck , deck_name ) : [EOL] deck_of_cards = DeckOfCards ( cards = deck . cards ) [EOL] filepath = _deck_path ( deck_name ) [EOL] write_message_to_file ( deck_of_cards , filepath ) [EOL] [EOL] [EOL] def deserialize_deck ( deck_name ) : [EOL] deck_of_cards = read_message_from_file ( DeckOfCards ( ) , filepath = _deck_path ( deck_name ) ) [EOL] return Deck ( cards = deck_of_cards . cards ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , List [EOL] import deck [EOL] import typing [EOL] from deck import Deck , deserialize_deck , serialize_deck [EOL] from proto . cards_pb2 import Card [EOL] [EOL] TWENTYNINE_DECK_NAME = [string] [EOL] STANDARD_DECK_NAME = [string] [EOL] [EOL] [EOL] def create_standard_deck ( ) : [EOL] suits = [ [string] , [string] , [string] , [string] ] [EOL] labels = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] cards = [ ] [EOL] for suit in suits : [EOL] for rank , label in enumerate ( labels ) : [EOL] rank = rank + [number] [EOL] value = values [ label ] if label in values else [number] [EOL] cards . append ( Card ( label = label , suit = suit , rank = rank , value = value ) ) [EOL] return Deck ( cards = cards ) [EOL] [EOL] [EOL] def create_twentynine_deck ( ) : [EOL] suits = [ [string] , [string] , [string] , [string] ] [EOL] labels = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] values = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] cards = [ ] [EOL] for suit in suits : [EOL] for rank , label in enumerate ( labels ) : [EOL] rank = rank + [number] [EOL] value = values [ label ] if label in values else [number] [EOL] cards . append ( Card ( label = label , suit = suit , rank = rank , value = value ) ) [EOL] return Deck ( cards = cards ) [EOL] [EOL] [EOL] def serialize_twentynine_deck ( ) : [EOL] deck = create_twentynine_deck ( ) [EOL] serialize_deck ( deck , TWENTYNINE_DECK_NAME ) [EOL] [EOL] [EOL] def new_twentynine_deck ( ) : [EOL] return deserialize_deck ( TWENTYNINE_DECK_NAME ) [EOL] [EOL] [EOL] def serialize_standard_deck ( ) : [EOL] deck = create_standard_deck ( ) [EOL] serialize_deck ( deck , STANDARD_DECK_NAME ) [EOL] [EOL] [EOL] def new_standard_deck ( ) : [EOL] return deserialize_deck ( STANDARD_DECK_NAME ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $deck.Deck$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import proto [EOL] from copy import deepcopy [EOL] from random import randint , random , shuffle [EOL] from typing import List [EOL] [EOL] from proto . cards_pb2 import Card [EOL] [EOL] [EOL] class Player ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . cards = [ ] [EOL] [EOL] def add_card ( self , card ) : [EOL] self . cards . append ( deepcopy ( card ) ) [EOL] [EOL] def play ( self , trump_suit , played_cards ) : [EOL] cards_with_lead_suit = self . _cards_with_lead_suit ( played_cards ) [EOL] if len ( cards_with_lead_suit ) > [number] : [EOL] shuffle ( cards_with_lead_suit ) [EOL] card = self . cards . pop ( cards_with_lead_suit [ [number] ] ) [EOL] else : [EOL] shuffle ( self . cards ) [EOL] card = self . cards . pop ( ) [EOL] return card [EOL] [EOL] def _cards_with_lead_suit ( self , played_cards ) : [EOL] if len ( played_cards ) == [number] : [EOL] return [ ] [EOL] lead_card = played_cards [ [number] ] [EOL] return [ idx for idx in range ( len ( self . cards ) ) if self . cards [ idx ] . suit == lead_card . suit ] [EOL] [EOL] def bid ( self , current_bid , max_bid ) : [EOL] return randint ( current_bid + [number] , max_bid ) [EOL] [EOL] def will_bid ( self , current_bid , max_bid ) : [EOL] return random ( ) > [number] [EOL] [EOL] def set_trump ( self ) : [EOL] cards = deepcopy ( self . cards ) [EOL] shuffle ( cards ) [EOL] return cards [ [number] ] . suit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 $None$ 0 0 0 $proto.cards_pb2.Card$ 0 0 0 0 0 0 0 0 0 0 0 $proto.cards_pb2.Card$ 0 0 0 0 0 $proto.cards_pb2.Card$ 0 0 0 $builtins.str$ 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[proto.cards_pb2.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] from typing import Any [EOL] [EOL] from google . protobuf import text_format [comment] [EOL] [EOL] [EOL] [comment] [EOL] def write_message_to_file ( message , filepath ) : [EOL] with open ( filepath , [string] ) as f : [EOL] f . write ( text_format . MessageToString ( message ) ) [EOL] [EOL] [EOL] def read_message_from_file ( message , filepath ) : [EOL] with open ( filepath , [string] ) as f : [EOL] text_format . Parse ( f . read ( ) , message ) [EOL] return message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Set [EOL] import builtins [EOL] import deck [EOL] import player [EOL] import typing [EOL] import src [EOL] import proto [EOL] import sys [EOL] from typing import List , NamedTuple , Set [EOL] [EOL] from deck import Deck [EOL] from player import Player [EOL] from proto . cards_pb2 import Card [EOL] [EOL] _TEAMS = [ [string] , [string] ] [EOL] [EOL] [EOL] [comment] [EOL] class Bid ( NamedTuple ) : [EOL] player = ... [EOL] value = ... [EOL] [EOL] [EOL] _MAX_BID = [number] [EOL] _MIN_BID = [number] [EOL] NO_BID = Bid ( player = - [number] , value = _MIN_BID ) [EOL] TARGET_SCORE = [number] [EOL] [EOL] [EOL] class Game ( object ) : [EOL] [EOL] def __init__ ( self , deck , n_players = [number] ) : [EOL] if n_players > [number] : [EOL] raise ValueError ( [string] . format ( n_players ) ) [EOL] self . deck = deck [EOL] self . n_players = n_players [EOL] self . n_tricks = int ( deck . size / self . n_players ) [EOL] self . n_teams = len ( _TEAMS ) [EOL] self . _players = { i : Player ( ) for i in range ( n_players ) } [EOL] self . _dealer_index = n_players - [number] [EOL] self . _highest_bid = NO_BID [EOL] self . _trump_suit = [string] [EOL] self . _trick_points = { i : [number] for i in range ( n_players ) } [EOL] self . _game_points = { i : [number] for i in range ( self . n_teams ) } [EOL] [EOL] def player ( self , index ) : [EOL] return self . _players [ index ] [EOL] [EOL] def deal_hand ( self ) : [EOL] player_idx = [number] [EOL] for card in self . deck . deal ( ) : [EOL] self . player ( player_idx ) . add_card ( card ) [EOL] player_idx += [number] [EOL] player_idx = player_idx % self . n_players [EOL] [EOL] assert player_idx == [number] , [string] [EOL] [EOL] def arbitrate_bidding ( self ) : [EOL] highest_bid = NO_BID [EOL] [comment] [EOL] player_idx = self . _dealer_index [EOL] players_who_passed = set ( ) [EOL] while True : [EOL] player_idx += [number] [EOL] player_idx = player_idx % self . n_players [EOL] current_player = self . player ( player_idx ) [EOL] n_passed = len ( players_who_passed ) [EOL] [comment] [EOL] if n_passed == self . n_players : [EOL] break [EOL] [comment] [EOL] if ( n_passed == ( self . n_players - [number] ) ) and ( highest_bid != NO_BID ) : [EOL] break [EOL] [comment] [EOL] if highest_bid . value == _MAX_BID : [EOL] break [EOL] [comment] [EOL] if player_idx in players_who_passed : [EOL] continue [EOL] [comment] [EOL] if not current_player . will_bid ( highest_bid . value , _MAX_BID ) : [EOL] players_who_passed . add ( player_idx ) [EOL] continue [EOL] bid_value = current_player . bid ( highest_bid . value , _MAX_BID ) [EOL] assert bid_value >= highest_bid . value , [string] [EOL] assert bid_value <= _MAX_BID , [string] [EOL] highest_bid = Bid ( player = player_idx , value = bid_value ) [EOL] [EOL] return highest_bid [EOL] [EOL] def get_trump ( self ) : [EOL] highest_bidder = int ( self . _highest_bid . player ) [EOL] return self . player ( highest_bidder ) . set_trump ( ) [EOL] [EOL] def play_trick ( self ) : [EOL] starting_player = ( self . _dealer_index + [number] ) % self . n_players [EOL] played_cards = [ Card ( ) ] * [number] [EOL] for idx in range ( [number] ) : [EOL] player_idx = ( starting_player + idx ) % self . n_players [EOL] played_card = self . player ( player_idx ) . play ( self . _trump_suit , played_cards ) [EOL] played_cards [ player_idx ] = played_card [EOL] [EOL] lead_suit = played_cards [ starting_player ] . suit [EOL] winning_player = _winning_player_for_hand ( played_cards , lead_suit , self . _trump_suit ) [EOL] points = sum ( [ card . value for card in played_cards ] ) [EOL] self . _trick_points [ winning_player ] += points [EOL] [EOL] def score_hand ( self ) : [EOL] teams_points = { i : [number] for i in range ( self . n_teams ) } [EOL] for player_idx in range ( self . n_players ) : [EOL] team_idx = _team ( player_idx ) [EOL] players_points = self . _trick_points [ player_idx ] [EOL] teams_points [ team_idx ] += players_points [EOL] [EOL] bidding_team = _team ( self . _highest_bid . player ) [EOL] if teams_points [ bidding_team ] >= self . _highest_bid . value : [EOL] self . _game_points [ bidding_team ] += [number] [EOL] else : [EOL] other_team = ( bidding_team + [number] ) % len ( _TEAMS ) [EOL] self . _game_points [ other_team ] += [number] [EOL] assert len ( _TEAMS ) == [number] , [string] . format ( _TEAMS ) [EOL] [EOL] def play_hand ( self ) : [EOL] self . deal_hand ( ) [EOL] self . _highest_bid = self . arbitrate_bidding ( ) [EOL] self . _trump_suit = self . get_trump ( ) [EOL] for _ in range ( self . n_tricks ) : [EOL] self . play_trick ( ) [EOL] self . _dealer_index += [number] [EOL] self . score_hand ( ) [EOL] [EOL] def run ( self ) : [EOL] best_score = [number] [EOL] while best_score < TARGET_SCORE : [EOL] self . play_hand ( ) [EOL] best_score = max ( self . _game_points . values ( ) ) [EOL] for team_idx in self . _game_points . keys ( ) : [EOL] if self . _game_points [ team_idx ] == best_score : [EOL] return team_idx [EOL] assert False , [string] [EOL] [EOL] [EOL] def _team ( player_index ) : [EOL] return player_index % len ( _TEAMS ) [EOL] [EOL] [EOL] def _winning_player_with_suit ( suit , cards ) : [EOL] one_card_in_suit = any ( [ card . suit == suit for card in cards ] ) [EOL] if not one_card_in_suit : [EOL] raise ValueError ( [string] . format ( cards , suit ) ) [EOL] [EOL] n_players = len ( cards ) [EOL] winning_player = - [number] [EOL] lowest_rank = sys . maxsize [EOL] for player in range ( n_players ) : [EOL] if cards [ player ] . suit != suit : [EOL] continue [EOL] if cards [ player ] . rank < lowest_rank : [EOL] winning_player = player [EOL] lowest_rank = cards [ player ] . rank [EOL] assert winning_player > - [number] , [string] [EOL] return winning_player [EOL] [EOL] [EOL] def _winning_player_for_hand ( cards , lead_suit , trump_suit ) : [EOL] n_players = len ( cards ) [EOL] trump_played = any ( [ cards [ idx ] . suit == trump_suit for idx in range ( n_players ) ] ) [EOL] if trump_played : [EOL] winning_player = _winning_player_with_suit ( trump_suit , cards ) [EOL] else : [EOL] winning_player = _winning_player_with_suit ( lead_suit , cards ) [EOL] return winning_player [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $src.game.Bid$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $src.game.Bid$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Game.player.Player$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $Bid$ 0 0 0 0 0 $src.game.Bid$ 0 $src.game.Bid$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $src.game.Bid$ 0 $src.game.Bid$ 0 0 0 0 0 0 0 0 $src.game.Bid$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.game.Bid$ 0 0 0 $builtins.int$ 0 0 0 $typing.Set[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $src.game.Bid$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $src.game.Bid$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $src.game.Bid$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $src.game.Bid$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 $builtins.int$ 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from unittest import TestCase , mock [EOL] [EOL] from deck import Deck , deserialize_deck , serialize_deck [EOL] from proto . cards_pb2 import Card , DeckOfCards [EOL] [EOL] [EOL] class DeckTest ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . labels = map ( str , range ( [number] , [number] ) ) [EOL] self . suits = [ [string] , [string] , [string] ] [EOL] self . deck = create_deck ( self . labels , self . suits ) [EOL] [EOL] def test_create_deck ( self ) : [EOL] d = Deck ( cards = [ ] ) [EOL] [EOL] self . assertIsNotNone ( d ) [EOL] [EOL] def test_multiple_deals ( self ) : [EOL] first_count = [number] [EOL] for _ in self . deck . deal ( ) : [EOL] first_count += [number] [EOL] [EOL] second_count = [number] [EOL] for _ in self . deck . deal ( ) : [EOL] second_count += [number] [EOL] [EOL] self . assertTrue ( first_count > [number] ) [EOL] self . assertEqual ( first_count , second_count ) [EOL] [EOL] @ mock . patch ( [string] ) def test_deck_is_not_shuffled ( self , mock_shuffle ) : [EOL] shuffled_cards = list ( self . deck . deal ( ) ) [EOL] [EOL] for card , shuffled_card in zip ( self . deck . _cards , shuffled_cards ) : [EOL] self . assertEqual ( card . rank , shuffled_card . rank ) [EOL] self . assertEqual ( card . label , shuffled_card . label ) [EOL] self . assertEqual ( card . suit , shuffled_card . suit ) [EOL] [EOL] @ mock . patch ( [string] ) def test_serialize_deck ( self , mock_writer ) : [EOL] deck_storage_format = DeckOfCards ( cards = self . deck . cards ) [EOL] [EOL] serialize_deck ( self . deck , [string] ) [EOL] [EOL] mock_writer . assert_called_once_with ( deck_storage_format , mock . ANY ) [EOL] [EOL] @ mock . patch ( [string] ) def test_deserialize_deck ( self , mock_reader ) : [EOL] deck_storage_format = DeckOfCards ( cards = self . deck . cards ) [EOL] mock_reader . return_value = deck_storage_format [EOL] [EOL] deck = deserialize_deck ( [string] ) [EOL] [EOL] for card , read_card in zip ( self . deck . _cards , deck . cards ) : [EOL] self . assertEqual ( card . rank , read_card . rank ) [EOL] self . assertEqual ( card . label , read_card . label ) [EOL] self . assertEqual ( card . suit , read_card . suit ) [EOL] [EOL] [EOL] def create_deck ( labels , suits ) : [EOL] cards = [ ] [EOL] for label in labels : [EOL] for suit in suits : [EOL] card = Card ( label = label , suit = suit ) [EOL] cards . append ( card ) [EOL] return Deck ( cards = cards ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from unittest import TestCase , mock [EOL] [EOL] import player [EOL] from deck import Deck [EOL] from game import _MAX_BID , NO_BID , TARGET_SCORE , Bid , Game [EOL] from proto . cards_pb2 import Card [EOL] [EOL] [EOL] class TestGame ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . deck = create_deck ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_deal_evenly ( self ) : [EOL] n_players = [number] [EOL] game = Game ( self . deck , n_players = n_players ) [EOL] n_cards_expected = game . deck . size / n_players [EOL] [EOL] game . deal_hand ( ) [EOL] [EOL] for idx in range ( n_players ) : [EOL] n_cards_player = len ( game . player ( idx ) . cards ) [EOL] self . assertEqual ( n_cards_player , n_cards_expected ) [EOL] [EOL] def test_extra_cards_asserts ( self ) : [EOL] five_card_deck = create_deck ( [ [string] , [string] , [string] , [string] , [string] ] , [ [string] ] ) [EOL] game = Game ( five_card_deck , n_players = [number] ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] game . deal_hand ( ) [EOL] [EOL] def test_max_four_players ( self ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] Game ( self . deck , n_players = [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( player . Player , [string] ) def test_bid_arbitration_success ( self , mock_bid , mock_will_bid ) : [EOL] n_players = [number] [EOL] mock_bid . side_effect = [ _MAX_BID - [number] , _MAX_BID - [number] , _MAX_BID - [number] , _MAX_BID - [number] ] [EOL] mock_will_bid . side_effect = [ True ] * n_players + [ False ] * n_players [EOL] game = Game ( self . deck , n_players = n_players ) [EOL] [EOL] bid = game . arbitrate_bidding ( ) [EOL] [EOL] self . assertNotEqual ( bid , NO_BID ) [EOL] self . assertEqual ( bid . player , game . _dealer_index ) [EOL] self . assertTrue ( bid . value > [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_everyone_passes_bid ( self , mock_will_bid ) : [EOL] mock_will_bid . side_effect = [ False ] * [number] [EOL] game = Game ( self . deck , n_players = [number] ) [EOL] [EOL] bid = game . arbitrate_bidding ( ) [EOL] [EOL] self . assertEqual ( bid , NO_BID ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( player . Player , [string] ) def test_player_bids_max ( self , mock_bid , mock_will_bid ) : [EOL] n_players = [number] [EOL] high_bidder = [number] [EOL] bids = [ [number] ] * n_players [EOL] bids [ high_bidder ] = _MAX_BID [EOL] mock_will_bid . side_effect = [ True ] * n_players [EOL] mock_bid . side_effect = bids [EOL] game = Game ( self . deck , n_players = n_players ) [EOL] [EOL] bid = game . arbitrate_bidding ( ) [EOL] [EOL] self . assertEqual ( bid . player , high_bidder ) [EOL] self . assertEqual ( bid . value , _MAX_BID ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( player . Player , [string] ) def test_low_bid_asserts ( self , mock_bid , mock_will_bid ) : [EOL] n_players = [number] [EOL] mock_will_bid . side_effect = [ True ] * [number] [EOL] mock_bid . side_effect = [ [number] ] * [number] [EOL] game = Game ( self . deck , n_players = n_players ) [EOL] [EOL] with self . assertRaises ( AssertionError ) : [EOL] game . arbitrate_bidding ( ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( player . Player , [string] ) def test_set_trump ( self , mock_set_trump , mock_bid , mock_will_bid ) : [EOL] n_players = [number] [EOL] mock_bid . side_effect = [ _MAX_BID - [number] , _MAX_BID - [number] , _MAX_BID - [number] , _MAX_BID - [number] ] [EOL] mock_will_bid . side_effect = [ True ] * n_players + [ False ] * n_players [EOL] trump_suit = [string] [EOL] mock_set_trump . return_value = trump_suit [EOL] game = Game ( self . deck , n_players = n_players ) [EOL] [EOL] game . play_hand ( ) [EOL] [EOL] self . assertEqual ( game . _trump_suit , trump_suit ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_trump_played_highest_trump_wins ( self , mock_play ) : [EOL] trump_card = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] a_diamond = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_spade = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_hearts = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] cards = [ bad_spade , trump_card , a_diamond , bad_hearts ] [EOL] mock_play . side_effect = cards [EOL] game = create_game ( cards , n_players = [number] ) [EOL] game . _trump_suit = [string] [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_trick ( ) [EOL] [EOL] self . assertEqual ( game . _trick_points [ [number] ] , points ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_trump_lead_highest_trump_wins ( self , mock_play ) : [EOL] trump_card = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] a_diamond = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_spade = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_hearts = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] cards = [ trump_card , bad_spade , a_diamond , bad_hearts ] [EOL] mock_play . side_effect = cards [EOL] game = create_game ( cards , n_players = [number] ) [EOL] game . _trump_suit = [string] [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_trick ( ) [EOL] [EOL] self . assertEqual ( game . _trick_points [ [number] ] , points ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_multiple_trumps_highest_trump_wins ( self , mock_play ) : [EOL] high_trump = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] low_trump = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_spade = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] bad_hearts = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] cards = [ low_trump , bad_spade , high_trump , bad_hearts ] [EOL] mock_play . side_effect = cards [EOL] game = create_game ( cards , n_players = [number] ) [EOL] game . _trump_suit = [string] [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_trick ( ) [EOL] [EOL] self . assertEqual ( game . _trick_points [ [number] ] , points ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_no_trump_all_one_suit_highest_wins ( self , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = [number] - i ) for i in range ( [number] ) ] [EOL] mock_play . side_effect = cards [EOL] game = create_game ( cards , n_players = [number] ) [EOL] game . _trump_suit = [string] [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_trick ( ) [EOL] [EOL] self . assertEqual ( game . _trick_points [ [number] ] , points ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) def test_no_trump_highest_lead_suit_wins ( self , mock_play ) : [EOL] a = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] b = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] c = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] d = Card ( label = [string] , suit = [string] , rank = [number] , value = [number] ) [EOL] cards = [ a , b , c , d ] [EOL] mock_play . side_effect = cards [EOL] game = create_game ( cards , n_players = [number] ) [EOL] game . _trump_suit = [string] [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_trick ( ) [EOL] [EOL] self . assertEqual ( game . _trick_points [ [number] ] , points ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( Game , [string] ) def test_multiple_tricks_scored_correctly ( self , mock_get_trump , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = [number] - i ) for i in range ( [number] ) ] * [number] [EOL] mock_play . side_effect = cards [EOL] mock_get_trump . return_value = [string] [EOL] game = create_game ( cards , n_players = [number] ) [EOL] points = sum ( [ card . value for card in cards ] ) [EOL] [EOL] game . play_hand ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] self . assertEqual ( game . _trick_points [ i ] , points / [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( Game , [string] ) def test_makes_bid ( self , mock_get_trump , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = [number] - i ) for i in range ( [number] ) ] [EOL] mock_play . side_effect = cards * [number] [EOL] game = create_game ( cards , n_players = [number] ) [EOL] mock_get_trump . return_value = [string] [EOL] points_per_player = sum ( [ card . value for card in cards ] ) [EOL] game . _highest_bid = Bid ( player = [number] , value = points_per_player * [number] ) [EOL] [EOL] game . play_hand ( ) [EOL] [EOL] self . assertEqual ( game . _game_points [ [number] ] , [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( Game , [string] ) @ mock . patch . object ( Game , [string] ) def test_doesnt_make_bid ( self , mock_get_trump , mock_arbitrate_bidding , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = [number] - i ) for i in range ( [number] ) ] [EOL] points_per_player = sum ( [ card . value for card in cards ] ) [EOL] mock_play . side_effect = cards * [number] [EOL] mock_arbitrate_bidding . return_value = Bid ( player = [number] , value = ( points_per_player * [number] ) + [number] ) [EOL] mock_get_trump . return_value = [string] [EOL] game = create_game ( cards , n_players = [number] ) [EOL] [EOL] game . play_hand ( ) [EOL] [EOL] self . assertEqual ( game . _game_points [ [number] ] , [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( Game , [string] ) @ mock . patch . object ( Game , [string] ) def test_team_wins_every_hand ( self , mock_get_trump , mock_arbitrate_bidding , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = i ) for i in range ( [number] ) ] [EOL] points_per_player = sum ( [ card . value for card in cards ] ) [EOL] mock_play . side_effect = cards * [number] * TARGET_SCORE [EOL] mock_arbitrate_bidding . return_value = Bid ( player = [number] , value = ( points_per_player * [number] ) ) [EOL] mock_get_trump . return_value = [string] [EOL] game = create_game ( cards , n_players = [number] ) [EOL] [EOL] winning_team = game . run ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( winning_team , [number] ) [EOL] [EOL] @ mock . patch . object ( player . Player , [string] ) @ mock . patch . object ( Game , [string] ) @ mock . patch . object ( Game , [string] ) def test_team_loses_every_hand ( self , mock_get_trump , mock_arbitrate_bidding , mock_play ) : [EOL] cards = [ Card ( label = str ( i ) , suit = [string] , rank = i , value = i ) for i in range ( [number] ) ] [EOL] points_per_player = sum ( [ card . value for card in cards ] ) [EOL] mock_play . side_effect = cards * [number] * TARGET_SCORE [EOL] mock_arbitrate_bidding . return_value = Bid ( player = [number] , value = ( points_per_player * [number] ) ) [EOL] mock_get_trump . return_value = [string] [EOL] game = create_game ( cards , n_players = [number] ) [EOL] [EOL] winning_team = game . run ( ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( winning_team , [number] ) [EOL] [EOL] [EOL] def create_deck ( labels , suits ) : [EOL] cards = [ ] [EOL] for label in labels : [EOL] for suit in suits : [EOL] card = Card ( label = label , suit = suit ) [EOL] cards . append ( card ) [EOL] return Deck ( cards ) [EOL] [EOL] [EOL] def create_game ( cards , n_players ) : [EOL] deck = Deck ( cards ) [EOL] return Game ( deck , n_players ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from player import Player [EOL] from proto . cards_pb2 import Card [EOL] [EOL] [EOL] class TestPlayer ( TestCase ) : [EOL] [EOL] def test_play_hand ( self ) : [EOL] player = create_player ( ) [EOL] [EOL] for _ in range ( len ( player . cards ) ) : [EOL] card = player . play ( trump_suit = [string] , played_cards = [ ] ) [EOL] self . assertNotIn ( card , player . cards ) [EOL] [EOL] def test_hand_empty_asserts ( self ) : [EOL] player = create_player ( ) [EOL] [EOL] for _ in range ( len ( player . cards ) ) : [EOL] player . play ( trump_suit = [string] , played_cards = [ ] ) [EOL] [EOL] with self . assertRaises ( IndexError ) : [EOL] player . play ( trump_suit = [string] , played_cards = [ ] ) [EOL] [EOL] def test_bid ( self ) : [EOL] player = create_player ( ) [EOL] [EOL] bid = player . bid ( [number] , [number] ) [EOL] [EOL] self . assertLessEqual ( bid , [number] ) [EOL] self . assertGreaterEqual ( bid , [number] ) [EOL] [EOL] def test_follow_suit ( self ) : [EOL] player = create_player ( ) [EOL] card1 = Card ( label = [string] , suit = [string] ) [EOL] card2 = Card ( label = [string] , suit = [string] ) [EOL] [EOL] card = player . play ( trump_suit = card1 . suit , played_cards = [ card1 , card2 ] ) [EOL] [EOL] self . assertEqual ( card . suit , card1 . suit ) [EOL] [EOL] def test_play_has_no_lead_suit ( self ) : [EOL] player = create_player ( ) [EOL] [EOL] card = player . play ( trump_suit = [string] , played_cards = [ ] ) [EOL] [EOL] self . assertIsNotNone ( card ) [EOL] [EOL] [EOL] def create_player ( labels = ( [string] , [string] , [string] ) , suits = ( [string] , [string] , [string] ) ) : [EOL] player = Player ( ) [EOL] for label in labels : [EOL] for suit in suits : [EOL] card = Card ( label = label , suit = suit ) [EOL] player . add_card ( card ) [EOL] return player [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from unittest import TestCase [EOL] [EOL] from deck_builder import create_standard_deck , create_twentynine_deck [EOL] [EOL] [EOL] class TestDeckBuilder ( TestCase ) : [EOL] [EOL] def test_create_deck ( self ) : [EOL] d = create_twentynine_deck ( ) [EOL] [EOL] self . assertIsNotNone ( d ) [EOL] [EOL] def test_29_deck_size ( self ) : [EOL] d = create_twentynine_deck ( ) [EOL] [EOL] cards = list ( d . deal ( ) ) [EOL] [EOL] self . assertEqual ( len ( cards ) , [number] ) [EOL] [EOL] def test_standard_deck_size ( self ) : [EOL] d = create_standard_deck ( ) [EOL] [EOL] cards = list ( d . deal ( ) ) [EOL] [EOL] self . assertEqual ( len ( cards ) , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0