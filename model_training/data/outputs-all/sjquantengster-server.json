from typing import Dict , Any [EOL] import typing [EOL] from functools import wraps [EOL] import json [EOL] import asyncio [EOL] [EOL] from alembic . config import Config [EOL] import click [EOL] [EOL] from app import config , create_app [EOL] [EOL] [EOL] def coroutine ( f ) : [EOL] [docstring] [EOL] [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] return asyncio . run ( f ( * args , ** kwargs ) ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ click . group ( ) def cli ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) def current ( ) : [EOL] [docstring] [EOL] from alembic . command import current [EOL] [EOL] alembic_ini_path = [string] [EOL] alembic_cfg = Config ( alembic_ini_path ) [EOL] [EOL] current ( alembic_cfg ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) def migrationshistory ( ) : [EOL] [docstring] [EOL] from alembic . command import history [EOL] [EOL] alembic_ini_path = [string] [EOL] alembic_cfg = Config ( alembic_ini_path ) [EOL] [EOL] history ( alembic_cfg ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) @ click . option ( [string] , help = [string] ) def makemigrations ( m ) : [EOL] [docstring] [EOL] from alembic . command import revision [EOL] [EOL] alembic_ini_path = [string] [EOL] alembic_cfg = Config ( alembic_ini_path ) [EOL] alembic_cfg . set_main_option ( [string] , config . DB_URL ) [EOL] [EOL] revision_kwargs = { [string] : True } [EOL] if m is not None : [EOL] revision_kwargs [ [string] ] = m [EOL] revision ( alembic_cfg , ** revision_kwargs ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) def migrate ( ) : [EOL] [docstring] [EOL] from alembic . command import upgrade [EOL] [EOL] alembic_ini_path = [string] [EOL] alembic_cfg = Config ( alembic_ini_path ) [EOL] alembic_cfg . set_main_option ( [string] , config . DB_URL ) [EOL] [EOL] upgrade ( alembic_cfg , [string] ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) @ click . argument ( [string] , default = [string] ) def downgrade ( revision ) : [EOL] [docstring] [EOL] from alembic . command import downgrade [EOL] [EOL] alembic_ini_path = [string] [EOL] alembic_cfg = Config ( alembic_ini_path ) [EOL] alembic_cfg . set_main_option ( [string] , config . DB_URL ) [EOL] [EOL] downgrade ( alembic_cfg , revision ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) @ coroutine async def init ( ) : [EOL] [docstring] [EOL] from app import db [EOL] from app . db_models import Category [EOL] from app . db_models import Genre [EOL] [EOL] await db . set_bind ( config . DB_URL ) [EOL] [EOL] with open ( [string] ) as f : [EOL] categories = json . loads ( f . read ( ) ) [EOL] [EOL] [comment] [EOL] await Category . insert ( ) . gino . all ( * categories ) [EOL] [EOL] with open ( [string] ) as f : [EOL] genres = json . loads ( f . read ( ) ) [EOL] [EOL] [comment] [EOL] await Genre . insert ( ) . gino . all ( * genres ) [EOL] [EOL] [EOL] @ cli . command ( help = [string] ) def runserver ( ) : [EOL] app = create_app ( ) [EOL] app . run ( host = [string] , port = [number] , debug = True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cli ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import uuid [EOL] import app [EOL] import typing [EOL] import builtins [EOL] from uuid import UUID [EOL] from datetime import datetime [EOL] [EOL] from pydantic import BaseModel , SecretStr , validator [EOL] [EOL] from app import config [EOL] from app . utils import get_photo_url [EOL] [EOL] [EOL] class UserModel ( BaseModel ) : [EOL] id = ... [EOL] email = ... [EOL] nickname = [string] [EOL] password_hash = SecretStr [EOL] photo = None [EOL] is_admin = False [EOL] [EOL] class Config : [EOL] orm_mode = True [EOL] [EOL] @ validator ( [string] , pre = True , always = True ) def get_photo ( cls , v , * , values , ** kwargs ) : [EOL] return get_photo_url ( v , media_url = config . MEDIA_URL ) [EOL] [EOL] [EOL] class TranslationModel ( BaseModel ) : [EOL] id = ... [EOL] translation = ... [EOL] line_id = ... [EOL] translator_id = ... [EOL] created_at = ... [EOL] updated_at = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $uuid.UUID$ 0 0 0 $datetime.datetime$ 0 0 0 $datetime.datetime$ 0 0 0
from typing import Dict , List , Tuple , Set , Optional , Any [EOL] import sqlalchemy [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple , Any , List , Set , Optional [EOL] from enum import Enum [EOL] from types import GeneratorType [EOL] from uuid import UUID [EOL] import datetime [EOL] import math [EOL] import uuid [EOL] import jwt [EOL] [EOL] from sqlalchemy . sql . elements import BinaryExpression [EOL] from pydantic import BaseModel [EOL] from pydantic . json import ENCODERS_BY_TYPE [EOL] from sanic . response import json [EOL] from sanic_jwt_extended . jwt_manager import JWT [EOL] from sanic_jwt_extended . tokens import Token [EOL] [EOL] from app import db [EOL] [EOL] [EOL] Token . JWT = JWT [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def jsonable_encoder ( obj , include = None , exclude = set ( ) , by_alias = True , skip_defaults = False , include_none = True , custom_encoder = { } , sqlalchemy_safe = True , ) : [EOL] if include is not None and not isinstance ( include , set ) : [EOL] include = set ( include ) [EOL] if exclude is not None and not isinstance ( exclude , set ) : [EOL] exclude = set ( exclude ) [EOL] if isinstance ( obj , BaseModel ) : [EOL] encoder = getattr ( obj . Config , [string] , custom_encoder ) [EOL] return jsonable_encoder ( obj . dict ( include = include , exclude = exclude , by_alias = by_alias , skip_defaults = skip_defaults , ) , include_none = include_none , custom_encoder = encoder , sqlalchemy_safe = sqlalchemy_safe , ) [EOL] if isinstance ( obj , UUID ) : [EOL] return str ( obj ) [EOL] if isinstance ( obj , Enum ) : [EOL] return obj . value [EOL] if isinstance ( obj , ( str , int , float , type ( None ) ) ) : [EOL] return obj [EOL] if isinstance ( obj , dict ) : [EOL] encoded_dict = { } [EOL] for key , value in obj . items ( ) : [EOL] if ( ( not sqlalchemy_safe or ( not isinstance ( key , str ) ) or ( not key . startswith ( [string] ) ) ) [EOL] and ( value is not None or include_none ) [EOL] and ( ( include and key in include ) or key not in exclude ) ) : [EOL] encoded_key = jsonable_encoder ( key , by_alias = by_alias , skip_defaults = skip_defaults , include_none = include_none , custom_encoder = custom_encoder , sqlalchemy_safe = sqlalchemy_safe , ) [EOL] encoded_value = jsonable_encoder ( value , by_alias = by_alias , skip_defaults = skip_defaults , include_none = include_none , custom_encoder = custom_encoder , sqlalchemy_safe = sqlalchemy_safe , ) [EOL] encoded_dict [ encoded_key ] = encoded_value [EOL] return encoded_dict [EOL] if isinstance ( obj , ( list , set , frozenset , GeneratorType , tuple ) ) : [EOL] encoded_list = [ ] [EOL] for item in obj : [EOL] encoded_list . append ( jsonable_encoder ( item , include = include , exclude = exclude , by_alias = by_alias , skip_defaults = skip_defaults , include_none = include_none , custom_encoder = custom_encoder , sqlalchemy_safe = sqlalchemy_safe , ) ) [EOL] return encoded_list [EOL] errors = [ ] [EOL] try : [EOL] if custom_encoder and type ( obj ) in custom_encoder : [EOL] encoder = custom_encoder [ type ( obj ) ] [EOL] else : [EOL] encoder = ENCODERS_BY_TYPE [ type ( obj ) ] [EOL] return encoder ( obj ) [EOL] except KeyError as e : [EOL] errors . append ( e ) [EOL] try : [EOL] data = dict ( obj ) [EOL] except Exception as e : [EOL] errors . append ( e ) [EOL] try : [EOL] data = vars ( obj ) [EOL] except Exception as e : [EOL] errors . append ( e ) [EOL] raise ValueError ( errors ) [EOL] return jsonable_encoder ( data , by_alias = by_alias , skip_defaults = skip_defaults , include_none = include_none , custom_encoder = custom_encoder , sqlalchemy_safe = sqlalchemy_safe , ) [EOL] [EOL] [EOL] def JsonResponse ( obj = None , status = [number] , headers = None , content_type = [string] , ** kwargs , ) : [EOL] return json ( jsonable_encoder ( obj , ** kwargs ) , ensure_ascii = False , headers = headers , status = status , content_type = content_type , ) [EOL] [EOL] [EOL] async def calc_max_page ( page_size , condition ) : [EOL] [docstring] [EOL] try : [EOL] count = await db . select ( [ db . func . count ( ) ] ) . where ( condition ) . gino . scalar ( ) [EOL] except AttributeError : [EOL] return [number] , [number] [EOL] return math . ceil ( count / page_size ) , count [EOL] [EOL] [EOL] def validate_file_size ( file_body , file_size = [number] ) : [EOL] if len ( file_body ) < [number] : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def get_csrf_token ( encoded_token ) : [EOL] token = Token ( encoded_token ) [EOL] print ( token . __dict__ ) [EOL] return token . csrf [EOL] [EOL] [EOL] [comment] [EOL] def encode_jwt ( cls , token_type , payload , expires_delta ) : [EOL] algorithm = cls . config . algorithm [EOL] secret = ( cls . config . secret_key if algorithm . startswith ( [string] ) else cls . config . private_key ) [EOL] [EOL] iss = payload . pop ( [string] ) if payload . get ( [string] ) else cls . config . default_iss [EOL] aud = payload . pop ( [string] ) if payload . get ( [string] ) else cls . config . default_aud [EOL] iat = datetime . datetime . utcnow ( ) [EOL] nbf = payload . pop ( [string] ) if payload . get ( [string] ) else iat [EOL] jti = uuid . uuid4 ( ) . hex [EOL] [EOL] reserved_claims = { [string] : iss , [string] : aud , [string] : jti , [string] : iat , [string] : nbf } [EOL] [EOL] if isinstance ( expires_delta , datetime . timedelta ) : [EOL] reserved_claims [ [string] ] = iat + expires_delta [EOL] [EOL] if [string] in cls . config . token_location and cls . config . csrf_protect : [EOL] reserved_claims [ [string] ] = jti [EOL] [EOL] payload . update ( reserved_claims ) [EOL] payload = { k : v for k , v in payload . items ( ) if v is not None } [EOL] [EOL] header = { [string] : token_type } [EOL] [EOL] token = jwt . encode ( payload , secret , algorithm , header , cls . config . json_encoder ) . decode ( [string] ) [EOL] [EOL] return token [EOL] [EOL] [EOL] def set_access_cookies ( response , encoded_access_token , max_age = None ) : [EOL] [docstring] [EOL] access_cookie_key = JWT . config . jwt_cookie [EOL] response . cookies [ access_cookie_key ] = encoded_access_token [EOL] access_cookie = response . cookies [ access_cookie_key ] [EOL] access_cookie [ [string] ] = max_age or [number] [comment] [EOL] access_cookie [ [string] ] = True [EOL] access_cookie [ [string] ] = [string] [EOL] if JWT . config . cookie_domain : [EOL] access_cookie [ [string] ] = JWT . config . cookie_domain [EOL] [EOL] if JWT . config . csrf_protect : [EOL] access_cookie_csrf_key = JWT . config . jwt_csrf_header [EOL] response . cookies [ access_cookie_csrf_key ] = get_csrf_token ( encoded_access_token ) [EOL] access_csrf_cookie = response . cookies [ access_cookie_csrf_key ] [EOL] access_csrf_cookie [ [string] ] = max_age or [number] [EOL] access_csrf_cookie [ [string] ] = False [EOL] access_csrf_cookie [ [string] ] = [string] [EOL] if JWT . config . cookie_domain : [EOL] access_csrf_cookie [ [string] ] = JWT . config . cookie_domain [EOL] [EOL] [EOL] def set_refresh_cookies ( response , encoded_refresh_token , max_age = None ) : [EOL] [docstring] [EOL] refresh_cookie_key = JWT . config . refresh_jwt_cookie [EOL] response . cookies [ refresh_cookie_key ] = encoded_refresh_token [EOL] refresh_cookie = response . cookies [ refresh_cookie_key ] [EOL] refresh_cookie [ [string] ] = max_age or [number] [comment] [EOL] refresh_cookie [ [string] ] = True [EOL] refresh_cookie [ [string] ] = [string] [EOL] if JWT . config . cookie_domain : [EOL] refresh_cookie [ [string] ] = JWT . config . cookie_domain [EOL] [EOL] if JWT . config . csrf_protect : [EOL] refresh_cookie_csrf_key = JWT . config . refresh_jwt_csrf_header [EOL] response . cookies [ refresh_cookie_csrf_key ] = get_csrf_token ( encoded_refresh_token ) [EOL] refresh_csrf_cookie = response . cookies [ refresh_cookie_csrf_key ] [EOL] refresh_csrf_cookie [ [string] ] = max_age or [number] [EOL] refresh_csrf_cookie [ [string] ] = False [EOL] refresh_csrf_cookie [ [string] ] = [string] [EOL] if JWT . config . cookie_domain : [EOL] refresh_csrf_cookie [ [string] ] = JWT . config . cookie_domain [EOL] [EOL] [EOL] def get_photo_url ( path , * , media_url = [string] ) : [EOL] if not path or path . startswith ( [string] ) : [EOL] return path [EOL] else : [EOL] return f"{ media_url } [string] { path }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import aiohttp [EOL] from sanic import Sanic [EOL] from gino . ext . sanic import Gino [EOL] from sanic_cors import CORS [EOL] from sanic_jwt_extended . jwt_manager import JWT [EOL] [EOL] from app import config [EOL] [EOL] db = Gino ( ) [EOL] [EOL] [EOL] def init_jwt ( app ) : [EOL] from app . utils import encode_jwt [EOL] [EOL] JWT . _encode_jwt = classmethod ( encode_jwt ) [EOL] with JWT . initialize ( app ) as manager : [EOL] manager . config . public_claim_namespace = config . JWT [ [string] ] [EOL] manager . config . private_claim_prefix = config . JWT [ [string] ] [EOL] manager . config . secret_key = config . JWT [ [string] ] [EOL] manager . config . token_location = config . JWT [ [string] ] [EOL] manager . config . access_token_expires = config . JWT [ [string] ] [EOL] manager . config . cookie_secure = config . JWT [ [string] ] [EOL] manager . config . jwt_csrf_header = config . JWT [ [string] ] [EOL] manager . config . refresh_jwt_csrf_header = config . JWT [ [string] ] [EOL] manager . config . csrf_protect = config . JWT [ [string] ] [EOL] manager . config . cookie_domain = config . JWT [ [string] ] [EOL] [EOL] [EOL] def init_oauth ( app ) : [EOL] @ app . listener ( [string] ) async def init_aiohttp_session ( sanic_app , _loop ) : [EOL] sanic_app . async_session = aiohttp . ClientSession ( ) [EOL] [EOL] @ app . listener ( [string] ) async def close_aiohttp_session ( sanic_app , _loop ) : [EOL] await sanic_app . async_session . close ( ) [EOL] [EOL] [EOL] def create_app ( ) : [EOL] [docstring] [EOL] app = Sanic ( ) [EOL] app . config . from_object ( config ) [EOL] init_oauth ( app ) [EOL] init_jwt ( app ) [EOL] [EOL] CORS ( app ) [EOL] db . init_app ( app ) [EOL] from app import views [EOL] [EOL] views . init_app ( app ) [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pydantic [EOL] import typing [EOL] from functools import wraps [EOL] import asyncio [EOL] import uuid [EOL] [EOL] from sanic . request import Request [EOL] from pydantic import create_model , BaseModel [EOL] [EOL] [EOL] def _get_request ( * args ) : [EOL] [docstring] [EOL] if isinstance ( args [ [number] ] , Request ) : [EOL] request = args [ [number] ] [EOL] else : [EOL] request = args [ [number] ] [EOL] return request [EOL] [EOL] [EOL] def expect_query ( ** field_definitions ) : [EOL] def actual_expect_query ( func ) : [EOL] model = create_model ( f" [string] { uuid . uuid4 ( ) . hex }" , ** field_definitions ) [EOL] [EOL] @ wraps ( func ) async def wrapper ( * args , ** kwargs ) : [EOL] request = _get_request ( * args ) [EOL] processed = model ( ** dict ( request . query_args ) ) . dict ( ) [EOL] kwargs . update ( processed ) [EOL] if asyncio . iscoroutinefunction ( func ) : [EOL] return await func ( * args , ** kwargs ) [EOL] else : [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return actual_expect_query [EOL] [EOL] [EOL] def expect_body ( ** field_definitions ) : [EOL] def actual_expect_body ( func ) : [EOL] model = create_model ( f" [string] { uuid . uuid4 ( ) . hex }" , ** field_definitions ) [EOL] [EOL] @ wraps ( func ) async def wrapper ( * args , ** kwargs ) : [EOL] request = _get_request ( * args ) [EOL] processed = model ( ** request . json ) . dict ( ) [EOL] [comment] [EOL] request . parsed_json = processed [EOL] if asyncio . iscoroutinefunction ( func ) : [EOL] return await func ( * args , ** kwargs ) [EOL] else : [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return actual_expect_body [EOL] [EOL] [EOL] def expect_query_with_model ( model ) : [EOL] def actual_expect_query ( func ) : [EOL] @ wraps ( func ) async def wrapper ( * args , ** kwargs ) : [EOL] request = _get_request ( * args ) [EOL] processed = model ( ** dict ( request . query_args ) ) . dict ( ) [EOL] kwargs . update ( processed ) [EOL] if asyncio . iscoroutinefunction ( func ) : [EOL] return await func ( * args , ** kwargs ) [EOL] else : [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return actual_expect_query [EOL] [EOL] [EOL] def expect_body_with_model ( model ) : [EOL] def actual_expect_body ( func ) : [EOL] @ wraps ( func ) async def wrapper ( * args , ** kwargs ) : [EOL] request = _get_request ( * args ) [EOL] processed = model ( ** request . json ) . dict ( ) [EOL] [comment] [EOL] request . parsed_json = processed [EOL] if asyncio . iscoroutinefunction ( func ) : [EOL] return await func ( * args , ** kwargs ) [EOL] else : [EOL] return func ( * args , ** kwargs ) [EOL] [EOL] return wrapper [EOL] [EOL] return actual_expect_body [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class UnsupportedExtension ( Exception ) : [EOL] def __init__ ( self , msg = [string] ) : [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class InvalidDataFrame ( Exception ) : [EOL] def __init__ ( self , msg = [string] ) : [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class DataDoesNotExist ( Exception ) : [EOL] def __init__ ( self , msg = [string] ) : [EOL] super ( ) . __init__ ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , Optional [EOL] import app [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from sanic . exceptions import ServerError [EOL] from sanic . views import HTTPMethodView [EOL] [EOL] from app import db [EOL] from . view_mixins import ( ListModelMixin , CreateModelMixin , RetrieveModelMixin , UpdateModelMixin , DestroyModelMixin , ) [EOL] [EOL] [EOL] class APIView ( HTTPMethodView ) : [EOL] [EOL] model = None [EOL] lookup_field = None [EOL] [EOL] def get_query ( self , request , * args , ** kwargs ) : [EOL] [EOL] query = self . model . query [EOL] [EOL] assert query is not None , ( [string] [string] % self . __class__ . __name__ ) [EOL] return query [EOL] [EOL] async def get_object ( self , * args , ** kwargs ) : [EOL] [EOL] lookup_field = self . lookup_field or [string] [EOL] try : [EOL] field = getattr ( self . model , lookup_field ) [EOL] except AttributeError : [EOL] raise AssertionError ( [string] [string] % self . __class__ . __name__ ) [EOL] [EOL] obj = await self . model . query . where ( field == kwargs [ lookup_field ] ) . gino . first ( ) [EOL] if obj is None : [EOL] raise ServerError ( [string] , status_code = [number] ) [EOL] return obj [EOL] [EOL] [EOL] class ListAPIView ( APIView , ListModelMixin , CreateModelMixin ) : [EOL] async def get ( self , request , * args , ** kwargs ) : [EOL] resp = await self . list ( request , * args , ** kwargs ) [EOL] return resp [EOL] [EOL] async def post ( self , request , * args , ** kwargs ) : [EOL] resp = await self . create ( request , * args , ** kwargs ) [EOL] return resp [EOL] [EOL] [EOL] class DetailAPIView ( APIView , RetrieveModelMixin , UpdateModelMixin , DestroyModelMixin ) : [EOL] async def get ( self , request , * args , ** kwargs ) : [EOL] resp = await self . retrieve ( request , * args , ** kwargs ) [EOL] return resp [EOL] [EOL] async def put ( self , request , * args , ** kwargs ) : [EOL] resp = await self . update ( request , * args , ** kwargs ) [EOL] return resp [EOL] [EOL] async def delete ( self , request , * args , ** kwargs ) : [EOL] resp = await self . destroy ( request , * args , ** kwargs ) [EOL] return resp [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
	0
from typing import Dict , Tuple , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Tuple [EOL] [EOL] [EOL] from app . utils import JsonResponse [EOL] [EOL] [EOL] class CreateModelMixin : [EOL] [docstring] [EOL] [EOL] async def create ( self , request , * args , ** kwargs ) : [EOL] instance = self . model ( ** request . json ) [EOL] await instance . create ( ) [EOL] return JsonResponse ( instance . to_dict ( ) , status = [number] ) [EOL] [EOL] [EOL] class ListModelMixin : [EOL] [docstring] [EOL] [EOL] pagination = True [EOL] page_size = [number] [EOL] [EOL] def get_paginated_query ( self , query , page = [number] ) : [EOL] [EOL] if not self . pagination : [EOL] return query [EOL] offset = ( page - [number] ) * self . page_size [EOL] return query . limit ( self . page_size ) . offset ( offset ) [EOL] [EOL] async def list ( self , request , * args , ** kwargs ) : [EOL] [EOL] page = kwargs . pop ( [string] , [number] ) [EOL] query = self . get_paginated_query ( self . get_query ( request , * args , ** kwargs ) , page = page ) [EOL] data = await query . gino . all ( ) [EOL] return JsonResponse ( [ each . to_dict ( ) for each in data ] , status = [number] ) [EOL] [EOL] [EOL] class RetrieveModelMixin : [EOL] [docstring] [EOL] [EOL] async def retrieve ( self , request , * args , ** kwargs ) : [EOL] return_obj = kwargs . pop ( [string] , False ) [EOL] instance = await self . get_object ( * args , ** kwargs ) [EOL] if return_obj : [EOL] return instance [EOL] else : [EOL] return JsonResponse ( instance . to_dict ( ) , status = [number] ) [EOL] [EOL] [EOL] class UpdateModelMixin : [EOL] [docstring] [EOL] [EOL] async def update ( self , request , * args , ** kwargs ) : [EOL] return_obj = kwargs . pop ( [string] , False ) [EOL] instance = await self . get_object ( * args , ** kwargs ) [EOL] data = { key : value for key , value in request . json . items ( ) if value is not None } [EOL] await instance . update ( ** data ) . apply ( ) [EOL] if return_obj : [EOL] return instance [EOL] else : [EOL] return JsonResponse ( instance . to_dict ( ) , status = [number] ) [EOL] [EOL] [EOL] class DestroyModelMixin : [EOL] [docstring] [EOL] [EOL] async def destroy ( self , request , * args , ** kwargs ) : [EOL] return_obj = kwargs . pop ( [string] , False ) [EOL] instance = await self . get_object ( * args , ** kwargs ) [EOL] await instance . delete ( ) [EOL] if return_obj : [EOL] return instance [EOL] else : [EOL] return JsonResponse ( status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Optional [EOL] import uuid [EOL] import app [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] import secrets [EOL] import random [EOL] import uuid [EOL] [EOL] from app . db_models import User [EOL] [EOL] [EOL] def generate_random_characters ( prefix_length = [number] , suffix_length = [number] ) : [EOL] [docstring] [EOL] allowed_prefix_chars = [string] [EOL] allowed_suffix_chars = [string] [EOL] [EOL] prefix = [string] . join ( secrets . choice ( allowed_prefix_chars ) for i in range ( prefix_length ) ) [EOL] suffix = [string] . join ( secrets . choice ( allowed_suffix_chars ) for i in range ( suffix_length ) ) [EOL] return prefix + suffix [EOL] [EOL] [EOL] async def get_user_by_email ( email ) : [EOL] [docstring] [EOL] user = await User . query . where ( User . email == email ) . gino . first ( ) [EOL] return user [EOL] [EOL] [EOL] async def get_user_by_id ( user_id ) : [EOL] [docstring] [EOL] user = await User . query . where ( User . id == user_id ) . gino . first ( ) [EOL] return user [EOL] [EOL] [EOL] async def create_user ( email , password = None , nickname = None , photo = None , is_admin = False , ) : [EOL] [docstring] [EOL] id_ = uuid . uuid4 ( ) [EOL] nickname = nickname or generate_random_characters ( prefix_length = [number] , suffix_length = random . randint ( [number] , [number] ) ) [EOL] user = User ( id = id_ , email = email , nickname = nickname , photo = photo , is_admin = is_admin ) [EOL] user . set_password ( password ) [EOL] await user . create ( ) [EOL] return user [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.db_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.db_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $app.db_models.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Literal , Any [EOL] import uuid [EOL] import typing [EOL] import typing_extensions [EOL] import builtins [EOL] from typing import List , Dict , Any [EOL] from uuid import UUID [EOL] from app . db_models import ( Line , Translation , User , Content , Category , LineLike , TranslationLike , ) [EOL] from app import db [EOL] from app import config [EOL] from app . exceptions import DataDoesNotExist [EOL] from app . utils import get_photo_url [EOL] [EOL] [EOL] async def get_user_activitiy_summary ( user_id ) : [EOL] query = ( db . select ( [ User . nickname , User . photo , db . func . count ( Translation . id ) ] ) . select_from ( User . outerjoin ( Translation ) ) . where ( User . id == user_id ) . group_by ( User . id ) ) [EOL] data = await query . gino . first ( ) [EOL] if data : [EOL] data = { [string] : user_id , [string] : data [ [number] ] , [string] : get_photo_url ( data [ [number] ] , media_url = config . MEDIA_URL ) , [string] : data [ [number] ] , } [EOL] else : [EOL] raise DataDoesNotExist ( [string] ) [EOL] return data [EOL] [EOL] [EOL] async def fetch_user_liked_english_lines ( user_id , limit = [number] , offset = [number] ) : [EOL] query = ( db . select ( [ Line . id , Line . line , Content . id , Content . title , Content . year , Category . id , Category . category , LineLike . created_at , ] ) . where ( LineLike . user_id == user_id ) . select_from ( Line . join ( Content , Line . content_id == Content . id ) . join ( Category , Content . category_id == Category . id ) . join ( LineLike , Line . id == LineLike . line_id ) ) . limit ( limit ) . offset ( offset ) . order_by ( LineLike . created_at . desc ( ) ) ) [EOL] columns = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] data = await query . gino . all ( ) [EOL] return [ dict ( zip ( columns , each ) ) for each in data ] [EOL] [EOL] [EOL] async def fetch_user_liked_korean_lines ( user_id , limit = [number] , offset = [number] ) : [EOL] query = ( db . select ( [ Translation . id , Translation . translation , Line . id , Line . line , Content . id , Content . title , Content . year , Category . id , Category . category , TranslationLike . created_at , ] ) . where ( TranslationLike . user_id == user_id ) . select_from ( Translation . join ( Line , Translation . line_id == Line . id ) . join ( Content , Line . content_id == Content . id ) . join ( Category , Content . category_id == Category . id ) . join ( TranslationLike , Translation . id == TranslationLike . translation_id ) ) . limit ( limit ) . offset ( offset ) . order_by ( TranslationLike . created_at . desc ( ) ) ) [EOL] [EOL] columns = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] data = await query . gino . all ( ) [EOL] return [ dict ( zip ( columns , each ) ) for each in data ] [EOL] [EOL] [EOL] async def fetch_user_translations ( user_id , limit = [number] , offset = [number] ) : [EOL] query = ( db . select ( [ Translation . id , Translation . translation , Line . id , Line . line , Content . id , Content . title , Content . year , Category . id , Category . category , ] ) . where ( Translation . user_id == user_id ) . select_from ( Translation . join ( Line , Translation . line_id == Line . id ) . join ( Content , Line . content_id == Content . id ) . join ( Category , Content . category_id == Category . id ) ) . limit ( limit ) . offset ( offset ) . order_by ( Translation . created_at . desc ( ) ) ) [EOL] columns = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ) [EOL] data = await query . gino . all ( ) [EOL] return [ dict ( zip ( columns , each ) ) for each in data ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict["str",typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import sanic [EOL] import typing [EOL] import datetime [EOL] from typing import List [EOL] from io import BytesIO [EOL] import uuid [EOL] [EOL] from sanic . request import Request [EOL] from sanic . blueprints import Blueprint [EOL] from sanic . exceptions import ServerError [EOL] import pandas as pd [EOL] from PIL import Image [EOL] [EOL] from app . db_models import Line , Content , ContentXGenre , Category , Genre , Translation [EOL] from app . decorators import expect_body [EOL] from app . utils import JsonResponse , validate_file_size [EOL] from app . libs import converter [EOL] [EOL] [EOL] blueprint = Blueprint ( [string] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) async def create_csv ( request ) : [EOL] [docstring] [EOL] app = request . app [EOL] input_text = request . files . get ( [string] ) . body . decode ( encoding = [string] , errors = [string] ) [EOL] ext = request . files . get ( [string] ) . name . split ( [string] ) [ - [number] ] [EOL] output_name = request . form . get ( [string] ) [EOL] [EOL] lines = converter . read_lines ( input_text , ext ) [EOL] df = converter . lines_to_df ( lines ) [EOL] [EOL] output_dir = app . config [ [string] ] [EOL] output = output_dir + [string] + output_name [EOL] [EOL] converter . df_to_csv ( df , output ) [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) async def create_mixed_csv ( request ) : [EOL] [docstring] [EOL] app = request . app [EOL] [EOL] input_eng_text = request . files . get ( [string] ) . body . decode ( encoding = [string] , errors = [string] ) [EOL] input_eng_ext = request . files . get ( [string] ) . name . split ( [string] ) [ - [number] ] [EOL] input_kor_text = request . files . get ( [string] ) . body . decode ( encoding = [string] , errors = [string] ) [EOL] input_kor_ext = request . files . get ( [string] ) . name . split ( [string] ) [ - [number] ] [EOL] output_name = request . form . get ( [string] ) [EOL] [EOL] lines_eng = converter . read_lines ( input_eng_text , input_eng_ext ) [EOL] lines_kor = converter . read_lines ( input_kor_text , input_kor_ext ) [EOL] df_eng = converter . lines_to_df ( lines_eng ) [EOL] df_kor = converter . lines_to_df ( lines_kor ) [EOL] df = converter . combine_eng_kor ( df_eng , df_kor ) [EOL] [EOL] output_dir = app . config [ [string] ] [EOL] output = output_dir + [string] + output_name [EOL] [EOL] converter . df_to_csv ( df , output ) [EOL] [EOL] return JsonResponse ( { [string] : [string] } , status = [number] , ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) @ expect_body ( title = ( str , ... ) , year = ( str , ... ) , reference = ( str , [string] ) , category_id = ( int , ... ) , genre_ids = ( List [ int ] , ... ) , ) async def upload_content ( request ) : [EOL] [docstring] [EOL] title = request . json [ [string] ] [EOL] year = request . json [ [string] ] [EOL] reference = request . json [ [string] ] [EOL] category_id = request . json [ [string] ] [EOL] genre_ids = request . json [ [string] ] [EOL] [EOL] category = await Category . get ( category_id ) [EOL] genres = await Genre . query . where ( Genre . id . in_ ( genre_ids ) ) . gino . all ( ) [EOL] content = Content ( title = title , year = year , reference = reference , category_id = category . id ) [EOL] [EOL] await content . create ( ) [EOL] [EOL] content_genre_list = [ dict ( content_id = content . id , genre_id = genre . id ) for genre in genres ] [EOL] [EOL] await ContentXGenre . insert ( ) . gino . all ( * content_genre_list ) [EOL] [EOL] return JsonResponse ( content . to_dict ( ) , status = [number] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) async def upload_eng_subtitle ( request , content_id ) : [EOL] content = await Content . get ( content_id ) [EOL] if content is None : [EOL] raise ServerError ( [string] , status_code = [number] ) [EOL] input_file = request . files . get ( [string] ) [EOL] df = pd . read_csv ( BytesIO ( input_file . body ) , encoding = [string] , header = [number] ) [EOL] df . loc [ : , [string] ] = content_id [EOL] df . time = df . time . apply ( lambda x : datetime . datetime . strptime ( x , [string] ) . time ( ) ) [EOL] eng_line_list = [ dict ( time = each [ [number] ] , line = each [ [number] ] , content_id = each [ [number] ] ) for each in df [ [ [string] , [string] , [string] ] ] . values ] [EOL] await Line . insert ( ) . gino . all ( * eng_line_list ) [EOL] [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) async def update_kor_subtitle ( request , content_id ) : [EOL] lines = await Line . query . where ( content_id == content_id ) . order_by ( [string] ) . gino . all ( ) [EOL] [EOL] if lines is None : [EOL] [comment] [EOL] raise ServerError ( [string] , status_code = [number] ) [EOL] [EOL] input_file = request . files . get ( [string] ) [EOL] df = pd . read_csv ( BytesIO ( input_file . body ) , encoding = [string] , header = [number] ) [EOL] [EOL] if len ( lines ) != len ( df ) : [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] df . loc [ : , [string] ] = content_id [EOL] df . loc [ : , [string] ] = [ each . id for each in lines ] [EOL] kor_line_list = [ dict ( translation = each [ [number] ] , line_id = each [ [number] ] , content_id = each [ [number] ] ) for each in df [ [ [string] , [string] , [string] ] ] . values ] [EOL] [EOL] [comment] [EOL] await Translation . insert ( ) . gino . all ( * kor_line_list ) [EOL] [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] [EOL] @ blueprint . route ( [string] , methods = [ [string] ] ) async def upload_photo ( request ) : [EOL] photo = request . files . get ( [string] ) [EOL] if not validate_file_size ( photo , [number] ) : [EOL] raise ServerError ( [string] , status_code = [number] ) [EOL] extension = photo . type . split ( [string] ) [ - [number] ] [EOL] path = f" [string] { str ( uuid . uuid4 ( ) ) } [string] { extension }" [EOL] image = Image . open ( BytesIO ( photo . body ) ) [EOL] image . save ( path , extension ) [EOL] return JsonResponse ( { [string] : f"{ path }" } , status = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . auth import blueprint as auth_bp [EOL] from . subtitle import blueprint as subtitle_bp [EOL] from . mypage import blueprint as mypage_bp [EOL] from . upload import blueprint as upload_bp [EOL] [EOL] [EOL] def init_app ( app ) : [EOL] app . static ( [string] , [string] ) [EOL] app . blueprint ( auth_bp ) [EOL] app . blueprint ( subtitle_bp ) [EOL] app . blueprint ( mypage_bp ) [EOL] app . blueprint ( upload_bp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Union , Any [EOL] import sanic_jwt_extended [EOL] import sanic [EOL] import typing [EOL] import builtins [EOL] from typing import List , Dict , Any , Tuple [EOL] [EOL] from sanic . request import Request [EOL] from sanic . exceptions import ServerError [EOL] from sanic . blueprints import Blueprint [EOL] from sanic_jwt_extended import jwt_optional [EOL] from sanic_jwt_extended . tokens import Token [EOL] [EOL] from app . db_models import LineLike , TranslationLike , Translation [EOL] from app . db_access . mypage import ( get_user_activitiy_summary , fetch_user_liked_english_lines , fetch_user_liked_korean_lines , fetch_user_translations , ) [EOL] from app . db_access . subtitle import ( get_like_count_per_english_line , get_like_count_per_korean_line , get_translation_count_per_line , get_genres_per_content , get_user_liked_english_lines , get_user_liked_korean_lines , ) [EOL] from app . libs . views import APIView [EOL] from app . utils import JsonResponse , calc_max_page [EOL] from app . decorators import expect_query [EOL] from app . exceptions import DataDoesNotExist [EOL] [EOL] [EOL] blueprint = Blueprint ( [string] , url_prefix = [string] ) [EOL] [EOL] [EOL] class UserActivitySummary ( APIView ) : [EOL] async def get ( self , request , user_id ) : [EOL] try : [EOL] resp = await get_user_activitiy_summary ( user_id ) [EOL] except DataDoesNotExist as e : [EOL] raise ServerError ( str ( e ) , status_code = [number] ) [EOL] return JsonResponse ( resp , status = [number] ) [EOL] [EOL] [EOL] class UserLikedEnglishLines ( APIView ) : [EOL] def _get_required_ids ( self , lines ) : [EOL] content_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in lines : [EOL] content_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) ) async def get ( self , request , user_id , page , per_page , token ) : [EOL] max_page , count = await calc_max_page ( per_page , LineLike . user_id == user_id ) [EOL] offset = per_page * ( page - [number] ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] ) [EOL] lines = await fetch_user_liked_english_lines ( user_id , limit = per_page , offset = offset ) [EOL] content_ids , line_ids = self . _get_required_ids ( lines ) [EOL] like_count = await get_like_count_per_english_line ( line_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_english_lines ( user_id , line_ids ) if user_id else [ ] ) [EOL] data = [ { ** line , [string] : genres [ line [ [string] ] ] , [string] : like_count . get ( line [ [string] ] , [number] ) , [string] : translation_count . get ( line [ [string] ] , [number] ) , [string] : line [ [string] ] in user_liked , } for line in lines ] [EOL] resp = { [string] : max_page , [string] : page , [string] : count , [string] : data , } [EOL] [EOL] return JsonResponse ( resp , status = [number] , ) [EOL] [EOL] [EOL] class UserLikedKoreanLines ( APIView ) : [EOL] def _get_required_ids ( self , translations ) : [EOL] content_ids = [ ] [EOL] translation_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in translations : [EOL] content_ids . append ( each [ [string] ] ) [EOL] translation_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , translation_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) ) async def get ( self , request , user_id , page , per_page , token ) : [EOL] max_page , count = await calc_max_page ( per_page , TranslationLike . user_id == user_id ) [EOL] offset = per_page * ( page - [number] ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] ) [EOL] translations = await fetch_user_liked_korean_lines ( user_id , limit = per_page , offset = offset ) [EOL] content_ids , translation_ids , line_ids = self . _get_required_ids ( translations ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] like_count = await get_like_count_per_korean_line ( translation_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_korean_lines ( user_id , translation_ids ) [EOL] if user_id [EOL] else [ ] ) [EOL] data = [ { ** each , [string] : like_count . get ( each [ [string] ] , [number] ) , [string] : translation_count . get ( each [ [string] ] , [number] ) , [string] : genres [ each [ [string] ] ] , [string] : each [ [string] ] in user_liked , } for each in translations ] [EOL] [EOL] return JsonResponse ( { [string] : max_page , [string] : page , [string] : count , [string] : data } , status = [number] , ) [EOL] [EOL] [EOL] class UserTranslations ( APIView ) : [EOL] def _get_required_ids ( self , translations ) : [EOL] content_ids = [ ] [EOL] translation_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in translations : [EOL] content_ids . append ( each [ [string] ] ) [EOL] translation_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , translation_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) ) async def get ( self , request , user_id , page , per_page , token ) : [EOL] max_page , count = await calc_max_page ( per_page , Translation . user_id == user_id ) [EOL] offset = per_page * ( page - [number] ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] ) [EOL] translations = await fetch_user_translations ( user_id , limit = per_page , offset = offset ) [EOL] content_ids , translation_ids , line_ids = self . _get_required_ids ( translations ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] like_count = await get_like_count_per_korean_line ( translation_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_korean_lines ( user_id , translation_ids ) [EOL] if user_id [EOL] else [ ] ) [EOL] data = [ { ** each , [string] : like_count . get ( each [ [string] ] , [number] ) , [string] : translation_count . get ( each [ [string] ] , [number] ) , [string] : genres [ each [ [string] ] ] , [string] : each [ [string] ] in user_liked , } for each in translations ] [EOL] [EOL] return JsonResponse ( { [string] : max_page , [string] : page , [string] : count , [string] : data } , status = [number] , ) [EOL] [EOL] [EOL] blueprint . add_route ( UserActivitySummary . as_view ( ) , [string] ) [EOL] blueprint . add_route ( UserLikedEnglishLines . as_view ( ) , [string] ) [EOL] blueprint . add_route ( UserLikedKoreanLines . as_view ( ) , [string] ) [EOL] blueprint . add_route ( UserTranslations . as_view ( ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Type , Optional , Union , Any [EOL] import app [EOL] import sanic [EOL] import typing [EOL] import sanic_jwt_extended [EOL] import builtins [EOL] from typing import List , Tuple , Dict , Any , Optional [EOL] [EOL] import asyncpg [EOL] from pydantic import constr [EOL] from sanic . request import Request [EOL] from sanic . exceptions import ServerError [EOL] from sanic . blueprints import Blueprint [EOL] from sanic_jwt_extended import jwt_required , jwt_optional [EOL] from sanic_jwt_extended . tokens import Token [EOL] [EOL] from app . db_models import ( User , Line , Translation , Category , Genre , Content , ) [EOL] from app . libs . views import APIView , ListAPIView , DetailAPIView [EOL] from app . libs . view_mixins import ( UpdateModelMixin , DestroyModelMixin , ) [EOL] from app . utils import calc_max_page [EOL] from app . utils import JsonResponse [EOL] from app . decorators import expect_query , expect_body [EOL] from app . db_access . subtitle import ( get_like_count_per_korean_line , get_like_count_per_english_line , randomly_pick_subtitles , search_english_lines , search_korean_lines , get_translation_count_per_line , get_genres_per_content , get_user_liked_english_lines , get_user_liked_korean_lines , get_translations , get_translation , create_english_like , delete_english_like , create_korean_like , delete_korean_like , ) [EOL] [EOL] [EOL] blueprint = Blueprint ( [string] , url_prefix = [string] ) [EOL] [EOL] [EOL] class ContentList ( ListAPIView ) : [EOL] model = Content [EOL] [EOL] [EOL] class CategoryList ( ListAPIView ) : [EOL] model = Category [EOL] [EOL] [EOL] class GenreList ( ListAPIView ) : [EOL] model = Genre [EOL] [EOL] [EOL] class ContentDetail ( DetailAPIView ) : [EOL] model = Content [EOL] [EOL] [EOL] class CategoryDetail ( DetailAPIView ) : [EOL] model = Category [EOL] [EOL] [EOL] class GenreDetail ( DetailAPIView ) : [EOL] model = Genre [EOL] [EOL] [EOL] class TranslationDetail ( DetailAPIView ) : [EOL] model = Translation [EOL] [EOL] [EOL] class LineList ( ListAPIView ) : [EOL] model = Line [EOL] [EOL] def get_query ( self , request , content_id ) : [EOL] return Line . query . where ( Line . content_id == content_id ) [EOL] [EOL] @ expect_query ( page = ( int , [number] ) , content_id = ( int , ... ) ) async def get ( self , request , page , content_id ) : [EOL] return await super ( ) . get ( request , page = page , content_id = content_id ) [EOL] [EOL] async def post ( self , request ) : [EOL] raise ServerError ( [string] , [number] ) [EOL] [EOL] [EOL] class RandomSubtitles ( APIView ) : [EOL] [docstring] [EOL] [EOL] def _get_required_ids ( self , lines ) : [EOL] content_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in lines : [EOL] content_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( count = ( int , [number] ) ) async def get ( self , requeest , count , token ) : [EOL] [docstring] [EOL] lines = await randomly_pick_subtitles ( count ) [EOL] content_ids , line_ids = self . _get_required_ids ( lines ) [EOL] like_count = await get_like_count_per_english_line ( line_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_english_lines ( user_id , line_ids ) if user_id else [ ] ) [EOL] data = [ { ** line , [string] : genres [ line [ [string] ] ] , [string] : like_count . get ( line [ [string] ] , [number] ) , [string] : translation_count . get ( line [ [string] ] , [number] ) , [string] : line [ [string] ] in user_liked , } for line in lines ] [EOL] resp = { [string] : [number] , [string] : [number] , [string] : len ( data ) , [string] : data , } [EOL] return JsonResponse ( resp , status = [number] ) [EOL] [EOL] [EOL] class SearchEnglish ( APIView ) : [EOL] def _get_required_ids ( self , lines ) : [EOL] content_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in lines : [EOL] content_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) , keyword = ( constr ( min_length = [number] ) , ... ) ) async def get ( self , request , page , per_page , keyword , token ) : [EOL] [docstring] [EOL] max_page , count = await calc_max_page ( per_page , Line . line . op ( [string] ) ( keyword ) ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] , ) [EOL] offset = per_page * ( page - [number] ) [EOL] lines = await search_english_lines ( keyword , per_page , offset ) [EOL] content_ids , line_ids = self . _get_required_ids ( lines ) [EOL] like_count = await get_like_count_per_english_line ( line_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_english_lines ( user_id , line_ids ) if user_id else [ ] ) [EOL] data = [ { ** line , [string] : genres [ line [ [string] ] ] , [string] : like_count . get ( line [ [string] ] , [number] ) , [string] : translation_count . get ( line [ [string] ] , [number] ) , [string] : line [ [string] ] in user_liked , } for line in lines ] [EOL] resp = { [string] : max_page , [string] : page , [string] : count , [string] : data , } [EOL] return JsonResponse ( resp , status = [number] ) [EOL] [EOL] [EOL] class SearchKorean ( APIView ) : [EOL] def _get_required_ids ( self , translations ) : [EOL] content_ids = [ ] [EOL] translation_ids = [ ] [EOL] line_ids = [ ] [EOL] for each in translations : [EOL] content_ids . append ( each [ [string] ] ) [EOL] translation_ids . append ( each [ [string] ] ) [EOL] line_ids . append ( each [ [string] ] ) [EOL] return content_ids , translation_ids , line_ids [EOL] [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) , keyword = ( constr ( min_length = [number] ) , ... ) ) async def get ( self , request , page , per_page , keyword , token ) : [EOL] [docstring] [EOL] max_page , count = await calc_max_page ( per_page , condition = Translation . translation . op ( [string] ) ( keyword ) ) [EOL] offset = per_page * ( page - [number] ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] , ) [EOL] [EOL] translations = await search_korean_lines ( keyword , per_page , offset ) [EOL] content_ids , translation_ids , line_ids = self . _get_required_ids ( translations ) [EOL] genres = await get_genres_per_content ( content_ids ) [EOL] like_count = await get_like_count_per_korean_line ( translation_ids ) [EOL] translation_count = await get_translation_count_per_line ( line_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_korean_lines ( user_id , translation_ids ) [EOL] if user_id [EOL] else [ ] ) [EOL] data = [ { ** each , [string] : like_count . get ( each [ [string] ] , [number] ) , [string] : translation_count . get ( each [ [string] ] , [number] ) , [string] : genres [ each [ [string] ] ] , [string] : each [ [string] ] in user_liked , } for each in translations ] [EOL] resp = { [string] : max_page , [string] : page , [string] : count , [string] : data , } [EOL] return JsonResponse ( resp ) [EOL] [EOL] [EOL] class TranslationListView ( APIView ) : [EOL] @ jwt_optional @ expect_query ( page = ( int , [number] ) , per_page = ( int , [number] ) , line_id = ( int , ... ) ) async def get ( self , request , page , per_page , line_id , token , ) : [EOL] max_page , count = await calc_max_page ( per_page , Translation . line_id == line_id ) [EOL] offset = per_page * ( page - [number] ) [EOL] if page > max_page : [EOL] return JsonResponse ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [ ] } , status = [number] ) [EOL] [EOL] translations = await get_translations ( line_id , per_page , offset ) [EOL] translation_ids = [ each [ [string] ] for each in translations ] [EOL] like_count = await get_like_count_per_korean_line ( translation_ids ) [EOL] user_id = token . identity if token else None [EOL] user_liked = ( await get_user_liked_korean_lines ( user_id , translation_ids ) [EOL] if user_id [EOL] else [ ] ) [EOL] [EOL] data = [ { ** each , [string] : like_count . get ( each [ [string] ] , [number] ) , [string] : each [ [string] ] in user_liked , } for each in translations ] [EOL] resp = { [string] : max_page , [string] : page , [string] : count , [string] : data , } [EOL] return JsonResponse ( resp ) [EOL] [EOL] @ jwt_required @ expect_body ( line_id = ( int , ... ) , translation = ( str , ... ) ) async def post ( self , request , token ) : [EOL] user_id = token . identity [EOL] translation = await Translation ( ** request . json , user_id = user_id ) . create ( ) [EOL] nickname = await User . select ( [string] ) . where ( User . id == user_id ) . gino . scalar ( ) [EOL] return JsonResponse ( { ** translation . to_dict ( ) , [string] : { [string] : user_id , [string] : nickname } } , status = [number] , ) [EOL] [EOL] [EOL] class TranslationDetailView ( APIView , UpdateModelMixin , DestroyModelMixin ) : [EOL] async def get_object ( self , translation_id ) : [EOL] return await get_translation ( translation_id ) [EOL] [EOL] @ jwt_required async def put ( self , request , translation_id , token ) : [EOL] translation = await get_translation ( translation_id ) [EOL] user_id = token . identity [EOL] if user_id == translation . translatior_id : [EOL] resp = await self . update ( request , translation_id ) [EOL] return resp [EOL] else : [EOL] raise ServerError ( [string] , [number] ) [EOL] [EOL] @ jwt_required async def delete ( self , request , translation_id , token ) : [EOL] translation = await get_translation ( translation_id ) [EOL] user_id = token . identity [EOL] if user_id == translation . translatior_id : [EOL] resp = await self . destroy ( request , translation_id ) [EOL] return resp [EOL] else : [EOL] raise ServerError ( [string] , [number] ) [EOL] [EOL] [EOL] class LikeEnglish ( APIView ) : [EOL] @ jwt_required async def post ( self , request , line_id , token ) : [EOL] user_id = token . identity [EOL] try : [EOL] await create_english_like ( line_id , user_id ) [EOL] except asyncpg . exceptions . UniqueViolationError : [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] @ jwt_required async def delete ( self , request , line_id , token ) : [EOL] user_id = token . identity [EOL] await delete_english_like ( line_id , user_id ) [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] [EOL] class LikeKorean ( APIView ) : [EOL] @ jwt_required async def post ( self , request , translation_id , token ) : [EOL] user_id = token . identity [EOL] try : [EOL] await create_korean_like ( translation_id , user_id ) [EOL] except asyncpg . exceptions . UniqueViolationError : [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] @ jwt_required async def delete ( self , request , translation_id , token ) : [EOL] user_id = token . identity [EOL] await delete_korean_like ( translation_id , user_id ) [EOL] return JsonResponse ( { [string] : [string] } , status = [number] ) [EOL] [EOL] [EOL] blueprint . add_route ( ContentList . as_view ( ) , [string] ) [EOL] blueprint . add_route ( CategoryList . as_view ( ) , [string] ) [EOL] blueprint . add_route ( GenreList . as_view ( ) , [string] ) [EOL] blueprint . add_route ( ContentDetail . as_view ( ) , [string] ) , [EOL] blueprint . add_route ( LineList . as_view ( ) , [string] ) , [EOL] blueprint . add_route ( CategoryDetail . as_view ( ) , [string] ) [EOL] blueprint . add_route ( GenreDetail . as_view ( ) , [string] ) [EOL] blueprint . add_route ( RandomSubtitles . as_view ( ) , [string] ) [EOL] blueprint . add_route ( SearchEnglish . as_view ( ) , [string] ) [EOL] blueprint . add_route ( SearchKorean . as_view ( ) , [string] ) [EOL] blueprint . add_route ( TranslationDetail . as_view ( ) , [string] ) [EOL] blueprint . add_route ( TranslationListView . as_view ( ) , [string] ) [EOL] blueprint . add_route ( TranslationDetailView . as_view ( ) , [string] ) [EOL] blueprint . add_route ( LikeEnglish . as_view ( ) , [string] ) [EOL] blueprint . add_route ( LikeKorean . as_view ( ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.list,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.list,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Optional[sanic_jwt_extended.tokens.Token]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Optional[sanic_jwt_extended.tokens.Token]$ 0 0 0 $typing.Optional[sanic_jwt_extended.tokens.Token]$ 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Any],typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Any]],builtins.int]]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Dict[builtins.str,typing.Any]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 $typing.Any$ 0 0 0 0 0 $sanic.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sanic.request.Request$ 0 $builtins.int$ 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 $sanic_jwt_extended.tokens.Token$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import logging [EOL] from __future__ import with_statement [EOL] from alembic import context [EOL] from sqlalchemy import create_engine , pool [EOL] from logging . config import fileConfig [EOL] import logging [EOL] [EOL] [comment] [EOL] from app import db [EOL] [EOL] [comment] [EOL] from app . db_models import * [EOL] [EOL] [comment] [EOL] [comment] [EOL] config = context . config [EOL] logger = logging . getLogger ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] fileConfig ( config . config_file_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] target_metadata = db [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def run_migrations_offline ( ) : [EOL] [docstring] [EOL] url = config . get_main_option ( [string] ) [EOL] context . configure ( url = url , target_metadata = target_metadata , literal_binds = True , compare_type = True ) [EOL] [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] [EOL] [EOL] def run_migrations_online ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def process_revision_directives ( context , revision , directives ) : [EOL] if getattr ( config . cmd_opts , [string] , False ) : [EOL] script = directives [ [number] ] [EOL] if script . upgrade_ops . is_empty ( ) : [EOL] directives [ : ] = [ ] [EOL] logger . info ( [string] ) [EOL] [EOL] engine = create_engine ( config . get_main_option ( [string] ) , poolclass = pool . NullPool ) [EOL] [EOL] connection = engine . connect ( ) [EOL] context . configure ( connection = connection , target_metadata = target_metadata , process_revision_directives = process_revision_directives , compare_type = True , ) [EOL] [EOL] try : [EOL] with context . begin_transaction ( ) : [EOL] context . run_migrations ( ) [EOL] except Exception as exception : [EOL] logger . error ( exception ) [EOL] raise exception [EOL] finally : [EOL] connection . close ( ) [EOL] [EOL] [EOL] if context . is_offline_mode ( ) : [EOL] run_migrations_offline ( ) [EOL] else : [EOL] run_migrations_online ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] async def test_index ( test_cli ) : [EOL] resp = await test_cli . get ( [string] ) [EOL] assert resp . status == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from app import create_app [EOL] [EOL] [EOL] @ pytest . yield_fixture def app ( ) : [EOL] app = create_app ( ) [EOL] yield app [EOL] [EOL] [EOL] @ pytest . fixture def test_cli ( loop , app , test_client ) : [EOL] return loop . run_until_complete ( test_client ( app ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0