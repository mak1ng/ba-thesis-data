from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] [EOL] def target_function ( d , p , c , x , y ) : [EOL] z = sum ( d * y ) + sum ( sum ( c * x ) ) + sum ( p * sum ( x . transpose ( ) ) ) [EOL] return z [EOL] [EOL] [EOL] def potential ( a , b , c ) : [EOL] a , b , c = balance ( a , b , c ) [EOL] x = dbr ( a , b ) [EOL] v , u = find_potentials ( x , c ) [EOL] delta_c = calculate_delta_c ( c , v , u ) [EOL] optimum = check_optimum ( delta_c ) [EOL] while not optimum : [EOL] max_i , max_j = find_max_diff ( delta_c ) [EOL] x [ max_i ] [ max_j ] = [number] [EOL] x_copy = clipping ( x ) [EOL] loop = find_loop ( x_copy , max_i , max_j ) [EOL] min_x , min_i , min_j = find_min_x ( x , loop ) [EOL] try : [EOL] x = new_dbr ( x , loop , min_x ) [EOL] if not check_degeneracy ( x ) : [EOL] x [ min_i ] [ min_j ] = - [number] [EOL] v , u = find_potentials ( x , c ) [EOL] delta_c = calculate_delta_c ( c , v , u ) [EOL] optimum = check_optimum ( delta_c ) [EOL] except : [EOL] optimum = True [EOL] return x [EOL] [EOL] [EOL] def dbr ( a , b ) : [EOL] x = np . array ( [ [ - [number] for _ in range ( len ( b ) ) ] for _ in range ( len ( a ) ) ] ) [EOL] for i in range ( len ( a ) ) : [EOL] for j in range ( len ( b ) ) : [EOL] result = min ( a [ i ] , b [ j ] ) [EOL] a [ i ] -= result [EOL] b [ j ] -= result [EOL] if result != [number] : [EOL] x [ i ] [ j ] = result [EOL] return x [EOL] [EOL] [EOL] def balance ( a , b , c ) : [EOL] sum_a = sum ( a ) [EOL] sum_b = sum ( b ) [EOL] diff = abs ( sum_a - sum_b ) [EOL] [EOL] if sum_a < sum_b : [EOL] a = np . append ( a , diff ) [EOL] c = np . append ( c , [ [ [number] for _ in range ( len ( b ) ) ] ] , axis = [number] ) [EOL] elif sum_a > sum_b : [EOL] b = np . append ( b , diff ) [EOL] c = np . append ( c , [ [ [number] ] for _ in range ( len ( a ) ) ] , axis = [number] ) [EOL] return a , b , c [EOL] [EOL] [EOL] def check_degeneracy ( x ) : [EOL] counter = [number] [EOL] for i in range ( len ( x ) ) : [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] if x [ i ] [ j ] >= [number] : [EOL] counter += [number] [EOL] if counter == ( len ( x ) + len ( x [ [number] ] ) - [number] ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def find_potentials ( x , c ) : [EOL] row = [number] [EOL] u = [ - [number] for _ in range ( len ( x ) - [number] ) ] [EOL] u . insert ( [number] , [number] ) [EOL] v = [ - [number] for _ in range ( len ( x [ [number] ] ) ) ] [EOL] v , u = go_row ( x , c , v , u , row ) [EOL] return v , u [EOL] [EOL] [EOL] def go_row ( x , c , v , u , i ) : [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] if x [ i ] [ j ] > [number] and v [ j ] == - [number] : [EOL] v [ j ] = c [ i ] [ j ] - u [ i ] [EOL] v , u = go_column ( x , c , v , u , j ) [EOL] return v , u [EOL] [EOL] [EOL] def go_column ( x , c , v , u , j ) : [EOL] for i in range ( len ( x ) ) : [EOL] if x [ i ] [ j ] > [number] and u [ i ] == - [number] : [EOL] u [ i ] = c [ i ] [ j ] - v [ j ] [EOL] v , u = go_row ( x , c , v , u , i ) [EOL] return v , u [EOL] [EOL] [EOL] def calculate_delta_c ( c , v , u ) : [EOL] delta_c = np . array ( [ [ [number] for _ in range ( len ( c [ [number] ] ) ) ] for _ in range ( len ( c ) ) ] ) [EOL] for i in range ( len ( c ) ) : [EOL] for j in range ( len ( c [ [number] ] ) ) : [EOL] delta_c [ i ] [ j ] = c [ i ] [ j ] - u [ i ] - v [ j ] [EOL] return delta_c [EOL] [EOL] [EOL] def check_optimum ( delta_c ) : [EOL] for i in range ( len ( delta_c ) ) : [EOL] for j in range ( len ( delta_c [ [number] ] ) ) : [EOL] if delta_c [ i ] [ j ] < [number] : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def find_max_diff ( delta_c ) : [EOL] max_diff = [number] [EOL] max_i = [number] [EOL] max_j = [number] [EOL] for i in range ( len ( delta_c ) ) : [EOL] for j in range ( len ( delta_c [ [number] ] ) ) : [EOL] if delta_c [ i ] [ j ] < [number] and max_diff > delta_c [ i ] [ j ] : [EOL] max_diff = delta_c [ i ] [ j ] [EOL] max_i = i [EOL] max_j = j [EOL] return max_i , max_j [EOL] [EOL] [EOL] def find_loop ( x , max_i , max_j ) : [EOL] loop = [ ] [EOL] loop = go_row_loop ( x , loop , max_i , max_j ) [EOL] return loop [EOL] [EOL] [EOL] def clipping ( x ) : [EOL] x_copy = x . copy ( ) [EOL] flag = True [EOL] while flag : [EOL] flag = False [EOL] for i in range ( len ( x ) ) : [EOL] counter = [number] [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] if x_copy [ i ] [ j ] >= [number] : [EOL] counter += [number] [EOL] if counter == [number] : [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] x_copy [ i ] [ j ] = - [number] [EOL] flag = True [EOL] [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] counter = [number] [EOL] for i in range ( len ( x ) ) : [EOL] if x_copy [ i ] [ j ] >= [number] : [EOL] counter += [number] [EOL] if counter == [number] : [EOL] for i in range ( len ( x ) ) : [EOL] x_copy [ i ] [ j ] = - [number] [EOL] flag = True [EOL] return x_copy [EOL] [EOL] [EOL] def go_row_loop ( x1 , loop , i , k ) : [EOL] x = x1 . copy ( ) [EOL] for j in range ( len ( x [ [number] ] ) ) : [EOL] if x [ i ] [ j ] >= [number] and j != k : [EOL] x [ i ] [ j ] = - [number] [EOL] go_column_loop ( x , loop , i , j ) [EOL] loop . append ( ( i , j ) ) [EOL] return loop [EOL] [EOL] [EOL] def go_column_loop ( x1 , loop , k , j ) : [EOL] x = x1 . copy ( ) [EOL] for i in range ( len ( x ) ) : [EOL] if x [ i ] [ j ] >= [number] and i != k : [EOL] x [ i ] [ j ] = - [number] [EOL] go_row_loop ( x , loop , i , j ) [EOL] loop . append ( ( i , j ) ) [EOL] return loop [EOL] [EOL] [EOL] def find_min_x ( x , loop ) : [EOL] min_x = [number] [EOL] min_i = [number] [EOL] min_j = [number] [EOL] for k in range ( [number] , len ( loop ) , [number] ) : [EOL] i , j = loop [ k ] [EOL] if x [ i ] [ j ] < min_x : [EOL] min_x = x [ i ] [ j ] [EOL] min_i = i [EOL] min_j = j [EOL] return min_x , min_i , min_j [EOL] [EOL] [EOL] def new_dbr ( x , loop , min_x ) : [EOL] i , j = loop [ [number] ] [EOL] x [ i ] [ j ] = min_x [EOL] for k in range ( [number] , len ( loop ) , [number] ) : [EOL] i , j = loop [ k ] [EOL] x [ i ] [ j ] -= min_x [EOL] for k in range ( [number] , len ( loop ) , [number] ) : [EOL] i , j = loop [ k ] [EOL] x [ i ] [ j ] += min_x [EOL] return x [EOL] [EOL] [EOL] def evaluating ( a , b , c , d , p , y ) : [EOL] x = potential ( a , b , c ) [EOL] new_x = np . array ( [ [ [number] for _ in range ( len ( b ) ) ] for _ in range ( len ( a ) ) ] ) [EOL] for i in range ( len ( a ) ) : [EOL] for j in range ( len ( b ) ) : [EOL] if x [ i ] [ j ] > [number] : [EOL] new_x [ i ] [ j ] = x [ i ] [ j ] [EOL] x = new_x [EOL] result = target_function ( d , p , c , x , y ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from kursach . method_potencialov import evaluating [EOL] from kursach . utils import prepare_matrix [EOL] [EOL] [EOL] def greedy_algorithm ( a , b , c , d , p , m1 , m2 ) : [EOL] y = [ [number] for _ in range ( m2 ) ] [EOL] sum_a = a [ : - len ( d ) ] . sum ( ) [EOL] sum_b = b . sum ( ) [EOL] ind = d . argsort ( ) [EOL] k = [number] [EOL] while sum_a < sum_b : [EOL] y [ ind [ k ] ] = [number] [EOL] sum_a += d [ ind [ k ] ] [EOL] k += [number] [EOL] [EOL] a , p , c = prepare_matrix ( a , p , c , y , m1 ) [EOL] [EOL] result = evaluating ( a , b , c , d , p , y ) [EOL] return result , y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] from kursach . method_potencialov import evaluating [EOL] from kursach . utils import prepare_matrix , unique_rows , generation_start_pull [EOL] [EOL] [EOL] def calculate_deviations ( d , c , m1 , p ) : [EOL] non_build_c = c [ m1 : ] [EOL] non_build_p = p [ m1 : ] [EOL] [EOL] d_average = d . mean ( ) [EOL] p_average = non_build_p . mean ( ) [EOL] ci_average = non_build_c . mean ( axis = [number] ) . mean ( ) [EOL] cj_average = non_build_c . mean ( axis = [number] ) [EOL] [EOL] d_eval = ( d - d_average ) / d_average [EOL] p_eval = ( non_build_p - p_average ) / p_average [EOL] ci_eval = ( non_build_c . mean ( axis = [number] ) - ci_average ) / ci_average [EOL] cj_eval = ( ( non_build_c - cj_average ) / cj_average ) . sum ( axis = [number] ) [EOL] [EOL] deviations = d_eval + p_eval + ci_eval + cj_eval [EOL] [EOL] return deviations [EOL] [EOL] [EOL] def evaluating_method ( a , b , c , d , p , m1 , m2 , pull , repeats , k ) : [EOL] non_build_a = a [ m1 : ] [EOL] default_a_sum = a [ : m1 ] . sum ( ) [EOL] [EOL] Y = generation_start_pull ( pull , m1 , m2 , a , b ) [EOL] [EOL] deviations = calculate_deviations ( d , c , m1 , p ) [EOL] [EOL] repeat = [number] [EOL] record = [number] [EOL] [EOL] target_range = [ ] [EOL] [EOL] while repeat < repeats : [EOL] prev_record = record [EOL] [EOL] targets = np . empty ( ( [number] , [number] ) , int ) [EOL] for y in Y : [EOL] [EOL] plan_a , plan_p , plan_c = prepare_matrix ( a , p , c , y , m1 ) [EOL] [EOL] target = evaluating ( plan_a , b , plan_c , d , plan_p , y ) [EOL] targets = np . append ( targets , target ) [EOL] [EOL] ind = targets . argsort ( ) [ k : ] [EOL] [EOL] record_ind = targets . argsort ( ) [ : [number] ] [EOL] record = targets [ record_ind ] [EOL] target_range . append ( record [ [number] ] ) [EOL] if prev_record > record : [EOL] record_layout = Y [ record_ind ] [EOL] repeat = [number] [EOL] else : [EOL] record = prev_record [EOL] [EOL] Y = np . delete ( Y , ind , axis = [number] ) [EOL] [EOL] for y in Y : [EOL] local_pull = np . empty ( ( [number] , m2 ) , int ) [EOL] local_deviations = np . empty ( ( [number] , [number] ) , int ) [EOL] for i in range ( len ( y ) ) : [EOL] new_y = y . copy ( ) [EOL] if y [ i ] == [number] : [EOL] new_y [ i ] = [number] [EOL] elif y [ i ] == [number] : [EOL] new_y [ i ] = [number] [EOL] sum_a = default_a_sum + ( non_build_a * new_y ) . sum ( ) [EOL] if sum_a >= b . sum ( ) : [EOL] local_pull = np . append ( local_pull , [ new_y ] , axis = [number] ) [EOL] deviation = ( new_y * deviations ) . sum ( ) [EOL] local_deviations = np . append ( local_deviations , deviation ) [EOL] ind = local_deviations . argsort ( ) [ int ( m2 / [number] ) : ] [EOL] local_pull = np . delete ( local_pull , ind , axis = [number] ) [EOL] Y = np . append ( Y , local_pull , axis = [number] ) [EOL] [EOL] Y = unique_rows ( Y ) [EOL] [comment] [EOL] repeat += [number] [EOL] [EOL] return record , record_layout [ [number] ] , target_range [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import sys [EOL] import time [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] [EOL] ROOT_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] [EOL] sys . path . append ( ROOT_DIR ) [EOL] [EOL] from kursach . utils import seconds_to_human [EOL] from kursach . cli import parse_cli_args [EOL] import numpy as np [EOL] from kursach . evaluating_method import evaluating_method [EOL] from kursach . random_method import random_method [EOL] from kursach . greedy_algorithm import greedy_algorithm [EOL] [EOL] [EOL] PULL = [number] [EOL] REPEATS = [number] [comment] [EOL] K = [number] [EOL] [EOL] [EOL] def main ( ) : [EOL] parsed_args = parse_cli_args ( ) [EOL] [EOL] evaluating_type = parsed_args . evaluating_type [EOL] [EOL] if evaluating_type == [string] : [EOL] [EOL] t_g = [ ] [EOL] t_e = [ ] [EOL] t_r = [ ] [EOL] target_g = [ ] [EOL] target_e = [ ] [EOL] target_r = [ ] [EOL] dimension = [ ] [EOL] [EOL] range_file_path = parsed_args . range_file_path [EOL] [EOL] with open ( range_file_path , [string] ) as input_file : [EOL] m2 , m1 , n = input_file . readline ( ) . split ( ) [EOL] a1 , b1 = input_file . readline ( ) . split ( ) [EOL] a2 , b2 = input_file . readline ( ) . split ( ) [EOL] a3 , b3 = input_file . readline ( ) . split ( ) [EOL] a4 , b4 = input_file . readline ( ) . split ( ) [EOL] a5 , b5 = input_file . readline ( ) . split ( ) [EOL] [EOL] m2 = int ( m2 ) [EOL] m1 = int ( m1 ) [EOL] n = int ( n ) [EOL] [EOL] for i in range ( [number] ) : [EOL] A = np . array ( np . random . randint ( int ( a1 ) , int ( b1 ) , size = ( m1 + m2 ) ) ) [EOL] B = np . array ( np . random . randint ( int ( a2 ) , int ( b2 ) , size = n ) ) [EOL] while A . sum ( ) < B . sum ( ) : [EOL] A = np . array ( np . random . randint ( int ( a1 ) , int ( b1 ) , size = ( m1 + m2 ) ) ) [EOL] B = np . array ( np . random . randint ( int ( a2 ) , int ( b2 ) , size = n ) ) [EOL] C = np . array ( np . random . randint ( int ( a3 ) , int ( b3 ) , size = ( ( m1 + m2 ) , n ) ) ) [EOL] D = np . array ( np . random . randint ( int ( a4 ) , int ( b4 ) , size = m2 ) ) [EOL] P = np . array ( np . random . randint ( int ( a5 ) , int ( b5 ) , size = ( m1 + m2 ) ) ) [EOL] [EOL] print ( [string] , i , [string] , m1 , [string] , m2 , [string] , n ) [EOL] [EOL] [comment] [EOL] [EOL] start_time = time . time ( ) [EOL] result , y = greedy_algorithm ( A , B , C , D , P , int ( m1 ) , int ( m2 ) ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] t_g . append ( total_time ) [EOL] target_g . append ( result ) [EOL] [EOL] print ( [string] , result , np . array ( y ) ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] print ( [string] ) [EOL] [EOL] start_time = time . time ( ) [EOL] record , record_layout , target_range = evaluating_method ( A , B , C , D , P , m1 , m2 , PULL , REPEATS , K ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] t_e . append ( total_time ) [EOL] target_e . append ( record [ [number] ] ) [EOL] [EOL] print ( [string] , record , record_layout ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] print ( [string] ) [EOL] [EOL] start_time = time . time ( ) [EOL] record , record_layout , target_range = random_method ( A , B , C , D , P , m1 , m2 , PULL , REPEATS , K ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] t_r . append ( total_time ) [EOL] target_r . append ( record [ [number] ] ) [EOL] [EOL] print ( [string] , record , record_layout ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] m2 = int ( [number] + m2 ) [EOL] [comment] [EOL] [EOL] dimension . append ( m2 ) [EOL] [EOL] plt . figure ( figsize = ( [number] , [number] ) ) [EOL] [EOL] plt . subplot ( [number] ) [EOL] plt . plot ( dimension , t_g , label = [string] ) [EOL] plt . plot ( dimension , t_e , label = [string] ) [EOL] plt . plot ( dimension , t_r , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] plt . subplot ( [number] ) [EOL] width = [number] [comment] [EOL] ind = np . arange ( len ( dimension ) ) [EOL] plt . bar ( ind - width * [number] , target_g , width , label = [string] ) [EOL] plt . bar ( ind - width * [number] , target_e , width , label = [string] ) [EOL] plt . bar ( ind + width * [number] , target_r , width , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] elif evaluating_type == [string] : [EOL] input_type = parsed_args . input_type [EOL] [EOL] if input_type == [string] : [EOL] [EOL] range_file_path = parsed_args . range_file_path [EOL] [EOL] with open ( range_file_path , [string] ) as input_file : [EOL] m2 , m1 , n = input_file . readline ( ) . split ( ) [EOL] [EOL] m2 = int ( m2 ) [EOL] m1 = int ( m1 ) [EOL] n = int ( n ) [EOL] [EOL] a , b = input_file . readline ( ) . split ( ) [EOL] A = np . array ( np . random . randint ( a , b , size = ( m1 + m2 ) ) ) [EOL] [EOL] a , b = input_file . readline ( ) . split ( ) [EOL] B = np . array ( np . random . randint ( a , b , size = n ) ) [EOL] [EOL] a , b = input_file . readline ( ) . split ( ) [EOL] C = np . array ( np . random . randint ( a , b , size = ( ( m1 + m2 ) , n ) ) ) [EOL] [EOL] a , b = input_file . readline ( ) . split ( ) [EOL] D = np . array ( np . random . randint ( a , b , size = m2 ) ) [EOL] [EOL] a , b = input_file . readline ( ) . split ( ) [EOL] P = np . array ( np . random . randint ( a , b , size = ( m1 + m2 ) ) ) [EOL] [EOL] print ( [string] , A ) [EOL] print ( [string] , B ) [EOL] print ( [string] , C ) [EOL] print ( [string] , D ) [EOL] print ( [string] , P ) [EOL] [EOL] elif input_type == [string] : [EOL] input_file_path = parsed_args . file_path [EOL] [EOL] with open ( input_file_path , [string] ) as input_file : [EOL] m2 , m1 , n = input_file . readline ( ) . split ( ) [EOL] [EOL] A = input_file . readline ( ) . split ( ) [EOL] B = input_file . readline ( ) . split ( ) [EOL] D = input_file . readline ( ) . split ( ) [EOL] P = input_file . readline ( ) . split ( ) [EOL] C = input_file . read ( ) . split ( ) [EOL] [EOL] m2 = int ( m2 ) [EOL] m1 = int ( m1 ) [EOL] n = int ( n ) [EOL] [EOL] A = np . array ( A ) . astype ( np . int ) [EOL] B = np . array ( B ) . astype ( np . int ) [EOL] C = np . array ( C ) . astype ( np . int ) . reshape ( m1 + m2 , n ) [EOL] D = np . array ( D ) . astype ( np . int ) [EOL] P = np . array ( P ) . astype ( np . int ) [EOL] [EOL] print ( [string] , A ) [EOL] print ( [string] , B ) [EOL] print ( [string] , C ) [EOL] print ( [string] , D ) [EOL] print ( [string] , P ) [EOL] [EOL] start_time = time . time ( ) [EOL] result = greedy_algorithm ( A , B , C , D , P , m1 , m2 ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] print ( [string] , result ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] [EOL] plt . figure ( figsize = ( [number] , [number] ) ) [EOL] [EOL] start_time = time . time ( ) [EOL] record , record_layout , target_range = evaluating_method ( A , B , C , D , P , m1 , m2 , PULL , REPEATS , K ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] print ( [string] , record , record_layout ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] plt . subplot ( [number] ) [EOL] x = np . arange ( len ( target_range ) ) [EOL] plt . plot ( x , target_range , label = [string] ) [EOL] [EOL] start_time = time . time ( ) [EOL] record , record_layout , target_range = random_method ( A , B , C , D , P , m1 , m2 , PULL , REPEATS , K ) [EOL] end_time = time . time ( ) [EOL] total_time = round ( end_time - start_time ) [EOL] [EOL] print ( [string] , record , record_layout ) [EOL] print ( [string] , seconds_to_human ( total_time ) ) [EOL] [EOL] plt . subplot ( [number] ) [EOL] x = np . arange ( len ( target_range ) ) [EOL] plt . plot ( x , target_range , label = [string] ) [EOL] [EOL] plt . ylabel ( [string] ) [EOL] [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import argparse [EOL] import builtins [EOL] import os [EOL] import argparse [EOL] [EOL] ROOT_DIR = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] [EOL] [EOL] def parse_cli_args ( args = None ) : [EOL] [docstring] [EOL] arg_parser = argparse . ArgumentParser ( description = [string] ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = [number] , ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = [number] , ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = [number] , ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = os . path . join ( ROOT_DIR , [string] ) ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = os . path . join ( ROOT_DIR , [string] ) ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = [string] ) [EOL] [EOL] arg_parser . add_argument ( [string] , [string] , default = [string] ) [EOL] [EOL] return arg_parser . parse_args ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] from kursach . method_potencialov import evaluating [EOL] from kursach . utils import generation_start_pull , prepare_matrix , unique_rows [EOL] [EOL] [EOL] def random_method ( a , b , c , d , p , m1 , m2 , pull , repeats , k ) : [EOL] Y = generation_start_pull ( pull , m1 , m2 , a , b ) [EOL] [EOL] origin_sum_a = a [ : m1 ] . sum ( ) [EOL] non_build_a = a [ m1 : ] [EOL] [EOL] repeat = [number] [EOL] record = [number] [EOL] [EOL] target_range = [ ] [EOL] [EOL] while repeat < repeats : [EOL] prev_record = record [EOL] [EOL] targets = np . empty ( ( [number] , [number] ) , int ) [EOL] [EOL] for y in Y : [EOL] plan_a , plan_p , plan_c = prepare_matrix ( a , p , c , y , m1 ) [EOL] [EOL] target = evaluating ( plan_a , b , plan_c , d , plan_p , y ) [EOL] targets = np . append ( targets , target ) [EOL] [EOL] ind = targets . argsort ( ) [ k : ] [EOL] [EOL] record_ind = targets . argsort ( ) [ : [number] ] [EOL] record = targets [ record_ind ] [EOL] target_range . append ( record [ [number] ] ) [EOL] if prev_record > record : [EOL] record_layout = Y [ record_ind ] [EOL] repeat = [number] [EOL] else : [EOL] record = prev_record [EOL] [EOL] [comment] [EOL] [EOL] Y = np . delete ( Y , ind , axis = [number] ) [EOL] [EOL] for y in Y : [EOL] local_pull = np . empty ( ( [number] , m2 ) , int ) [EOL] for i in range ( len ( y ) ) : [EOL] new_y = y . copy ( ) [EOL] if y [ i ] == [number] : [EOL] new_y [ i ] = [number] [EOL] elif y [ i ] == [number] : [EOL] new_y [ i ] = [number] [EOL] sum_a = origin_sum_a + ( non_build_a * new_y ) . sum ( ) [EOL] if sum_a >= b . sum ( ) : [EOL] local_pull = np . append ( local_pull , [ new_y ] , axis = [number] ) [EOL] ind = np . array ( np . random . randint ( int ( pull / [number] ) , size = ( int ( m2 / [number] ) ) ) ) [EOL] local_pull = np . delete ( local_pull , ind , axis = [number] ) [EOL] Y = np . append ( Y , local_pull , axis = [number] ) [EOL] [EOL] Y = unique_rows ( Y ) [EOL] [comment] [EOL] repeat += [number] [EOL] [EOL] return record , record_layout [ [number] ] , target_range [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import numpy as np [EOL] [EOL] [EOL] def prepare_matrix ( a , p , c , y , m1 ) : [EOL] i , = np . where ( y == [number] ) [EOL] c = np . delete ( c , i + m1 , axis = [number] ) [EOL] p = np . delete ( p , i + m1 , axis = [number] ) [EOL] a = np . delete ( a , i + m1 , axis = [number] ) [EOL] [EOL] c = c + p . reshape ( p . shape [ [number] ] , [number] ) [EOL] [EOL] return a , p , c [EOL] [EOL] [EOL] def generation_start_pull ( pull , m1 , m2 , a , b ) : [EOL] Y = np . empty ( ( [number] , [number] ) ) [EOL] origin_sum_a = a [ : m1 ] . sum ( ) [EOL] non_build_a = a [ m1 : ] [EOL] while Y . shape [ [number] ] < pull / [number] : [EOL] Y = np . array ( np . random . randint ( [number] , size = ( pull , m2 ) ) ) [EOL] sum_a = origin_sum_a + ( non_build_a * Y ) . sum ( axis = [number] ) [EOL] i , = np . where ( sum_a < b . sum ( ) ) [EOL] Y = np . delete ( Y , i , axis = [number] ) [EOL] [EOL] return Y [EOL] [EOL] [EOL] def unique_rows ( a ) : [EOL] a = np . ascontiguousarray ( a ) [EOL] unique_a = np . unique ( a . view ( [ ( [string] , a . dtype ) ] * a . shape [ [number] ] ) ) [EOL] return unique_a . view ( a . dtype ) . reshape ( ( unique_a . shape [ [number] ] , a . shape [ [number] ] ) ) [EOL] [EOL] [EOL] def validate_input_data ( ) : [EOL] pass [EOL] [EOL] [EOL] def seconds_to_human ( sec ) : [EOL] h = sec // [number] [EOL] m = ( sec - h * [number] ) // [number] [EOL] s = sec - m * [number] - h * [number] [EOL] return f"{ h } [string] { m } [string] { s } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0