[docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Callable , Dict , Union , List , Tuple , Any [EOL] import web3 [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import eth_abi [EOL] import raiden_contracts [EOL] import logging [EOL] import sys [EOL] import requests [EOL] from typing import Callable , Dict , Union , List , Tuple [EOL] [EOL] from eth_abi . codec import ABICodec [EOL] from web3 import Web3 [EOL] from web3 . _utils . events import get_event_data [EOL] from web3 . _utils . abi import filter_by_type [EOL] from eth_utils import to_checksum_address , encode_hex , decode_hex [EOL] from eth_utils . abi import event_abi_to_log_topic [EOL] import gevent [EOL] import gevent . event [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] from raiden_contracts . constants import ( CONTRACT_TOKEN_NETWORK_REGISTRY , EVENT_TOKEN_NETWORK_CREATED , ) [EOL] from web3 . types import FilterParams [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def create_channel_event_topics ( ) : [EOL] return [ None , ] [EOL] [EOL] [EOL] def create_registry_event_topics ( contract_manager ) : [EOL] new_network_abi = contract_manager . get_event_abi ( CONTRACT_TOKEN_NETWORK_REGISTRY , EVENT_TOKEN_NETWORK_CREATED , ) [EOL] return [ encode_hex ( event_abi_to_log_topic ( new_network_abi ) ) ] [EOL] [EOL] [EOL] def decode_event ( codec , topic_to_event_abi , log_entry ) : [EOL] topic = log_entry [ [string] ] [ [number] ] [EOL] event_abi = topic_to_event_abi [ topic ] [EOL] [EOL] return get_event_data ( codec , event_abi , log_entry ) [EOL] [EOL] [EOL] def get_events ( web3 , contract_address , topics , from_block = [number] , to_block = [string] , ) : [EOL] [docstring] [EOL] filter_params = FilterParams ( { [string] : from_block , [string] : to_block , [string] : to_checksum_address ( contract_address ) , [string] : topics , } ) [EOL] [EOL] return web3 . eth . getLogs ( filter_params ) [EOL] [EOL] [EOL] class BlockchainListener ( gevent . Greenlet ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , web3 , contract_manager , contract_name , contract_address , * , required_confirmations = [number] , sync_chunk_size = [number] , poll_interval = [number] , sync_start_block = [number] , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . contract_manager = contract_manager [EOL] self . contract_name = contract_name [EOL] self . contract_address = contract_address [EOL] [EOL] self . required_confirmations = required_confirmations [EOL] self . web3 = web3 [EOL] [EOL] self . confirmed_callbacks = { } [EOL] self . unconfirmed_callbacks = { } [EOL] [EOL] self . wait_sync_event = gevent . event . Event ( ) [EOL] self . is_connected = gevent . event . Event ( ) [EOL] self . sync_chunk_size = sync_chunk_size [EOL] self . running = False [EOL] self . poll_interval = poll_interval [EOL] [EOL] self . unconfirmed_head_number = sync_start_block [EOL] self . confirmed_head_number = sync_start_block [EOL] self . unconfirmed_head_hash = None [EOL] self . confirmed_head_hash = None [EOL] [EOL] self . counter = [number] [EOL] [EOL] def add_confirmed_listener ( self , topics , callback ) : [EOL] [docstring] [EOL] self . confirmed_callbacks [ self . counter ] = ( topics , callback ) [EOL] self . counter += [number] [EOL] [EOL] def add_unconfirmed_listener ( self , topics , callback ) : [EOL] [docstring] [EOL] self . unconfirmed_callbacks [ self . counter ] = ( topics , callback ) [EOL] self . counter += [number] [EOL] [EOL] def _run ( self ) : [EOL] self . running = True [EOL] log . info ( [string] , self . poll_interval ) [EOL] while self . running : [EOL] try : [EOL] self . _update ( ) [EOL] self . is_connected . set ( ) [EOL] if self . wait_sync_event . is_set ( ) : [EOL] gevent . sleep ( self . poll_interval ) [EOL] except requests . exceptions . ConnectionError as e : [EOL] endpoint = self . web3 . currentProvider . endpoint_uri [EOL] log . warning ( [string] % ( endpoint , self . poll_interval ) , ) [EOL] gevent . sleep ( self . poll_interval ) [EOL] self . is_connected . clear ( ) [EOL] log . info ( [string] ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] self . running = False [EOL] [EOL] def wait_sync ( self ) : [EOL] [docstring] [EOL] self . wait_sync_event . wait ( ) [EOL] [EOL] def _update ( self ) : [EOL] current_block = self . web3 . eth . blockNumber [EOL] [EOL] [comment] [EOL] self . reset_unconfirmed_on_reorg ( current_block ) [EOL] [EOL] new_unconfirmed_head_number = self . unconfirmed_head_number + self . sync_chunk_size [EOL] new_unconfirmed_head_number = min ( new_unconfirmed_head_number , current_block ) [EOL] new_confirmed_head_number = max ( new_unconfirmed_head_number - self . required_confirmations , self . confirmed_head_number , ) [EOL] [EOL] [comment] [EOL] if ( self . confirmed_head_number >= new_confirmed_head_number and self . unconfirmed_head_number >= new_unconfirmed_head_number ) : [EOL] return [EOL] [EOL] run_confirmed_filters = ( self . confirmed_head_number < new_confirmed_head_number and len ( self . confirmed_callbacks ) > [number] ) [EOL] if run_confirmed_filters : [EOL] [comment] [EOL] filters_confirmed = self . get_filter_params ( self . confirmed_head_number , new_confirmed_head_number , ) [EOL] log . info ( [string] , filters_confirmed [ [string] ] , filters_confirmed [ [string] ] , current_block , ) [EOL] [comment] [EOL] self . filter_events ( filters_confirmed , self . confirmed_callbacks ) [EOL] log . debug ( [string] ) [EOL] [EOL] run_unconfirmed_filters = ( self . unconfirmed_head_number < new_unconfirmed_head_number and len ( self . unconfirmed_callbacks ) > [number] ) [EOL] if run_unconfirmed_filters : [EOL] [comment] [EOL] filters_unconfirmed = self . get_filter_params ( self . unconfirmed_head_number , new_unconfirmed_head_number , ) [EOL] log . debug ( [string] , filters_unconfirmed [ [string] ] , filters_unconfirmed [ [string] ] , current_block , ) [EOL] [comment] [EOL] self . filter_events ( filters_unconfirmed , self . unconfirmed_callbacks ) [EOL] log . debug ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] new_unconfirmed_head_hash = self . web3 . eth . getBlock ( new_unconfirmed_head_number ) . hash [EOL] new_confirmed_head_hash = self . web3 . eth . getBlock ( new_confirmed_head_number ) . hash [EOL] except AttributeError : [EOL] log . critical ( [string] [string] % ( new_unconfirmed_head_number , new_confirmed_head_number ) ) [EOL] log . critical ( [string] [string] ) [EOL] log . critical ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] self . unconfirmed_head_number = new_unconfirmed_head_number [EOL] self . unconfirmed_head_hash = new_unconfirmed_head_hash [EOL] self . confirmed_head_number = new_confirmed_head_number [EOL] self . confirmed_head_hash = new_confirmed_head_hash [EOL] [EOL] if not self . wait_sync_event . is_set ( ) and new_unconfirmed_head_number == current_block : [EOL] self . wait_sync_event . set ( ) [EOL] [EOL] def filter_events ( self , filter_params , name_to_callback ) : [EOL] [docstring] [EOL] for id , ( topics , callback ) in name_to_callback . items ( ) : [EOL] events = get_events ( web3 = self . web3 , contract_address = self . contract_address , topics = topics , ** filter_params , ) [EOL] [EOL] events_abi = filter_by_type ( [string] , self . contract_manager . get_contract_abi ( self . contract_name ) ) [EOL] topic_to_event_abi = { event_abi_to_log_topic ( event_abi ) : event_abi for event_abi in events_abi } [EOL] for raw_event in events : [EOL] decoded_event = decode_event ( codec = self . web3 . codec , topic_to_event_abi = topic_to_event_abi , log_entry = raw_event , ) [EOL] log . debug ( [string] , decoded_event ) [EOL] callback ( decoded_event ) [EOL] [EOL] def _detected_chain_reorg ( self , current_block ) : [EOL] log . debug ( [string] [string] [string] , self . unconfirmed_head_number , current_block , current_block - self . unconfirmed_head_number , ) [EOL] [comment] [EOL] self . unconfirmed_head_number = self . confirmed_head_number [EOL] self . unconfirmed_head_hash = self . confirmed_head_hash [EOL] [EOL] def reset_unconfirmed_on_reorg ( self , current_block ) : [EOL] [docstring] [EOL] if self . wait_sync_event . is_set ( ) : [comment] [EOL] [EOL] [comment] [EOL] if current_block >= self . unconfirmed_head_number : [EOL] [comment] [EOL] current_unconfirmed_hash = self . web3 . eth . getBlock ( self . unconfirmed_head_number , ) [ [string] ] [EOL] if current_unconfirmed_hash != self . unconfirmed_head_hash : [EOL] self . _detected_chain_reorg ( current_block ) [EOL] [comment] [EOL] elif current_block < self . unconfirmed_head_number : [EOL] self . _detected_chain_reorg ( current_block ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] current_head_hash = self . web3 . eth . getBlock ( self . confirmed_head_number ) [ [string] ] [EOL] if current_head_hash != self . confirmed_head_hash : [EOL] log . critical ( [string] [string] [string] , self . confirmed_head_hash , self . confirmed_head_number , current_head_hash , self . required_confirmations , ) [EOL] sys . exit ( [number] ) [comment] [EOL] except AttributeError : [EOL] log . critical ( [string] [string] , self . confirmed_head_number , self . confirmed_head_hash , ) [EOL] sys . exit ( [number] ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def get_filter_params ( self , from_block , to_block ) : [EOL] assert from_block <= to_block [EOL] return { [string] : from_block + [number] , [string] : to_block + [number] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[typing.List,typing.Callable]]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Tuple[typing.List,typing.Callable]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List$ 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] from typing import NewType [EOL] [EOL] T_Address = str [EOL] Address = NewType ( [string] , T_Address ) [EOL] [EOL] T_ChannelIdentifier = int [EOL] ChannelIdentifier = NewType ( [string] , T_ChannelIdentifier ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import metrics_backend [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List [EOL] from functools import reduce [EOL] [EOL] from metrics_backend . model import ( TokenNetwork , ChannelView , PaymentNetworkMetrics , ParticipantsChannels , ) [EOL] from metrics_backend . utils import Address [EOL] [EOL] [EOL] def _state_to_str ( state ) : [EOL] if state == ChannelView . State . OPENED : [EOL] return [string] [EOL] elif state == ChannelView . State . CLOSED : [EOL] return [string] [EOL] elif state == ChannelView . State . SETTLED : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] def _calculate_channels_per_node ( channels_by_participants , num_participants , ) : [EOL] num_channels = reduce ( lambda acc , channels : acc + channels . opened , channels_by_participants . values ( ) , [number] , ) [EOL] return num_channels / num_participants if num_participants > [number] else [number] [EOL] [EOL] def token_network_to_dict ( token_network ) : [EOL] [docstring] [EOL] num_channels_opened = [number] [EOL] num_channels_closed = [number] [EOL] num_channels_settled = [number] [EOL] [EOL] channels = [ ] [EOL] nodes = dict ( ) [EOL] total_deposits = [number] [EOL] [EOL] for channel_id , view in token_network . channels . items ( ) : [EOL] channel = dict ( channel_identifier = channel_id , status = _state_to_str ( view . state ) , participant1 = view . participant1 , participant2 = view . participant2 , deposit1 = view . deposit_p1 , deposit2 = view . deposit_p2 , ) [EOL] channels . append ( channel ) [EOL] [EOL] if view . state == ChannelView . State . OPENED : [EOL] num_channels_opened += [number] [EOL] total_deposits += view . deposit_p1 [EOL] total_deposits += view . deposit_p2 [EOL] elif view . state == ChannelView . State . CLOSED : [EOL] num_channels_closed += [number] [EOL] elif view . state == ChannelView . State . SETTLED : [EOL] num_channels_settled += [number] [EOL] [EOL] for address , participants_channels in token_network . participants . items ( ) : [EOL] nodes [ address ] = dict ( opened = participants_channels . opened , closed = participants_channels . closed , settled = participants_channels . settled , ) [EOL] [EOL] num_nodes_with_open_channels = reduce ( lambda acc , channels : acc + ( [number] if channels . opened > [number] else [number] ) , token_network . participants . values ( ) , [number] , ) [EOL] [EOL] if num_channels_opened > [number] : [EOL] avg_deposit_per_channel = total_deposits / num_channels_opened [EOL] else : [EOL] avg_deposit_per_channel = [number] [EOL] [EOL] if num_nodes_with_open_channels > [number] : [EOL] avg_deposit_per_node = total_deposits / num_nodes_with_open_channels [EOL] else : [EOL] avg_deposit_per_node = [number] [EOL] [EOL] avg_channels_per_node = _calculate_channels_per_node ( token_network . participants , num_nodes_with_open_channels , ) [EOL] [EOL] return dict ( address = token_network . address , token = dict ( address = token_network . token_info . address , name = token_network . token_info . name , symbol = token_network . token_info . symbol , decimals = token_network . token_info . decimals , ) , num_channels_total = len ( channels ) , num_channels_opened = num_channels_opened , num_channels_closed = num_channels_closed , num_channels_settled = num_channels_settled , total_deposits = total_deposits , avg_deposit_per_channel = avg_deposit_per_channel , avg_deposit_per_node = avg_deposit_per_node , avg_channels_per_node = avg_channels_per_node , channels = channels , nodes = nodes , ) [EOL] [EOL] def metrics_to_dict ( payment_network_metrics ) : [EOL] [docstring] [EOL] [EOL] open_channels_by_participant = payment_network_metrics . open_channels_by_participant [EOL] [EOL] summed_open_channels = reduce ( lambda acc , channels : acc + channels , open_channels_by_participant . values ( ) , [number] , ) [EOL] num_nodes_with_open_channels = reduce ( lambda acc , channels : acc + ( [number] if channels > [number] else [number] ) , open_channels_by_participant . values ( ) , [number] , ) [EOL] [EOL] if num_nodes_with_open_channels > [number] : [EOL] avg_channels_per_node = summed_open_channels / num_nodes_with_open_channels [EOL] else : [EOL] avg_channels_per_node = [number] [EOL] [EOL] top_nodes_by_channels = sorted ( [ { [string] : node , [string] : num } for node , num in open_channels_by_participant . items ( ) ] , key = lambda participant : participant [ [string] ] ) [ - [number] : ] [EOL] [EOL] return dict ( num_token_networks = payment_network_metrics . num_token_networks , num_channels_opened = payment_network_metrics . num_channels_opened , num_channels_closed = payment_network_metrics . num_channels_closed , num_channels_settled = payment_network_metrics . num_channels_settled , num_nodes_with_open_channels = num_nodes_with_open_channels , avg_channels_per_node = avg_channels_per_node , top_nodes_by_channels = top_nodes_by_channels ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import web3 [EOL] import metrics_backend [EOL] import builtins [EOL] from web3 . contract import Contract [EOL] from web3 . exceptions import BadFunctionCallOutput [EOL] [EOL] from metrics_backend . model import TokenInfo [EOL] [EOL] [EOL] def get_token_name ( token_contract ) : [EOL] try : [EOL] return token_contract . functions . name ( ) . call ( ) [EOL] except BadFunctionCallOutput : [EOL] return [string] [EOL] [comment] [EOL] except ValueError : [EOL] return [string] [EOL] [EOL] [EOL] def get_token_symbol ( token_contract ) : [EOL] try : [EOL] return token_contract . functions . symbol ( ) . call ( ) [EOL] except BadFunctionCallOutput : [EOL] return [string] [EOL] [comment] [EOL] except ( ValueError , OverflowError ) : [EOL] return [string] [EOL] [EOL] [EOL] def get_token_decimals ( token_contract ) : [EOL] try : [EOL] return token_contract . functions . decimals ( ) . call ( ) [EOL] except BadFunctionCallOutput : [EOL] return [number] [EOL] [comment] [EOL] except ValueError : [EOL] return [number] [EOL] [EOL] [EOL] def get_token_info ( token_contract ) : [EOL] return TokenInfo ( token_contract . address , get_token_name ( token_contract ) , get_token_symbol ( token_contract ) , get_token_decimals ( token_contract ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.model.TokenInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import builtins [EOL] import backend [EOL] import logging [EOL] import typing [EOL] import metrics_backend [EOL] import logging [EOL] from typing import Dict [EOL] [EOL] from eth_utils import is_checksum_address [EOL] from dataclasses import dataclass [EOL] from metrics_backend . utils import Address , ChannelIdentifier [EOL] [EOL] from metrics_backend . model import ChannelView [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ dataclass class TokenInfo : [EOL] address = ... [EOL] name = ... [EOL] symbol = ... [EOL] decimals = ... [EOL] [EOL] @ dataclass class ParticipantsChannels : [EOL] opened = ... [EOL] closed = ... [EOL] settled = ... [EOL] [EOL] [EOL] class TokenNetwork : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , token_network_address , token_info ) : [EOL] [docstring] [EOL] [EOL] self . address = token_network_address [EOL] self . token_info = token_info [EOL] self . channels = dict ( ) [EOL] self . participants = dict ( ) [EOL] [EOL] def handle_channel_opened_event ( self , channel_identifier , participant1 , participant2 , ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] view = ChannelView ( channel_identifier , participant1 , participant2 ) [EOL] self . channels [ channel_identifier ] = view [EOL] [EOL] self . _add_opened_channel_to_participant ( participant1 ) [EOL] self . _add_opened_channel_to_participant ( participant2 ) [EOL] [EOL] def handle_channel_new_deposit_event ( self , channel_identifier , receiver , total_deposit ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( receiver ) [EOL] [EOL] try : [EOL] self . channels [ channel_identifier ] . update_deposit ( receiver , total_deposit ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] [EOL] def handle_channel_withdraw_event ( self , channel_identifier , withdrawing_participant , total_withdraw ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( withdrawing_participant ) [EOL] [EOL] if not channel_identifier in self . channels : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] return [EOL] [EOL] self . channels [ channel_identifier ] . withdraw ( withdrawing_participant , total_withdraw ) [EOL] [EOL] def handle_channel_closed_event ( self , channel_identifier ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] channel = self . channels [ channel_identifier ] [EOL] channel . update_state ( ChannelView . State . CLOSED ) [EOL] [EOL] self . _add_closed_channel_to_participant ( channel . participant1 ) [EOL] self . _add_closed_channel_to_participant ( channel . participant2 ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] [EOL] def handle_channel_settled_event ( self , channel_identifier ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] channel = self . channels [ channel_identifier ] [EOL] channel . update_state ( ChannelView . State . SETTLED ) [EOL] [EOL] self . _add_settled_channel_to_participant ( channel . participant1 ) [EOL] self . _add_settled_channel_to_participant ( channel . participant2 ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] [EOL] def get_channel ( self , channel_identifier ) : [EOL] if not channel_identifier in self . channels . keys ( ) : [EOL] return None [EOL] else : [EOL] return self . channels [ channel_identifier ] [EOL] [EOL] def _add_opened_channel_to_participant ( self , participant ) : [EOL] if not participant in self . participants : [EOL] self . participants [ participant ] = ParticipantsChannels ( [number] , [number] , [number] ) [EOL] self . participants [ participant ] . opened += [number] [EOL] [EOL] def _add_closed_channel_to_participant ( self , participant ) : [EOL] self . participants [ participant ] . opened -= [number] [EOL] self . participants [ participant ] . closed += [number] [EOL] [EOL] def _add_settled_channel_to_participant ( self , participant ) : [EOL] self . participants [ participant ] . closed -= [number] [EOL] self . participants [ participant ] . settled += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $metrics_backend.utils.Address$ 0 $backend.metrics_backend.model.token_network.TokenInfo$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 $backend.metrics_backend.model.token_network.TokenInfo$ 0 $backend.metrics_backend.model.token_network.TokenInfo$ 0 0 0 $typing.Dict[metrics_backend.utils.ChannelIdentifier,metrics_backend.model.ChannelView]$ 0 0 0 0 0 0 0 $typing.Dict[metrics_backend.utils.Address,ParticipantsChannels]$ 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 $metrics_backend.utils.Address$ 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 $typing.Any$ 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 $metrics_backend.utils.Address$ 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 $typing.Any$ 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.ChannelIdentifier$ 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0
import ChannelView [EOL] import metrics_backend [EOL] import builtins [EOL] from enum import Enum [EOL] [EOL] from eth_utils import is_checksum_address [EOL] from metrics_backend . utils import Address , ChannelIdentifier [EOL] [EOL] [EOL] class ChannelView : [EOL] [docstring] [EOL] class State ( Enum ) : [EOL] OPENED = [string] , [EOL] CLOSED = [string] , [EOL] SETTLED = [string] , [EOL] [EOL] def __init__ ( self , channel_id , participant1 , participant2 , ) : [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] self . participant1 = participant1 [EOL] self . participant2 = participant2 [EOL] [EOL] self . channel_id = channel_id [EOL] self . _deposit_p1 = [number] [EOL] self . _deposit_p2 = [number] [EOL] self . state = ChannelView . State . OPENED [EOL] [EOL] self . _total_deposit_p1 = [number] [EOL] self . _total_deposit_p2 = [number] [EOL] self . _total_withdraw_p1 = [number] [EOL] self . _total_withdraw_p2 = [number] [EOL] [EOL] def update_deposit ( self , participant , new_total_deposit = None , ) : [EOL] if new_total_deposit is not None : [EOL] if participant == self . participant1 : [EOL] self . _deposit_p1 += new_total_deposit - self . _total_deposit_p1 [EOL] self . _total_deposit_p1 = new_total_deposit [EOL] elif participant == self . participant2 : [EOL] self . _deposit_p2 += new_total_deposit - self . _total_deposit_p2 [EOL] self . _total_deposit_p2 = new_total_deposit [EOL] [EOL] def withdraw ( self , participant , new_total_withdraw , ) : [EOL] if participant == self . participant1 : [EOL] self . _deposit_p1 -= new_total_withdraw - self . _total_withdraw_p1 [EOL] self . _total_withdraw_p1 = new_total_withdraw [EOL] elif participant == self . participant2 : [EOL] self . _deposit_p2 -= new_total_withdraw - self . _total_withdraw_p2 [EOL] self . _total_withdraw_p2 = new_total_withdraw [EOL] [EOL] def update_state ( self , new_state ) : [EOL] if new_state is not None : [EOL] self . state = new_state [EOL] [EOL] @ property def deposit_p1 ( self ) : [EOL] return self . _deposit_p1 [EOL] [EOL] @ property def deposit_p2 ( self ) : [EOL] return self . _deposit_p2 [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . channel_id , self . participant1 , self . participant2 , self . state , self . deposit_p1 , self . deposit_p2 , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 $builtins.int$ 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $ChannelView.State$ 0 0 0 0 $ChannelView.State$ 0 0 0 0 0 0 0 0 0 $ChannelView.State$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . channel_view import ChannelView [EOL] from . token_network import TokenNetwork , TokenInfo , ParticipantsChannels [EOL] from . payment_network_metrics import PaymentNetworkMetrics [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import logging [EOL] import metrics_backend [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] from typing import Dict [EOL] from collections import defaultdict [EOL] [EOL] from eth_utils import is_checksum_address [EOL] from metrics_backend . utils import Address [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class PaymentNetworkMetrics : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] self . num_token_networks = [number] [EOL] self . num_channels_opened = [number] [EOL] self . num_channels_closed = [number] [EOL] self . num_channels_settled = [number] [EOL] self . open_channels_by_participant = defaultdict ( lambda : [number] ) [EOL] [EOL] def handle_channel_opened_event ( self , participant1 , participant2 , ) : [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] self . num_channels_opened += [number] [EOL] self . _add_opened_channel_to_participant ( participant1 ) [EOL] self . _add_opened_channel_to_participant ( participant2 ) [EOL] [EOL] def handle_channel_closed_event ( self , participant1 , participant2 , ) : [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] self . num_channels_opened -= [number] [EOL] self . num_channels_closed += [number] [EOL] self . _remove_opened_channel_from_participant ( participant1 ) [EOL] self . _remove_opened_channel_from_participant ( participant2 ) [EOL] [EOL] def handle_channel_settled_event ( self ) : [EOL] self . num_channels_closed -= [number] [EOL] self . num_channels_settled += [number] [EOL] [EOL] def handle_token_network_created ( self ) : [EOL] self . num_token_networks += [number] [EOL] [EOL] def _add_opened_channel_to_participant ( self , participant ) : [EOL] self . open_channels_by_participant [ participant ] += [number] [EOL] [EOL] def _remove_opened_channel_from_participant ( self , participant ) : [EOL] if not self . open_channels_by_participant [ participant ] == [number] : [EOL] self . open_channels_by_participant [ participant ] -= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[metrics_backend.utils.Address,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0 0 0 0 0 0 $metrics_backend.utils.Address$ 0 0 0 0