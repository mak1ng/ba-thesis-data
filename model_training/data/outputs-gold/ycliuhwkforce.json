import os [EOL] import sys [EOL] [EOL] [comment] [EOL] this_dir = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] sys . path . insert ( [number] , os . path . join ( this_dir , [string] ) ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] import sys [EOL] from setuptools import setup [EOL] from pip . req import parse_requirements [EOL] from pip . download import PipSession [EOL] [EOL] VERSION = [string] [EOL] [EOL] scripts = [ [string] ] [EOL] [EOL] install_requires = [ str ( ir . req ) for ir in parse_requirements ( [string] , session = PipSession ( ) ) ] [EOL] [EOL] if __name__ == [string] : [EOL] setup ( name = [string] , version = VERSION , author = [string] , author_email = [string] , license = [string] , url = [string] , description = [string] , packages = [ [string] ] , scripts = scripts , keywords = [ [string] , [string] , [string] , [string] ] , install_requires = install_requires , package_data = { [string] : [ [string] ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import pickle [EOL] [EOL] [EOL] class CacheModule ( object ) : [EOL] [docstring] [EOL] [EOL] def _load ( self , filepath ) : [EOL] [comment] [EOL] with open ( filepath , [string] ) as f : [EOL] return pickle . load ( f , encoding = [string] ) [EOL] [EOL] def _dump ( self , value , filepath ) : [EOL] with open ( filepath , [string] ) as f : [EOL] [comment] [EOL] pickle . dump ( value , f , protocol = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] import logging [EOL] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] ) [EOL] logger = logging . getLogger ( __name__ ) [EOL] BOTO_LOGGER_NAME = [string] [EOL] logging . getLogger ( BOTO_LOGGER_NAME ) . setLevel ( logging . CRITICAL ) [comment] [EOL] [EOL] [EOL] def init_logger ( debug = False ) : [EOL] if debug is True : [EOL] logger . setLevel ( logging . DEBUG ) [EOL] logging . getLogger ( BOTO_LOGGER_NAME ) . setLevel ( logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , Literal , Any [EOL] import typing [EOL] import logging [EOL] import typing_extensions [EOL] import logging [EOL] import os [EOL] import re [EOL] import shutil [EOL] from pprint import pformat [EOL] from base64 import urlsafe_b64encode [EOL] [EOL] import boto3 [EOL] import yaml [EOL] from botocore . errorfactory import ClientError [EOL] [EOL] from . aws_facts import get_vpc_facts [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def ensure_aws_facts ( self ) : [EOL] self . vpc_facts = get_vpc_facts ( vpc_id = self . vpc_id ) [EOL] logger . debug ( [string] , pformat ( self . vpc_facts , indent = [number] , width = [number] ) ) [EOL] [EOL] [EOL] def ensure_kops_k8s_version_consistency ( self ) : [EOL] [comment] [EOL] BIN_DEPS = ( [string] , [string] , ) [EOL] for bin in BIN_DEPS : [EOL] bin_path = shutil . which ( bin ) [EOL] if bin_path is None or not os . access ( bin_path , os . X_OK ) : [EOL] raise RuntimeError ( [string] . format ( bin ) ) [EOL] [EOL] kops_version = None [EOL] k8s_version = None [EOL] try : [EOL] [comment] [EOL] kops_version = re . search ( [string] , self . _kops_cmd ( [string] ) ) . group ( [number] ) [EOL] with open ( os . path . join ( self . DIR_TEMPLATE , [string] ) ) as f : [EOL] k8s_version = re . search ( [string] , f . read ( ) ) . group ( [number] ) [EOL] assert kops_version . split ( [string] ) [ : [number] ] == k8s_version . split ( [string] ) [ : [number] ] [EOL] except Exception as e : [EOL] e . args += ( ( [string] [string] [string] ) . format ( kops_v = kops_version , k8s_v = k8s_version ) , ) [EOL] raise e [EOL] [EOL] [EOL] def ensure_region ( self ) : [EOL] [comment] [EOL] os . environ [ [string] ] = os . environ . get ( [string] , None ) or self . region [EOL] [EOL] [EOL] def ensure_tmp_dir_existing_and_empty ( self ) : [EOL] [comment] [EOL] try : [EOL] logger . debug ( [string] , self . DIR_TMP ) [EOL] shutil . rmtree ( self . DIR_TMP ) [EOL] except FileNotFoundError : [EOL] ... [EOL] finally : [EOL] os . makedirs ( self . DIR_TMP ) [EOL] [EOL] [EOL] def ensure_ssh_pair ( self ) : [EOL] [EOL] [comment] [EOL] public_key_name = [string] [EOL] try : [EOL] with open ( self . current_value_file_path ) as f : [EOL] public_key_material = yaml . load ( f ) [ public_key_name ] [EOL] except ( KeyError , TypeError ) as e : [EOL] e . args += ( [string] . format ( public_key_name , self . current_value_file_path ) , ) [EOL] raise e [EOL] ec2_key_pair_key = self . cluster_name [EOL] try : [EOL] ec2 = boto3 . client ( [string] ) [EOL] ec2 . import_key_pair ( KeyName = ec2_key_pair_key , PublicKeyMaterial = public_key_material ) [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] != [string] : [EOL] raise e [EOL] logger . warn ( [string] , ec2_key_pair_key ) [EOL] [EOL] kops_default_admin_name = [string] [EOL] [EOL] def create_kops_secret_ssh_key ( ) : [EOL] [comment] [EOL] cmd = [string] . format ( kops_u = kops_default_admin_name ) [EOL] ssh_public_key_path = os . path . join ( self . DIR_TMP , urlsafe_b64encode ( ec2_key_pair_key . encode ( ) ) . decode ( ) + [string] ) [EOL] with open ( ssh_public_key_path , [string] ) as f : [EOL] f . write ( public_key_material ) [EOL] cmd += [string] . format ( ssh_public_key_path = ssh_public_key_path , ) [EOL] self . _kops_cmd ( cmd ) [EOL] [EOL] def is_kops_secret_ssh_key_exits ( ) : [EOL] try : [EOL] cmd = [string] . format ( kops_u = kops_default_admin_name ) [EOL] return kops_default_admin_name in ( self . _kops_cmd ( cmd ) or [string] ) [EOL] except RuntimeError as e : [EOL] if [string] in e . args [ [number] ] : [EOL] return False [EOL] raise e [EOL] [EOL] if not is_kops_secret_ssh_key_exits ( ) : [EOL] create_kops_secret_ssh_key ( ) [EOL] [EOL] [EOL] def ensure_state_store ( self ) : [EOL] [EOL] s3 = boto3 . resource ( [string] ) [EOL] bucket = s3 . Bucket ( self . state_store_name ) [EOL] try : [EOL] bucket . create ( ACL = [string] , CreateBucketConfiguration = dict ( LocationConstraint = self . region ) ) [EOL] bucket_versioning = s3 . BucketVersioning ( self . state_store_name ) [EOL] bucket_versioning . enable ( ) [EOL] except ClientError as e : [EOL] if e . response [ [string] ] [ [string] ] == [string] : [EOL] logger . debug ( [string] , self . state_store_name ) [EOL] return [EOL] raise e [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Dict , List , Any , Tuple [EOL] import typing [EOL] import boto3 [comment] [EOL] [EOL] SUBNET_GROUPS = ( [string] , [string] , ) [comment] [EOL] [EOL] [EOL] def check_rt_internet_facing ( facing , route_table ) : [comment] [EOL] assert facing in SUBNET_GROUPS , [string] % SUBNET_GROUPS [EOL] routes_facing_igw = [ route for route in route_table . routes if route . state == [string] [EOL] and route . gateway_id is not None [EOL] and route . gateway_id . startswith ( [string] ) ] [comment] [EOL] routes_facing_nat = [ route for route in route_table . routes if route . state == [string] [EOL] and route . nat_gateway_id is not None [EOL] and route . nat_gateway_id . startswith ( [string] ) ] [comment] [EOL] nat_id = None [EOL] try : [EOL] nat_id = routes_facing_nat [ [number] ] . nat_gateway_id [EOL] except ( AttributeError , IndexError ) : [EOL] ... [EOL] if facing == [string] : [EOL] return len ( routes_facing_igw ) > [number] , nat_id [EOL] elif facing == [string] : [EOL] return len ( routes_facing_igw ) == [number] and len ( routes_facing_nat ) > [number] , nat_id [comment] [EOL] [EOL] [EOL] def get_vpc_facts ( vpc_id ) : [comment] [EOL] ec2_c = boto3 . resource ( [string] ) [EOL] vpc_c = ec2_c . Vpc ( id = vpc_id ) [EOL] [EOL] vpc = dict ( id = vpc_id , cidr = vpc_c . cidr_block ) [EOL] [EOL] azs = set ( ) [EOL] for facing in SUBNET_GROUPS : [EOL] subnets = set ( ) [EOL] for rt in vpc_c . route_tables . all ( ) : [EOL] is_facing_true , nat_id = check_rt_internet_facing ( facing , rt ) [EOL] if not is_facing_true : [EOL] continue [EOL] for asso in rt . associations : [EOL] if asso . main is True : [EOL] [comment] [EOL] continue [EOL] subnet = asso . subnet [EOL] subnets . add ( subnet . id ) [EOL] azs . add ( subnet . availability_zone ) [EOL] [EOL] vpc [ [string] . join ( [ [string] , facing , subnet . availability_zone ] ) ] = [ subnet . id ] [EOL] zone = subnet . availability_zone [ - [number] ] [EOL] vpc [ zone ] = vpc . get ( zone , { } ) [EOL] vpc [ zone ] [ facing ] = dict ( id = subnet . id , cidr = subnet . cidr_block ) [EOL] if facing == [string] and nat_id is not None : [EOL] vpc [ zone ] [ facing ] [ [string] ] = nat_id [EOL] [EOL] vpc [ [string] % facing ] = list ( subnets ) [EOL] [EOL] return dict ( azs = list ( azs ) , vpc = vpc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Union , Type , List , Iterator , Any , Tuple [EOL] import typing [EOL] import logging [EOL] import jinja2 [EOL] import kforce [EOL] import logging [EOL] import os [EOL] import re [EOL] import shutil [EOL] import sys [EOL] from difflib import unified_diff [EOL] from subprocess import getstatusoutput [EOL] [EOL] import yaml [EOL] from jinja2 import Template [EOL] [EOL] from . import init_logger [EOL] from . pre_steps import ( ensure_aws_facts , ensure_kops_k8s_version_consistency , ensure_region , ensure_ssh_pair , ensure_state_store , ensure_tmp_dir_existing_and_empty , ) [EOL] from . utils import color_diff [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class UnSupportedCommand ( BaseException ) : [EOL] ... [EOL] [EOL] [EOL] ENVS = ( [string] , [string] , [string] , [string] , ) [EOL] [EOL] [EOL] class Command ( object ) : [EOL] [EOL] DIR_ROOT = os . getcwd ( ) [EOL] DIR_TEMPLATE = os . path . join ( DIR_ROOT , [string] ) [EOL] DIR_ADDON = os . path . join ( DIR_TEMPLATE , [string] ) [EOL] DIR_TMP = os . path . join ( DIR_ROOT , [string] ) [EOL] [EOL] @ property def required_paths ( self ) : [EOL] return ( self . DIR_TEMPLATE , self . DIR_ADDON , self . current_value_file_path , self . cluster_template_path , ) [EOL] [EOL] ensure_region = ensure_region [EOL] ensure_kops_k8s_version_consistency = ensure_kops_k8s_version_consistency [EOL] ensure_tmp_dir_existing_and_empty = ensure_tmp_dir_existing_and_empty [EOL] [EOL] def ensure_dir_and_files ( self ) : [EOL] for p in self . required_paths : [EOL] self . _validate_path ( p ) [EOL] logger . debug ( [string] , p ) [EOL] [EOL] def __init__ ( self , env , account_name , vpc_id , region = [string] , debug = False ) : [EOL] init_logger ( debug = debug ) [EOL] [EOL] logger . debug ( [string] , self . get_name ( ) , ( env , account_name , vpc_id , region , debug ) ) [EOL] [EOL] if env not in ENVS : [EOL] raise ValueError ( [string] . format ( env , ENVS ) ) [EOL] [EOL] self . env = env [EOL] self . account_name = account_name [EOL] self . vpc_id = vpc_id [EOL] self . region = region [EOL] [EOL] self . cluster_name = [string] . format ( self . env , self . account_name ) [EOL] [EOL] self . state_store_name = [string] % self . account_name [comment] [EOL] self . state_store_uri = [string] % self . state_store_name [EOL] [EOL] self . template_rendered_path = os . path . join ( self . DIR_ROOT , [string] , [string] . format ( self . env , self . account_name ) ) [EOL] [EOL] self . current_vars_dir = os . path . join ( self . DIR_ROOT , [string] , self . account_name ) [EOL] self . current_value_file_path = os . path . join ( self . current_vars_dir , [string] % self . env ) [EOL] self . current_ig_dir = os . path . join ( self . current_vars_dir , [string] % self . env ) [EOL] self . current_snippets_dir = os . path . join ( self . current_vars_dir , [string] % self . env ) [EOL] self . cluster_snippets_dir = os . path . join ( self . DIR_TEMPLATE , [string] ) [EOL] self . cluster_template_path = os . path . join ( self . DIR_TEMPLATE , [string] ) [EOL] [EOL] def _run ( self , * args , ** kwargs ) : [EOL] self . __pre_run ( ) [EOL] self . run ( * args , ** kwargs ) [EOL] [EOL] def run ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ classmethod def get_name ( cls ) : [EOL] return cls . __name__ . lower ( ) [EOL] [EOL] def __pre_run ( self ) : [EOL] for i in dir ( self ) : [EOL] if not i . startswith ( [string] ) : [EOL] continue [EOL] f = getattr ( self , i ) [EOL] if callable ( f ) : [EOL] logger . debug ( [string] , self . __class__ . __name__ , f . __name__ , self . get_name ( ) ) [EOL] f ( ) [EOL] [EOL] def _validate_path ( self , p ) : [EOL] if os . path . isdir ( p ) or os . path . isfile ( p ) : [EOL] return True [EOL] raise IOError ( [string] . format ( p ) ) [EOL] [EOL] def _ensure_dir ( self , path , force = False ) : [EOL] if force is True : [EOL] try : [EOL] shutil . rmtree ( path ) [EOL] except FileNotFoundError : [EOL] ... [EOL] [EOL] try : [EOL] os . listdir ( path ) [EOL] except FileNotFoundError : [EOL] os . makedirs ( path ) [EOL] [EOL] def _ensure_file ( self , path , force = False ) : [EOL] if force is True : [EOL] try : [EOL] shutil . rmtree ( path ) [EOL] except FileNotFoundError : [EOL] ... [EOL] if not os . path . isfile ( path ) : [EOL] open ( path , [string] ) . close ( ) [EOL] [EOL] def _sh ( self , cmd ) : [EOL] cmd = cmd if isinstance ( cmd , ( list , tuple ) ) else [ cmd ] [EOL] cmd = [ sub_flag for flag in cmd for sub_flag in flag . split ( [string] ) if sub_flag ] [EOL] cmd_str = [string] . join ( cmd ) [EOL] logger . info ( [string] , self . env , self . account_name , cmd , cmd_str ) [EOL] exitcode , data = getstatusoutput ( cmd_str ) [EOL] logger . debug ( [string] , exitcode , data ) [EOL] if exitcode != [number] : [EOL] logger . error ( [string] , cmd_str , exitcode ) [EOL] raise RuntimeError ( data ) [EOL] return data [EOL] [EOL] def _kops_cmd ( self , args ) : [EOL] args = args if isinstance ( args , ( list , tuple ) ) else [ args ] [EOL] required_global_flags = [string] . format ( name = self . cluster_name , state = self . state_store_uri ) [EOL] args . insert ( [number] , shutil . which ( [string] ) ) [EOL] args . append ( required_global_flags ) [EOL] return self . _sh ( args ) [EOL] [EOL] def _kubectl_cmd ( self , args ) : [EOL] args = args if isinstance ( args , ( list , tuple ) ) else [ args ] [EOL] kubectl = shutil . which ( [string] ) [EOL] [EOL] [comment] [EOL] use_context_args = [ kubectl , [string] , [string] , self . cluster_name ] [EOL] logger . debug ( [string] , [string] . join ( use_context_args ) ) [EOL] self . _sh ( use_context_args ) [EOL] [EOL] if args [ [number] ] is not kubectl : [EOL] args . insert ( [number] , kubectl ) [EOL] return self . _sh ( args ) [EOL] [EOL] def list_dir_safe ( self , path ) : [EOL] try : [EOL] return os . listdir ( path ) [EOL] except ( FileNotFoundError , NotADirectoryError ) : [EOL] return [ ] [EOL] [EOL] [EOL] class New ( Command ) : [EOL] [EOL] DIR_RAW_TEMPLATE = os . path . join ( os . path . dirname ( os . path . abspath ( __file__ ) ) , [string] ) [EOL] [EOL] @ property def required_paths ( self ) : [EOL] return ( self . DIR_TEMPLATE , self . DIR_ADDON , self . cluster_template_path , ) [EOL] [EOL] def __initialize_templates ( self , force ) : [EOL] to_dir = self . DIR_TEMPLATE [EOL] self . _ensure_dir ( to_dir , force = force ) [EOL] file_list = os . listdir ( self . DIR_RAW_TEMPLATE ) [EOL] if force is False : [EOL] try : [EOL] existing_files = os . listdir ( to_dir ) [EOL] for f in file_list : [EOL] assert f in existing_files [EOL] logger . info ( [string] ) [EOL] return [EOL] except AssertionError : [EOL] ... [EOL] [EOL] [comment] [EOL] logger . info ( [string] , [string] . join ( [ os . path . join ( to_dir , f ) for f in file_list ] ) ) [EOL] shutil . rmtree ( to_dir ) [EOL] shutil . copytree ( self . DIR_RAW_TEMPLATE , to_dir ) [EOL] [EOL] [comment] [EOL] self . _ensure_dir ( self . DIR_ADDON , force = force ) [EOL] [EOL] def __initialize_vars ( self , force ) : [EOL] [comment] [EOL] self . _ensure_dir ( self . current_vars_dir , force = force ) [EOL] self . _ensure_dir ( os . path . join ( self . current_vars_dir , [string] % self . env ) , force = force ) [EOL] self . _ensure_dir ( os . path . join ( self . current_snippets_dir ) , force = force ) [EOL] self . _ensure_dir ( self . current_ig_dir , force = force ) [EOL] self . _ensure_file ( os . path . join ( self . current_vars_dir , [string] % self . env ) , force = force ) [EOL] [EOL] def run ( self , force = False ) : [EOL] logger . info ( [string] , self . get_name ( ) , force ) [EOL] self . __initialize_templates ( force = force ) [EOL] self . __initialize_vars ( force = force ) [EOL] self . _ensure_dir ( os . path . join ( self . DIR_ROOT , [string] ) , force = force ) [EOL] [EOL] [EOL] class Build ( Command ) : [EOL] [EOL] ensure_aws_facts = ensure_aws_facts [EOL] [EOL] @ property def required_paths ( self ) : [EOL] return super ( ) . required_paths + ( self . DIR_TMP , self . current_vars_dir , ) [EOL] [EOL] def run ( self ) : [EOL] logger . info ( [string] , self . get_name ( ) ) [EOL] [EOL] cmd = [string] [EOL] cmd += [string] . join ( [ [string] + f for f in [ self . __build_value_file ( ) , self . current_value_file_path ] ] ) [EOL] cmd += [string] . join ( [ [string] + f for f in ( self . cluster_template_path , self . current_ig_dir ) if os . path . isfile ( f ) or self . list_dir_safe ( f ) ] ) [EOL] [comment] [EOL] [EOL] cmd += [string] + self . cluster_snippets_dir [EOL] try : [EOL] os . listdir ( self . current_snippets_dir ) [EOL] cmd += [string] + self . current_snippets_dir [EOL] except FileNotFoundError : [EOL] ... [EOL] data = self . _kops_cmd ( cmd ) [EOL] with open ( self . template_rendered_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] f . write ( data [ data . index ( [string] ) : ] ) [EOL] [EOL] def __build_value_file ( self ) : [EOL] with open ( os . path . join ( self . DIR_TEMPLATE , [string] ) ) as f : [EOL] value_template = Template ( f . read ( ) ) [EOL] template_rendered = value_template . render ( env = self . env , account_name = self . account_name , state_store_name = self . state_store_name , vpc_facts = yaml . dump ( self . vpc_facts , default_flow_style = False ) ) [EOL] built_value_file_path = os . path . join ( self . DIR_TMP , [string] ) [EOL] with open ( built_value_file_path , [string] ) as f : [EOL] f . write ( template_rendered ) [EOL] return built_value_file_path [EOL] [EOL] [EOL] class Diff ( Command ) : [EOL] [EOL] ensure_state_store = ensure_state_store [EOL] [EOL] @ property def required_paths ( self ) : [EOL] return super ( ) . required_paths + ( self . DIR_TMP , self . template_rendered_path , ) [EOL] [EOL] def run ( self ) : [EOL] logger . info ( [string] , self . get_name ( ) ) [EOL] [EOL] try : [EOL] self . _validate_path ( self . template_rendered_path ) [EOL] except IOError : [EOL] raise IOError ( [string] ) [EOL] [EOL] with open ( self . template_rendered_path ) as f : [EOL] template_to_render = f . read ( ) [EOL] [EOL] current_state = self . __get_current_cluster_state ( ) [EOL] if [string] in current_state : [EOL] logger . info ( [string] , self . cluster_name ) [EOL] current_state = [string] [EOL] diff_result = unified_diff ( current_state . splitlines ( ) , template_to_render . splitlines ( ) , fromfile = [string] , tofile = self . template_rendered_path ) [EOL] for line in color_diff ( diff_result ) : [EOL] sys . stdout . write ( [string] + line ) [EOL] [EOL] def __get_current_cluster_state ( self ) : [EOL] try : [EOL] return self . _kops_cmd ( [string] ) [EOL] except RuntimeError as e : [EOL] logger . warn ( [string] , self . cluster_name ) [EOL] return e . args [ [number] ] [EOL] [EOL] [EOL] class Apply ( Command ) : [EOL] [EOL] ensure_state_store = ensure_state_store [EOL] [EOL] @ property def required_paths ( self ) : [EOL] return super ( ) . required_paths + ( self . template_rendered_path , ) [EOL] [EOL] def run ( self ) : [EOL] logger . info ( [string] , self . get_name ( ) ) [EOL] [EOL] cmd = [string] % self . template_rendered_path [EOL] self . _kops_cmd ( cmd ) [EOL] [EOL] [comment] [EOL] ensure_ssh_pair ( self ) [EOL] [EOL] cmd = [string] [EOL] self . _kops_cmd ( cmd ) [EOL] logger . info ( ( [string] [string] ) . format ( name = self . cluster_name , state = self . state_store_uri ) ) [EOL] [EOL] [EOL] class Install ( Command ) : [EOL] [docstring] [EOL] [EOL] def run ( self ) : [EOL] logger . info ( [string] , self . get_name ( ) ) [EOL] [EOL] for addon in os . listdir ( self . DIR_ADDON ) : [EOL] addon_path = os . path . join ( self . DIR_ADDON , addon ) [EOL] cmd = [string] % addon_path [EOL] logger . info ( [string] , cmd ) [EOL] logger . info ( self . _kubectl_cmd ( cmd ) ) [EOL] [EOL] [EOL] class CommandFactory ( object ) : [EOL] [EOL] __enabled_cmds = ( New , Build , Diff , Apply , Install , ) [EOL] [EOL] def __register ( self , ** kwargs ) : [EOL] for klass in self . __enabled_cmds : [EOL] setattr ( self , klass . get_name ( ) , klass ( ** kwargs ) . _run ) [EOL] [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . __register ( ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[kforce.commands.New],typing.Type[kforce.commands.Build],typing.Type[kforce.commands.Diff],typing.Type[kforce.commands.Apply],typing.Type[kforce.commands.Install]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
try : [EOL] from colorama import Fore , Back , Style , init [EOL] init ( ) [EOL] except ImportError : [comment] [EOL] [EOL] class ColorFallback ( ) : [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return [string] [EOL] [EOL] Fore = Back = Style = ColorFallback ( ) [EOL] [EOL] [EOL] def color_diff ( diff ) : [EOL] for line in diff : [EOL] if line . startswith ( [string] ) : [EOL] yield Fore . GREEN + line + Fore . RESET [EOL] elif line . startswith ( [string] ) : [EOL] yield Fore . RED + line + Fore . RESET [EOL] elif line . startswith ( [string] ) : [EOL] yield Fore . BLUE + line + Fore . RESET [EOL] else : [EOL] yield line [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from unittest import TestCase [EOL] [EOL] [EOL] class TestNew ( TestCase ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import _importlib_modulespec [EOL] import kforce [EOL] import logging [EOL] import os [EOL] from importlib import import_module [EOL] from unittest import TestCase [EOL] from unittest . mock import MagicMock , create_autospec [EOL] [EOL] import mockfs [EOL] import pytest [EOL] from kforce import commands [EOL] from mock import patch [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TestCommands ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] params = dict ( env = [string] , account_name = [string] , vpc_id = [string] ) [EOL] self . cmd = commands . CommandFactory ( ** params ) [EOL] [EOL] def test_register ( self ) : [EOL] cmds = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] module = import_module ( [string] ) [EOL] for c_name in cmds : [EOL] c = getattr ( self . cmd , c_name ) [EOL] c_raw = getattr ( module , c_name . title ( ) ) [EOL] assert c . __name__ == [string] [EOL] assert isinstance ( c . __self__ , c_raw ) [EOL] [EOL] [EOL] class BaseCommandClient ( TestCase ) : [EOL] [EOL] def setUp ( self , klass ) : [EOL] self . mfs = mockfs . replace_builtins ( ) [EOL] [EOL] params = dict ( env = [string] , account_name = [string] , vpc_id = [string] ) [EOL] self . c = klass ( ** params ) [EOL] [EOL] for p in self . c . required_paths : [EOL] self . mfs . add_entries ( { p : [string] } ) [EOL] [EOL] def tearDown ( self ) : [EOL] mockfs . restore_builtins ( ) [EOL] [EOL] [EOL] class TestCommand ( BaseCommandClient ) : [EOL] [EOL] def setUp ( self ) : [EOL] super ( ) . setUp ( commands . Command ) [EOL] [EOL] def test_env_check ( self ) : [EOL] params = dict ( env = [string] , account_name = [string] , vpc_id = [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] commands . Command ( ** params ) [EOL] [EOL] params = dict ( env = [string] , account_name = [string] , vpc_id = [string] ) [EOL] assert commands . Command ( ** params ) . env == [string] [EOL] [EOL] def test_pre_run ( self ) : [EOL] params = dict ( env = [string] , account_name = [string] , vpc_id = [string] , debug = True ) [EOL] [EOL] def fake_func ( ) : [EOL] ... [EOL] [EOL] c = commands . Command ( ** params ) [EOL] ensure_func_names = [ i for i in dir ( c ) if i . startswith ( [string] ) and callable ( getattr ( c , i ) ) ] [EOL] for i in ensure_func_names : [EOL] setattr ( c , i , create_autospec ( fake_func ) ) [EOL] setattr ( c , [string] , create_autospec ( fake_func ) ) [EOL] c . _run ( ) [EOL] [EOL] getattr ( c , [string] ) . assert_called_once ( ) [EOL] for i in ensure_func_names : [EOL] getattr ( c , i ) . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kforce.commands.CommandFactory$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $_importlib_modulespec.ModuleType$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $kforce.commands.Command$ 0 0 0 0 0 0 0 0
	0
	0
import os [EOL] from unittest import TestCase [EOL] [EOL] from kforce . aws_facts import get_vpc_facts [EOL] from moto import mock_ec2 [EOL] [EOL] [EOL] @ mock_ec2 class TestAwsFacts ( TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] ... [EOL] [EOL] def test_check_rt_internet_facing ( self ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0