from typing import Any , Type , Dict [EOL] import typing [EOL] from typing import Any , Dict [EOL] [EOL] Action = Dict [ str , Any ] [EOL] Config = Dict [ str , Any ] [EOL] JsonType = Any [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict [EOL] import asyncio [EOL] import robotica [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import asyncio [EOL] import logging [EOL] [EOL] from robotica . types import Config [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Plugin : [EOL] def __init__ ( self , * , name , loop , config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _loop = loop [EOL] self . _config = config [EOL] [EOL] def start ( self ) : [EOL] pass [EOL] [EOL] def stop ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0
import logging [EOL] import builtins [EOL] import asyncio [EOL] import robotica [EOL] [docstring] [EOL] import asyncio [EOL] import json [EOL] import logging [EOL] [EOL] from hbmqtt . client import MQTTClient , ClientException , QOS_0 [EOL] [EOL] from robotica . plugins . outputs import Output [EOL] from robotica . types import JsonType , Action , Config [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class MqttOutput ( Output ) : [EOL] [EOL] def __init__ ( self , * , name , loop , config ) : [EOL] super ( ) . __init__ ( name = name , loop = loop , config = config , ) [EOL] self . _disabled = self . _config [ [string] ] [EOL] self . _broker_url = self . _config [ [string] ] [EOL] self . _locations = self . _config . get ( [string] , { } ) or { } [EOL] self . _client = MQTTClient ( config = { [string] : [number] , [string] : [number] , } ) [EOL] [EOL] def start ( self ) : [EOL] if not self . _disabled : [EOL] self . _loop . run_until_complete ( self . _client . connect ( self . _broker_url ) ) [EOL] [EOL] def stop ( self ) : [EOL] pass [EOL] [EOL] def is_action_required_for_location ( self , location , action ) : [EOL] if self . _disabled : [EOL] return False [EOL] [EOL] if location not in self . _locations : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] async def execute ( self , location , action ) : [EOL] if not self . is_action_required_for_location ( location , action ) : [EOL] return [EOL] [EOL] await self . _execute ( [string] % location , action , ) [EOL] [EOL] async def _execute ( self , topic , data ) : [EOL] logger . debug ( [string] % ( data , topic ) ) [EOL] raw_data = json . dumps ( data ) . encode ( [string] ) [EOL] try : [EOL] await self . _client . publish ( topic , raw_data , qos = QOS_0 , ) [EOL] except ClientException : [EOL] logger . exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $robotica.types.JsonType$ 0 0 0 0 0 0 0 0 0 0 $robotica.types.JsonType$ 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $robotica.types.JsonType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import asyncio [EOL] import robotica [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import shlex [EOL] from typing import Dict , List [EOL] [EOL] from robotica . plugins . outputs import Output [EOL] from robotica . types import Action , Config [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class AudioOutput ( Output ) : [EOL] [EOL] def __init__ ( self , * , name , loop , config ) : [EOL] super ( ) . __init__ ( name = name , loop = loop , config = config , ) [EOL] self . _disabled = self . _config [ [string] ] [EOL] self . _locations = self . _config . get ( [string] , { } ) or { } [EOL] [EOL] def start ( self ) : [EOL] pass [EOL] [EOL] def stop ( self ) : [EOL] pass [EOL] [EOL] def is_action_required_for_location ( self , location , action ) : [EOL] if self . _disabled : [EOL] return False [EOL] [EOL] if location not in self . _locations : [EOL] return False [EOL] [EOL] if [string] in action : [EOL] return True [EOL] [EOL] if [string] in action : [EOL] return True [EOL] [EOL] if [string] in action : [EOL] return True [EOL] [EOL] if [string] in action : [EOL] return True [EOL] [EOL] if [string] in action : [EOL] return True [EOL] [EOL] return False [EOL] [EOL] async def execute ( self , location , action ) : [EOL] location_config = self . _locations . get ( location , { } ) [EOL] music_pause_cmd = location_config . get ( [string] , [ ] ) [EOL] music_resume_cmd = location_config . get ( [string] , [ ] ) [EOL] [EOL] [comment] [EOL] if [string] in action and action [ [string] ] is None : [EOL] await self . music_stop ( location = location ) [EOL] paused = False [EOL] else : [EOL] paused = await self . _execute ( music_pause_cmd , { } ) == [number] [EOL] [EOL] [comment] [EOL] if [string] in action : [EOL] await self . play_sound ( location , [string] ) [EOL] [EOL] [comment] [EOL] if [string] in action and action [ [string] ] is not None : [EOL] sound = action [ [string] ] [EOL] await self . play_sound ( location = location , sound = sound [ [string] ] ) [EOL] [EOL] [comment] [EOL] if [string] in action : [EOL] message = action [ [string] ] [EOL] await self . say ( location = location , text = message [ [string] ] ) [EOL] [EOL] [comment] [EOL] if [string] in action : [EOL] timer = action [ [string] ] [EOL] time_left = timer [ [string] ] [EOL] if time_left > [number] and time_left % [number] == [number] : [EOL] message_text = [string] % time_left [EOL] await self . say ( location = location , text = message_text ) [EOL] [EOL] [comment] [EOL] if [string] in action : [EOL] timer = action [ [string] ] [EOL] [comment] [EOL] message_text = [string] [EOL] await self . play_sound ( location , [string] ) [EOL] await self . say ( location = location , text = message_text ) [EOL] [EOL] [comment] [EOL] if [string] in action and action [ [string] ] is not None : [EOL] music = action [ [string] ] [EOL] await self . music_play ( location = location , play_list = music [ [string] ] ) [EOL] elif paused : [EOL] await self . _execute ( music_resume_cmd , { } ) [EOL] [EOL] @ staticmethod async def _execute ( cmd_list , params ) : [EOL] for cmd in cmd_list : [EOL] split = [ value . format ( ** params ) for value in shlex . split ( cmd ) ] [EOL] logger . info ( [string] , split ) [EOL] process = await asyncio . create_subprocess_exec ( * split ) [EOL] result = await process . wait ( ) [EOL] if result != [number] : [EOL] logger . info ( [string] , split , result ) [EOL] return result [EOL] return [number] [EOL] [EOL] async def say ( self , location , text ) : [EOL] location_config = self . _locations . get ( location , { } ) [EOL] say_cmd = location_config . get ( [string] , [ ] ) [EOL] if len ( say_cmd ) == [number] : [EOL] return [EOL] logger . debug ( [string] , location , text ) [EOL] [EOL] await self . play_sound ( location , [string] ) [EOL] await self . _execute ( say_cmd , { [string] : text } ) [EOL] await self . play_sound ( location , [string] ) [EOL] await self . _execute ( say_cmd , { [string] : text } ) [EOL] await self . play_sound ( location , [string] ) [EOL] [EOL] async def play_sound ( self , location , sound ) : [EOL] sound_file = self . _config [ [string] ] . get ( sound ) [EOL] if not sound_file : [EOL] return [EOL] location_config = self . _locations . get ( location , { } ) [EOL] play_cmd = location_config . get ( [string] , [ ] ) [EOL] if len ( play_cmd ) == [number] : [EOL] return [EOL] logger . debug ( [string] , location , sound_file ) [EOL] await self . _execute ( play_cmd , { [string] : sound_file } ) [EOL] [EOL] async def music_play ( self , location , play_list ) : [EOL] location_config = self . _locations . get ( location , { } ) [EOL] music_play_cmd = location_config . get ( [string] , [ ] ) [EOL] if len ( music_play_cmd ) == [number] : [EOL] return [EOL] logger . debug ( [string] , location , play_list ) [EOL] await self . _execute ( music_play_cmd , { [string] : play_list } ) [EOL] [EOL] async def music_stop ( self , location ) : [EOL] location_config = self . _locations . get ( location , { } ) [EOL] music_stop_cmd = location_config . get ( [string] , [ ] ) [EOL] if len ( music_stop_cmd ) == [number] : [EOL] return [EOL] logger . debug ( [string] , location ) [EOL] await self . _execute ( music_stop_cmd , { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 $asyncio.subprocess.Process$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
import builtins [EOL] import robotica [EOL] from robotica . plugins import Plugin [EOL] from robotica . types import Action [EOL] [EOL] [EOL] class Output ( Plugin ) : [EOL] def is_action_required_for_location ( self , location , action ) : [EOL] raise NotImplemented ( ) [EOL] [EOL] async def execute ( self , location , action ) : [EOL] raise NotImplemented ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def test_dummy ( ) : [EOL] [docstring] [EOL] assert True is not False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0