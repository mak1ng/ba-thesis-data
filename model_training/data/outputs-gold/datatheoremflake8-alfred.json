[docstring] [EOL] [EOL] from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterator , Optional , Any , Dict , Tuple , Type [EOL] import builtins [EOL] import ast [EOL] import flake8_alfred [EOL] import _ast [EOL] import typing [EOL] [docstring] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] from ast import AST [EOL] from typing import Any , Dict , Iterator , Optional , Tuple [EOL] [EOL] from pkg_resources import get_distribution [EOL] from . symbols import SymbolsVisitor [EOL] [EOL] [EOL] [comment] [EOL] FlakeError = Tuple [ int , int , str , type ] [EOL] [EOL] [EOL] class WarnSymbols : [EOL] [docstring] [EOL] BANNED = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] name = [string] [EOL] version = get_distribution ( [string] ) . version [EOL] [EOL] def __init__ ( self , tree ) : [EOL] self . _tree = tree [EOL] [EOL] @ classmethod def add_options ( cls , parser ) : [EOL] [docstring] [EOL] parser . add_option ( [string] , default = [string] , parse_from_config = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ classmethod def parse_options ( cls , options ) : [EOL] [docstring] [EOL] lines = options . warn_symbols . splitlines ( ) [EOL] for line in lines : [EOL] symbol , _ , warning = line . partition ( [string] ) [EOL] cls . BANNED [ symbol . strip ( ) ] = warning . strip ( ) [EOL] cls . BANNED . pop ( [string] , None ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] visitor = SymbolsVisitor ( ) [EOL] for symbol , node in visitor . visit ( self . _tree ) : [EOL] [comment] [EOL] warning = None [EOL] for module in submodules ( symbol ) : [EOL] warning = self . BANNED . get ( module , warning ) [EOL] [comment] [EOL] if warning is None : [EOL] continue [EOL] [comment] [EOL] yield ( node . lineno , node . col_offset , f" [string] { warning }" , type ( self ) ) [EOL] [EOL] [EOL] def submodules ( symbol ) : [EOL] [docstring] [EOL] bits = symbol . split ( [string] ) [EOL] for i in range ( len ( bits ) ) : [EOL] yield [string] . join ( bits [ : i + [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $ast.AST$ 0 0 0 0 0 $_ast.AST$ 0 $ast.AST$ 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[FlakeError]$ 0 0 0 0 0 0 0 $flake8_alfred.symbols.SymbolsVisitor$ 0 0 0 0 0 0 0 0 0 0 $flake8_alfred.symbols.SymbolsVisitor$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Iterator , Optional , Mapping , TypeVar , Iterable , ChainMap , Any , Tuple , Type [EOL] import builtins [EOL] import collections [EOL] import ast [EOL] import _ast [EOL] import typing [EOL] import visitor [EOL] [docstring] [EOL] [EOL] import builtins [EOL] [EOL] from ast import ( AST , arg , arguments , comprehension , ExceptHandler , expr , stmt , AsyncFunctionDef , ClassDef , FunctionDef , Import , ImportFrom , Attribute , DictComp , GeneratorExp , Lambda , ListComp , Name , SetComp , Del , Param , Store , iter_child_nodes ) [EOL] [EOL] from typing import ( Any , ChainMap as ChainMapT , Iterable , Iterator , Mapping , Optional , Tuple , TypeVar , Union ) [EOL] [EOL] from collections import ChainMap [EOL] from contextlib import contextmanager [EOL] [EOL] from . visitor import Visitor [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] [EOL] Function = Union [ AsyncFunctionDef , FunctionDef ] [EOL] ScopeT = ChainMapT [ str , Optional [ str ] ] [EOL] Symbols = Iterable [ Tuple [ str , Union [ expr , stmt ] ] ] [EOL] UnaryComp = Union [ GeneratorExp , ListComp , SetComp ] [EOL] [EOL] [EOL] class SymbolsVisitor ( Visitor [ AST , Symbols ] ) : [EOL] [docstring] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] init = dir ( builtins ) [EOL] self . scopes = ChainMap ( dict ( zip ( init , init ) ) ) [EOL] [EOL] @ contextmanager def scope ( self ) : [EOL] [docstring] [EOL] self . scopes = self . scopes . new_child ( ) [EOL] try : [EOL] yield self . scopes . maps [ [number] ] [EOL] finally : [EOL] self . scopes = self . scopes . parents [EOL] [EOL] def generic_visit ( self , node ) : [EOL] [docstring] [EOL] for child in iter_child_nodes ( node ) : [EOL] yield from self . visit ( child ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def visit_arguments_defaults ( vtor , node ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] yield from visit_iterable ( vtor , filter ( None , node . kw_defaults ) ) [EOL] yield from visit_iterable ( vtor , node . defaults ) [EOL] [EOL] [EOL] def visit_arguments_names ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_iterable ( vtor , node . kwonlyargs ) [EOL] yield from visit_iterable ( vtor , node . args ) [EOL] yield from visit_optional ( vtor , node . kwarg ) [EOL] yield from visit_optional ( vtor , node . vararg ) [EOL] [EOL] [EOL] def visit_optional ( vtor , node ) : [EOL] [docstring] [EOL] if node is not None : [EOL] yield from vtor . visit ( node ) [EOL] [EOL] [EOL] def visit_iterable ( vtor , node ) : [EOL] [docstring] [EOL] for item in node : [EOL] yield from vtor . visit ( item ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( arg ) def visit_arg ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_optional ( vtor , node . annotation ) [EOL] vtor . scopes [ node . arg ] = None [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( arguments ) def visit_arguments ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_arguments_defaults ( vtor , node ) [EOL] yield from visit_arguments_names ( vtor , node ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( comprehension ) def visit_comprehension ( vtor , node ) : [EOL] [docstring] [EOL] yield from vtor . visit ( node . iter ) [EOL] yield from vtor . visit ( node . target ) [EOL] yield from visit_iterable ( vtor , node . ifs ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( ExceptHandler ) def visit_except_handler ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_optional ( vtor , node . type ) [EOL] if node . name is not None : [EOL] vtor . scopes [ node . name ] = None [EOL] yield from visit_iterable ( vtor , node . body ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( ClassDef ) def visit_class_def ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_iterable ( vtor , node . decorator_list ) [EOL] yield from visit_iterable ( vtor , node . bases ) [EOL] yield from visit_iterable ( vtor , node . keywords ) [EOL] vtor . scopes [ node . name ] = None [EOL] with vtor . scope ( ) : [EOL] yield from visit_iterable ( vtor , node . body ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( AsyncFunctionDef ) @ SymbolsVisitor . on ( FunctionDef ) def visit_function ( vtor , node ) : [EOL] [docstring] [EOL] yield from visit_iterable ( vtor , node . decorator_list ) [EOL] yield from visit_optional ( vtor , node . returns ) [EOL] yield from visit_arguments_defaults ( vtor , node . args ) [EOL] vtor . scopes [ node . name ] = None [EOL] with vtor . scope ( ) : [EOL] yield from visit_arguments_names ( vtor , node . args ) [EOL] yield from visit_iterable ( vtor , node . body ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( Import ) def visit_import ( vtor , node ) : [EOL] [docstring] [EOL] for alias in node . names : [EOL] vtor . scopes [ alias . asname or alias . name ] = alias . name [EOL] yield ( alias . name , node ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( ImportFrom ) def visit_import_from ( vtor , node ) : [EOL] [docstring] [EOL] for alias in node . names : [EOL] module = node . module or [string] [EOL] qualified = f"{ module } [string] { alias . name }" [EOL] vtor . scopes [ alias . asname or alias . name ] = qualified [EOL] yield ( qualified , node ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( Attribute ) def visit_attribute ( vtor , node ) : [EOL] [docstring] [EOL] for lhs , _ in vtor . visit ( node . value ) : [EOL] yield ( f"{ lhs } [string] { node . attr }" , node ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( DictComp ) def visit_dict_comp ( vtor , node ) : [EOL] [docstring] [EOL] with vtor . scope ( ) : [EOL] yield from visit_iterable ( vtor , node . generators ) [EOL] yield from vtor . visit ( node . key ) [EOL] yield from vtor . visit ( node . value ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( Lambda ) def visit_lambda ( vtor , node ) : [EOL] [docstring] [EOL] with vtor . scope ( ) : [EOL] yield from vtor . visit ( node . args ) [EOL] yield from vtor . visit ( node . body ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( Name ) def visit_name ( vtor , node ) : [EOL] [docstring] [EOL] if isinstance ( node . ctx , ( Del , Param , Store ) ) : [EOL] vtor . scopes [ node . id ] = None [EOL] name = vtor . scopes . get ( node . id ) [EOL] if name is not None : [EOL] yield ( name , node ) [EOL] [EOL] [EOL] @ SymbolsVisitor . on ( GeneratorExp ) @ SymbolsVisitor . on ( ListComp ) @ SymbolsVisitor . on ( SetComp ) def visit_unary_comp ( vtor , node ) : [EOL] [docstring] [EOL] with vtor . scope ( ) : [EOL] yield from visit_iterable ( vtor , node . generators ) [EOL] yield from vtor . visit ( node . elt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Mapping[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Symbols$ 0 0 0 $ast.AST$ 0 0 0 0 0 0 0 0 0 0 $ast.AST$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Tuple , TypeVar , Hashable , ChainMap , Any , Dict , Type , Callable [EOL] import typing [EOL] import builtins [EOL] import collections [EOL] [docstring] [EOL] [EOL] from collections import ChainMap [EOL] [EOL] from typing import ( Any , Callable , ChainMap as ChainMapT , Dict , Generic , Hashable , Tuple , Type , TypeVar ) [EOL] [EOL] [EOL] A = TypeVar ( [string] ) [EOL] B = TypeVar ( [string] ) [EOL] C = TypeVar ( [string] ) [EOL] [EOL] [EOL] class RegisterMeta ( type ) : [EOL] [docstring] [EOL] @ classmethod def __prepare__ ( cls , name , bases , ** kwargs ) : [EOL] dicts = ( base . shared_dict for base in bases if isinstance ( base , cls ) ) [EOL] return { [string] : ChainMap ( * dicts ) . new_child ( ) } [EOL] [EOL] @ property def shared_dict ( cls ) : [EOL] [docstring] [EOL] return cls . _shared_dict [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class GenericRegisterMeta ( RegisterMeta , type ( Generic ) ) : [comment] [EOL] [docstring] [EOL] [EOL] [EOL] class Dispatcher ( Generic [ A , B ] , metaclass = GenericRegisterMeta ) : [EOL] [docstring] [EOL] def dispatch ( self , key ) : [EOL] [docstring] [EOL] return type ( self ) . shared_dict [ key ] [EOL] [EOL] @ classmethod def on ( cls , key ) : [EOL] [docstring] [EOL] def _wrapper ( value ) : [EOL] cls . shared_dict [ key ] = value [EOL] return value [EOL] return _wrapper [EOL] [EOL] [EOL] class Visitor ( Dispatcher [ Type [ A ] , Callable [ [ [string] , A ] , B ] ] ) : [EOL] [docstring] [EOL] def generic_visit ( self , node ) : [EOL] [docstring] [EOL] raise TypeError ( f"{ type ( node ) } [string] { self }" ) [EOL] [EOL] def visit ( self , node ) : [EOL] [docstring] [EOL] for base in type ( node ) . mro ( ) : [EOL] try : [EOL] function = self . dispatch ( base ) [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] return function ( self , node ) [EOL] return self . generic_visit ( node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ChainMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $B$ 0 0 0 $A$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $A$ 0 0 0 0 0 0 $typing.Callable[[C],C]$ 0 0 0 $typing.Hashable$ 0 0 0 0 0 0 $C$ 0 $C$ 0 0 0 0 0 0 0 0 0 0 $C$ 0 0 $C$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $B$ 0 0 0 $A$ 0 0 0 0 0 0 0 0 0 0 0 $A$ 0 0 0 0 0 0 0 0 0 0 $B$ 0 0 0 $A$ 0 0 0 0 0 0 0 0 0 0 $A$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $A$ 0 0 0 0 0 0 0 $A$ 0 0