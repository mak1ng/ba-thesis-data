from api . chat_websockets import APP [EOL] [EOL] APP . run ( debug = True )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import api [EOL] from marshmallow import Schema , fields [EOL] [EOL] [EOL] class Email ( Schema ) : [EOL] email = fields . Email ( ) [EOL] [EOL] class UserId ( Schema ) : [EOL] id = fields . Str ( ) [EOL] [EOL] class Interlocutor ( UserId ) : [EOL] pass [EOL] [EOL] class IdEmail ( UserId , Email ) : [EOL] pass [EOL] [EOL] class EmailPass ( Email ) : [EOL] password = fields . Str ( ) [EOL] [EOL] [EOL] class ConvSchema ( Schema ) : [EOL] id = fields . Str ( ) [EOL] created_at = fields . Int ( required = True ) [EOL] users = fields . List ( fields . Str ( ) , required = True ) [EOL] [EOL] [EOL] class ChatMessage ( Schema ) : [EOL] id = fields . Str ( required = True ) [EOL] author = fields . Str ( required = True ) [EOL] conversation = fields . Str ( required = True ) [EOL] timestamp = fields . Str ( required = True ) [EOL] content = fields . Str ( required = True ) [EOL] read = fields . Bool ( required = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import api [EOL] import uuid [EOL] import datetime [EOL] import pymongo [EOL] from pymongo . operations import IndexModel [EOL] from pymodm import connect [EOL] from pymodm import MongoModel , fields [EOL] [EOL] [EOL] MONGO_CONN_ALIAS = [string] [EOL] connect ( [string] , alias = MONGO_CONN_ALIAS ) [EOL] [EOL] [EOL] class User ( MongoModel ) : [EOL] id = fields . CharField ( primary_key = True , default = lambda : str ( uuid . uuid1 ( ) ) ) [EOL] email = fields . EmailField ( ) [EOL] password_crypto = fields . CharField ( ) [EOL] class Meta : [EOL] connection_alias = MONGO_CONN_ALIAS [EOL] indexes = [ IndexModel ( [ ( [string] , pymongo . DESCENDING ) ] ) ] [EOL] [EOL] [EOL] class Conversation ( MongoModel ) : [EOL] [docstring] [EOL] id = fields . CharField ( primary_key = True , default = lambda : str ( uuid . uuid1 ( ) ) ) [EOL] created_at = fields . IntegerField ( ) [EOL] users = fields . ListField ( field = fields . ReferenceField ( User ) ) [EOL] class Meta : [EOL] connection_alias = MONGO_CONN_ALIAS [EOL] indexes = [ IndexModel ( [ ( [string] , pymongo . DESCENDING ) ] ) ] [EOL] [EOL] [EOL] class Message ( MongoModel ) : [EOL] id = fields . CharField ( primary_key = True , default = lambda : str ( uuid . uuid1 ( ) ) ) [EOL] author = fields . ReferenceField ( User ) [EOL] conversation = fields . ReferenceField ( Conversation ) [EOL] timestamp = fields . DateTimeField ( default = datetime . datetime . utcnow ) [EOL] content = fields . CharField ( ) [EOL] class Meta : [EOL] connection_alias = MONGO_CONN_ALIAS [EOL] indexes = [ IndexModel ( [ ( [string] , pymongo . DESCENDING ) ] ) , IndexModel ( [ ( [string] , pymongo . DESCENDING ) ] ) , IndexModel ( [ ( [string] , pymongo . DESCENDING ) ] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[api.models.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[api.models.Message]$ 0 0 0 0 0 0 0 0 $typing.Type[api.models.Message]$ 0 0 0 0 0 0 0 0 $typing.Type[api.models.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[api.models.Message]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import types [EOL] import typing [EOL] import api [EOL] [docstring] [EOL] from celery import Celery [EOL] from . types import MessageType [EOL] from . models import Message [EOL] [EOL] [EOL] CELERY_SINGLETON = Celery ( __name__ , broker = [string] , backend = [string] ) [EOL] [EOL] [EOL] @ CELERY_SINGLETON . task def save_msg_in_db ( msg ) : [EOL] msg_entry = Message ( ** msg ) [EOL] msg_entry . save ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Callable , Dict [EOL] import builtins [EOL] import types [EOL] import typing [EOL] import api [EOL] from functools import wraps [EOL] from typing import Callable [EOL] import jwt [EOL] from sanic . response import json [EOL] from . models import Conversation [EOL] from . schemas import ChatMessage , ConvSchema [EOL] from . types import ( MsgStoreType , MessageType , ConversationType , ConvStoreType ) [EOL] from . jobs import save_msg_in_db [EOL] [EOL] [EOL] def login_required ( handler ) : [EOL] @ wraps ( handler ) async def decorated ( request , * args ) : [EOL] jwt_auth = request . headers . get ( [string] ) [EOL] try : [EOL] auth_info = jwt . decode ( jwt_auth ) [EOL] except : [comment] [EOL] err = { [string] : [string] } [EOL] return json ( err , [number] ) [EOL] response = await handler ( request , auth_info , * args ) [EOL] return response [EOL] [EOL] [EOL] def store_msg ( msg , msg_store ) : [EOL] msg_store [ msg [ [string] ] ] . append ( msg ) [EOL] save_msg_in_db ( msg ) [EOL] [EOL] [EOL] def get_conversation ( conv_id , conversations ) : [EOL] if conv_id not in conversations : [EOL] conv_obj = Conversation . objects . get ( { [string] : conv_id } ) [EOL] conv = ConvSchema ( ) . dump ( conv_obj ) [EOL] conversations [ conv_id ] = conv [EOL] else : [EOL] conv = conversations [ conv_id ] [EOL] return conv [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List , Dict [EOL] import builtins [EOL] import types [EOL] import typing [EOL] import api [EOL] import json [EOL] from typing import Set , Dict , Any , List [EOL] [EOL] from sanic import Sanic [EOL] from sanic . exceptions import abort [EOL] from sanic . response import json as jsonr [EOL] from sanic . response import text [EOL] from passlib . hash import pbkdf2_sha256 [EOL] import jwt [EOL] [EOL] from . models import User , Conversation , Message [EOL] from . schemas import ( IdEmail , EmailPass , UserId , Interlocutor , ConvSchema , ChatMessage ) [EOL] from . helpers import ( login_required , store_msg , get_conversation ) [EOL] from . types import ( MessageType , MsgStoreType , ConvStoreType ) [EOL] [EOL] [EOL] APP = Sanic ( __name__ ) [EOL] APP . config . SECRET = [string] [EOL] [EOL] [EOL] DUMMY_SUMMARY = { [string] : [string] , [string] : [ { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : True } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : True } ] } ] } [EOL] [EOL] @ APP . route ( [string] ) async def get_chat_summary ( request ) : [EOL] print ( request ) [EOL] return jsonr ( DUMMY_SUMMARY ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) async def favicon ( request ) : [EOL] return text ( [string] ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) async def register_user ( request ) : [EOL] [docstring] [EOL] req_data , sch_err = EmailPass ( ) . load ( request . data ) [EOL] if sch_err : [EOL] return jsonr ( { [string] : sch_err } , [number] ) [EOL] email = req_data . lower ( ) [EOL] if User . objects . raw ( { [string] : email } ) . count ( ) : [EOL] err = { [string] : f' [string] { email } [string] ' } [EOL] return jsonr ( err , [number] ) [EOL] pwd = pbkdf2_sha256 . hash ( request . data . password ) [EOL] user = User ( email = email , password = pwd ) [EOL] user . save ( ) [EOL] token = jwt . encode ( { [string] : user . id } , APP . config . SECRET , algorithm = [string] ) [EOL] return jsonr ( { [string] : token } ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) async def create_auth_token ( request ) : [EOL] [docstring] [EOL] req_data , sch_err = EmailPass ( ) . load ( request . data ) [EOL] if sch_err : [EOL] return jsonr ( { [string] : sch_err } , [number] ) [EOL] email = req_data . email . lower ( ) [EOL] try : [EOL] user = User . objects . get ( { [string] : email } ) [EOL] except User . DoesNotExist : [EOL] err = { [string] : f' [string] { email }' } [EOL] return jsonr ( err , status = [number] ) [EOL] if pbkdf2_sha256 . verify ( req_data . password , user . password_crypto ) : [EOL] token = jwt . encode ( { [string] : user . id } , APP . config . SECRET , algorithm = [string] ) [EOL] return jsonr ( { [string] : token } ) [EOL] else : [EOL] err = { [string] : [string] } [EOL] return jsonr ( err , [number] ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ login_required async def create_chat_room ( request , auth_info ) : [EOL] [comment] [EOL] req_data , sch_err = Interlocutor ( ) . load ( request . data ) [EOL] interlocutor = req_data . id [EOL] if sch_err : [EOL] return jsonr ( { [string] : sch_err } , [number] ) [EOL] users = [ auth_info [ [string] ] , interlocutor ] [EOL] users . sort ( ) [EOL] try : [EOL] conv = Conversation . objects . get ( { [string] : users } ) [EOL] except Conversation . DoesNotExist : [EOL] conv = Conversation ( users = users ) [EOL] conv . save ( ) [EOL] serialized_conv = ConvSchema ( ) . dump ( conv ) [EOL] return jsonr ( serialized_conv ) [EOL] [EOL] [EOL] [comment] [EOL] CLIENTS = { } [EOL] CONVERSATIONS = { } [EOL] MSG_STORE = { } [EOL] [EOL] @ APP . websocket ( [string] ) @ login_required async def ws_test ( request , auth_info , wsock ) : [EOL] CLIENTS [ auth_info [ [string] ] ] = wsock [EOL] while True : [EOL] raw_msg = await wsock . recv ( ) [EOL] msg , sch_err = ChatMessage ( ) . load ( json . loads ( raw_msg ) ) [EOL] if not sch_err : [EOL] store_msg ( ChatMessage ( ) . dump ( msg ) , MSG_STORE ) [EOL] try : [EOL] conv = get_conversation ( msg [ [string] ] , CONVERSATIONS ) [EOL] except Conversation . DoesNotExist : [EOL] continue [EOL] interlocutor_id = next ( user for user in conv [ [string] ] if user != msg [ [string] ] ) [EOL] if interlocutor_id in CLIENTS : [EOL] interlocutor = CLIENTS [ interlocutor_id ] [EOL] if interlocutor . status == [string] : [EOL] await interlocutor . send ( msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] APP . run ( debug = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , Dict [EOL] import typing [EOL] import api [EOL] from typing import List , Dict , Set , Any [EOL] from mypy_extensions import TypedDict [EOL] [EOL] MessageType = TypedDict ( [string] , { [string] : str , [string] : str , [string] : str , [string] : str , [string] : int , [string] : bool } ) [EOL] [EOL] MsgStoreType = Dict [ str , List [ MessageType ] ] [EOL] [EOL] ConversationType = TypedDict ( [string] , { [string] : str , [string] : int , [string] : List [ str ] } ) [EOL] [EOL] ConvStoreType = Dict [ str , ConversationType ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Dict[builtins.str,api.types.ConversationType]]$ 0 0 0 0 0 0 0 0