import unittest [EOL] from find_median import find_median [EOL] [EOL] [EOL] class FindMedianOfTwoArraysTest ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( find_median ( [ [number] , [number] ] , [ [number] ] ) , [number] ) [EOL] self . assertEqual ( find_median ( [ [number] , [number] ] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_diff_len ( self ) : [EOL] self . assertEqual ( find_median ( [ [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] self . assertEqual ( find_median ( [ [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] self . assertEqual ( find_median ( [ [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_neg ( self ) : [EOL] self . assertEqual ( find_median ( [ [number] , [number] ] , [ - [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_empty ( self ) : [EOL] self . assertEqual ( find_median ( [ ] , [ [number] , [number] , [number] ] ) , [number] ) [EOL] self . assertEqual ( find_median ( [ ] , [ [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] self . assertEqual ( find_median ( [ [number] , [number] , [number] ] , [ ] ) , [number] ) [EOL] self . assertEqual ( find_median ( [ [number] , [number] , [number] , [number] ] , [ ] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def find_median ( nums1 , nums2 ) : [EOL] nums1_len = len ( nums1 ) [EOL] nums2_len = len ( nums2 ) [EOL] total_len = nums1_len + nums2_len [EOL] [EOL] [comment] [EOL] [EOL] if nums1_len == [number] : [EOL] half_index = int ( nums2_len / [number] ) [EOL] [EOL] if nums2_len % [number] == [number] : [EOL] return ( nums2 [ half_index - [number] ] + nums2 [ half_index ] ) / [number] [EOL] else : [EOL] return nums2 [ half_index ] [EOL] elif nums2_len == [number] : [EOL] half_index = int ( nums1_len / [number] ) [EOL] [EOL] if nums1_len % [number] == [number] : [EOL] return ( nums1 [ half_index - [number] ] + nums1 [ half_index ] ) / [number] [EOL] else : [EOL] return nums1 [ half_index ] [EOL] [EOL] [comment] [EOL] [EOL] nums1_index = [number] [EOL] nums2_index = [number] [EOL] median = [number] [EOL] [EOL] [comment] [EOL] [EOL] iter_count = int ( total_len / [number] ) \ [EOL] if ( total_len % [number] ) == [number] else int ( total_len / [number] ) + [number] [EOL] [EOL] while nums1_index < (nums1_len) and nums2_index < (nums2_len) : [EOL] if nums1 [ nums1_index ] > nums2 [ nums2_index ] : [EOL] median = nums2 [ nums2_index ] [EOL] nums2_index += [number] [EOL] else : [EOL] median = nums1 [ nums1_index ] [EOL] nums1_index += [number] [EOL] [EOL] iter_count -= [number] [EOL] [EOL] if iter_count == [number] : [EOL] if total_len % [number] == [number] : [EOL] one_over = [number] [EOL] [EOL] if nums1_index < nums1_len and nums2_index < nums2_len : [EOL] one_over = nums1 [ nums1_index ] \ [EOL] if nums1 [ nums1_index ] < nums2 [ nums2_index ] \ [EOL] else nums2 [ nums2_index ] [EOL] elif nums1_index < nums1_len : [EOL] one_over = nums1 [ nums1_index ] [EOL] elif nums2_index < nums2_len : [EOL] one_over = nums2 [ nums2_index ] [EOL] [EOL] median = int ( ( median + one_over ) / [number] ) [EOL] return median [EOL] [EOL] [comment] [EOL] [EOL] while nums1_index < (nums1_len) : [EOL] median = nums1 [ nums1_index ] [EOL] nums1_index += [number] [EOL] iter_count -= [number] [EOL] [EOL] if iter_count == [number] : [EOL] if total_len % [number] == [number] : [EOL] one_over = nums1 [ nums1_index ] [EOL] median = int ( ( median + one_over ) / [number] ) [EOL] [EOL] return median [EOL] [EOL] while nums2_index < (nums2_len) : [EOL] median = nums2 [ nums2_index ] [EOL] nums2_index += [number] [EOL] iter_count -= [number] [EOL] [EOL] if iter_count == [number] : [EOL] if total_len % [number] == [number] : [EOL] one_over = nums2 [ nums2_index ] [EOL] median = int ( ( median + one_over ) / [number] ) [EOL] [EOL] return median [EOL] [EOL] return median [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] from typing import List , Tuple [EOL] [EOL] [EOL] def find_sum ( data , target ) : [EOL] d = dict ( ) [EOL] [EOL] [comment] [EOL] for ( i , val ) in enumerate ( data ) : [EOL] d [ val ] = i [EOL] [EOL] for ( i , val ) in enumerate ( data ) : [EOL] [comment] [EOL] diff = target - val [EOL] [comment] [EOL] if diff in d and i != d [ diff ] : [EOL] return ( i , d [ diff ] ) [EOL] [EOL] [comment] [EOL] return ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from find_sum import find_sum [EOL] [EOL] [EOL] class TestFindSum ( unittest . TestCase ) : [EOL] [EOL] def test_simple ( self ) : [EOL] x , y = find_sum ( [ [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] self . fail ( ) [EOL] [EOL] def test_simple2 ( self ) : [EOL] x , y = find_sum ( [ [number] , [number] , [number] ] , [number] ) [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] self . fail ( ) [EOL] [EOL] def test_negative ( self ) : [EOL] x , y = find_sum ( [ - [number] , - [number] , - [number] , - [number] , - [number] ] , - [number] ) [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] self . fail ( ) [EOL] [EOL] def test_mixed ( self ) : [EOL] x , y = find_sum ( [ - [number] , [number] , - [number] , [number] , - [number] ] , [number] ) [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] if x == [number] : [EOL] self . assertEqual ( y , [number] ) [EOL] return [EOL] [EOL] self . fail ( ) [EOL] [EOL] def test_uniform ( self ) : [EOL] x , y = find_sum ( [ [number] , [number] ] , [number] ) [EOL] [EOL] self . assertEqual ( x , [number] ) [EOL] self . assertEqual ( y , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def find_palindromic_substring ( s ) : [EOL] max_head = [number] [EOL] max_tail = [number] [EOL] max_count = [number] [EOL] [EOL] [comment] [EOL] [EOL] for center in range ( [number] , len ( s ) ) : [EOL] head = center [EOL] tail = center [EOL] [EOL] while head >= [number] and tail < len ( s ) : [EOL] if s [ head ] == s [ tail ] : [EOL] count = tail - head + [number] [EOL] [EOL] if count > max_count : [EOL] max_count = count [EOL] max_head = head [EOL] max_tail = tail [EOL] else : [EOL] break [EOL] [EOL] head -= [number] [EOL] tail += [number] [EOL] [EOL] [comment] [EOL] [EOL] for left_center in range ( [number] , len ( s ) - [number] ) : [EOL] right_center = left_center + [number] [EOL] [EOL] while left_center >= [number] and right_center < len ( s ) : [EOL] if s [ left_center ] == s [ right_center ] : [EOL] count = right_center - left_center + [number] [EOL] [EOL] if count > max_count : [EOL] max_count = count [EOL] max_head = left_center [EOL] max_tail = right_center [EOL] else : [EOL] break [EOL] [EOL] left_center -= [number] [EOL] right_center += [number] [EOL] [EOL] return s [ max_head : max_tail + [number] ] [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from find_palindromic_substring import find_palindromic_substring [EOL] [EOL] [EOL] class FindLongestPalindromicSubstringTests ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( find_palindromic_substring ( [string] ) , [string] ) [EOL] self . assertEqual ( find_palindromic_substring ( [string] ) , [string] ) [EOL] [EOL] def test_simple ( self ) : [EOL] self . assertEqual ( find_palindromic_substring ( [string] ) , [string] ) [EOL] [EOL] def test_nested ( self ) : [EOL] self . assertEqual ( find_palindromic_substring ( [string] ) , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] def convert ( s , numRows ) : [EOL] [comment] [EOL] if numRows <= [number] : [EOL] return s [EOL] [EOL] [comment] [EOL] buffer = [string] [EOL] row_buffers = list ( ) [EOL] [EOL] for i in range ( [number] , numRows ) : [EOL] row_buffers . append ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] step = [number] [EOL] y = [number] [EOL] [EOL] for c in s : [EOL] row_buffers [ y ] += c [EOL] [EOL] y += step [EOL] [EOL] if y == [number] : [EOL] step = [number] [EOL] elif y == numRows - [number] : [EOL] step = - [number] [EOL] [EOL] for row_buffer in row_buffers : [EOL] buffer += row_buffer [EOL] [EOL] return buffer [EOL] [EOL] if __name__ == [string] : [EOL] print ( list ( range ( [number] , [number] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def is_palindrome ( x ) : [EOL] if x < [number] : [EOL] return False [EOL] [EOL] digits = [ ] [EOL] [EOL] while x >= [number] : [EOL] digit = x % [number] [EOL] x -= digit [EOL] x = int ( x / [number] ) [EOL] digits . append ( digit ) [EOL] [EOL] digits . append ( x ) [EOL] [EOL] head_index = [number] [EOL] tail_index = len ( digits ) - [number] [EOL] [EOL] while head_index != tail_index and ( head_index + [number] ) != tail_index : [EOL] [EOL] if digits [ head_index ] != digits [ tail_index ] : [EOL] return False [EOL] [EOL] tail_index -= [number] [EOL] head_index += [number] [EOL] [EOL] return digits [ head_index ] == digits [ tail_index ] [EOL]	0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from is_palindrome import is_palindrome [EOL] [EOL] [EOL] class PalindromeNumberTests ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertTrue ( is_palindrome ( [number] ) ) [EOL] self . assertFalse ( is_palindrome ( - [number] ) ) [EOL] self . assertFalse ( is_palindrome ( [number] ) ) [EOL] [EOL] def test_even_palindrome ( self ) : [EOL] self . assertTrue ( is_palindrome ( [number] ) ) [EOL] self . assertFalse ( is_palindrome ( [number] ) ) [EOL] self . assertFalse ( is_palindrome ( - [number] ) ) [EOL] [EOL] def test_zero ( self ) : [EOL] self . assertTrue ( is_palindrome ( [number] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from reverse import reverse [EOL] [EOL] [EOL] class ReverseIntegerTests ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( reverse ( [number] ) , [number] ) [EOL] self . assertEqual ( reverse ( - [number] ) , - [number] ) [EOL] self . assertEqual ( reverse ( [number] ) , [number] ) [EOL] [EOL] def test_10s ( self ) : [EOL] self . assertEqual ( reverse ( [number] ) , [number] ) [EOL] [EOL] def test_overflow ( self ) : [EOL] self . assertEqual ( reverse ( [number] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import builtins [EOL] def reverse ( x ) : [EOL] max_int32 = ( [number] ** ( [number] - [number] ) ) - [number] [EOL] min_int32 = ( [number] ** ( [number] - [number] ) ) * - [number] [EOL] [EOL] output = [number] [EOL] sign = [number] if x > [number] else - [number] [EOL] x = x if x > [number] else x * - [number] [EOL] [EOL] while x >= [number] : [EOL] last = x % [number] [EOL] x -= last [EOL] x = int ( x / [number] ) [EOL] [EOL] [comment] [EOL] output *= [number] [EOL] output += last [EOL] [EOL] if output > max_int32 : [EOL] return [number] [EOL] [EOL] [comment] [EOL] output *= [number] [EOL] output += x [EOL] [EOL] output *= sign [EOL] [EOL] if output > max_int32 or output < min_int32 : [EOL] return [number] [EOL] [EOL] return output [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] value = [number] [EOL] [EOL] while value > [number] : [EOL] last = value % [number] [EOL] value -= last [EOL] value = int ( value / [number] ) [EOL] [EOL] print ( [string] . format ( value , last ) ) [EOL] [EOL] [comment] [EOL] max_int32 = ( [number] ** ( [number] - [number] ) ) - [number] [EOL] print ( [string] . format ( max_int32 ) ) [EOL] [EOL] min_int32 = ( [number] ** ( [number] - [number] ) ) * - [number] [EOL] print ( [string] . format ( min_int32 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from add_two_nums import add_two_nums , ListNode [EOL] [EOL] [EOL] class TestListNode ( unittest . TestCase ) : [EOL] [EOL] def test_not_equal ( self ) : [EOL] head_a = ListNode . make_list ( [number] ) [EOL] head_b = ListNode . make_list ( [number] ) [EOL] [EOL] self . assertNotEqual ( head_a , head_b ) [EOL] [EOL] def test_equal ( self ) : [EOL] head_a = ListNode . make_list ( [number] ) [EOL] head_b = ListNode . make_list ( [number] ) [EOL] [EOL] self . assertEqual ( head_a , head_b ) [EOL] [EOL] def test_equal_int ( self ) : [EOL] head = ListNode . make_list ( [number] ) [EOL] self . assertEqual ( head , [number] ) [EOL] [EOL] [EOL] class TestAddTwoNumbers ( unittest . TestCase ) : [EOL] [EOL] def test_same_length ( self ) : [EOL] head_a = ListNode . make_list ( [number] ) [EOL] head_b = ListNode . make_list ( [number] ) [EOL] [EOL] result = add_two_nums ( head_a , head_b ) [EOL] [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_diff_length ( self ) : [EOL] head_a = ListNode . make_list ( [number] ) [EOL] head_b = ListNode . make_list ( [number] ) [EOL] [EOL] result = add_two_nums ( head_a , head_b ) [EOL] [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_overflow ( self ) : [EOL] head_a = ListNode . make_list ( [number] ) [EOL] head_b = ListNode . make_list ( [number] ) [EOL] [EOL] result = add_two_nums ( head_a , head_b ) [EOL] [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] [EOL] [comment] [EOL] class ListNode : [EOL] [EOL] def __init__ ( self , x = [number] ) : [EOL] self . val = x [EOL] self . next = None [comment] [EOL] [EOL] @ staticmethod def make_list ( number ) : [EOL] s = str ( number ) [EOL] i = len ( s ) - [number] [EOL] curent = None [EOL] head = None [EOL] [EOL] while i >= [number] : [EOL] value = int ( s [ i ] ) [EOL] [EOL] if head is None : [EOL] current = ListNode ( value ) [EOL] head = current [EOL] else : [EOL] current . next = ListNode ( value ) [EOL] current = current . next [EOL] [EOL] i -= [number] [EOL] [EOL] assert current is not None [EOL] assert head is not None [EOL] [EOL] return head [EOL] [EOL] def __str__ ( self ) : [EOL] node = self [comment] [EOL] buffer = [string] [EOL] [EOL] while node is not None : [EOL] buffer += str ( node . val ) [EOL] [EOL] if node . next is not None : [EOL] buffer += [string] [EOL] [EOL] node = node . next [EOL] [EOL] return buffer [EOL] [EOL] def __eq__ ( self , other ) : [EOL] other_list = None [EOL] if isinstance ( other , int ) : [EOL] other_list = ListNode . make_list ( other ) [EOL] elif isinstance ( other , ListNode ) : [EOL] other_list = other [EOL] [EOL] assert other_list is not None [EOL] [EOL] return self . _compare ( other_list ) [EOL] [EOL] def _compare ( self , other ) : [EOL] self_current = self [comment] [EOL] other_current = other [comment] [EOL] [EOL] while True : [EOL] if self_current is not None and other_current is not None : [EOL] if self_current . val == other_current . val : [EOL] self_current = self_current . next [EOL] other_current = other_current . next [EOL] continue [EOL] else : [EOL] return False [EOL] elif self_current is None and other_current is None : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def add_two_nums ( l1 , l2 ) : [EOL] head = None [EOL] cursor = None [EOL] [EOL] l1_current = l1 [comment] [EOL] l2_current = l2 [comment] [EOL] carried = [number] [EOL] [EOL] while l1_current is not None or l2_current is not None : [EOL] l1_current_val = [number] [EOL] l2_current_val = [number] [EOL] [EOL] if l1_current is not None : [EOL] l1_current_val = l1_current . val [EOL] [EOL] if l2_current is not None : [EOL] l2_current_val = l2_current . val [EOL] [EOL] val = l1_current_val + l2_current_val + carried [EOL] [EOL] if val >= [number] : [EOL] val -= [number] [EOL] carried = [number] [EOL] else : [EOL] [comment] [EOL] carried = [number] [EOL] [EOL] if head is None : [EOL] head = ListNode ( val ) [EOL] cursor = head [EOL] else : [EOL] cursor . next = ListNode ( val ) [EOL] cursor = cursor . next [EOL] [EOL] if l1_current is not None : [EOL] l1_current = l1_current . next [EOL] [EOL] if l2_current is not None : [EOL] l2_current = l2_current . next [EOL] [EOL] [comment] [EOL] if carried > [number] : [EOL] assert cursor is not None [EOL] cursor . next = ListNode ( carried ) [EOL] [EOL] assert head is not None [EOL] [EOL] return head [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $"ListNode"$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $"ListNode"$ 0 0 0 0 0 0 0 0 0 0 $"ListNode"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ListNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] def convert ( num ) : [EOL] values = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] symbols = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , } [EOL] [EOL] specials = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] s = [string] [EOL] digits = list ( ) [EOL] multiplier = [number] [EOL] [EOL] while num >= [number] : [EOL] digit = num % [number] [EOL] num -= digit [EOL] num = int ( num / [number] ) [EOL] digits . append ( digit * multiplier ) [EOL] multiplier *= [number] [EOL] [EOL] digits . append ( num * multiplier ) [EOL] digits . reverse ( ) [EOL] [EOL] for digit in digits : [EOL] if digit in specials : [EOL] s += specials [ digit ] [EOL] continue [EOL] [EOL] values_i = [number] [EOL] while values_i < len ( values ) : [EOL] value = values [ values_i ] [EOL] [EOL] if int ( digit / value ) >= [number] : [EOL] digit -= value [EOL] s += symbols [ value ] [EOL] continue [EOL] [EOL] values_i += [number] [EOL] [EOL] return s [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( convert ( [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from convert import convert [EOL] import unittest [EOL] [EOL] [EOL] class IntToRomansTest ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] [EOL] def test_edge ( self ) : [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] self . assertEqual ( convert ( [number] ) , [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] def convert ( s ) : [EOL] symbols = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] value = [number] [EOL] i = [number] [EOL] [EOL] while i < len ( s ) - [number] : [EOL] current = symbols [ s [ i ] ] [EOL] peek = symbols [ s [ i + [number] ] ] [EOL] [EOL] if peek > current : [EOL] value += peek - current [EOL] i += [number] [EOL] continue [EOL] [EOL] value += current [EOL] i += [number] [EOL] [EOL] if i < len ( s ) : [EOL] value += symbols [ s [ i ] ] [EOL] [EOL] return value [EOL] [EOL] if __name__ == [string] : [EOL] print ( convert ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] def my_atoi ( str ) : [EOL] MAX = ( [number] ** [number] ) - [number] [EOL] MIN = - [number] * ( [number] ** [number] ) [EOL] [EOL] sign = [number] [EOL] value = [number] [EOL] [EOL] i = [number] [EOL] [EOL] if len ( str ) == [number] : [EOL] return [number] [EOL] [EOL] while i < len ( str ) and str [ i ] == [string] : [EOL] i += [number] [EOL] [EOL] if i >= len ( str ) : [EOL] return [number] [EOL] [EOL] if str [ i ] == [string] : [EOL] sign = [number] [EOL] i += [number] [EOL] elif str [ i ] == [string] : [EOL] sign = - [number] [EOL] i += [number] [EOL] elif str [ i ] . isalpha ( ) : [EOL] return [number] [EOL] [EOL] if i >= len ( str ) : [EOL] return [number] [EOL] [EOL] while i < len ( str ) and str [ i ] . isnumeric ( ) : [EOL] v = int ( str [ i ] ) [EOL] value *= [number] [EOL] value += v [EOL] i += [number] [EOL] [EOL] value *= sign [EOL] [EOL] if value > MAX : [EOL] return MAX [EOL] elif value < MIN : [EOL] return MIN [EOL] else : [EOL] return value [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( my_atoi ( [string] ) ) [EOL] print ( my_atoi ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from atoi import my_atoi [EOL] [EOL] [EOL] class StringToIntegerAtolTests ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , - [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , - [number] ) [EOL] [EOL] def test_decimal ( self ) : [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] [EOL] def test_sign ( self ) : [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , - [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] [EOL] def test_whitespace ( self ) : [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , - [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] self . assertEqual ( my_atoi ( [string] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from max_area import max_area [EOL] import unittest [EOL] [EOL] [EOL] class MaxAreaTests ( unittest . TestCase ) : [EOL] def test_given ( self ) : [EOL] self . assertEqual ( max_area ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def max_area ( height ) : [EOL] head_i = [number] [EOL] tail_i = len ( height ) - [number] [EOL] max_area = [number] [EOL] [EOL] while head_i != tail_i : [EOL] head_h = height [ head_i ] [EOL] tail_h = height [ tail_i ] [EOL] [EOL] h = head_h if head_h < tail_h else tail_h [EOL] w = tail_i - head_i [EOL] [EOL] area = h * w [EOL] [EOL] if max_area < area : [EOL] max_area = area [EOL] [EOL] if head_h > tail_h : [EOL] tail_i -= [number] [EOL] else : [EOL] head_i += [number] [EOL] [EOL] return max_area [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0