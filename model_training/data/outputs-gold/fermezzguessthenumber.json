	0
from typing import Any [EOL] import typing [EOL] from mock import patch [EOL] [EOL] from guessthenumber . constants import GAME_OVER_MESSAGE [EOL] from guessthenumber . evaluator import ( Answer , Evaluator , ) [EOL] from guessthenumber . game import ( HumanGuessesMachineThinksGame , MachineGuessesHumanThinksGame , ) [EOL] from guessthenumber . guesser import Guesser [EOL] from guessthenumber . thinker import Thinker [EOL] [EOL] [EOL] class TestGames : [EOL] [EOL] @ patch ( [string] , return_value = True ) @ patch ( [string] , return_value = [string] ) @ patch ( [string] , return_value = [string] ) @ patch ( [string] ) def test_game_hgmtg ( self , mocked_print , mocked_think_number , mocked_ask_for_a_guess , mocked_evaluate_guess ) : [EOL] [EOL] game = HumanGuessesMachineThinksGame ( ) [EOL] game . play ( ) [EOL] mocked_print . assert_called_once_with ( GAME_OVER_MESSAGE ) [EOL] mocked_think_number . assert_called_once_with ( cipher_quantity = [number] ) [EOL] mocked_ask_for_a_guess . assert_called_once ( ) [EOL] mocked_evaluate_guess . assert_called_once_with ( [string] , [string] ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_hgmtg_ask_for_a_guess ( self , mocked_print , mocked_input ) : [EOL] [EOL] game = HumanGuessesMachineThinksGame ( ) [EOL] game . ask_for_a_guess ( [string] ) [EOL] mocked_print . assert_called_once_with ( [string] ) [EOL] mocked_input . assert_called_once_with ( [string] ) [EOL] [EOL] @ patch ( [string] , return_value = None ) @ patch ( [string] , return_value = GAME_OVER_MESSAGE ) @ patch ( [string] ) def test_game_mghtg ( self , mocked_input , mocked_print , mocked_take_a_guess ) : [EOL] [EOL] game = MachineGuessesHumanThinksGame ( ) [EOL] game . play ( ) [EOL] [EOL] mocked_input . assert_not_called [EOL] mocked_print . assert_called_once_with ( GAME_OVER_MESSAGE ) [EOL] mocked_take_a_guess . assert_called_once_with ( None ) [EOL] [EOL] [EOL] @ patch ( [string] , return_value = [number] ) class TestThinker : [EOL] [EOL] def test_think_number_four_ciphers ( self , mocked_randint ) : [EOL] assert [string] == Thinker . think_number ( ) [EOL] [EOL] def test_think_number_zero_ciphers ( self , mocked_randint ) : [EOL] [docstring] [EOL] assert [string] == Thinker . think_number ( cipher_quantity = [number] ) [EOL] [EOL] def test_think_number_minus_one_ciphers ( self , mocked_randint ) : [EOL] [docstring] [EOL] assert [string] == Thinker . think_number ( cipher_quantity = - [number] ) [EOL] [EOL] [EOL] class TestEvaluator : [EOL] [EOL] def test_evaluate_guess ( self ) : [EOL] answer = Evaluator . evaluate_guess ( [string] , [string] ) [EOL] [EOL] assert [number] == answer . rights [EOL] assert [number] == answer . wrongs [EOL] assert [number] == answer . present_but_wrong [EOL] [EOL] def test_evaluate_guess_three_wrongs ( self ) : [EOL] answer = Evaluator . evaluate_guess ( [string] , [string] ) [EOL] [EOL] assert [number] == answer . rights [EOL] assert [number] == answer . wrongs [EOL] assert [number] == answer . present_but_wrong [EOL] [EOL] def test_evaluate_guess_two_rights_one_wrong_one_pbw ( self ) : [EOL] answer = Evaluator . evaluate_guess ( [string] , [string] ) [EOL] [EOL] assert [number] == answer . rights [EOL] assert [number] == answer . wrongs [EOL] assert [number] == answer . present_but_wrong [EOL] [EOL] def test_evaluate_guess_one_right_three_wrongs ( self ) : [EOL] answer = Evaluator . evaluate_guess ( [string] , [string] ) [EOL] [EOL] assert [number] == answer . rights [EOL] assert [number] == answer . wrongs [EOL] assert [number] == answer . present_but_wrong [EOL] [EOL] def test_evaluate_guess_no_rights_four_pbw ( self ) : [EOL] answer = Evaluator . evaluate_guess ( [string] , [string] ) [EOL] [EOL] assert [number] == answer . rights [EOL] assert [number] == answer . wrongs [EOL] assert [number] == answer . present_but_wrong [EOL] [EOL] [EOL] class TestAnswer : [EOL] [EOL] def test_answer_str ( self ) : [EOL] answer = Answer ( [string] , [number] , [number] , [number] ) [EOL] assert [string] == str ( answer ) [EOL] [EOL] def test_answer_bool_false ( self ) : [EOL] answer = Answer ( [string] , [number] , [number] , [number] ) [EOL] assert not bool ( answer ) [EOL] [EOL] def test_answer_bool_true ( self ) : [EOL] answer = Answer ( [string] , [number] , [number] , [number] ) [EOL] assert bool ( answer ) [EOL] [EOL] [EOL] class TestGuesser : [EOL] [EOL] def test_guesser ( self ) : [EOL] guesser = Guesser ( [number] ) [EOL] [EOL] assert guesser . lower_guess == [number] [EOL] assert guesser . current_guess == [number] [EOL] assert guesser . higher_guess == [number] [EOL] [EOL] def test_guesser_take_a_guess_no_hint ( self ) : [EOL] guesser = Guesser ( [number] ) [EOL] guess = guesser . take_a_guess ( ) [EOL] [EOL] assert guess == str ( [number] // [number] ) [EOL] [EOL] def test_guesser_take_a_guess_lower_hint ( self ) : [EOL] guesser = Guesser ( [number] ) [EOL] guesser . lower_guess = [number] [EOL] guesser . current_guess = [number] [EOL] guess = guesser . take_a_guess ( [string] ) [EOL] [EOL] assert guesser . higher_guess == [number] [EOL] assert guess == str ( [number] // [number] ) [EOL] [EOL] def test_guesser_take_a_guess_higher_hint ( self ) : [EOL] guesser = Guesser ( [number] ) [EOL] guesser . current_guess = [number] [EOL] guesser . higher_guess = [number] [EOL] guess = guesser . take_a_guess ( [string] ) [EOL] [EOL] assert guesser . lower_guess == [number] [EOL] assert guess == str ( [number] // [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
import builtins [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] @ dataclass class Answer : [EOL] [EOL] number = ... [EOL] rights = ... [EOL] wrongs = ... [EOL] present_but_wrong = ... [EOL] [EOL] def __str__ ( self ) : [EOL] return f' [string] { self . rights } [string] { self . wrongs } [string] { self . present_but_wrong } [string] ' [EOL] [EOL] def __bool__ ( self ) : [EOL] return len ( self . number ) == self . rights and self . wrongs == [number] and self . present_but_wrong == [number] [EOL] [EOL] [EOL] class Evaluator : [EOL] [EOL] @ classmethod def evaluate_guess ( cls , guess , number ) : [EOL] rights = [number] [EOL] wrongs = [number] [EOL] present_but_wrong = [number] [EOL] [EOL] if guess == number : [EOL] return Answer ( number , len ( number ) , [number] , [number] ) [EOL] [EOL] for idx , char in enumerate ( guess ) : [EOL] if char == number [ idx ] : [EOL] rights += [number] [EOL] elif char in number : [EOL] present_but_wrong += [number] [EOL] else : [EOL] wrongs += [number] [EOL] [EOL] return Answer ( number , rights , wrongs , present_but_wrong ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Answer$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0
import builtins [EOL] from guessthenumber . common import generate_stringified_random_number [EOL] [EOL] [EOL] class Thinker : [EOL] [EOL] @ classmethod def think_number ( cls , cipher_quantity = [number] ) : [EOL] return generate_stringified_random_number ( cipher_quantity ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Optional [EOL] import guessthenumber [EOL] import builtins [EOL] import python [EOL] import typing [EOL] from abc import ( ABC , abstractmethod , ) [EOL] from typing import Optional [EOL] [EOL] from guessthenumber . constants import GAME_OVER_MESSAGE [EOL] from guessthenumber . evaluator import ( Answer , Evaluator , ) [EOL] from guessthenumber . guesser import Guesser [EOL] from guessthenumber . thinker import Thinker [EOL] [EOL] [EOL] class Game ( ABC ) : [EOL] [EOL] @ abstractmethod def play ( self , cipher_quantity = [number] , additional_message = None ) : [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] [EOL] class MachineGuessesHumanThinksGame ( Game ) : [EOL] [EOL] def play ( self , cipher_quantity = [number] , additional_message = None ) : [EOL] [EOL] guesser = Guesser ( cipher_quantity ) [EOL] hint = None [EOL] [EOL] [comment] [EOL] while True : [EOL] guess = guesser . take_a_guess ( hint ) [EOL] [EOL] if guess is None : [EOL] break [EOL] [EOL] hint = input ( f' [string] { guess } [string] ' ) [EOL] [EOL] print ( GAME_OVER_MESSAGE ) [EOL] [EOL] [EOL] class HumanGuessesMachineThinksGame ( Game ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] def play ( self , cipher_quantity = [number] , additional_message = None ) : [EOL] number = Thinker . think_number ( cipher_quantity = [number] ) [EOL] [EOL] while True : [EOL] guess = self . ask_for_a_guess ( additional_message ) [EOL] answer = Evaluator . evaluate_guess ( guess , number ) [EOL] [EOL] if answer : [EOL] break [EOL] [EOL] additional_message = str ( answer ) [EOL] [EOL] print ( GAME_OVER_MESSAGE ) [EOL] [EOL] @ staticmethod def ask_for_a_guess ( additional_message = None ) : [EOL] if additional_message : [EOL] print ( additional_message ) [EOL] [EOL] return input ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] which_game = int ( input ( [string] [string] [string] [string] ) ) [EOL] if which_game == [number] : [EOL] game = MachineGuessesHumanThinksGame ( ) [EOL] elif which_game == [number] : [EOL] game = HumanGuessesMachineThinksGame ( ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] game . play ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $guessthenumber.guesser.Guesser$ 0 0 0 $builtins.int$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $guessthenumber.guesser.Guesser$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $guessthenumber.evaluator.Answer$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $guessthenumber.evaluator.Answer$ 0 0 0 0 0 $builtins.str$ 0 0 0 $guessthenumber.evaluator.Answer$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $python.guessthenumber.game.Game$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $python.guessthenumber.game.Game$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $python.guessthenumber.game.Game$ 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from guessthenumber . common import max_cipher_quantity_number [EOL] [EOL] [EOL] class Guesser : [EOL] [EOL] def __init__ ( self , cipher_quantity ) : [EOL] self . lower_guess = [number] [EOL] self . current_guess = [number] [EOL] self . higher_guess = max_cipher_quantity_number ( cipher_quantity ) [EOL] [EOL] def take_a_guess ( self , hint = None ) : [EOL] [EOL] guess = None [EOL] [EOL] if hint is None : [EOL] guess = self . higher_guess // [number] [EOL] self . current_guess = guess [EOL] elif hint == [string] : [EOL] guess = ( self . lower_guess + self . current_guess ) // [number] [EOL] self . higher_guess , self . current_guess = self . current_guess , guess [EOL] elif hint == [string] : [EOL] guess = ( self . current_guess + self . higher_guess ) // [number] [EOL] self . lower_guess , self . current_guess = self . current_guess , guess [EOL] [EOL] return str ( guess ) if guess else None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $typing.Optional[builtins.int]$ 0 0 0
	0
import builtins [EOL] import random [EOL] [EOL] [EOL] def generate_stringified_random_number ( cipher_quantity ) : [EOL] return [string] . join ( map ( str , [ random . randint ( [number] , [number] ) for i in range ( cipher_quantity ) ] ) ) [EOL] [EOL] [EOL] def max_cipher_quantity_number ( cipher_quantity ) : [EOL] return int ( [string] * cipher_quantity ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] GAME_OVER_MESSAGE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0