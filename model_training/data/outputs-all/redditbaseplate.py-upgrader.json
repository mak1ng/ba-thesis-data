from setuptools import setup , find_packages [EOL] [EOL] setup ( name = [string] , packages = find_packages ( ) , python_requires = [string] , entry_points = { [string] : [ [string] ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import baseplate_py_upgrader [EOL] import typing [EOL] import pytest [EOL] [EOL] from baseplate_py_upgrader . wheelhouse import Version [EOL] from baseplate_py_upgrader . wheelhouse import Wheel [EOL] from baseplate_py_upgrader . wheelhouse import Wheelhouse [EOL] from baseplate_py_upgrader . wheelhouse import WheelhouseError [EOL] [EOL] [EOL] def test_empty_wheelhouse ( ) : [EOL] wheelhouse = Wheelhouse ( [ ] ) [EOL] [EOL] with pytest . raises ( WheelhouseError ) : [EOL] wheelhouse . get_latest_version ( [string] ) [EOL] [EOL] [EOL] def test_wheel_not_found ( ) : [EOL] wheelhouse = Wheelhouse ( [ Wheel ( [string] , [string] ) ] ) [EOL] [EOL] with pytest . raises ( WheelhouseError ) : [EOL] wheelhouse . get_latest_version ( [string] ) [EOL] [EOL] [EOL] def test_latest_release ( ) : [EOL] wheelhouse = Wheelhouse ( [ Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , ] ) [EOL] [EOL] assert wheelhouse . get_latest_version ( [string] ) == [string] [EOL] [EOL] [EOL] def test_latest_dev ( ) : [EOL] wheelhouse = Wheelhouse ( [ Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , ] ) [EOL] [EOL] assert wheelhouse . get_latest_version ( [string] ) == [string] [EOL] [EOL] [EOL] def test_parse_clean_release ( ) : [EOL] version = Version . from_str ( [string] ) [EOL] assert version . release == [ [number] , [number] ] [EOL] assert version . dev == float ( [string] ) [EOL] [EOL] [EOL] def test_parse_dev_release ( ) : [EOL] version = Version . from_str ( [string] ) [EOL] assert version . release == [ [number] , [number] , [number] ] [EOL] assert version . dev == [number] [EOL] [EOL] [EOL] def test_sort_version ( ) : [EOL] assert Version . from_str ( [string] ) < Version . from_str ( [string] ) [EOL] assert Version . from_str ( [string] ) < Version . from_str ( [string] ) [EOL] assert Version . from_str ( [string] ) >= Version . from_str ( [string] ) [EOL] assert Version . from_str ( [string] ) >= Version . from_str ( [string] ) [EOL] [EOL] [EOL] def test_ensure ( ) : [EOL] wheelhouse = Wheelhouse ( [ Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , Wheel ( [string] , [string] ) , ] ) [EOL] [EOL] print ( [string] ) [EOL] requirements_file = { [string] : [string] } [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] assert requirements_file == { [string] : [string] } [EOL] [EOL] print ( [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] assert requirements_file == { [string] : [string] } [EOL] [EOL] print ( [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] assert requirements_file == { [string] : [string] } [EOL] [EOL] print ( [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] assert requirements_file == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import textwrap [EOL] [EOL] from lib2to3 . refactor import RefactoringTool [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def reformat ( text ) : [EOL] return f"{ textwrap . dedent ( text ) } [string] " [EOL] [EOL] [EOL] class TestRefactoringTool : [EOL] def __init__ ( self , fixer ) : [EOL] self . refactoring_tool = RefactoringTool ( [ fixer ] , { } , explicit = True ) [EOL] [EOL] def refactor ( self , before ) : [EOL] print ( [string] , before ) [EOL] print ( [string] , repr ( self . refactoring_tool . driver . parse_string ( reformat ( before ) ) ) , ) [EOL] return str ( self . refactoring_tool . refactor_string ( reformat ( before ) , [string] ) ) [EOL] [EOL] def refactor_and_check ( self , before , expected ) : [EOL] __tracebackhide__ = True [EOL] [EOL] after = self . refactor ( before ) [EOL] assert reformat ( expected ) . rstrip ( [string] ) == after . rstrip ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def make_refactorer ( ) : [EOL] return TestRefactoringTool [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [ [string] ] ) , ( [string] , [ ] ) , ( [string] , [ ] ) , ( [string] , [ ] ) , ( [string] , [ [string] ] ) , ( [string] , [ ] ) , ( [string] , [ [string] ] ) , ( [string] , [ ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ ] ) , ( [string] , [ ] ) , ( [string] , [ ] ) , ) , ) def test_fix_deprecated_wireup ( caplog , make_refactorer , input , expected_logs ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] result = refactorer . refactor ( input ) [EOL] assert result , [string] [EOL] [EOL] if expected_logs : [EOL] assert caplog . records [EOL] for i , expected_levelname in enumerate ( expected_logs ) : [EOL] assert caplog . records [ i ] . levelname == expected_levelname , [string] [EOL] else : [EOL] assert not caplog . records , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] ) , ) , ) def test_fix_import_name ( make_refactorer , before , expected ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] refactorer . refactor_and_check ( before , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] ) , ) , ) def test_fix_import_from ( make_refactorer , before , expected ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] refactorer . refactor_and_check ( before , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] ) , ) , ) def test_fix_module_usage ( make_refactorer , before , expected ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] refactorer . refactor_and_check ( before , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] , ) , ( [string] , [string] , ) , ) , ) def test_fix_strings ( make_refactorer , before , expected ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] refactorer . refactor_and_check ( before , expected ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , ) , ) def test_fix_make_context_object ( caplog , make_refactorer , input ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] result = refactorer . refactor ( input ) [EOL] assert result , [string] [EOL] assert caplog . records [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , ) , ) def test_fix_make_context_object ( caplog , make_refactorer , input ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] result = refactorer . refactor ( input ) [EOL] assert result , [string] [EOL] assert caplog . records [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ( [string] , [string] , ) , ) , ) def test_thrift_entrypoint ( make_refactorer , before , expected ) : [EOL] refactorer = make_refactorer ( [string] ) [EOL] refactorer . refactor_and_check ( before , expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Callable , Any , Dict , List , Union , Optional [EOL] import baseplate_py_upgrader [EOL] import operator [EOL] import requirements [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import collections [EOL] import logging [EOL] import operator [EOL] import re [EOL] import urllib . request [EOL] [EOL] from typing import Callable [EOL] from typing import DefaultDict [EOL] from typing import List [EOL] from typing import NamedTuple [EOL] from typing import Optional [EOL] from typing import Sequence [EOL] from typing import Tuple [EOL] [EOL] from . requirements import RequirementsFile [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] WHEEL_INDEX = [string] [EOL] [EOL] [EOL] [comment] [EOL] WHEEL_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] VERSION_RE = re . compile ( [string] ) [EOL] REQUIREMENT_RE = re . compile ( [string] ) [EOL] SPECIFIER_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] OPERATORS = { [string] : operator . ge , [string] : operator . le , [string] : operator . eq } [EOL] [EOL] [EOL] class WheelhouseError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Wheel ( NamedTuple ) : [EOL] name = ... [EOL] version = ... [EOL] [EOL] [EOL] class Version ( NamedTuple ) : [EOL] release = ... [EOL] dev = ... [EOL] [EOL] @ classmethod def from_str ( cls , version ) : [EOL] m = VERSION_RE . match ( version ) [EOL] if not m : [EOL] raise ValueError ( f" [string] { version }" ) [EOL] [EOL] release = [ int ( c ) for c in m [ [string] ] . split ( [string] ) ] [EOL] dev = m . group ( [string] ) [EOL] return cls ( release , float ( dev ) if dev else float ( [string] ) ) [EOL] [EOL] [EOL] class SpecifierSet ( NamedTuple ) : [EOL] specifiers = ... [EOL] [EOL] @ classmethod def from_str ( cls , requirements ) : [EOL] specifiers = [ ] [EOL] for specifier_text in requirements . split ( [string] ) : [EOL] m = SPECIFIER_RE . match ( specifier_text ) [EOL] if not m : [EOL] raise ValueError ( f" [string] { repr ( specifier_text ) }" ) [EOL] specifiers . append ( ( OPERATORS [ m [ [string] ] ] , Version . from_str ( m [ [string] ] ) ) ) [EOL] return cls ( specifiers ) [EOL] [EOL] def satisfied_by ( self , version ) : [EOL] return all ( op ( version , specified ) for op , specified in self . specifiers ) [EOL] [EOL] [EOL] class Wheelhouse : [EOL] @ classmethod def fetch ( cls ) : [EOL] wheels = [ ] [EOL] with urllib . request . urlopen ( WHEEL_INDEX ) as f : [EOL] for line in f . read ( ) . decode ( [string] ) . splitlines ( ) : [EOL] m = WHEEL_RE . match ( line ) [EOL] if m : [EOL] wheels . append ( Wheel ( m [ [string] ] . lower ( ) , m [ [string] ] ) ) [EOL] [EOL] return cls ( wheels ) [EOL] [EOL] def __init__ ( self , wheels ) : [EOL] by_distribution = collections . defaultdict ( list ) [EOL] for wheel in wheels : [EOL] by_distribution [ wheel . name ] . append ( wheel . version ) [EOL] [EOL] self . by_distribution = dict ( by_distribution ) [EOL] [EOL] def get_available_versions ( self , distribution_name ) : [EOL] try : [EOL] return self . by_distribution [ distribution_name . lower ( ) . replace ( [string] , [string] ) ] [EOL] except KeyError : [EOL] raise WheelhouseError ( f" [string] { repr ( distribution_name ) }" ) [EOL] [EOL] def get_latest_version ( self , distribution_name , prefix = None ) : [EOL] versions = self . get_available_versions ( distribution_name ) [EOL] [EOL] if not prefix or [string] not in prefix : [EOL] versions = [ v for v in versions if [string] not in v ] [EOL] [EOL] if prefix : [EOL] return str ( max ( ( v for v in versions if v . startswith ( prefix ) ) , key = Version . from_str ) ) [EOL] else : [EOL] return str ( max ( versions , key = Version . from_str ) ) [EOL] [EOL] def ensure ( self , requirements_file , requirement ) : [EOL] m = REQUIREMENT_RE . match ( requirement ) [EOL] if not m : [EOL] raise ValueError ( f" [string] { repr ( requirement ) }" ) [EOL] [EOL] distribution_name = m [ [string] ] [EOL] specifiers = SpecifierSet . from_str ( m [ [string] ] ) [EOL] [EOL] try : [EOL] current_version = Version . from_str ( requirements_file [ distribution_name ] ) [EOL] except KeyError : [EOL] return [EOL] [EOL] if specifiers . satisfied_by ( current_version ) : [EOL] return [EOL] [EOL] versions = self . get_available_versions ( distribution_name ) [EOL] for version_str in sorted ( versions , key = Version . from_str , reverse = True ) : [EOL] version = Version . from_str ( version_str ) [EOL] if specifiers . satisfied_by ( version ) : [EOL] logger . info ( [string] , distribution_name , version_str , ) [EOL] requirements_file [ distribution_name ] = version_str [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Callable[[typing.Any,typing.Any],typing.Any],typing.Callable[[typing.Any,typing.Any],typing.Any],typing.Callable[[typing.Any,typing.Any],typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $"Version"$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Tuple[typing.Callable[[Version,Version],builtins.bool],Version]]$ 0 0 0 0 0 0 0 $"SpecifierSet"$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Callable[[typing.Any,typing.Any],typing.Any],typing.Callable[[typing.Any,typing.Any],typing.Any],typing.Callable[[typing.Any,typing.Any],typing.Any]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 0 $Version$ 0 0 0 0 0 0 0 0 $Version$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Wheelhouse"$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[Wheel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Wheel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $requirements.RequirementsFile$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $baseplate_py_upgrader.wheelhouse.SpecifierSet$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 $requirements.RequirementsFile$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.SpecifierSet$ 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 0 0 0 0 $baseplate_py_upgrader.wheelhouse.SpecifierSet$ 0 0 0 $baseplate_py_upgrader.wheelhouse.Version$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $requirements.RequirementsFile$ 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Dict [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] from lib2to3 . main import StdoutRefactoringTool [EOL] from lib2to3 . refactor import get_fixers_from_package [EOL] from pathlib import Path [EOL] [EOL] [EOL] def refactor_python_files ( root , fix_package ) : [EOL] fixers = get_fixers_from_package ( fix_package ) [EOL] options = { [string] : True } [EOL] refactoring_tool = StdoutRefactoringTool ( fixers = fixers , options = options , explicit = [ ] , nobackups = True , show_diffs = False , ) [EOL] refactoring_tool . refactor ( [ root ] , write = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Any , List [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] from pathlib import Path [EOL] from typing import List [EOL] [EOL] [EOL] class RequirementsError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class RequirementsNotFoundError ( RequirementsError ) : [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( f" [string] { path }" ) [EOL] [EOL] [EOL] REQUIREMENT_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] class RequirementsFile : [EOL] @ classmethod def from_root ( cls , root ) : [EOL] path = root / [string] [EOL] [EOL] try : [EOL] lines = path . read_text ( [string] ) . splitlines ( ) [EOL] return cls ( path , lines ) [EOL] except OSError as exc : [EOL] raise RequirementsNotFoundError ( root ) from exc [EOL] [EOL] def __init__ ( self , path , lines ) : [EOL] self . path = path [EOL] self . lines = lines [EOL] [EOL] def __getitem__ ( self , distribution_name ) : [EOL] for line in self . lines : [EOL] m = REQUIREMENT_RE . match ( line ) [EOL] if m : [EOL] if m [ [string] ] . lower ( ) == distribution_name . lower ( ) : [EOL] return m [ [string] ] [EOL] raise KeyError ( f"{ distribution_name } [string] " ) [EOL] [EOL] def __setitem__ ( self , distribution_name , version ) : [EOL] for i , line in enumerate ( self . lines ) : [EOL] m = REQUIREMENT_RE . match ( line ) [EOL] if m : [EOL] if m [ [string] ] . lower ( ) == distribution_name . lower ( ) : [EOL] self . lines [ i ] = f"{ distribution_name } [string] { version }" [EOL] return [EOL] self . lines . append ( f"{ distribution_name } [string] { version }" ) [EOL] [EOL] def write ( self ) : [EOL] with self . path . open ( [string] ) as f : [EOL] f . write ( [string] . join ( self . lines ) + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"RequirementsFile"$ 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Optional , Tuple , Type [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] [EOL] from . docker import IMAGE_RE [EOL] [EOL] [EOL] PYTHON_REQUIRES_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] PythonVersion = Tuple [ int , int ] [EOL] [EOL] [EOL] def _make_version_tuple ( version_str ) : [EOL] major , sep , minor = version_str . partition ( [string] ) [EOL] assert sep and minor [EOL] return ( int ( major ) , int ( minor ) ) [EOL] [EOL] [EOL] def guess_python_version ( root ) : [EOL] try : [EOL] setup_py_text = ( root / [string] ) . read_text ( ) [EOL] for op , version in PYTHON_REQUIRES_RE . findall ( setup_py_text ) : [EOL] return _make_version_tuple ( version ) [EOL] except OSError : [EOL] pass [EOL] [EOL] try : [EOL] dockerfile_text = ( root / [string] ) . read_text ( ) [EOL] for match in IMAGE_RE . findall ( dockerfile_text ) : [EOL] return _make_version_tuple ( match [ [number] ] ) [EOL] except OSError : [EOL] pass [EOL] [EOL] try : [EOL] dockerfile_text = ( root / [string] ) . read_text ( ) [EOL] for match in IMAGE_RE . findall ( dockerfile_text ) : [EOL] return _make_version_tuple ( match [ [number] ] ) [EOL] except OSError : [EOL] pass [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PythonVersion$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PythonVersion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Match , Any [EOL] import pathlib [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import logging [EOL] import re [EOL] [EOL] from pathlib import Path [EOL] from typing import Match [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] IMAGE_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def upgrade_docker_image_references_in_file ( target_series , filepath ) : [EOL] major , minor = target_series . split ( [string] ) [EOL] if major == [string] : [EOL] image_series = f"{ major } [string] { minor }" [EOL] else : [EOL] image_series = f"{ major }" [EOL] [EOL] def replace_docker_image_reference ( m ) : [EOL] return f" [string] { image_series } [string] { m [ [string] ] } [string] { m [ [string] ] }{ m [ [string] ] or [string] }" [EOL] [EOL] file_content = filepath . read_text ( ) [EOL] changed = IMAGE_RE . sub ( replace_docker_image_reference , file_content , re . MULTILINE ) [EOL] [EOL] if file_content == changed : [EOL] return [EOL] [EOL] with filepath . open ( [string] ) as f : [EOL] logger . info ( [string] , filepath ) [EOL] f . write ( changed ) [EOL] [EOL] [EOL] def upgrade_docker_image_references ( target_series , root ) : [EOL] for dockerfile in root . glob ( [string] ) : [EOL] upgrade_docker_image_references_in_file ( target_series , dockerfile ) [EOL] [EOL] dronefile = root / [string] [EOL] if dronefile . exists ( ) : [EOL] upgrade_docker_image_references_in_file ( target_series , dronefile ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , Dict [EOL] import python_version [EOL] import pathlib [EOL] import wheelhouse [EOL] import requirements [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import argparse [EOL] import logging [EOL] import subprocess [EOL] import sys [EOL] [EOL] from pathlib import Path [EOL] from typing import Callable [EOL] from typing import Dict [EOL] from typing import Optional [EOL] [EOL] from . colors import Color [EOL] from . colors import colorize [EOL] from . colors import print [EOL] from . docker import upgrade_docker_image_references [EOL] from . fixes import v0_29 [EOL] from . fixes import v1_0 [EOL] from . fixes import v1_3 [EOL] from . python_version import guess_python_version [EOL] from . python_version import PythonVersion [EOL] from . requirements import RequirementsFile [EOL] from . wheelhouse import Wheelhouse [EOL] [EOL] [EOL] def no_op_upgrade ( root , python_version , requirements_file , wheelhouse , ) : [EOL] [comment] [EOL] return [number] [EOL] [EOL] [EOL] [comment] [EOL] UPGRADES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [comment] [EOL] PREFIX_OVERRIDE = { } [EOL] [EOL] [comment] [EOL] UPDATERS = { [string] : no_op_upgrade , [string] : no_op_upgrade , [string] : v0_29 . update , [string] : no_op_upgrade , [string] : v1_0 . update , [string] : no_op_upgrade , [string] : no_op_upgrade , [string] : v1_3 . update , [string] : no_op_upgrade , } [EOL] [EOL] [EOL] class LogFormatter ( logging . Formatter ) : [EOL] prefixes = { logging . DEBUG : colorize ( [string] , Color . BLUE ) , logging . INFO : colorize ( [string] , Color . GREEN . BOLD ) , logging . WARNING : colorize ( [string] , Color . YELLOW . BOLD ) , logging . ERROR : colorize ( [string] , Color . RED . BOLD ) , logging . CRITICAL : colorize ( [string] , Color . RED . BOLD ) , } [EOL] [EOL] def format ( self , record ) : [EOL] return f" [string] { self . prefixes [ record . levelno ] } [string] { super ( ) . format ( record ) }" [EOL] [EOL] [EOL] def is_git_repo_and_clean ( root ) : [EOL] result = subprocess . run ( [ [string] , [string] , [string] ] , cwd = root , capture_output = True ) [EOL] return result . returncode == [number] and not result . stdout [EOL] [EOL] [EOL] def get_target_series ( current_version ) : [EOL] for prefix , target in UPGRADES . items ( ) : [EOL] if current_version . startswith ( prefix ) : [EOL] return target [EOL] raise Exception ( f" [string] { repr ( current_version ) } [string] " ) [EOL] [EOL] [EOL] def _main ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , type = Path , ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if not is_git_repo_and_clean ( args . source_dir ) : [EOL] print ( f"{ args . source_dir } [string] " , color = Color . RED . BOLD , ) [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] requirements_file = RequirementsFile . from_root ( args . source_dir ) [EOL] [EOL] try : [EOL] current_version = requirements_file [ [string] ] [EOL] except KeyError : [EOL] print ( [string] , color = Color . RED . BOLD ) [EOL] return [number] [EOL] [EOL] python_version = guess_python_version ( args . source_dir ) [EOL] [EOL] wheelhouse = Wheelhouse . fetch ( ) [EOL] target_series = get_target_series ( current_version ) [EOL] prefix = PREFIX_OVERRIDE . get ( target_series , target_series ) [EOL] target_version = wheelhouse . get_latest_version ( [string] , prefix = prefix ) [EOL] [EOL] print ( [string] , color = Color . CYAN . BOLD ) [EOL] print ( f" [string] { args . source_dir }" ) [EOL] if python_version : [EOL] print ( f" [string] { [string] . join ( str ( v ) for v in python_version ) }" ) [EOL] else : [EOL] print ( [string] , color = Color . YELLOW . BOLD ) [EOL] print ( f" [string] { current_version }" ) [EOL] print ( f" [string] { target_version } [string] { target_series } [string] " ) [EOL] print ( ) [EOL] [EOL] updater = UPDATERS [ target_series ] [EOL] result = updater ( args . source_dir , python_version , requirements_file , wheelhouse ) [EOL] [EOL] upgrade_docker_image_references ( target_series , args . source_dir ) [EOL] [EOL] if result == [number] : [EOL] logging . info ( [string] , target_version ) [EOL] requirements_file [ [string] ] = target_version [EOL] [EOL] print ( ) [EOL] print ( [string] , color = Color . CYAN . BOLD ) [EOL] print ( [string] , color = Color . WHITE . BOLD ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] [EOL] if target_series in UPGRADES : [EOL] print ( [string] , color = Color . CYAN . BOLD , ) [EOL] else : [EOL] print ( ) [EOL] print ( [string] , color = Color . RED . BOLD ) [EOL] [EOL] requirements_file . write ( ) [EOL] [EOL] return result [EOL] [EOL] [EOL] def main ( ) : [EOL] formatter = LogFormatter ( [string] ) [EOL] handler = logging . StreamHandler ( sys . stdout ) [EOL] handler . setFormatter ( formatter ) [EOL] root_logger = logging . getLogger ( ) [EOL] root_logger . addHandler ( handler ) [EOL] root_logger . setLevel ( logging . INFO ) [EOL] [EOL] try : [EOL] sys . exit ( _main ( ) ) [EOL] except Exception as exc : [EOL] print ( f" [string] { exc }" , color = Color . RED . BOLD ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.LogRecord$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TextIO , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import builtins [EOL] import enum [EOL] import sys [EOL] [EOL] from typing import Any [EOL] from typing import Optional [EOL] from typing import TextIO [EOL] [EOL] [EOL] @ enum . unique class Color ( enum . Enum ) : [EOL] RED = [string] [EOL] GREEN = [string] [EOL] YELLOW = [string] [EOL] BLUE = [string] [EOL] MAGENTA = [string] [EOL] CYAN = [string] [EOL] WHITE = [string] [EOL] [EOL] BOLD_RED = [string] [EOL] BOLD_GREEN = [string] [EOL] BOLD_YELLOW = [string] [EOL] BOLD_BLUE = [string] [EOL] BOLD_MAGENTA = [string] [EOL] BOLD_CYAN = [string] [EOL] BOLD_WHITE = [string] [EOL] [EOL] @ property def BOLD ( self ) : [EOL] return Color ( f" [string] { self . value }" ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . value ) [EOL] [EOL] [EOL] def colorize ( message , color ) : [EOL] return f" [string] { color } [string] { message } [string] " [EOL] [EOL] [EOL] def print ( * objects , sep = [string] , end = [string] , file = sys . stdout , flush = False , color = None , ) : [EOL] joined = sep . join ( ( str ( obj ) for obj in objects ) ) [EOL] if color : [EOL] joined = colorize ( joined , color ) [EOL] return builtins . print ( joined , end = end , file = file , flush = flush ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $"Color"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List , Tuple , Optional [EOL] import logging [EOL] import builtins [EOL] import lib2to3 [EOL] import typing [EOL] import logging [EOL] [EOL] from lib2to3 . fixer_base import BaseFix [EOL] from lib2to3 . fixer_util import Comma [EOL] from lib2to3 . fixer_util import Dot [EOL] from lib2to3 . fixer_util import Leaf [EOL] from lib2to3 . fixer_util import Name [EOL] from lib2to3 . fixer_util import Node [EOL] from lib2to3 . fixer_util import syms [EOL] from lib2to3 . fixer_util import token [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] from typing import Union [EOL] [EOL] [EOL] LN = Union [ Node , Leaf ] [EOL] Capture = Dict [ str , LN ] [EOL] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class BaseplateBaseFix ( BaseFix ) : [EOL] def warn ( self , node , message ) : [EOL] logger . warning ( [string] , node . get_lineno ( ) , self . filename , message ) [EOL] [EOL] [EOL] def split_package_and_name ( dotted_name ) : [EOL] * module , name = dotted_name . split ( [string] ) [EOL] return ( [string] . join ( module ) , name ) [EOL] [EOL] [EOL] def traverse_dotted_name ( dotted_name ) : [EOL] result = [ ] [EOL] for part in dotted_name . leaves ( ) : [EOL] assert part . type in ( token . NAME , token . DOT , token . STAR , ) , f" [string] { repr ( part ) }" [EOL] result . append ( part . value ) [EOL] return [string] . join ( result ) [EOL] [EOL] [EOL] def DottedName ( full_name , prefix ) : [EOL] names = [ name . strip ( ) for name in full_name . split ( [string] ) ] [EOL] [EOL] dotted_name = [ ] [EOL] for name in names : [EOL] dotted_name . append ( Name ( name ) ) [EOL] dotted_name . append ( Dot ( ) ) [EOL] dotted_name . pop ( ) [EOL] [EOL] return Node ( syms . dotted_name , dotted_name , prefix = prefix ) [EOL] [EOL] [EOL] def ImportAsName ( name , nick , prefix = None ) : [EOL] if not nick : [EOL] return Name ( name , prefix = prefix ) [EOL] return Node ( syms . import_as_name , [ Name ( name ) , Name ( [string] , prefix = [string] ) , Name ( nick , prefix = [string] ) ] , prefix = prefix , ) [EOL] [EOL] [EOL] def FromImport ( package , imports , prefix ) : [EOL] children = [ ] [EOL] for name , nick in imports : [EOL] children . append ( ImportAsName ( name , nick , prefix = [string] ) ) [EOL] children . append ( Comma ( ) ) [EOL] children . pop ( ) [EOL] import_as_names = Node ( syms . import_as_names , children ) [EOL] [EOL] return Node ( syms . import_from , [ Name ( [string] , prefix = prefix ) , DottedName ( package , prefix = [string] ) , Name ( [string] , prefix = [string] ) , import_as_names , ] , ) [EOL] [EOL] [EOL] def AttrChain ( name ) : [EOL] first , * rest = name . split ( [string] ) [EOL] children = [ Name ( first ) ] [EOL] for attr in rest : [EOL] children . append ( Node ( syms . trailer , [ Dot ( ) , Name ( attr ) ] ) ) [EOL] return children [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib2to3.fixer_util.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib2to3.fixer_util.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib2to3.fixer_util.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[lib2to3.fixer_util.Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Match , List , Optional [EOL] import python_version [EOL] import wheelhouse [EOL] import pathlib [EOL] import requirements [EOL] import builtins [EOL] import typing [EOL] import configparser [EOL] import logging [EOL] [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] [EOL] from . . . python_version import PythonVersion [EOL] from . . . refactor import refactor_python_files [EOL] from . . . requirements import RequirementsFile [EOL] from . . . wheelhouse import Wheelhouse [EOL] from . thrift import find_invalid_thrift_idl [EOL] [EOL] [EOL] def add_max_concurrency ( root ) : [EOL] servers = { } [EOL] [EOL] for path in root . glob ( [string] ) : [EOL] config_lines = path . read_text ( ) . splitlines ( ) [EOL] [EOL] current_server = None [EOL] for i , line in enumerate ( config_lines ) : [EOL] m = configparser . RawConfigParser . SECTCRE . match ( line ) [EOL] if m : [EOL] name = m . group ( [string] ) [EOL] if name . startswith ( [string] ) : [EOL] current_server = name [EOL] else : [EOL] current_server = None [EOL] continue [EOL] [EOL] if current_server : [EOL] m = configparser . RawConfigParser . OPTCRE . match ( line ) [EOL] if m : [EOL] name = m . group ( [string] ) [EOL] if name == [string] : [EOL] servers [ current_server ] = None [EOL] elif name == [string] : [EOL] servers [ current_server ] = i [EOL] [EOL] insertion_points = list ( filter ( None , servers . values ( ) ) ) [EOL] if insertion_points : [EOL] for line_no in sorted ( insertion_points , reverse = True ) : [EOL] config_lines . insert ( line_no + [number] , [string] ) [EOL] [EOL] with path . open ( [string] ) as f : [EOL] f . write ( [string] . join ( config_lines ) + [string] ) [EOL] [EOL] logging . info ( [string] , path ) [EOL] [EOL] [EOL] def fix_thrift_compiler_references ( root ) : [EOL] for path in root . glob ( [string] ) : [EOL] if not path . is_file ( ) : [EOL] continue [EOL] [EOL] if path . stat ( ) . st_size > [number] : [EOL] continue [EOL] [EOL] try : [EOL] input = path . read_text ( encoding = [string] ) [EOL] except UnicodeError : [EOL] continue [EOL] [EOL] if [string] in input : [EOL] output = input . replace ( [string] , [string] ) [EOL] with path . open ( [string] ) as f : [EOL] f . write ( output ) [EOL] logging . info ( [string] , path ) [EOL] [EOL] [EOL] def update ( root , python_version , requirements_file , wheelhouse , ) : [EOL] result = [number] [EOL] [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] [EOL] refactor_python_files ( root , __name__ ) [EOL] [EOL] add_max_concurrency ( root ) [EOL] [EOL] if find_invalid_thrift_idl ( root ) : [EOL] result = [number] [EOL] [EOL] fix_thrift_compiler_references ( root ) [EOL] [EOL] logging . warning ( [string] ) [EOL] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] from lib2to3 . fixer_util import Assign [EOL] from lib2to3 . fixer_util import Call [EOL] from lib2to3 . fixer_util import Comma [EOL] from lib2to3 . fixer_util import Name [EOL] from lib2to3 . fixer_util import Newline [EOL] from lib2to3 . fixer_util import Node [EOL] from lib2to3 . fixer_util import syms [EOL] from lib2to3 . fixer_util import token [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import FromImport [EOL] from . . import LN [EOL] from . . import traverse_dotted_name [EOL] [EOL] [EOL] class FixThriftEntrypoint ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] if node . type == syms . import_from : [EOL] module_name = traverse_dotted_name ( capture [ [string] ] ) [EOL] if module_name != [string] : [EOL] return [EOL] [EOL] to_process = capture [ [string] ] [EOL] imports = [ ] [EOL] for n in to_process : [EOL] if n . type in ( token . COMMA , token . LPAR , token . RPAR ) : [EOL] continue [EOL] elif n . type == token . STAR : [EOL] imports . append ( ( [string] , None ) ) [EOL] elif n . type == token . NAME : [EOL] if n . value == [string] : [EOL] imports . append ( ( [string] , None ) ) [EOL] else : [EOL] imports . append ( ( n . value , None ) ) [EOL] elif n . type == syms . import_as_name : [EOL] import_name , import_nick = n . children [ [number] ] , n . children [ [number] ] [EOL] assert ( n . children [ [number] ] . type == token . NAME and n . children [ [number] ] . value == [string] ) [EOL] [EOL] if import_name . value == [string] : [EOL] self . warn ( n , [string] , ) [EOL] continue [EOL] [EOL] imports . append ( ( import_name . value , import_nick . value if import_nick else None ) ) [EOL] elif n . type == syms . import_as_names : [EOL] to_process . extend ( n . children ) [EOL] else : [EOL] raise Exception ( f" [string] { repr ( n ) }" ) [EOL] [EOL] if imports : [EOL] node . replace ( FromImport ( module_name , imports , prefix = node . prefix ) ) [EOL] else : [EOL] node . remove ( ) [EOL] elif node . type == syms . power : [EOL] capture [ [string] ] . replace ( Name ( [string] ) ) [EOL] elif node . type == syms . simple_stmt : [EOL] if [string] in capture : [EOL] capture [ [string] ] . replace ( Name ( [string] ) ) [EOL] elif [string] in capture : [EOL] self . arguments = [ arg . clone ( ) for arg in capture [ [string] ] ] [EOL] self . remove_me = node [EOL] elif [string] in capture : [EOL] processor_name = capture [ [string] ] . clone ( ) [EOL] processor_name . prefix = [string] [EOL] arguments = [ processor_name , Comma ( ) ] [EOL] original_arguments = getattr ( self , [string] , None ) [EOL] if original_arguments : [EOL] original_arguments [ [number] ] . prefix = [string] [EOL] arguments . extend ( original_arguments ) [EOL] else : [EOL] arguments . extend ( ( Name ( [string] , prefix = [string] ) , Comma ( ) , Name ( [string] , prefix = [string] ) , ) ) [EOL] [EOL] node . replace ( [ Assign ( capture [ [string] ] . clone ( ) , Node ( syms . simple_stmt , [ Call ( Name ( [string] ) , arguments , ) ] , ) , ) , Newline ( ) , ] ) [EOL] [EOL] if hasattr ( self , [string] ) : [EOL] self . remove_me . remove ( ) [EOL] else : [EOL] raise Exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Capture$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $Capture$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 $LN$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 $LN$ 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 $Capture$ 0 0 $typing.Any$ 0 $Capture$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Iterator , Any [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import re [EOL] [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from typing import Iterator [EOL] from typing import NamedTuple [EOL] [EOL] [EOL] RESERVED_KEYWORDS = { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , } [EOL] [EOL] [EOL] class TokenKind ( Enum ) : [EOL] WHITESPACE = re . compile ( [string] ) [EOL] MULTILINE_COMMENT = re . compile ( [string] ) [EOL] DOC_COMMENT = re . compile ( [string] ) [EOL] UNIX_COMMENT = re . compile ( [string] ) [EOL] COMMENT = re . compile ( [string] ) [EOL] BOOL_CONSTANT = re . compile ( [string] ) [EOL] FLOAT_CONSTANT = re . compile ( [string] ) [EOL] HEX_CONSTANT = re . compile ( [string] ) [EOL] DEC_CONSTANT = re . compile ( [string] ) [EOL] STRING_LITERAL = re . compile ( [string] ) [EOL] SYMBOL = re . compile ( [string] ) [EOL] IDENTIFIER = re . compile ( [string] ) [EOL] [EOL] [EOL] class Token ( NamedTuple ) : [EOL] kind = ... [EOL] value = ... [EOL] line = ... [EOL] [EOL] [EOL] class ThriftError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def read_tokens ( text ) : [EOL] pos = [number] [EOL] line_no = [number] [EOL] [EOL] while pos < len ( text ) : [EOL] for kind in TokenKind : [EOL] m = kind . value . match ( text [ pos : ] ) [EOL] if m : [EOL] value = m . group ( [number] ) [EOL] line_no += value . count ( [string] ) [EOL] pos += m . end ( ) [EOL] [EOL] if kind is not TokenKind . WHITESPACE : [EOL] yield Token ( kind = kind , value = value , line = line_no ) [EOL] [EOL] break [EOL] else : [EOL] raise ThriftError ( f" [string] { line_no } [string] " ) [EOL] [EOL] [EOL] def find_invalid_thrift_idl ( root ) : [EOL] any_errors = False [EOL] for path in root . glob ( [string] ) : [EOL] error_seen = False [EOL] try : [EOL] text = path . read_text ( [string] ) [EOL] for token in read_tokens ( text ) : [EOL] if token . kind != TokenKind . IDENTIFIER : [EOL] continue [EOL] [EOL] if token . value == [string] : [EOL] logging . error ( [string] [string] , token . line , path , ) [EOL] error_seen = True [EOL] elif token . value in RESERVED_KEYWORDS : [EOL] logging . error ( [string] [string] , token . line , path , token . value , ) [EOL] error_seen = True [EOL] except ThriftError as exc : [EOL] logging . warning ( [string] , path , exc ) [EOL] [EOL] if error_seen : [EOL] any_errors = True [EOL] [EOL] return any_errors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TokenKind$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from lib2to3 . fixer_util import syms [EOL] [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import LN [EOL] [EOL] [EOL] class FixDeprecatedWireup ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] args = capture [ [string] ] [EOL] if len ( args ) == [number] and args [ [number] ] . type == syms . arglist : [EOL] args = args [ [number] ] . children [EOL] [EOL] if capture [ [string] ] . value == [string] : [EOL] [comment] [EOL] if len ( args ) == [number] : [EOL] return [EOL] [EOL] if capture [ [string] ] . value == [string] : [EOL] [comment] [EOL] if len ( args ) == [number] : [EOL] return [EOL] [EOL] [comment] [EOL] if len ( args ) == [number] and args [ [number] ] . type == syms . argument : [EOL] return [EOL] [EOL] if capture [ [string] ] . value == [string] : [EOL] [comment] [EOL] if len ( args ) == [number] : [EOL] return [EOL] [EOL] self . warn ( node , [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0
from typing import Optional [EOL] import python_version [EOL] import pathlib [EOL] import wheelhouse [EOL] import requirements [EOL] import builtins [EOL] import typing [EOL] from pathlib import Path [EOL] from typing import Optional [EOL] [EOL] from . . . python_version import PythonVersion [EOL] from . . . refactor import refactor_python_files [EOL] from . . . requirements import RequirementsFile [EOL] from . . . wheelhouse import Wheelhouse [EOL] [EOL] [EOL] def update ( root , python_version , requirements_file , wheelhouse , ) : [EOL] refactor_python_files ( root , __name__ ) [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from . import replace_module_references [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import LN [EOL] [EOL] [EOL] class FixStrings ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] new_text = replace_module_references ( node . value ) [EOL] if new_text != node . value : [EOL] node . value = new_text [EOL] node . changed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 $builtins.str$ 0 0 0 $LN$ 0 0 0 0 0 $builtins.str$ 0 $LN$ 0 0 0 0 $LN$ 0 0 0 $builtins.str$ 0 $LN$ 0 0 0 0 0
from typing import Pattern , Match , Optional , Dict [EOL] import python_version [EOL] import pathlib [EOL] import wheelhouse [EOL] import requirements [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import re [EOL] [EOL] from pathlib import Path [EOL] from typing import Match [EOL] from typing import Optional [EOL] [EOL] from . . . python_version import PythonVersion [EOL] from . . . refactor import refactor_python_files [EOL] from . . . requirements import RequirementsFile [EOL] from . . . wheelhouse import Wheelhouse [EOL] [EOL] [EOL] RENAMES = { [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] BASEPLATE_NAME_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] class NameRemovedError ( Exception ) : [EOL] def __init__ ( self , name ) : [EOL] super ( ) . __init__ ( f"{ repr ( name ) } [string] " ) [EOL] [EOL] [EOL] def get_new_name ( name ) : [EOL] [docstring] [EOL] for old , new in sorted ( RENAMES . items ( ) , key = lambda i : len ( i [ [number] ] ) , reverse = True ) : [EOL] if name == old or name . startswith ( old + [string] ) : [EOL] if new is None : [EOL] raise NameRemovedError ( old ) [EOL] [EOL] try : [EOL] return name . replace ( old , new , [number] ) [EOL] except KeyError : [EOL] return None [EOL] return None [EOL] [EOL] [EOL] def replace_module_references ( corpus ) : [EOL] [docstring] [EOL] [EOL] def replace_name ( m ) : [EOL] old_name = m [ [string] ] [EOL] try : [EOL] new_name = get_new_name ( old_name ) [EOL] except NameRemovedError : [EOL] new_name = None [EOL] return new_name or old_name [EOL] [EOL] return BASEPLATE_NAME_RE . sub ( replace_name , corpus , re . MULTILINE ) [EOL] [EOL] [EOL] def update ( root , python_version , requirements_file , wheelhouse , ) : [EOL] if python_version : [EOL] if python_version < ( [number] , [number] ) : [EOL] logging . error ( [string] ) [EOL] return [number] [EOL] else : [EOL] logging . warning ( [string] ) [EOL] [EOL] refactor_python_files ( root , __name__ ) [EOL] [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] wheelhouse . ensure ( requirements_file , [string] ) [EOL] [EOL] for path in root . glob ( [string] ) : [EOL] if path . suffix in ( [string] , [string] , [string] , [string] ) : [EOL] try : [EOL] old = path . read_text ( [string] ) [EOL] new = replace_module_references ( old ) [EOL] if new != old : [EOL] logging . info ( [string] , path ) [EOL] with path . open ( [string] , encoding = [string] ) as f : [EOL] f . write ( new ) [EOL] except OSError as exc : [EOL] logging . warning ( [string] , path , exc ) [EOL] [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , DefaultDict , List , Tuple , Optional [EOL] import builtins [EOL] import typing [EOL] import collections [EOL] [EOL] from lib2to3 . fixer_util import find_indentation [EOL] from lib2to3 . fixer_util import Name [EOL] from lib2to3 . fixer_util import Node [EOL] from lib2to3 . fixer_util import syms [EOL] from lib2to3 . fixer_util import token [EOL] from typing import DefaultDict [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] [EOL] from . import get_new_name [EOL] from . import NameRemovedError [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import FromImport [EOL] from . . import ImportAsName [EOL] from . . import LN [EOL] from . . import split_package_and_name [EOL] from . . import traverse_dotted_name [EOL] [EOL] [EOL] class FixImportFrom ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] module_name = traverse_dotted_name ( capture [ [string] ] ) [EOL] [EOL] to_process = capture [ [string] ] [EOL] imports = [ ] [EOL] for n in to_process : [EOL] if n . type in ( token . COMMA , token . LPAR , token . RPAR ) : [EOL] continue [EOL] elif n . type == token . STAR : [EOL] self . warn ( n , [string] ) [EOL] imports . append ( ( [string] , None ) ) [EOL] elif n . type == token . NAME : [EOL] imports . append ( ( n . value , None ) ) [EOL] elif n . type == syms . import_as_name : [EOL] import_name , import_nick = n . children [ [number] ] , n . children [ [number] ] [EOL] assert n . children [ [number] ] . type == token . NAME and n . children [ [number] ] . value == [string] [EOL] imports . append ( ( import_name . value , import_nick . value if import_nick else None ) ) [EOL] elif n . type == syms . import_as_names : [EOL] to_process . extend ( n . children ) [EOL] else : [EOL] raise Exception ( f" [string] { repr ( n ) }" ) [EOL] [EOL] imports_by_package = collections . defaultdict ( list ) [EOL] for name , nick in imports : [EOL] full_name = f"{ module_name } [string] { name }" [EOL] try : [EOL] new_full_name = get_new_name ( full_name ) or full_name [EOL] except NameRemovedError as exc : [EOL] self . warn ( node , str ( exc ) ) [EOL] continue [EOL] package , new_name = split_package_and_name ( new_full_name ) [EOL] if name != new_name and nick is None : [EOL] nick = name [EOL] imports_by_package [ package ] . append ( ( new_name , nick ) ) [EOL] [EOL] indent = find_indentation ( node ) [EOL] nodes = [ ] [EOL] for package , imports in sorted ( imports_by_package . items ( ) , key = lambda i : i [ [number] ] ) : [EOL] if package : [EOL] result = FromImport ( package , imports , prefix = f" [string] { indent }" ) [EOL] nodes . append ( result ) [EOL] else : [EOL] for name , nick in imports : [EOL] nodes . append ( Node ( syms . import_name , [ Name ( [string] ) , ImportAsName ( name , nick , prefix = [string] ) ] , prefix = f" [string] { indent }" , ) ) [EOL] [EOL] if not nodes : [EOL] return [EOL] [EOL] nodes [ [number] ] . prefix = node . prefix [EOL] node . replace ( nodes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 $builtins.str$ 0 0 0 $Capture$ 0 0 0 0 0 0 $typing.Any$ 0 $Capture$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 $typing.DefaultDict[builtins.str,typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 $LN$ 0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Any , List [EOL] import typing [EOL] from lib2to3 . fixer_util import Node [EOL] from lib2to3 . fixer_util import syms [EOL] from lib2to3 . fixer_util import token [EOL] from typing import List [EOL] [EOL] from . import get_new_name [EOL] from . import NameRemovedError [EOL] from . . import AttrChain [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import LN [EOL] [EOL] [EOL] class FixModuleUsage ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] full_name = [ ] [EOL] trailer = [ ] [EOL] for i , n in enumerate ( node . children ) : [EOL] if n . type == token . NAME : [EOL] full_name . append ( n . value ) [EOL] elif n . type == syms . trailer : [EOL] if n . children [ [number] ] . type != token . DOT : [EOL] trailer = node . children [ i : ] [EOL] break [EOL] full_name . append ( n . children [ [number] ] . value ) [EOL] else : [EOL] trailer = node . children [ i : ] [EOL] [EOL] try : [EOL] new_name = get_new_name ( [string] . join ( full_name ) ) [EOL] except NameRemovedError as exc : [EOL] self . warn ( node , str ( exc ) ) [EOL] return [EOL] [EOL] if new_name : [EOL] new_node = Node ( syms . power , AttrChain ( new_name ) , prefix = node . prefix ) [EOL] for n in trailer : [EOL] new_node . append_child ( n ) [EOL] node . replace ( new_node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import LN [EOL] [EOL] [EOL] class FixCassExecutionProfiles ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] self . warn ( node , [string] [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Any , List [EOL] import typing [EOL] from lib2to3 . fixer_util import find_indentation [EOL] from lib2to3 . fixer_util import Name [EOL] from lib2to3 . fixer_util import Node [EOL] from lib2to3 . fixer_util import syms [EOL] from lib2to3 . fixer_util import token [EOL] [EOL] from . import get_new_name [EOL] from . import NameRemovedError [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import ImportAsName [EOL] from . . import LN [EOL] from . . import traverse_dotted_name [EOL] [EOL] [EOL] class FixImportName ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] imports = [ ] [EOL] for n in capture [ [string] ] : [EOL] if n . type == token . COMMA : [EOL] pass [EOL] elif n . type == token . NAME : [EOL] imports . append ( ( n . value , None ) ) [EOL] elif n . type == syms . dotted_name : [EOL] imports . append ( ( traverse_dotted_name ( n ) , None ) ) [EOL] elif n . type == syms . dotted_as_name : [EOL] import_name , import_nick = n . children [ [number] ] , n . children [ [number] ] [EOL] assert n . children [ [number] ] . type == token . NAME and n . children [ [number] ] . value == [string] [EOL] imports . append ( ( traverse_dotted_name ( import_name ) , import_nick . value ) ) [EOL] [EOL] rename_seen = False [EOL] nodes = [ ] [EOL] indent = find_indentation ( node ) [EOL] for name , nick in imports : [EOL] try : [EOL] new_name = get_new_name ( name ) [EOL] except NameRemovedError as exc : [EOL] self . warn ( node , str ( exc ) ) [EOL] continue [EOL] [EOL] if new_name : [EOL] rename_seen = True [EOL] name = new_name [EOL] new_node = Node ( syms . import_name , [ Name ( [string] ) , ImportAsName ( name , nick , prefix = [string] ) ] , prefix = f" [string] { indent }" , ) [EOL] nodes . append ( new_node ) [EOL] [EOL] if not nodes : [EOL] return [EOL] [EOL] nodes [ [number] ] . prefix = node . prefix [EOL] [EOL] if rename_seen : [EOL] node . replace ( nodes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $Capture$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $LN$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $LN$ 0 0 0 0 0 $builtins.str$ 0 0 $LN$ 0 0 0 $typing.List[typing.Any]$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from . . import BaseplateBaseFix [EOL] from . . import Capture [EOL] from . . import LN [EOL] [EOL] [EOL] class FixMakeContextObject ( BaseplateBaseFix ) : [EOL] PATTERN = [string] [EOL] [EOL] def transform ( self , node , capture ) : [EOL] self . warn ( node , [string] [string] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $LN$ 0 $Capture$ 0 0 0 0 0 0 0 $LN$ 0 0 0 0 0 0