from typing import Pattern [EOL] import typing [EOL] [docstring] [EOL] import ast [EOL] import re [EOL] [EOL] [EOL] try : [EOL] from setuptools import find_packages , setup [EOL] except ImportError : [EOL] from distutils . core import setup [EOL] [EOL] [EOL] version_regex = re . compile ( [string] ) [EOL] [EOL] [EOL] def get_version ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] return str ( ast . literal_eval ( version_regex . search ( f . read ( ) ) . group ( [number] ) ) ) [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] with open ( [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , version = get_version ( ) , author = [string] , author_email = [string] , url = [string] , license = [string] , description = [string] , long_description = get_long_description ( ) , long_description_content_type = [string] , packages = find_packages ( ) , package_data = { [string] : [ [string] ] } , zip_safe = False , classifiers = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import _importlib_modulespec [EOL] import uuid [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] import types [EOL] import typing [EOL] import uuid [EOL] [EOL] [comment] [EOL] Bool = bool [EOL] [EOL] [comment] [EOL] [comment] [EOL] Buffer = typing . Union [ bytes , bytearray , memoryview ] [comment] [EOL] [EOL] [EOL] [comment] [EOL] Bytes = bytes [comment] [EOL] [EOL] [EOL] [comment] [EOL] Datetime = datetime . datetime [comment] [EOL] [EOL] [EOL] [comment] [EOL] Float = float [comment] [EOL] [EOL] [EOL] [comment] [EOL] Int = int [comment] [EOL] [EOL] [EOL] [comment] [EOL] Module = types . ModuleType [EOL] [EOL] [EOL] [comment] [EOL] Primitive = typing . Union [ int , float , str , bytes , bytearray , memoryview ] [comment] [EOL] [EOL] [EOL] [comment] [EOL] Str = str [comment] [EOL] [EOL] [EOL] [comment] [EOL] UUID = uuid . UUID [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.bool]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Type[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Type[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Type[_importlib_modulespec.ModuleType]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Type[uuid.UUID]$ 0 0 0 $typing.Type[uuid.UUID]$ 0 0
from typing import Any , Dict [EOL] import datetime [EOL] import typing [EOL] import ulid [EOL] [docstring] [EOL] import copy [EOL] import datetime [EOL] import operator [EOL] import pickle [EOL] import time [EOL] import uuid [EOL] [EOL] import pytest [EOL] [EOL] from ulid import base32 , ulid [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ list , dict , set , tuple , type ( None ) ] ) def unsupported_comparison_type ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ ulid . MemoryView , ulid . Timestamp , ulid . Randomness , ulid . ULID ] ) def model_types ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def model_with_eq_bytes ( model_types , valid_bytes_128 , valid_bytes_80 , valid_bytes_48 ) : [EOL] [docstring] [EOL] if model_types in ( ulid . MemoryView , ulid . ULID ) : [EOL] return model_types , valid_bytes_128 [EOL] if model_types == ulid . Randomness : [EOL] return model_types , valid_bytes_80 [EOL] if model_types == ulid . Timestamp : [EOL] return model_types , valid_bytes_48 [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def model_with_ne_bytes ( model_types , valid_bytes_128 , valid_bytes_80 , valid_bytes_48 ) : [EOL] [docstring] [EOL] if model_types in ( ulid . MemoryView , ulid . ULID ) : [EOL] return model_types , valid_bytes_128 , valid_bytes_80 [EOL] if model_types == ulid . Randomness : [EOL] return model_types , valid_bytes_80 , valid_bytes_128 [EOL] if model_types == ulid . Timestamp : [EOL] return model_types , valid_bytes_48 , valid_bytes_128 [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def model_with_ordered_bytes ( model_types , valid_bytes_128_before , valid_bytes_128_after , valid_bytes_80_before , valid_bytes_80_after , valid_bytes_48_before , valid_bytes_48_after ) : [EOL] [docstring] [EOL] if model_types in ( ulid . MemoryView , ulid . ULID ) : [EOL] return model_types , valid_bytes_128_before , valid_bytes_128_after [EOL] if model_types == ulid . Randomness : [EOL] return model_types , valid_bytes_80_before , valid_bytes_80_after [EOL] if model_types == ulid . Timestamp : [EOL] return model_types , valid_bytes_48_before , valid_bytes_48_after [EOL] [EOL] [EOL] def test_model_supports_eq_with_expected_types ( model_with_eq_bytes ) : [EOL] [docstring] [EOL] model_type , equal_bytes = model_with_eq_bytes [EOL] [EOL] model = model_type ( equal_bytes ) [EOL] assert model == model_type ( equal_bytes ) [EOL] assert model == bytes ( equal_bytes ) [EOL] assert model == bytearray ( equal_bytes ) [EOL] assert model == memoryview ( equal_bytes ) [EOL] assert model == int . from_bytes ( equal_bytes , byteorder = [string] ) [EOL] assert model == float ( int . from_bytes ( equal_bytes , byteorder = [string] ) ) [EOL] assert model == base32 . encode ( equal_bytes ) [EOL] [EOL] [EOL] def test_model_supports_ne_with_expected_types ( model_with_ne_bytes ) : [EOL] [docstring] [EOL] model_type , equal_bytes , not_equal_bytes = model_with_ne_bytes [EOL] [EOL] model = model_type ( equal_bytes ) [EOL] assert model != ulid . MemoryView ( not_equal_bytes ) [EOL] assert model != bytes ( not_equal_bytes ) [EOL] assert model != bytearray ( not_equal_bytes ) [EOL] assert model != memoryview ( not_equal_bytes ) [EOL] assert model != int . from_bytes ( not_equal_bytes , byteorder = [string] ) [EOL] assert model != float ( int . from_bytes ( not_equal_bytes , byteorder = [string] ) ) [EOL] assert model != base32 . encode ( not_equal_bytes ) [EOL] [EOL] [EOL] def test_model_supports_lt_with_expected_types ( model_with_ordered_bytes ) : [EOL] [docstring] [EOL] model_type , less_than_bytes , greater_than_bytes = model_with_ordered_bytes [EOL] [EOL] model = model_type ( less_than_bytes ) [EOL] assert model < ulid . MemoryView ( greater_than_bytes ) [EOL] assert model < bytes ( greater_than_bytes ) [EOL] assert model < bytearray ( greater_than_bytes ) [EOL] assert model < memoryview ( greater_than_bytes ) [EOL] assert model < int . from_bytes ( greater_than_bytes , byteorder = [string] ) [EOL] assert model < float ( int . from_bytes ( greater_than_bytes , byteorder = [string] ) ) [EOL] assert model < base32 . encode ( greater_than_bytes ) [EOL] [EOL] [EOL] def test_model_supports_gt_with_expected_types ( model_with_ordered_bytes ) : [EOL] [docstring] [EOL] model_type , less_than_bytes , greater_than_bytes = model_with_ordered_bytes [EOL] [EOL] model = model_type ( greater_than_bytes ) [EOL] assert model > ulid . MemoryView ( less_than_bytes ) [EOL] assert model > bytes ( less_than_bytes ) [EOL] assert model > bytearray ( less_than_bytes ) [EOL] assert model > memoryview ( less_than_bytes ) [EOL] assert model > int . from_bytes ( less_than_bytes , byteorder = [string] ) [EOL] assert model > float ( int . from_bytes ( less_than_bytes , byteorder = [string] ) ) [EOL] assert model > base32 . encode ( less_than_bytes ) [EOL] [EOL] [EOL] def test_model_supports_le_with_expected_types ( model_with_ordered_bytes ) : [EOL] [docstring] [EOL] model_type , less_than_bytes , greater_than_bytes = model_with_ordered_bytes [EOL] [EOL] model = model_type ( less_than_bytes ) [EOL] assert model <= ulid . MemoryView ( less_than_bytes ) [EOL] assert model <= bytes ( less_than_bytes ) [EOL] assert model <= bytearray ( less_than_bytes ) [EOL] assert model <= memoryview ( less_than_bytes ) [EOL] assert model <= int . from_bytes ( less_than_bytes , byteorder = [string] ) [EOL] assert model <= float ( int . from_bytes ( less_than_bytes , byteorder = [string] ) ) [EOL] assert model <= base32 . encode ( less_than_bytes ) [EOL] [EOL] assert model <= ulid . MemoryView ( greater_than_bytes ) [EOL] assert model <= bytes ( greater_than_bytes ) [EOL] assert model <= bytearray ( greater_than_bytes ) [EOL] assert model <= memoryview ( greater_than_bytes ) [EOL] assert model <= int . from_bytes ( greater_than_bytes , byteorder = [string] ) [EOL] assert model <= float ( int . from_bytes ( greater_than_bytes , byteorder = [string] ) ) [EOL] assert model <= base32 . encode ( greater_than_bytes ) [EOL] [EOL] [EOL] def test_model_supports_ge_with_expected_types ( model_with_ordered_bytes ) : [EOL] [docstring] [EOL] model_type , less_than_bytes , greater_than_bytes = model_with_ordered_bytes [EOL] [EOL] model = model_type ( greater_than_bytes ) [EOL] assert model >= ulid . MemoryView ( greater_than_bytes ) [EOL] assert model >= bytes ( greater_than_bytes ) [EOL] assert model >= bytearray ( greater_than_bytes ) [EOL] assert model >= memoryview ( greater_than_bytes ) [EOL] assert model >= int . from_bytes ( greater_than_bytes , byteorder = [string] ) [EOL] assert model >= float ( int . from_bytes ( greater_than_bytes , byteorder = [string] ) ) [EOL] assert model >= base32 . encode ( greater_than_bytes ) [EOL] [EOL] assert model >= ulid . MemoryView ( less_than_bytes ) [EOL] assert model >= bytes ( less_than_bytes ) [EOL] assert model >= bytearray ( less_than_bytes ) [EOL] assert model >= memoryview ( less_than_bytes ) [EOL] assert model >= int . from_bytes ( less_than_bytes , byteorder = [string] ) [EOL] assert model >= float ( int . from_bytes ( less_than_bytes , byteorder = [string] ) ) [EOL] assert model >= base32 . encode ( less_than_bytes ) [EOL] [EOL] [EOL] def test_memoryview_eq_false_with_unsupported_type ( valid_bytes_128 , unsupported_comparison_type ) : [EOL] [docstring] [EOL] assert not ulid . MemoryView ( valid_bytes_128 ) == unsupported_comparison_type ( ) [EOL] [EOL] [EOL] def test_memoryview_ne_false_with_unsupported_type ( valid_bytes_128 , unsupported_comparison_type ) : [EOL] [docstring] [EOL] assert ulid . MemoryView ( valid_bytes_128 ) != unsupported_comparison_type ( ) [EOL] [EOL] [EOL] def test_memoryview_unorderble_with_unsupported_type ( valid_bytes_128 , unsupported_comparison_type ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] for op in ( operator . lt , operator . gt , operator . le , operator . ge ) : [EOL] with pytest . raises ( TypeError ) : [EOL] op ( mv , unsupported_comparison_type ( ) ) [EOL] [EOL] [EOL] def test_memoryview_supports_bin ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert bin ( mv ) == mv . bin [EOL] [EOL] [EOL] def test_memoryview_supports_hex ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert hex ( mv ) == mv . hex [EOL] [EOL] [EOL] def test_memoryview_supports_oct ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert oct ( mv ) == mv . oct [EOL] [EOL] [EOL] def test_memoryview_supports_bytes ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert bytes ( mv ) == mv . bytes [EOL] [EOL] [EOL] def test_memoryview_supports_str ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert str ( mv ) == mv . str [EOL] [EOL] [EOL] def test_memoryview_supports_int ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert int ( mv ) == mv . int [EOL] [EOL] [EOL] def test_memoryview_supports_float ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert float ( mv ) == mv . float [EOL] [EOL] [EOL] def test_memoryview_supports_hash ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert hash ( mv ) == hash ( mv . memory ) [EOL] [EOL] [EOL] def test_memoryview_supports_index ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert mv . __index__ ( ) == mv . int [EOL] [EOL] [EOL] def test_memoryview_supports_getstate ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] assert mv . __getstate__ ( ) == mv . str [EOL] [EOL] [EOL] def test_memoryview_supports_pickle ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] serialized = pickle . dumps ( mv ) [EOL] assert serialized is not None [EOL] assert isinstance ( serialized , bytes ) [EOL] deserialized = pickle . loads ( serialized ) [EOL] assert deserialized == mv . str [EOL] [EOL] [EOL] def test_memoryview_supports_copy ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] copied = copy . copy ( mv ) [EOL] assert copied == mv [EOL] [EOL] [EOL] def test_memoryview_supports_deepcopy ( valid_bytes_128 ) : [EOL] [docstring] [EOL] mv = ulid . MemoryView ( valid_bytes_128 ) [EOL] data = dict ( a = dict ( b = dict ( c = mv ) ) ) [EOL] copied = copy . deepcopy ( data ) [EOL] assert copied == data [EOL] [EOL] [EOL] def test_timestamp_coverts_bytes_to_unix_time_seconds ( ) : [EOL] [docstring] [EOL] now_ms = int ( time . time ( ) ) * [number] [EOL] timestamp = ulid . Timestamp ( now_ms . to_bytes ( [number] , byteorder = [string] ) ) [EOL] assert timestamp . timestamp == now_ms / [number] [EOL] [EOL] [EOL] def test_timestamp_converts_to_utc_aware_datetime ( ) : [EOL] [docstring] [EOL] now_ms = int ( time . time ( ) ) * [number] [EOL] timezone = datetime . timezone . utc [EOL] timestamp = ulid . Timestamp ( now_ms . to_bytes ( [number] , byteorder = [string] ) ) [EOL] assert timestamp . datetime == datetime . datetime . utcfromtimestamp ( now_ms / [number] ) . replace ( tzinfo = timezone ) [EOL] [EOL] [EOL] def test_ulid_timestamp_returns_instance ( valid_bytes_128 ) : [EOL] [docstring] [EOL] assert isinstance ( ulid . ULID ( valid_bytes_128 ) . timestamp ( ) , ulid . Timestamp ) [EOL] [EOL] [EOL] def test_ulid_timestamp_is_first_48_bits ( valid_bytes_128 ) : [EOL] [docstring] [EOL] timestamp = ulid . ULID ( valid_bytes_128 ) . timestamp ( ) [EOL] assert timestamp . bytes == valid_bytes_128 [ : [number] ] [EOL] [EOL] [EOL] def test_ulid_randomness_returns_instance ( valid_bytes_128 ) : [EOL] [docstring] [EOL] assert isinstance ( ulid . ULID ( valid_bytes_128 ) . randomness ( ) , ulid . Randomness ) [EOL] [EOL] [EOL] def test_ulid_randomness_is_first_48_bits ( valid_bytes_128 ) : [EOL] [docstring] [EOL] randomness = ulid . ULID ( valid_bytes_128 ) . randomness ( ) [EOL] assert randomness . bytes == valid_bytes_128 [ [number] : ] [EOL] [EOL] [EOL] def test_ulid_uuid_returns_instance ( valid_bytes_128 ) : [EOL] [docstring] [EOL] assert isinstance ( ulid . ULID ( valid_bytes_128 ) . uuid , uuid . UUID ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import uuid [EOL] import datetime [EOL] import typing [EOL] import ulid [EOL] [docstring] [EOL] import datetime [EOL] import time [EOL] import uuid [EOL] [EOL] import pytest [EOL] [EOL] from ulid import base32 , consts , ulid [EOL] from ulid . api import default , monotonic [EOL] from ulid . api . api import ALL [EOL] [EOL] BYTES_SIZE_EXC_REGEX = [string] [EOL] INT_SIZE_EXC_REGEX = [string] [EOL] INT_NEGATIVE_EXC_REGEX = [string] [EOL] STR_SIZE_EXC_REGEX = [string] [EOL] UNSUPPORTED_TIMESTAMP_TYPE_EXC_REGEX = ( [string] [string] ) [EOL] TIMESTAMP_SIZE_EXC_REGEX = [string] [EOL] UNSUPPORTED_RANDOMNESS_TYPE_EXC_REGEX = [string] [EOL] RANDOMNESS_SIZE_EXC_REGEX = [string] [EOL] [EOL] PARSE_STR_LEN_EXC_REGEX = [string] [EOL] PARSE_UNSUPPORTED_TYPE_REGEX = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ default , monotonic ] ) def api ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ list , dict , set , tuple , type ( None ) ] ) def unsupported_type ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ bytes , bytearray , memoryview ] ) def buffer_type ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] def test_package_has_dunder_all ( api ) : [EOL] [docstring] [EOL] assert hasattr ( api , [string] ) [EOL] assert isinstance ( api . __all__ , list ) [EOL] [EOL] [EOL] def test_package_exposes_expected_interface ( api ) : [EOL] [docstring] [EOL] assert api . __all__ == ALL [EOL] [EOL] [EOL] def test_min_timestamp_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MIN_TIMESTAMP [EOL] assert value == consts . MIN_TIMESTAMP [EOL] [EOL] [EOL] def test_max_timestamp_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MAX_TIMESTAMP [EOL] assert value == consts . MAX_TIMESTAMP [EOL] [EOL] [EOL] def test_min_randomness_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MIN_RANDOMNESS [EOL] assert value == consts . MIN_RANDOMNESS [EOL] [EOL] [EOL] def test_max_randomness_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MAX_RANDOMNESS [EOL] assert value == consts . MAX_RANDOMNESS [EOL] [EOL] [EOL] def test_min_ulid_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MIN_ULID [EOL] assert value == consts . MIN_ULID [EOL] [EOL] [EOL] def test_max_ulid_uses_expected_value ( api ) : [EOL] [docstring] [EOL] value = api . MAX_ULID [EOL] assert value == consts . MAX_ULID [EOL] [EOL] [EOL] def test_new_returns_ulid_instance ( api ) : [EOL] [docstring] [EOL] assert isinstance ( api . new ( ) , ulid . ULID ) [EOL] [EOL] [EOL] def test_parse_returns_given_ulid_instance ( api ) : [EOL] [docstring] [EOL] value = api . new ( ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance == value [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_uuid ( api ) : [EOL] [docstring] [EOL] value = uuid . uuid4 ( ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == value . bytes [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_uuid_str ( api ) : [EOL] [docstring] [EOL] value = uuid . uuid4 ( ) [EOL] instance = api . parse ( str ( value ) ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == value . bytes [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_uuid_hex_str ( api ) : [EOL] [docstring] [EOL] value = uuid . uuid4 ( ) [EOL] instance = api . parse ( value . hex ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == value . bytes [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_ulid_str ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = base32 . encode ( valid_bytes_128 ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_randomness_str ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = base32 . encode_randomness ( valid_bytes_80 ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . str == value [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_timestamp_str ( api , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = base32 . encode_timestamp ( valid_bytes_48 ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) . str == value [EOL] [EOL] [EOL] def test_parse_error_on_invalid_length_str ( api , invalid_str_10_16_26_32_36 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( invalid_str_10_16_26_32_36 ) [EOL] assert ex . match ( PARSE_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_int ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = int . from_bytes ( valid_bytes_128 , byteorder = [string] ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_parse_raises_when_int_greater_than_128_bits ( api , invalid_bytes_128_overflow ) : [EOL] [docstring] [EOL] value = int . from_bytes ( invalid_bytes_128_overflow , byteorder = [string] ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( value ) [EOL] assert ex . match ( INT_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_raises_when_int_negative ( api ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( - [number] ) [EOL] assert ex . match ( INT_NEGATIVE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_float ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = float ( int . from_bytes ( valid_bytes_128 , byteorder = [string] ) ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . int == int ( value ) [EOL] [EOL] [EOL] def test_parse_raises_when_float_greater_than_128_bits ( api , invalid_bytes_128_overflow ) : [EOL] [docstring] [EOL] value = float ( int . from_bytes ( invalid_bytes_128_overflow , byteorder = [string] ) ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( value ) [EOL] assert ex . match ( INT_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_raises_when_float_negative ( api ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( float ( - [number] ) ) [EOL] assert ex . match ( INT_NEGATIVE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_returns_ulid_instance_from_buffer_type ( api , buffer_type , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_128 ) [EOL] instance = api . parse ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_parse_raises_when_buffer_type_not_128_bits ( api , buffer_type , invalid_bytes_128 ) : [EOL] [docstring] [EOL] value = buffer_type ( invalid_bytes_128 ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( value ) [EOL] assert ex . match ( BYTES_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_parse_raises_when_given_unsupported_type ( api , unsupported_type ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . parse ( unsupported_type ) [EOL] assert ex . match ( PARSE_UNSUPPORTED_TYPE_REGEX ) [EOL] [EOL] [EOL] def test_create_timestamp_datetime_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = datetime . datetime . now ( ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == int ( value . timestamp ( ) ) [EOL] [EOL] [EOL] def test_create_timestamp_int_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = int ( time . time ( ) ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == value [EOL] [EOL] [EOL] def test_create_timestamp_float_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = float ( time . time ( ) ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == int ( value ) [EOL] [EOL] [EOL] def test_create_timestamp_str_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = base32 . encode_timestamp ( valid_bytes_48 ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) . str == value [EOL] [EOL] [EOL] def test_create_timestamp_bytes_returns_ulid_instance ( api , buffer_type , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_48 ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) . bytes == value [EOL] [EOL] [EOL] def test_create_timestamp_timestamp_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = ulid . Timestamp ( valid_bytes_48 ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) == value [EOL] [EOL] [EOL] def test_create_timestamp_ulid_returns_ulid_instance ( api , valid_bytes_128 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = api . create ( value , valid_bytes_80 ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) == value . timestamp ( ) [EOL] [EOL] [EOL] def test_create_raises_when_given_unsupported_timestamp_type ( api , unsupported_type , valid_bytes_80 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . create ( unsupported_type , valid_bytes_80 ) [EOL] assert ex . match ( UNSUPPORTED_TIMESTAMP_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_create_randomness_int_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = int . from_bytes ( valid_bytes_80 , byteorder = [string] ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . int == value [EOL] [EOL] [EOL] def test_create_randomness_float_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = float ( int . from_bytes ( valid_bytes_80 , byteorder = [string] ) ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . int == int ( value ) [EOL] [EOL] [EOL] def test_create_randomness_str_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [EOL] [docstring] [EOL] value = base32 . encode_randomness ( valid_bytes_80 ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . str == value [EOL] [EOL] [EOL] def test_create_randomness_bytes_returns_ulid_instance ( api , buffer_type , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_80 ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . bytes == value [EOL] [EOL] [EOL] def test_create_randomness_randomness_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = ulid . Randomness ( valid_bytes_80 ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) == value [EOL] [EOL] [EOL] def test_create_randomness_ulid_returns_ulid_instance ( api , valid_bytes_48 , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = api . create ( valid_bytes_48 , value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) == value . randomness ( ) [EOL] [EOL] [EOL] def test_create_raises_when_given_unsupported_randomness_type ( api , unsupported_type , valid_bytes_48 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . create ( valid_bytes_48 , unsupported_type ) [EOL] assert ex . match ( UNSUPPORTED_RANDOMNESS_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_bytes_returns_ulid_instance ( api , buffer_type , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_128 ) [EOL] instance = api . from_bytes ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_from_bytes_raises_when_not_128_bits ( api , buffer_type , invalid_bytes_128 ) : [EOL] [docstring] [EOL] value = buffer_type ( invalid_bytes_128 ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_bytes ( value ) [EOL] assert ex . match ( BYTES_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_int_returns_ulid_instance ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = int . from_bytes ( valid_bytes_128 , byteorder = [string] ) [EOL] instance = api . from_int ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_from_int_raises_when_greater_than_128_bits ( api , invalid_bytes_128_overflow ) : [EOL] [docstring] [EOL] value = int . from_bytes ( invalid_bytes_128_overflow , byteorder = [string] ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_int ( value ) [EOL] assert ex . match ( INT_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_int_raises_when_negative_number ( api ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_int ( - [number] ) [EOL] assert ex . match ( INT_NEGATIVE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_str_returns_ulid_instance ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = base32 . encode ( valid_bytes_128 ) [EOL] instance = api . from_str ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == valid_bytes_128 [EOL] [EOL] [EOL] def test_from_str_raises_when_not_128_bits ( api , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = base32 . encode ( valid_bytes_48 ) [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_str ( value ) [EOL] assert ex . match ( STR_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_uuid_returns_ulid_instance ( api ) : [EOL] [docstring] [EOL] value = uuid . uuid4 ( ) [EOL] instance = api . from_uuid ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . bytes == value . bytes [EOL] [EOL] [EOL] def test_from_timestamp_datetime_returns_ulid_instance ( api ) : [EOL] [docstring] [EOL] value = datetime . datetime . now ( ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == int ( value . timestamp ( ) ) [EOL] [EOL] [EOL] def test_from_timestamp_int_returns_ulid_instance ( api ) : [EOL] [docstring] [EOL] value = int ( time . time ( ) ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == value [EOL] [EOL] [EOL] def test_from_timestamp_float_returns_ulid_instance ( api ) : [EOL] [docstring] [EOL] value = float ( time . time ( ) ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert int ( instance . timestamp ( ) . timestamp ) == int ( value ) [EOL] [EOL] [EOL] def test_from_timestamp_str_returns_ulid_instance ( api , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = base32 . encode_timestamp ( valid_bytes_48 ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) . str == value [EOL] [EOL] [EOL] def test_from_timestamp_bytes_returns_ulid_instance ( api , buffer_type , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_48 ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) . bytes == value [EOL] [EOL] [EOL] def test_from_timestamp_timestamp_returns_ulid_instance ( api , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = ulid . Timestamp ( valid_bytes_48 ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) == value [EOL] [EOL] [EOL] def test_from_timestamp_ulid_returns_ulid_instance ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = api . from_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . timestamp ( ) == value . timestamp ( ) [EOL] [EOL] [EOL] def test_from_timestamp_with_unsupported_type_raises ( api , unsupported_type ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_timestamp ( unsupported_type ( ) ) [EOL] assert ex . match ( UNSUPPORTED_TIMESTAMP_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_timestamp_with_incorrect_size_bytes_raises ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_timestamp ( valid_bytes_128 ) [EOL] assert ex . match ( TIMESTAMP_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_randomness_int_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = int . from_bytes ( valid_bytes_80 , byteorder = [string] ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . int == value [EOL] [EOL] [EOL] def test_from_randomness_float_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = float ( int . from_bytes ( valid_bytes_80 , byteorder = [string] ) ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . int == int ( value ) [EOL] [EOL] [EOL] def test_from_randomness_str_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [EOL] [docstring] [EOL] value = base32 . encode_randomness ( valid_bytes_80 ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . str == value [EOL] [EOL] [EOL] def test_from_randomness_bytes_returns_ulid_instance ( api , buffer_type , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_80 ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) . bytes == value [EOL] [EOL] [EOL] def test_from_randomness_randomness_returns_ulid_instance ( api , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = ulid . Randomness ( valid_bytes_80 ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) == value [EOL] [EOL] [EOL] def test_from_randomness_ulid_returns_ulid_instance ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = api . from_randomness ( value ) [EOL] assert isinstance ( instance , ulid . ULID ) [EOL] assert instance . randomness ( ) == value . randomness ( ) [EOL] [EOL] [EOL] def test_from_randomness_with_unsupported_type_raises ( api , unsupported_type ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_randomness ( unsupported_type ( ) ) [EOL] assert ex . match ( UNSUPPORTED_RANDOMNESS_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_from_randomness_with_incorrect_size_bytes_raises ( api , valid_bytes_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] api . from_randomness ( valid_bytes_128 ) [EOL] assert ex . match ( RANDOMNESS_SIZE_EXC_REGEX ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[docstring] [EOL] import pytest [EOL] [EOL] import ulid as mod [EOL] from ulid import api , ulid [EOL] [EOL] [EOL] def test_module_has_dunder_version ( ) : [EOL] [docstring] [EOL] assert hasattr ( mod , [string] ) [EOL] assert isinstance ( mod . __version__ , str ) [EOL] [EOL] [EOL] def test_module_has_dunder_all ( ) : [EOL] [docstring] [EOL] assert hasattr ( mod , [string] ) [EOL] assert isinstance ( mod . __all__ , list ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ api , ulid ] ) def test_module_has_submodule_interface ( submodule ) : [EOL] [docstring] [EOL] assert hasattr ( submodule , [string] ) [EOL] for i in submodule . __all__ : [EOL] assert hasattr ( mod , i ) [EOL] [EOL] [EOL] def test_module_exposes_api_interfaces_via_all ( ) : [EOL] [docstring] [EOL] assert mod . __all__ == api . __all__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] from ulid . providers import base , default [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def provider ( ) : [EOL] [docstring] [EOL] return default . Provider ( ) [EOL] [EOL] [EOL] def test_provider_derives_from_base ( ) : [EOL] [docstring] [EOL] assert issubclass ( default . Provider , base . Provider ) [EOL] [EOL] [EOL] def test_provider_new_returns_bytes_pair ( provider ) : [EOL] [docstring] [EOL] value = provider . new ( ) [EOL] assert isinstance ( value , tuple ) [EOL] assert len ( value ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] [EOL] [EOL] def test_provider_timestamp_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . timestamp ( ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL] [EOL] [EOL] def test_provider_timestamp_uses_time_epoch ( provider ) : [EOL] [docstring] [EOL] timestamp_bytes = provider . timestamp ( ) [EOL] timestamp_int = int . from_bytes ( timestamp_bytes , byteorder = [string] ) [EOL] assert timestamp_int // [number] < time . time ( ) [EOL] [EOL] [EOL] def test_provider_randomness_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . randomness ( provider . timestamp ( ) ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL] [EOL] [EOL] def test_provider_randomness_returns_random_values_for_same_timestamp ( provider ) : [EOL] [docstring] [EOL] timestamp = provider . timestamp ( ) [EOL] x = provider . randomness ( timestamp ) [EOL] y = provider . randomness ( timestamp ) [EOL] [EOL] assert x != y [EOL] [EOL] x_int = int . from_bytes ( x , byteorder = [string] ) [EOL] y_int = int . from_bytes ( y , byteorder = [string] ) [EOL] [EOL] assert x_int + [number] != y_int [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import inspect [EOL] [EOL] from ulid . providers . time import base [EOL] [EOL] [EOL] def test_provider_is_abstract ( ) : [EOL] [docstring] [EOL] assert inspect . isabstract ( base . Provider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import pytest [EOL] [EOL] from ulid import base32 [EOL] [EOL] NON_BASE_32_EXC_REGEX = [string] [EOL] NON_ASCII_EXC_REGEX = [string] [EOL] ENCODE_BYTE_SIZE_EXC_REGEX = [string] [EOL] ENCODE_ULID_BYTE_SIZE_EXC_REGEX = [string] [EOL] ENCODE_TIMESTAMP_BYTE_SIZE_EXC_REGEX = [string] [EOL] ENCODE_RANDOMNESS_BYTE_SIZE_EXC_REGEX = [string] [EOL] DECODE_STR_LEN_EXC_REGEX = [string] [EOL] DECODE_ULID_STR_LEN_EXC_REGEX = [string] [EOL] DECODE_TIMESTAMP_STR_LEN_EXC_REGEX = [string] [EOL] DECODE_RANDOMNESS_STR_LEN_EXC_REGEX = [string] [EOL] TIMESTAMP_OVERFLOW_EXC_REGEX = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def decoding_alphabet ( ) : [EOL] [docstring] [EOL] return base32 . ENCODING + [string] [EOL] [EOL] [EOL] def test_encode_handles_ulid_and_returns_26_char_string ( valid_bytes_128 ) : [EOL] [docstring] [EOL] encoded = base32 . encode ( valid_bytes_128 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_handles_timestamp_and_returns_10_char_string ( valid_bytes_48 ) : [EOL] [docstring] [EOL] encoded = base32 . encode ( valid_bytes_48 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_handles_randomness_and_returns_16_char_string ( valid_bytes_80 ) : [EOL] [docstring] [EOL] encoded = base32 . encode ( valid_bytes_80 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_raises_on_bytes_length_mismatch ( invalid_bytes_48_80_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . encode ( invalid_bytes_48_80_128 ) [EOL] assert ex . match ( ENCODE_BYTE_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_encode_ulid_returns_26_char_string ( valid_bytes_128 ) : [EOL] [docstring] [EOL] encoded = base32 . encode_ulid ( valid_bytes_128 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_ulid_raises_on_bytes_length_mismatch ( invalid_bytes_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . encode_ulid ( invalid_bytes_128 ) [EOL] assert ex . match ( ENCODE_ULID_BYTE_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_encode_timestamp_returns_10_char_string ( valid_bytes_48 ) : [EOL] [docstring] [EOL] encoded = base32 . encode_timestamp ( valid_bytes_48 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_timestamp_raises_on_bytes_length_mismatch ( invalid_bytes_48 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . encode_timestamp ( invalid_bytes_48 ) [EOL] assert ex . match ( ENCODE_TIMESTAMP_BYTE_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_encode_randomness_returns_16_char_string ( valid_bytes_80 ) : [EOL] [docstring] [EOL] encoded = base32 . encode_randomness ( valid_bytes_80 ) [EOL] assert isinstance ( encoded , str ) [EOL] assert len ( encoded ) == [number] [EOL] [EOL] [EOL] def test_encode_randomness_raises_on_bytes_length_mismatch ( invalid_bytes_80 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . encode_randomness ( invalid_bytes_80 ) [EOL] assert ex . match ( ENCODE_RANDOMNESS_BYTE_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_handles_ulid_and_returns_16_bytes ( valid_str_26 ) : [EOL] [docstring] [EOL] decoded = base32 . decode ( valid_str_26 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_handles_timestamp_and_returns_6_bytes ( valid_str_10 ) : [EOL] [docstring] [EOL] decoded = base32 . decode ( valid_str_10 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_handles_randomness_and_returns_10_bytes ( valid_str_16 ) : [EOL] [docstring] [EOL] decoded = base32 . decode ( valid_str_16 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_raises_on_str_length_mismatch ( invalid_str_10_16_26 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode ( invalid_str_10_16_26 ) [EOL] assert ex . match ( DECODE_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_raises_on_extended_ascii_str ( extended_ascii_str_valid_length ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode ( extended_ascii_str_valid_length ) [EOL] assert ex . match ( NON_ASCII_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_raises_on_non_base32_decode_char ( ascii_non_base32_str_valid_length ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode ( ascii_non_base32_str_valid_length ) [EOL] ex . match ( NON_BASE_32_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_ulid_returns_16_bytes ( valid_str_26 ) : [EOL] [docstring] [EOL] decoded = base32 . decode_ulid ( valid_str_26 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_ulid_raises_on_str_length_mismatch ( invalid_str_26 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_ulid ( invalid_str_26 ) [EOL] assert ex . match ( DECODE_ULID_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_ulid_raises_on_non_ascii_str ( extended_ascii_str_26 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_ulid ( extended_ascii_str_26 ) [EOL] assert ex . match ( NON_ASCII_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_ulid_raises_on_non_base32_decode_char ( ascii_non_base32_str_26 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_ulid ( ascii_non_base32_str_26 ) [EOL] ex . match ( NON_BASE_32_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_timestamp_returns_6_bytes ( valid_str_10 ) : [EOL] [docstring] [EOL] decoded = base32 . decode_timestamp ( valid_str_10 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_timestamp_raises_on_str_length_mismatch ( invalid_str_10 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_timestamp ( invalid_str_10 ) [EOL] assert ex . match ( DECODE_TIMESTAMP_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_timestamp_raises_on_non_ascii_str ( extended_ascii_str_10 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_timestamp ( extended_ascii_str_10 ) [EOL] assert ex . match ( NON_ASCII_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_timestamp_raises_on_non_base32_decode_char ( ascii_non_base32_str_10 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_timestamp ( ascii_non_base32_str_10 ) [EOL] ex . match ( NON_BASE_32_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_randomness_returns_10_bytes ( valid_str_16 ) : [EOL] [docstring] [EOL] decoded = base32 . decode_randomness ( valid_str_16 ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == [number] [EOL] [EOL] [EOL] def test_decode_randomness_raises_on_str_length_mismatch ( invalid_str_16 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_randomness ( invalid_str_16 ) [EOL] assert ex . match ( DECODE_RANDOMNESS_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_randomness_raises_on_non_ascii_str ( extended_ascii_str_16 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_randomness ( extended_ascii_str_16 ) [EOL] assert ex . match ( NON_ASCII_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_randomness_raises_on_non_base32_decode_char ( ascii_non_base32_str_16 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . decode_randomness ( ascii_non_base32_str_16 ) [EOL] ex . match ( NON_BASE_32_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_table_has_value_for_entire_decoding_alphabet ( decoding_alphabet ) : [EOL] [docstring] [EOL] for char in decoding_alphabet : [EOL] assert base32 . DECODING [ ord ( char ) ] != [number] , [string] . format ( char ) [EOL] [EOL] [EOL] def test_str_to_bytes_returns_expected_bytes ( valid_str_valid_length ) : [EOL] [docstring] [EOL] decoded = base32 . str_to_bytes ( valid_str_valid_length , len ( valid_str_valid_length ) ) [EOL] assert isinstance ( decoded , bytes ) [EOL] assert len ( decoded ) == len ( valid_str_valid_length ) [EOL] [EOL] [EOL] def test_str_to_bytes_raises_on_unexpected_length ( invalid_str_26 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . str_to_bytes ( invalid_str_26 , [number] ) [EOL] assert ex . match ( DECODE_ULID_STR_LEN_EXC_REGEX ) [EOL] [EOL] [EOL] def test_str_to_bytes_raises_on_extended_ascii_str ( extended_ascii_str_valid_length ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . str_to_bytes ( extended_ascii_str_valid_length , len ( extended_ascii_str_valid_length ) ) [EOL] assert ex . match ( NON_ASCII_EXC_REGEX ) [EOL] [EOL] [EOL] def test_str_to_bytes_raises_on_non_base32_decode_char ( ascii_non_base32_str_valid_length ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . str_to_bytes ( ascii_non_base32_str_valid_length , len ( ascii_non_base32_str_valid_length ) ) [EOL] ex . match ( NON_BASE_32_EXC_REGEX ) [EOL] [EOL] [EOL] def test_str_to_bytes_raises_on_timestamp_msb_overflow ( invalid_str_10_msb_invalid ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] base32 . str_to_bytes ( invalid_str_10_msb_invalid , len ( invalid_str_10_msb_invalid ) ) [EOL] ex . match ( TIMESTAMP_OVERFLOW_EXC_REGEX ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from ulid . providers import base , default , microsecond , time [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def provider ( ) : [EOL] [docstring] [EOL] return microsecond . Provider ( default . Provider ( ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_epoch_milliseconds ( ) : [EOL] [docstring] [EOL] return time . PROVIDER . milliseconds ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_epoch_microseconds ( ) : [EOL] [docstring] [EOL] return time . PROVIDER . microseconds ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def mock_time_provider ( mocker , valid_epoch_milliseconds , valid_epoch_microseconds ) : [EOL] [docstring] [EOL] provider = mocker . Mock ( spec = time . Provider ) [EOL] provider . milliseconds = mocker . Mock ( return_value = valid_epoch_milliseconds ) [EOL] provider . microseconds = mocker . Mock ( return_value = valid_epoch_microseconds ) [EOL] return provider [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def provider_time_mock ( mocker , mock_time_provider ) : [EOL] [docstring] [EOL] mocker . patch . object ( microsecond . time , [string] , side_effect = mock_time_provider . milliseconds ) [EOL] mocker . patch . object ( microsecond . time , [string] , side_effect = mock_time_provider . microseconds ) [EOL] return microsecond . Provider ( default . Provider ( ) ) [EOL] [EOL] [EOL] def test_provider_derives_from_base ( ) : [EOL] [docstring] [EOL] assert issubclass ( microsecond . Provider , base . Provider ) [EOL] [EOL] [EOL] def test_provider_new_returns_bytes_pair ( provider ) : [EOL] [docstring] [EOL] value = provider . new ( ) [EOL] assert isinstance ( value , tuple ) [EOL] assert len ( value ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] [EOL] [EOL] def test_provider_new_returns_randomness_with_microseconds ( provider_time_mock ) : [EOL] [docstring] [EOL] epoch_us = time . microseconds ( ) [EOL] epoch_ms = epoch_us // [number] [EOL] microseconds = epoch_us % epoch_ms [EOL] microseconds_bits = microseconds << [number] [EOL] [EOL] _ , randomness = provider_time_mock . new ( ) [EOL] [EOL] prefix = int . from_bytes ( randomness [ : [number] ] , byteorder = [string] ) [EOL] microsecond_prefix_bits = ( prefix >> [number] ) << [number] [EOL] [EOL] assert microsecond_prefix_bits == microseconds_bits [EOL] [EOL] [EOL] def test_provider_timestamp_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . timestamp ( ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL] [EOL] [EOL] def test_provider_timestamp_uses_time_epoch ( provider ) : [EOL] [docstring] [EOL] timestamp_bytes = provider . timestamp ( ) [EOL] timestamp_int = int . from_bytes ( timestamp_bytes , byteorder = [string] ) [EOL] assert timestamp_int <= time . milliseconds ( ) [EOL] [EOL] [EOL] def test_provider_randomness_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . randomness ( provider . timestamp ( ) ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import datetime [EOL] import typing [EOL] import ulid [EOL] [docstring] [EOL] import datetime [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] from ulid import base32 , codec , ulid [EOL] [EOL] UNSUPPORTED_TIMESTAMP_TYPE_EXC_REGEX = ( [string] [string] ) [EOL] TIMESTAMP_SIZE_EXC_REGEX = [string] [EOL] UNSUPPORTED_RANDOMNESS_TYPE_EXC_REGEX = [string] [EOL] RANDOMNESS_SIZE_EXC_REGEX = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ list , dict , set , tuple , type ( None ) ] ) def unsupported_type ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ bytes , bytearray , memoryview ] ) def buffer_type ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] def test_decode_timestamp_datetime_returns_timestamp_instance ( ) : [EOL] [docstring] [EOL] value = datetime . datetime . now ( ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert int ( instance . timestamp ) == int ( value . timestamp ( ) ) [EOL] [EOL] [EOL] def test_decode_timestamp_int_returns_timestamp_instance ( ) : [EOL] [docstring] [EOL] value = int ( time . time ( ) ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert int ( instance . timestamp ) == value [EOL] [EOL] [EOL] def test_decode_timestamp_float_returns_timestamp_instance ( ) : [EOL] [docstring] [EOL] value = float ( time . time ( ) ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert int ( instance . timestamp ) == int ( value ) [EOL] [EOL] [EOL] def test_decode_timestamp_str_returns_timestamp_instance ( valid_bytes_48 ) : [EOL] [docstring] [EOL] value = base32 . encode_timestamp ( valid_bytes_48 ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert instance . str == value [EOL] [EOL] [EOL] def test_decode_timestamp_bytes_returns_timestamp_instance ( buffer_type , valid_bytes_48 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_48 ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert instance . bytes == value [EOL] [EOL] [EOL] def test_decode_timestamp_timestamp_returns_timestamp_instance ( valid_bytes_48 ) : [EOL] [docstring] [EOL] value = ulid . Timestamp ( valid_bytes_48 ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert instance == value [EOL] [EOL] [EOL] def test_decode_timestamp_ulid_returns_timestamp_instance ( valid_bytes_128 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = codec . decode_timestamp ( value ) [EOL] assert isinstance ( instance , ulid . Timestamp ) [EOL] assert instance == value . timestamp ( ) [EOL] [EOL] [EOL] def test_decode_timestamp_with_unsupported_type_raises ( unsupported_type ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] codec . decode_timestamp ( unsupported_type ( ) ) [EOL] assert ex . match ( UNSUPPORTED_TIMESTAMP_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_timestamp_with_incorrect_size_bytes_raises ( valid_bytes_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] codec . decode_timestamp ( valid_bytes_128 ) [EOL] assert ex . match ( TIMESTAMP_SIZE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_randomness_int_returns_randomness_instance ( valid_bytes_80 ) : [EOL] [docstring] [EOL] value = int . from_bytes ( valid_bytes_80 , byteorder = [string] ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance . int == value [EOL] [EOL] [EOL] def test_decode_randomness_float_returns_randomness_instance ( valid_bytes_80 ) : [EOL] [docstring] [EOL] value = float ( int . from_bytes ( valid_bytes_80 , byteorder = [string] ) ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance . int == int ( value ) [EOL] [EOL] [EOL] def test_decode_randomness_str_returns_randomness_instance ( valid_bytes_80 ) : [EOL] [EOL] [docstring] [EOL] value = base32 . encode_randomness ( valid_bytes_80 ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance . str == value [EOL] [EOL] [EOL] def test_decode_randomness_bytes_returns_randomness_instance ( buffer_type , valid_bytes_80 ) : [EOL] [docstring] [EOL] value = buffer_type ( valid_bytes_80 ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance . bytes == value [EOL] [EOL] [EOL] def test_decode_randomness_randomness_returns_randomness_instance ( valid_bytes_80 ) : [EOL] [docstring] [EOL] value = ulid . Randomness ( valid_bytes_80 ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance == value [EOL] [EOL] [EOL] def test_decode_randomness_ulid_returns_randomness_instance ( valid_bytes_128 ) : [EOL] [docstring] [EOL] value = ulid . ULID ( valid_bytes_128 ) [EOL] instance = codec . decode_randomness ( value ) [EOL] assert isinstance ( instance , ulid . Randomness ) [EOL] assert instance == value . randomness ( ) [EOL] [EOL] [EOL] def test_decode_randomness_with_unsupported_type_raises ( unsupported_type ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] codec . decode_randomness ( unsupported_type ( ) ) [EOL] assert ex . match ( UNSUPPORTED_RANDOMNESS_TYPE_EXC_REGEX ) [EOL] [EOL] [EOL] def test_decode_randomness_with_incorrect_size_bytes_raises ( valid_bytes_128 ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) as ex : [EOL] codec . decode_randomness ( valid_bytes_128 ) [EOL] assert ex . match ( RANDOMNESS_SIZE_EXC_REGEX ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[docstring] [EOL] from ulid import providers [EOL] from ulid . providers import default , monotonic [EOL] [EOL] [EOL] def test_package_has_dunder_all ( ) : [EOL] [docstring] [EOL] assert hasattr ( providers , [string] ) [EOL] assert isinstance ( providers . __all__ , list ) [EOL] [EOL] [EOL] def test_package_exposes_expected_interface ( ) : [EOL] [docstring] [EOL] assert providers . __all__ == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_package_has_default_provider ( ) : [EOL] [docstring] [EOL] assert isinstance ( providers . DEFAULT , default . Provider ) [EOL] [EOL] [EOL] def test_package_has_monotonic_provider ( ) : [EOL] [docstring] [EOL] assert isinstance ( providers . MONOTONIC , monotonic . Provider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from ulid . api import default [EOL] from ulid . api . api import ALL [EOL] [EOL] [EOL] def test_module_has_dunder_all ( ) : [EOL] [docstring] [EOL] assert hasattr ( default , [string] ) [EOL] assert isinstance ( default . __all__ , list ) [EOL] [EOL] [EOL] def test_module_exposes_expected_interface ( ) : [EOL] [docstring] [EOL] assert default . __all__ == ALL [EOL] [EOL] [EOL] def test_module_api_uses_correct_provider ( ) : [EOL] [docstring] [EOL] assert isinstance ( default . API . provider , type ( default . providers . DEFAULT ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import sys [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] from ulid . providers . time import base , nanosecond [EOL] [EOL] pytestmark = pytest . mark . skipif ( sys . version_info < ( [number] , [number] ) , reason = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def provider ( ) : [EOL] [docstring] [EOL] return nanosecond . Provider ( ) [EOL] [EOL] [EOL] def test_provider_derives_from_base ( ) : [EOL] [docstring] [EOL] assert issubclass ( nanosecond . Provider , base . Provider ) [EOL] [EOL] [EOL] def test_provider_milliseconds_returns_int ( provider ) : [EOL] [docstring] [EOL] value = provider . milliseconds ( ) [EOL] assert isinstance ( value , int ) [EOL] [EOL] [EOL] def test_provider_microseconds_returns_int ( provider ) : [EOL] [docstring] [EOL] value = provider . microseconds ( ) [EOL] assert isinstance ( value , int ) [EOL] [EOL] [EOL] def test_provider_milliseconds_is_unix_epoch ( provider ) : [EOL] [docstring] [EOL] x = int ( time . time ( ) * [number] ) [EOL] time . sleep ( [number] ) [EOL] y = provider . milliseconds ( ) [EOL] time . sleep ( [number] ) [EOL] z = int ( time . time ( ) * [number] ) [EOL] [EOL] assert x <= y <= z [EOL] [EOL] [EOL] def test_provider_microseconds_is_unix_epoch ( provider ) : [EOL] [docstring] [EOL] x = int ( time . time ( ) * [number] * [number] ) [EOL] time . sleep ( [number] ) [EOL] y = provider . microseconds ( ) [EOL] time . sleep ( [number] ) [EOL] z = int ( time . time ( ) * [number] * [number] ) [EOL] [EOL] assert x <= y <= z [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import copy [EOL] import datetime [EOL] [EOL] import pytest [EOL] [EOL] from ulid import api [EOL] [EOL] [EOL] def test_github_issue_58 ( ) : [EOL] [docstring] [EOL] value = [string] [EOL] instance = api . from_str ( value ) [EOL] assert instance . str == [string] [EOL] [EOL] [EOL] def test_github_issue_61 ( ) : [EOL] [docstring] [EOL] for s in ( [string] , [string] ) : [EOL] with pytest . raises ( ValueError ) : [EOL] api . from_str ( s ) [EOL] [EOL] [EOL] def test_github_issue_452 ( ) : [EOL] [docstring] [EOL] result = copy . deepcopy ( api . new ( ) ) [EOL] assert result is not None [EOL] [EOL] [EOL] def test_github_issue_463 ( ) : [EOL] [docstring] [EOL] instance = api . new ( ) [EOL] assert instance . timestamp ( ) . datetime . tzinfo == datetime . timezone . utc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import calendar [EOL] import datetime [EOL] import os [EOL] import random [EOL] [EOL] import pytest [EOL] [EOL] from ulid import base32 [EOL] [EOL] ASCII_ALPHABET = [string] . join ( chr ( d ) for d in range ( [number] , [number] ) ) [EOL] EXTENDED_ASCII_ALPHABET = [string] . join ( chr ( d ) for d in range ( [number] , [number] ) ) [EOL] ASCII_NON_BASE_32_ALPHABET = [string] . join ( set ( ASCII_ALPHABET ) . difference ( set ( base32 . ENCODING ) ) ) [EOL] MSB_ASCII_ALPHABET = [string] . join ( chr ( d ) for d in range ( [number] , [number] ) ) [EOL] MSB_ASCII_INVALID_ALPHABET = [string] . join ( set ( base32 . ENCODING ) . difference ( set ( MSB_ASCII_ALPHABET ) ) ) [EOL] [EOL] MIN_EPOCH = [number] [EOL] MAX_EPOCH = [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_48_before ( ) : [EOL] [docstring] [EOL] return fixed_year_timestamp_bytes ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_48_after ( ) : [EOL] [docstring] [EOL] return fixed_year_timestamp_bytes ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_80_before ( valid_bytes_48_before ) : [EOL] [docstring] [EOL] return valid_bytes_48_before + [string] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_80_after ( valid_bytes_48_after ) : [EOL] [docstring] [EOL] return valid_bytes_48_after + [string] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_128_before ( valid_bytes_48_before ) : [EOL] [docstring] [EOL] return valid_bytes_48_before + [string] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_128_after ( valid_bytes_48_after ) : [EOL] [docstring] [EOL] return valid_bytes_48_after + [string] * [number] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_128 ( ) : [EOL] [docstring] [EOL] return random_timestamp_bytes ( ) + random_bytes ( [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_80 ( ) : [EOL] [docstring] [EOL] return random_bytes ( [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_bytes_48 ( ) : [EOL] [docstring] [EOL] return random_timestamp_bytes ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_bytes_128_overflow ( request ) : [EOL] [docstring] [EOL] return random_non_zero_byte ( ) + random_bytes ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_bytes_128 ( request ) : [EOL] [docstring] [EOL] return random_bytes ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_bytes_80 ( request ) : [EOL] [docstring] [EOL] return random_bytes ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_bytes_48 ( request ) : [EOL] [docstring] [EOL] return random_bytes ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_bytes_48_80_128 ( request ) : [EOL] [docstring] [EOL] return random_bytes ( request . param , not_in = [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ [number] , [number] , [number] ] ) def valid_str_valid_length ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_str_26 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_str_10 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def valid_str_16 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_str_26 ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_str_16 ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_str_10 ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , not_in = [ [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def invalid_str_10_msb_invalid ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , msb_alphabet = MSB_ASCII_INVALID_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_str_10_16_26 ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , not_in = [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = range ( [number] , [number] ) ) def invalid_str_10_16_26_32_36 ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , not_in = [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ [number] , [number] , [number] ] ) def ascii_non_base32_str_valid_length ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , alphabet = ASCII_NON_BASE_32_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def ascii_non_base32_str_26 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = ASCII_NON_BASE_32_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def ascii_non_base32_str_10 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = ASCII_NON_BASE_32_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def ascii_non_base32_str_16 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = ASCII_NON_BASE_32_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , params = [ [number] , [number] , [number] ] ) def extended_ascii_str_valid_length ( request ) : [EOL] [docstring] [EOL] return random_str ( request . param , alphabet = EXTENDED_ASCII_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def extended_ascii_str_26 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = EXTENDED_ASCII_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def extended_ascii_str_10 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = EXTENDED_ASCII_ALPHABET ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def extended_ascii_str_16 ( ) : [EOL] [docstring] [EOL] return random_str ( [number] , alphabet = EXTENDED_ASCII_ALPHABET ) [EOL] [EOL] [EOL] def random_timestamp_bytes ( ) : [EOL] [docstring] [EOL] value = random . randint ( MIN_EPOCH , MAX_EPOCH - [number] ) [EOL] return value . to_bytes ( [number] , byteorder = [string] ) [EOL] [EOL] [EOL] def random_non_zero_byte ( ) : [EOL] [docstring] [EOL] value = random . randint ( [number] , [number] ) [EOL] return value . to_bytes ( [number] , byteorder = [string] ) [EOL] [EOL] [EOL] def random_bytes ( num_bytes , not_in = ( - [number] , ) ) : [EOL] [docstring] [EOL] num_bytes = num_bytes + [number] if num_bytes in not_in else num_bytes [EOL] return os . urandom ( num_bytes ) [EOL] [EOL] [EOL] def random_str ( num_chars , alphabet = base32 . ENCODING , msb_alphabet = MSB_ASCII_ALPHABET , not_in = ( - [number] , ) ) : [EOL] [docstring] [EOL] num_chars = num_chars + [number] if num_chars in not_in else num_chars [EOL] return random . choice ( msb_alphabet ) + [string] . join ( random . choice ( alphabet ) for _ in range ( num_chars - [number] ) ) [EOL] [EOL] [EOL] def fixed_year_timestamp_bytes ( * args , ** kwargs ) : [EOL] [docstring] [EOL] timestamp = int ( calendar . timegm ( datetime . datetime ( * args , ** kwargs ) . timetuple ( ) ) ) * [number] [EOL] return timestamp . to_bytes ( [number] , byteorder = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] [EOL] import pytest [EOL] [EOL] from ulid . providers import base , default , monotonic [EOL] [EOL] RANDOMNESS_OVERFLOW_REGEX = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def provider ( ) : [EOL] [docstring] [EOL] return monotonic . Provider ( default . Provider ( ) ) [EOL] [EOL] [EOL] def test_provider_derives_from_base ( ) : [EOL] [docstring] [EOL] assert issubclass ( monotonic . Provider , base . Provider ) [EOL] [EOL] [EOL] def test_provider_new_returns_bytes_pair ( provider ) : [EOL] [docstring] [EOL] value = provider . new ( ) [EOL] assert isinstance ( value , tuple ) [EOL] assert len ( value ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] assert len ( value [ [number] ] ) == [number] [EOL] [EOL] [EOL] def test_provider_timestamp_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . timestamp ( ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL] [EOL] [EOL] def test_provider_timestamp_uses_time_epoch ( provider ) : [EOL] [docstring] [EOL] timestamp_bytes = provider . timestamp ( ) [EOL] timestamp_int = int . from_bytes ( timestamp_bytes , byteorder = [string] ) [EOL] assert timestamp_int // [number] < time . time ( ) [EOL] [EOL] [EOL] def test_provider_randomness_returns_bytes ( provider ) : [EOL] [docstring] [EOL] value = provider . randomness ( provider . timestamp ( ) ) [EOL] assert isinstance ( value , bytes ) [EOL] assert len ( value ) == [number] [EOL] [EOL] [EOL] def test_provider_randomness_returns_increasing_values_for_same_timestamp ( provider ) : [EOL] [docstring] [EOL] timestamp = provider . timestamp ( ) [EOL] x = provider . randomness ( timestamp ) [EOL] y = provider . randomness ( timestamp ) [EOL] [EOL] assert x != y [EOL] [EOL] x_int = int . from_bytes ( x , byteorder = [string] ) [EOL] y_int = int . from_bytes ( y , byteorder = [string] ) [EOL] [EOL] assert x_int + [number] == y_int [EOL] [EOL] [EOL] def test_provider_randomness_raises_on_max_randomness ( provider ) : [EOL] [docstring] [EOL] timestamp = provider . timestamp ( ) [EOL] [EOL] with pytest . raises ( ValueError , match = RANDOMNESS_OVERFLOW_REGEX ) : [EOL] provider . randomness ( timestamp ) [EOL] provider . prev_randomness = monotonic . consts . MAX_RANDOMNESS [EOL] provider . randomness ( timestamp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from ulid import providers [EOL] from ulid . api . api import ALL , Api [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def mock_provider ( mocker ) : [EOL] [docstring] [EOL] provider = mocker . Mock ( spec = providers . Provider ) [EOL] provider . new = mocker . Mock ( side_effect = providers . DEFAULT . new ) [EOL] provider . timestamp = mocker . Mock ( side_effect = providers . DEFAULT . timestamp ) [EOL] provider . randomness = mocker . Mock ( side_effect = providers . DEFAULT . randomness ) [EOL] return provider [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def mock_api ( mock_provider ) : [EOL] [docstring] [EOL] return Api ( mock_provider ) [EOL] [EOL] [EOL] def test_all_defined_expected_methods ( ) : [EOL] [docstring] [EOL] assert ALL == [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_api_new_calls_provider_new ( mock_api ) : [EOL] [docstring] [EOL] mock_api . new ( ) [EOL] [EOL] mock_api . provider . new . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_api_from_timestamp_calls_provider_randomness ( mocker , mock_api , valid_bytes_48 ) : [EOL] [docstring] [EOL] mock_api . from_timestamp ( valid_bytes_48 ) [EOL] [EOL] mock_api . provider . timestamp . assert_not_called ( ) [EOL] mock_api . provider . randomness . assert_called_once_with ( mocker . ANY ) [EOL] [EOL] [EOL] def test_api_from_randomness_calls_provider_timestamp ( mock_api , valid_bytes_80 ) : [EOL] [docstring] [EOL] mock_api . from_randomness ( valid_bytes_80 ) [EOL] [EOL] mock_api . provider . timestamp . assert_called_once_with ( ) [EOL] mock_api . provider . randomness . assert_not_called ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import inspect [EOL] [EOL] from ulid . providers import base [EOL] [EOL] [EOL] def test_provider_is_abstract ( ) : [EOL] [docstring] [EOL] assert inspect . isabstract ( base . Provider ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from ulid . api import monotonic [EOL] from ulid . api . api import ALL [EOL] [EOL] [EOL] def test_module_has_dunder_all ( ) : [EOL] [docstring] [EOL] assert hasattr ( monotonic , [string] ) [EOL] assert isinstance ( monotonic . __all__ , list ) [EOL] [EOL] [EOL] def test_module_exposes_expected_interface ( ) : [EOL] [docstring] [EOL] assert monotonic . __all__ == ALL [EOL] [EOL] [EOL] def test_module_api_uses_correct_provider ( ) : [EOL] [docstring] [EOL] assert isinstance ( monotonic . API . provider , type ( monotonic . providers . MONOTONIC ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import uuid [EOL] [EOL] import ulid [EOL] [EOL] [EOL] def test_ulid_new ( benchmark ) : [EOL] [docstring] [EOL] benchmark ( ulid . new ) [EOL] [EOL] [EOL] def test_uuid_v1_new ( benchmark ) : [EOL] [docstring] [EOL] benchmark ( uuid . uuid1 ) [EOL] [EOL] [EOL] def test_uuid_v4_new ( benchmark ) : [EOL] [docstring] [EOL] benchmark ( uuid . uuid4 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict , Tuple [EOL] import typing [EOL] [docstring] [EOL] import datetime [EOL] import os [EOL] import sys [EOL] [EOL] import sphinx_rtd_theme [EOL] [EOL] from sphinx . ext . autodoc import ModuleLevelDocumenter , DataDocumenter [EOL] [EOL] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] source_suffix = [string] [EOL] [EOL] [comment] [EOL] master_doc = [string] [EOL] [EOL] [comment] [EOL] project = [string] [EOL] copyright = [string] . format ( datetime . datetime . now ( ) . year ) [EOL] author = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] version = [string] [EOL] [comment] [EOL] release = version [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] language = None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] pygments_style = [string] [EOL] [EOL] [comment] [EOL] autoclass_content = [string] [EOL] autodoc_member_order = [string] [EOL] [EOL] [comment] [EOL] todo_include_todos = True [EOL] [EOL] html_show_sphinx = False [EOL] html_use_modindex = False [EOL] html_show_sourcelink = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] html_theme_path = [ sphinx_rtd_theme . get_html_theme_path ( ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] htmlhelp_basename = [string] . format ( project ) [EOL] [EOL] latex_elements = { } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] latex_documents = [ ( master_doc , [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] man_pages = [ ( master_doc , [string] , [string] , [ author ] , [number] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] texinfo_documents = [ ( master_doc , [string] , [string] , author , [string] , [string] , [string] ) , ] [EOL] [EOL] [comment] [EOL] intersphinx_mapping = { [string] : None } [EOL] [EOL] [comment] [EOL] epub_title = project [EOL] epub_author = author [EOL] epub_publisher = author [EOL] epub_copyright = copyright [EOL] [EOL] [comment] [EOL] epub_exclude_files = [ [string] ] [EOL] [EOL] [comment] [EOL] DataDocumenter . add_directive_header = lambda s , sig : ModuleLevelDocumenter . add_directive_header ( s , sig ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,typing.List[builtins.str],builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0