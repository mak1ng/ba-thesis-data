from typing import Type , Optional , List , Iterable [EOL] import typing [EOL] import src [EOL] import json [EOL] import math [EOL] import functools [EOL] from typing import Tuple , List , Iterable , Optional , NamedTuple [EOL] [EOL] [EOL] Power = float [EOL] Reach = float [EOL] Distance = float [EOL] [EOL] [EOL] class Point ( NamedTuple ) : [EOL] x = ... [EOL] y = ... [EOL] [EOL] [EOL] class Device ( NamedTuple ) : [EOL] point = ... [EOL] [EOL] [EOL] class Station ( NamedTuple ) : [EOL] point = ... [EOL] reach = ... [EOL] [EOL] [EOL] class StationPower ( NamedTuple ) : [EOL] station = ... [EOL] power = [number] [EOL] [EOL] [EOL] Stations = List [ Station ] [EOL] [EOL] [EOL] def find_most_suitable_station ( stations , device ) : [EOL] def compare ( best_so_far , candidate ) : [EOL] return candidate if candidate . power > best_so_far . power \ [EOL] else best_so_far [EOL] [EOL] station = functools . reduce ( compare , enrich_stations_with_power ( stations , device ) , StationPower ( Station ( Point ( [number] , [number] ) , [number] ) ) ) [EOL] return station if station . power > [number] else None [EOL] [EOL] [EOL] def enrich_stations_with_power ( stations , device ) : [EOL] return map ( lambda station : StationPower ( station , station_power_to_device ( station . reach , distance_to_station ( station . point , device . point ) ) ) , stations ) [EOL] [EOL] [EOL] def station_power_to_device ( reach , distance ) : [EOL] return [number] if distance > reach else ( reach - distance ) ** [number] [EOL] [EOL] [EOL] def distance_to_station ( station , device ) : [EOL] return math . hypot ( station . x - device . x , station . y - device . y ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $Point$ 0 0 0 0 0 0 0 0 0 0 0 0 $Point$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $Station$ 0 0 0 $Power$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[StationPower]$ 0 0 0 0 0 0 0 0 $StationPower$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[StationPower]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Power$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Distance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import core [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from typing import List [EOL] [EOL] import click [EOL] [EOL] from core import Station , Point , Device , find_most_suitable_station [EOL] [EOL] [EOL] def stations_from_json ( stations ) : [EOL] return [ Station ( Point ( station [ [number] ] , station [ [number] ] ) , station [ [number] ] ) for station in json . loads ( stations ) ] [EOL] [EOL] [EOL] def device_from_json ( point ) : [EOL] return Device ( Point ( * json . loads ( point ) ) ) [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , help = [string] , required = True ) @ click . option ( [string] , help = [string] , required = True ) def main ( json_stations , json_point ) : [EOL] stations , device = stations_from_json ( json_stations ) , device_from_json ( json_point ) [EOL] station_power = find_most_suitable_station ( stations , device ) [EOL] if station_power is None : [EOL] click . echo ( [string] % ( device . point . x , device . point . y ) ) [EOL] else : [EOL] click . echo ( [string] % ( device . point . x , device . point . y , station_power . station . point . x , station_power . station . point . y , station_power . power ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[core.Station]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $core.Device$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from main import stations_from_json , device_from_json [EOL] from core import Station , Point , Device [EOL] [EOL] [EOL] def test_stations_from_json ( ) : [EOL] assert stations_from_json ( [string] ) == [ Station ( Point ( [number] , [number] ) , [number] ) ] [EOL] [EOL] [EOL] def test_point_from_json ( ) : [EOL] assert device_from_json ( [string] ) == Device ( Point ( [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from core import Point , Station , StationPower , Device , find_most_suitable_station , distance_to_station , station_power_to_device , enrich_stations_with_power [EOL] [EOL] [EOL] def test_find_most_suitable_station ( ) : [EOL] stations = [ Station ( Point ( [number] , [number] ) , [number] ) , Station ( Point ( [number] , [number] ) , [number] ) , Station ( Point ( [number] , [number] ) , [number] ) ] [EOL] assert find_most_suitable_station ( stations , Device ( Point ( [number] , [number] ) ) ) == StationPower ( Station ( Point ( [number] , [number] ) , [number] ) , [number] ) [EOL] [EOL] assert find_most_suitable_station ( stations , Device ( Point ( [number] , [number] ) ) ) is None [EOL] [EOL] station , power = find_most_suitable_station ( stations , Device ( Point ( [number] , [number] ) ) ) [EOL] assert station . point == Point ( x = [number] , y = [number] ) [EOL] assert station . reach == [number] [EOL] assert round ( power , [number] ) == [number] [EOL] [EOL] station , power = find_most_suitable_station ( stations , Device ( Point ( [number] , [number] ) ) ) [EOL] assert station . point == Point ( x = [number] , y = [number] ) [EOL] assert station . reach == [number] [EOL] assert round ( power , [number] ) == [number] [EOL] [EOL] [EOL] def test_distance_to_station ( ) : [EOL] assert distance_to_station ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) == [number] [EOL] assert distance_to_station ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) == [number] [EOL] assert distance_to_station ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) == [number] [EOL] [EOL] [EOL] def test_station_power_to_device ( ) : [EOL] assert station_power_to_device ( [number] , [number] ) == [number] [EOL] assert station_power_to_device ( [number] , [number] ) == [number] [EOL] assert station_power_to_device ( [number] , [number] ) == [number] [EOL] [EOL] [EOL] def test_enrich_stations_with_power ( ) : [EOL] stations = [ Station ( Point ( [number] , [number] ) , [number] ) ] [EOL] device = Device ( Point ( [number] , [number] ) ) [EOL] assert list ( enrich_stations_with_power ( stations , device ) ) == [ StationPower ( Station ( Point ( [number] , [number] ) , [number] ) , [number] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0