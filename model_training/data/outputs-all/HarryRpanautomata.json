[comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import sys [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] file_path , dep_name = sys . argv [ [number] : ] [EOL] with open ( file_path , [string] ) as handle : [EOL] data = json . load ( handle ) [EOL] version = data [ [string] ] [ dep_name ] [EOL] print ( version [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] import json [EOL] import sys [EOL] [EOL] if __name__ == [string] : [EOL] if len ( sys . argv ) < [number] : [EOL] print ( [string] % ( sys . argv [ [number] ] , ) ) [EOL] sys . exit ( [number] ) [EOL] with open ( sys . argv [ [number] ] , [string] ) as handle : [EOL] data = json . load ( handle ) [EOL] print ( json . dumps ( data [ [string] ] ) ) [EOL] sys . exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from setuptools import setup , find_packages [EOL] from pip . req import parse_requirements [EOL] from pip . download import PipSession [EOL] [EOL] requirements = parse_requirements ( [string] , session = PipSession ( ) ) [EOL] [EOL] setup ( name = [string] , version = [string] , packages = find_packages ( ) , py_modules = [ [string] ] , python_requires = [string] , install_requires = [ str ( ir . req ) for ir in requirements ] , entry_points = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Any [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] [EOL] __all__ = ( [string] , ) [EOL] [EOL] [EOL] from urllib . parse import quote_plus [EOL] import requests [EOL] [EOL] [EOL] class RestClient ( object ) : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , url , api = None ) : [EOL] assert url is not None [EOL] self . _url = url [EOL] self . _session = None [EOL] if api is None : [EOL] self . _session = requests . Session ( ) [EOL] self . _api = self if api is None else api [EOL] assert isinstance ( self . _api , RestClient ) [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] if name [ [number] ] == [string] : [EOL] raise AttributeError [EOL] return RestClient ( self . _url + [string] + name , self . _api ) [EOL] [EOL] def __call__ ( self , name = None ) : [EOL] if name is None : [EOL] return self [EOL] if name [ [number] ] == [string] : [EOL] raise AttributeError [EOL] return RestClient ( self . _url + [string] + quote_plus ( name ) , self . _api ) [EOL] [EOL] def _request ( self , method , params = None , data = None ) : [EOL] sess = self . _api . _session [EOL] req = requests . Request ( method = method , url = self . _url , params = params , data = data ) [EOL] resp = sess . send ( req . prepare ( ) ) [EOL] try : [EOL] data = resp . json ( ) [EOL] error = data . get ( [string] ) [EOL] if error : [EOL] raise RuntimeError ( error ) [EOL] return data [EOL] except ValueError : [EOL] resp . raise_for_status ( ) [EOL] [EOL] def GET ( self , ** kwargs ) : [EOL] return self . _request ( [string] , params = kwargs ) [EOL] [EOL] def POST ( self , ** kwargs ) : [EOL] return self . _request ( [string] , data = kwargs ) [EOL] [EOL] def PUT ( self , ** kwargs ) : [EOL] return self . _request ( [string] , data = kwargs ) [EOL] [EOL] def DELETE ( self , ** kwargs ) : [EOL] return self . _request ( [string] , data = kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $requests.models.Request$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Tuple [EOL] import click [EOL] import typing [EOL] from enum import IntEnum [EOL] [EOL] import click [EOL] [EOL] [EOL] class SwapState ( IntEnum ) : [EOL] Invalid = [number] [EOL] AlicePropose = [number] [EOL] AliceCancel = [number] [EOL] AliceWithdraw = [number] [EOL] AliceRefund = [number] [EOL] BobAccept = [number] [EOL] BobReject = [number] [EOL] BobWithdraw = [number] [EOL] [EOL] [EOL] class SwapSide ( object ) : [EOL] __slots__ = ( [string] , [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , contract , token , address , amount ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert isinstance ( amount , int ) [EOL] self . contract = contract [comment] [EOL] self . token = token [comment] [EOL] self . address = address [comment] [EOL] self . amount = amount [comment] [EOL] [EOL] [EOL] class Swap ( object ) : [EOL] __slots__ = ( [string] , [string] , [string] ) [EOL] [EOL] def __init__ ( self , state , alice_side , bob_side ) : [EOL] assert isinstance ( state , SwapState ) [EOL] assert isinstance ( alice_side , SwapSide ) [EOL] assert isinstance ( bob_side , SwapSide ) [EOL] self . state = state [EOL] self . alice_side = alice_side [EOL] self . bob_side = bob_side [EOL] [EOL] [EOL] class SwapProposal ( object ) : [EOL] __slots__ = ( [string] , [string] ) [EOL] [EOL] def __init__ ( self , swap , proof ) : [EOL] self . swap = swap [EOL] self . proof = proof [EOL] [EOL] def cancel ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] def wait ( self ) : [EOL] [comment] [EOL] [comment] [EOL] return SwapConfirmed ( self . swap . alice_side ) [EOL] [EOL] def accept ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return SwapConfirmed ( self . swap . bob_side ) [EOL] [EOL] def reject ( self ) : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] class SwapConfirmed ( object ) : [EOL] __slots__ = ( [string] , ) [EOL] [EOL] def __init__ ( self , side ) : [EOL] assert isinstance ( side , SwapSide ) [EOL] self . side = side [EOL] [EOL] def withdraw ( self ) : [EOL] return True [EOL] [EOL] [EOL] class SwapManager ( object ) : [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def propose ( self , alice_side , bob_side ) : [EOL] assert isinstance ( alice_side , SwapSide ) [EOL] assert isinstance ( bob_side , SwapSide ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] swap = None [EOL] proposal = None [EOL] return SwapProposal ( swap , proposal ) [EOL] [EOL] [EOL] @ click . command ( help = [string] ) def alice_propose ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( help = [string] ) def alice_cancel ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( ) def alice_refund ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( ) def alice_withdraw ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( ) def bob_accept ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( ) def bob_reject ( ) : [EOL] pass [EOL] [EOL] [EOL] @ click . command ( ) def bob_withdraw ( ) : [EOL] pass [EOL] [EOL] [EOL] COMMANDS = click . Group ( [string] , help = [string] ) [EOL] COMMANDS . add_command ( alice_propose ) [EOL] COMMANDS . add_command ( alice_cancel ) [EOL] COMMANDS . add_command ( alice_refund ) [EOL] COMMANDS . add_command ( alice_withdraw ) [EOL] COMMANDS . add_command ( bob_accept ) [EOL] COMMANDS . add_command ( bob_reject ) [EOL] COMMANDS . add_command ( bob_withdraw ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] COMMANDS . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from panautomata . merkle import hashs , merkle_hash , merkle_tree , merkle_path , merkle_proof [EOL] from panautomata . utils import bit_set [EOL] [EOL] [EOL] class MerkleTest ( unittest . TestCase ) : [EOL] def test_merkle ( self ) : [EOL] [comment] [EOL] for i in range ( [number] , [number] ) : [EOL] items = list ( range ( [number] , i ) ) [EOL] tree , root = merkle_tree ( items ) [EOL] [EOL] [comment] [EOL] for item in items : [EOL] proof = merkle_path ( item , tree ) [EOL] self . assertEqual ( merkle_proof ( item , proof , root ) , True ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( ( [number] << [number] ) , [number] ) [EOL] self . assertEqual ( bit_set ( [number] , [number] ) , [number] ) [EOL] self . assertEqual ( root , [number] ) [EOL] self . assertEqual ( item , [number] ) [EOL] self . assertEqual ( hashs ( item ) , [number] ) [EOL] self . assertEqual ( merkle_hash ( item ) , [number] ) [EOL] self . assertEqual ( proof , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from binascii import unhexlify , hexlify [EOL] [EOL] from panautomata . utils import bytes_to_int [EOL] from panautomata . merkle import merkle_tree [EOL] from panautomata . lithium . common import verify_proof , process_block , proof_for_tx , process_transaction [EOL] [EOL] from fakerpc import FakeRPC [EOL] [EOL] [EOL] FAKERPC_INSTANCE = FakeRPC ( [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [ ] } ] , [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ] , [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [ ] , [string] : [string] , [string] : [string] } ] ) [EOL] [EOL] [EOL] class TestLithiumCommon ( unittest . TestCase ) : [EOL] def test_block ( self ) : [EOL] block , tx_count , log_count = process_block ( FAKERPC_INSTANCE , [number] ) [EOL] self . assertEqual ( block . items [ [number] ] , unhexlify ( [string] ) ) [EOL] self . assertEqual ( tx_count , [number] ) [EOL] self . assertEqual ( log_count , [number] ) [EOL] [EOL] def test_proof_tx ( self ) : [EOL] block , block_tx_count , block_log_count = process_block ( FAKERPC_INSTANCE , [number] ) [EOL] self . assertEqual ( block . hash , bytes_to_int ( unhexlify ( [string] ) ) ) [EOL] [EOL] tx_hash = [string] [EOL] leaf = process_transaction ( FAKERPC_INSTANCE , tx_hash ) [EOL] self . assertEqual ( leaf , unhexlify ( [string] ) ) [EOL] [EOL] self . assertEqual ( block . root , [number] ) [EOL] [EOL] proof = proof_for_tx ( FAKERPC_INSTANCE , tx_hash ) [EOL] self . assertEqual ( len ( proof ) , [number] ) [EOL] self . assertEqual ( proof , unhexlify ( [string] ) ) [EOL] [EOL] self . assertEqual ( verify_proof ( block . root , leaf , proof ) , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0
[EOL] class FakeRPC ( object ) : [EOL] def __init__ ( self , in_blocks , in_transactions , in_receipts ) : [EOL] self . _blocks_by_height = { int ( _ [ [string] ] , [number] ) : _ for _ in in_blocks } [EOL] [comment] [EOL] self . _transactions = { _ [ [string] ] : _ for _ in in_transactions } [EOL] self . _receipts = { _ [ [string] ] : _ for _ in in_receipts } [EOL] [EOL] def eth_getTransactionByHash ( self , tx_hash ) : [EOL] return self . _transactions [ tx_hash ] [EOL] [EOL] def eth_getTransactionReceipt ( self , tx_hash ) : [EOL] return self . _receipts [ tx_hash ] [EOL] [EOL] def eth_getBlockByNumber ( self , block_height , tx_objects = True ) : [EOL] assert tx_objects is False [comment] [EOL] return self . _blocks_by_height [ block_height ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0