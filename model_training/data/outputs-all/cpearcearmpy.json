from typing import Any [EOL] import typing [EOL] import index [EOL] from index import InvertedIndex [EOL] from item import item_id [EOL] [EOL] [EOL] def test_InvertedIndex ( ) : [EOL] data = ( [string] [string] [string] [string] [string] [string] ) [EOL] index = InvertedIndex ( ) [EOL] index . load ( data ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] assert ( index . support ( { item_id ( [string] ) } ) == [number] / [number] ) [EOL] [EOL] sup_zx = index . support ( { item_id ( [string] ) , item_id ( [string] ) } ) [EOL] assert ( sup_zx == [number] / [number] ) [EOL] [EOL] sup_zxy = index . support ( { item_id ( [string] ) , item_id ( [string] ) , item_id ( [string] ) } ) [EOL] assert ( sup_zxy == [number] / [number] ) [EOL] [EOL] sup_zxyi = index . support ( { item_id ( [string] ) , item_id ( [string] ) , item_id ( [string] ) , item_id ( [string] ) } ) [EOL] assert ( sup_zxyi == [number] / [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from item import item_id [EOL] [EOL] class DatasetReader : [EOL] def __init__ ( self , csv_file_path ) : [EOL] self . csv_file_path = csv_file_path [EOL] [EOL] def __iter__ ( self ) : [EOL] [EOL] def tokenize ( line ) : [EOL] return map ( lambda x : x . strip ( ) , line . split ( [string] ) ) [EOL] [EOL] def itemize ( tokens ) : [EOL] return map ( item_id , tokens ) [EOL] [EOL] return map ( set , map ( itemize , map ( tokenize , open ( self . csv_file_path ) ) ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import argparse [EOL] import datasetreader [EOL] import sys [EOL] import time [EOL] from argparse import ArgumentParser [EOL] from argparse import ArgumentTypeError [EOL] from fptree import mine_fp_tree [EOL] from generaterules import generate_rules [EOL] from index import InvertedIndex [EOL] from item import item_str [EOL] from datasetreader import DatasetReader [EOL] [EOL] [EOL] def set_to_string ( s ) : [EOL] ss = [string] [EOL] for x in sorted ( map ( item_str , s ) ) : [EOL] if ss != [string] : [EOL] ss += [string] [EOL] ss += str ( x ) [EOL] return ss [EOL] [EOL] [EOL] def float_between_0_and_1 ( string ) : [EOL] value = float ( string ) [EOL] if value < [number] or value > [number] : [EOL] msg = [string] % string [EOL] raise ArgumentTypeError ( msg ) [EOL] return value [EOL] [EOL] [EOL] def float_gteq_1 ( string ) : [EOL] value = float ( string ) [EOL] if value < [number] : [EOL] msg = [string] % string [EOL] raise ArgumentTypeError ( msg ) [EOL] return value [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , required = True ) [EOL] parser . add_argument ( [string] , dest = [string] , required = True ) [EOL] parser . add_argument ( [string] , dest = [string] , type = float_between_0_and_1 , required = True ) [EOL] parser . add_argument ( [string] , dest = [string] , type = float_between_0_and_1 , required = True ) [EOL] parser . add_argument ( [string] , dest = [string] , type = float_gteq_1 , required = True ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] program_start = time . time ( ) [EOL] start = program_start [EOL] print ( [string] ) [EOL] print ( [string] . format ( args . input ) ) [EOL] print ( [string] . format ( args . output ) ) [EOL] print ( [string] . format ( args . min_confidence ) ) [EOL] print ( [string] . format ( args . min_support ) ) [EOL] print ( [string] . format ( args . min_lift ) ) [EOL] [EOL] print ( [string] , flush = True ) [EOL] reader = DatasetReader ( args . input ) [EOL] ( itemsets , itemset_counts , num_transactions ) = mine_fp_tree ( reader , args . min_support ) [EOL] duration = time . time ( ) - start [EOL] print ( [string] . format ( len ( itemsets ) , duration ) , flush = True ) [EOL] [EOL] start = time . time ( ) [EOL] rules = generate_rules ( itemsets , itemset_counts , num_transactions , args . min_confidence , args . min_lift ) [EOL] duration = time . time ( ) - start [EOL] print ( [string] . format ( len ( rules ) , duration ) , flush = True ) [EOL] [EOL] start = time . time ( ) [EOL] with open ( args . output , [string] ) as f : [EOL] f . write ( [string] ) [EOL] for ( antecedent , consequent , confidence , lift , support ) in rules : [EOL] f . write ( [string] . format ( set_to_string ( antecedent ) , set_to_string ( consequent ) , confidence , lift , support ) ) [EOL] print ( [string] . format ( duration ) , flush = True ) [EOL] [EOL] duration = time . time ( ) - program_start [EOL] print ( [string] . format ( duration ) ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from mypy import api [EOL] [EOL] [EOL] def test_types ( ) : [EOL] files_to_type_check = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] result = api . run ( files_to_type_check ) [EOL] [EOL] if result [ [number] ] : [EOL] print ( [string] ) [EOL] print ( result [ [number] ] ) [comment] [EOL] [EOL] if result [ [number] ] : [EOL] print ( [string] ) [EOL] print ( result [ [number] ] ) [comment] [EOL] [EOL] print ( [string] , result [ [number] ] ) [EOL] assert ( result [ [number] ] == [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , FrozenSet [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] from typing import Dict , FrozenSet , List [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] itemNameToId = { } [EOL] itemIdToName = { } [EOL] [EOL] [EOL] def item_id ( name ) : [EOL] if not isinstance ( name , str ) : [EOL] raise TypeError ( [string] ) [EOL] if name not in itemNameToId : [EOL] itemId = len ( itemNameToId ) + [number] [EOL] itemNameToId [ name ] = itemId [EOL] itemIdToName [ itemId ] = name [EOL] return itemId [EOL] else : [EOL] return itemNameToId [ name ] [EOL] [EOL] def item_str ( id ) : [EOL] return itemIdToName [ id ] [EOL] [EOL] def ItemSet ( lst ) : [EOL] return frozenset ( map ( item_id , lst ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 $typing.FrozenSet[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator [EOL] import typing [EOL] import _csv [EOL] import csv [EOL] from item import item_id [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] class InvertedIndex : [EOL] def __init__ ( self ) : [EOL] self . index = dict ( ) [EOL] self . num_transactions = [number] [EOL] [EOL] def add ( self , transaction ) : [EOL] self . num_transactions += [number] [EOL] for item in transaction : [EOL] if not isinstance ( item , int ) : [EOL] raise TypeError ( [string] ) [EOL] if item not in self . index : [EOL] self . index [ item ] = set ( ) [EOL] self . index [ item ] . add ( self . num_transactions ) [EOL] [EOL] def load ( self , data ) : [EOL] if not isinstance ( data , str ) : [EOL] raise TypeError ( [string] ) [EOL] for transaction in data . splitlines ( ) : [EOL] self . add ( [ item_id ( s ) for s in transaction . split ( [string] ) ] ) [EOL] [EOL] def load_csv ( self , csvFilePath ) : [EOL] if not isinstance ( csvFilePath , str ) : [EOL] raise TypeError ( [string] ) [EOL] with open ( csvFilePath , newline = [string] ) as csvfile : [EOL] reader = csv . reader ( csvfile ) [EOL] for line in reader : [EOL] transaction = map ( item_id , line ) [EOL] self . add ( transaction ) [EOL] [EOL] def items ( self ) : [EOL] return self . index . keys ( ) [EOL] [EOL] def count ( self , itemset ) : [EOL] for item in itemset : [EOL] if not isinstance ( item , int ) : [EOL] raise TypeError ( [string] ) [EOL] if ( not isinstance ( itemset , set ) and not isinstance ( itemset , frozenset ) and not isinstance ( itemset , list ) ) : [EOL] raise TypeError ( [string] ) [EOL] return len ( set . intersection ( * [ self . index [ i ] for i in itemset ] ) ) [EOL] [EOL] def support ( self , itemset ) : [EOL] return self . count ( itemset ) / self . num_transactions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 $_csv._reader$ 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import typing [EOL] import builtins [EOL] from itertools import product [EOL] from typing import List [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def contains_all_subsets ( candidate , candidates ) : [EOL] for item in candidate : [EOL] if candidate - { item } not in candidates : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def apriori ( index , minsup ) : [EOL] print ( [string] . format ( minsup ) ) [EOL] candidates = set ( [ frozenset ( { i } ) for i in index . items ( ) if index . support ( { i } ) >= minsup ] ) [EOL] results = list ( candidates ) [EOL] itemset_size = [number] [EOL] while len ( candidates ) > [number] : [EOL] generation = set ( ) [EOL] for ( a , b ) in product ( candidates , repeat = [number] ) : [EOL] if ( len ( a - b ) == [number] [EOL] and index . support ( a | b ) >= minsup [EOL] and contains_all_subsets ( a | b , candidates ) ) : [EOL] generation . add ( frozenset ( a | b ) ) [EOL] print ( [string] . format ( len ( generation ) , itemset_size ) ) [EOL] itemset_size += [number] [EOL] results . extend ( list ( generation ) ) [EOL] candidates = generation [EOL] return list ( map ( lambda x : list ( sorted ( list ( x ) ) ) , results ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , DefaultDict , Dict , Iterator , Tuple , Any , Counter [EOL] import typing [EOL] import collections [EOL] import fptree [EOL] import builtins [EOL] from collections import Counter [EOL] from collections import deque [EOL] from collections import defaultdict [EOL] from apriori import apriori [EOL] from index import InvertedIndex [EOL] from typing import Counter , DefaultDict , Dict , Iterator , List , Tuple [EOL] import time [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] class FPNode : [EOL] count = ... [EOL] children = ... [EOL] parent = ... [EOL] [EOL] def __init__ ( self , item = None , count = [number] , parent = None ) : [EOL] self . item = item [EOL] [comment] [EOL] self . count = count [EOL] self . children = { } [EOL] self . parent = parent [EOL] [EOL] def is_root ( self ) : [EOL] return self . parent is None [EOL] [EOL] def __str__ ( self , level = [number] ) : [EOL] ret = ( [string] if self . is_root ( ) [EOL] else [string] * level + str ( self . item ) + [string] + str ( self . count ) ) [EOL] ret += [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] children = sorted ( self . children . values ( ) , key = lambda node : node . item ) [EOL] children = sorted ( children , key = lambda node : node . count , reverse = True ) [EOL] for node in children : [EOL] ret += node . __str__ ( level + [number] ) [EOL] return ret [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] [EOL] class FPTree : [EOL] root = ... [EOL] header = ... [EOL] item_count = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . root = FPNode ( ) [EOL] self . header = defaultdict ( list ) [EOL] self . item_count = Counter ( ) [EOL] [EOL] def insert ( self , transaction , count = [number] ) : [EOL] assert ( count > [number] ) [EOL] parent = self . root [EOL] parent . count += count [EOL] for item in transaction : [EOL] self . item_count [ item ] += count [EOL] if item not in parent . children : [EOL] node = FPNode ( item , count , parent ) [EOL] parent . children [ item ] = node [EOL] parent = node [EOL] self . header [ item ] . append ( parent ) [EOL] else : [EOL] parent = parent . children [ item ] [EOL] parent . count += count [EOL] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] + str ( self . root ) + [string] [EOL] [EOL] def path_to_root ( node ) : [EOL] path = [ ] [EOL] while not node . is_root ( ) : [EOL] path += [ node . item ] [EOL] node = node . parent [EOL] return path [EOL] [EOL] [EOL] def construct_conditional_tree ( tree , item ) : [EOL] conditional_tree = FPTree ( ) [EOL] for node in tree . header [ item ] : [EOL] path = path_to_root ( node . parent ) [EOL] conditional_tree . insert ( reversed ( path ) , node . count ) [EOL] return conditional_tree [EOL] [EOL] [EOL] def fp_growth ( tree , min_count , path , path_count , itemsets , itemset_counts ) : [EOL] [comment] [EOL] [comment] [EOL] for item in sorted ( tree . item_count . keys ( ) , key = lambda i : tree . item_count [ i ] ) : [EOL] if tree . item_count [ item ] < min_count : [EOL] [comment] [EOL] continue [EOL] [EOL] [comment] [EOL] [comment] [EOL] conditional_tree = construct_conditional_tree ( tree , item ) [EOL] itemset = path + [ item ] [EOL] itemset . sort ( ) [EOL] new_path_count = conditional_tree . root . count [EOL] fp_growth ( conditional_tree , min_count , itemset , new_path_count , itemsets , itemset_counts ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] itemset_key = tuple ( itemset ) [EOL] assert ( itemset_key not in itemset_counts ) [EOL] itemset_counts [ itemset_key ] = new_path_count [EOL] [EOL] itemsets . append ( itemset ) [EOL] [EOL] def mine_fp_tree ( transactions , min_support ) : [EOL] ( tree , num_transactions ) = construct_initial_tree ( transactions , min_support ) [EOL] min_count = min_support * num_transactions [EOL] itemsets = [ ] [EOL] itemset_counts = dict ( ) [EOL] start = time . time ( ) [EOL] fp_growth ( tree , min_count , [ ] , num_transactions , itemsets , itemset_counts ) [EOL] duration = time . time ( ) - start [EOL] print ( [string] . format ( len ( itemsets ) , duration ) ) [EOL] return ( itemsets , itemset_counts , num_transactions ) [EOL] [EOL] [EOL] def sort_transaction ( transaction , frequency ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if frequency is None : [EOL] return transaction [EOL] if not isinstance ( frequency , Counter ) : [EOL] raise TypeError ( [string] ) [EOL] return sorted ( transaction , key = lambda item : frequency [ item ] , reverse = True ) [EOL] [EOL] def count_item_frequency_in ( transactions ) : [EOL] frequency = Counter ( ) [EOL] num_transactions = [number] [EOL] for transaction in transactions : [EOL] num_transactions += [number] [EOL] for item in transaction : [EOL] frequency [ item ] += [number] [EOL] return ( frequency , num_transactions ) [EOL] [EOL] [EOL] def construct_initial_tree ( transactions , min_support ) : [EOL] start = time . time ( ) [EOL] print ( [string] ) [EOL] ( frequency , num_transactions ) = count_item_frequency_in ( transactions ) [EOL] duration = time . time ( ) - start [EOL] print ( [string] . format ( duration ) ) [EOL] start = time . time ( ) [EOL] min_count = num_transactions * min_support [EOL] print ( [string] ) [EOL] tree = FPTree ( ) [EOL] for transaction in transactions : [EOL] [comment] [EOL] [comment] [EOL] transaction = filter ( lambda item : frequency [ item ] >= min_count , transaction ) [EOL] tree . insert ( sort_transaction ( transaction , frequency ) ) [EOL] duration = time . time ( ) - start [EOL] print ( [string] . format ( duration ) ) [EOL] return ( tree , num_transactions ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.int,'FPNode']$ 0 0 0 $'FPNode'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fptree.FPNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.int,fptree.FPNode]$ 0 0 0 0 0 0 $fptree.FPNode$ 0 $fptree.FPNode$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fptree.FPNode]$ 0 0 0 0 0 $typing.List[fptree.FPNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fptree.FPNode]$ 0 0 0 $typing.List[fptree.FPNode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fptree.FPNode]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FPNode$ 0 0 0 $typing.DefaultDict$ 0 0 0 $collections.Counter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fptree.FPNode$ 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $collections.Counter[typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterator[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $fptree.FPNode$ 0 0 0 0 0 $fptree.FPNode$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $fptree.FPNode$ 0 0 0 0 $fptree.FPNode$ 0 0 0 0 0 $builtins.int$ 0 $fptree.FPNode$ 0 0 $fptree.FPNode$ 0 0 0 0 0 0 $fptree.FPNode$ 0 $fptree.FPNode$ 0 $fptree.FPNode$ 0 0 0 0 0 0 0 0 0 0 $fptree.FPNode$ 0 0 0 0 0 $fptree.FPNode$ 0 $fptree.FPNode$ 0 0 0 0 0 0 $fptree.FPNode$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FPTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Set [EOL] import typing [EOL] import index [EOL] from collections import Counter [EOL] from fptree import FPTree [EOL] from fptree import mine_fp_tree [EOL] from fptree import construct_initial_tree [EOL] from fptree import count_item_frequency_in [EOL] from fptree import sort_transaction [EOL] from apriori import apriori [EOL] from index import InvertedIndex [EOL] from item import item_id [EOL] from item import ItemSet [EOL] from datasetreader import DatasetReader [EOL] import time [EOL] import sys [EOL] [EOL] [EOL] test_transactions = list ( map ( lambda t : list ( map ( item_id , t ) ) , [ [ [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , ] ) ) [EOL] [EOL] [EOL] def test_basic_sanity ( ) : [EOL] [comment] [EOL] expected_itemsets = { ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , ItemSet ( [string] ) , } [EOL] [EOL] ( itemsets , _ , _ ) = mine_fp_tree ( test_transactions , [number] / len ( test_transactions ) ) [EOL] print ( [string] . format ( expected_itemsets ) ) [EOL] print ( [string] . format ( itemsets ) ) [EOL] assert ( len ( itemsets ) == len ( expected_itemsets ) ) [EOL] for itemset in [ frozenset ( list ( x ) ) for x in itemsets ] : [EOL] assert ( itemset in expected_itemsets ) [EOL] [EOL] [EOL] def test_stress ( ) : [EOL] datasets = [ ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] [EOL] for ( csvFilePath , min_support ) in datasets : [EOL] [comment] [EOL] print ( [string] . format ( csvFilePath ) ) [EOL] start = time . time ( ) [EOL] index = InvertedIndex ( ) [EOL] index . load_csv ( csvFilePath ) [EOL] apriori_itemsets = apriori ( index , min_support ) [EOL] apriori_duration = time . time ( ) - start [EOL] print ( [string] . format ( len ( apriori_itemsets ) , apriori_duration ) ) [EOL] [EOL] print ( [string] . format ( csvFilePath ) ) [EOL] start = time . time ( ) [EOL] ( fptree_itemsets , _ , _ ) = mine_fp_tree ( DatasetReader ( csvFilePath ) , min_support ) [EOL] fptree_duration = time . time ( ) - start [EOL] print ( [string] . format ( len ( fptree_itemsets ) , fptree_duration ) ) [EOL] [EOL] assert ( len ( fptree_itemsets ) == len ( apriori_itemsets ) ) [EOL] for itemset in [ list ( x ) for x in fptree_itemsets ] : [EOL] assert ( itemset in apriori_itemsets ) [EOL] [EOL] if apriori_duration > fptree_duration : [EOL] print ( [string] . format ( apriori_duration - fptree_duration ) ) [EOL] else : [EOL] print ( [string] . format ( fptree_duration - apriori_duration ) ) [EOL] print ( [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any [EOL] import typing [EOL] import index [EOL] from index import InvertedIndex [EOL] from apriori import apriori [EOL] from item import item_id , item_str , ItemSet [EOL] from generaterules import generate_rules [EOL] import sys [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def test_apriori ( ) : [EOL] data = ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] expectedItemSets = { ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] , ItemSet ( [string] ) : [number] / [number] } [EOL] [EOL] index = InvertedIndex ( ) [EOL] index . load ( data ) [EOL] itemsets = apriori ( index , [number] / [number] ) [EOL] assert ( len ( itemsets ) == len ( expectedItemSets ) ) [EOL] for itemset in itemsets : [EOL] assert ( frozenset ( itemset ) in expectedItemSets ) [EOL] for itemset in itemsets : [EOL] assert ( expectedItemSets [ frozenset ( itemset ) ] == index . support ( itemset ) ) [EOL] [EOL] print ( [string] . format ( [ i for i in itemsets if len ( i ) > [number] ] ) ) [EOL] [EOL] def itemize ( a ) : [EOL] return list ( map ( item_id , a ) ) [EOL] [EOL] [comment] [EOL] rx = [ ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] , [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] , [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] , [string] ] , [ [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] , [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] , [string] ] , [number] , [number] , [number] ) , ( [ [string] ] , [ [string] , [string] ] , [number] , [number] , [number] ) ] [EOL] [EOL] expectedRules = list ( map ( lambda a : ( itemize ( a [ [number] ] ) , itemize ( a [ [number] ] ) , a [ [number] ] , a [ [number] ] , a [ [number] ] ) , rx ) ) [EOL] [EOL] itemset_counts = dict ( map ( lambda i : ( tuple ( i ) , index . count ( i ) ) , itemsets ) ) [EOL] rules = generate_rules ( itemsets , itemset_counts , index . num_transactions , [number] , [number] ) [EOL] [EOL] def deitemize ( a ) : [EOL] return list ( map ( item_str , a ) ) [EOL] [EOL] p = list ( map ( lambda a : ( deitemize ( a [ [number] ] ) , deitemize ( a [ [number] ] ) , a [ [number] ] , a [ [number] ] , a [ [number] ] ) , rules ) ) [EOL] print ( [string] ) [EOL] print ( p ) [EOL] [EOL] for ( antecedent , consequent , confidence , lift , support ) in rules : [EOL] print ( [string] . format ( antecedent , consequent , confidence , lift , support ) ) [EOL] [EOL] assert ( len ( rules ) == len ( expectedRules ) ) [EOL] for i in range ( len ( rules ) ) : [EOL] assert ( expectedRules [ i ] in rules ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Set , Dict , Tuple , Any , Callable [EOL] import typing [EOL] import builtins [EOL] from item import ItemSet [EOL] from apriori import apriori [EOL] from itertools import chain , combinations [EOL] from typing import Callable , Dict , List , Tuple [EOL] import sys [EOL] [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def split_out ( item , itemset ) : [EOL] return [ x for x in itemset if x != item ] , [ item ] [EOL] [EOL] [EOL] def calc_stats ( support , antecedent , consequent , calculate_support ) : [EOL] a_sup = calculate_support ( antecedent ) [EOL] confidence = support / a_sup [EOL] c_sup = calculate_support ( consequent ) [EOL] lift = support / ( a_sup * c_sup ) [EOL] return ( confidence , lift ) [EOL] [EOL] [EOL] def is_sorted ( candidates ) : [EOL] for i in range ( [number] , len ( candidates ) ) : [EOL] if candidates [ i - [number] ] > candidates [ i ] : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def prefix_match_len ( a , b ) : [EOL] assert ( len ( a ) == len ( b ) ) [EOL] for i in range ( len ( a ) ) : [EOL] if a [ i ] != b [ i ] : [EOL] return i [EOL] return len ( a ) [EOL] [EOL] [EOL] def generate_rules_for_itemset ( itemset , calculate_support , min_confidence , min_lift ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] rules = [ ] [EOL] candidates = [ ] [EOL] [EOL] [comment] [EOL] support = calculate_support ( itemset ) [EOL] for item in itemset : [EOL] ( antecedent , consequent ) = split_out ( item , itemset ) [EOL] ( confidence , lift ) = calc_stats ( support , antecedent , consequent , calculate_support ) [EOL] if confidence < min_confidence : [EOL] continue [EOL] if lift >= min_lift : [EOL] rules . append ( ( antecedent , consequent , confidence , lift , support ) ) [EOL] candidates . append ( consequent ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] k = len ( itemset ) [EOL] itemset_as_set = set ( itemset ) [EOL] while len ( candidates ) > [number] and len ( candidates [ [number] ] ) + [number] < k : [EOL] assert ( is_sorted ( candidates ) ) [EOL] next_gen = [ ] [EOL] m = len ( candidates [ [number] ] ) [EOL] for i1 in range ( len ( candidates ) ) : [EOL] for i2 in range ( i1 + [number] , len ( candidates ) ) : [EOL] c1 = candidates [ i1 ] [EOL] c2 = candidates [ i2 ] [EOL] if prefix_match_len ( c1 , c2 ) != m - [number] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] break [EOL] consequent = list ( sorted ( set ( c1 ) | set ( c2 ) ) ) [EOL] antecedent = list ( sorted ( itemset_as_set - set ( consequent ) ) ) [EOL] assert ( is_sorted ( consequent ) ) [EOL] ( confidence , lift ) = calc_stats ( support , antecedent , consequent , calculate_support ) [EOL] if confidence < min_confidence : [EOL] continue [EOL] if lift >= min_lift : [EOL] rules . append ( ( antecedent , consequent , confidence , lift , support ) ) [EOL] next_gen . append ( consequent ) [EOL] candidates = next_gen [EOL] return rules [EOL] [EOL] [EOL] def generate_rules ( itemsets , itemset_counts , num_transactions , min_confidence , min_lift ) : [EOL] [EOL] def calculate_support ( i ) : [EOL] key = list ( i ) [EOL] return itemset_counts [ tuple ( key ) ] / num_transactions [EOL] [EOL] rules = [ ] [EOL] for itemset in filter ( lambda i : len ( i ) > [number] , itemsets ) : [EOL] rules . extend ( generate_rules_for_itemset ( itemset , calculate_support , min_confidence , min_lift ) ) [EOL] return rules [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.int],typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.List[builtins.int],typing.List[builtins.int],builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.List[builtins.int],typing.List[builtins.int],builtins.float,builtins.float,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0