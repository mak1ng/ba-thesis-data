	0
from typing import Any , Literal , Tuple , List [EOL] import typing [EOL] import _csv [EOL] import typing_extensions [EOL] import csv [EOL] import inspect [EOL] import io [EOL] import textwrap [EOL] [EOL] import click [EOL] import numpy as np [EOL] from traitlets import Tuple [EOL] from traitlets . traitlets import TraitError , TraitType , Int , Float , Complex , Bool , HasTraits , Unicode , Enum , is_trait [EOL] from traittypes import Array [EOL] [EOL] from crowddynamics . core . vector2D import length [EOL] from crowddynamics . exceptions import InvalidType , InvalidValue [EOL] [EOL] [EOL] def shape_validator ( * dimensions ) : [EOL] [docstring] [EOL] [EOL] def validator ( trait , value ) : [EOL] if value . shape == dimensions : [EOL] return value [EOL] else : [EOL] raise TraitError ( [string] % ( dimensions , value . shape ) ) [EOL] [EOL] return validator [EOL] [EOL] [EOL] def length_validator ( * lengths ) : [EOL] [docstring] [EOL] [EOL] def validator ( trait , value ) : [EOL] l = length ( value ) [EOL] if np . any ( np . isclose ( l , lengths ) ) : [EOL] return value [EOL] else : [EOL] raise TraitError ( [string] % ( lengths , l ) ) [EOL] [EOL] return validator [EOL] [EOL] [EOL] def trait_to_type ( trait ) : [EOL] if is_trait ( trait ) : [EOL] if isinstance ( trait , Int ) : [EOL] return int [EOL] elif isinstance ( trait , Float ) : [EOL] return float [EOL] elif isinstance ( trait , Complex ) : [EOL] return complex [EOL] elif isinstance ( trait , Bool ) : [EOL] return bool [EOL] elif isinstance ( trait , Unicode ) : [EOL] raise str [EOL] else : [EOL] raise InvalidValue ( [string] [string] . format ( trait ) ) [EOL] else : [EOL] raise InvalidType ( [string] . format ( TraitType ) ) [EOL] [EOL] [EOL] def trait_to_dtype ( name , trait ) : [EOL] [docstring] [EOL] if is_trait ( trait ) : [EOL] if isinstance ( trait , Int ) : [EOL] return name , np . int64 [EOL] elif isinstance ( trait , Float ) : [EOL] return name , np . float64 [EOL] elif isinstance ( trait , Complex ) : [EOL] return name , np . complex128 [EOL] elif isinstance ( trait , Bool ) : [EOL] return name , np . bool_ [EOL] elif isinstance ( trait , Unicode ) : [EOL] raise NotImplementedError [EOL] elif isinstance ( trait , Enum ) : [EOL] raise NotImplementedError [EOL] elif isinstance ( trait , Array ) : [EOL] return name , trait . dtype , trait . default_value . shape [EOL] else : [EOL] raise InvalidValue ( [string] [string] . format ( trait ) ) [EOL] else : [EOL] raise InvalidType ( [string] . format ( TraitType ) ) [EOL] [EOL] [EOL] def trait_to_option ( name , trait ) : [EOL] if is_trait ( trait ) : [EOL] if isinstance ( trait , Int ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , type = click . IntRange ( trait . min , trait . max ) ) [EOL] elif isinstance ( trait , Float ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , type = float ) [EOL] elif isinstance ( trait , Complex ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , type = complex ) [EOL] elif isinstance ( trait , Bool ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , is_flag = True ) [EOL] elif isinstance ( trait , Unicode ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , type = str ) [EOL] elif isinstance ( trait , Enum ) : [EOL] [comment] [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = str ( trait . default_value ) , type = click . Choice ( list ( map ( str , trait . values ) ) ) ) [EOL] elif isinstance ( trait , Tuple ) : [EOL] return click . Option ( param_decls = ( [string] + name , ) , default = trait . default_value , type = tuple ( trait_to_type ( t ) for t in trait . _traits ) ) [EOL] else : [EOL] raise InvalidValue ( [string] [string] . format ( trait ) ) [EOL] else : [EOL] raise InvalidType ( [string] . format ( TraitType ) ) [EOL] [EOL] [EOL] def class_own_traits ( cls , exclude_attrs = None ) : [EOL] [docstring] [EOL] if issubclass ( cls , HasTraits ) : [EOL] for name , trait in vars ( cls ) . items ( ) : [EOL] if callable ( exclude_attrs ) and exclude_attrs ( name ) : [EOL] continue [EOL] if isinstance ( trait , TraitType ) : [EOL] yield name , trait [EOL] [EOL] [EOL] def class_traits ( cls , exclude_attrs = None , exclude_cls = None ) : [EOL] [docstring] [EOL] for c in inspect . getmro ( cls ) : [EOL] if callable ( exclude_cls ) and exclude_cls ( c ) : [EOL] continue [EOL] yield from class_own_traits ( c , exclude_attrs ) [EOL] [EOL] [EOL] def class_to_struct_dtype ( cls , exclude_attrs , exclude_cls ) : [EOL] [docstring] [EOL] return np . dtype ( [ trait_to_dtype ( name , trait ) for name , trait in class_traits ( cls , exclude_attrs = exclude_attrs , exclude_cls = exclude_cls ) ] ) [EOL] [EOL] [EOL] class Rst ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ staticmethod def math ( s ) : [EOL] if s in ( [string] , None ) : [EOL] return [string] [EOL] else : [EOL] return [string] % s [EOL] @ staticmethod def literal ( s ) : [EOL] if isinstance ( s , str ) and s == [string] : [EOL] return [string] [EOL] else : [EOL] return [string] % s [EOL] [EOL] [EOL] def table_of_traits ( cls ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] indent = [number] * [string] [EOL] header = ( [string] , [string] , [string] , [string] ) [EOL] with io . StringIO ( ) as buffer : [EOL] writer = csv . writer ( buffer ) [EOL] writer . writerow ( header ) [EOL] for name , trait in class_traits ( cls ) : [EOL] row = [ Rst . literal ( name ) , Rst . math ( trait . metadata . get ( [string] , [string] ) ) , Rst . literal ( trait . default_value ) , trait . metadata . get ( [string] , [string] ) ] [EOL] writer . writerow ( row ) [EOL] table = buffer . getvalue ( ) [EOL] [EOL] return [string] . join ( ( [string] , [string] , textwrap . indent ( [string] , indent ) , [string] , textwrap . indent ( table , indent ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import _importlib_modulespec [EOL] import logging [EOL] [docstring] [EOL] import importlib . util [EOL] import logging [EOL] import os [EOL] [EOL] from configobj import ConfigObj [EOL] from validate import Validator [EOL] [EOL] from crowddynamics . exceptions import ValidationError , deprecated [EOL] from crowddynamics . utils import remember_cwd [EOL] [EOL] CONFIG_ROOT = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] [EOL] LOG_CFG = os . path . join ( CONFIG_ROOT , [string] ) [EOL] [EOL] CROWDDYNAMICS_CFG_SPEC = os . path . join ( CONFIG_ROOT , [string] ) [EOL] CROWDDYNAMICS_CFG = [string] [EOL] [EOL] BODY_TYPES_CFG = os . path . join ( CONFIG_ROOT , [string] ) [EOL] BODY_TYPES_CFG_SPEC = os . path . join ( CONFIG_ROOT , [string] ) [EOL] [EOL] [EOL] def load_config ( infile , configspec = None ) : [EOL] [docstring] [EOL] config = ConfigObj ( infile = infile , configspec = configspec ) [EOL] if configspec and not config . validate ( Validator ( ) ) : [EOL] raise ValidationError [EOL] return config [EOL] [EOL] [EOL] @ deprecated def import_simulation_callables ( confpath ) : [EOL] [docstring] [EOL] logger = logging . getLogger ( __name__ ) [EOL] base , _ = os . path . split ( confpath ) [EOL] config = load_config ( confpath , configspec = CROWDDYNAMICS_CFG_SPEC ) [EOL] conf = config . get ( [string] , [ ] ) [EOL] [EOL] if conf : [EOL] for name , configs in conf . items ( ) : [EOL] path = configs [ [string] ] [EOL] for funcname in configs [ [string] ] : [EOL] try : [EOL] with remember_cwd ( base ) : [EOL] spec = importlib . util . spec_from_file_location ( name , path ) [EOL] module = importlib . util . module_from_spec ( spec ) [EOL] spec . loader . exec_module ( module ) [EOL] [EOL] try : [EOL] yield funcname , getattr ( module , funcname ) [EOL] except AttributeError as e : [EOL] logger . warning ( e ) [EOL] except ImportError as e : [EOL] logger . warning ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict , List , Union [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import platform [EOL] import sys [EOL] [EOL] import loggingtools [EOL] [EOL] from crowddynamics . config import LOG_CFG [EOL] [EOL] LOGLEVELS = [ logging . CRITICAL , logging . FATAL , logging . ERROR , logging . WARNING , logging . WARN , logging . INFO , logging . DEBUG , logging . NOTSET , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def format_numpy ( precision = [number] , threshold = [number] , edgeitems = [number] , linewidth = None , suppress = False , nanstr = None , infstr = None , formatter = None ) : [EOL] try : [EOL] import numpy as np [EOL] np . set_printoptions ( precision , threshold , edgeitems , linewidth , suppress , nanstr , infstr , formatter ) [EOL] except ImportError : [EOL] return [EOL] [EOL] [EOL] pandas_options = { [string] : None , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] [EOL] def format_pandas ( opts = pandas_options ) : [EOL] try : [EOL] import pandas as pd [EOL] for key , val in opts . items ( ) : [EOL] pd . set_option ( key , val ) [EOL] except ImportError : [EOL] return [EOL] [EOL] [EOL] def user_info ( ) : [EOL] logger = logging . getLogger ( __name__ ) [EOL] logger . info ( [string] , platform . platform ( ) ) [EOL] logger . info ( [string] , sys . path [ [number] ] ) [EOL] logger . info ( [string] , sys . version [ [number] : [number] ] ) [EOL] [EOL] [EOL] def setup_logging ( loglevel = logging . INFO , log_cfg = LOG_CFG ) : [EOL] loggingtools . setup_logging ( log_cfg , [string] ) [EOL] format_numpy ( ) [EOL] format_pandas ( ) [EOL] user_info ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , Tuple [EOL] import typing [EOL] from . _version import get_versions [EOL] [EOL] [EOL] __author__ = [string] [EOL] __authors__ = ( [string] , ) [EOL] __email__ = [string] [EOL] __license__ = [string] [EOL] __version__ = get_versions ( ) [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] del get_versions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_interactions ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import numpy as np [EOL] [EOL] [EOL] [comment] [EOL] obstacle_type_linear = np . dtype ( [ ( [string] , np . float64 , [number] ) , ( [string] , np . float64 , [number] ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import numba [EOL] import numpy as np [EOL] from numba import f8 , void [EOL] from numba . types import Float , Array [EOL] [EOL] [EOL] @ numba . vectorize ( [ f8 ( f8 ) ] , cache = True ) def wrap_to_pi ( rad ) : [EOL] [docstring] [EOL] [comment] [EOL] rad_ = rad % ( [number] * np . pi ) [EOL] if rad < [number] and rad_ == np . pi : [EOL] [comment] [EOL] return - np . pi [EOL] elif rad_ > np . pi : [EOL] return rad_ - ( [number] * np . pi ) [EOL] else : [EOL] return rad_ [EOL] [EOL] [EOL] @ numba . jit ( f8 [ : ] ( f8 [ : ] ) , nopython = True , nogil = True , cache = True ) def rotate90 ( v ) : [EOL] [docstring] [EOL] rot = np . zeros_like ( v ) [EOL] rot [ [number] ] = - v [ [number] ] [EOL] rot [ [number] ] = v [ [number] ] [EOL] return rot [EOL] [EOL] [EOL] @ numba . jit ( f8 [ : ] ( f8 [ : ] ) , nopython = True , nogil = True , cache = True ) def rotate270 ( v ) : [EOL] [docstring] [EOL] rot = np . zeros_like ( v ) [EOL] rot [ [number] ] = v [ [number] ] [EOL] rot [ [number] ] = - v [ [number] ] [EOL] return rot [EOL] [EOL] [EOL] @ numba . jit ( [ f8 ( f8 [ : ] ) , f8 [ : ] ( f8 [ : , : ] ) ] , nopython = True , nogil = True , cache = True ) def angle ( v ) : [EOL] [docstring] [EOL] return np . arctan2 ( v [ ... , [number] ] , v [ ... , [number] ] ) [EOL] [EOL] [EOL] @ numba . jit ( [ f8 ( f8 [ : ] ) , f8 [ : ] ( f8 [ : , : ] ) ] , nopython = True , nogil = True , cache = True ) def length ( v ) : [EOL] [docstring] [EOL] return np . hypot ( v [ ... , [number] ] , v [ ... , [number] ] ) [EOL] [EOL] [EOL] @ numba . jit ( [ f8 ( f8 [ : ] , f8 [ : ] ) , f8 [ : ] ( f8 [ : , : ] , f8 [ : , : ] ) ] , nopython = True , nogil = True , cache = True ) def dot ( v0 , v1 ) : [EOL] [docstring] [EOL] return v0 [ ... , [number] ] * v1 [ ... , [number] ] + v0 [ ... , [number] ] * v1 [ ... , [number] ] [EOL] [EOL] [EOL] @ numba . jit ( [ f8 ( f8 [ : ] , f8 [ : ] ) , f8 [ : ] ( f8 [ : , : ] , f8 [ : , : ] ) ] , nopython = True , nogil = True , cache = True ) def cross ( v0 , v1 ) : [EOL] [docstring] [EOL] return v0 [ ... , [number] ] * v1 [ ... , [number] ] - v0 [ ... , [number] ] * v1 [ ... , [number] ] [EOL] [EOL] [EOL] @ numba . jit ( f8 [ : ] ( f8 [ : ] ) , nopython = True , nogil = True , cache = True ) def normalize ( v ) : [EOL] [docstring] [EOL] l = length ( v ) [EOL] return v / l if l else v [EOL] [EOL] [EOL] @ numba . jit ( void ( f8 [ : ] , f8 ) , nopython = True , nogil = True , cache = True ) def truncate ( v , l ) : [EOL] [docstring] [EOL] vlen = length ( v ) [EOL] if vlen > l : [EOL] v *= l / vlen [EOL] [EOL] [EOL] @ numba . generated_jit ( nopython = True , nogil = True , cache = True ) def unit_vector ( orientation ) : [EOL] [docstring] [EOL] if isinstance ( orientation , Float ) : [EOL] return lambda orientation : np . array ( ( np . cos ( orientation ) , np . sin ( orientation ) ) ) [EOL] elif isinstance ( orientation , Array ) : [EOL] return lambda orientation : np . vstack ( ( np . cos ( orientation ) , np . sin ( orientation ) ) ) . T [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [EOL] @ numba . jit ( [ f8 [ : ] ( f8 [ : ] , f8 [ : ] , f8 ) , f8 [ : , : ] ( f8 [ : , : ] , f8 [ : , : ] , f8 ) ] , nopython = True , nogil = True , cache = True ) def weighted_average ( e0 , e1 , weight ) : [EOL] [docstring] [EOL] return weight * e0 + ( [number] - weight ) * e1 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Dict [EOL] import typing [EOL] import numba [EOL] import numpy as np [EOL] from numba import f8 , i8 [EOL] from scipy . spatial import Voronoi [EOL] from shapely . geometry . polygon import Polygon [EOL] [EOL] from crowddynamics . core . geom2D import polygon_area [EOL] [EOL] [EOL] def density_classical ( points , cell_size ) : [EOL] [docstring] [EOL] indices = np . floor ( points / cell_size ) [EOL] x , y = indices [ : , [number] ] , indices [ : , [number] ] [EOL] x_min , y_min = x . min ( ) , y . min ( ) [EOL] shape = x . max ( ) - x_min , y . max ( ) - y_min [EOL] count = np . zeros ( shape , dtype = np . int64 ) [EOL] for i , j in zip ( x , y ) : [EOL] count [ i - x_min , j - y_min ] += [number] [EOL] return count / cell_size ** [number] [EOL] [EOL] [EOL] @ numba . jit ( ) def bounding_box ( points ) : [EOL] [docstring] [EOL] out = np . empty ( ( points . ndim , [number] ) ) [EOL] for i in range ( points . ndim ) : [EOL] x = points [ : , i ] [EOL] out [ i , [number] ] = x . min ( ) [EOL] out [ i , [number] ] = x . max ( ) [EOL] return out [EOL] [EOL] [EOL] def rectangle ( xmin , xmax , ymin , ymax ) : [EOL] return Polygon ( ( ( xmin , ymin ) , ( xmin , ymax ) , ( xmax , ymax ) , ( xmax , ymin ) ) ) [EOL] [EOL] [EOL] def voronoi_finite_polygons_2d ( vor , radius = None ) : [EOL] [docstring] [EOL] [EOL] if vor . points . shape [ [number] ] != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] new_regions = [ ] [EOL] new_vertices = vor . vertices . tolist ( ) [EOL] [EOL] center = vor . points . mean ( axis = [number] ) [EOL] if radius is None : [EOL] radius = vor . points . ptp ( ) . max ( ) * [number] [EOL] [EOL] [comment] [EOL] all_ridges = { } [EOL] for ( p1 , p2 ) , ( v1 , v2 ) in zip ( vor . ridge_points , vor . ridge_vertices ) : [EOL] all_ridges . setdefault ( p1 , [ ] ) . append ( ( p2 , v1 , v2 ) ) [EOL] all_ridges . setdefault ( p2 , [ ] ) . append ( ( p1 , v1 , v2 ) ) [EOL] [EOL] [comment] [EOL] for p1 , region in enumerate ( vor . point_region ) : [EOL] vertices = vor . regions [ region ] [EOL] [EOL] if all ( v >= [number] for v in vertices ) : [EOL] [comment] [EOL] new_regions . append ( vertices ) [EOL] continue [EOL] [EOL] [comment] [EOL] ridges = all_ridges [ p1 ] [EOL] new_region = [ v for v in vertices if v >= [number] ] [EOL] [EOL] for p2 , v1 , v2 in ridges : [EOL] if v2 < [number] : [EOL] v1 , v2 = v2 , v1 [EOL] if v1 >= [number] : [EOL] [comment] [EOL] continue [EOL] [EOL] [comment] [EOL] [EOL] t = vor . points [ p2 ] - vor . points [ p1 ] [comment] [EOL] t /= np . linalg . norm ( t ) [EOL] n = np . array ( [ - t [ [number] ] , t [ [number] ] ] ) [comment] [EOL] [EOL] midpoint = vor . points [ [ p1 , p2 ] ] . mean ( axis = [number] ) [EOL] direction = np . sign ( np . dot ( midpoint - center , n ) ) * n [EOL] far_point = vor . vertices [ v2 ] + direction * radius [EOL] [EOL] new_region . append ( len ( new_vertices ) ) [EOL] new_vertices . append ( far_point . tolist ( ) ) [EOL] [EOL] [comment] [EOL] vs = np . asarray ( [ new_vertices [ v ] for v in new_region ] ) [EOL] c = vs . mean ( axis = [number] ) [EOL] angles = np . arctan2 ( vs [ : , [number] ] - c [ [number] ] , vs [ : , [number] ] - c [ [number] ] ) [EOL] new_region = np . array ( new_region ) [ np . argsort ( angles ) ] [EOL] [EOL] [comment] [EOL] new_regions . append ( new_region . tolist ( ) ) [EOL] [EOL] return new_regions , np . asarray ( new_vertices ) [EOL] [EOL] [EOL] def density_voronoi_1 ( points , cell_size ) : [EOL] [docstring] [EOL] assert points . ndim == [number] , [string] [EOL] assert len ( points ) >= [number] , [string] [EOL] assert cell_size > [number] , [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] bbox_points = bounding_box ( points ) [EOL] ( xmin , xmax ) , ( ymin , ymax ) = bbox_points [EOL] observation_area = rectangle ( xmin , xmax , ymin , ymax ) [EOL] [EOL] [comment] [EOL] vor = Voronoi ( points ) [EOL] new_regions , new_vertices = voronoi_finite_polygons_2d ( vor ) [EOL] [EOL] [comment] [EOL] ( imin , imax ) , ( jmin , jmax ) = np . int64 ( bbox_points / cell_size ) [EOL] density = np . zeros ( shape = ( imax - imin + [number] , jmax - imin + [number] ) ) [EOL] [EOL] [comment] [EOL] for region in new_regions : [EOL] vertices = new_vertices [ region ] [EOL] voronoi_cell = Polygon ( shell = vertices ) & observation_area [EOL] minx , miny , maxx , maxy = voronoi_cell . bounds [EOL] [EOL] [comment] [EOL] [comment] [EOL] for i in range ( int ( minx / cell_size ) , int ( maxx / cell_size ) + [number] ) : [EOL] for j in range ( int ( miny / cell_size ) , int ( maxy / cell_size ) + [number] ) : [EOL] cell = rectangle ( i * cell_size , ( i + [number] ) * cell_size , j * cell_size , ( j + [number] ) * cell_size ) [EOL] intersection = voronoi_cell & cell [EOL] density [ i - imin , j - jmin ] += intersection . area / voronoi_cell . area [EOL] [EOL] return density / ( cell_size ** [number] ) [EOL] [EOL] [EOL] def density_voronoi_2 ( points , cell_size ) : [EOL] [docstring] [EOL] [comment] [EOL] vor = Voronoi ( points ) [EOL] new_regions , new_vertices = voronoi_finite_polygons_2d ( vor ) [EOL] [EOL] [comment] [EOL] area = np . array ( [ polygon_area ( new_vertices [ i ] ) for i in new_regions ] ) [EOL] [EOL] return _core_2 ( points , cell_size , area , vor . point_region ) [EOL] [EOL] [EOL] @ numba . jit ( [ f8 [ : , : ] ( f8 [ : , : ] , f8 , f8 [ : ] , i8 [ : ] ) ] , nopython = True , nogil = True , cache = True ) def _core_2 ( points , cell_size , area , point_region ) : [EOL] [docstring] [EOL] [comment] [EOL] indices = ( points / cell_size ) . astype ( np . int64 ) [EOL] x , y = indices [ : , [number] ] , indices [ : , [number] ] [EOL] x_min , y_min = x . min ( ) , y . min ( ) [EOL] shape = x . max ( ) - x_min + [number] , y . max ( ) - y_min + [number] [EOL] density = np . zeros ( shape ) [EOL] area_sum = np . zeros ( shape ) [EOL] [EOL] for k , ( i , j ) in enumerate ( zip ( x , y ) ) : [EOL] index = i - x_min , j - y_min [EOL] density [ index ] += [number] [EOL] area_sum [ index ] += area [ point_region [ k ] ] [EOL] [EOL] n , m = density . shape [EOL] for i in range ( n ) : [EOL] for j in range ( m ) : [EOL] s = area_sum [ i , j ] [EOL] if s > [number] : [EOL] density [ i , j ] /= s [EOL] [EOL] return density [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] from collections import defaultdict , MutableSequence [EOL] from itertools import product [EOL] [EOL] [EOL] class MutableBlockList ( object ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] def __init__ ( self , cell_size , default_list = list ) : [EOL] [docstring] [EOL] assert cell_size > [number] [EOL] assert callable ( default_list ) [EOL] [EOL] self . _cell_size = cell_size [EOL] self . _list = default_list [EOL] self . _blocks = defaultdict ( default_list ) [EOL] [EOL] self . _str = [string] [string] . format ( cell_size = cell_size , default_list = default_list ) [EOL] [EOL] @ staticmethod def _transform ( value , cell_size ) : [EOL] [docstring] [EOL] try : [EOL] return tuple ( elem // cell_size for elem in value ) [EOL] except : [EOL] raise KeyError [EOL] [EOL] @ staticmethod def _nearest_blocks ( index , radius ) : [EOL] [docstring] [EOL] ranges = ( range ( - radius , radius + [number] ) for _ in range ( len ( index ) ) ) [EOL] for i in product ( * ranges ) : [EOL] yield tuple ( map ( sum , zip ( index , i ) ) ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] [docstring] [EOL] index = self . _transform ( key , self . _cell_size ) [EOL] self . _blocks [ index ] . append ( value ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] [docstring] [EOL] index = self . _transform ( item , self . _cell_size ) [EOL] return self . _blocks [ index ] [EOL] [EOL] def nearest ( self , item , radius = [number] ) : [EOL] [docstring] [EOL] index = self . _transform ( item , self . _cell_size ) [EOL] return sum ( ( self . _blocks [ key ] for key in self . _nearest_blocks ( index , radius ) ) , self . _list ( ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return self . _str [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.range,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.range,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import hypothesis . strategies as st [EOL] import numpy as np [EOL] from hypothesis import given , assume [EOL] from hypothesis . extra . numpy import arrays [EOL] [EOL] from crowddynamics . core . rand import poisson_clock , poisson_timings [EOL] from crowddynamics . testing import reals [EOL] [EOL] [EOL] @ given ( interval = reals ( [number] , [number] ) , dt = reals ( [number] , [number] ) ) def test_poisson_clock ( interval , dt ) : [EOL] [comment] [EOL] assume ( [number] / [number] < interval / dt < [number] ) [EOL] [EOL] time_prev = [number] [EOL] for time in poisson_clock ( interval , dt ) : [EOL] assert isinstance ( time , float ) [EOL] assert time_prev < time < dt [EOL] time_prev = time [EOL] [EOL] [EOL] @ given ( players = arrays ( elements = st . integers ( [number] , [number] ** [number] ) , shape = [number] , dtype = np . int64 ) , interval = reals ( [number] , [number] ) , dt = reals ( [number] , [number] ) ) def test_poisson_timings ( players , interval , dt ) : [EOL] [comment] [EOL] assume ( [number] / [number] < interval / dt < [number] ) [EOL] [EOL] for index in poisson_timings ( players , interval , dt ) : [EOL] assert isinstance ( index , int ) [EOL] assert index in players [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import pytest [EOL] from hypothesis import given , assume [EOL] from shapely . geometry import Polygon , LineString [EOL] [EOL] from crowddynamics . core . geom2D import polygon_area , line_intersect [EOL] from crowddynamics . core . vector2D import length [EOL] from crowddynamics . testing import reals [EOL] [EOL] [EOL] @ given ( reals ( - [number] , [number] , shape = ( [number] , [number] ) ) ) def test_polygon_area ( vertices ) : [EOL] poly = Polygon ( vertices ) . convex_hull [EOL] assume ( poly . area > [number] ) [EOL] area = polygon_area ( np . asarray ( poly . exterior ) ) [EOL] assert np . isclose ( area , poly . area ) [EOL] [EOL] [EOL] [comment] [EOL] @ given ( x0 = reals ( [number] , [number] , shape = [number] , exclude_zero = [string] ) , x1 = reals ( [number] , [number] , shape = [number] , exclude_zero = [string] ) , y0 = reals ( [number] , [number] , shape = [number] , exclude_zero = [string] ) , y1 = reals ( [number] , [number] , shape = [number] , exclude_zero = [string] ) ) def test_line_intersect ( x0 , x1 , y0 , y1 ) : [EOL] assume ( not np . isclose ( length ( x1 - x0 ) , [number] ) ) [EOL] assume ( not np . isclose ( length ( y1 - y0 ) , [number] ) ) [EOL] [EOL] res = line_intersect ( x0 , x1 , y0 , y1 ) [EOL] correct = LineString ( [ x0 , x1 ] ) . intersects ( LineString ( [ y0 , y1 ] ) ) [EOL] assert res == correct [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import hypothesis . strategies as st [EOL] from hypothesis . core import given [EOL] from hypothesis . extra . numpy import arrays [EOL] [EOL] import crowddynamics . testing as testing [EOL] from crowddynamics . core . interactions import ( interaction_agent_agent_circular , interaction_agent_agent_three_circle , agent_agent_block_list , agent_circular_obstacle , agent_three_circle_obstacle ) [EOL] from crowddynamics . core . structures import obstacle_type_linear [EOL] from crowddynamics . simulation . agents import Circular , ThreeCircle [EOL] [EOL] CELL_SIZE = [number] [EOL] agent_attributes = { [string] : testing . reals ( [number] , [number] , exclude_zero = [string] ) , [string] : testing . reals ( [number] , [number] , exclude_zero = [string] ) , [string] : testing . reals ( - [number] , [number] , shape = [number] ) , [string] : testing . reals ( - [number] , [number] , shape = [number] ) , [string] : st . just ( [string] ) } [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ given ( testing . agents ( size_strategy = st . just ( [number] ) , agent_type = Circular , attributes = agent_attributes ) ) def test_agent_interactions_circular ( agents ) : [EOL] interaction_agent_agent_circular ( [number] , [number] , agents ) [EOL] assert True [EOL] [EOL] [EOL] @ given ( testing . agents ( size_strategy = st . just ( [number] ) , agent_type = ThreeCircle , attributes = agent_attributes ) ) def test_agent_interactions_three_circle ( agents ) : [EOL] interaction_agent_agent_three_circle ( [number] , [number] , agents ) [EOL] assert True [EOL] [EOL] [EOL] @ given ( testing . agents ( size_strategy = st . integers ( [number] , [number] ) , agent_type = Circular , attributes = agent_attributes ) ) def test_agent_block_list_circular ( agents ) : [EOL] agent_agent_block_list ( agents , CELL_SIZE ) [EOL] assert True [EOL] [EOL] [EOL] @ given ( testing . agents ( size_strategy = st . integers ( [number] , [number] ) , agent_type = ThreeCircle , attributes = agent_attributes ) ) def test_agent_block_list_three_circle ( agents ) : [EOL] agent_agent_block_list ( agents , CELL_SIZE ) [EOL] assert True [EOL] [EOL] [EOL] [comment] [EOL] [EOL] @ given ( agents = testing . agents ( size_strategy = st . just ( [number] ) , agent_type = Circular , attributes = agent_attributes ) , obstacles = arrays ( dtype = obstacle_type_linear , shape = [number] , elements = st . tuples ( testing . reals ( - [number] , [number] ) , testing . reals ( - [number] , [number] ) ) ) ) def test_agent_circular_obstacle ( agents , obstacles ) : [EOL] agent_circular_obstacle ( agents , obstacles ) [EOL] assert True [EOL] [EOL] [EOL] @ given ( agents = testing . agents ( size_strategy = st . just ( [number] ) , agent_type = ThreeCircle , attributes = agent_attributes ) , obstacles = arrays ( dtype = obstacle_type_linear , shape = [number] , elements = st . tuples ( testing . reals ( - [number] , [number] ) , testing . reals ( - [number] , [number] ) ) ) ) def test_agent_three_circle_obstacle ( agents , obstacles ) : [EOL] agent_three_circle_obstacle ( agents , obstacles ) [EOL] assert True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] from crowddynamics . core . interactions import agent_agent_block_list [EOL] from crowddynamics . core . vector2D import unit_vector [EOL] from crowddynamics . simulation . agents import Agents , Circular , ThreeCircle , AgentGroup [EOL] [EOL] [EOL] def attributes ( ) : [EOL] orientation = np . random . uniform ( - np . pi , np . pi ) [EOL] return dict ( body_type = [string] , orientation = orientation , velocity = np . random . uniform ( [number] , [number] , [number] ) , angular_velocity = np . random . uniform ( - [number] , [number] ) , target_direction = unit_vector ( orientation ) , target_orientation = orientation ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [number] , [number] , [number] ) ) @ pytest . mark . parametrize ( [string] , ( Circular , ThreeCircle ) ) def test_agent_agent_block_list ( benchmark , size , agent_type , algorithm ) : [EOL] [comment] [EOL] area_size = np . sqrt ( [number] * size ) [EOL] agents = Agents ( agent_type = agent_type ) [EOL] group = AgentGroup ( agent_type = agent_type , size = size , attributes = attributes ) [EOL] agents . add_non_overlapping_group ( group , position_gen = lambda : np . random . uniform ( - area_size , area_size , [number] ) ) [EOL] benchmark ( agent_agent_block_list , agents . array ) [EOL] assert True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import hypothesis . strategies as st [EOL] import numpy as np [EOL] from hypothesis import given , assume [EOL] [EOL] from crowddynamics . core . evacuation import agent_closer_to_exit , narrow_exit_capacity [EOL] from crowddynamics . testing import reals [EOL] [EOL] [EOL] @ given ( c_door = reals ( shape = [number] ) , position = reals ( shape = ( [number] , [number] ) ) ) def test_agent_closer_to_exit ( c_door , position ) : [EOL] indices = agent_closer_to_exit ( c_door , position ) [EOL] assert isinstance ( indices , np . ndarray ) [EOL] assert indices . dtype . type is np . int64 [EOL] [EOL] [EOL] @ given ( d_door = reals ( [number] , [number] , exclude_zero = [string] ) , d_agent = reals ( [number] , [number] , exclude_zero = [string] ) , d_layer = reals ( [number] , [number] , exclude_zero = [string] ) | st . none ( ) , coeff = reals ( [number] , [number] , exclude_zero = [string] ) ) def test_narrow_exit_capacity ( d_door , d_agent , d_layer , coeff ) : [EOL] assume ( d_door >= d_agent ) [EOL] capacity = narrow_exit_capacity ( d_door , d_agent , d_layer , coeff ) [EOL] assert isinstance ( capacity , float ) [EOL] assert capacity >= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import pytest [EOL] from hypothesis . core import given [EOL] from hypothesis . extra . numpy import arrays [EOL] [EOL] from crowddynamics . core . steering . quickest_path import direction_map , distance_map , meshgrid [EOL] from crowddynamics . testing import reals [EOL] [EOL] [EOL] @ given ( step = reals ( [number] , [number] ) ) def test_meshgrid ( step ) : [EOL] mgrid = meshgrid ( step , minx = [number] , miny = [number] , maxx = [number] , maxy = [number] ) [EOL] assert True [EOL] [EOL] [EOL] @ pytest . mark . skip def test_distance_map ( mgrid , targets , obstacles ) : [EOL] dmap = distance_map ( mgrid , targets , obstacles ) [EOL] assert True [EOL] [EOL] [EOL] @ given ( dmap = arrays ( dtype = np . float64 , shape = ( [number] , [number] ) , elements = reals ( - [number] , [number] , exclude_zero = True ) ) ) def test_direction_map ( dmap ) : [EOL] u , v = direction_map ( dmap ) [EOL] assert u . shape == dmap . shape [EOL] assert v . shape == dmap . shape [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import numpy as np [EOL] [EOL] from crowddynamics . core . rand import truncnorm [EOL] [EOL] [EOL] def force_fluctuation ( mass , scale ) : [EOL] [docstring] [EOL] size = len ( mass ) [EOL] phi = np . random . uniform ( [number] , [number] * np . pi , size = size ) [EOL] unit_vector = np . array ( ( np . cos ( phi ) , np . sin ( phi ) ) ) [EOL] magnitude = truncnorm ( [number] , [number] , loc = [number] , scale = scale , size = size ) [EOL] return ( mass * magnitude * unit_vector ) . T [EOL] [EOL] [EOL] def torque_fluctuation ( inertia_rot , scale ) : [EOL] [docstring] [EOL] size = len ( inertia_rot ) [EOL] return inertia_rot * truncnorm ( - [number] , [number] , loc = [number] , scale = scale , size = size ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] def attractor_point ( ) : [EOL] [docstring] [EOL] return NotImplementedError [EOL] [EOL] [EOL] def adjusting_force_intra_subgroup ( ) : [EOL] [docstring] [EOL] return NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] from hypothesis import given [EOL] [EOL] from crowddynamics . core . motion . adjusting import force_adjust , torque_adjust [EOL] from crowddynamics . core . motion . contact import force_contact [EOL] from crowddynamics . core . motion . fluctuation import force_fluctuation , torque_fluctuation [EOL] from crowddynamics . testing import reals [EOL] [EOL] SIZE = [number] [EOL] [EOL] [EOL] @ given ( mass = reals ( min_value = [number] , shape = SIZE ) , scale = reals ( min_value = [number] , shape = SIZE ) ) def test_force_fluctuation ( mass , scale ) : [EOL] ans = force_fluctuation ( mass , scale ) [EOL] assert isinstance ( ans , np . ndarray ) [EOL] assert ans . dtype . type is np . float64 [EOL] assert ans . shape == ( SIZE , [number] ) [EOL] [EOL] [EOL] @ given ( mass = reals ( min_value = [number] ) , tau_adj = reals ( min_value = [number] , exclude_zero = [string] ) , v0 = reals ( min_value = [number] ) , e0 = reals ( shape = [number] ) , v = reals ( shape = [number] ) ) def test_force_adjust ( mass , tau_adj , v0 , e0 , v ) : [EOL] ans = force_adjust ( mass , tau_adj , v0 , e0 , v ) [EOL] assert isinstance ( ans , np . ndarray ) [EOL] assert ans . dtype . type is np . float64 [EOL] assert ans . shape == ( [number] , ) [EOL] [EOL] [EOL] @ given ( h = reals ( ) , n = reals ( shape = [number] ) , v = reals ( shape = [number] ) , t = reals ( shape = [number] ) , mu = reals ( min_value = [number] ) , kappa = reals ( min_value = [number] ) , damping = reals ( min_value = [number] ) ) def test_force_contact ( h , n , v , t , mu , kappa , damping ) : [EOL] ans = force_contact ( h , n , v , t , mu , kappa , damping ) [EOL] assert isinstance ( ans , np . ndarray ) [EOL] assert ans . dtype . type is np . float64 [EOL] assert ans . shape == ( [number] , ) [EOL] [EOL] [EOL] @ given ( inertia_rot = reals ( [number] , shape = SIZE ) , scale = reals ( [number] , shape = SIZE ) ) def test_torque_fluctuation ( inertia_rot , scale ) : [EOL] ans = torque_fluctuation ( inertia_rot , scale ) [EOL] assert isinstance ( ans , np . ndarray ) [EOL] assert ans . dtype . type is np . float64 [EOL] assert ans . shape == ( SIZE , ) [EOL] [EOL] [EOL] @ given ( inertia_rot = reals ( [number] ) , tau_rot = reals ( [number] , exclude_zero = [string] ) , phi_0 = reals ( ) , phi = reals ( ) , omega_0 = reals ( ) , omega = reals ( ) ) def test_torque_adjust ( inertia_rot , tau_rot , phi_0 , phi , omega_0 , omega ) : [EOL] ans = torque_adjust ( inertia_rot , tau_rot , phi_0 , phi , omega_0 , omega ) [EOL] assert isinstance ( ans , float ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pytest [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_interactions ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , Dict [EOL] import typing [EOL] import crowddynamics [EOL] import os [EOL] from collections import Callable [EOL] [EOL] import numpy as np [EOL] from loggingtools . log_with import log_with [EOL] from matplotlib . path import Path [EOL] from shapely . geometry . polygon import Polygon [EOL] from traitlets . traitlets import Float , Instance , Unicode , default , Int [EOL] [EOL] from crowddynamics . core . evacuation import exit_detection [EOL] from crowddynamics . core . geometry import geom_to_linear_obstacles [EOL] from crowddynamics . core . integrator import velocity_verlet_integrator [EOL] from crowddynamics . core . interactions import agent_agent_block_list , agent_obstacle [EOL] from crowddynamics . core . motion . adjusting import force_adjust_agents , torque_adjust_agents [EOL] from crowddynamics . core . motion . fluctuation import force_fluctuation , torque_fluctuation [EOL] from crowddynamics . core . steering . collective_motion import leader_follower_with_herding_interaction , leader_follower_interaction [EOL] from crowddynamics . core . steering . navigation import getdefault [EOL] from crowddynamics . core . steering . orientation import orient_towards_target_direction [EOL] from crowddynamics . core . structures import obstacle_type_linear [EOL] from crowddynamics . io import save_npy , save_csv , save_geometry_json [EOL] from crowddynamics . simulation . agents import is_model [EOL] from crowddynamics . simulation . base import LogicNodeBase [EOL] [EOL] [EOL] class LogicNode ( LogicNodeBase ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , simulation , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . simulation = simulation [EOL] [EOL] def update ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class Reset ( LogicNode ) : [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] agents [ [string] ] = [number] [EOL] if is_model ( agents , [string] ) : [EOL] agents [ [string] ] = [number] [EOL] [EOL] [EOL] class Integrator ( LogicNode ) : [EOL] dt_min = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] dt_max = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] dt = velocity_verlet_integrator ( agents , self . dt_min , self . dt_max ) [EOL] self . simulation . data [ [string] ] = dt [EOL] self . simulation . data [ [string] ] += dt [EOL] [EOL] [EOL] class Fluctuation ( LogicNode ) : [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] force = force_fluctuation ( agents [ [string] ] , agents [ [string] ] ) [EOL] agents [ [string] ] += force [EOL] if is_model ( agents , [string] ) : [EOL] torque = torque_fluctuation ( agents [ [string] ] , agents [ [string] ] ) [EOL] agents [ [string] ] += torque [EOL] [EOL] [EOL] class Adjusting ( LogicNode ) : [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] force_adjust_agents ( agents ) [EOL] if is_model ( agents , [string] ) : [EOL] torque_adjust_agents ( agents ) [EOL] [EOL] [EOL] class AgentAgentInteractions ( LogicNode ) : [EOL] sight_soc = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] max_agent_radius = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] f_soc_max = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] cell_size = Float ( min = [number] , help = [string] ) [EOL] [EOL] @ default ( [string] ) def _default_cell_size ( self ) : [EOL] return self . sight_soc + [number] * self . max_agent_radius [EOL] [EOL] def update ( self ) : [EOL] agent_agent_block_list ( self . simulation . agents . array , self . cell_size ) [EOL] [EOL] [EOL] class AgentObstacleInteractions ( LogicNode ) : [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] if self . simulation . field . obstacles is None : [EOL] obstacles = np . zeros ( shape = [number] , dtype = obstacle_type_linear ) [EOL] else : [EOL] obstacles = geom_to_linear_obstacles ( self . simulation . field . obstacles ) [EOL] agent_obstacle ( agents , obstacles ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class Navigation ( LogicNode ) : [EOL] step = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] radius = Float ( default_value = [number] , min = [number] , help = [string] ) [EOL] strength = Float ( default_value = [number] , min = [number] , max = [number] , help = [string] ) [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] field = self . simulation . field [EOL] [EOL] for target in range ( len ( field . targets ) ) : [EOL] has_target = agents [ [string] ] == target [EOL] if not has_target . size : [EOL] continue [EOL] [EOL] mgrid , distance_map , direction_map = field . navigation_to_target ( target , self . step , self . radius , self . strength ) [EOL] [EOL] [comment] [EOL] indices = np . fliplr ( mgrid . indicer ( agents [ has_target ] [ [string] ] ) ) [EOL] new_direction = getdefault ( indices , direction_map , agents [ has_target ] [ [string] ] ) [EOL] agents [ [string] ] [ has_target ] = new_direction [EOL] [EOL] [EOL] class LeaderFollower ( LogicNode ) : [EOL] sight = Float ( default_value = [number] , min = [number] , help = [string] [string] ) [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] field = self . simulation . field [EOL] [EOL] obstacles = geom_to_linear_obstacles ( field . obstacles ) [EOL] direction = leader_follower_interaction ( agents , obstacles , self . sight ) [EOL] is_follower = agents [ [string] ] [EOL] agents [ [string] ] [ is_follower ] = direction [ is_follower ] [EOL] [EOL] [EOL] class LeaderFollowerWithHerding ( LogicNode ) : [EOL] sight_follower = Float ( default_value = [number] , min = [number] , help = [string] [string] ) [EOL] size_nearest_other = Int ( default_value = [number] , min = [number] , help = [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] field = self . simulation . field [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] obstacles = geom_to_linear_obstacles ( field . obstacles ) [EOL] direction_herding = leader_follower_with_herding_interaction ( agents , obstacles , self . sight_follower , self . size_nearest_other ) [EOL] is_follower = agents [ [string] ] [EOL] agents [ [string] ] [ is_follower ] = direction_herding [ is_follower ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class ExitDetection ( LogicNode ) : [EOL] [docstring] [EOL] detection_range = Float ( default_value = [number] , min = [number] ) [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] field = self . simulation . field [EOL] [EOL] center_door = np . stack ( [ np . mean ( np . asarray ( target ) , axis = [number] ) for target in field . targets ] ) [EOL] obstacles = geom_to_linear_obstacles ( field . obstacles ) [EOL] [EOL] targets , has_detected = exit_detection ( center_door , agents [ [string] ] , obstacles , self . detection_range ) [EOL] mask = agents [ [string] ] & has_detected [EOL] agents [ [string] ] [ mask ] = targets [ mask ] [EOL] agents [ [string] ] [ mask ] = False [EOL] [EOL] [EOL] class Orientation ( LogicNode ) : [EOL] def update ( self ) : [EOL] if is_model ( self . simulation . agents . array , [string] ) : [EOL] orient_towards_target_direction ( self . simulation . agents . array ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class SaveSimulationData ( LogicNode ) : [EOL] [docstring] [EOL] save_condition = Instance ( Callable , help = [string] ) [EOL] base_directory = Unicode ( default_value = [string] , help = [string] ) [EOL] save_directory = Unicode ( help = [string] ) [EOL] [EOL] def __init__ ( self , simulation , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( simulation , * args , ** kwargs ) [EOL] os . makedirs ( self . full_path , exist_ok = True ) [EOL] [EOL] [comment] [EOL] save_data_csv = save_csv ( self . full_path , [string] ) [EOL] save_data_csv . send ( None ) [EOL] save_data_csv . send ( self . simulation . metadata ) [EOL] save_data_csv . send ( True ) [EOL] [EOL] [comment] [EOL] geometries = { name : getattr ( self . simulation . field , name ) for name in ( [string] , [string] , [string] , [string] ) } [EOL] save_geometry_json ( os . path . join ( self . full_path , [string] ) , geometries ) [EOL] [EOL] [comment] [EOL] self . save_data_csv = save_csv ( self . full_path , [string] ) [EOL] self . save_data_csv . send ( None ) [EOL] [EOL] [comment] [EOL] self . save_agent_npy = save_npy ( self . full_path , [string] ) [EOL] self . save_agent_npy . send ( None ) [EOL] [EOL] @ property def full_path ( self ) : [EOL] return os . path . join ( os . path . abspath ( self . base_directory ) , self . save_directory ) [EOL] [EOL] @ default ( [string] ) def _default_save_directory ( self ) : [EOL] return self . simulation . name_with_timestamp [EOL] [EOL] def add_to_simulation_logic ( self ) : [EOL] self . simulation . logic [ [string] ] . inject_before ( self ) [EOL] [EOL] def update ( self ) : [EOL] save = self . save_condition ( self . simulation ) [EOL] [EOL] self . save_agent_npy . send ( self . simulation . agents . array ) [EOL] self . save_agent_npy . send ( save ) [EOL] [EOL] self . save_data_csv . send ( self . simulation . data ) [EOL] self . save_data_csv . send ( save ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class InsideDomain ( LogicNode ) : [EOL] [docstring] [EOL] def __init__ ( self , simulation ) : [EOL] super ( ) . __init__ ( simulation ) [EOL] self . simulation . data [ [string] ] = [number] [EOL] field = self . simulation . field [EOL] self . domain_path = Path ( np . asarray ( field . domain . exterior ) ) [EOL] [EOL] def update ( self ) : [EOL] agents = self . simulation . agents . array [EOL] new_state = self . domain_path . contains_points ( agents [ [string] ] ) [EOL] change = agents [ [string] ] ^ new_state [EOL] agents [ [string] ] = new_state [EOL] [EOL] self . simulation . data [ [string] ] += np . sum ( change ) [EOL] [EOL] [EOL] class TargetReached ( LogicNode ) : [EOL] [docstring] [EOL] prefix = [string] [EOL] [EOL] def __init__ ( self , simulation , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( simulation , * args , ** kwargs ) [EOL] size = len ( self . simulation . agents . array ) [EOL] [EOL] self . names = [ ] [EOL] self . paths = [ ] [EOL] self . reached_by = [ ] [EOL] [EOL] [comment] [EOL] for i , target in enumerate ( self . simulation . field . targets ) : [EOL] if isinstance ( target , Polygon ) : [EOL] name = self . prefix . format ( i ) [EOL] self . names . append ( name ) [EOL] self . paths . append ( Path ( np . asarray ( target . exterior ) ) ) [EOL] self . reached_by . append ( np . zeros ( size , dtype = np . bool_ ) ) [EOL] self . simulation . data [ name ] = [number] [EOL] [EOL] def update ( self ) : [EOL] [comment] [EOL] for name , path , reached_by in zip ( self . names , self . paths , self . reached_by ) : [EOL] reached_by |= path . contains_points ( self . simulation . agents . array ) [EOL] self . simulation . data [ name ] = np . sum ( reached_by ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.Integrator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.Integrator]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.AgentAgentInteractions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.AgentAgentInteractions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.AgentAgentInteractions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.AgentAgentInteractions]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.Navigation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.Navigation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.Navigation]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.LeaderFollower]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.LeaderFollowerWithHerding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.LeaderFollowerWithHerding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.ExitDetection]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.SaveSimulationData]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.SaveSimulationData]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[crowddynamics.simulation.logic.SaveSimulationData]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , List [EOL] import typing [EOL] from crowddynamics . simulation . base import LogicNodeBase , FieldBase , AgentsBase , SimulationBase [EOL] [EOL] [EOL] def test_fieldbase ( ) : [EOL] field = FieldBase ( ) [EOL] assert True [EOL] [EOL] [EOL] def test_agentbase ( ) : [EOL] agents = AgentsBase ( ) [EOL] assert True [EOL] [EOL] [EOL] def test_logicnodebase ( ) : [EOL] node = [ LogicNodeBase ( str ( i ) ) for i in range ( [number] ) ] [EOL] tree = node [ [number] ] << node [ [number] ] << ( node [ [number] ] , node [ [number] ] ) [EOL] assert node [ [number] ] . is_root [EOL] assert node [ [number] ] . children == ( node [ [number] ] , node [ [number] ] , node [ [number] ] ) [EOL] [EOL] [EOL] def test_simulationbase ( ) : [EOL] simu = SimulationBase ( ) [EOL] assert True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] import crowddynamics [EOL] import pytest [EOL] import numpy as np [EOL] [EOL] from crowddynamics . core . vector2D import length [EOL] from crowddynamics . examples . validation import TestMovement , TestAgentInteraction [EOL] from crowddynamics . simulation . agents import AgentTypes [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , AgentTypes ) def test_movement ( agent_type ) : [EOL] simulation = TestMovement ( agent_type = agent_type ) [EOL] agent_start = np . copy ( simulation . agents . array ) [EOL] [EOL] simulation . exit_condition = lambda s : s . data [ [string] ] == [number] [EOL] simulation . run ( ) [EOL] [EOL] agent_end = np . copy ( simulation . agents . array ) [EOL] dist = length ( agent_end [ [number] ] [ [string] ] - agent_start [ [number] ] [ [string] ] ) [EOL] expected_dist = [number] [EOL] assert dist >= expected_dist or np . isclose ( dist , expected_dist ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , AgentTypes ) def test_agent_interaction ( agent_type ) : [EOL] simulation = TestAgentInteraction ( agent_type = agent_type ) [EOL] agent_start = np . copy ( simulation . agents . array ) [EOL] [EOL] simulation . exit_condition = lambda s : s . data [ [string] ] == [number] [EOL] simulation . run ( ) [EOL] [EOL] agent_end = np . copy ( simulation . agents . array ) [EOL] dist = length ( agent_end [ [number] ] [ [string] ] - agent_start [ [number] ] [ [string] ] ) [EOL] expected_dist = [number] [EOL] assert dist >= expected_dist or np . isclose ( dist , expected_dist ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from crowddynamics . simulation . agents import AgentTypes [EOL] from crowddynamics . simulation . multiagent import MultiAgentSimulation [EOL] from crowddynamics . utils import import_subclasses [EOL] [EOL] root = os . path . dirname ( os . path . dirname ( __file__ ) ) [EOL] simulations = import_subclasses ( os . path . join ( root , [string] ) , MultiAgentSimulation ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , simulations . values ( ) ) @ pytest . mark . parametrize ( [string] , AgentTypes ) def test_simulations ( simulation , agent_type ) : [EOL] simu = simulation ( agent_type = agent_type ) [EOL] simu . exit_condition = lambda s : s . data [ [string] ] == [number] [EOL] simu . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0