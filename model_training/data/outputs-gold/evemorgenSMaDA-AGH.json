	0
from typing import Any , List [EOL] import typing [EOL] from core . neuron import Neuron , InputNeuron , OutputNeuron [EOL] [EOL] [EOL] class Layer : [EOL] def __init__ ( self , num_of_neurons = [number] , name = [string] ) : [EOL] self . neurons = [ Neuron ( ) for _ in range ( num_of_neurons ) ] [EOL] self . name = name [EOL] for n in self . neurons : [EOL] n . set_layer_name ( self . name ) [EOL] [EOL] def set_network_name ( self , net_name ) : [EOL] self . network_name = net_name [EOL] for n in self . neurons : [EOL] n . set_network_name ( net_name ) [EOL] n . set_layer_name ( self . name ) [EOL] [EOL] def connect_layer ( self , another , side ) : [EOL] for n in self . neurons : [EOL] for m in another . neurons : [EOL] n . connect ( m , side ) [EOL] [EOL] def stimulate_next ( self ) : [EOL] for n in self . neurons : [EOL] n . stimulate_outputs ( ) [EOL] [EOL] def stimulate_delta ( self ) : [EOL] for n in self . neurons : [EOL] n . stimulate_inputs ( ) [EOL] [EOL] def calculate_weight ( self ) : [EOL] for n in self . neurons : [EOL] n . calculate_weight ( ) [EOL] [EOL] def generate_cypher ( self ) : [EOL] query = [ ] [EOL] for n in self . neurons : [EOL] n . set_layer_name ( self . name ) [EOL] query . append ( n . generate_cypher ( ) ) [EOL] return query [EOL] [EOL] def __repr__ ( self ) : [EOL] return str ( self . neurons ) [EOL] [EOL] class InputLayer ( Layer ) : [EOL] def __init__ ( self , values , name = [string] ) : [EOL] super ( ) . __init__ ( name = name ) [EOL] self . neurons = [ InputNeuron ( value ) for value in values ] [EOL] [EOL] def set_input ( self , input ) : [EOL] for n , v in zip ( self . neurons , input ) : [EOL] n . update_value ( v ) [EOL] [EOL] [EOL] class OutputLayer ( Layer ) : [EOL] def __init__ ( self , values , name = [string] ) : [EOL] super ( ) . __init__ ( name = name ) [EOL] self . neurons = [ OutputNeuron ( value ) for value in values ] [EOL] [EOL] def calculate_delta ( self ) : [EOL] for neuron in self . neurons : [EOL] neuron . stimulate_delta ( None ) [EOL] [EOL] def set_output ( self , output ) : [EOL] for n , v in zip ( self . neurons , output ) : [EOL] n . set_desired ( v ) [EOL] [EOL] [EOL] class BiasLayer ( Layer ) : [EOL] def __init__ ( self , neurons , name = [string] ) : [EOL] super ( ) . __init__ ( name = name ) [EOL] self . neurons = neurons [EOL] [EOL] def pass_output ( self , outputs ) : [EOL] for neuron , value in zip ( self . neurons , outputs ) : [EOL] neuron . set_bias ( value )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , List [EOL] import typing [EOL] from singleton_decorator import singleton [EOL] import yaml [EOL] [EOL] @ singleton class NamePicker ( ) : [EOL] def __init__ ( self ) : [EOL] self . names = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . i = - [number] [EOL] [EOL] def _inc_i ( self ) : [EOL] self . i = ( self . i + [number] ) % len ( self . names ) [EOL] [EOL] def get_input_name ( self ) : [EOL] self . _inc_i ( ) [EOL] return ( [string] % self . i ) [EOL] [EOL] def get_output_name ( self ) : [EOL] self . _inc_i ( ) [EOL] return ( [string] % self . i ) [EOL] [EOL] def get_neuron_name ( self ) : [EOL] self . _inc_i ( ) [EOL] return ( [string] % ( self . names [ self . i ] , self . i ) ) [EOL] [EOL] def get_layer_name ( self ) : [EOL] self . _inc_i ( ) ; [EOL] return ( [string] % ( self . names [ self . i ] , self . i ) ) [EOL] [EOL] [EOL] with open ( [string] , [string] ) as file : [EOL] constants = yaml . load ( file )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any , List , Callable , Dict , Tuple [EOL] import itertools [EOL] import typing [EOL] import _curses [EOL] import curses [EOL] import yaml [EOL] import math [EOL] from curses import KEY_RIGHT , KEY_LEFT , KEY_UP , KEY_DOWN [EOL] from random import randint [EOL] from itertools import cycle [EOL] from time import time [EOL] import sys [EOL] [EOL] sys . path . append ( [string] ) [EOL] [EOL] from core . network import load_network [EOL] [EOL] board = { [string] : [number] , [string] : [number] } [EOL] [EOL] mooves = [ KEY_RIGHT , KEY_RIGHT , KEY_RIGHT , KEY_RIGHT ] [EOL] [EOL] moove = cycle ( mooves ) [EOL] [EOL] [EOL] def init_gui ( ) : [EOL] curses . initscr ( ) [EOL] win = curses . newwin ( board [ [string] ] , board [ [string] ] , [number] , [number] ) [EOL] win . keypad ( [number] ) [EOL] curses . noecho ( ) [EOL] curses . curs_set ( [number] ) [EOL] win . border ( [number] ) [EOL] win . nodelay ( [number] ) [EOL] return win [EOL] [EOL] [EOL] def violated_boundary_conditions ( snake ) : [EOL] return ( snake [ [number] ] [ [number] ] == [number] or snake [ [number] ] [ [number] ] == [number] or snake [ [number] ] [ [number] ] == board [ [string] ] - [number] or snake [ [number] ] [ [number] ] == board [ [string] ] - [number] or snake [ [number] ] in snake [ [number] : ] ) [EOL] [EOL] [EOL] def calculate_head ( snake , key ) : [EOL] snake . insert ( [number] , ( snake [ [number] ] [ [number] ] + ( key == KEY_DOWN and [number] ) + ( key == KEY_UP and - [number] ) , snake [ [number] ] [ [number] ] + ( key == KEY_LEFT and - [number] ) + ( key == KEY_RIGHT and [number] ) ) ) [EOL] [EOL] [EOL] def get_input ( player , event , key ) : [EOL] dir = { KEY_UP : { KEY_LEFT : - [number] , KEY_UP : [number] , KEY_RIGHT : [number] } , KEY_LEFT : { KEY_DOWN : - [number] , KEY_LEFT : [number] , KEY_UP : [number] } , KEY_RIGHT : { KEY_UP : - [number] , KEY_RIGHT : [number] , KEY_DOWN : [number] } , KEY_DOWN : { KEY_RIGHT : - [number] , KEY_DOWN : [number] , KEY_LEFT : [number] } } [EOL] [EOL] opposite = { KEY_DOWN : KEY_UP , KEY_UP : KEY_DOWN , KEY_LEFT : KEY_RIGHT , KEY_RIGHT : KEY_LEFT } [EOL] [EOL] if player : [EOL] if event != - [number] and event != opposite [ key ] : [EOL] return event , dir [ key ] [ event ] [EOL] else : [EOL] return key , dir [ key ] [ key ] [EOL] else : [EOL] return next ( moove ) [EOL] [EOL] [EOL] def init_state ( player , gui , snek ) : [EOL] if player : [EOL] delay = [number] [EOL] elif gui and not player : [EOL] delay = [number] [EOL] else : [EOL] delay = [number] [EOL] return ( KEY_RIGHT , [number] , delay , snek if snek is not None else [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] , ( randint ( [number] , board [ [string] ] - [number] ) , randint ( [number] , board [ [string] ] - [number] ) ) , ) [EOL] [EOL] [EOL] def new_food ( snake ) : [EOL] food = ( randint ( [number] , board [ [string] ] - [number] ) , randint ( [number] , board [ [string] ] - [number] ) ) [comment] [EOL] return food if food not in snake else new_food ( snake ) [EOL] [EOL] [EOL] def eat_food ( snake , food ) : [EOL] return snake [ [number] ] == food [EOL] [EOL] [EOL] def extract_features ( snake , board , score , food , key , action ) : [EOL] directions = { KEY_DOWN : { [string] : ( [number] , [number] ) , [string] : ( [number] , [number] ) , [string] : ( [number] , - [number] ) } , KEY_UP : { [string] : ( - [number] , [number] ) , [string] : ( [number] , - [number] ) , [string] : ( [number] , [number] ) } , KEY_LEFT : { [string] : ( [number] , - [number] ) , [string] : ( [number] , [number] ) , [string] : ( - [number] , [number] ) } , KEY_RIGHT : { [string] : ( [number] , [number] ) , [string] : ( - [number] , [number] ) , [string] : ( [number] , [number] ) } } [EOL] head = snake [ [number] ] [EOL] head_front = ( head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] , head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] ) [EOL] head_left = ( head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] , head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] ) [EOL] head_right = ( head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] , head [ [number] ] + directions [ key ] [ [string] ] [ [number] ] ) [EOL] [EOL] obstacle_front = int ( violated_boundary_conditions ( [ head_front ] + snake [ [number] : ] ) ) [EOL] obstacle_left = int ( violated_boundary_conditions ( [ head_left ] + snake [ [number] : ] ) ) [EOL] obstacle_right = int ( violated_boundary_conditions ( [ head_right ] + snake [ [number] : ] ) ) [EOL] [EOL] food_angle = math . atan2 ( abs ( head [ [number] ] - food [ [number] ] ) , abs ( head [ [number] ] - food [ [number] ] ) ) [EOL] [comment] [EOL] [EOL] return obstacle_front , obstacle_left , obstacle_right , action , food_angle [EOL] [EOL] [EOL] def draw ( win , snake , food , delay , score , last = None ) : [EOL] win . addch ( food [ [number] ] , food [ [number] ] , [string] ) [EOL] if last is not None : [EOL] win . addch ( last [ [number] ] , last [ [number] ] , [string] ) [EOL] win . addch ( snake [ [number] ] [ [number] ] , snake [ [number] ] [ [number] ] , [string] ) [EOL] win . border ( [number] ) [EOL] win . addstr ( [number] , [number] , [string] + str ( score ) + [string] ) [comment] [EOL] win . addstr ( [number] , [number] , [string] ) [comment] [EOL] win . timeout ( delay ) [comment] [EOL] [EOL] def draw_features ( win , features , board ) : [EOL] win . addstr ( board [ [string] ] - [number] , [number] , str ( { [string] : features [ [number] ] , [string] : features [ [number] ] , [string] : features [ [number] ] , [string] : features [ [number] ] } ) ) [EOL] [EOL] [EOL] def random_action ( prev_action , features ) : [EOL] action = randint ( [number] , [number] ) - [number] [EOL] dir = { KEY_UP : { - [number] : KEY_LEFT , [number] : KEY_UP , [number] : KEY_RIGHT } , KEY_LEFT : { - [number] : KEY_DOWN , [number] : KEY_LEFT , [number] : KEY_UP } , KEY_RIGHT : { - [number] : KEY_UP , [number] : KEY_RIGHT , [number] : KEY_DOWN } , KEY_DOWN : { - [number] : KEY_RIGHT , [number] : KEY_DOWN , [number] : KEY_LEFT } } [EOL] [EOL] return dir [ prev_action ] [ action ] , action [EOL] [EOL] def neural_action ( prev_action , features ) : [EOL] dir = { KEY_UP : { - [number] : KEY_LEFT , [number] : KEY_UP , [number] : KEY_RIGHT } , KEY_LEFT : { - [number] : KEY_DOWN , [number] : KEY_LEFT , [number] : KEY_UP } , KEY_RIGHT : { - [number] : KEY_UP , [number] : KEY_RIGHT , [number] : KEY_DOWN } , KEY_DOWN : { - [number] : KEY_RIGHT , [number] : KEY_DOWN , [number] : KEY_LEFT } } [EOL] [EOL] left = network . test ( features [ : - [number] ] + ( - [number] , ) ) [EOL] front = network . test ( features [ : - [number] ] + ( [number] , ) ) [EOL] right = network . test ( features [ : - [number] ] + ( [number] , ) ) [EOL] [EOL] [EOL] if left == max ( left , front , right ) : [EOL] return dir [ prev_action ] [ - [number] ] , - [number] [EOL] elif front == max ( left , front , right ) : [EOL] return dir [ prev_action ] [ [number] ] , [number] [EOL] else : [EOL] return dir [ prev_action ] [ [number] ] , [number] [EOL] [EOL] [EOL] def neural_action2 ( prev_action , features ) : [EOL] dir = { KEY_UP : { - [number] : KEY_LEFT , [number] : KEY_UP , [number] : KEY_RIGHT } , KEY_LEFT : { - [number] : KEY_DOWN , [number] : KEY_LEFT , [number] : KEY_UP } , KEY_RIGHT : { - [number] : KEY_UP , [number] : KEY_RIGHT , [number] : KEY_DOWN } , KEY_DOWN : { - [number] : KEY_RIGHT , [number] : KEY_DOWN , [number] : KEY_LEFT } } [EOL] [EOL] left = network . test ( features [ : - [number] ] + ( features [ - [number] ] , - [number] ) ) [EOL] front = network . test ( features [ : - [number] ] + ( features [ - [number] ] , [number] ) ) [EOL] right = network . test ( features [ : - [number] ] + ( features [ - [number] ] , [number] ) ) [EOL] [EOL] [EOL] if left == max ( left , front , right ) : [EOL] return dir [ prev_action ] [ - [number] ] , - [number] [EOL] elif front == max ( left , front , right ) : [EOL] return dir [ prev_action ] [ [number] ] , [number] [EOL] else : [EOL] return dir [ prev_action ] [ [number] ] , [number] [EOL] [EOL] [EOL] def food_distance ( snek , food ) : [EOL] head = snek [ [number] ] [EOL] return math . sqrt ( ( head [ [number] ] - food [ [number] ] ) ** [number] + ( head [ [number] ] - food [ [number] ] ) ** [number] ) [EOL] [EOL] def snek ( player = False , gui = False , snek = None , action = random_action ) : [EOL] win = init_gui ( ) [EOL] key , score , delay , snake , food = init_state ( player , gui , snek ) [EOL] [EOL] win . addch ( food [ [number] ] , food [ [number] ] , [string] ) [comment] [EOL] [EOL] while key != [number] : [comment] [EOL] prevKey = key [comment] [EOL] prev_dist = food_distance ( snake , food ) [EOL] prev_score = score [EOL] [EOL] features = extract_features ( snake , board , score , food , key , key ) [EOL] [EOL] event = win . getch ( ) [EOL] if player : [EOL] key , choosen_action = get_input ( player , event , key ) [EOL] else : [EOL] key , choosen_action = action ( prevKey , features ) [EOL] [EOL] if key not in [ KEY_LEFT , KEY_RIGHT , KEY_UP , KEY_DOWN , [number] ] : [comment] [EOL] key = prevKey [EOL] [EOL] features = extract_features ( snake , board , score , food , key , choosen_action ) [EOL] [EOL] calculate_head ( snake , key ) [EOL] [EOL] last = None [EOL] if eat_food ( snake , food ) : [EOL] food = new_food ( snake ) [EOL] score += [number] [EOL] else : [EOL] last = snake . pop ( ) [comment] [EOL] [EOL] new_dist = food_distance ( snake , food ) [EOL] [EOL] if violated_boundary_conditions ( snake ) : [EOL] result = - [number] [EOL] elif violated_boundary_conditions ( snake ) and ( new_dist < prev_dist or score > prev_score ) : [EOL] result = [number] [EOL] elif not violated_boundary_conditions ( snake ) and ( new_dist < prev_dist ) or score > prev_score : [EOL] result = [number] [EOL] else : [EOL] result = - [number] [EOL] [EOL] features = extract_features ( snake , board , score , food , key , choosen_action ) [EOL] learning_data . append ( ( * features , result ) ) [EOL] [EOL] prev_score = score [EOL] [EOL] if violated_boundary_conditions ( snake ) : [EOL] break [EOL] [EOL] if gui : [EOL] draw ( win , snake , food , delay , score , last ) [EOL] draw_features ( win , features , board ) [EOL] [EOL] [EOL] curses . endwin ( ) [EOL] return score [EOL] [EOL] learning_data = [ ] [EOL] [EOL] def learn ( ) : [EOL] start_time = time ( ) [EOL] while len ( learning_data ) < [number] : [EOL] score = snek ( player = True , gui = True ) [EOL] end_time = time ( ) [EOL] [EOL] print ( end_time - start_time ) [EOL] [EOL] with open ( [string] , [string] ) as file : [EOL] yaml . dump ( learning_data , file ) [EOL] [EOL] [comment] [EOL] network = load_network ( [string] ) [EOL] [EOL] def test ( ) : [EOL] for _ in range ( [number] ) : [EOL] score = snek ( player = False , gui = True , action = neural_action2 ) [EOL] [EOL] [comment] [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.cycle[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List , Dict [EOL] import typing [EOL] from core . neuron import BiasNeuron [EOL] from core . layer import Layer , InputLayer , OutputLayer [EOL] from core . network import Network [EOL] [EOL] [EOL] net_name = [string] [EOL] inputs = InputLayer ( [ [number] , [number] ] ) [EOL] middle = Layer ( [number] ) [EOL] middle2 = Layer ( [number] ) [EOL] output = OutputLayer ( [ [number] ] ) [EOL] [EOL] network = Network ( [ inputs , middle , middle2 , output ] , net_name ) [EOL] network . connect ( ) [EOL] [EOL] [EOL] learning_data = [ { [string] : [ [number] , [number] ] , [string] : [ [number] ] } , { [string] : [ [number] , [number] ] , [string] : [ [number] ] } , { [string] : [ [number] , [number] ] , [string] : [ [number] ] } , { [string] : [ [number] , [number] ] , [string] : [ [number] ] } ] [EOL] [EOL] network . load_learning_data ( learning_data ) [EOL] network . normalize_learning_data ( ) [EOL] print ( [string] ) [EOL] network . print_data ( ) [EOL] [EOL] network . learn ( times = [number] ) [EOL] [EOL] [EOL] i = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] o = [ network . test ( io ) for io in i ] [EOL] [EOL] [EOL] print ( [string] ) [EOL] network . print_io ( i , o ) [EOL] [EOL] print ( [string] ) [EOL] network . print_weights ( ) [EOL] [EOL] bias = BiasNeuron ( [number] ) [EOL] bias . set_network_name ( net_name ) [EOL] middle . neurons [ [number] ] . connect ( bias , [string] ) [EOL] [EOL] network . dump_network ( [string] , prompt = True ) [EOL] [EOL] network . dump_cypher ( [string] , additional_neurons = [ bias ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.List[builtins.int]]]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] import _csv [EOL] import numpy as np [EOL] import csv [EOL] import math [EOL] import random [EOL] import yaml [EOL] import matplotlib . pyplot as plt [EOL] from scipy . misc import toimage [EOL] from itertools import product [EOL] [EOL] from core . utils import constants [EOL] [EOL] [comment] [EOL] LOAD_MAP = True [EOL] NUM_OF_FEATURES = [number] [EOL] WIDTH = [number] [EOL] HEIGHT = [number] [EOL] max_iters = [number] [EOL] radius = WIDTH / [number] [EOL] learning_rate = constants [ [string] ] [EOL] minimal_change = [number] [EOL] [EOL] [EOL] class LemmeOut ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def load_data ( filename ) : [EOL] p = [ ] [EOL] c = [ ] [EOL] [EOL] with open ( filename , newline = [string] ) as csvfile : [EOL] reader = csv . reader ( csvfile ) [EOL] for row in reader : [EOL] p . append ( [ float ( x ) for x in row [ [number] : NUM_OF_FEATURES ] ] ) [EOL] c . append ( row [ [number] ] ) [EOL] return p , c [EOL] [EOL] [EOL] def distance ( map , x ) : [EOL] reshaped = x . reshape ( ( [number] , [number] , - [number] ) ) [EOL] squared = ( map - reshaped ) ** [number] [EOL] return np . sqrt ( np . sum ( squared , [number] ) ) [EOL] [EOL] [EOL] def best_match ( map , pattern ) : [EOL] np_pattern = np . asarray ( pattern , dtype = np . float32 ) [EOL] eucli_map = distance ( map , np_pattern ) [EOL] [EOL] bmu_x = np . argmin ( np . amin ( eucli_map , [number] ) , [number] ) [EOL] bmu_y = np . argmin ( eucli_map , [number] ) [ int ( bmu_x ) ] [EOL] [EOL] return list ( map [ bmu_x ] [ bmu_y ] ) [EOL] [EOL] [EOL] def load_som ( filename ) : [EOL] with open ( filename , [string] ) as stream : [EOL] return yaml . load ( stream ) [EOL] [EOL] [EOL] def generate_result_map ( pat , cls , map ) : [EOL] result_map = np . zeros ( [ HEIGHT , WIDTH , [number] ] , dtype = np . float32 ) [EOL] iris_map = { [string] : ( [number] , [ [number] , [number] , [number] ] ) , [string] : ( [number] , [ [number] , [number] , [number] ] ) , [string] : ( [number] , [ [number] , [number] , [number] ] ) } [EOL] [EOL] for i , pattern in enumerate ( pat ) : [EOL] [EOL] eucli_map = distance ( map , pattern ) [EOL] [EOL] x = np . argmin ( np . amin ( eucli_map , [number] ) , [number] ) [EOL] y = np . argmin ( eucli_map , [number] ) [ int ( x ) ] [EOL] [EOL] if result_map [ x ] [ y ] [ iris_map [ cls [ i ] ] [ [number] ] ] <= [number] : [EOL] result_map [ x ] [ y ] += np . asarray ( iris_map [ cls [ i ] ] [ [number] ] ) [EOL] i += [number] [EOL] [EOL] return np . flip ( result_map , [number] ) [EOL] [EOL] [EOL] py_patterns , classes = load_data ( [string] ) [EOL] patterns = np . asarray ( py_patterns , dtype = np . float32 ) [EOL] [EOL] if LOAD_MAP : [EOL] map = load_som ( [string] ) [EOL] else : [EOL] map = np . random . uniform ( size = ( HEIGHT , WIDTH , NUM_OF_FEATURES ) ) [EOL] before = generate_result_map ( patterns , classes , map ) [EOL] toimage ( before ) . save ( [string] ) [EOL] old_map = np . zeros ( ( HEIGHT , WIDTH , NUM_OF_FEATURES ) ) [EOL] [EOL] coords = np . zeros ( [ HEIGHT , WIDTH , [number] ] , dtype = np . int32 ) [EOL] [EOL] for i in range ( HEIGHT ) : [EOL] for j in range ( WIDTH ) : [EOL] coords [ i ] [ j ] = [ i , j ] [EOL] [EOL] max_iterations = max_iters * len ( patterns ) [EOL] bmu = np . zeros ( [ [number] ] , dtype = np . int32 ) [EOL] [EOL] time = [number] [EOL] [EOL] try : [EOL] for n in range ( max_iters ) : [EOL] shuffle = random . sample ( range ( len ( patterns ) ) , len ( patterns ) ) [EOL] [EOL] for i in range ( len ( patterns ) ) : [EOL] current_change = np . sqrt ( np . sum ( np . sum ( ( old_map - map ) ** [number] , [number] ) ) ) [EOL] [EOL] if current_change <= minimal_change : [EOL] raise LemmeOut [EOL] else : [EOL] pattern = patterns [ shuffle [ i ] ] [EOL] eucli_map = distance ( map , pattern ) [EOL] [EOL] bmu [ [number] ] = np . argmin ( np . amin ( eucli_map , [number] ) , [number] ) [EOL] bmu [ [number] ] = np . argmin ( eucli_map , [number] ) [ int ( bmu [ [number] ] ) ] [EOL] [EOL] eucli_bmu = distance ( coords , bmu ) [EOL] [EOL] old_map = np . copy ( map ) [EOL] [EOL] for i , j in product ( range ( HEIGHT ) , range ( WIDTH ) ) : [EOL] dist = eucli_bmu [ i ] [ j ] [EOL] if dist <= radius : [EOL] theta = math . exp ( - ( dist ** [number] ) / ( [number] * ( radius ** [number] ) ) ) [EOL] map [ i ] [ j ] = map [ i ] [ j ] + theta * learning_rate * ( pattern - map [ i ] [ j ] ) [EOL] [EOL] learning_rate = constants [ [string] ] * math . exp ( - [number] * time / ( max_iters * len ( patterns ) ) ) [EOL] radius = ( WIDTH / [number] ) * math . exp ( - [number] * time / ( ( max_iters * len ( patterns ) ) / math . log ( radius ) ) ) [EOL] [EOL] time += [number] [EOL] if n % ( max_iters / [number] ) == [number] : [EOL] print ( [string] . format ( n ) ) [EOL] except LemmeOut : [EOL] pass [EOL] [EOL] after = generate_result_map ( patterns , classes , map ) [EOL] toimage ( after ) . save ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import ComputationalIntelligence [EOL] import typing [EOL] import _csv [EOL] import csv [EOL] from collections import Counter [EOL] from core . layer import Layer , InputLayer , OutputLayer [EOL] from core . network import Network [EOL] from models . som_np import load_som , best_match [EOL] [EOL] [EOL] class InputSom ( InputLayer ) : [EOL] def __init__ ( self , values , map ) : [EOL] super ( ) . __init__ ( values , name = [string] ) [EOL] self . map = map [EOL] [EOL] def set_input ( self , input ) : [EOL] for n , v in zip ( self . neurons , best_match ( self . map , input ) ) : [EOL] n . update_value ( v ) [EOL] [EOL] iris_map = { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } [EOL] [EOL] learning_data = [ ] [EOL] [EOL] with open ( [string] , newline = [string] ) as csvfile : [EOL] reader = csv . reader ( csvfile ) [EOL] for row in reader : [EOL] learning_data . append ( { [string] : [ float ( x ) for x in row [ [number] : [number] ] ] , [string] : iris_map [ row [ [number] ] ] } ) [EOL] [EOL] map = load_som ( [string] ) [EOL] inputs = InputLayer ( [ [number] , [number] , [number] , [number] ] , name = [string] ) [EOL] inputs_som = InputSom ( [ [number] , [number] , [number] , [number] ] , map ) [EOL] inputs_som . set_network_name ( [string] ) [EOL] middle = Layer ( [number] ) [EOL] output = OutputLayer ( [ [number] , [number] , [number] ] ) [EOL] [EOL] network = Network ( [ inputs , middle , output ] , [string] ) [EOL] network . connect ( ) [EOL] network . load_learning_data ( learning_data ) [EOL] middle . connect_layer ( inputs_som , [string] ) [EOL] network . dump_cypher ( [string] , additional_neurons = inputs_som . neurons ) [EOL] [docstring]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 $_csv._reader$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ComputationalIntelligence.awesome_neural.models.som.InputSom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $ComputationalIntelligence.awesome_neural.models.som.InputSom$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $ComputationalIntelligence.awesome_neural.models.som.InputSom$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $ComputationalIntelligence.awesome_neural.models.som.InputSom$ 0 0 0 0 0
import builtins [EOL] from typing import Any , Counter , List , Dict , Tuple [EOL] import collections [EOL] import typing [EOL] import _csv [EOL] import csv [EOL] from collections import Counter [EOL] [EOL] from core . layer import Layer , InputLayer , OutputLayer [EOL] from core . network import Network [EOL] [EOL] [EOL] iris_map = { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } [EOL] [EOL] learning_data = [ ] [EOL] [EOL] with open ( [string] , newline = [string] ) as csvfile : [EOL] reader = csv . reader ( csvfile ) [EOL] for row in reader : [EOL] learning_data . append ( { [string] : [ float ( x ) for x in row [ [number] : [number] ] ] , [string] : iris_map [ row [ [number] ] ] } ) [EOL] [EOL] inputs = InputLayer ( [ [number] , [number] , [number] , [number] ] ) [EOL] middle = Layer ( [number] ) [EOL] middle2 = Layer ( [number] ) [EOL] output = OutputLayer ( [ [number] , [number] , [number] ] ) [EOL] [EOL] network = Network ( [ inputs , middle , middle2 , output ] ) [EOL] network . connect ( ) [EOL] [EOL] network . load_learning_data ( learning_data ) [EOL] network . normalize_learning_data ( ) [EOL] print ( [string] ) [EOL] network . print_data ( ) [EOL] [EOL] [comment] [EOL] folds = [number] [EOL] results = network . learn_kfolds ( folds , times = [number] ) [EOL] scores = [ ( n , [ round ( x ) for x in out ] == check ) for n , out , check in results ] [EOL] stuff = Counter ( scores ) [EOL] print ( [string] , [ stuff [ ( i , True ) ] / ( stuff [ ( i , False ) ] + stuff [ ( i , True ) ] ) * [number] for i in range ( folds ) ] ) [EOL] [EOL] i = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] o = [ network . test ( io ) for io in i ] [EOL] network . print_io ( i , o , output_names = [ [string] , [string] , [string] ] ) [EOL] [EOL] network . dump_network ( [string] , prompt = True )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.float]]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import ComputationalIntelligence [EOL] import iris [EOL] import csv [EOL] import typing [EOL] import csv [EOL] from pprint import pprint [EOL] from copy import deepcopy [EOL] [EOL] iris_map = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] class Iris : [EOL] def __init__ ( self , class_name , petal_length , sepal_length , petal_width , sepal_width ) : [EOL] self . class_name = class_name [EOL] self . petal_length = petal_length [EOL] self . petal_width = petal_width [EOL] self . sepal_length = sepal_length [EOL] self . sepal_width = sepal_width [EOL] [EOL] self . weight = [number] [EOL] [EOL] self . params = { [string] : iris_map [ self . class_name ] , [string] : self . petal_length , [string] : self . petal_width , [string] : self . sepal_length , [string] : self . sepal_width } [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( id ( self ) , self . class_name , self . petal_length , self . petal_width , self . sepal_length , self . sepal_width ) [EOL] [EOL] def load_data ( filename ) : [EOL] params = { } [EOL] irises = [ ] [EOL] with open ( filename , newline = [string] ) as csvfile : [EOL] reader = csv . DictReader ( csvfile ) [EOL] for row in reader : [EOL] iris = Iris ( row [ [string] ] , row [ [string] ] , row [ [string] ] , row [ [string] ] , row [ [string] ] ) [EOL] irises . append ( iris ) [EOL] for key in row . keys ( ) : [EOL] if key not in params : [EOL] params [ key ] = { } [EOL] for key , val in row . items ( ) : [EOL] if val not in params [ key ] and val . startswith ( [string] ) : [EOL] params [ key ] [ iris_map [ val ] ] = [ ] [EOL] elif val not in params [ key ] : [EOL] params [ key ] [ val ] = [ ] [EOL] if val . startswith ( [string] ) : [EOL] params [ key ] [ iris_map [ val ] ] . append ( iris ) [EOL] else : [EOL] params [ key ] [ val ] . append ( iris ) [EOL] return params , irises [EOL] [EOL] def calculate_weights ( params , iris ) : [EOL] weights = deepcopy ( params ) [EOL] iris . weight = [number] [EOL] [comment] [EOL] iri_value = { [string] : iris_map [ iris . class_name ] } [EOL] for param in params : [EOL] for value in params [ param ] : [EOL] if iris in params [ param ] [ value ] : [EOL] try : [EOL] iri_value [ param ] = float ( value ) [EOL] except ValueError : [EOL] iri_value [ param ] = iris_map [ value ] [EOL] weights [ param ] [ value ] = [number] [EOL] [EOL] for param in params : [EOL] mx = max ( [ float ( x ) for x in params [ param ] . keys ( ) ] ) [EOL] mn = min ( [ float ( x ) for x in params [ param ] . keys ( ) ] ) [EOL] print ( mx , mn ) [EOL] for value in params [ param ] : [EOL] if float ( value ) != iri_value [ param ] : [EOL] weights [ param ] [ value ] = [number] - abs ( float ( value ) - iri_value [ param ] ) / ( mx - mn ) [EOL] [EOL] return weights [EOL] [EOL] [EOL] def get_similarities ( weights , irises ) : [EOL] similarities = [ ] [EOL] [EOL] [EOL] for iris in irises : [EOL] tmp = [ ] [EOL] for param in weights : [EOL] if isinstance ( weights [ param ] [ iris . params [ param ] ] , float ) : [EOL] tmp . append ( iris . weight * weights [ param ] [ iris . params [ param ] ] ) [EOL] [EOL] similarities . append ( ( iris , round ( sum ( tmp ) * [number] , [number] ) ) ) [EOL] [EOL] return similarities [EOL] [EOL] [EOL] [EOL] params , irises = load_data ( [string] ) [EOL] [EOL] looking_for = irises [ [number] ] [EOL] [EOL] weights = calculate_weights ( params , looking_for ) [EOL] pprint ( weights ) [EOL] similar = sorted ( get_similarities ( weights , irises ) , key = lambda x : x [ [number] ] ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Generator , List , Dict , Union , Tuple [EOL] import typing [EOL] import _csv [EOL] import csv [EOL] [EOL] from core . network import load_network [EOL] [EOL] iris_map = { [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] , [string] : [ [number] , [number] , [number] ] } [EOL] [EOL] reverse_map = { ( ) : [string] , ( [number] , [number] , [number] ) : [string] , ( [number] , [number] , [number] ) : [string] , ( [number] , [number] , [number] ) : [string] , ( [number] , [number] , [number] ) : [string] } [EOL] [EOL] network = load_network ( [string] ) [EOL] [EOL] i = [ ] [EOL] diagnosis = [ ] [EOL] with open ( [string] , newline = [string] ) as csvfile : [EOL] reader = csv . reader ( csvfile ) [EOL] for n , row in enumerate ( reader ) : [EOL] i . append ( [ float ( x ) for x in row [ [number] : [number] ] ] ) [EOL] diagnosis . append ( ( n , row [ [number] ] ) ) [EOL] o = [ network . test ( io ) for io in i ] [EOL] [EOL] [comment] [EOL] good = [number] [EOL] bad = [number] [EOL] for tup , out in zip ( diagnosis , o ) : [EOL] _ , name = tup [EOL] outtup = ( round ( x ) for x in out ) [EOL] print ( tuple ( outtup ) ) [EOL] if name == reverse_map [ tuple ( outtup ) ] : [EOL] good += [number] [EOL] else : [EOL] bad += [number] [EOL] [EOL] print ( [string] % ( good , bad , good + bad ) ) [EOL] print ( [string] % ( good / ( good + bad ) * [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 $_csv._reader$ 0 0 0 0 0 0 0 0 0 0 0 $_csv._reader$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.int,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.int,None,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.int,None,None]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import numpy as np [EOL] import matplotlib . pyplot as plt [EOL] import h5py [EOL] import scipy [EOL] from PIL import Image [EOL] from scipy import ndimage [EOL] from lr_utils import load_dataset [EOL] import math [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] train_set_x_orig , train_set_y , test_set_x_orig , test_set_y , classes = load_dataset ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] index = [number] [EOL] plt . imshow ( train_set_x_orig [ index ] ) [EOL] print ( [string] + str ( train_set_y [ : , index ] ) + [string] + classes [ np . squeeze ( train_set_y [ : , index ] ) ] . decode ( [string] ) + [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] m_train = train_set_x_orig . shape [ [number] ] [EOL] m_test = test_set_x_orig . shape [ [number] ] [EOL] num_px = test_set_x_orig . shape [ [number] ] [EOL] [EOL] print ( [string] + str ( m_train ) ) [EOL] print ( [string] + str ( m_test ) ) [EOL] print ( [string] + str ( num_px ) ) [EOL] print ( [string] + str ( num_px ) + [string] + str ( num_px ) + [string] ) [EOL] print ( [string] + str ( train_set_x_orig . shape ) ) [EOL] print ( [string] + str ( train_set_y . shape ) ) [EOL] print ( [string] + str ( test_set_x_orig . shape ) ) [EOL] print ( [string] + str ( test_set_y . shape ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] train_set_x_flatten = train_set_x_orig . reshape ( ( num_px * num_px * [number] , m_train ) ) [EOL] test_set_x_flatten = test_set_x_orig . reshape ( ( num_px * num_px * [number] , m_test ) ) [EOL] [EOL] print ( [string] + str ( train_set_x_flatten . shape ) ) [EOL] print ( [string] + str ( train_set_y . shape ) ) [EOL] print ( [string] + str ( test_set_x_flatten . shape ) ) [EOL] print ( [string] + str ( test_set_y . shape ) ) [EOL] print ( [string] + str ( train_set_x_flatten [ [number] : [number] , [number] ] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] train_set_x = train_set_x_flatten / [number] [EOL] test_set_x = test_set_x_flatten / [number] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def sigmoid ( z ) : [EOL] [docstring] [EOL] [EOL] return [number] / ( [number] + np . exp ( - [number] * z ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] print ( [string] + str ( sigmoid ( np . array ( [ [number] , [number] ] ) ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def initialize_with_zeros ( dim ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] w = np . zeros ( ( dim , [number] ) ) [EOL] b = [number] [EOL] [comment] [EOL] [EOL] assert ( w . shape == ( dim , [number] ) ) [EOL] assert ( isinstance ( b , float ) or isinstance ( b , int ) ) [EOL] [EOL] return w , b [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] dim = [number] [EOL] w , b = initialize_with_zeros ( dim ) [EOL] print ( [string] + str ( w ) ) [EOL] print ( [string] + str ( b ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def propagate ( w , b , X , Y ) : [EOL] [docstring] [EOL] [EOL] m = X . shape [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] A = sigmoid ( np . dot ( w . T , X ) + b ) [EOL] [comment] [EOL] cost = ( - [number] / m ) * sum ( [ Y [ [number] ] [ i ] * math . log ( A [ [number] ] [ i ] ) + ( [number] - Y [ [number] ] [ i ] ) * math . log ( [number] - A [ [number] ] [ i ] ) for i in range ( [number] , m ) ] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] dw = ( [number] / m ) * np . dot ( X , ( ( A - Y ) . T ) ) [EOL] db = ( [number] / m ) * sum ( [ A [ [number] ] [ i ] - Y [ [number] ] [ i ] for i in range ( m ) ] ) [EOL] [comment] [EOL] assert ( db . dtype == float ) [EOL] [comment] [EOL] [EOL] cost = np . squeeze ( cost ) [EOL] assert ( cost . shape == ( ) ) [EOL] [EOL] grads = { [string] : dw , [string] : db } [EOL] [EOL] return grads , cost [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] w , b , X , Y = np . array ( [ [ [number] ] , [ [number] ] ] ) , [number] , np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) , np . array ( [ [ [number] , [number] ] ] ) [EOL] grads , cost = propagate ( w , b , X , Y ) [EOL] print ( [string] + str ( grads [ [string] ] ) ) [EOL] print ( [string] + str ( grads [ [string] ] ) ) [EOL] print ( [string] + str ( cost ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def optimize ( w , b , X , Y , num_iterations , learning_rate , print_cost = False ) : [EOL] [docstring] [EOL] [EOL] costs = [ ] [EOL] [EOL] for i in range ( num_iterations ) : [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] grads , cost = propagate ( w , b , X , Y ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] dw = grads [ [string] ] [EOL] db = grads [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] w = w - learning_rate * dw [EOL] b = b - learning_rate * db [EOL] [comment] [EOL] [EOL] [comment] [EOL] if i % [number] == [number] : [EOL] costs . append ( cost ) [EOL] [EOL] [comment] [EOL] if print_cost and i % [number] == [number] : [EOL] print ( [string] % ( i , cost ) ) [EOL] [EOL] params = { [string] : w , [string] : b } [EOL] [EOL] grads = { [string] : dw , [string] : db } [EOL] [EOL] return params , grads , costs [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] params , grads , costs = optimize ( w , b , X , Y , num_iterations = [number] , learning_rate = [number] , print_cost = False ) [EOL] [EOL] print ( [string] + str ( params [ [string] ] ) ) [EOL] print ( [string] + str ( params [ [string] ] ) ) [EOL] print ( [string] + str ( grads [ [string] ] ) ) [EOL] print ( [string] + str ( grads [ [string] ] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def predict ( w , b , X ) : [EOL] [docstring] [EOL] [EOL] m = X . shape [ [number] ] [EOL] Y_prediction = np . zeros ( ( [number] , m ) ) [EOL] w = w . reshape ( X . shape [ [number] ] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] A = sigmoid ( np . dot ( w . T , X ) + b ) [EOL] [comment] [EOL] [EOL] for i in range ( A . shape [ [number] ] ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] Y_prediction [ [number] , i ] = [number] if A [ [number] , i ] > [number] else [number] [EOL] [comment] [EOL] assert ( Y_prediction . shape == ( [number] , m ) ) [EOL] [EOL] return Y_prediction [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] print ( [string] + str ( predict ( w , b , X ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def model ( X_train , Y_train , X_test , Y_test , num_iterations = [number] , learning_rate = [number] , print_cost = False ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] num_px = test_set_x_orig . shape [ [number] ] [EOL] w , b = initialize_with_zeros ( num_px * num_px * [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] parameters , grads , costs = optimize ( w , b , X_train , Y_train , num_iterations , learning_rate , print_cost ) [EOL] [EOL] [comment] [EOL] w = parameters [ [string] ] [EOL] b = parameters [ [string] ] [EOL] [EOL] [comment] [EOL] Y_prediction_test = predict ( w , b , X_test ) [EOL] Y_prediction_train = predict ( w , b , X_train ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] print ( [string] . format ( [number] - np . mean ( np . abs ( Y_prediction_train - Y_train ) ) * [number] ) ) [EOL] print ( [string] . format ( [number] - np . mean ( np . abs ( Y_prediction_test - Y_test ) ) * [number] ) ) [EOL] [EOL] [EOL] d = { [string] : costs , [string] : Y_prediction_test , [string] : Y_prediction_train , [string] : w , [string] : b , [string] : learning_rate , [string] : num_iterations } [EOL] [EOL] return d [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] d = model ( train_set_x , train_set_y , test_set_x , test_set_y , num_iterations = [number] , learning_rate = [number] , print_cost = True ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] costs = np . squeeze ( d [ [string] ] ) [EOL] plt . plot ( costs ) [EOL] plt . ylabel ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . title ( [string] + str ( d [ [string] ] ) ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] import h5py [EOL] [EOL] [EOL] def load_dataset ( ) : [EOL] train_dataset = h5py . File ( [string] , [string] ) [EOL] train_set_x_orig = np . array ( train_dataset [ [string] ] [ : ] ) [comment] [EOL] train_set_y_orig = np . array ( train_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] test_dataset = h5py . File ( [string] , [string] ) [EOL] test_set_x_orig = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] test_set_y_orig = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] classes = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] train_set_y_orig = train_set_y_orig . reshape ( ( [number] , train_set_y_orig . shape [ [number] ] ) ) [EOL] test_set_y_orig = test_set_y_orig . reshape ( ( [number] , test_set_y_orig . shape [ [number] ] ) ) [EOL] [EOL] return train_set_x_orig , train_set_y_orig , test_set_x_orig , test_set_y_orig , classes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] import math [EOL] import numpy as np [EOL] import h5py [EOL] import matplotlib . pyplot as plt [EOL] import tensorflow as tf [EOL] from tensorflow . python . framework import ops [EOL] [EOL] def load_dataset ( ) : [EOL] train_dataset = h5py . File ( [string] , [string] ) [EOL] train_set_x_orig = np . array ( train_dataset [ [string] ] [ : ] ) [comment] [EOL] train_set_y_orig = np . array ( train_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] test_dataset = h5py . File ( [string] , [string] ) [EOL] test_set_x_orig = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] test_set_y_orig = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] classes = np . array ( test_dataset [ [string] ] [ : ] ) [comment] [EOL] [EOL] train_set_y_orig = train_set_y_orig . reshape ( ( [number] , train_set_y_orig . shape [ [number] ] ) ) [EOL] test_set_y_orig = test_set_y_orig . reshape ( ( [number] , test_set_y_orig . shape [ [number] ] ) ) [EOL] [EOL] return train_set_x_orig , train_set_y_orig , test_set_x_orig , test_set_y_orig , classes [EOL] [EOL] [EOL] def random_mini_batches ( X , Y , mini_batch_size = [number] , seed = [number] ) : [EOL] [docstring] [EOL] [EOL] m = X . shape [ [number] ] [comment] [EOL] mini_batches = [ ] [EOL] np . random . seed ( seed ) [EOL] [EOL] [comment] [EOL] permutation = list ( np . random . permutation ( m ) ) [EOL] shuffled_X = X [ permutation , : , : , : ] [EOL] shuffled_Y = Y [ permutation , : ] [EOL] [EOL] [comment] [EOL] num_complete_minibatches = math . floor ( m / mini_batch_size ) [comment] [EOL] for k in range ( [number] , num_complete_minibatches ) : [EOL] mini_batch_X = shuffled_X [ k * mini_batch_size : k * mini_batch_size + mini_batch_size , : , : , : ] [EOL] mini_batch_Y = shuffled_Y [ k * mini_batch_size : k * mini_batch_size + mini_batch_size , : ] [EOL] mini_batch = ( mini_batch_X , mini_batch_Y ) [EOL] mini_batches . append ( mini_batch ) [EOL] [EOL] [comment] [EOL] if m % mini_batch_size != [number] : [EOL] mini_batch_X = shuffled_X [ num_complete_minibatches * mini_batch_size : m , : , : , : ] [EOL] mini_batch_Y = shuffled_Y [ num_complete_minibatches * mini_batch_size : m , : ] [EOL] mini_batch = ( mini_batch_X , mini_batch_Y ) [EOL] mini_batches . append ( mini_batch ) [EOL] [EOL] return mini_batches [EOL] [EOL] [EOL] def convert_to_one_hot ( Y , C ) : [EOL] Y = np . eye ( C ) [ Y . reshape ( - [number] ) ] . T [EOL] return Y [EOL] [EOL] [EOL] def forward_propagation_for_predict ( X , parameters ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] W1 = parameters [ [string] ] [EOL] b1 = parameters [ [string] ] [EOL] W2 = parameters [ [string] ] [EOL] b2 = parameters [ [string] ] [EOL] W3 = parameters [ [string] ] [EOL] b3 = parameters [ [string] ] [EOL] [comment] [EOL] Z1 = tf . add ( tf . matmul ( W1 , X ) , b1 ) [comment] [EOL] A1 = tf . nn . relu ( Z1 ) [comment] [EOL] Z2 = tf . add ( tf . matmul ( W2 , A1 ) , b2 ) [comment] [EOL] A2 = tf . nn . relu ( Z2 ) [comment] [EOL] Z3 = tf . add ( tf . matmul ( W3 , A2 ) , b3 ) [comment] [EOL] [EOL] return Z3 [EOL] [EOL] def predict ( X , parameters ) : [EOL] [EOL] W1 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] b1 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] W2 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] b2 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] W3 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] b3 = tf . convert_to_tensor ( parameters [ [string] ] ) [EOL] [EOL] params = { [string] : W1 , [string] : b1 , [string] : W2 , [string] : b2 , [string] : W3 , [string] : b3 } [EOL] [EOL] x = tf . placeholder ( [string] , [ [number] , [number] ] ) [EOL] [EOL] z3 = forward_propagation_for_predict ( x , params ) [EOL] p = tf . argmax ( z3 ) [EOL] [EOL] sess = tf . Session ( ) [EOL] prediction = sess . run ( p , feed_dict = { x : X } ) [EOL] [EOL] return prediction [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] import pandas as pd [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] df0 = pd . read_csv ( [string] , names = [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] print ( df0 . head ( n = [number] ) , [string] ) [EOL] [EOL] print ( [string] ) [EOL] print ( df0 [ [string] ] . value_counts ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] df_raw = df0 . copy ( ) [EOL] df_raw [ [string] ] = [ [number] if b == [string] else [number] for b in df_raw . balance ] [EOL] [EOL] print ( [string] ) [EOL] print ( df_raw [ [string] ] . value_counts ( ) , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] from sklearn . linear_model import LogisticRegression [EOL] from sklearn . metrics import accuracy_score [EOL] [EOL] [comment] [EOL] X_raw = df_raw . drop ( [string] , axis = [number] ) [EOL] y_raw = df_raw . balance [EOL] [EOL] [comment] [EOL] clf_raw = LogisticRegression ( ) . fit ( X_raw , y_raw ) [EOL] [EOL] [comment] [EOL] y_pred_raw = clf_raw . predict ( X_raw ) [EOL] [EOL] acc_original = accuracy_score ( y_pred_raw , y_raw ) [EOL] print ( [string] . format ( acc_original ) ) [EOL] print ( [string] , np . unique ( y_pred_raw ) , [string] ) [EOL] [EOL] [comment] [EOL] [EOL] from sklearn . utils import resample [EOL] [EOL] [comment] [EOL] df_majority = df_raw [ df_raw . balance == [number] ] [EOL] df_minority = df_raw [ df_raw . balance == [number] ] [EOL] [EOL] [comment] [EOL] df_minority_upsampled = resample ( df_minority , replace = True , n_samples = df_majority . shape [ [number] ] , random_state = [number] ) [comment] [EOL] [EOL] [comment] [EOL] df_upsampled = pd . concat ( [ df_majority , df_minority_upsampled ] ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( df_upsampled . balance . value_counts ( ) , [string] ) [EOL] [EOL] [comment] [EOL] X_sample = df_upsampled . drop ( [string] , axis = [number] ) [EOL] y_sample = df_upsampled . balance [EOL] [EOL] [comment] [EOL] clf_sample = LogisticRegression ( ) . fit ( X_sample , y_sample ) [EOL] [EOL] [comment] [EOL] y_pred_sample = clf_sample . predict ( X_sample ) [EOL] [EOL] print ( [string] . format ( accuracy_score ( y_sample , y_pred_sample ) ) ) [EOL] print ( [string] , np . unique ( y_pred_sample ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pandas as pd [EOL] [EOL] from sklearn import datasets [EOL] [EOL] from sklearn . model_selection import train_test_split [EOL] [EOL] from sklearn . neighbors import KNeighborsClassifier [EOL] from sklearn . metrics import accuracy_score , classification_report [EOL] [EOL] from sklearn . preprocessing import StandardScaler [EOL] [EOL] [comment] [EOL] [EOL] n_neighbors = [number] [EOL] [EOL] [comment] [EOL] [EOL] dataset = datasets . load_wine ( ) [EOL] X_raw = pd . DataFrame ( data = dataset . data , columns = dataset . feature_names ) [EOL] y = pd . DataFrame ( data = dataset . target , columns = [ [string] ] ) [EOL] [EOL] [comment] [EOL] X_train_raw , X_test_raw , y_train , y_test = train_test_split ( X_raw , y , test_size = [number] , stratify = y , random_state = [number] ) [EOL] [comment] [EOL] [EOL] [EOL] clf_raw = KNeighborsClassifier ( n_neighbors = n_neighbors ) . fit ( X_train_raw , y_train . values . ravel ( ) ) [EOL] [EOL] y_test_pred_raw = clf_raw . predict ( X_test_raw ) [EOL] [EOL] print ( [string] ) [EOL] acc_raw = accuracy_score ( y_test_pred_raw , y_test ) [EOL] print ( [string] . format ( acc_raw ) , [string] ) [EOL] print ( [string] , classification_report ( y_test , y_test_pred_raw ) ) [EOL] [EOL] [comment] [EOL] [EOL] scaler = StandardScaler ( ) . fit ( X_raw ) [EOL] X_scaled = X_raw . copy ( ) [EOL] X_scaled . iloc [ : , : ] = scaler . transform ( X_raw ) [EOL] [EOL] [EOL] [comment] [EOL] X_train_scaled , X_test_scaled , y_train , y_test = train_test_split ( X_scaled , y , test_size = [number] , stratify = y , random_state = [number] ) [EOL] [EOL] clf_scaled = KNeighborsClassifier ( n_neighbors = n_neighbors ) . fit ( X_train_scaled , y_train . values . ravel ( ) ) [EOL] [EOL] y_test_pred_scaled = clf_scaled . predict ( X_test_scaled ) [EOL] [EOL] print ( [string] ) [EOL] acc_scaled = accuracy_score ( y_test_pred_scaled , y_test ) [EOL] print ( [string] . format ( acc_scaled ) , [string] ) [EOL] print ( [string] , classification_report ( y_test , y_test_pred_scaled ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from sklearn import datasets [EOL] from sklearn . linear_model import LogisticRegression [EOL] from sklearn . model_selection import cross_val_score [EOL] [EOL] iris = datasets . load_iris ( ) [EOL] lg = LogisticRegression ( random_state = [number] ) [EOL] [EOL] res = cross_val_score ( lg , iris . data , iris . target , cv = [number] ) [EOL] print ( res ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pandas as pd [EOL] import numpy as np [EOL] from sklearn import datasets [EOL] from sklearn . feature_selection import RFE [EOL] from sklearn . linear_model import LogisticRegression [EOL] [EOL] [comment] [EOL] dataset = datasets . load_iris ( ) [EOL] [EOL] [comment] [EOL] model = LogisticRegression ( ) [EOL] [EOL] X_all = dataset . data [EOL] y = dataset . target [EOL] [EOL] [comment] [EOL] [EOL] fmodel = model . fit ( X_all , y ) [EOL] [EOL] acc_all = fmodel . score ( X_all , y ) [EOL] print ( [string] . format ( acc_all ) ) [EOL] [EOL] [comment] [EOL] [EOL] n_features = [number] [EOL] rfe = RFE ( fmodel , n_features , step = [number] ) . fit ( X_all , y ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] feature_rank = pd . DataFrame ( np . column_stack ( [ dataset . feature_names , rfe . ranking_ , rfe . support_ ] ) , columns = [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] x_df = pd . DataFrame ( X_all ) [EOL] X_filt = x_df [ x_df . columns [ rfe . support_ ] ] [EOL] [EOL] [comment] [EOL] fmodel2 = model . fit ( X_filt , y ) [EOL] [EOL] acc_all2 = fmodel . score ( X_filt , y ) [EOL] print ( [string] . format ( acc_all2 ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Optional [EOL] import geom [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] from math import sqrt [EOL] [EOL] from geom import Point [EOL] [EOL] [EOL] class Vector : [EOL] def __init__ ( self , p1 , p2 = None ) : [EOL] if p2 is not None : [EOL] self . x = p2 . x - p1 . x [EOL] self . y = p2 . y - p1 . y [EOL] self . z = p2 . z - p1 . z [EOL] else : [EOL] self . x = p1 . x [EOL] self . y = p1 . y [EOL] self . z = p1 . z [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Vector ( Point ( self . x + other . x , self . y + other . y , self . z + other . z ) ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return Vector ( Point ( self . x - other . x , self . y - other . y , self . z - other . z ) ) [EOL] [EOL] def length ( self ) : [EOL] return sqrt ( self . x ** [number] + self . y ** [number] + self . z ** [number] ) [EOL] [EOL] def __mul__ ( self , other ) : [EOL] if isinstance ( other , ( int , float ) ) : [EOL] return Vector ( Point ( self . x * other , self . y * other , self . z * other ) ) [EOL] [EOL] def __truediv__ ( self , other ) : [EOL] if isinstance ( other , ( int , float ) ) : [EOL] return Vector ( Point ( self . x / other , self . y / other , self . z / other ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . x } [string] { self . y } [string] { self . z } [string] " [EOL] [EOL] [EOL] def dot ( v1 , v2 ) : [EOL] return v1 . x * v2 . x + v1 . y * v2 . y + v1 . z * v2 . z [EOL] [EOL] [EOL] def cross ( v1 , v2 ) : [EOL] return Vector ( Point ( v1 . z * v2 . y , v1 . x * v2 . z , v1 . y * v2 . x ) , Point ( v1 . y * v2 . z , v1 . z * v2 . x , v1 . x * v2 . y ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 $'Vector'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from typing import List [EOL] [EOL] [EOL] @ dataclass class Point : [EOL] x = ... [EOL] y = ... [EOL] z = ... [EOL] [EOL] def __add__ ( self , other ) : [EOL] import vec [EOL] if isinstance ( other , vec . Vector ) : [EOL] return Point ( self . x + other . x , self . y + other . y , self . z + other . z ) [EOL] [EOL] [EOL] @ dataclass class Edge : [EOL] p1 = ... [EOL] p2 = ... [EOL] [EOL] [EOL] @ dataclass class Face : [EOL] p1 = ... [EOL] p2 = ... [EOL] p3 = ... [EOL] [EOL] @ property def edges ( self ) : [EOL] return [ Edge ( self . p1 , self . p2 ) , Edge ( self . p2 , self . p3 ) , Edge ( self . p1 , self . p3 ) ] [EOL] [EOL] [EOL] @ dataclass class Solid : [EOL] faces = field ( default_factory = list ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Point$ 0 0 0 $Point$ 0 0 0 0 0 0 0 0 0 0 0 $Point$ 0 0 0 $Point$ 0 0 0 $Point$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Face]$ 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import geom [EOL] import typing [EOL] import builtins [EOL] import re [EOL] import itertools [EOL] from math import sqrt [EOL] from multimethod import multimethod [EOL] [EOL] from geom import Point , Edge , Face , Solid [EOL] from vec import Vector , cross , dot [EOL] [EOL] [EOL] def import_data ( filename ) : [EOL] lines = open ( filename , [string] ) . read ( ) [EOL] solids = re . split ( [string] , lines ) [EOL] return [ Solid ( [ Face ( * [ Point ( * [ float ( p ) for p in point . split ( [string] ) ] ) for point in face . split ( [string] ) if len ( point ) != [number] ] ) for face in solid . split ( [string] ) if face != [string] ] ) for solid in solids if solid != [string] ] [EOL] [EOL] [EOL] @ multimethod def distance ( a , b ) : [EOL] [comment] [EOL] return sqrt ( ( a . x - b . x ) ** [number] + ( a . y - b . y ) ** [number] + ( a . z - b . z ) ** [number] ) [EOL] [EOL] [EOL] @ multimethod def distance ( a , b ) : [EOL] [comment] [EOL] ae1 , ae2 , ae3 = a . edges [EOL] be1 , be2 , be3 = b . edges [EOL] distances = [ distance ( a , b . p1 ) , distance ( a , b . p2 ) , distance ( a , b . p3 ) , distance ( b , a . p1 ) , distance ( b , a . p2 ) , distance ( b , a . p3 ) , distance ( ae1 , be1 ) , distance ( ae1 , be2 ) , distance ( ae1 , be3 ) , distance ( ae2 , be1 ) , distance ( ae2 , be2 ) , distance ( ae2 , be3 ) , distance ( ae3 , be1 ) , distance ( ae3 , be2 ) , distance ( ae3 , be3 ) ] [EOL] return min ( distances ) [EOL] [EOL] [EOL] @ multimethod def distance ( f , p ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] np = cross ( Vector ( f . p1 , f . p2 ) , Vector ( f . p1 , f . p3 ) ) [EOL] [EOL] [comment] [EOL] cosa = dot ( Vector ( f . p1 , p ) , np ) / ( np . length ( ) * Vector ( f . p1 , p ) . length ( ) ) [EOL] [EOL] [comment] [EOL] p0p0l = Vector ( p , f . p1 ) . length ( ) * cosa [EOL] [EOL] [comment] [EOL] p0p0p = np * ( ( - [number] ) * (p0p0l) / np . length ( ) ) [EOL] [EOL] [comment] [EOL] p0p = p + p0p0p [EOL] [EOL] [comment] [EOL] area = cross ( Vector ( f . p1 , f . p2 ) , Vector ( f . p1 , f . p3 ) ) . length ( ) / [number] [EOL] a = cross ( Vector ( p0p , f . p2 ) , Vector ( p0p , f . p3 ) ) . length ( ) / ( [number] * area ) [EOL] b = cross ( Vector ( p0p , f . p3 ) , Vector ( p0p , f . p1 ) ) . length ( ) / ( [number] * area ) [EOL] c = [number] - a - b [EOL] [EOL] if [number] <= a <= [number] and [number] <= b <= [number] and [number] <= c <= [number] : [EOL] return sqrt ( dot ( p0p0p , p0p0p ) ) [EOL] else : [EOL] e1 = Edge ( f . p1 , f . p2 ) [EOL] e2 = Edge ( f . p2 , f . p3 ) [EOL] e3 = Edge ( f . p1 , f . p3 ) [EOL] [EOL] return min ( distance ( e1 , p ) , distance ( e2 , p ) , distance ( e3 , p ) , distance ( f . p1 , p ) , distance ( f . p2 , p ) , distance ( f . p3 , p ) ) [EOL] [EOL] [EOL] @ multimethod def distance ( a , b ) : [EOL] distances = [ distance ( f1 , f2 ) for f1 , f2 in itertools . product ( a . faces , b . faces ) ] [EOL] return min ( distances ) [EOL] [EOL] [EOL] @ multimethod def distance ( e , p ) : [EOL] [comment] [EOL] v = Vector ( e . p1 , e . p2 ) [EOL] w = Vector ( e . p1 , p ) [EOL] c1 = dot ( w , v ) [EOL] c2 = dot ( v , v ) [EOL] b = c1 / c2 [EOL] pb = Point ( e . p1 . x + b * v . x , e . p1 . y + b * v . y , e . p1 . z + b * v . z ) [EOL] [EOL] if c1 <= [number] : [EOL] return distance ( p , e . p1 ) [EOL] if c2 <= c1 : [EOL] return distance ( p , e . p2 ) [EOL] return distance ( p , pb ) [EOL] [EOL] [EOL] @ multimethod def distance ( e1 , e2 ) : [EOL] [comment] [EOL] SMALL_NUM = [number] [EOL] u , v , w = Vector ( e1 . p1 , e1 . p2 ) , Vector ( e2 . p1 , e2 . p2 ) , Vector ( e2 . p1 , e1 . p1 ) [EOL] a , b , c , d , e = dot ( u , u ) , dot ( u , v ) , dot ( v , v ) , dot ( u , w ) , dot ( v , w ) [EOL] D = a * c - b * b [EOL] sc , sN , sD = D , D , D [EOL] tc , tN , tD = D , D , D [EOL] [EOL] if D < SMALL_NUM : [EOL] sN , sD = [number] , [number] [EOL] tN , tD = e , c [EOL] else : [EOL] sN , tN = ( b * e - c * d ) , ( a * e - b * d ) [EOL] if sN < [number] : [EOL] sN , tN , tD = [number] , e , c [EOL] elif sN > sD : [EOL] sN , tN , tD = sD , e + b , c [EOL] if tN < [number] : [EOL] tN = [number] [EOL] if - d < [number] : [EOL] sN = [number] [EOL] elif - d > a : [EOL] sN = sD [EOL] else : [EOL] sN , sD = - d , a [EOL] elif tN > tD : [EOL] tN = tD [EOL] if ( - d + b ) < [number] : [EOL] sN = [number] [EOL] elif ( - d + b ) > a : [EOL] sN = sD [EOL] else : [EOL] sN , sD = ( - d + b ) , a [EOL] [EOL] sc = sN / sD [EOL] tc = tN / tD [EOL] dP = w + ( u * sc ) - ( v * tc ) [EOL] return dP . length ( ) [EOL] [EOL] [EOL] @ multimethod def distance ( a , b ) : [EOL] eb1 , eb2 , eb3 = b . edges [EOL] return min ( distance ( a , eb1 ) , distance ( a , eb2 ) , distance ( a , eb3 ) , distance ( a , b . p1 ) , distance ( a , b . p2 ) , distance ( a , b . p3 ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] solids = import_data ( [string] ) [EOL] print ( [string] , distance ( solids [ [number] ] , solids [ [number] ] ) ) [EOL] print ( [string] , distance ( Face ( Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) ) , Face ( Point ( [number] , [number] , [number] ) , Point ( [number] , [number] , [number] ) , Point ( - [number] , - [number] , [number] ) ) ) ) [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import builtins [EOL] import multiprocessing [EOL] import json [EOL] import time [EOL] import math [EOL] import multiprocessing [EOL] from pandas import DataFrame [EOL] [EOL] from typing import List , Tuple [EOL] from functools import reduce [EOL] [EOL] matrix = List [ List [ float ] ] [EOL] [EOL] [EOL] def timeit ( method ) : [EOL] [EOL] def timed ( * args , ** kw ) : [EOL] ts = time . time ( ) [EOL] result = method ( * args , ** kw ) [EOL] te = time . time ( ) [EOL] [EOL] print ( [string] % ( method . __name__ , te - ts ) ) [EOL] return result [EOL] [EOL] return timed [EOL] [EOL] [EOL] def mul_s ( x , y ) : [EOL] return [ [ sum ( a * b for a , b in zip ( x_row , y_col ) ) for y_col in zip ( * y ) ] for x_row in x ] [EOL] [EOL] [EOL] @ timeit def mul_all ( m_list ) : [EOL] return reduce ( mul_s , m_list ) [EOL] [EOL] [EOL] def chunks ( l , n ) : [EOL] for i in range ( [number] , len ( l ) , n ) : [EOL] yield l [ i : i + n ] [EOL] [EOL] [EOL] def generate_tasks ( to_multiply ) : [EOL] return list ( chunks ( to_multiply , [number] ) ) [EOL] [EOL] [EOL] def mul_st ( tup ) : [EOL] if len ( tup ) == [number] : [EOL] return mul_s ( * tup ) [EOL] else : [EOL] return tup [ [number] ] [EOL] [EOL] [EOL] @ timeit def after_pool ( m_list , pool ) : [EOL] tasks = generate_tasks ( m_list ) [EOL] while len ( tasks ) != [number] : [EOL] result = pool . map ( mul_st , tasks ) [EOL] tasks = generate_tasks ( result ) [EOL] return mul_st ( result ) [EOL] [EOL] [EOL] def mul_all_p ( m_list ) : [EOL] pool = multiprocessing . Pool ( multiprocessing . cpu_count ( ) ) [EOL] return after_pool ( m_list , pool ) [EOL] [EOL] [EOL] def flatten_matrix ( m_list ) : [EOL] return sum ( m_list , [ ] ) [EOL] [EOL] [EOL] x = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] y = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] z = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] [EOL] matrices = json . load ( open ( [string] , [string] ) ) [EOL] s1 , p1 = mul_all ( [ x , y , z ] ) , mul_all_p ( [ x , y , z ] ) [EOL] assert s1 == p1 [EOL] s2 , p2 = mul_all ( matrices ) , mul_all_p ( matrices ) [EOL] assert all ( [ math . isclose ( s , p ) for s , p in zip ( flatten_matrix ( s2 ) , flatten_matrix ( p2 ) ) ] ) [EOL] print ( DataFrame ( s2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $matrix$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $matrix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $matrix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] [EOL] command = [string] [EOL] [EOL] def parse_outputs ( directory ) : [EOL] experiments = dict ( ) [EOL] for file in os . listdir ( path = directory ) : [EOL] experiment_name = file . split ( [string] ) [ [number] ] [EOL] if experiment_name not in experiments : [EOL] experiments [ experiment_name ] = dict ( ) [EOL] [EOL] output = subprocess . check_output ( [ [string] , [string] , command . format ( directory + [string] + file , [string] ) ] ) [EOL] print ( output ) [EOL] [EOL] [EOL] parse_outputs ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import sys [EOL] import os [EOL] [EOL] import plotly . plotly as py [EOL] import plotly . graph_objs as go [EOL] [EOL] if not os . path . exists ( os . path . expanduser ( [string] ) ) : [EOL] print ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] values = [ float ( x ) for x in sys . stdin ] [EOL] [EOL] [comment] [EOL] trace = go . Scatter ( y = values , mode = sys . argv [ [number] ] if len ( sys . argv ) > [number] else [string] ) [EOL] [EOL] py . plot ( [ trace ] , filename = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any , Generator , Tuple [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] from more_itertools import chunked [EOL] from bidict import bidict [EOL] from typing import Tuple [EOL] [EOL] [docstring] [EOL] [EOL] DNA_LOOKUP = bidict ( { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , type = str ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] parser . add_argument ( [string] , [string] , help = [string] , action = [string] ) [EOL] args = parser . parse_args ( ) [EOL] return args . text , args . key , args . encrypt , args . decrypt [EOL] [EOL] [EOL] def prepare_key ( text , key ) : [EOL] [docstring] [EOL] return ( key * int ( ( len ( text ) / len ( key ) ) + [number] ) ) [ : len ( text ) ] [EOL] [EOL] [EOL] def left_pad ( number ) : [EOL] [docstring] [EOL] return ( [string] * ( [number] - len ( number ) ) ) + number [EOL] [EOL] [EOL] def encrypt ( text , key ) : [EOL] [docstring] [EOL] [EOL] binary = [string] . join ( [ left_pad ( format ( ord ( a ) ^ ord ( b ) , [string] ) ) for a , b in zip ( text , key ) ] ) [EOL] dna = [string] . join ( [ DNA_LOOKUP [ [string] . join ( chunk ) ] for chunk in chunked ( binary , [number] ) ] ) [EOL] return dna [EOL] [EOL] [EOL] def decrypt ( text , key ) : [EOL] [docstring] [EOL] reverse_dna = [string] . join ( [ DNA_LOOKUP . inv [ letter ] for letter in text ] ) [EOL] bin_string = ( reverse_dna [ i : i + [number] ] for i in range ( [number] , len ( reverse_dna ) , [number] ) ) [EOL] string = [string] . join ( chr ( int ( char , [number] ) ^ ord ( key ) ) for char , key in zip ( bin_string , key ) ) [EOL] return string [EOL] [EOL] [EOL] text , key , encryption , decryption = parse_args ( ) [EOL] key = prepare_key ( text , key ) [EOL] if encryption : [EOL] print ( encrypt ( text , key ) ) [EOL] if decryption : [EOL] print ( decrypt ( text , key ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.bool,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import random [EOL] [EOL] from mesa . visualization . modules import CanvasGrid [EOL] from mesa . visualization . ModularVisualization import ModularServer [EOL] [EOL] from shape_model . model import Walker , ShapesModel [EOL] [EOL] [EOL] def agent_draw ( agent ) : [EOL] portrayal = None [EOL] if agent is None : [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] elif isinstance ( agent , Walker ) : [EOL] print ( [string] . format ( agent . unique_id , agent . heading ) ) [EOL] portrayal = { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : agent . heading [ [number] ] , [string] : agent . heading [ [number] ] , [string] : agent . unique_id , [string] : [string] , [string] : [number] , } [EOL] if agent . type == [string] : [EOL] portrayal = { [string] : [string] , [string] : agent . pos [ [number] ] , [string] : agent . pos [ [number] ] , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [number] } [EOL] return portrayal [EOL] [EOL] [EOL] def launch_shape_model ( ) : [EOL] width = [number] [EOL] height = [number] [EOL] num_agents = [number] [EOL] pixel_ratio = [number] [EOL] grid = CanvasGrid ( agent_draw , width , height , width * pixel_ratio , height * pixel_ratio ) [EOL] server = ModularServer ( ShapesModel , [ grid ] , [string] , model_params = { [string] : num_agents , [string] : width , [string] : height } ) [EOL] server . max_steps = [number] [EOL] server . port = [number] [EOL] server . launch ( ) [EOL] [EOL] if __name__ == [string] : [EOL] random . seed ( [number] ) [EOL] launch_shape_model ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , List , Tuple , Dict [EOL] import typing [EOL] import AgentBasedModelling [EOL] import random [EOL] [EOL] from mesa import Model , Agent [EOL] from mesa . space import SingleGrid [EOL] from mesa . time import RandomActivation [EOL] [EOL] ID = [number] [EOL] [EOL] def load_scene ( filename , grid , model ) : [EOL] lines = open ( filename , [string] ) . readlines ( ) [EOL] types = { [string] : [string] , [string] : [string] } [EOL] for i , line in enumerate ( lines ) : [EOL] for j , char in enumerate ( line ) : [EOL] if char not in ( [string] , [string] ) : [EOL] grid . place_agent ( Walker ( [number] + i + j * i , model , ( j , - i ) , type = types [ char ] ) , ( j , - i ) ) [EOL] [EOL] [EOL] class Walker ( Agent ) : [EOL] def __init__ ( self , unique_id , model , pos , heading = ( [number] , [number] ) , type = [string] ) : [EOL] super ( ) . __init__ ( unique_id , model ) [EOL] self . type = type [EOL] self . pos = pos [EOL] self . heading = heading [EOL] self . headings = { ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , - [number] ) } [EOL] [EOL] [EOL] class ShapesModel ( Model ) : [EOL] def __init__ ( self , N , width = [number] , height = [number] ) : [EOL] self . running = True [EOL] self . N = N [comment] [EOL] self . headings = ( ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) , ( [number] , - [number] ) ) [comment] [EOL] self . grid = SingleGrid ( width , height , torus = False ) [EOL] self . schedule = RandomActivation ( self ) [EOL] load_scene ( [string] , self . grid , self ) [EOL] [docstring] [EOL] [EOL] def make_walls ( self ) : [EOL] for i in range ( [number] , [number] ) : [EOL] self . grid . place_agent ( Walker ( [number] , self , ( i , [number] ) , type = [string] ) , ( i , [number] ) ) [EOL] [EOL] [EOL] def make_walker_agents ( self ) : [EOL] unique_id = [number] [EOL] while True : [EOL] if unique_id == self . N : [EOL] break [EOL] x = random . randrange ( self . grid . width ) [EOL] y = random . randrange ( self . grid . height ) [EOL] pos = ( x , y ) [EOL] heading = random . choice ( self . headings ) [EOL] [comment] [EOL] if self . grid . is_cell_empty ( pos ) : [EOL] print ( [string] . format ( x , y , unique_id ) ) [EOL] a = Walker ( unique_id , self , pos , heading ) [EOL] self . schedule . add ( a ) [EOL] self . grid . place_agent ( a , ( x , y ) ) [EOL] self . grid . place_agent ( a , ( x + [number] , y ) ) [EOL] self . grid . place_agent ( a , ( x , y + [number] ) ) [EOL] self . grid . place_agent ( a , ( x + [number] , y + [number] ) ) [EOL] unique_id += [number] [EOL] [EOL] def step ( self ) : [EOL] self . schedule . step ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int],typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 0 $builtins.int$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.mesa.model.Walker$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import AgentBasedModelling [EOL] import builtins [EOL] import logging [EOL] import yaml [EOL] [EOL] from time import time [EOL] from typing import List , Optional [EOL] from dataclasses import dataclass [EOL] from car import Car [EOL] [EOL] [EOL] def load_config ( filename ) : [EOL] with open ( filename , [string] ) as yml_file : [EOL] return yaml . load ( yml_file ) [EOL] [EOL] [EOL] @ dataclass class TimeRange : [EOL] start = ... [EOL] end = ... [EOL] vin = ... [EOL] [EOL] def overlap ( self , other ) : [EOL] latest_start = max ( self . start , other . start ) [EOL] earliest_end = min ( self . end , other . end ) [EOL] delta = earliest_end - latest_start [EOL] overlap = max ( [number] , delta ) [EOL] return overlap [EOL] [EOL] def inside ( self , point ) : [EOL] return self . end > point > self . start [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . start == other . start and self . end == other . end and self . vin == other . vin [EOL] [EOL] [EOL] class Timeline : [EOL] def __init__ ( self ) : [EOL] self . timeline = [ ] [EOL] [EOL] def add_timespan ( self , start , end = None , duration = None , vin = None ) : [EOL] if end is not None and end > start : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] new_range = TimeRange ( start , end if end is not None else start + duration , vin ) [EOL] logging . debug ( f" [string] { vin } [string] { new_range }" ) [EOL] if any ( map ( lambda r : r . overlap ( new_range ) > [number] , self . timeline ) ) : [EOL] logging . debug ( f" [string] { self . timeline }" ) [EOL] return False [EOL] self . _insert_timespan ( new_range ) [EOL] return True [EOL] [EOL] def cancel_timespan ( self , start , end = None , duration = None , vin = None ) : [EOL] to_remove = TimeRange ( start , end if end is not None else start + duration , vin ) [EOL] self . timeline = [ e for e in self . timeline if e != to_remove ] [EOL] return True [EOL] [EOL] def within_reserved ( self , timestamp ) : [EOL] return any ( [ time_range . inside ( timestamp ) for time_range in self . timeline ] ) [EOL] [EOL] def _insert_timespan ( self , new_r ) : [EOL] logging . debug ( f" [string] { new_r }" ) [EOL] if self . timeline == [ ] : [EOL] logging . debug ( [string] ) [EOL] self . timeline = [ new_r ] [EOL] elif len ( self . timeline ) == [number] and new_r . end < self . timeline [ [number] ] . start : [EOL] logging . debug ( [string] ) [EOL] self . timeline . insert ( [number] , new_r ) [EOL] elif len ( self . timeline ) == [number] and new_r . start > self . timeline [ [number] ] . end : [EOL] self . timeline . append ( new_r ) [EOL] logging . debug ( [string] ) [EOL] else : [EOL] for r1 , r2 in zip ( self . timeline , self . timeline [ [number] : ] ) : [EOL] logging . debug ( f" [string] { r1 } [string] { r2 }" ) [EOL] if new_r . end < r1 . start : [EOL] logging . debug ( [string] ) [EOL] self . timeline . insert ( self . timeline . index ( r1 ) , new_r ) [EOL] break [EOL] elif new_r . start > r1 . end and new_r . end < r2 . start : [EOL] logging . debug ( f" [string] { r1 } [string] { r2 }" ) [EOL] self . timeline . insert ( self . timeline . index ( r1 ) + [number] , new_r ) [EOL] break [EOL] else : [EOL] self . timeline . append ( new_r ) [EOL] [EOL] def _clear_old_events ( self , when = None ) : [EOL] if when is None : [EOL] when = time ( ) [EOL] self . timeline = [ e for e in self . timeline if e . start > when ] [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . timeline }" [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 $AgentBasedModelling.project.pygame.utils.TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 $TimeRange$ 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 $TimeRange$ 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 $TimeRange$ 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 $TimeRange$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 0 0 0 $typing.List[AgentBasedModelling.project.pygame.utils.TimeRange]$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List , Dict , Tuple [EOL] import pygame [EOL] import typing [EOL] import builtins [EOL] import pygame [EOL] from time import time [EOL] from dataclasses import dataclass [EOL] from math import sqrt [EOL] from itertools import product [EOL] from utils import Timeline [EOL] [EOL] from typing import Dict , Any , List , Tuple [EOL] Config = Dict [ str , Any ] [EOL] Triple = Tuple [ int , int , int ] [EOL] [EOL] [EOL] @ dataclass class Cell : [EOL] rect = ... [EOL] timeline = ... [EOL] [EOL] def draw_cell ( self , screen , current_time , filled = False , ) : [EOL] if self . timeline . within_reserved ( current_time ) : [EOL] pygame . draw . rect ( screen , ( [number] , [number] , [number] ) , self . rect , [number] ) [EOL] else : [EOL] pygame . draw . rect ( screen , ( [number] , [number] , [number] ) , self . rect , [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . rect == other . rect and self . timeline == other . timeline [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( str ( self ) ) [EOL] [EOL] [EOL] class Grid : [EOL] def __init__ ( self , config , cars ) : [EOL] self . cars = cars [EOL] self . squares = config [ [string] ] [EOL] self . x_lines = int ( sqrt ( self . squares ) ) - [number] [EOL] self . y_lines = int ( sqrt ( self . squares ) ) - [number] [EOL] self . start_x , self . start_y = config [ [string] ] [EOL] self . end_x , self . end_y = config [ [string] ] [EOL] self . color = config [ [string] ] [EOL] spacing_y = ( self . end_y - self . start_y ) / ( self . y_lines + [number] ) [EOL] spacing_x = ( self . end_x - self . start_x ) / ( self . x_lines + [number] ) [EOL] self . points = None [EOL] self . g = [ Cell ( pygame . Rect ( self . start_x + spacing_x * x , self . start_y + spacing_y * y , spacing_x , spacing_y ) , Timeline ( ) ) for x , y in product ( range ( [number] , self . x_lines + [number] ) , range ( [number] , self . y_lines + [number] ) ) ] [EOL] [EOL] def point_in_grid ( self , point ) : [EOL] return self . end_x > point [ [number] ] > self . start_x and self . end_y > point [ [number] ] > self . start_y [EOL] [EOL] def draw_grid ( self , screen , current_time ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for cell in self . g : [EOL] cell . draw_cell ( screen , current_time ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def add_points_to_draw ( self , points ) : [EOL] self . points = points [EOL] [EOL] def clear_old_reservations ( self , time ) : [EOL] for cell in self . g : [EOL] cell . timeline . _clear_old_events ( time ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygame.Rect$ 0 0 0 $utils.Timeline$ 0 0 0 0 0 0 0 0 0 $pygame.Surface$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $Config$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0 0 0 $Triple$ 0 $Config$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Cell]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pygame.Surface$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygame.Surface$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any , List , Dict , Tuple [EOL] import typing [EOL] import builtins [EOL] import pygame [EOL] import random [EOL] from copy import copy [EOL] from math import cos , sin , pi , hypot [EOL] [EOL] from typing import List , Dict , Tuple [EOL] Waypoint = Tuple [ int , int ] [EOL] [EOL] [EOL] def random_vin ( i = [number] ) : [EOL] used_vins = [ ] [EOL] while True : [EOL] i = ( i + random . randint ( [number] , [number] ) ) % [number] [EOL] if i not in used_vins : [EOL] yield [string] + str ( i ) [EOL] used_vins . append ( i ) [EOL] [EOL] [EOL] class Car ( pygame . sprite . Sprite ) : [EOL] def __init__ ( self , config , path = None , dir = None , image = None , supervisor = None ) : [EOL] pygame . sprite . Sprite . __init__ ( self ) [EOL] self . config = config [EOL] self . image = pygame . image . load ( image or random . choice ( config [ [string] ] ) ) [EOL] self . vin = next ( random_vin ( ) ) [EOL] self . rect = self . image . get_rect ( ) [EOL] self . oryginal = copy ( self . image ) [EOL] self . dir = dir or [number] [EOL] self . velocity = config [ [string] ] [EOL] self . max_velocity = config [ [string] ] [EOL] self . acceleration = [number] [EOL] self . max_acceleration = [number] [EOL] self . waypoints = random . choice ( config [ [string] ] ) [EOL] self . waypoint_grid_intersect = [ d for d in config [ [string] ] if set ( d . keys ( ) ) == set ( self . waypoints ) ] [ [number] ] [EOL] self . waypoint_idx = [number] [EOL] self . current_waypoint = self . waypoints [ [number] ] [EOL] self . rect . x , self . rect . y = self . waypoints [ [number] ] [EOL] self . rect . x -= self . image . get_rect ( ) . size [ [number] ] / [number] [EOL] self . rect . y -= self . image . get_rect ( ) . size [ [number] ] / [number] [EOL] [EOL] def _entering_leaving_waypoint_index ( self ) : [EOL] [comment] [EOL] props = [ self . waypoint_grid_intersect [ w ] for w in self . waypoints ] [EOL] start = props . index ( True ) [EOL] end = props . index ( False , start ) [EOL] return ( start , end ) [EOL] [EOL] def _adjust_velocity ( self , velo = None ) : [EOL] if velo is not None : [EOL] self . velocity = velo [EOL] elif self . waypoint_idx == self . _entering_leaving_waypoint_index ( ) [ [number] ] : [EOL] self . velocity = self . max_velocity [EOL] elif self . waypoint_idx >= self . _entering_leaving_waypoint_index ( ) [ [number] ] : [EOL] self . velocity = self . config [ [string] ] [EOL] [EOL] def next_waypoint ( self ) : [EOL] self . waypoint_idx += [number] [EOL] try : [EOL] self . current_waypoint = self . waypoints [ self . waypoint_idx ] [EOL] except IndexError : [EOL] self . kill ( ) [EOL] [EOL] def turn ( self , amount ) : [EOL] oldCenter = self . rect . center [EOL] self . dir += amount [EOL] self . image = pygame . transform . rotate ( self . oryginal , [number] - self . dir ) [EOL] self . rect = self . image . get_rect ( ) [EOL] self . rect . center = oldCenter [EOL] [EOL] def towards_waypoint ( self ) : [EOL] ( waypoint_x , waypoint_y ) = self . current_waypoint [EOL] ( center_x , center_y ) = self . rect . center [EOL] waypoint_vector = pygame . math . Vector2 ( waypoint_x - center_x , waypoint_y - center_y ) [EOL] current_heading = pygame . math . Vector2 ( self . velocity , [number] ) [EOL] current_heading . rotate_ip ( self . dir ) [EOL] to_rotate = current_heading . angle_to ( waypoint_vector ) [EOL] self . turn ( to_rotate ) [EOL] [EOL] def update ( self ) : [EOL] self . towards_waypoint ( ) [EOL] self . rect . x += cos ( self . dir * pi / [number] ) * self . velocity [EOL] self . rect . y += sin ( self . dir * pi / [number] ) * self . velocity [EOL] ( waypoint_x , waypoint_y ) = self . current_waypoint [EOL] ( center_x , center_y ) = self . rect . center [EOL] if hypot ( waypoint_x - center_x , waypoint_y - center_y ) <= self . velocity : [EOL] self . _adjust_velocity ( ) [EOL] self . next_waypoint ( ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . vin } [string] { self . rect . x } [string] { self . rect . y } [string] { self . velocity } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[Waypoint]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[Waypoint,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Waypoint]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $Waypoint$ 0 0 0 $typing.List[Waypoint]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Waypoint]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.bool]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Type , Any , List , Tuple [EOL] import car [EOL] import typing [EOL] import builtins [EOL] import math [EOL] import time [EOL] import logging [EOL] [EOL] from typing import List [EOL] [EOL] from car import Car [EOL] [EOL] from pygame import sprite , rect [EOL] [EOL] Waypoint = List [ int ] [EOL] [EOL] [EOL] class Supervisor : [EOL] def __init__ ( self , grid , screen ) : [EOL] self . grid = grid [EOL] self . reservation_id = [number] [EOL] self . screen = screen [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { len ( self . grid . cars ) } [string] " [EOL] [EOL] def reserve_road ( self , car , current_time ) : [EOL] start , end = car . _entering_leaving_waypoint_index ( ) [EOL] road_before = car . waypoints [ [number] : start + [number] ] [EOL] road_in_square = car . waypoints [ start : end + [number] ] [EOL] init_speed = car . velocity [EOL] for speed in [ init_speed * x for x in [ [number] , [number] , [number] ] ] : [EOL] cells = self . cells_from_waypoints ( road_before , speed , road_in_square , car ) [EOL] now = current_time - [number] [EOL] duration = [number] / car . velocity [EOL] results = [ cell . timeline . add_timespan ( now + t , duration = duration , vin = car . vin ) for cell , t in cells ] [EOL] logging . debug ( f" [string] { car . vin } [string] { cells } [string] { now } [string] { results }" ) [EOL] if not all ( results ) : [EOL] logging . debug ( f" [string] { car . vin } [string] { now }" ) [EOL] for cell , t in cells : [EOL] cell . timeline . cancel_timespan ( now + t , duration = duration , vin = car . vin ) [EOL] continue [EOL] car . _adjust_velocity ( speed ) [EOL] self . reservation_id += [number] [EOL] return ( self . reservation_id , all ( results ) ) [EOL] [comment] [EOL] return ( self . reservation_id , False ) [EOL] [EOL] def route_len ( self , route , until ) : [EOL] return sum ( [ self . points_len ( route [ j ] , route [ j + [number] ] ) for j in range ( until ) ] ) [EOL] [EOL] def points_len ( self , p1 , p2 ) : [EOL] p1x , p1y = p1 [EOL] p2x , p2y = p2 [EOL] return math . hypot ( p1x - p2x , p1y - p2y ) [EOL] [EOL] def cells_from_waypoints ( self , road_before , road_speed , road , car ) : [EOL] cells = set ( ) [EOL] points_to_add = [ ] [EOL] time_before = self . route_len ( road_before , len ( road_before ) - [number] ) / road_speed [EOL] for i in range ( len ( road ) - [number] ) : [EOL] w1 , w2 = road [ i ] , road [ i + [number] ] [EOL] w1x , w1y = w1 [EOL] w2x , w2y = w2 [EOL] prec = math . floor ( self . points_len ( w1 , w2 ) / [number] ) [EOL] points = [ ( ( int ( w1x + i * ( w2x - w1x ) / prec ) ) , int ( w1y + i * ( w2y - w1y ) / prec ) ) for i in range ( prec ) ] [EOL] points_to_add = points_to_add + points [EOL] for point in points : [EOL] for cell in self . grid . g : [comment] [EOL] potential_dist = ( car . rect . size [ [number] ] + car . rect . size [ [number] ] + cell . rect . size [ [number] ] ) / [number] [EOL] if self . points_len ( cell . rect . center , point ) < potential_dist and cell not in [ c for c , _ in cells ] : [EOL] cells . add ( ( cell , time_before + ( self . route_len ( road , i ) + self . points_len ( road [ i ] , point ) ) / car . velocity ) ) [EOL] [EOL] return cells [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0
from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] import pygraphviz as pgv [EOL] [EOL] from opyenxes . data_in . XUniversalParser import XUniversalParser [EOL] [EOL] path = [string] [EOL] [EOL] [comment] [EOL] with open ( path ) as log_file : [EOL] [comment] [EOL] log = XUniversalParser ( ) . parse ( log_file ) [ [number] ] [EOL] [EOL] event = log [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] workflow_log = [ ] [EOL] for trace in log : [EOL] workflow_trace = [ ] [EOL] for event in trace [ [number] : : [number] ] : [EOL] [comment] [EOL] event_name = event . get_attributes ( ) [ [string] ] . get_value ( ) [EOL] workflow_trace . append ( event_name ) [EOL] workflow_log . append ( workflow_trace ) [EOL] [EOL] [comment] [EOL] w_net = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for i in range ( [number] , len ( w_trace ) - [number] ) : [EOL] ev_i , ev_j = w_trace [ i ] , w_trace [ i + [number] ] [EOL] if ev_i not in w_net . keys ( ) : [EOL] w_net [ ev_i ] = set ( ) [EOL] w_net [ ev_i ] . add ( ev_j ) [EOL] [EOL] [comment] [EOL] ev_counter = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for ev in w_trace : [EOL] ev_counter [ ev ] = ev_counter . get ( ev , [number] ) + [number] [EOL] [EOL] [comment] [EOL] edge_count = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for i in range ( [number] , len ( w_trace ) - [number] ) : [EOL] edge_tuple = ( w_trace [ i ] , w_trace [ i + [number] ] ) [EOL] edge_count [ edge_tuple ] = edge_count . get ( edge_tuple , [number] ) + [number] [EOL] [EOL] [comment] [EOL] edge_max = max ( edge_count . values ( ) ) [EOL] for edge in edge_count : [EOL] edge_count [ edge ] = edge_count [ edge ] * [number] / edge_max [EOL] [EOL] [comment] [EOL] color_min = min ( ev_counter . values ( ) ) [EOL] color_max = max ( ev_counter . values ( ) ) [EOL] [EOL] [comment] [EOL] G = pgv . AGraph ( strict = False , directed = True ) [EOL] G . graph_attr [ [string] ] = [string] [EOL] G . node_attr [ [string] ] = [string] [EOL] for event in w_net : [EOL] value = ev_counter [ event ] [EOL] color = int ( float ( color_max - value ) / float ( color_max - color_min ) * [number] ) [EOL] my_color = [string] + str ( hex ( color ) ) [ [number] : ] [EOL] text = event + [string] + str ( ev_counter [ event ] ) + [string] [EOL] G . add_node ( event , label = text , style = [string] , fillcolor = my_color ) [EOL] for preceding in w_net [ event ] : [EOL] G . add_edge ( event , preceding , penwidth = edge_count [ ( event , preceding ) ] , label = edge_count [ ( event , preceding ) ] * edge_max / [number] ) [EOL] [EOL] G . draw ( [string] , prog = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , List , Tuple , Dict [EOL] import typing [EOL] from random import choice [EOL] from gvanim import Animation , gif , render [EOL] from opyenxes . data_in . XUniversalParser import XUniversalParser [EOL] [EOL] path = [string] [EOL] [EOL] colors = [ line . replace ( [string] , [string] ) for line in open ( [string] ) . readlines ( ) ] [EOL] [EOL] [comment] [EOL] with open ( path ) as log_file : [EOL] [comment] [EOL] log = XUniversalParser ( ) . parse ( log_file ) [ [number] ] [EOL] [EOL] event = log [ [number] ] [ [number] ] [EOL] [EOL] [comment] [EOL] workflow_log = [ ] [EOL] for trace in log : [EOL] workflow_trace = [ ] [EOL] for event in trace [ [number] : : [number] ] : [EOL] [comment] [EOL] event_name = event . get_attributes ( ) [ [string] ] . get_value ( ) [EOL] workflow_trace . append ( event_name ) [EOL] workflow_log . append ( workflow_trace ) [EOL] [EOL] [comment] [EOL] w_net = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for i in range ( [number] , len ( w_trace ) - [number] ) : [EOL] ev_i , ev_j = w_trace [ i ] , w_trace [ i + [number] ] [EOL] if ev_i not in w_net . keys ( ) : [EOL] w_net [ ev_i ] = set ( ) [EOL] w_net [ ev_i ] . add ( ev_j ) [EOL] [EOL] [comment] [EOL] ev_counter = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for ev in w_trace : [EOL] ev_counter [ ev ] = ev_counter . get ( ev , [number] ) + [number] [EOL] [EOL] [comment] [EOL] edge_count = dict ( ) [EOL] for w_trace in workflow_log : [EOL] for i in range ( [number] , len ( w_trace ) - [number] ) : [EOL] edge_tuple = ( w_trace [ i ] , w_trace [ i + [number] ] ) [EOL] edge_count [ edge_tuple ] = edge_count . get ( edge_tuple , [number] ) + [number] [EOL] [EOL] [comment] [EOL] ga = Animation ( ) [EOL] for event in w_net : [EOL] text = event + [string] + str ( ev_counter [ event ] ) + [string] [EOL] ga . label_node ( event , text ) [EOL] for preceding in w_net [ event ] : [EOL] ga . add_edge ( event , preceding ) [EOL] [EOL] ga . next_step ( ) [EOL] a = [number] [EOL] for w_trace in workflow_log : [EOL] color = choice ( colors ) [EOL] for i in range ( [number] , len ( w_trace ) - [number] ) : [EOL] [comment] [EOL] for j in range ( [number] , i + [number] ) : [EOL] ga . highlight_node ( w_trace [ j ] , color = color ) [EOL] ga . highlight_edge ( w_trace [ j ] , w_trace [ j + [number] ] , color = color ) [EOL] ga . next_step ( ) [EOL] a += [number] [EOL] print ( a ) [EOL] if a > [number] : [EOL] break [EOL] [EOL] graphs = ga . graphs ( ) [EOL] files = render ( graphs , [string] , [string] , size = [number] ) [EOL] gif ( files , [string] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0