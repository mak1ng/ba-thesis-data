[comment] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] from setuptools import find_packages , setup [EOL] [EOL] install_requires_replacements = { } [EOL] [EOL] requirements = list ( set ( install_requires_replacements . get ( requirement . strip ( ) , requirement . strip ( ) ) for requirement in open ( [string] ) if not requirement . lstrip ( ) . startswith ( [string] ) ) ) [EOL] [EOL] setup_requirements = [ [string] , ] [EOL] [EOL] test_requirements = [ [string] , ] [EOL] [EOL] setup ( author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , ] , description = [string] , entry_points = { [string] : [ [string] , ] , } , install_requires = requirements , long_description = [string] , include_package_data = True , keywords = [string] , name = [string] , packages = find_packages ( include = [ [string] ] ) , setup_requires = setup_requirements , test_suite = [string] , tests_require = test_requirements , url = [string] , version = [string] , zip_safe = False , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Any , Dict [EOL] import metrics_backend [EOL] import logging [EOL] import builtins [EOL] import raiden_libs [EOL] import raiden_contracts [EOL] import typing [EOL] import web3 [EOL] import logging [EOL] import sys [EOL] import traceback [EOL] from typing import Dict , Optional , List [EOL] [EOL] import gevent [EOL] from web3 import Web3 [EOL] from eth_utils import is_checksum_address [EOL] from raiden_libs . gevent_error_handler import register_error_handler [EOL] from raiden_libs . types import Address [EOL] from raiden_contracts . contract_manager import ContractManager [EOL] from raiden_contracts . constants import ( ChannelEvent , CONTRACT_TOKEN_NETWORK , CONTRACT_TOKEN_NETWORK_REGISTRY , ) [EOL] from metrics_backend . model import TokenNetwork [EOL] from metrics_backend . utils . blockchain_listener import ( BlockchainListener , create_registry_event_topics , create_channel_event_topics , ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def error_handler ( _ , exc_info ) : [EOL] log . fatal ( [string] ) [EOL] traceback . print_exception ( etype = exc_info [ [number] ] , value = exc_info [ [number] ] , tb = exc_info [ [number] ] ) [EOL] sys . exit ( ) [EOL] [EOL] [EOL] class MetricsService ( gevent . Greenlet ) : [EOL] def __init__ ( self , web3 , contract_manager , registry_address , sync_start_block = [number] , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . web3 = web3 [EOL] self . contract_manager = contract_manager [EOL] [EOL] self . is_running = gevent . event . Event ( ) [EOL] self . token_networks = { } [EOL] self . token_network_listeners = [ ] [EOL] [EOL] log . info ( [string] ) [EOL] self . token_network_registry_listener = BlockchainListener ( web3 = web3 , contract_manager = contract_manager , contract_name = CONTRACT_TOKEN_NETWORK_REGISTRY , contract_address = registry_address , sync_start_block = sync_start_block , ) [EOL] self . _setup_token_networks ( ) [EOL] [EOL] def _setup_token_networks ( self ) : [EOL] self . token_network_registry_listener . add_confirmed_listener ( create_registry_event_topics ( ) , self . handle_token_network_created ) [EOL] [EOL] def _run ( self ) : [EOL] register_error_handler ( error_handler ) [EOL] if self . token_network_registry_listener is not None : [EOL] self . token_network_registry_listener . start ( ) [EOL] [EOL] self . is_running . wait ( ) [EOL] [EOL] def stop ( self ) : [EOL] self . is_running . set ( ) [EOL] [EOL] def follows_token_network ( self , token_network_address ) : [EOL] [docstring] [EOL] assert is_checksum_address ( token_network_address ) [EOL] [EOL] return token_network_address in self . token_networks . keys ( ) [EOL] [EOL] def _get_token_network ( self , token_network_address ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( token_network_address ) [EOL] [EOL] if not self . follows_token_network ( token_network_address ) : [EOL] return None [EOL] else : [EOL] return self . token_networks [ token_network_address ] [EOL] [EOL] def handle_channel_event ( self , event ) : [EOL] event_name = event [ [string] ] [EOL] [EOL] if event_name == ChannelEvent . OPENED : [EOL] self . handle_channel_opened ( event ) [EOL] elif event_name == ChannelEvent . DEPOSIT : [EOL] self . handle_channel_new_deposit ( event ) [EOL] elif event_name == ChannelEvent . CLOSED : [EOL] self . handle_channel_closed ( event ) [EOL] elif event_name == ChannelEvent . SETTLED : [EOL] self . handle_channel_settled ( event ) [EOL] else : [EOL] log . info ( [string] , event_name ) [EOL] [EOL] def handle_channel_opened ( self , event ) : [EOL] token_network = self . _get_token_network ( event [ [string] ] ) [EOL] [EOL] if token_network is None : [EOL] return [EOL] [EOL] channel_identifier = event [ [string] ] [ [string] ] [EOL] participant1 = event [ [string] ] [ [string] ] [EOL] participant2 = event [ [string] ] [ [string] ] [EOL] log . info ( [string] . format ( token_network . address , channel_identifier , participant1 , participant2 , ) ) [EOL] [EOL] token_network . handle_channel_opened_event ( channel_identifier , participant1 , participant2 ) [EOL] [EOL] def handle_channel_new_deposit ( self , event ) : [EOL] token_network = self . _get_token_network ( event [ [string] ] ) [EOL] [EOL] if token_network is None : [EOL] return [EOL] [EOL] channel_identifier = event [ [string] ] [ [string] ] [EOL] participant_address = event [ [string] ] [ [string] ] [EOL] total_deposit = event [ [string] ] [ [string] ] [EOL] [EOL] log . info ( [string] . format ( token_network . address , channel_identifier , total_deposit , participant_address ) ) [EOL] [EOL] token_network . handle_channel_new_deposit_event ( channel_identifier , participant_address , total_deposit ) [EOL] [EOL] def handle_channel_closed ( self , event ) : [EOL] token_network = self . _get_token_network ( event [ [string] ] ) [EOL] [EOL] if token_network is None : [EOL] return [EOL] [EOL] channel_identifier = event [ [string] ] [ [string] ] [EOL] [EOL] log . info ( [string] . format ( token_network . address , channel_identifier , ) ) [EOL] [EOL] token_network . handle_channel_closed_event ( channel_identifier ) [EOL] [EOL] def handle_channel_settled ( self , event ) : [EOL] token_network = self . _get_token_network ( event [ [string] ] ) [EOL] [EOL] if token_network is None : [EOL] return [EOL] [EOL] channel_identifier = event [ [string] ] [ [string] ] [EOL] [EOL] log . info ( [string] . format ( token_network . address , channel_identifier , ) ) [EOL] [EOL] token_network . handle_channel_settled_event ( channel_identifier ) [EOL] [EOL] def handle_token_network_created ( self , event ) : [EOL] token_network_address = event [ [string] ] [ [string] ] [EOL] token_address = event [ [string] ] [ [string] ] [EOL] event_block_number = event [ [string] ] [EOL] [EOL] assert is_checksum_address ( token_network_address ) [EOL] assert is_checksum_address ( token_address ) [EOL] [EOL] if not self . follows_token_network ( token_network_address ) : [EOL] log . info ( f' [string] { token_address } [string] { token_network_address }' ) [EOL] self . create_token_network_for_address ( token_network_address , event_block_number ) [EOL] [EOL] def create_token_network_for_address ( self , token_network_address , block_number = [number] , ) : [EOL] token_network = TokenNetwork ( token_network_address ) [EOL] self . token_networks [ token_network_address ] = token_network [EOL] [EOL] log . info ( [string] , token_network_address ) [EOL] token_network_listener = BlockchainListener ( web3 = self . web3 , contract_manager = self . contract_manager , contract_address = token_network_address , contract_name = CONTRACT_TOKEN_NETWORK , sync_start_block = block_number , ) [EOL] [EOL] [comment] [EOL] token_network_listener . add_confirmed_listener ( create_channel_event_topics ( ) , self . handle_channel_event , ) [EOL] token_network_listener . start ( ) [EOL] self . token_network_listeners . append ( token_network_listener ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[metrics_backend.model.TokenNetwork]$ 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict [EOL] import logging [EOL] import typing [EOL] import metrics_backend [EOL] from gevent import monkey [comment] [EOL] monkey . patch_all ( ) [comment] [EOL] [EOL] import logging [EOL] import os [EOL] import sys [EOL] import json [EOL] [EOL] import click [EOL] import gevent [EOL] from web3 import HTTPProvider , Web3 [EOL] from requests . exceptions import ConnectionError [EOL] from raiden_libs . no_ssl_patch import no_ssl_verification [EOL] from raiden_contracts . contract_manager import CONTRACT_MANAGER [EOL] [EOL] from metrics_backend . api . rest import NetworkInfoAPI [EOL] from metrics_backend . metrics_service import MetricsService [EOL] from metrics_backend . utils . serialisation import token_network_to_dict [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] REGISTRY_ADDRESS = [string] [EOL] DEFAULT_PORT = [number] [EOL] OUTPUT_FILE = [string] [EOL] TEMP_FILE = [string] [EOL] OUTPUT_PERIOD = [number] [comment] [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , default = [string] , type = str , help = [string] ) def main ( eth_rpc , ) : [EOL] [comment] [EOL] logging . basicConfig ( level = logging . INFO , format = [string] , datefmt = [string] , ) [EOL] [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . INFO ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] try : [EOL] log . info ( f' [string] { eth_rpc }' ) [EOL] web3 = Web3 ( HTTPProvider ( eth_rpc ) ) [EOL] except ConnectionError : [EOL] log . error ( [string] [string] ) [EOL] sys . exit ( ) [EOL] [EOL] with no_ssl_verification ( ) : [EOL] service = None [EOL] try : [EOL] service = MetricsService ( web3 = web3 , contract_manager = CONTRACT_MANAGER , registry_address = REGISTRY_ADDRESS , sync_start_block = [number] , ) [EOL] [EOL] gevent . spawn ( write_topology_task , service ) [EOL] [EOL] api = NetworkInfoAPI ( service ) [EOL] api . run ( port = DEFAULT_PORT ) [EOL] print ( f' [string] { DEFAULT_PORT } [string] ' ) [EOL] [EOL] print ( [string] ) [EOL] service . run ( ) [EOL] [EOL] except ( KeyboardInterrupt , SystemExit ) : [EOL] print ( [string] ) [EOL] finally : [EOL] if service : [EOL] log . info ( [string] ) [EOL] service . stop ( ) [EOL] [EOL] return [number] [EOL] [EOL] [EOL] def write_topology_task ( pathfinding_service ) : [EOL] while True : [EOL] result = dict ( num_networks = len ( pathfinding_service . token_networks ) , ) [EOL] [EOL] result . update ( { network . address : token_network_to_dict ( network ) for network in pathfinding_service . token_networks . values ( ) } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with open ( TEMP_FILE , [string] ) as f : [EOL] json . dump ( result , f ) [EOL] [EOL] os . rename ( TEMP_FILE , OUTPUT_FILE ) [EOL] log . info ( f' [string] { OUTPUT_FILE }' ) [EOL] [EOL] gevent . sleep ( OUTPUT_PERIOD ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __version__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import List , Tuple , Dict [EOL] import metrics_backend [EOL] import flask [EOL] import flask_restful [EOL] import gevent [EOL] import builtins [EOL] import typing [EOL] from typing import Tuple , Dict , List [EOL] [EOL] import gevent [EOL] from flask import Flask [EOL] from flask_restful import Api , Resource [EOL] from flask_cors import CORS [EOL] from gevent import Greenlet [EOL] from gevent . pywsgi import WSGIServer [EOL] [EOL] from metrics_backend . metrics_service import MetricsService [EOL] from metrics_backend . utils . serialisation import token_network_to_dict [EOL] [EOL] [EOL] class NetworkInfoResource ( Resource ) : [EOL] def __init__ ( self , metrics_service ) : [EOL] self . metrics_service = metrics_service [EOL] [EOL] def get ( self ) : [EOL] result = dict ( num_networks = len ( self . metrics_service . token_networks ) , ) [EOL] [EOL] result . update ( { network . address : token_network_to_dict ( network ) for network in self . metrics_service . token_networks . values ( ) } ) [EOL] return { [string] : result } , [number] [EOL] [EOL] [EOL] class NetworkInfoAPI : [EOL] def __init__ ( self , metrics_service ) : [EOL] self . flask_app = Flask ( __name__ ) [EOL] CORS ( self . flask_app ) [EOL] self . api = Api ( self . flask_app ) [EOL] self . rest_server = None [EOL] self . server_greenlet = None [EOL] [EOL] resources = [ ( [string] , NetworkInfoResource , { } ) , ] [EOL] [EOL] for endpoint_url , resource , kwargs in resources : [EOL] kwargs [ [string] ] = metrics_service [EOL] self . api . add_resource ( resource , endpoint_url , resource_class_kwargs = kwargs ) [EOL] [EOL] def run ( self , port = [number] ) : [EOL] self . rest_server = WSGIServer ( ( [string] , port ) , self . flask_app ) [EOL] self . server_greenlet = gevent . spawn ( self . rest_server . serve_forever ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $metrics_backend.metrics_service.MetricsService$ 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 $gevent.pywsgi.WSGIServer$ 0 0 0 0 0 $gevent.Greenlet$ 0 0 0 0 $typing.List[typing.Tuple[builtins.str,flask_restful.Resource,typing.Dict]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,flask_restful.Resource,typing.Dict]]$ 0 0 0 0 0 0 0 $metrics_backend.metrics_service.MetricsService$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Tuple , Dict [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] import raiden_libs [EOL] import logging [EOL] from typing import Dict , Tuple [EOL] [EOL] from networkx import DiGraph [EOL] from eth_utils import is_checksum_address [EOL] from raiden_libs . types import Address , ChannelIdentifier [EOL] [EOL] from metrics_backend . model import ChannelView [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TokenNetwork : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , token_network_address ) : [EOL] [docstring] [EOL] [EOL] self . address = token_network_address [EOL] self . channel_id_to_addresses = dict ( ) [EOL] self . G = DiGraph ( ) [EOL] [EOL] def handle_channel_opened_event ( self , channel_identifier , participant1 , participant2 , ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] self . channel_id_to_addresses [ channel_identifier ] = ( participant1 , participant2 ) [EOL] [EOL] view1 = ChannelView ( channel_identifier , participant1 , participant2 , deposit = [number] ) [EOL] view2 = ChannelView ( channel_identifier , participant2 , participant1 , deposit = [number] ) [EOL] [EOL] self . G . add_edge ( participant1 , participant2 , view = view1 ) [EOL] self . G . add_edge ( participant2 , participant1 , view = view2 ) [EOL] [EOL] def handle_channel_new_deposit_event ( self , channel_identifier , receiver , total_deposit ) : [EOL] [docstring] [EOL] [EOL] assert is_checksum_address ( receiver ) [EOL] [EOL] try : [EOL] participant1 , participant2 = self . channel_id_to_addresses [ channel_identifier ] [EOL] [EOL] if receiver == participant1 : [EOL] self . G [ participant1 ] [ participant2 ] [ [string] ] . update_capacity ( deposit = total_deposit ) [EOL] elif receiver == participant2 : [EOL] self . G [ participant2 ] [ participant1 ] [ [string] ] . update_capacity ( deposit = total_deposit ) [EOL] else : [EOL] log . error ( [string] ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] [EOL] def handle_channel_closed_event ( self , channel_identifier ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] participant1 , participant2 = self . channel_id_to_addresses [ channel_identifier ] [EOL] [EOL] self . G [ participant1 ] [ participant2 ] [ [string] ] . update_state ( ChannelView . State . CLOSED ) [EOL] self . G [ participant2 ] [ participant1 ] [ [string] ] . update_state ( ChannelView . State . CLOSED ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL] [EOL] def handle_channel_settled_event ( self , channel_identifier ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] participant1 , participant2 = self . channel_id_to_addresses [ channel_identifier ] [EOL] [EOL] self . G [ participant1 ] [ participant2 ] [ [string] ] . update_state ( ChannelView . State . SETTLED ) [EOL] self . G [ participant2 ] [ participant1 ] [ [string] ] . update_state ( ChannelView . State . SETTLED ) [EOL] except KeyError : [EOL] log . error ( [string] . format ( channel_identifier ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 $typing.Dict[raiden_libs.types.ChannelIdentifier,typing.Tuple[raiden_libs.types.Address,raiden_libs.types.Address]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 $typing.Any$ 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 $raiden_libs.types.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $raiden_libs.types.ChannelIdentifier$ 0 0 0
import builtins [EOL] import raiden_libs [EOL] import ChannelView [EOL] from enum import Enum [EOL] [EOL] from eth_utils import is_checksum_address [EOL] from raiden_libs . types import Address , ChannelIdentifier [EOL] [EOL] [EOL] class ChannelView : [EOL] [docstring] [EOL] class State ( Enum ) : [EOL] OPENED = [string] , [EOL] CLOSED = [string] , [EOL] SETTLED = [string] , [EOL] [EOL] def __init__ ( self , channel_id , participant1 , participant2 , deposit = [number] ) : [EOL] assert is_checksum_address ( participant1 ) [EOL] assert is_checksum_address ( participant2 ) [EOL] [EOL] self . self = participant1 [EOL] self . partner = participant2 [EOL] [EOL] self . _deposit = deposit [EOL] self . state = ChannelView . State . OPENED [EOL] self . channel_id = channel_id [EOL] [EOL] def update_capacity ( self , deposit = None , ) : [EOL] if deposit is not None : [EOL] self . _deposit = deposit [EOL] [EOL] def update_state ( self , new_state ) : [EOL] if new_state is not None : [EOL] self . state = new_state [EOL] [EOL] @ property def deposit ( self ) : [EOL] return self . _deposit [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . self , self . partner , self . deposit , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $raiden_libs.types.Address$ 0 $raiden_libs.types.Address$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 0 $raiden_libs.types.Address$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $ChannelView.State$ 0 0 0 0 $ChannelView.State$ 0 0 0 0 0 0 0 0 0 $ChannelView.State$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . channel_view import ChannelView [EOL] from . token_network import TokenNetwork [EOL] [EOL] __all__ = [ [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import builtins [EOL] import typing [EOL] import metrics_backend [EOL] from typing import Dict , List [EOL] [EOL] from metrics_backend . model import TokenNetwork , ChannelView [EOL] [EOL] [EOL] def _state_to_str ( state ) : [EOL] if state == ChannelView . State . OPENED : [EOL] return [string] [EOL] elif state == ChannelView . State . CLOSED : [EOL] return [string] [EOL] elif state == ChannelView . State . SETTLED : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] def token_network_to_dict ( token_network ) : [EOL] [docstring] [EOL] num_channels_opened = [number] [EOL] num_channels_closed = [number] [EOL] num_channels_settled = [number] [EOL] [EOL] participants = [ ] [EOL] channels = [ ] [EOL] for channel_id in token_network . channel_id_to_addresses . keys ( ) : [EOL] ends = token_network . channel_id_to_addresses [ channel_id ] [EOL] participants . extend ( ends ) [EOL] [EOL] p1 , p2 = ends [EOL] [EOL] try : [EOL] view1 = token_network . G [ p1 ] [ p2 ] [ [string] ] [EOL] view2 = token_network . G [ p2 ] [ p1 ] [ [string] ] [EOL] except Exception : [EOL] raise RuntimeError ( [string] , p1 , p2 ) [EOL] [EOL] channel = dict ( channel_identifier = channel_id , status = _state_to_str ( view1 . state ) , participant1 = ends [ [number] ] , participant2 = ends [ [number] ] , deposit1 = view1 . deposit , deposit2 = view2 . deposit , ) [EOL] channels . append ( channel ) [EOL] [EOL] if view1 . state == ChannelView . State . OPENED : [EOL] num_channels_opened += [number] [EOL] elif view1 . state == ChannelView . State . CLOSED : [EOL] num_channels_closed += [number] [EOL] elif view1 . state == ChannelView . State . SETTLED : [EOL] num_channels_settled += [number] [EOL] [EOL] [comment] [EOL] participants_deduped = list ( set ( participants ) ) [EOL] [EOL] return dict ( token_address = token_network . address , num_channels_total = len ( channels ) , num_channels_opened = num_channels_opened , num_channels_closed = num_channels_closed , num_channels_settled = num_channels_settled , num_nodes = len ( participants_deduped ) , nodes = participants_deduped , channels = channels , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0