import os [EOL] [EOL] ROOT_DIR = os . path . realpath ( os . path . join ( os . getcwd ( ) , os . path . dirname ( __file__ ) ) ) [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import src [EOL] import typing [EOL] import logging [EOL] import os [EOL] import yaml [EOL] import logging . config [EOL] [EOL] from apscheduler . schedulers . blocking import BlockingScheduler [EOL] [EOL] from config import ROOT_DIR [EOL] from src . monitor import Monitor [EOL] from src . connection_tester import ConnectionTester [EOL] from src . status_tracker import StatusTracker [EOL] from src . notifiers . entry_writer_notifier import EntryWriterNotifier [EOL] from src . notifiers . json_entry_writer import JsonEntryWriter [EOL] [EOL] [EOL] def setup_logging ( ) : [EOL] with open ( os . path . join ( ROOT_DIR , [string] ) , [string] ) as log_file : [EOL] config = yaml . safe_load ( log_file . read ( ) ) [EOL] logging . config . dictConfig ( config ) [EOL] [EOL] [EOL] setup_logging ( ) [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] if __name__ == [string] : [EOL] scheduler = BlockingScheduler ( ) [EOL] connection_tester = ConnectionTester ( ) [EOL] status_tracker = StatusTracker ( ) [EOL] json_writer = JsonEntryWriter ( os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] , [string] ) ) [EOL] notifier = EntryWriterNotifier ( json_writer ) [EOL] monitor_config = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] monitor = Monitor ( scheduler , connection_tester , status_tracker , notifier , monitor_config ) [EOL] [EOL] try : [EOL] logger . info ( [string] ) [EOL] monitor . run_test ( ) [EOL] logger . info ( [string] ) [EOL] scheduler . start ( ) [EOL] except ( KeyboardInterrupt , SystemExit ) : [EOL] logger . info ( [string] ) [EOL] scheduler . shutdown ( ) [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.monitor.Monitor$ 0 0 0 0 0 0 $src.connection_tester.ConnectionTester$ 0 0 0 0 0 0 $src.status_tracker.StatusTracker$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $src.connection_tester.ConnectionTester$ 0 0 0 0 0 $src.status_tracker.StatusTracker$ 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.entry_writer_notifier.EntryWriterNotifier$ 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.monitor.Monitor$ 0 0 0 $typing.Any$ 0 $src.connection_tester.ConnectionTester$ 0 $src.status_tracker.StatusTracker$ 0 $src.notifiers.entry_writer_notifier.EntryWriterNotifier$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $src.monitor.Monitor$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
import builtins [EOL] import datetime [EOL] import logging [EOL] import logging [EOL] from enum import Enum [EOL] from datetime import datetime [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Status ( Enum ) : [EOL] [docstring] [EOL] UNKNOWN = [number] [comment] [EOL] OK = [number] [comment] [EOL] WARNING = [number] [comment] [EOL] ERROR = [number] [comment] [EOL] [EOL] [EOL] class StatusChange ( Enum ) : [EOL] INVALID = - [number] [EOL] NONE = [number] [EOL] ERROR_RESOLVED = [number] [EOL] WARNING_RESOLVED = [number] [EOL] NEW_ERROR = [number] [EOL] NEW_WARNING = [number] [EOL] [EOL] [EOL] class StatusTracker : [EOL] def __init__ ( self , number_retry_attempts = None ) : [EOL] [comment] [EOL] self . _status = Status . UNKNOWN [EOL] self . _last_successful_run = datetime . min [EOL] self . _number_failures = [number] [EOL] [EOL] [comment] [EOL] self . _number_retry_attempts = number_retry_attempts or [number] [EOL] [EOL] @ property def status ( self ) : [EOL] return self . _status [EOL] [EOL] @ property def last_success ( self ) : [EOL] return self . _last_successful_run [EOL] [EOL] def submit_result ( self , test_passed ) : [EOL] if not test_passed : [EOL] self . _number_failures += [number] [EOL] else : [EOL] self . _number_failures = [number] [EOL] [EOL] if self . _number_failures == [number] : [EOL] new_status = Status . OK [EOL] elif self . _number_failures < self . _number_retry_attempts + [number] : [EOL] new_status = Status . WARNING [EOL] else : [EOL] new_status = Status . ERROR [EOL] [EOL] return self . _set_status ( new_status ) [EOL] [EOL] def _set_status ( self , status ) : [EOL] if not isinstance ( status , Status ) : [EOL] raise TypeError ( [string] . format ( type = type ( status ) ) ) [EOL] [EOL] logger . info ( [string] , status ) [EOL] [EOL] [comment] [EOL] if status == self . _status : [EOL] logger . debug ( [string] ) [EOL] [comment] [EOL] if self . _status == Status . OK : [EOL] self . _last_successful_run = datetime . now ( ) [EOL] [EOL] status_change = StatusChange . NONE [EOL] [EOL] [comment] [EOL] elif ( ( self . _status != Status . OK ) and ( status == Status . OK ) ) : [EOL] logger . debug ( [string] ) [EOL] resolved_time = datetime . now ( ) [EOL] [EOL] if self . _status == Status . ERROR : [EOL] status_change = StatusChange . ERROR_RESOLVED [EOL] elif self . status == Status . WARNING : [EOL] status_change = StatusChange . WARNING_RESOLVED [EOL] elif self . status == Status . UNKNOWN : [EOL] status_change = StatusChange . NONE [EOL] else : [EOL] logger . error ( [string] , self . status ) [EOL] status_change = StatusChange . INVALID [EOL] [EOL] self . _last_successful_run = resolved_time [EOL] [EOL] elif ( ( self . _status != Status . WARNING ) and ( status == Status . WARNING ) ) : [EOL] logger . debug ( [string] ) [EOL] status_change = StatusChange . NEW_WARNING [EOL] [EOL] if self . _status == Status . ERROR : [EOL] logger . error ( [string] [string] ) [EOL] status_change = StatusChange . INVALID [EOL] [EOL] elif ( ( self . _status != Status . ERROR ) and ( status == Status . ERROR ) ) : [EOL] logger . debug ( [string] ) [EOL] status_change = StatusChange . NEW_ERROR [EOL] [EOL] else : [EOL] logger . error ( [string] [string] , self . _status , status ) [EOL] status_change = StatusChange . INVALID [EOL] [EOL] [comment] [EOL] self . _status = status [EOL] [EOL] return status_change [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import logging [EOL] import logging [EOL] import socket [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ConnectionTester : [EOL] def __init__ ( self , remote_to_check = [string] ) : [EOL] logger . debug ( [string] ) [EOL] self . remote_to_check = remote_to_check [EOL] [EOL] def run_test ( self ) : [EOL] try : [EOL] [comment] [EOL] [comment] [EOL] host = socket . gethostbyname ( self . remote_to_check ) [EOL] [comment] [EOL] [comment] [EOL] socket . create_connection ( ( host , [number] ) , [number] ) [EOL] return True [EOL] except socket . error : [EOL] logger . exception ( [string] ) [EOL] pass [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import datetime [EOL] import logging [EOL] import logging [EOL] from datetime import datetime [EOL] from src . status_tracker import Status , StatusChange [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ConnectionEntry : [EOL] def __init__ ( self , time , result , status , status_change ) : [EOL] self . _time = time [EOL] self . _result = result [EOL] self . _status = status [EOL] self . _status_change = status_change [EOL] [EOL] @ classmethod def from_json ( cls , json_entry ) : [EOL] if not all ( key in json_entry for key in ( [string] , [string] , [string] , [string] ) ) : [EOL] logger . error ( [string] , json_entry ) [EOL] raise ValueError ( [string] . format ( dict = json_entry ) ) [EOL] if any ( key not in ( [string] , [string] , [string] , [string] ) for key in json_entry ) : [EOL] logger . error ( [string] , json_entry ) [EOL] raise ValueError ( [string] . format ( dict = json_entry ) ) [EOL] [EOL] return ConnectionEntry ( datetime . strptime ( json_entry [ [string] ] , [string] ) , bool ( json_entry [ [string] ] ) , Status [ json_entry [ [string] ] ] , StatusChange [ json_entry [ [string] ] ] ) [EOL] [EOL] def to_json ( self ) : [EOL] json_dict = { [string] : str ( self . _time ) , [string] : self . _result , [string] : self . _status . name , [string] : self . _status_change . name } [EOL] [EOL] return json_dict [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( ( isinstance ( other , ConnectionEntry ) ) and ( self . _time == other . _time ) and ( self . _result == other . _result ) and ( self . _status == other . _status ) and ( self . _status_change == other . _status_change ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . to_json ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import datetime [EOL] import builtins [EOL] import src [EOL] import logging [EOL] import json [EOL] import os [EOL] import logging [EOL] from enum import Enum [EOL] from datetime import datetime [EOL] [EOL] from src . connection_entry import ConnectionEntry [EOL] from src . status_tracker import Status , StatusChange [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class EntryWriter : [EOL] def write_new_entry ( self , entry ) : [EOL] pass [EOL] [EOL] [EOL] class EntryWriterNotifier : [EOL] def __init__ ( self , writer ) : [EOL] self . _writer = writer [EOL] [EOL] def notify ( self , time , result , status , status_change ) : [EOL] new_entry = ConnectionEntry ( time , result , status , status_change ) [EOL] [EOL] self . _writer . write_new_entry ( new_entry ) [EOL] [EOL] [EOL] class FileType ( Enum ) : [EOL] NONE = [number] [EOL] JSON_LIST = [number] [EOL] [EOL] [EOL] def prepare_data_file ( file_path , file_type = FileType . NONE ) : [EOL] logger . debug ( [string] , file_path ) [EOL] [EOL] os . makedirs ( os . path . dirname ( file_path ) , exist_ok = True ) [EOL] [EOL] if os . path . isfile ( file_path ) : [EOL] logger . debug ( [string] ) [EOL] return [EOL] [EOL] with open ( file_path , [string] ) as new_file : [EOL] logger . debug ( [string] ) [EOL] if file_type == FileType . JSON_LIST : [EOL] json . dump ( [ ] , new_file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import src [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import json [EOL] from src . connection_entry import ConnectionEntry [EOL] from src . notifiers . entry_writer_notifier import EntryWriter , FileType , prepare_data_file [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class JsonEntryWriter ( EntryWriter ) : [EOL] def __init__ ( self , output_file ) : [EOL] self . _output_file = output_file [EOL] prepare_data_file ( output_file , FileType . JSON_LIST ) [EOL] [EOL] def write_new_entry ( self , entry ) : [EOL] logger . debug ( [string] , entry ) [EOL] [EOL] current_info = self . _get_test_data ( ) [EOL] current_info . append ( entry . to_json ( ) ) [EOL] [EOL] self . _save_test_data ( current_info ) [EOL] [EOL] def _get_test_data ( self ) : [EOL] with open ( self . _output_file , [string] ) as test_data : [EOL] data = json . load ( test_data ) [EOL] [EOL] return data [EOL] [EOL] def _save_test_data ( self , new_test_data ) : [EOL] with open ( self . _output_file , [string] ) as test_data : [EOL] json . dump ( new_test_data , test_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 $logging.Logger$ 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0
	0
	0
from typing import Dict , Union , Any [EOL] import src [EOL] import typing [EOL] import unittest [EOL] from datetime import datetime [EOL] from src . connection_entry import ConnectionEntry [EOL] from src . status_tracker import Status , StatusChange [EOL] [EOL] [EOL] class TestConnectionEntry ( unittest . TestCase ) : [EOL] def test_initialisation ( self ) : [EOL] connection_entry = ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . OK , StatusChange . NEW_WARNING ) [EOL] [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , connection_entry . _time ) [EOL] self . assertEqual ( True , connection_entry . _result ) [EOL] self . assertEqual ( Status . OK , connection_entry . _status ) [EOL] self . assertEqual ( StatusChange . NEW_WARNING , connection_entry . _status_change ) [EOL] [EOL] def test_from_json_valid ( self ) : [EOL] input_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : str ( True ) , [string] : Status . UNKNOWN . name , [string] : StatusChange . WARNING_RESOLVED . name } [EOL] [EOL] connection_entry = ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . UNKNOWN , StatusChange . WARNING_RESOLVED ) , connection_entry ) [EOL] [EOL] def test_from_json_missing_time ( self ) : [EOL] input_json = { [string] : str ( True ) , [string] : Status . UNKNOWN . name , [string] : StatusChange . WARNING_RESOLVED . name } [EOL] [EOL] with self . assertRaises ( ValueError ) as ex : [EOL] ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( [string] . format ( dict = input_json ) , str ( ex . exception ) ) [EOL] [EOL] def test_from_json_missing_result ( self ) : [EOL] input_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : Status . UNKNOWN . name , [string] : StatusChange . WARNING_RESOLVED . name } [EOL] [EOL] with self . assertRaises ( ValueError ) as ex : [EOL] ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( [string] . format ( dict = input_json ) , str ( ex . exception ) ) [EOL] [EOL] def test_from_json_missing_status ( self ) : [EOL] input_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : str ( True ) , [string] : StatusChange . WARNING_RESOLVED . name } [EOL] [EOL] with self . assertRaises ( ValueError ) as ex : [EOL] ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( [string] . format ( dict = input_json ) , str ( ex . exception ) ) [EOL] [EOL] def test_from_json_missing_status_change ( self ) : [EOL] input_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : str ( True ) , [string] : Status . UNKNOWN . name , } [EOL] [EOL] with self . assertRaises ( ValueError ) as ex : [EOL] ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( [string] . format ( dict = input_json ) , str ( ex . exception ) ) [EOL] [EOL] def test_from_json_extra_parameters ( self ) : [EOL] input_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : str ( True ) , [string] : Status . UNKNOWN . name , [string] : StatusChange . WARNING_RESOLVED . name , [string] : [string] } [EOL] [EOL] with self . assertRaises ( ValueError ) as ex : [EOL] ConnectionEntry . from_json ( input_json ) [EOL] [EOL] self . assertEqual ( [string] . format ( dict = input_json ) , str ( ex . exception ) ) [EOL] [EOL] def test_to_json ( self ) : [EOL] connection_entry = ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . OK , StatusChange . NEW_WARNING ) [EOL] [EOL] self . assertEqual ( { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : True , [string] : Status . OK . name , [string] : StatusChange . NEW_WARNING . name } , connection_entry . to_json ( ) ) [EOL] [EOL] def test_to_from_json_loop ( self ) : [EOL] first_connection_entry = ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . OK , StatusChange . NEW_WARNING ) [EOL] [EOL] second_connection_entry = ConnectionEntry . from_json ( first_connection_entry . to_json ( ) ) [EOL] [EOL] self . assertEqual ( first_connection_entry , second_connection_entry ) [EOL] [EOL] def test_from_to_json_loop ( self ) : [EOL] first_json = { [string] : str ( datetime ( [number] , [number] , [number] ) ) , [string] : True , [string] : Status . UNKNOWN . name , [string] : StatusChange . WARNING_RESOLVED . name } [EOL] [EOL] second_json = ConnectionEntry . from_json ( first_json ) . to_json ( ) [EOL] [EOL] self . assertEqual ( first_json , second_json ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]$ 0 $typing.Any$ 0 0
import src [EOL] import unittest [EOL] from datetime import datetime [EOL] from freezegun import freeze_time [EOL] from src . status_tracker import StatusChange , Status , StatusTracker [EOL] [EOL] [EOL] class TestStatusTracker ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . status_tracker = StatusTracker ( ) [EOL] [EOL] def submit_result_and_expect ( self , to_submit , expect_status , expect_status_change ) : [EOL] status_change = self . status_tracker . submit_result ( to_submit ) [EOL] [EOL] self . assertEqual ( expect_status , self . status_tracker . status ) [EOL] self . assertEqual ( expect_status_change , status_change ) [EOL] [EOL] def test_initialised_correctly ( self ) : [EOL] [comment] [EOL] self . assertEqual ( Status . UNKNOWN , self . status_tracker . status ) [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [comment] [EOL] self . assertEqual ( [number] , self . status_tracker . _number_retry_attempts ) [EOL] self . assertEqual ( [number] , self . status_tracker . _number_failures ) [EOL] [EOL] @ freeze_time ( [string] ) def test_submit_result_status_first_ok ( self ) : [EOL] self . submit_result_and_expect ( True , Status . OK , StatusChange . NONE ) [EOL] [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , self . status_tracker . last_success ) [EOL] [EOL] @ freeze_time ( [string] ) def test_submit_result_status_ok_no_change ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . OK [EOL] [EOL] self . submit_result_and_expect ( True , Status . OK , StatusChange . NONE ) [EOL] [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_status_warning_no_change ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . WARNING [EOL] [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NONE ) [EOL] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_status_error_no_change ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . ERROR [EOL] self . status_tracker . _number_retry_attempts = [number] [EOL] [EOL] self . submit_result_and_expect ( False , Status . ERROR , StatusChange . NONE ) [EOL] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_status_ok_new_warning ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . OK [EOL] [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NEW_WARNING ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_status_ok_new_error ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . OK [EOL] self . status_tracker . _number_retry_attempts = [number] [EOL] [EOL] self . submit_result_and_expect ( False , Status . ERROR , StatusChange . NEW_ERROR ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_status_warning_new_error ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . WARNING [EOL] self . status_tracker . _number_retry_attempts = [number] [EOL] [EOL] self . submit_result_and_expect ( False , Status . ERROR , StatusChange . NEW_ERROR ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] @ freeze_time ( [string] ) def test_submit_result_status_warning_resolved ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . WARNING [EOL] self . status_tracker . _number_retry_attempts = [number] [EOL] [EOL] self . submit_result_and_expect ( True , Status . OK , StatusChange . WARNING_RESOLVED ) [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , self . status_tracker . last_success ) [EOL] [EOL] @ freeze_time ( [string] ) def test_submit_result_status_error_resolved ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . ERROR [EOL] self . status_tracker . _number_retry_attempts = [number] [EOL] [EOL] self . submit_result_and_expect ( True , Status . OK , StatusChange . ERROR_RESOLVED ) [EOL] [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , self . status_tracker . last_success ) [EOL] [EOL] def test_submit_result_retry_attempts ( self ) : [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NEW_WARNING ) [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NONE ) [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NONE ) [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NONE ) [EOL] self . submit_result_and_expect ( False , Status . WARNING , StatusChange . NONE ) [EOL] self . submit_result_and_expect ( False , Status . ERROR , StatusChange . NEW_ERROR ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_set_status_invalid_value_error_to_warning ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = Status . ERROR [EOL] [EOL] status_change = self . status_tracker . _set_status ( Status . WARNING ) [EOL] [EOL] self . assertEqual ( Status . WARNING , self . status_tracker . status ) [EOL] self . assertEqual ( StatusChange . INVALID , status_change ) [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] def test_set_status_invalid_type ( self ) : [EOL] with self . assertRaises ( TypeError ) : [EOL] self . status_tracker . _set_status ( - [number] ) [EOL] [EOL] self . assertEqual ( Status . UNKNOWN , self . status_tracker . status ) [EOL] self . assertEqual ( datetime . min , self . status_tracker . last_success ) [EOL] [EOL] @ freeze_time ( [string] ) def test_set_status_invalid_initial_state ( self ) : [EOL] [comment] [EOL] self . status_tracker . _status = - [number] [EOL] [EOL] status_change = self . status_tracker . _set_status ( Status . OK ) [EOL] [EOL] self . assertEqual ( Status . OK , self . status_tracker . status ) [EOL] self . assertEqual ( StatusChange . INVALID , status_change ) [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , self . status_tracker . last_success ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusTracker$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.status_tracker.StatusChange$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] import unittest [EOL] from src . connection_tester import ConnectionTester [EOL] [EOL] [EOL] class TestConnectionTester ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . connection_tester = ConnectionTester ( [string] ) [EOL] [EOL] def test_current_real_connection ( self ) : [EOL] have_connection = self . connection_tester . run_test ( ) [EOL] [EOL] self . assertTrue ( have_connection , [string] [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_tester.ConnectionTester$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0
	0
from typing import Any [EOL] import src [EOL] import typing [EOL] import unittest [EOL] import os [EOL] import json [EOL] from datetime import datetime [EOL] from unittest . mock import MagicMock [EOL] [EOL] from src . notifiers . entry_writer_notifier import EntryWriterNotifier , EntryWriter , FileType , prepare_data_file [EOL] from src . status_tracker import Status , StatusChange [EOL] from src . connection_entry import ConnectionEntry [EOL] [EOL] [EOL] class TestEntryWriterNotifier ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . entry_writer = EntryWriter ( ) [EOL] self . entry_writer . write_new_entry = MagicMock ( ) [EOL] [EOL] self . entry_writer_notifier = EntryWriterNotifier ( self . entry_writer ) [EOL] [EOL] def test_entry_writer_notify ( self ) : [EOL] self . entry_writer_notifier . notify ( datetime ( [number] , [number] , [number] ) , True , Status . OK , StatusChange . ERROR_RESOLVED ) [EOL] [EOL] self . entry_writer . write_new_entry . assert_called_with ( ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . OK , StatusChange . ERROR_RESOLVED ) ) [EOL] [EOL] [EOL] class TestPrepareDataFile ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . data_file = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . remove ( self . data_file ) [EOL] [EOL] def test_creates_file ( self ) : [EOL] prepare_data_file ( self . data_file ) [EOL] [EOL] self . assertEquals ( [number] , os . path . exists ( self . data_file ) ) [EOL] with open ( self . data_file , [string] ) as file : [EOL] contents = file . read ( ) [EOL] self . assertEqual ( [string] , contents ) [EOL] [EOL] def test_doesnt_override_existing_file ( self ) : [EOL] with open ( self . data_file , [string] ) as new_json_file : [EOL] new_json_file . write ( [string] ) [EOL] [EOL] prepare_data_file ( self . data_file ) [EOL] [EOL] with open ( self . data_file , [string] ) as file : [EOL] contents = file . read ( ) [EOL] self . assertEqual ( [string] , contents ) [EOL] [EOL] def test_creates_json_list_file ( self ) : [EOL] prepare_data_file ( self . data_file , file_type = FileType . JSON_LIST ) [EOL] [EOL] self . assertEquals ( [number] , os . path . exists ( self . data_file ) ) [EOL] with open ( self . data_file , [string] ) as json_file : [EOL] json_data = json . load ( json_file ) [EOL] self . assertEqual ( [ ] , json_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.entry_writer_notifier.EntryWriter$ 0 0 0 0 0 0 0 $src.notifiers.entry_writer_notifier.EntryWriter$ 0 0 0 0 0 0 0 0 0 0 $src.notifiers.entry_writer_notifier.EntryWriterNotifier$ 0 0 0 0 0 $src.notifiers.entry_writer_notifier.EntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Dict , Union , Any [EOL] import src [EOL] import typing [EOL] import unittest [EOL] import os [EOL] import json [EOL] from datetime import datetime [EOL] from unittest . mock import MagicMock , patch [EOL] [EOL] from src . notifiers . json_entry_writer import JsonEntryWriter , FileType [EOL] from src . status_tracker import Status , StatusChange [EOL] from src . connection_entry import ConnectionEntry [EOL] [EOL] connection_entry_data = [ { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] } ] [EOL] [EOL] [EOL] class TestJsonEntryWriterInitialisation ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . data_file = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . remove ( self . data_file ) [EOL] [EOL] def test_initiation_creates_file ( self ) : [EOL] json_writer = JsonEntryWriter ( self . data_file ) [EOL] [EOL] self . assertEquals ( [number] , os . path . exists ( self . data_file ) ) [EOL] self . assertEquals ( [ ] , json_writer . _get_test_data ( ) ) [EOL] [EOL] def test_initiation_doesnt_override_existing_file ( self ) : [EOL] with open ( self . data_file , [string] ) as new_json_file : [EOL] json . dump ( connection_entry_data , new_json_file ) [EOL] [EOL] JsonEntryWriter ( self . data_file ) [EOL] [EOL] with open ( self . data_file , [string] ) as blame_data : [EOL] data = json . load ( blame_data ) [EOL] self . assertListEqual ( connection_entry_data , data ) [EOL] [EOL] [EOL] class TestJsonEntryWriterWithFile ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . data_file = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] [EOL] with open ( self . data_file , [string] ) as new_json_file : [EOL] json . dump ( connection_entry_data , new_json_file ) [EOL] [EOL] self . json_writer = JsonEntryWriter ( self . data_file ) [EOL] [EOL] def tearDown ( self ) : [EOL] os . remove ( self . data_file ) [EOL] [EOL] def test_write_entry ( self ) : [EOL] new_entry = ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . WARNING , StatusChange . ERROR_RESOLVED ) [EOL] self . json_writer . write_new_entry ( new_entry ) [EOL] [EOL] final_data = [ { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } ] [EOL] [EOL] with open ( self . data_file , [string] ) as blame_data : [EOL] data = json . load ( blame_data ) [EOL] self . assertListEqual ( final_data , data ) [EOL] [EOL] [EOL] class TestJsonEntryWriterWithoutFile ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] self . patcher = patch ( [string] ) [EOL] self . addCleanup ( self . patcher . stop ) [EOL] self . mock_prepare_data_file = self . patcher . start ( ) [EOL] [EOL] self . json_writer = JsonEntryWriter ( [string] ) [EOL] [EOL] [comment] [EOL] self . json_writer . _get_test_data = MagicMock ( return_value = connection_entry_data ) [EOL] self . json_writer . _save_test_data = MagicMock ( ) [EOL] [EOL] def test_create_blame_entry ( self ) : [EOL] new_entry = ConnectionEntry ( datetime ( [number] , [number] , [number] ) , True , Status . WARNING , StatusChange . ERROR_RESOLVED ) [EOL] self . json_writer . write_new_entry ( new_entry ) [EOL] [EOL] final_data = [ { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : False , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : True , [string] : [string] , [string] : [string] } ] [EOL] [EOL] self . mock_prepare_data_file . assert_called_with ( [string] , FileType . JSON_LIST ) [EOL] self . json_writer . _get_test_data . assert_called ( ) [EOL] self . json_writer . _save_test_data . assert_called_with ( final_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 $src.notifiers.json_entry_writer.JsonEntryWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.connection_entry.ConnectionEntry$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.bool,builtins.str]]]$ 0 0
	0
import unittest [EOL] from src . connection_tester import ConnectionTester [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] class MockConnectionTester ( ConnectionTester ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ConnectionTester , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] self . run_test = MagicMock ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0
import unittest [EOL] from src . status_tracker import StatusTracker [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] class MockStatusTracker ( StatusTracker ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( StatusTracker , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] self . submit_result = MagicMock ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0
import unittest [EOL] from src . notifiers . entry_writer_notifier import EntryWriterNotifier [EOL] from unittest . mock import MagicMock [EOL] [EOL] [EOL] class MockEntryWriterNotifier ( EntryWriterNotifier ) : [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( EntryWriterNotifier , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] self . notify = MagicMock ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.MagicMock$ 0 0 0 0 0
	0