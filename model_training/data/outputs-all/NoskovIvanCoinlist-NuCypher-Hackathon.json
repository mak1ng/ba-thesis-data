[comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Dict , List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] from setuptools import setup , find_packages [EOL] from setuptools . command . install import install [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] PACKAGE_NAME = [string] [EOL] BASE_DIR = os . path . dirname ( __file__ ) [EOL] [EOL] ABOUT = dict ( ) [EOL] with open ( os . path . join ( BASE_DIR , PACKAGE_NAME , [string] ) ) as f : [EOL] exec ( f . read ( ) , ABOUT ) [EOL] [EOL] with open ( os . path . join ( BASE_DIR , [string] ) ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class VerifyVersionCommand ( install ) : [EOL] [docstring] [EOL] description = [string] [EOL] [EOL] def run ( self ) : [EOL] tag = os . getenv ( [string] ) [EOL] if tag . startswith ( [string] ) : [EOL] tag = tag [ [number] : ] [EOL] [EOL] version = ABOUT [ [string] ] [EOL] if version . startswith ( [string] ) : [EOL] version = version [ [number] : ] [EOL] [EOL] if tag != version : [EOL] info = [string] . format ( os . getenv ( [string] ) , ABOUT [ [string] ] ) [EOL] sys . exit ( info ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] with open ( os . path . join ( BASE_DIR , [string] ) ) as f : [EOL] _PIP_FLAGS , * INSTALL_REQUIRES = f . read ( ) . split ( [string] ) [EOL] [EOL] [EOL] TESTS_REQUIRE = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] DEPLOY_REQUIRES = [ [string] , [string] , ] [EOL] [EOL] DOCS_REQUIRE = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] BENCHMARKS_REQUIRE = [ [string] ] [EOL] [EOL] EXTRAS_REQUIRE = { [string] : TESTS_REQUIRE , [string] : DEPLOY_REQUIRES , [string] : DOCS_REQUIRE , [string] : BENCHMARKS_REQUIRE } [EOL] [EOL] setup ( name = ABOUT [ [string] ] , url = ABOUT [ [string] ] , version = ABOUT [ [string] ] , author = ABOUT [ [string] ] , author_email = ABOUT [ [string] ] , description = ABOUT [ [string] ] , license = ABOUT [ [string] ] , long_description = long_description , long_description_content_type = [string] , setup_requires = [ [string] ] , tests_require = TESTS_REQUIRE , install_requires = INSTALL_REQUIRES , extras_require = EXTRAS_REQUIRE , packages = find_packages ( exclude = [ [string] ] ) , package_data = { PACKAGE_NAME : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] } , include_package_data = True , entry_points = { [string] : [ [string] . format ( PACKAGE_NAME ) , [string] . format ( PACKAGE_NAME ) , ] } , cmdclass = { [string] : VerifyVersionCommand } , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , python_requires = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import os [EOL] [EOL] from constant_sorrow . constants import ( UNINITIALIZED_CONFIGURATION ) [EOL] [EOL] from nucypher . config . constants import DEFAULT_CONFIG_ROOT [EOL] from nucypher . config . keyring import NucypherKeyring [EOL] from nucypher . config . node import NodeConfiguration [EOL] [EOL] [EOL] class UrsulaConfiguration ( NodeConfiguration ) : [EOL] from nucypher . characters . lawful import Ursula [EOL] [EOL] _CHARACTER_CLASS = Ursula [EOL] _NAME = _CHARACTER_CLASS . __name__ . lower ( ) [EOL] [EOL] CONFIG_FILENAME = [string] . format ( _NAME ) [EOL] DEFAULT_CONFIG_FILE_LOCATION = os . path . join ( DEFAULT_CONFIG_ROOT , CONFIG_FILENAME ) [EOL] DEFAULT_DB_NAME = [string] . format ( _NAME ) [EOL] [EOL] def __init__ ( self , dev_mode = False , db_filepath = None , * args , ** kwargs ) : [EOL] self . db_filepath = db_filepath or UNINITIALIZED_CONFIGURATION [EOL] super ( ) . __init__ ( dev_mode = dev_mode , * args , ** kwargs ) [EOL] [EOL] def generate_runtime_filepaths ( self , config_root ) : [EOL] base_filepaths = super ( ) . generate_runtime_filepaths ( config_root = config_root ) [EOL] filepaths = dict ( db_filepath = os . path . join ( config_root , self . DEFAULT_DB_NAME ) ) [EOL] base_filepaths . update ( filepaths ) [EOL] return base_filepaths [EOL] [EOL] @ property def static_payload ( self ) : [EOL] payload = dict ( rest_host = self . rest_host , rest_port = self . rest_port , db_filepath = self . db_filepath , ) [EOL] return { ** super ( ) . static_payload , ** payload } [EOL] [EOL] @ property def dynamic_payload ( self ) : [EOL] payload = dict ( network_middleware = self . network_middleware , tls_curve = self . tls_curve , certificate = self . certificate , interface_signature = self . interface_signature , timestamp = None , ) [EOL] return { ** super ( ) . dynamic_payload , ** payload } [EOL] [EOL] def produce ( self , ** overrides ) : [EOL] [docstring] [EOL] [EOL] merged_parameters = self . generate_parameters ( ** overrides ) [EOL] ursula = self . _CHARACTER_CLASS ( ** merged_parameters ) [EOL] [EOL] if self . dev_mode : [EOL] class MockDatastoreThreadPool ( object ) : [EOL] def callInThread ( self , f , * args , ** kwargs ) : [EOL] return f ( * args , ** kwargs ) [EOL] ursula . datastore_threadpool = MockDatastoreThreadPool ( ) [EOL] [EOL] return ursula [EOL] [EOL] def write_keyring ( self , password , ** generation_kwargs ) : [EOL] [EOL] return super ( ) . write_keyring ( password = password , encrypting = True , rest = True , host = self . rest_host , curve = self . tls_curve , ** generation_kwargs ) [EOL] [EOL] [EOL] class AliceConfiguration ( NodeConfiguration ) : [EOL] from nucypher . characters . lawful import Alice [EOL] [EOL] _CHARACTER_CLASS = Alice [EOL] _NAME = _CHARACTER_CLASS . __name__ . lower ( ) [EOL] [EOL] CONFIG_FILENAME = [string] . format ( _NAME ) [EOL] DEFAULT_CONFIG_FILE_LOCATION = os . path . join ( DEFAULT_CONFIG_ROOT , CONFIG_FILENAME ) [EOL] DEFAULT_REST_PORT = [number] [EOL] [EOL] def write_keyring ( self , password , ** generation_kwargs ) : [EOL] [EOL] return super ( ) . write_keyring ( password = password , encrypting = True , rest = False , ** generation_kwargs ) [EOL] [EOL] [EOL] class BobConfiguration ( NodeConfiguration ) : [EOL] from nucypher . characters . lawful import Bob [EOL] [EOL] _CHARACTER_CLASS = Bob [EOL] _NAME = _CHARACTER_CLASS . __name__ . lower ( ) [EOL] [EOL] CONFIG_FILENAME = [string] . format ( _NAME ) [EOL] DEFAULT_CONFIG_FILE_LOCATION = os . path . join ( DEFAULT_CONFIG_ROOT , CONFIG_FILENAME ) [EOL] DEFAULT_REST_PORT = [number] [EOL] [EOL] def write_keyring ( self , password , ** generation_kwargs ) : [EOL] [EOL] return super ( ) . write_keyring ( password = password , encrypting = True , rest = False , ** generation_kwargs ) [EOL] [EOL] [EOL] class FelixConfiguration ( NodeConfiguration ) : [EOL] from nucypher . characters . chaotic import Felix [EOL] [EOL] def __init__ ( self , db_filepath = None , * args , ** kwargs ) : [EOL] [EOL] [comment] [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [comment] [EOL] self . db_filepath = db_filepath or os . path . join ( self . config_root , self . DEFAULT_DB_NAME ) [EOL] [EOL] [comment] [EOL] _CHARACTER_CLASS = Felix [EOL] _NAME = _CHARACTER_CLASS . __name__ . lower ( ) [EOL] [EOL] [comment] [EOL] CONFIG_FILENAME = [string] . format ( _NAME ) [EOL] DEFAULT_CONFIG_FILE_LOCATION = os . path . join ( DEFAULT_CONFIG_ROOT , CONFIG_FILENAME ) [EOL] [EOL] [comment] [EOL] DEFAULT_DB_NAME = [string] . format ( _NAME ) [EOL] DEFAULT_DB_FILEPATH = os . path . join ( DEFAULT_CONFIG_ROOT , DEFAULT_DB_NAME ) [EOL] [EOL] [comment] [EOL] DEFAULT_REST_PORT = [number] [EOL] DEFAULT_LEARNER_PORT = [number] [EOL] [EOL] @ property def static_payload ( self ) : [EOL] payload = dict ( rest_host = self . rest_host , rest_port = self . rest_port , db_filepath = self . db_filepath , ) [EOL] return { ** super ( ) . static_payload , ** payload } [EOL] [EOL] def write_keyring ( self , password , ** generation_kwargs ) : [EOL] [EOL] return super ( ) . write_keyring ( password = password , encrypting = True , rest = True , host = self . rest_host , curve = self . tls_curve , ** generation_kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.config.keyring.NucypherKeyring$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import nucypher [EOL] [EOL] [EOL] NU_BANNER = [string] [EOL] [EOL] NUCYPHER_BANNER = [string] . format ( nucypher . __version__ ) [EOL] [EOL] [EOL] ALICE_BANNER = [string] [EOL] [EOL] [EOL] BOB_BANNER = [string] [EOL] [EOL] [EOL] ENRICO_BANNER = [string] [EOL] [EOL] [EOL] MOE_BANNER = [string] [EOL] [EOL] [EOL] URSULA_BANNER = [string] [EOL] [EOL] FELIX_BANNER = [string]	0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import cryptography [EOL] [docstring] [EOL] [EOL] [EOL] from cryptography . hazmat . primitives import hashes [EOL] [EOL] [comment] [EOL] KECCAK_DIGEST_LENGTH = [number] [EOL] BLAKE2B_DIGEST_LENGTH = [number] [EOL] [EOL] [comment] [EOL] SHA256 = hashes . SHA256 ( ) [EOL] BLAKE2B = hashes . BLAKE2b ( [number] ) [EOL] [EOL] [comment] [EOL] CAPSULE_LENGTH = [number] [EOL] PUBLIC_KEY_LENGTH = [number] [EOL] PUBLIC_ADDRESS_LENGTH = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $cryptography.hazmat.primitives.hashes.SHA256$ 0 0 0 $cryptography.hazmat.primitives.hashes.SHA256$ 0 0 0 $cryptography.hazmat.primitives.hashes.BLAKE2b$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
import builtins [EOL] from typing import Any , Type [EOL] import nucypher [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import os [EOL] from collections import deque [EOL] [EOL] import click [EOL] import maya [EOL] from twisted . internet import reactor [EOL] from twisted . internet . protocol import connectionDone [EOL] from twisted . protocols . basic import LineReceiver [EOL] [EOL] from nucypher . cli . painting import build_fleet_state_status [EOL] [EOL] [EOL] class UrsulaCommandProtocol ( LineReceiver ) : [EOL] [EOL] encoding = [string] [EOL] delimiter = os . linesep . encode ( encoding = encoding ) [EOL] [EOL] def __init__ ( self , ursula ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . ursula = ursula [EOL] self . start_time = maya . now ( ) [EOL] [EOL] self . __history = deque ( maxlen = [number] ) [EOL] self . prompt = bytes ( [string] . format ( self . ursula . checksum_public_address [ : [number] ] ) , encoding = [string] ) [EOL] [EOL] [comment] [EOL] self . __commands = { [string] : self . paintHelp , [string] : self . paintHelp , [string] : self . paintStatus , [string] : self . paintKnownNodes , [string] : self . paintFleetState , [string] : self . paintStakes , [string] : self . confirm_activity , [string] : self . cycle_teacher , [string] : self . start_learning , [string] : self . stop_learning , [string] : self . stop , } [EOL] [EOL] @ property def commands ( self ) : [EOL] return self . __commands . keys ( ) [EOL] [EOL] def paintHelp ( self ) : [EOL] [docstring] [EOL] click . secho ( [string] ) [EOL] for command , func in self . __commands . items ( ) : [EOL] if [string] not in command : [EOL] try : [EOL] click . secho ( f'{ command } [string] { [string] * len ( command ) } [string] { func . __doc__ . lstrip ( ) }' ) [EOL] except AttributeError : [EOL] raise AttributeError ( [string] [string] ) [EOL] [EOL] def paintKnownNodes ( self ) : [EOL] [docstring] [EOL] from nucypher . cli . painting import paint_known_nodes [EOL] paint_known_nodes ( ursula = self . ursula ) [EOL] [EOL] def paintStakes ( self ) : [EOL] [docstring] [EOL] from nucypher . cli . painting import paint_stakes [EOL] if self . ursula . stakes : [EOL] paint_stakes ( stakes = self . ursula . stakes ) [EOL] else : [EOL] click . secho ( [string] ) [EOL] [EOL] def paintStatus ( self ) : [EOL] [docstring] [EOL] from nucypher . cli . painting import paint_node_status [EOL] paint_node_status ( ursula = self . ursula , start_time = self . start_time ) [EOL] [EOL] def paintFleetState ( self ) : [EOL] [docstring] [EOL] line = [string] . format ( build_fleet_state_status ( ursula = self . ursula ) ) [EOL] click . secho ( line ) [EOL] [EOL] def connectionMade ( self ) : [EOL] [EOL] message = [string] . format ( self . ursula . checksum_public_address , self . ursula . rest_url ( ) ) [EOL] [EOL] click . secho ( message , fg = [string] ) [EOL] click . secho ( [string] . format ( self . ursula . nickname_icon , self . ursula . nickname ) , fg = [string] , bold = True ) [EOL] [EOL] click . secho ( [string] ) [EOL] self . transport . write ( self . prompt ) [EOL] [EOL] def connectionLost ( self , reason = connectionDone ) : [EOL] self . ursula . stop_learning_loop ( reason = reason ) [EOL] [EOL] def lineReceived ( self , line ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] raw_line = line . decode ( encoding = self . encoding ) [EOL] line = raw_line . strip ( ) . lower ( ) [EOL] [EOL] [comment] [EOL] try : [EOL] self . __commands [ line ] ( ) [EOL] [EOL] [comment] [EOL] except KeyError : [EOL] if line : [comment] [EOL] click . secho ( [string] . format ( [string] . join ( self . __commands . keys ( ) ) ) ) [EOL] [EOL] else : [EOL] self . __history . append ( raw_line ) [EOL] [EOL] [comment] [EOL] self . transport . write ( self . prompt ) [EOL] [EOL] def cycle_teacher ( self ) : [EOL] [docstring] [EOL] return self . ursula . cycle_teacher_node ( ) [EOL] [EOL] def start_learning ( self ) : [EOL] [docstring] [EOL] return self . ursula . start_learning_loop ( ) [EOL] [EOL] def stop_learning ( self ) : [EOL] [docstring] [EOL] return self . ursula . stop_learning_loop ( ) [EOL] [EOL] def confirm_activity ( self ) : [EOL] [docstring] [EOL] return self . ursula . confirm_activity ( ) [EOL] [EOL] def stop ( self ) : [EOL] [docstring] [EOL] return reactor . stop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import nucypher [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] [EOL] import click [EOL] [EOL] from nucypher . blockchain . eth . actors import Deployer [EOL] from nucypher . blockchain . eth . agents import NucypherTokenAgent [EOL] from nucypher . blockchain . eth . chains import Blockchain [EOL] from nucypher . blockchain . eth . interfaces import BlockchainInterface [EOL] from nucypher . blockchain . eth . registry import EthereumContractRegistry [EOL] from nucypher . cli . config import nucypher_deployer_config [EOL] from nucypher . cli . types import EIP55_CHECKSUM_ADDRESS , EXISTING_READABLE_FILE [EOL] from nucypher . config . constants import DEFAULT_CONFIG_ROOT [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . option ( [string] , is_flag = True ) @ click . option ( [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = EIP55_CHECKSUM_ADDRESS ) @ click . option ( [string] , help = [string] , type = EIP55_CHECKSUM_ADDRESS ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , type = click . INT ) @ click . option ( [string] , help = [string] , type = click . Path ( file_okay = True ) ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , type = click . Path ( exists = False , file_okay = True ) ) @ nucypher_deployer_config def deploy ( click_config , action , poa , provider_uri , deployer_address , contract_name , allocation_infile , allocation_outfile , registry_infile , registry_outfile , no_compile , amount , recipient_address , force ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if not os . path . exists ( DEFAULT_CONFIG_ROOT ) : [EOL] os . makedirs ( DEFAULT_CONFIG_ROOT ) [EOL] [EOL] [comment] [EOL] registry , registry_filepath = None , ( registry_outfile or registry_infile ) [EOL] if registry_filepath is not None : [EOL] registry = EthereumContractRegistry ( registry_filepath = registry_filepath ) [EOL] [EOL] [comment] [EOL] blockchain = Blockchain . connect ( provider_uri = provider_uri , registry = registry , deployer = True , compile = not no_compile , poa = poa ) [EOL] [EOL] [comment] [EOL] if not deployer_address : [EOL] etherbase = blockchain . interface . w3 . eth . accounts [ [number] ] [EOL] deployer_address = etherbase [comment] [EOL] [EOL] click . confirm ( [string] . format ( deployer_address ) , abort = True ) [EOL] deployer = Deployer ( blockchain = blockchain , deployer_address = deployer_address ) [EOL] [EOL] [comment] [EOL] if action == [string] : [EOL] secrets = click_config . collect_deployment_secrets ( ) [EOL] [EOL] [comment] [EOL] __deployment_transactions = dict ( ) [EOL] __deployment_agents = dict ( ) [EOL] [EOL] if force : [EOL] deployer . blockchain . interface . registry . _destroy ( ) [EOL] [EOL] try : [EOL] txhashes , agents = deployer . deploy_network_contracts ( miner_secret = bytes ( secrets . miner_secret , encoding = [string] ) , policy_secret = bytes ( secrets . policy_secret , encoding = [string] ) ) [EOL] except BlockchainInterface . InterfaceError : [EOL] raise [comment] [EOL] else : [EOL] __deployment_transactions . update ( txhashes ) [EOL] [EOL] [comment] [EOL] deployer . deploy_escrow_proxy ( secret = bytes ( secrets . escrow_proxy_secret , encoding = [string] ) ) [EOL] click . secho ( [string] , fg = [string] , bold = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if contract_name : [EOL] [EOL] try : [EOL] deployer_func = deployer . deployers [ contract_name ] [EOL] except KeyError : [EOL] message = [string] . format ( contract_name , deployer . deployers . keys ( ) ) [EOL] click . secho ( message , fg = [string] , bold = True ) [EOL] raise click . Abort ( ) [EOL] else : [EOL] _txs , _agent = deployer_func ( ) [EOL] [EOL] registry_outfile = deployer . blockchain . interface . registry . filepath [EOL] click . secho ( [string] . format ( registry_outfile ) , bold = True , fg = [string] ) [EOL] for contract_name , transactions in __deployment_transactions . items ( ) : [EOL] [EOL] heading = [string] . format ( contract_name , agents [ contract_name ] . contract_address ) [EOL] click . secho ( heading , bold = True ) [EOL] click . echo ( [string] * ( [number] + [number] + len ( contract_name ) ) ) [EOL] [EOL] total_gas_used = [number] [EOL] for tx_name , txhash in transactions . items ( ) : [EOL] receipt = deployer . blockchain . wait_for_receipt ( txhash = txhash ) [EOL] total_gas_used += int ( receipt [ [string] ] ) [EOL] [EOL] if receipt [ [string] ] == [number] : [EOL] click . secho ( [string] , fg = [string] , nl = False , bold = True ) [EOL] else : [EOL] click . secho ( [string] , fg = [string] , nl = False , bold = True ) [EOL] click . secho ( [string] . format ( tx_name ) , fg = [string] , nl = False ) [EOL] click . secho ( [string] . format ( txhash . hex ( ) ) , fg = [string] , nl = False ) [EOL] click . secho ( [string] . format ( receipt [ [string] ] ) ) [EOL] [EOL] click . secho ( [string] . format ( receipt [ [string] ] , receipt [ [string] ] . hex ( ) ) ) [EOL] [EOL] click . secho ( [string] . format ( total_gas_used ) , bold = True , fg = [string] ) [EOL] [EOL] elif action == [string] : [EOL] if not allocation_infile : [EOL] allocation_infile = click . prompt ( [string] ) [EOL] click . confirm ( [string] , abort = True ) [EOL] deployer . deploy_beneficiaries_from_file ( allocation_data_filepath = allocation_infile , allocation_outfile = allocation_outfile ) [EOL] [EOL] elif action == [string] : [EOL] token_agent = NucypherTokenAgent ( blockchain = blockchain ) [EOL] click . confirm ( f" [string] { amount } [string] { token_agent . contract_address } [string] { recipient_address } [string] " , abort = True ) [EOL] txhash = token_agent . transfer ( amount = amount , sender_address = token_agent . contract_address , target_address = recipient_address ) [EOL] click . secho ( f" [string] { txhash }" ) [EOL] return [EOL] [EOL] elif action == [string] : [EOL] registry_filepath = deployer . blockchain . interface . registry . filepath [EOL] click . confirm ( f" [string] { registry_filepath } [string] " , abort = True ) [EOL] os . remove ( registry_filepath ) [EOL] click . secho ( f" [string] { registry_filepath }" , fg = [string] ) [EOL] [EOL] else : [EOL] raise click . BadArgumentUsage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import click [EOL] from constant_sorrow import constants [EOL] from nucypher . characters . banners import MOE_BANNER [EOL] [EOL] from nucypher . characters . chaotic import Moe [EOL] from nucypher . cli import actions [EOL] from nucypher . cli . config import nucypher_click_config [EOL] from nucypher . cli . types import NETWORK_PORT [EOL] from nucypher . network . middleware import RestMiddleware [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . INT , default = [number] ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = [number] ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = [number] ) @ click . option ( [string] , [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , is_flag = True ) @ nucypher_click_config def moe ( click_config , teacher_uri , min_stake , network , ws_port , dry_run , http_port , learn_on_launch ) : [EOL] [EOL] [docstring] [EOL] [EOL] if not click_config . json_ipc and not click_config . quiet : [EOL] click . secho ( MOE_BANNER ) [EOL] [EOL] [comment] [EOL] teacher_uris = [ teacher_uri ] if teacher_uri else list ( ) [EOL] teacher_nodes = actions . load_seednodes ( teacher_uris = teacher_uris , min_stake = min_stake , federated_only = True , network_middleware = click_config . middleware ) [EOL] [EOL] [comment] [EOL] if network : [EOL] domain_constant = getattr ( constants , network . upper ( ) ) [EOL] domains = { domain_constant } [EOL] else : [EOL] domains = None [EOL] [EOL] monitor = Moe ( domains = domains , network_middleware = RestMiddleware ( ) , known_nodes = teacher_nodes , federated_only = True ) [EOL] [EOL] monitor . start_learning_loop ( now = learn_on_launch ) [EOL] monitor . start ( http_port = http_port , ws_port = ws_port , dry_run = dry_run ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import click [EOL] from umbral . keys import UmbralPublicKey [EOL] [EOL] from nucypher . characters . banners import ENRICO_BANNER [EOL] from nucypher . characters . control . emitters import IPCStdoutEmitter [EOL] from nucypher . characters . lawful import Enrico [EOL] from nucypher . cli . config import nucypher_click_config [EOL] from nucypher . cli . types import NETWORK_PORT [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . option ( [string] , [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = [number] ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ nucypher_click_config def enrico ( click_config , action , policy_encrypting_key , dry_run , http_port , message ) : [EOL] [docstring] [EOL] [EOL] if not policy_encrypting_key : [EOL] raise click . BadArgumentUsage ( [string] ) [EOL] [EOL] if not click_config . json_ipc and not click_config . quiet : [EOL] click . secho ( ENRICO_BANNER ) [EOL] [EOL] policy_encrypting_key = UmbralPublicKey . from_bytes ( bytes . fromhex ( policy_encrypting_key ) ) [EOL] ENRICO = Enrico ( policy_encrypting_key = policy_encrypting_key ) [EOL] [EOL] if click_config . json_ipc : [EOL] ENRICO . controller . emitter = IPCStdoutEmitter ( quiet = click_config . quiet ) [EOL] [EOL] if action == [string] : [comment] [EOL] controller = ENRICO . make_web_controller ( ) [EOL] ENRICO . log . info ( [string] ) [EOL] return controller . start ( http_port = http_port , dry_run = dry_run ) [EOL] [EOL] elif action == [string] : [EOL] if not message : [EOL] raise click . BadArgumentUsage ( [string] ) [EOL] [EOL] encryption_request = { [string] : message } [EOL] [EOL] response = ENRICO . controller . encrypt_message ( request = encryption_request ) [EOL] return response [EOL] [EOL] else : [EOL] raise click . BadArgumentUsage [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional [EOL] import typing [EOL] import os [EOL] [EOL] import click [EOL] [EOL] from nucypher . characters . banners import FELIX_BANNER [EOL] from nucypher . cli import actions , painting [EOL] from nucypher . cli . config import nucypher_click_config [EOL] from nucypher . cli . types import NETWORK_PORT , EXISTING_READABLE_FILE , EIP55_CHECKSUM_ADDRESS [EOL] from nucypher . config . characters import FelixConfiguration [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . INT , default = [number] ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING , default = [string] ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = FelixConfiguration . DEFAULT_REST_PORT ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = FelixConfiguration . DEFAULT_LEARNER_PORT ) @ click . option ( [string] , [string] , help = [string] , is_flag = True , default = False ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . Path ( ) ) @ click . option ( [string] , help = [string] , type = EIP55_CHECKSUM_ADDRESS ) @ click . option ( [string] , help = [string] , is_flag = True , default = None ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , is_flag = True ) @ nucypher_click_config def felix ( click_config , action , teacher_uri , min_stake , network , host , dry_run , port , discovery_port , provider_uri , config_root , checksum_address , poa , config_file , db_filepath , no_registry , registry_filepath , force ) : [EOL] [EOL] if not click_config . quiet : [EOL] click . secho ( FELIX_BANNER . format ( checksum_address or [string] ) ) [EOL] [EOL] if action == [string] : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if not network : [EOL] raise click . BadArgumentUsage ( [string] ) [EOL] [EOL] [comment] [EOL] if not checksum_address : [EOL] raise click . BadArgumentUsage ( [string] ) [EOL] [EOL] [comment] [EOL] if not config_root : [comment] [EOL] config_root = click_config . config_file [comment] [EOL] new_password = click_config . get_password ( confirm = True ) [EOL] [EOL] new_felix_config = FelixConfiguration . generate ( password = new_password , config_root = config_root , rest_host = host , rest_port = discovery_port , db_filepath = db_filepath , domains = { network } if network else None , checksum_public_address = checksum_address , no_registry = no_registry , registry_filepath = registry_filepath , provider_uri = provider_uri , poa = poa ) [EOL] [EOL] [comment] [EOL] painting . paint_new_installation_help ( new_configuration = new_felix_config , config_root = config_root , config_file = config_file ) [EOL] [EOL] return [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] domains = [ bytes ( network , encoding = [string] ) ] if network else None [EOL] [EOL] [comment] [EOL] try : [EOL] felix_config = FelixConfiguration . from_configuration_file ( filepath = config_file , domains = domains , registry_filepath = registry_filepath , provider_uri = provider_uri , rest_host = host , rest_port = port , db_filepath = db_filepath , poa = poa ) [EOL] except FileNotFoundError : [EOL] click . secho ( f" [string] { config_file } [string] " f" [string] " ) [EOL] raise click . Abort [EOL] [EOL] else : [EOL] [EOL] [comment] [EOL] teacher_uris = [ teacher_uri ] if teacher_uri else list ( ) [EOL] teacher_nodes = actions . load_seednodes ( teacher_uris = teacher_uris , min_stake = min_stake , federated_only = False , network_middleware = click_config . middleware ) [EOL] [EOL] [comment] [EOL] click_config . unlock_keyring ( character_configuration = felix_config ) [EOL] FELIX = felix_config . produce ( domains = network , known_nodes = teacher_nodes ) [EOL] FELIX . make_web_app ( ) [comment] [EOL] [EOL] if action == [string] : [comment] [EOL] if os . path . isfile ( FELIX . db_filepath ) : [EOL] if not force : [EOL] click . confirm ( [string] , abort = True ) [EOL] os . remove ( FELIX . db_filepath ) [EOL] click . secho ( f" [string] { FELIX . db_filepath }" ) [EOL] [EOL] FELIX . create_tables ( ) [EOL] click . secho ( f" [string] { FELIX . db_filepath }" ) [EOL] [EOL] elif action == [string] : [EOL] token_balance = FELIX . token_balance [EOL] eth_balance = FELIX . eth_balance [EOL] click . secho ( f""" [string] { FELIX . checksum_public_address } [string] { str ( token_balance ) } [string] { str ( eth_balance ) } [string] """ ) [EOL] return [EOL] [EOL] elif action == [string] : [EOL] accounts = FELIX . blockchain . interface . w3 . eth . accounts [EOL] for account in accounts : [EOL] click . secho ( account ) [EOL] return [EOL] [EOL] elif action == [string] : [comment] [EOL] FELIX . start ( host = host , port = port , web_services = not dry_run , distribution = True , crash_on_error = click_config . debug ) [EOL] [EOL] else : [comment] [EOL] raise click . BadArgumentUsage ( [string] . format ( action ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import datetime [EOL] from base64 import b64encode [EOL] [EOL] import click [EOL] import maya [EOL] [EOL] from nucypher . characters . banners import ALICE_BANNER [EOL] from nucypher . characters . control . emitters import IPCStdoutEmitter [EOL] from nucypher . cli import actions , painting [EOL] from nucypher . cli . config import nucypher_click_config [EOL] from nucypher . cli . types import NETWORK_PORT , EXISTING_READABLE_FILE [EOL] from nucypher . config . characters import AliceConfiguration [EOL] from nucypher . config . constants import GLOBAL_DOMAIN [EOL] [EOL] [EOL] @ click . command ( ) @ click . argument ( [string] ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . INT , default = [number] ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = [number] ) @ click . option ( [string] , help = [string] , type = NETWORK_PORT , default = [number] ) @ click . option ( [string] , [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . Path ( ) ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , type = EXISTING_READABLE_FILE ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . STRING ) @ click . option ( [string] , help = [string] , type = click . INT ) @ click . option ( [string] , help = [string] , type = click . INT ) @ click . option ( [string] , [string] , help = [string] , is_flag = True ) @ click . option ( [string] , help = [string] , is_flag = True ) @ click . option ( [string] , [string] , help = [string] , is_flag = True ) @ nucypher_click_config def alice ( click_config , action , teacher_uri , min_stake , http_port , discovery_port , federated_only , network , config_root , config_file , provider_uri , no_registry , registry_filepath , dev , force , dry_run , bob_encrypting_key , bob_verifying_key , policy_encrypting_key , label , m , n ) : [EOL] [EOL] [docstring] [EOL] [EOL] if not click_config . json_ipc and not click_config . quiet : [EOL] click . secho ( ALICE_BANNER ) [EOL] [EOL] if action == [string] : [EOL] [docstring] [EOL] [EOL] if not network : [EOL] raise click . BadArgumentUsage ( [string] ) [EOL] [EOL] if dev : [EOL] click_config . emitter ( message = [string] , color = [string] ) [EOL] [EOL] if not config_root : [comment] [EOL] config_root = click_config . config_file [comment] [EOL] [EOL] new_alice_config = AliceConfiguration . generate ( password = click_config . get_password ( confirm = True ) , config_root = config_root , rest_host = [string] , domains = { network } if network else None , federated_only = federated_only , no_registry = no_registry , registry_filepath = registry_filepath , provider_uri = provider_uri ) [EOL] [EOL] return painting . paint_new_installation_help ( new_configuration = new_alice_config , config_root = config_root , config_file = config_file ) [EOL] [EOL] elif action == [string] : [EOL] [docstring] [EOL] if dev : [EOL] message = [string] [EOL] raise click . BadOptionUsage ( option_name = [string] , message = message ) [EOL] [EOL] destroyed_path = actions . destroy_system_configuration ( config_class = AliceConfiguration , config_file = config_file , network = network , config_root = config_root , force = force ) [EOL] [EOL] return nucypher_click_config . emitter ( message = f" [string] { destroyed_path }" , color = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if dev : [EOL] alice_config = AliceConfiguration ( dev_mode = True , network_middleware = click_config . middleware , domains = { network } , provider_uri = provider_uri , federated_only = True ) [EOL] [EOL] else : [EOL] alice_config = AliceConfiguration . from_configuration_file ( filepath = config_file , domains = { network or GLOBAL_DOMAIN } , network_middleware = click_config . middleware , rest_port = discovery_port , provider_uri = provider_uri ) [EOL] [EOL] if not dev : [EOL] click_config . unlock_keyring ( character_configuration = alice_config ) [EOL] [EOL] [comment] [EOL] teacher_uris = [ teacher_uri ] if teacher_uri else list ( ) [EOL] teacher_nodes = actions . load_seednodes ( teacher_uris = teacher_uris , min_stake = min_stake , federated_only = federated_only , network_middleware = click_config . middleware ) [EOL] [comment] [EOL] ALICE = alice_config ( known_nodes = teacher_nodes , network_middleware = click_config . middleware ) [EOL] [EOL] [comment] [EOL] if click_config . json_ipc : [EOL] ALICE . controller . emitter = IPCStdoutEmitter ( quiet = click_config . quiet ) [EOL] [EOL] if action == [string] : [EOL] [docstring] [EOL] ALICE . controller . emitter ( message = f" [string] { bytes ( ALICE . stamp ) . hex ( ) }" , color = [string] , bold = True ) [EOL] controller = ALICE . make_web_controller ( crash_on_error = click_config . debug ) [EOL] ALICE . log . info ( [string] ) [EOL] return controller . start ( http_port = http_port , dry_run = dry_run ) [EOL] [EOL] elif action == [string] : [EOL] [docstring] [EOL] configuration_file_location = config_file or alice_config . config_file_location [EOL] response = AliceConfiguration . _read_configuration_file ( filepath = configuration_file_location ) [EOL] return ALICE . controller . emitter ( response = response ) [comment] [EOL] [EOL] elif action == [string] : [EOL] response = ALICE . controller . public_keys ( ) [EOL] return response [EOL] [EOL] elif action == [string] : [EOL] if not all ( ( bob_verifying_key , bob_encrypting_key , label ) ) : [EOL] raise click . BadArgumentUsage ( message = [string] [string] ) [EOL] [EOL] create_policy_request = { [string] : bob_encrypting_key , [string] : bob_verifying_key , [string] : label , [string] : m , [string] : n , } [EOL] [EOL] return ALICE . controller . create_policy ( request = create_policy_request ) [EOL] [EOL] elif action == [string] : [EOL] return ALICE . controller . derive_policy_encrypting_key ( label = label ) [EOL] [EOL] elif action == [string] : [EOL] grant_request = { [string] : bob_encrypting_key , [string] : bob_verifying_key , [string] : label , [string] : m , [string] : n , [string] : ( maya . now ( ) + datetime . timedelta ( days = [number] ) ) . iso8601 ( ) , } [EOL] [EOL] return ALICE . controller . grant ( request = grant_request ) [EOL] [EOL] elif action == [string] : [EOL] return ALICE . controller . revoke ( policy_encrypting_key = policy_encrypting_key ) [EOL] [EOL] else : [EOL] raise click . BadArgumentUsage ( f" [string] { action }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import datetime [EOL] import pathlib [EOL] [EOL] from sentry_sdk import capture_exception , add_breadcrumb [EOL] from sentry_sdk . integrations . logging import LoggingIntegration [EOL] from twisted . logger import FileLogObserver , jsonFileLogObserver , formatEvent , formatEventAsClassicLogText [EOL] from twisted . logger import ILogObserver [EOL] from twisted . logger import LogLevel [EOL] from twisted . python . logfile import DailyLogFile [EOL] from zope . interface import provider [EOL] [EOL] import nucypher [EOL] from nucypher . config . constants import USER_LOG_DIR [EOL] from twisted . logger import globalLogPublisher [EOL] [EOL] [EOL] def initialize_sentry ( dsn ) : [EOL] import sentry_sdk [EOL] import logging [EOL] [EOL] sentry_logging = LoggingIntegration ( level = logging . INFO , event_level = logging . DEBUG ) [EOL] sentry_sdk . init ( dsn = dsn , integrations = [ sentry_logging ] , release = nucypher . __version__ ) [EOL] [EOL] [EOL] def _get_or_create_user_log_dir ( ) : [EOL] return pathlib . Path ( USER_LOG_DIR ) . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [EOL] def getJsonFileObserver ( name = [string] , path = USER_LOG_DIR ) : [comment] [EOL] _get_or_create_user_log_dir ( ) [EOL] logfile = DailyLogFile ( name , path ) [EOL] observer = jsonFileLogObserver ( outFile = logfile ) [EOL] return observer [EOL] [EOL] [EOL] def getTextFileObserver ( name = [string] , path = USER_LOG_DIR ) : [EOL] _get_or_create_user_log_dir ( ) [EOL] logfile = DailyLogFile ( name , path ) [EOL] observer = FileLogObserver ( formatEvent = formatEventAsClassicLogText , outFile = logfile ) [EOL] return observer [EOL] [EOL] [EOL] class SimpleObserver : [EOL] [EOL] @ provider ( ILogObserver ) def __call__ ( self , event ) : [EOL] if event [ [string] ] >= GlobalConsoleLogger . log_level : [EOL] event [ [string] ] = event [ [string] ] [EOL] print ( formatEvent ( event ) ) [EOL] [EOL] [EOL] class GlobalConsoleLogger : [EOL] [EOL] log_level = LogLevel . levelWithName ( [string] ) [EOL] started = False [EOL] [EOL] @ classmethod def set_log_level ( cls , log_level_name ) : [EOL] cls . log_level = LogLevel . levelWithName ( log_level_name ) [EOL] if not cls . started : [EOL] cls . start ( ) [EOL] [EOL] @ classmethod def start ( cls ) : [EOL] globalLogPublisher . addObserver ( getTextFileObserver ( ) ) [EOL] cls . started = True [EOL] [EOL] @ classmethod def start_if_not_started ( cls ) : [EOL] if not cls . started : [EOL] cls . start ( ) [EOL] [EOL] [EOL] def logToSentry ( event ) : [EOL] [EOL] [comment] [EOL] if not event . get ( [string] ) or [string] not in event : [EOL] add_breadcrumb ( level = event . get ( [string] ) . name , message = event . get ( [string] ) , category = event . get ( [string] ) ) [EOL] return [EOL] [EOL] [comment] [EOL] f = event [ [string] ] [EOL] capture_exception ( ( f . type , f . value , f . getTracebackObject ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[nucypher.utilities.logging.GlobalConsoleLogger]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import socket [EOL] [docstring] [EOL] [EOL] [EOL] import contextlib [EOL] import os [EOL] import socket [EOL] import time [EOL] from datetime import datetime [EOL] from random import SystemRandom [EOL] from string import digits , ascii_uppercase [EOL] [EOL] from web3 import Web3 [EOL] [EOL] from nucypher . blockchain . eth . constants import DISPATCHER_SECRET_LENGTH , NUNITS_PER_TOKEN [EOL] from nucypher . config . characters import UrsulaConfiguration [EOL] from nucypher . config . constants import BASE_DIR [EOL] [EOL] [EOL] def select_test_port ( ) : [EOL] [docstring] [EOL] [EOL] closed_socket = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) [EOL] with contextlib . closing ( closed_socket ) as open_socket : [EOL] open_socket . bind ( ( [string] , [number] ) ) [EOL] port = open_socket . getsockname ( ) [ [number] ] [EOL] [EOL] if port == UrsulaConfiguration . DEFAULT_REST_PORT : [EOL] return select_test_port ( ) [EOL] [EOL] open_socket . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] return port [EOL] [EOL] [EOL] MOCK_POLICY_DEFAULT_M = [number] [EOL] [EOL] MOCK_URSULA_STARTING_PORT = select_test_port ( ) [EOL] [EOL] MOCK_KNOWN_URSULAS_CACHE = { } [EOL] [EOL] NUMBER_OF_URSULAS_IN_DEVELOPMENT_NETWORK = [number] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] TEST_CONTRACTS_DIR = os . path . join ( BASE_DIR , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] DEVELOPMENT_TOKEN_AIRDROP_AMOUNT = [number] * int ( NUNITS_PER_TOKEN ) [EOL] [EOL] DEVELOPMENT_ETH_AIRDROP_AMOUNT = [number] ** [number] * [number] ** [number] [comment] [EOL] [EOL] MINERS_ESCROW_DEPLOYMENT_SECRET = os . urandom ( DISPATCHER_SECRET_LENGTH ) [EOL] [EOL] POLICY_MANAGER_DEPLOYMENT_SECRET = os . urandom ( DISPATCHER_SECRET_LENGTH ) [EOL] [EOL] INSECURE_DEVELOPMENT_PASSWORD = [string] . join ( SystemRandom ( ) . choice ( ascii_uppercase + digits ) for _ in range ( [number] ) ) [EOL] [EOL] MAX_TEST_SEEDER_ENTRIES = [number] [EOL] [EOL] TESTING_ETH_AIRDROP_AMOUNT = int ( Web3 ( ) . fromWei ( [number] , [string] ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] BASE_TEMP_DIR = os . path . join ( [string] , [string] ) [EOL] [EOL] BASE_TEMP_PREFIX = [string] [EOL] [EOL] MOCK_CUSTOM_INSTALLATION_PATH = os . path . join ( BASE_TEMP_DIR , f'{ BASE_TEMP_PREFIX } [string] { str ( datetime . now ( ) ) }' ) [EOL] [EOL] MOCK_ALLOCATION_INFILE = os . path . join ( BASE_TEMP_DIR , f'{ BASE_TEMP_PREFIX } [string] { str ( datetime . now ( ) ) } [string] ' ) [EOL] [EOL] MOCK_ALLOCATION_REGISTRY_FILEPATH = os . path . join ( BASE_TEMP_DIR , f'{ BASE_TEMP_PREFIX } [string] { str ( datetime . now ( ) ) } [string] ' ) [EOL] [EOL] MOCK_CUSTOM_INSTALLATION_PATH_2 = [string] . format ( time . time ( ) ) [EOL] [EOL] MOCK_REGISTRY_FILEPATH = os . path . join ( BASE_TEMP_DIR , f'{ BASE_TEMP_PREFIX } [string] { str ( datetime . now ( ) ) } [string] ' ) [EOL] [EOL] TEMPORARY_DOMAIN = [string] [comment] [EOL] [EOL] GETH_DEV_URI = f' [string] { BASE_TEMP_DIR } [string] ' [comment] [EOL] [EOL] PYEVM_DEV_URI = [string] [EOL] [EOL] TEST_PROVIDER_URI = PYEVM_DEV_URI [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] MOCK_IP_ADDRESS = [string] [EOL] [EOL] MOCK_IP_ADDRESS_2 = [string] [EOL] [EOL] MOCK_URSULA_DB_FILEPATH = [string] [EOL] [EOL] PYEVM_GAS_LIMIT = [number] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Tuple , Any [EOL] import maya [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] [docstring] [EOL] [EOL] import maya [EOL] [EOL] from nucypher . blockchain . eth . constants import ( MIN_ALLOWED_LOCKED , MAX_ALLOWED_LOCKED , MIN_LOCKED_PERIODS , MAX_MINTING_PERIODS , SECONDS_PER_PERIOD ) [EOL] [EOL] [EOL] def datetime_to_period ( datetime ) : [EOL] [docstring] [EOL] future_period = datetime . epoch // int ( SECONDS_PER_PERIOD ) [EOL] return int ( future_period ) [EOL] [EOL] [EOL] def datetime_at_period ( period ) : [EOL] [docstring] [EOL] [EOL] now = maya . now ( ) [EOL] current_period = datetime_to_period ( datetime = now ) [EOL] delta_periods = period - current_period [EOL] [EOL] [comment] [EOL] if delta_periods : [EOL] target_period = now + maya . timedelta ( days = delta_periods ) [EOL] [EOL] [comment] [EOL] else : [EOL] target_period = now - maya . timedelta ( days = delta_periods ) [EOL] [EOL] return target_period [EOL] [EOL] [EOL] def calculate_period_duration ( future_time ) : [EOL] [docstring] [EOL] future_period = datetime_to_period ( datetime = future_time ) [EOL] current_period = datetime_to_period ( datetime = maya . now ( ) ) [EOL] periods = future_period - current_period [EOL] return periods [EOL] [EOL] [EOL] def __validate ( rulebook ) : [EOL] [docstring] [EOL] for rule , failure_message in rulebook : [EOL] if not rule : [EOL] raise ValueError ( failure_message ) [EOL] return True [EOL] [EOL] [EOL] def validate_stake_amount ( amount , raise_on_fail = True ) : [EOL] [docstring] [EOL] from nucypher . blockchain . eth . token import NU [EOL] [EOL] min_locked = NU ( MIN_ALLOWED_LOCKED , [string] ) [EOL] max_locked = NU ( MAX_ALLOWED_LOCKED , [string] ) [EOL] [EOL] rulebook = ( ( min_locked <= amount , [string] . format ( minimum = min_locked , amount = amount ) ) , ( max_locked >= amount , [string] . format ( maximum = max_locked , amount = amount ) ) , ) [EOL] [EOL] if raise_on_fail is True : [EOL] __validate ( rulebook = rulebook ) [EOL] return all ( rulebook ) [EOL] [EOL] [EOL] def validate_locktime ( lock_periods , raise_on_fail = True ) : [EOL] [docstring] [EOL] [EOL] rulebook = ( ( MIN_LOCKED_PERIODS <= lock_periods , [string] . format ( minimum = MIN_LOCKED_PERIODS , locktime = lock_periods ) ) , ( MAX_MINTING_PERIODS >= lock_periods , [string] . format ( maximum = MAX_MINTING_PERIODS , locktime = lock_periods ) ) , ) [EOL] [EOL] if raise_on_fail is True : [EOL] __validate ( rulebook = rulebook ) [EOL] return all ( rulebook ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $maya.MayaDT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Optional , Any , Union , Type [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] import web3 [EOL] [docstring] [EOL] [EOL] [EOL] from twisted . logger import Logger [EOL] from web3 . middleware import geth_poa_middleware [EOL] [EOL] from constant_sorrow . constants import NO_BLOCKCHAIN_AVAILABLE [EOL] from typing import Union [EOL] from web3 . contract import Contract [EOL] [EOL] from nucypher . blockchain . eth . interfaces import BlockchainInterface , BlockchainDeployerInterface [EOL] from nucypher . blockchain . eth . registry import EthereumContractRegistry [EOL] from nucypher . blockchain . eth . sol . compile import SolidityCompiler [EOL] [EOL] [EOL] class Blockchain : [EOL] [docstring] [EOL] [EOL] _instance = NO_BLOCKCHAIN_AVAILABLE [EOL] __default_interface_class = BlockchainInterface [EOL] [EOL] class ConnectionNotEstablished ( RuntimeError ) : [EOL] pass [EOL] [EOL] def __init__ ( self , interface = None ) : [EOL] [EOL] self . log = Logger ( [string] ) [comment] [EOL] [EOL] [comment] [EOL] if interface is None : [EOL] interface = self . __default_interface_class ( ) [EOL] self . __interface = interface [EOL] [EOL] [comment] [EOL] if self . _instance is NO_BLOCKCHAIN_AVAILABLE : [EOL] Blockchain . _instance = self [EOL] else : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] class_name = self . __class__ . __name__ [EOL] r = [string] [EOL] return r . format ( class_name , self . __interface ) [EOL] [EOL] @ property def interface ( self ) : [EOL] return self . __interface [EOL] [EOL] @ classmethod def connect ( cls , provider_uri = None , registry = None , deployer = False , compile = False , poa = False ) : [EOL] [EOL] if cls . _instance is NO_BLOCKCHAIN_AVAILABLE : [EOL] registry = registry or EthereumContractRegistry ( ) [EOL] compiler = SolidityCompiler ( ) if compile is True else None [EOL] InterfaceClass = BlockchainDeployerInterface if deployer is True else BlockchainInterface [EOL] interface = InterfaceClass ( provider_uri = provider_uri , registry = registry , compiler = compiler ) [EOL] [EOL] if poa is True : [EOL] interface . w3 . middleware_onion . inject ( geth_poa_middleware , layer = [number] ) [EOL] [EOL] cls . _instance = cls ( interface = interface ) [EOL] else : [EOL] if provider_uri is not None : [EOL] existing_uri = cls . _instance . interface . provider_uri [EOL] if existing_uri != provider_uri : [EOL] raise ValueError ( [string] [string] . format ( existing_uri ) ) [EOL] [EOL] if registry is not None : [EOL] [comment] [EOL] [comment] [EOL] cls . _instance . interface . registry = registry [EOL] [EOL] return cls . _instance [EOL] [EOL] def get_contract ( self , name ) : [EOL] [docstring] [EOL] return self . __interface . get_contract_by_name ( name ) [EOL] [EOL] def wait_for_receipt ( self , txhash , timeout = None ) : [EOL] [docstring] [EOL] timeout = timeout if timeout is not None else self . interface . timeout [EOL] result = self . __interface . w3 . eth . waitForTransactionReceipt ( txhash , timeout = timeout ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface,nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface,nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface,nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 0 0 0 0 0 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface,nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface,nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[nucypher.blockchain.eth.interfaces.BlockchainInterface,nucypher.blockchain.eth.interfaces.BlockchainDeployerInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Blockchain'$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[nucypher.blockchain.eth.sol.compile.SolidityCompiler]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Type[nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 $typing.Type[nucypher.blockchain.eth.interfaces.BlockchainInterface]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[nucypher.blockchain.eth.sol.compile.SolidityCompiler]$ 0 $typing.Optional[nucypher.blockchain.eth.sol.compile.SolidityCompiler]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.interfaces.BlockchainInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $web3.contract.Contract$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0
from typing import Any , Dict , Tuple , List , Type , Union [EOL] import _pydecimal [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] from _pydecimal import Decimal [EOL] [EOL] import eth_utils [EOL] import maya [EOL] from eth_utils import currency [EOL] from nacl . hash import sha256 [EOL] from typing import Union , Tuple [EOL] [EOL] from nucypher . blockchain . eth . agents import NucypherTokenAgent [EOL] from nucypher . blockchain . eth . constants import TOKEN_DECIMALS [EOL] from nucypher . blockchain . eth . utils import datetime_at_period , datetime_to_period [EOL] [EOL] [EOL] class NU : [EOL] [docstring] [EOL] [EOL] __symbol = [string] [EOL] __decimals = TOKEN_DECIMALS [EOL] __agent_class = NucypherTokenAgent [EOL] [EOL] [comment] [EOL] __denominations = { [string] : [string] , [string] : [string] } [EOL] [EOL] class InvalidAmount ( ValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value , denomination ) : [EOL] [EOL] [comment] [EOL] wrapped_denom = self . __denominations [ denomination ] [EOL] [EOL] [comment] [EOL] try : [EOL] self . __value = currency . to_wei ( number = value , unit = wrapped_denom ) [EOL] except ValueError as e : [EOL] raise NU . InvalidAmount ( f"{ value } [string] { str ( e ) }" ) [EOL] [EOL] @ classmethod def from_nunits ( cls , value ) : [EOL] return cls ( value , denomination = [string] ) [EOL] [EOL] @ classmethod def from_tokens ( cls , value ) : [EOL] return cls ( value , denomination = [string] ) [EOL] [EOL] def to_tokens ( self ) : [EOL] [docstring] [EOL] return currency . from_wei ( self . __value , unit = [string] ) [EOL] [EOL] def to_nunits ( self ) : [EOL] [docstring] [EOL] return int ( self . __value ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return int ( self ) == int ( other ) [EOL] [EOL] def __bool__ ( self ) : [EOL] if self . __value == [number] : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def __radd__ ( self , other ) : [EOL] return NU ( int ( self ) + int ( other ) , [string] ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return NU ( int ( self ) + int ( other ) , [string] ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return NU ( int ( self ) - int ( other ) , [string] ) [EOL] [EOL] def __rmul__ ( self , other ) : [EOL] return NU ( int ( self ) * int ( other ) , [string] ) [EOL] [EOL] def __mul__ ( self , other ) : [EOL] return NU ( int ( self ) * int ( other ) , [string] ) [EOL] [EOL] def __floordiv__ ( self , other ) : [EOL] return NU ( int ( self ) // int ( other ) , [string] ) [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return int ( self ) > int ( other ) [EOL] [EOL] def __ge__ ( self , other ) : [EOL] return int ( self ) >= int ( other ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return int ( self ) < int ( other ) [EOL] [EOL] def __le__ ( self , other ) : [EOL] return int ( self ) <= int ( other ) [EOL] [EOL] def __int__ ( self ) : [EOL] [docstring] [EOL] return int ( self . to_nunits ( ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] r = f'{ self . __symbol } [string] { str ( self . __value ) } [string] ' [EOL] return r [EOL] [EOL] def __str__ ( self ) : [EOL] return f'{ str ( self . to_tokens ( ) ) } [string] { self . __symbol }' [EOL] [EOL] [EOL] class Stake : [EOL] [docstring] [EOL] [EOL] __ID_LENGTH = [number] [EOL] [EOL] def __init__ ( self , owner_address , index , value , start_period , end_period ) : [EOL] [EOL] [comment] [EOL] self . owner_address = owner_address [EOL] self . index = index [EOL] self . value = value [EOL] self . start_period = start_period [EOL] self . end_period = end_period [EOL] self . duration = ( self . end_period - self . start_period ) + [number] [EOL] [EOL] [comment] [EOL] self . start_datetime = datetime_at_period ( period = start_period ) [EOL] self . end_datetime = datetime_at_period ( period = end_period ) [EOL] self . duration_delta = self . end_datetime - self . start_datetime [EOL] [EOL] def __repr__ ( self ) : [EOL] r = f' [string] { self . index } [string] { self . value } [string] { self . end_period } [string] ' [EOL] return r [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return bool ( self . value == other . value ) [EOL] [EOL] @ classmethod def from_stake_info ( cls , owner_address , index , stake_info ) : [EOL] [docstring] [EOL] start_period , end_period , value = stake_info [EOL] instance = cls ( owner_address = owner_address , index = index , start_period = start_period , end_period = end_period , value = NU ( value , [string] ) ) [EOL] return instance [EOL] [EOL] def to_stake_info ( self ) : [EOL] [docstring] [EOL] return self . start_period , self . end_period , int ( self . value ) [EOL] [EOL] @ property def id ( self ) : [EOL] [docstring] [EOL] digest_elements = list ( ) [EOL] digest_elements . append ( eth_utils . to_canonical_address ( address = self . owner_address ) ) [EOL] digest_elements . append ( str ( self . index ) . encode ( ) ) [EOL] digest_elements . append ( str ( self . start_period ) . encode ( ) ) [EOL] digest_elements . append ( str ( self . end_period ) . encode ( ) ) [EOL] digest_elements . append ( str ( self . value ) . encode ( ) ) [EOL] digest = [string] . join ( digest_elements ) [EOL] stake_id = sha256 ( digest ) . hex ( ) [ : [number] ] [EOL] return stake_id [ : self . __ID_LENGTH ] [EOL] [EOL] @ property def periods_remaining ( self ) : [EOL] [docstring] [EOL] current_period = datetime_to_period ( datetime = maya . now ( ) ) [EOL] return self . end_period - current_period [EOL] [EOL] def time_remaining ( self , slang = False ) : [EOL] [docstring] [EOL] now = maya . now ( ) [EOL] delta = self . end_datetime - now [EOL] [EOL] if slang : [EOL] result = self . end_datetime . slang_date ( ) [EOL] else : [EOL] result = delta . seconds [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[nucypher.blockchain.eth.token.NU]$ 0 0 0 $typing.Type[nucypher.blockchain.eth.agents.NucypherTokenAgent]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float,builtins.str]$ 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.float,builtins.str]$ 0 0 0 0 0 0 0 0 $_pydecimal.Decimal$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'NU'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $nucypher.blockchain.eth.token.NU$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $nucypher.blockchain.eth.token.NU$ 0 $nucypher.blockchain.eth.token.NU$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 $nucypher.blockchain.eth.token.Stake$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.token.Stake$ 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Type , Any , Optional [EOL] import builtins [EOL] import nucypher [EOL] import urllib [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] from urllib . parse import urlparse [EOL] [EOL] from eth_utils import is_checksum_address [EOL] [EOL] from bytestring_splitter import VariableLengthBytestring [EOL] [EOL] [EOL] class SuspiciousActivity ( RuntimeError ) : [EOL] [docstring] [EOL] [EOL] [EOL] def parse_node_uri ( uri ) : [EOL] from nucypher . config . characters import UrsulaConfiguration [EOL] [EOL] if [string] in uri : [EOL] checksum_address , uri = uri . split ( [string] ) [EOL] if not is_checksum_address ( checksum_address ) : [EOL] raise ValueError ( [string] . format ( checksum_address ) ) [EOL] else : [EOL] checksum_address = None [comment] [EOL] [EOL] parsed_uri = urlparse ( uri ) [EOL] [EOL] if not parsed_uri . scheme : [EOL] try : [EOL] parsed_uri = urlparse ( [string] + uri ) [EOL] except Exception : [EOL] raise [comment] [EOL] [EOL] if not parsed_uri . scheme == [string] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] hostname = parsed_uri . hostname [EOL] port = parsed_uri . port or UrsulaConfiguration . DEFAULT_REST_PORT [EOL] return hostname , port , checksum_address [EOL] [EOL] [EOL] class InterfaceInfo : [EOL] expected_bytes_length = lambda : VariableLengthBytestring [EOL] [EOL] def __init__ ( self , host , port ) : [EOL] loopback , localhost = [string] , [string] [EOL] self . host = loopback if host == localhost else host [EOL] self . port = int ( port ) [EOL] [EOL] @ classmethod def from_bytes ( cls , url_string ) : [EOL] host_bytes , port_bytes = url_string . split ( [string] , [number] ) [EOL] port = int . from_bytes ( port_bytes , [string] ) [EOL] host = host_bytes . decode ( [string] ) [EOL] return cls ( host = host , port = port ) [EOL] [EOL] @ property def uri ( self ) : [EOL] return [string] . format ( self . host , self . port ) [EOL] [EOL] @ property def formal_uri ( self ) : [EOL] return [string] . format ( [string] , self . uri ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( self . host , encoding = [string] ) + [string] + self . port . to_bytes ( [number] , [string] ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return bytes ( self ) + bytes ( other ) [EOL] [EOL] def __radd__ ( self , other ) : [EOL] return bytes ( other ) + bytes ( self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type [EOL] import requests [EOL] import typing [EOL] import socket [EOL] import requests , socket [EOL] [EOL] NodeSeemsToBeDown = ( requests . exceptions . ConnectionError , requests . exceptions . ReadTimeout , socket . gaierror , ConnectionRefusedError ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type[requests.exceptions.ConnectionError],typing.Type[requests.exceptions.ReadTimeout],typing.Type[socket.gaierror],typing.Type[builtins.ConnectionRefusedError]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] LEARNING_LOOP_VERSION = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from sqlalchemy import event [EOL] from sqlalchemy . engine import Engine [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] [EOL] Base = declarative_base ( ) [EOL] [EOL] [EOL] @ event . listens_for ( Engine , [string] ) def set_secure_delete_pragma ( dbapi_connection , connection_record ) : [EOL] cursor = dbapi_connection . cursor ( ) [EOL] cursor . execute ( [string] ) [EOL] cursor . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import os [EOL] [EOL] import maya [EOL] import pytest [EOL] [EOL] [EOL] class NucypherPytestRunner : [EOL] TEST_PATH = os . path . join ( [string] , [string] ) [EOL] PYTEST_ARGS = [ [string] , TEST_PATH ] [EOL] [EOL] def pytest_sessionstart ( self ) : [EOL] print ( [string] ) [EOL] self . start_time = maya . now ( ) [EOL] [EOL] def pytest_sessionfinish ( self ) : [EOL] duration = maya . now ( ) - self . start_time [EOL] print ( [string] ) [EOL] print ( [string] . format ( duration ) ) [EOL] [EOL] [EOL] def run ( ) : [EOL] pytest . main ( NucypherPytestRunner . PYTEST_ARGS , plugins = [ NucypherPytestRunner ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type , Any , Set [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] from nucypher . characters . lawful import Ursula [EOL] from nucypher . config . storages import ( ForgetfulNodeStorage , TemporaryFileBasedNodeStorage , NodeStorage ) [EOL] from nucypher . utilities . sandbox . constants import MOCK_URSULA_DB_FILEPATH , MOCK_URSULA_STARTING_PORT [EOL] [EOL] MOCK_S3_BUCKET_NAME = [string] [EOL] S3_DOMAIN_NAME = [string] [EOL] [EOL] [EOL] class BaseTestNodeStorageBackends : [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def light_ursula ( temp_dir_path ) : [EOL] node = Ursula ( rest_host = [string] , rest_port = MOCK_URSULA_STARTING_PORT , db_filepath = MOCK_URSULA_DB_FILEPATH , federated_only = True ) [EOL] yield node [EOL] [EOL] character_class = Ursula [EOL] federated_only = True [EOL] storage_backend = NotImplemented [EOL] [EOL] def _read_and_write_metadata ( self , ursula , node_storage ) : [EOL] [comment] [EOL] node_storage . store_node_metadata ( node = ursula ) [EOL] [EOL] [comment] [EOL] node_from_storage = node_storage . get ( checksum_address = ursula . checksum_public_address , federated_only = True ) [EOL] assert ursula == node_from_storage , [string] . format ( node_storage ) [EOL] [EOL] [comment] [EOL] all_known_nodes = set ( ) [EOL] for port in range ( MOCK_URSULA_STARTING_PORT , MOCK_URSULA_STARTING_PORT + [number] ) : [EOL] node = Ursula ( rest_host = [string] , db_filepath = MOCK_URSULA_DB_FILEPATH , rest_port = port , federated_only = True ) [EOL] node_storage . store_node_metadata ( node = node ) [EOL] all_known_nodes . add ( node ) [EOL] [EOL] [comment] [EOL] all_stored_nodes = node_storage . all ( federated_only = True ) [EOL] all_known_nodes . add ( ursula ) [EOL] assert len ( all_known_nodes ) == len ( all_stored_nodes ) [EOL] assert all_stored_nodes == all_known_nodes [EOL] [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] random_node = all_known_nodes . pop ( ) [EOL] random_node_from_storage = node_storage . get ( checksum_address = random_node . checksum_public_address , federated_only = True ) [EOL] assert random_node . checksum_public_address == random_node_from_storage . checksum_public_address [EOL] [EOL] return True [EOL] [EOL] def _write_and_delete_metadata ( self , ursula , node_storage ) : [EOL] [comment] [EOL] node_storage . store_node_metadata ( node = ursula ) [EOL] [EOL] [comment] [EOL] node_storage . remove ( checksum_address = ursula . checksum_public_address , certificate = False ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( NodeStorage . UnknownNode ) : [EOL] _node_from_storage = node_storage . get ( checksum_address = ursula . checksum_public_address , federated_only = True ) [EOL] [EOL] [comment] [EOL] all_stored_nodes = node_storage . all ( federated_only = True ) [EOL] assert all_stored_nodes == set ( ) [EOL] return True [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_delete_node_in_storage ( self , light_ursula ) : [EOL] assert self . _write_and_delete_metadata ( ursula = light_ursula , node_storage = self . storage_backend ) [EOL] [EOL] def test_read_and_write_to_storage ( self , light_ursula ) : [EOL] assert self . _read_and_write_metadata ( ursula = light_ursula , node_storage = self . storage_backend ) [EOL] [EOL] [EOL] class TestInMemoryNodeStorage ( BaseTestNodeStorageBackends ) : [EOL] storage_backend = ForgetfulNodeStorage ( character_class = BaseTestNodeStorageBackends . character_class , federated_only = BaseTestNodeStorageBackends . federated_only ) [EOL] storage_backend . initialize ( ) [EOL] [EOL] [EOL] class TestTemporaryFileBasedNodeStorage ( BaseTestNodeStorageBackends ) : [EOL] storage_backend = TemporaryFileBasedNodeStorage ( character_class = BaseTestNodeStorageBackends . character_class , federated_only = BaseTestNodeStorageBackends . federated_only ) [EOL] storage_backend . initialize ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Type[tests.config.test_storages.BaseTestNodeStorageBackends]$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Type[tests.config.test_storages.BaseTestNodeStorageBackends]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.config.test_storages.TestInMemoryNodeStorage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.config.test_storages.TestInMemoryNodeStorage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.config.test_storages.TestTemporaryFileBasedNodeStorage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.config.test_storages.TestTemporaryFileBasedNodeStorage]$ 0 0 0 0 0
from typing import Any [EOL] import nucypher [EOL] import typing [EOL] import pytest [EOL] [EOL] from umbral . keys import UmbralPrivateKey [EOL] from umbral . signing import Signer [EOL] [EOL] from nucypher . config . keyring import NucypherKeyring [EOL] from nucypher . crypto . powers import DelegatingPower , DecryptingPower [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_validate_password ( ) : [EOL] [comment] [EOL] password = [string] * [number] [EOL] with pytest . raises ( ValueError ) : [EOL] _keyring = NucypherKeyring . generate ( password = password ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) : [EOL] _keyring = NucypherKeyring . generate ( password = [string] ) [EOL] [EOL] [EOL] def test_generate_alice_keyring ( tmpdir ) : [EOL] password = [string] * [number] [EOL] [EOL] keyring = NucypherKeyring . generate ( password = password , encrypting = True , rest = False , keyring_root = tmpdir ) [EOL] [EOL] enc_pubkey = keyring . encrypting_public_key [EOL] assert enc_pubkey is not None [EOL] [EOL] with pytest . raises ( NucypherKeyring . KeyringLocked ) : [EOL] _dec_keypair = keyring . derive_crypto_power ( DecryptingPower ) . keypair [EOL] [EOL] keyring . unlock ( password ) [EOL] dec_keypair = keyring . derive_crypto_power ( DecryptingPower ) . keypair [EOL] [EOL] assert enc_pubkey == dec_keypair . pubkey [EOL] [EOL] label = [string] [EOL] [EOL] delegating_power = keyring . derive_crypto_power ( DelegatingPower ) [EOL] delegating_pubkey = delegating_power . get_pubkey_from_label ( label ) [EOL] [EOL] bob_pubkey = UmbralPrivateKey . gen_key ( ) . get_pubkey ( ) [EOL] signer = Signer ( UmbralPrivateKey . gen_key ( ) ) [EOL] delegating_pubkey_again , _kfrags = delegating_power . generate_kfrags ( bob_pubkey , signer , label , m = [number] , n = [number] ) [EOL] [EOL] assert delegating_pubkey == delegating_pubkey_again [EOL] [EOL] another_delegating_power = keyring . derive_crypto_power ( DelegatingPower ) [EOL] another_delegating_pubkey = another_delegating_power . get_pubkey_from_label ( label ) [EOL] [EOL] assert delegating_pubkey == another_delegating_pubkey [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Literal , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] from nucypher . cli . deploy import deploy [EOL] from nucypher . cli . main import nucypher_cli [EOL] [EOL] [EOL] def test_nucypher_help_message ( click_runner ) : [EOL] help_args = ( [string] , ) [EOL] result = click_runner . invoke ( nucypher_cli , help_args , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output , [string] [EOL] [EOL] [EOL] def test_nucypher_ursula_help_message ( click_runner ) : [EOL] help_args = ( [string] , [string] ) [EOL] result = click_runner . invoke ( nucypher_cli , help_args , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output , [string] [EOL] [EOL] [EOL] def test_nucypher_deploy_help_message ( click_runner ) : [EOL] help_args = ( [string] , ) [EOL] result = click_runner . invoke ( deploy , help_args , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , Literal , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] import json [EOL] import os [EOL] from json import JSONDecodeError [EOL] [EOL] import pytest [EOL] [EOL] from nucypher . cli . main import nucypher_cli [EOL] from nucypher . config . characters import UrsulaConfiguration [EOL] from nucypher . config . constants import APP_DIR , DEFAULT_CONFIG_ROOT [EOL] from nucypher . utilities . sandbox . constants import ( INSECURE_DEVELOPMENT_PASSWORD , MOCK_CUSTOM_INSTALLATION_PATH , MOCK_IP_ADDRESS , MOCK_URSULA_STARTING_PORT , TEMPORARY_DOMAIN ) [EOL] [EOL] [EOL] def test_initialize_ursula_defaults ( click_runner , mocker ) : [EOL] [EOL] [comment] [EOL] mocker . patch . object ( UrsulaConfiguration , [string] , autospec = True ) [EOL] mocker . patch . object ( UrsulaConfiguration , [string] , autospec = True ) [EOL] [EOL] [comment] [EOL] init_args = ( [string] , [string] , [string] , TEMPORARY_DOMAIN , [string] ) [EOL] [EOL] user_input = [string] . format ( password = INSECURE_DEVELOPMENT_PASSWORD , ip = MOCK_IP_ADDRESS ) [EOL] result = click_runner . invoke ( nucypher_cli , init_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] assert [string] in result . output [EOL] [EOL] [comment] [EOL] assert [string] in result . output , [string] [EOL] assert [string] in result . output , [string] [EOL] [EOL] [EOL] def test_initialize_custom_configuration_root ( custom_filepath , click_runner ) : [EOL] [EOL] [comment] [EOL] init_args = ( [string] , [string] , [string] , TEMPORARY_DOMAIN , [string] , [string] , custom_filepath , [string] , MOCK_IP_ADDRESS , [string] , MOCK_URSULA_STARTING_PORT ) [EOL] [EOL] user_input = [string] . format ( password = INSECURE_DEVELOPMENT_PASSWORD ) [EOL] result = click_runner . invoke ( nucypher_cli , init_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] assert MOCK_CUSTOM_INSTALLATION_PATH in result . output , [string] [EOL] assert [string] in result . output , [string] [EOL] assert [string] not in result . output [EOL] [EOL] [comment] [EOL] assert os . path . isdir ( custom_filepath ) , [string] [EOL] assert os . path . isdir ( os . path . join ( custom_filepath , [string] ) ) , [string] [EOL] assert os . path . isdir ( os . path . join ( custom_filepath , [string] ) ) , [string] [EOL] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [comment] [EOL] assert [string] in result . output , [string] [EOL] assert [string] in result . output , [string] [EOL] [EOL] [EOL] def test_configuration_file_contents ( custom_filepath , nominal_federated_configuration_fields ) : [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [comment] [EOL] with open ( custom_config_filepath , [string] ) as config_file : [EOL] raw_contents = config_file . read ( ) [EOL] [EOL] try : [EOL] data = json . loads ( raw_contents ) [EOL] except JSONDecodeError : [EOL] raise pytest . fail ( msg = [string] . format ( custom_config_filepath ) ) [EOL] [EOL] for field in nominal_federated_configuration_fields : [EOL] assert field in data , [string] [EOL] if any ( keyword in field for keyword in ( [string] , [string] ) ) : [EOL] path = data [ field ] [EOL] user_data_dir = APP_DIR . user_data_dir [EOL] [comment] [EOL] assert user_data_dir not in path , [string] . format ( field , user_data_dir ) [EOL] [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [EOL] def test_password_prompt ( click_runner , custom_filepath ) : [EOL] [EOL] [comment] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] view_args = ( [string] , [string] , [string] , custom_config_filepath ) [EOL] [EOL] user_input = [string] . format ( INSECURE_DEVELOPMENT_PASSWORD ) [EOL] result = click_runner . invoke ( nucypher_cli , view_args , input = user_input , catch_exceptions = False , env = dict ( ) ) [EOL] assert [string] in result . output , [string] [EOL] assert result . exit_code == [number] [EOL] [EOL] envvars = { [string] : INSECURE_DEVELOPMENT_PASSWORD } [EOL] result = click_runner . invoke ( nucypher_cli , view_args , input = user_input , catch_exceptions = False , env = envvars ) [EOL] assert not [string] in result . output , [string] [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] def test_ursula_view_configuration ( custom_filepath , click_runner , nominal_federated_configuration_fields ) : [EOL] [EOL] [comment] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] view_args = ( [string] , [string] , [string] , os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) ) [EOL] [EOL] [comment] [EOL] result = click_runner . invoke ( nucypher_cli , view_args , input = [string] . format ( INSECURE_DEVELOPMENT_PASSWORD ) , catch_exceptions = False ) [EOL] [EOL] [comment] [EOL] assert [string] in result . output , [string] [EOL] assert MOCK_CUSTOM_INSTALLATION_PATH in result . output [EOL] for field in nominal_federated_configuration_fields : [EOL] assert field in result . output , [string] [EOL] [EOL] [comment] [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [EOL] def test_run_federated_ursula_from_config_file ( custom_filepath , click_runner ) : [EOL] [EOL] [comment] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [comment] [EOL] run_args = ( [string] , [string] , [string] , [string] , custom_config_filepath ) [EOL] [EOL] result = click_runner . invoke ( nucypher_cli , run_args , input = [string] . format ( INSECURE_DEVELOPMENT_PASSWORD ) , catch_exceptions = False ) [EOL] [EOL] [comment] [EOL] assert result . exit_code == [number] [EOL] assert [string] in result . output , [string] [EOL] assert [string] in result . output [EOL] assert [string] in result . output [EOL] assert [string] in result . output [EOL] assert [string] in result . output [EOL] [EOL] [EOL] def test_empty_federated_status ( click_runner , custom_filepath ) : [EOL] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] status_args = ( [string] , [string] , custom_config_filepath ) [EOL] result = click_runner . invoke ( nucypher_cli , status_args , catch_exceptions = True ) [EOL] [EOL] assert result . exit_code == [number] [EOL] [EOL] assert [string] in result . output [EOL] heading = [string] [EOL] assert heading in result . output [EOL] assert [string] not in result . output [EOL] [EOL] [EOL] def test_ursula_destroy_configuration ( custom_filepath , click_runner ) : [EOL] [EOL] preexisting_live_configuration = os . path . isdir ( DEFAULT_CONFIG_ROOT ) [EOL] preexisting_live_configuration_file = os . path . isfile ( os . path . join ( DEFAULT_CONFIG_ROOT , UrsulaConfiguration . CONFIG_FILENAME ) ) [EOL] [EOL] [comment] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] [comment] [EOL] destruction_args = ( [string] , [string] , [string] , custom_config_filepath ) [EOL] result = click_runner . invoke ( nucypher_cli , destruction_args , input = [string] . format ( INSECURE_DEVELOPMENT_PASSWORD ) , catch_exceptions = False ) [EOL] [EOL] [comment] [EOL] assert not os . path . isfile ( custom_config_filepath ) , [string] [EOL] assert [string] in result . output , [string] [EOL] assert [string] in result . output , [string] [EOL] assert custom_filepath in result . output , [string] [EOL] assert f' [string] ' in result . output , [string] [EOL] assert result . exit_code == [number] , [string] [EOL] [EOL] [comment] [EOL] assert not os . path . isfile ( custom_config_filepath ) , [string] [comment] [EOL] assert not os . path . isdir ( custom_filepath ) , [string] [comment] [EOL] [EOL] [comment] [EOL] if preexisting_live_configuration : [EOL] configuration_still_exists = os . path . isdir ( DEFAULT_CONFIG_ROOT ) [EOL] assert configuration_still_exists [EOL] [EOL] if preexisting_live_configuration_file : [EOL] file_still_exists = os . path . isfile ( os . path . join ( DEFAULT_CONFIG_ROOT , UrsulaConfiguration . CONFIG_FILENAME ) ) [EOL] assert file_still_exists , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import nucypher [EOL] import typing [EOL] import sys [EOL] from contextlib import contextmanager [EOL] [EOL] import pytest [EOL] from io import StringIO [EOL] [EOL] from nucypher . cli . config import NucypherClickConfig [EOL] from nucypher . cli . processes import UrsulaCommandProtocol [EOL] [EOL] [comment] [EOL] [EOL] NucypherClickConfig . log_to_sentry = False [EOL] NucypherClickConfig . log_to_file = False [EOL] [EOL] [EOL] @ contextmanager def capture_output ( ) : [EOL] new_out , new_err = StringIO ( ) , StringIO ( ) [EOL] old_out , old_err = sys . stdout , sys . stderr [EOL] try : [EOL] sys . stdout , sys . stderr = new_out , new_err [EOL] yield sys . stdout , sys . stderr [EOL] finally : [EOL] sys . stdout , sys . stderr = old_out , old_err [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def ursula ( federated_ursulas ) : [EOL] ursula = federated_ursulas . pop ( ) [EOL] return ursula [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def protocol ( ursula ) : [EOL] protocol = UrsulaCommandProtocol ( ursula = ursula ) [EOL] return protocol [EOL] [EOL] [EOL] def test_ursula_command_protocol_creation ( ursula ) : [EOL] [EOL] protocol = UrsulaCommandProtocol ( ursula = ursula ) [EOL] [EOL] assert protocol . ursula == ursula [EOL] assert [string] in protocol . prompt [EOL] [EOL] [EOL] def test_ursula_command_help ( protocol , ursula ) : [EOL] [EOL] class FakeTransport : [EOL] [docstring] [EOL] [EOL] mock_output = [string] [EOL] [EOL] @ staticmethod def write ( data ) : [EOL] FakeTransport . mock_output += data [EOL] [EOL] protocol . transport = FakeTransport [EOL] [EOL] with capture_output ( ) as ( out , err ) : [EOL] protocol . lineReceived ( line = [string] ) [EOL] [EOL] [comment] [EOL] result = out . getvalue ( ) [EOL] for command in protocol . commands : [EOL] assert command in result , [string] . format ( command ) [EOL] [EOL] [comment] [EOL] with capture_output ( ) as ( out , err ) : [EOL] protocol . lineReceived ( line = [string] ) [EOL] assert protocol . prompt in FakeTransport . mock_output [EOL] [EOL] [EOL] def test_ursula_command_status ( protocol , ursula ) : [EOL] [EOL] with capture_output ( ) as ( out , err ) : [EOL] protocol . paintStatus ( ) [EOL] result = out . getvalue ( ) [EOL] assert ursula . checksum_public_address in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] [EOL] [EOL] def test_ursula_command_known_nodes ( protocol , ursula ) : [EOL] [EOL] with capture_output ( ) as ( out , err ) : [EOL] protocol . paintKnownNodes ( ) [EOL] result = out . getvalue ( ) [EOL] assert [string] in result [EOL] assert ursula . checksum_public_address not in result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Literal , Tuple , List [EOL] import nucypher [EOL] import typing_extensions [EOL] import typing [EOL] import decimal [EOL] import json [EOL] import os [EOL] import random [EOL] import secrets [EOL] import string [EOL] [EOL] import datetime [EOL] import maya [EOL] import pytest [EOL] from umbral . keys import UmbralPublicKey [EOL] [EOL] from nucypher . blockchain . eth . actors import Miner [EOL] from nucypher . blockchain . eth . agents import NucypherTokenAgent , MinerAgent [EOL] from nucypher . blockchain . eth . constants import MIN_LOCKED_PERIODS , MIN_ALLOWED_LOCKED [EOL] from nucypher . blockchain . eth . token import NU [EOL] from nucypher . characters . lawful import Enrico [EOL] from nucypher . cli . main import nucypher_cli [EOL] from nucypher . config . characters import UrsulaConfiguration , BobConfiguration [EOL] from nucypher . utilities . sandbox import constants [EOL] from nucypher . utilities . sandbox . blockchain import token_airdrop [EOL] from nucypher . utilities . sandbox . constants import ( MOCK_IP_ADDRESS , TEST_PROVIDER_URI , MOCK_URSULA_STARTING_PORT , INSECURE_DEVELOPMENT_PASSWORD , MOCK_REGISTRY_FILEPATH , TEMPORARY_DOMAIN , TESTING_ETH_AIRDROP_AMOUNT ) [EOL] from nucypher . utilities . sandbox . middleware import MockRestMiddleware [EOL] from nucypher . utilities . sandbox . ursula import start_pytest_ursula_services [EOL] [EOL] from web3 import Web3 [EOL] [EOL] [EOL] STAKE_VALUE = NU ( MIN_ALLOWED_LOCKED * [number] , [string] ) [EOL] POLICY_RATE = Web3 . toWei ( [number] , [string] ) [EOL] POLICY_VALUE = POLICY_RATE * MIN_LOCKED_PERIODS [comment] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True , scope = [string] ) def funded_blockchain ( deployed_blockchain ) : [EOL] [EOL] [comment] [EOL] blockchain , _deployer_address , registry = deployed_blockchain [EOL] deployer_address , * everyone_else , staking_participant = blockchain . interface . w3 . eth . accounts [EOL] [EOL] [comment] [EOL] blockchain . ether_airdrop ( amount = TESTING_ETH_AIRDROP_AMOUNT ) [EOL] [EOL] [comment] [EOL] token_airdrop ( token_agent = NucypherTokenAgent ( blockchain = blockchain ) , origin = _deployer_address , addresses = everyone_else , amount = MIN_ALLOWED_LOCKED * [number] ) [EOL] [EOL] [comment] [EOL] yield blockchain , _deployer_address [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def staking_participant ( funded_blockchain , blockchain_ursulas ) : [EOL] [comment] [EOL] for teacher in blockchain_ursulas : [EOL] start_pytest_ursula_services ( ursula = teacher ) [EOL] [EOL] teachers = list ( blockchain_ursulas ) [EOL] staking_participant = teachers [ - [number] ] [EOL] return staking_participant [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def configuration_file_location ( custom_filepath ) : [EOL] _configuration_file_location = os . path . join ( constants . MOCK_CUSTOM_INSTALLATION_PATH , [string] ) [EOL] return _configuration_file_location [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def charlie_blockchain_test_config ( blockchain_ursulas , three_agents ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] etherbase , alice_address , bob_address , * everyone_else = token_agent . blockchain . interface . w3 . eth . accounts [EOL] [EOL] config = BobConfiguration ( dev_mode = True , provider_uri = [string] , checksum_public_address = bob_address , network_middleware = MockRestMiddleware ( ) , known_nodes = blockchain_ursulas , start_learning_now = False , abort_on_learning_error = True , federated_only = False , import_seed_registry = False , save_metadata = False , reload_metadata = False ) [EOL] yield config [EOL] config . cleanup ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def mock_registry_filepath ( deployed_blockchain ) : [EOL] [EOL] _blockchain , _deployer_address , _registry = deployed_blockchain [EOL] [EOL] [comment] [EOL] with open ( MOCK_REGISTRY_FILEPATH , [string] ) as file : [EOL] file . write ( json . dumps ( _registry . read ( ) ) ) [EOL] [EOL] yield MOCK_REGISTRY_FILEPATH [EOL] [EOL] if os . path . isfile ( MOCK_REGISTRY_FILEPATH ) : [EOL] os . remove ( MOCK_REGISTRY_FILEPATH ) [EOL] [EOL] [EOL] def test_initialize_system_blockchain_configuration ( click_runner , custom_filepath , mock_registry_filepath , staking_participant ) : [EOL] [EOL] init_args = ( [string] , [string] , [string] , [string] , str ( TEMPORARY_DOMAIN , encoding = [string] ) , [string] , staking_participant . checksum_public_address , [string] , custom_filepath , [string] , TEST_PROVIDER_URI , [string] , mock_registry_filepath , [string] , MOCK_IP_ADDRESS , [string] , MOCK_URSULA_STARTING_PORT ) [EOL] [EOL] user_input = [string] . format ( password = INSECURE_DEVELOPMENT_PASSWORD ) [EOL] result = click_runner . invoke ( nucypher_cli , init_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [comment] [EOL] assert os . path . isdir ( custom_filepath ) , [string] [EOL] assert os . path . isdir ( os . path . join ( custom_filepath , [string] ) ) , [string] [EOL] assert os . path . isdir ( os . path . join ( custom_filepath , [string] ) ) , [string] [EOL] [EOL] custom_config_filepath = os . path . join ( custom_filepath , UrsulaConfiguration . CONFIG_FILENAME ) [EOL] assert os . path . isfile ( custom_config_filepath ) , [string] [EOL] [EOL] with open ( custom_config_filepath , [string] ) as config_file : [EOL] raw_config_data = config_file . read ( ) [EOL] config_data = json . loads ( raw_config_data ) [EOL] assert config_data [ [string] ] == TEST_PROVIDER_URI [EOL] assert config_data [ [string] ] == staking_participant . checksum_public_address [EOL] assert str ( TEMPORARY_DOMAIN , encoding = [string] ) in config_data [ [string] ] [EOL] [EOL] [EOL] def test_init_ursula_stake ( click_runner , configuration_file_location , funded_blockchain ) : [EOL] stake_args = ( [string] , [string] , [string] , configuration_file_location , [string] , STAKE_VALUE . to_tokens ( ) , [string] , MIN_LOCKED_PERIODS , [string] , [string] ) [EOL] [EOL] result = click_runner . invoke ( nucypher_cli , stake_args , input = INSECURE_DEVELOPMENT_PASSWORD , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] with open ( configuration_file_location , [string] ) as config_file : [EOL] config_data = json . loads ( config_file . read ( ) ) [EOL] [EOL] [comment] [EOL] miner_agent = MinerAgent ( ) [EOL] stakes = list ( miner_agent . get_all_stakes ( miner_address = config_data [ [string] ] ) ) [EOL] assert len ( stakes ) == [number] [EOL] start_period , end_period , value = stakes [ [number] ] [EOL] assert NU ( int ( value ) , [string] ) == STAKE_VALUE [EOL] [EOL] [EOL] def test_list_ursula_stakes ( click_runner , funded_blockchain , configuration_file_location ) : [EOL] _blockchain , _deployer_address = funded_blockchain [EOL] [EOL] stake_args = ( [string] , [string] , [string] , configuration_file_location , [string] , [string] ) [EOL] [EOL] user_input = f'{ INSECURE_DEVELOPMENT_PASSWORD }' [EOL] result = click_runner . invoke ( nucypher_cli , stake_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] assert str ( STAKE_VALUE ) in result . output [EOL] [EOL] [EOL] def test_ursula_divide_stakes ( click_runner , configuration_file_location ) : [EOL] [EOL] divide_args = ( [string] , [string] , [string] , [string] , configuration_file_location , [string] , [string] , [string] , [number] , [string] , NU ( MIN_ALLOWED_LOCKED , [string] ) . to_tokens ( ) , [string] , [number] ) [EOL] [EOL] result = click_runner . invoke ( nucypher_cli , divide_args , catch_exceptions = False , env = dict ( NUCYPHER_KEYRING_PASSWORD = INSECURE_DEVELOPMENT_PASSWORD ) ) [EOL] assert result . exit_code == [number] [EOL] [EOL] stake_args = ( [string] , [string] , [string] , configuration_file_location , [string] , [string] ) [EOL] [EOL] user_input = f'{ INSECURE_DEVELOPMENT_PASSWORD }' [EOL] result = click_runner . invoke ( nucypher_cli , stake_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] assert str ( NU ( MIN_ALLOWED_LOCKED , [string] ) . to_tokens ( ) ) in result . output [EOL] [EOL] [EOL] def test_run_blockchain_ursula ( click_runner , configuration_file_location , funded_blockchain , alice_blockchain_test_config , bob_blockchain_test_config , charlie_blockchain_test_config , random_policy_label , blockchain_ursulas , staking_participant ) : [EOL] [EOL] [comment] [EOL] init_args = ( [string] , [string] , [string] , [string] , [string] , configuration_file_location ) [EOL] [EOL] user_input = f'{ INSECURE_DEVELOPMENT_PASSWORD }' [EOL] result = click_runner . invoke ( nucypher_cli , init_args , input = user_input , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] [EOL] def test_collect_rewards_integration ( click_runner , funded_blockchain , configuration_file_location , alice_blockchain_test_config , bob_blockchain_test_config , charlie_blockchain_test_config , random_policy_label , blockchain_ursulas , staking_participant ) : [EOL] [EOL] blockchain = staking_participant . blockchain [EOL] [EOL] [comment] [EOL] alice = alice_blockchain_test_config . produce ( blockchain = funded_blockchain , network_middleware = MockRestMiddleware ( ) , known_nodes = blockchain_ursulas ) [EOL] [EOL] bob = bob_blockchain_test_config . produce ( blockchain = blockchain , network_middleware = MockRestMiddleware ( ) , known_nodes = blockchain_ursulas ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] half_stake_time = MIN_LOCKED_PERIODS // [number] [comment] [EOL] logger = staking_participant . log [comment] [EOL] current_period = [number] [comment] [EOL] [EOL] miner = Miner ( checksum_address = staking_participant . checksum_public_address , blockchain = blockchain , is_me = True ) [EOL] [EOL] pre_stake_eth_balance = miner . eth_balance [EOL] [EOL] [comment] [EOL] for _ in range ( half_stake_time ) : [EOL] current_period += [number] [EOL] logger . debug ( f" [string] { current_period }" ) [EOL] blockchain . time_travel ( periods = [number] ) [EOL] miner . confirm_activity ( ) [EOL] [EOL] M , N = [number] , [number] [EOL] expiration = maya . now ( ) + datetime . timedelta ( days = [number] ) [EOL] blockchain_policy = alice . grant ( bob = bob , label = random_policy_label , m = M , n = [number] , value = POLICY_VALUE , expiration = expiration , handpicked_ursulas = { staking_participant } ) [EOL] [EOL] [comment] [EOL] bob . join_policy ( random_policy_label , bytes ( alice . stamp ) ) [EOL] [EOL] [comment] [EOL] enrico = Enrico ( policy_encrypting_key = blockchain_policy . public_key , network_middleware = MockRestMiddleware ( ) ) [EOL] [EOL] for index , _period in enumerate ( range ( half_stake_time - [number] ) ) : [EOL] logger . debug ( f" [string] { current_period }" ) [EOL] [EOL] alphabet = string . ascii_letters + string . digits [EOL] [EOL] [comment] [EOL] if not random . choice ( ( True , False ) ) : [EOL] continue [comment] [EOL] [EOL] max_reencryptions_per_period = [number] [EOL] quantity = random . choice ( range ( max_reencryptions_per_period + [number] ) ) [EOL] quantity *= index [comment] [EOL] verifying_key = UmbralPublicKey . from_bytes ( bytes ( alice . stamp ) ) [EOL] [EOL] [comment] [EOL] for _i in range ( quantity ) : [EOL] [EOL] [comment] [EOL] random_data = [string] . join ( secrets . choice ( alphabet ) for i in range ( secrets . choice ( range ( [number] , [number] ) ) ) ) [EOL] ciphertext , signature = enrico . encrypt_message ( message = bytes ( random_data , encoding = [string] ) ) [EOL] [EOL] [comment] [EOL] payload = dict ( message_kit = ciphertext , data_source = enrico , alice_verifying_key = verifying_key , label = random_policy_label ) [EOL] [EOL] _cleartext = bob . retrieve ( ** payload ) [EOL] [EOL] [comment] [EOL] blockchain . time_travel ( periods = [number] ) [EOL] miner . confirm_activity ( ) [EOL] current_period += [number] [EOL] [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] current_period += [number] [EOL] logger . debug ( f" [string] { current_period }" ) [EOL] blockchain . time_travel ( periods = [number] ) [EOL] miner . confirm_activity ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] burner_wallet = blockchain . interface . w3 . eth . account . create ( INSECURE_DEVELOPMENT_PASSWORD ) [EOL] assert blockchain . interface . w3 . eth . getBalance ( burner_wallet . address ) == [number] [EOL] [EOL] [comment] [EOL] random_teacher = list ( blockchain_ursulas ) . pop ( ) [EOL] [EOL] collection_args = ( [string] , [string] , [string] , [string] , random_teacher . rest_interface , [string] , configuration_file_location , [string] , burner_wallet . address , [string] , [string] ) [EOL] [EOL] result = click_runner . invoke ( nucypher_cli , collection_args , input = INSECURE_DEVELOPMENT_PASSWORD , catch_exceptions = False ) [EOL] assert result . exit_code == [number] [EOL] [EOL] collected_reward = blockchain . interface . w3 . eth . getBalance ( burner_wallet . address ) [EOL] assert collected_reward != [number] [EOL] [EOL] expected_reward = Web3 . toWei ( [number] , [string] ) * [number] * M [EOL] assert collected_reward == expected_reward [EOL] assert miner . eth_balance == pre_stake_eth_balance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.token.NU$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.token.NU$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.token.NU$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $nucypher.blockchain.eth.token.NU$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import functools [EOL] from functools import partial [EOL] [EOL] from nucypher . utilities . sandbox . ursula import make_federated_ursulas [EOL] [EOL] [EOL] def test_learner_learns_about_domains_separately ( ursula_federated_test_config , caplog ) : [EOL] lonely_ursula_maker = partial ( make_federated_ursulas , ursula_config = ursula_federated_test_config , quantity = [number] , know_each_other = True ) [EOL] global_learners = lonely_ursula_maker ( ) [EOL] first_domain_learners = lonely_ursula_maker ( domains = set ( [ [string] ] ) ) [EOL] second_domain_learners = lonely_ursula_maker ( domains = set ( [ [string] ] ) ) [EOL] [EOL] big_learner = global_learners . pop ( ) [EOL] [EOL] assert len ( big_learner . known_nodes ) == [number] [EOL] [EOL] [comment] [EOL] big_learner . _current_teacher_node = first_domain_learners . pop ( ) [EOL] big_learner . learn_from_teacher_node ( ) [EOL] [EOL] [comment] [EOL] big_learner . _current_teacher_node = second_domain_learners . pop ( ) [EOL] big_learner . learn_from_teacher_node ( ) [EOL] [EOL] assert len ( big_learner . known_nodes ) == [number] [EOL] [EOL] new_first_domain_learner = lonely_ursula_maker ( domains = set ( [ [string] ] ) ) . pop ( ) [EOL] new_second_domain_learner = lonely_ursula_maker ( domains = set ( [ [string] ] ) ) [EOL] [EOL] new_first_domain_learner . _current_teacher_node = big_learner [EOL] new_first_domain_learner . learn_from_teacher_node ( ) [EOL] [EOL] [comment] [EOL] assert not set ( second_domain_learners ) . intersection ( set ( new_first_domain_learner . known_nodes ) ) [EOL] [EOL] [comment] [EOL] assert set ( first_domain_learners ) . intersection ( set ( new_first_domain_learner . known_nodes ) ) == first_domain_learners [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import pytest [EOL] from eth_keys . datatypes import Signature as EthSignature [EOL] [EOL] from nucypher . characters . lawful import Ursula [EOL] from nucypher . characters . unlawful import Vladimir [EOL] from nucypher . crypto . powers import SigningPower , CryptoPower [EOL] from nucypher . utilities . sandbox . constants import INSECURE_DEVELOPMENT_PASSWORD [EOL] from nucypher . utilities . sandbox . middleware import MockRestMiddleware [EOL] from nucypher . utilities . sandbox . ursula import make_federated_ursulas [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_federated_ursula_substantiates_stamp ( ) : [EOL] assert False [EOL] [EOL] [EOL] def test_new_federated_ursula_announces_herself ( ursula_federated_test_config ) : [EOL] ursula_in_a_house , ursula_with_a_mouse = make_federated_ursulas ( ursula_config = ursula_federated_test_config , quantity = [number] , know_each_other = False , network_middleware = MockRestMiddleware ( ) ) [EOL] [EOL] [comment] [EOL] assert ursula_in_a_house . known_nodes == ursula_with_a_mouse . known_nodes [EOL] [EOL] ursula_in_a_house . remember_node ( ursula_with_a_mouse ) [EOL] [EOL] [comment] [EOL] assert ursula_with_a_mouse in ursula_in_a_house . known_nodes [EOL] assert ursula_in_a_house not in ursula_with_a_mouse . known_nodes [EOL] [EOL] [comment] [EOL] ursula_in_a_house . learn_from_teacher_node ( ) [EOL] [EOL] assert ursula_with_a_mouse in ursula_in_a_house . known_nodes [EOL] assert ursula_in_a_house in ursula_with_a_mouse . known_nodes [EOL] [EOL] [EOL] def test_blockchain_ursula_substantiates_stamp ( blockchain_ursulas ) : [EOL] first_ursula = list ( blockchain_ursulas ) [ [number] ] [EOL] signature_as_bytes = first_ursula . _evidence_of_decentralized_identity [EOL] signature = EthSignature ( signature_bytes = signature_as_bytes ) [EOL] proper_public_key_for_first_ursula = signature . recover_public_key_from_msg ( bytes ( first_ursula . stamp ) ) [EOL] proper_address_for_first_ursula = proper_public_key_for_first_ursula . to_checksum_address ( ) [EOL] assert proper_address_for_first_ursula == first_ursula . checksum_public_address [EOL] [EOL] [comment] [EOL] assert first_ursula . _stamp_has_valid_wallet_signature [EOL] [EOL] [EOL] def test_blockchain_ursula_verifies_stamp ( blockchain_ursulas ) : [EOL] first_ursula = list ( blockchain_ursulas ) [ [number] ] [EOL] [EOL] [comment] [EOL] first_ursula . verified_stamp = False [EOL] first_ursula . stamp_is_valid ( ) [EOL] [EOL] [comment] [EOL] assert first_ursula . verified_stamp [EOL] [EOL] [EOL] def test_vladimir_cannot_verify_interface_with_ursulas_signing_key ( blockchain_ursulas ) : [EOL] his_target = list ( blockchain_ursulas ) [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] assert his_target . interface_is_valid ( ) [EOL] [EOL] [comment] [EOL] vladimir = Vladimir . from_target_ursula ( his_target , claim_signing_key = True ) [EOL] [EOL] [comment] [EOL] vladimir . substantiate_stamp ( password = INSECURE_DEVELOPMENT_PASSWORD ) [EOL] vladimir . stamp_is_valid ( ) [EOL] [EOL] [comment] [EOL] assert vladimir . stamp == his_target . stamp [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( vladimir . InvalidNode ) : [EOL] vladimir . interface_is_valid ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( vladimir . InvalidNode ) : [EOL] vladimir . validate_metadata ( ) [EOL] [EOL] [EOL] def test_vladimir_uses_his_own_signing_key ( blockchain_alice , blockchain_ursulas ) : [EOL] [docstring] [EOL] his_target = list ( blockchain_ursulas ) [ [number] ] [EOL] [EOL] fraudulent_keys = CryptoPower ( power_ups = Ursula . _default_crypto_powerups ) [comment] [EOL] [EOL] vladimir = Vladimir . from_target_ursula ( target_ursula = his_target ) [EOL] [EOL] message = vladimir . _signable_interface_info_message ( ) [EOL] signature = vladimir . _crypto_power . power_ups ( SigningPower ) . sign ( vladimir . timestamp_bytes ( ) + message ) [EOL] vladimir . _interface_signature_object = signature [EOL] [EOL] vladimir . substantiate_stamp ( password = INSECURE_DEVELOPMENT_PASSWORD ) [EOL] [EOL] [comment] [EOL] vladimir . validate_metadata ( ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( vladimir . InvalidNode ) : [EOL] vladimir . verify_node ( blockchain_alice . network_middleware , certificate_filepath = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from nucypher . characters . lawful import Ursula [EOL] [EOL] [EOL] def test_serialize_ursula ( federated_ursulas ) : [EOL] ursula = federated_ursulas . pop ( ) [EOL] ursula_as_bytes = bytes ( ursula ) [EOL] ursula_object = Ursula . from_bytes ( ursula_as_bytes , federated_only = True ) [EOL] assert ursula == ursula_object [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import os [EOL] import time [EOL] [EOL] import datetime [EOL] import maya [EOL] import pytest [EOL] [EOL] from constant_sorrow . constants import NO_DECRYPTION_PERFORMED [EOL] from nucypher . characters . lawful import Bob , Ursula [EOL] from nucypher . characters . lawful import Enrico [EOL] from nucypher . policy . models import TreasureMap [EOL] from nucypher . utilities . sandbox . constants import NUMBER_OF_URSULAS_IN_DEVELOPMENT_NETWORK , MOCK_POLICY_DEFAULT_M [EOL] from nucypher . utilities . sandbox . middleware import MockRestMiddleware [EOL] [EOL] [EOL] def test_federated_bob_full_retrieve_flow ( federated_ursulas , federated_bob , federated_alice , capsule_side_channel , enacted_federated_policy ) : [EOL] [comment] [EOL] treasure_map = enacted_federated_policy . treasure_map [EOL] federated_bob . treasure_maps [ treasure_map . public_id ( ) ] = treasure_map [EOL] [EOL] for ursula in federated_ursulas : [EOL] federated_bob . remember_node ( ursula ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] the_message_kit , the_data_source = capsule_side_channel [EOL] [EOL] alices_verifying_key = federated_alice . stamp . as_umbral_pubkey ( ) [EOL] [EOL] delivered_cleartexts = federated_bob . retrieve ( message_kit = the_message_kit , data_source = the_data_source , alice_verifying_key = alices_verifying_key , label = enacted_federated_policy . label ) [EOL] [EOL] [comment] [EOL] assert [string] == delivered_cleartexts [ [number] ] [EOL] [EOL] [EOL] def test_bob_joins_policy_and_retrieves ( federated_alice , federated_ursulas , certificates_tempdir , ) : [EOL] [comment] [EOL] a_couple_of_ursulas = list ( federated_ursulas ) [ : [number] ] [EOL] rest_of_ursulas = list ( federated_ursulas ) [ [number] : ] [EOL] [EOL] [comment] [EOL] bob = Bob ( federated_only = True , start_learning_now = True , network_middleware = MockRestMiddleware ( ) , abort_on_learning_error = True , known_nodes = a_couple_of_ursulas , ) [EOL] [EOL] [comment] [EOL] assert len ( bob . known_nodes ) == [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] n = NUMBER_OF_URSULAS_IN_DEVELOPMENT_NETWORK - [number] [EOL] label = [string] + os . urandom ( [number] ) [EOL] contract_end_datetime = maya . now ( ) + datetime . timedelta ( days = [number] ) [EOL] policy = federated_alice . grant ( bob = bob , label = label , m = [number] , n = n , expiration = contract_end_datetime , handpicked_ursulas = set ( rest_of_ursulas ) , ) [EOL] [EOL] assert bob == policy . bob [EOL] assert label == policy . label [EOL] [EOL] [comment] [EOL] bob . join_policy ( label = label , alice_pubkey_sig = federated_alice . stamp , block = True ) [EOL] [EOL] [comment] [EOL] assert len ( bob . known_nodes ) == len ( federated_ursulas ) [EOL] [EOL] [comment] [EOL] enrico = Enrico ( policy_encrypting_key = policy . public_key ) [EOL] [EOL] plaintext = [string] [EOL] message_kit , _signature = enrico . encrypt_message ( plaintext ) [EOL] [EOL] alices_verifying_key = federated_alice . stamp . as_umbral_pubkey ( ) [EOL] [EOL] [comment] [EOL] delivered_cleartexts = bob . retrieve ( message_kit = message_kit , data_source = enrico , alice_verifying_key = alices_verifying_key , label = policy . label ) [EOL] [EOL] assert plaintext == delivered_cleartexts [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] failed_revocations = federated_alice . revoke ( policy ) [EOL] assert len ( failed_revocations ) == [number] [EOL] [EOL] with pytest . raises ( Ursula . NotEnoughUrsulas ) : [EOL] _cleartexts = bob . retrieve ( message_kit = message_kit , data_source = enrico , alice_verifying_key = alices_verifying_key , label = policy . label ) [EOL] [EOL] [EOL] def test_treasure_map_serialization ( enacted_federated_policy , federated_bob ) : [EOL] treasure_map = enacted_federated_policy . treasure_map [EOL] assert treasure_map . m is not None [EOL] assert treasure_map . m != NO_DECRYPTION_PERFORMED [EOL] assert treasure_map . m == MOCK_POLICY_DEFAULT_M , [string] [EOL] [EOL] serialized_map = bytes ( treasure_map ) [EOL] deserialized_map = TreasureMap . from_bytes ( serialized_map ) [EOL] assert deserialized_map . _hrac == treasure_map . _hrac [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) : [EOL] deserialized_map . m [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] deserialized_map . destinations [EOL] [EOL] compass = federated_bob . make_compass_for_alice ( enacted_federated_policy . alice ) [EOL] deserialized_map . orient ( compass ) [EOL] assert deserialized_map . m == treasure_map . m [EOL] assert deserialized_map . destinations == treasure_map . destinations [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import pytest [EOL] [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from nucypher . blockchain . eth . constants import NULL_ADDRESS [EOL] from nucypher . utilities . sandbox . constants import MOCK_IP_ADDRESS , MOCK_IP_ADDRESS_2 , MAX_TEST_SEEDER_ENTRIES , MOCK_URSULA_STARTING_PORT [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) def test_seeder ( testerchain ) : [EOL] origin , seed_address , another_seed_address , * everyone_else = testerchain . interface . w3 . eth . accounts [EOL] seed = ( MOCK_IP_ADDRESS , MOCK_URSULA_STARTING_PORT ) [EOL] another_seed = ( MOCK_IP_ADDRESS_2 , MOCK_URSULA_STARTING_PORT + [number] ) [EOL] [EOL] contract , _txhash = testerchain . interface . deploy_contract ( [string] , MAX_TEST_SEEDER_ENTRIES ) [EOL] [EOL] assert contract . functions . getSeedArrayLength ( ) . call ( ) == MAX_TEST_SEEDER_ENTRIES [EOL] assert contract . functions . owner ( ) . call ( ) == origin [EOL] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] txhash = contract . functions . enroll ( seed_address , * seed ) . transact ( { [string] : seed_address } ) [EOL] testerchain . wait_for_receipt ( txhash ) [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] txhash = contract . functions . refresh ( * seed ) . transact ( { [string] : seed_address } ) [EOL] testerchain . wait_for_receipt ( txhash ) [EOL] [EOL] txhash = contract . functions . enroll ( seed_address , * seed ) . transact ( { [string] : origin } ) [EOL] testerchain . wait_for_receipt ( txhash ) [EOL] assert contract . functions . seeds ( seed_address ) . call ( ) == [ * seed ] [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == seed_address [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == NULL_ADDRESS [EOL] txhash = contract . functions . enroll ( another_seed_address , * another_seed ) . transact ( { [string] : origin } ) [EOL] testerchain . wait_for_receipt ( txhash ) [EOL] assert contract . functions . seeds ( another_seed_address ) . call ( ) == [ * another_seed ] [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == seed_address [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == another_seed_address [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == NULL_ADDRESS [EOL] [EOL] txhash = contract . functions . refresh ( * another_seed ) . transact ( { [string] : seed_address } ) [EOL] testerchain . wait_for_receipt ( txhash ) [EOL] assert contract . functions . seedArray ( [number] ) . call ( ) == seed_address [EOL] assert contract . functions . seeds ( seed_address ) . call ( ) == [ * another_seed ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import cryptography [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import os [EOL] [EOL] import coincurve [EOL] import pytest [EOL] from cryptography . hazmat . backends . openssl import backend [EOL] from cryptography . hazmat . primitives import hashes [EOL] from cryptography . hazmat . primitives . asymmetric import ec [EOL] from eth_tester . exceptions import TransactionFailed [EOL] from eth_utils import to_canonical_address , to_checksum_address [EOL] from web3 . contract import Contract [EOL] [EOL] from umbral import pre [EOL] from umbral . config import default_params [EOL] from umbral . curvebn import CurveBN [EOL] from umbral . keys import UmbralPrivateKey [EOL] from umbral . random_oracles import hash_to_curvebn , ExtendedKeccak [EOL] from umbral . signing import Signature , Signer [EOL] [EOL] from nucypher . policy . models import IndisputableEvidence [EOL] [EOL] [EOL] ALGORITHM_KECCAK256 = [number] [EOL] ALGORITHM_SHA256 = [number] [EOL] BASE_PENALTY = [number] [EOL] PENALTY_HISTORY_COEFFICIENT = [number] [EOL] PERCENTAGE_PENALTY_COEFFICIENT = [number] [EOL] REWARD_COEFFICIENT = [number] [EOL] secret = [number] . to_bytes ( [number] , byteorder = [string] ) [EOL] secret2 = [number] . to_bytes ( [number] , byteorder = [string] ) [EOL] [EOL] [EOL] def sign_data ( data , umbral_privkey ) : [EOL] umbral_pubkey_bytes = umbral_privkey . get_pubkey ( ) . to_bytes ( is_compressed = False ) [EOL] [EOL] [comment] [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( data ) [EOL] data_hash = hash_ctx . finalize ( ) [EOL] [EOL] [comment] [EOL] cryptography_priv_key = umbral_privkey . to_cryptography_privkey ( ) [EOL] signature_der_bytes = cryptography_priv_key . sign ( data , ec . ECDSA ( hashes . SHA256 ( ) ) ) [EOL] signature = Signature . from_bytes ( signature_der_bytes , der_encoded = True ) [EOL] recoverable_signature = make_recoverable_signature ( data_hash , signature , umbral_pubkey_bytes ) [EOL] return recoverable_signature [EOL] [EOL] [EOL] def make_recoverable_signature ( data_hash , signature , umbral_pubkey_bytes ) : [EOL] recoverable_signature = bytes ( signature ) + bytes ( [ [number] ] ) [EOL] pubkey_bytes = coincurve . PublicKey . from_signature_and_message ( recoverable_signature , data_hash , hasher = None ) . format ( compressed = False ) [EOL] if pubkey_bytes != umbral_pubkey_bytes : [EOL] recoverable_signature = bytes ( signature ) + bytes ( [ [number] ] ) [EOL] return recoverable_signature [EOL] [EOL] [EOL] [comment] [EOL] def fragments ( metadata ) : [EOL] delegating_privkey = UmbralPrivateKey . gen_key ( ) [EOL] _symmetric_key , capsule = pre . _encapsulate ( delegating_privkey . get_pubkey ( ) ) [EOL] signing_privkey = UmbralPrivateKey . gen_key ( ) [EOL] signer = Signer ( signing_privkey ) [EOL] priv_key_bob = UmbralPrivateKey . gen_key ( ) [EOL] pub_key_bob = priv_key_bob . get_pubkey ( ) [EOL] kfrags = pre . generate_kfrags ( delegating_privkey = delegating_privkey , signer = signer , receiving_pubkey = pub_key_bob , threshold = [number] , N = [number] , sign_delegating_key = False , sign_receiving_key = False ) [EOL] capsule . set_correctness_keys ( delegating_privkey . get_pubkey ( ) , pub_key_bob , signing_privkey . get_pubkey ( ) ) [EOL] cfrag = pre . reencrypt ( kfrags [ [number] ] , capsule , metadata = metadata ) [EOL] return capsule , cfrag [EOL] [EOL] [EOL] @ pytest . mark . slow def test_evaluate_cfrag ( testerchain , escrow , adjudicator_contract ) : [EOL] creator , miner , wrong_miner , investigator , * everyone_else = testerchain . interface . w3 . eth . accounts [EOL] evaluation_log = adjudicator_contract . events . CFragEvaluated . createFilter ( fromBlock = [string] ) [EOL] [EOL] [comment] [EOL] umbral_params = default_params ( ) [EOL] u_xcoord , u_ycoord = umbral_params . u . to_affine ( ) [EOL] u_sign = [number] + ( u_ycoord % [number] ) [EOL] assert u_sign == adjudicator_contract . functions . UMBRAL_PARAMETER_U_SIGN ( ) . call ( ) [EOL] assert u_xcoord == adjudicator_contract . functions . UMBRAL_PARAMETER_U_XCOORD ( ) . call ( ) [EOL] assert u_ycoord == adjudicator_contract . functions . UMBRAL_PARAMETER_U_YCOORD ( ) . call ( ) [EOL] [EOL] [comment] [EOL] test_data = os . urandom ( [number] ) [EOL] h = hash_to_curvebn ( test_data , params = umbral_params , hash_class = ExtendedKeccak ) [EOL] assert int ( h ) == adjudicator_contract . functions . extendedKeccakToBN ( test_data ) . call ( ) [EOL] [EOL] [comment] [EOL] tx = escrow . functions . setMinerInfo ( miner , [number] ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] miner_umbral_private_key = UmbralPrivateKey . gen_key ( ) [EOL] miner_umbral_public_key_bytes = miner_umbral_private_key . get_pubkey ( ) . to_bytes ( is_compressed = False ) [EOL] [EOL] [comment] [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( miner_umbral_public_key_bytes ) [EOL] miner_umbral_public_key_hash = hash_ctx . finalize ( ) [EOL] provider = testerchain . interface . provider [EOL] address = to_canonical_address ( miner ) [EOL] sig_key = provider . ethereum_tester . backend . _key_lookup [ address ] [EOL] signed_miner_umbral_public_key = bytes ( sig_key . sign_msg_hash ( miner_umbral_public_key_hash ) ) [EOL] [EOL] [comment] [EOL] metadata = os . urandom ( [number] ) [EOL] capsule , cfrag = fragments ( metadata ) [EOL] [EOL] assert cfrag . verify_correctness ( capsule ) [EOL] [EOL] capsule_bytes = capsule . to_bytes ( ) [EOL] cfrag_bytes = cfrag . to_bytes ( ) [EOL] [EOL] [comment] [EOL] evidence = IndisputableEvidence ( capsule , cfrag , ursula = None ) [EOL] [EOL] evidence_data = evidence . precompute_values ( ) [EOL] assert len ( evidence_data ) == [number] * [number] + [number] + [number] + [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] address = adjudicator_contract . functions . aliceAddress ( cfrag_bytes , evidence_data ) . call ( ) [EOL] assert address == to_checksum_address ( evidence_data [ - [number] : - [number] ] . hex ( ) ) [EOL] [EOL] proof_challenge_scalar = int ( evidence . get_proof_challenge_scalar ( ) ) [EOL] computeProofChallengeScalar = adjudicator_contract . functions . computeProofChallengeScalar [EOL] assert proof_challenge_scalar == computeProofChallengeScalar ( capsule_bytes , cfrag_bytes ) . call ( ) [EOL] [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( capsule_bytes + cfrag_bytes ) [EOL] data_hash = hash_ctx . finalize ( ) [EOL] [comment] [EOL] assert not adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] [EOL] [comment] [EOL] requester_umbral_private_key = UmbralPrivateKey . gen_key ( ) [EOL] requester_umbral_public_key_bytes = requester_umbral_private_key . get_pubkey ( ) . to_bytes ( is_compressed = False ) [EOL] [EOL] [comment] [EOL] capsule_signature_by_requester = sign_data ( capsule_bytes , requester_umbral_private_key ) [EOL] capsule_signature_by_requester_and_miner = sign_data ( capsule_signature_by_requester , miner_umbral_private_key ) [EOL] cfrag_signature_by_miner = sign_data ( cfrag_bytes , miner_umbral_private_key ) [EOL] [EOL] [comment] [EOL] args = ( capsule_bytes , capsule_signature_by_requester , capsule_signature_by_requester_and_miner , cfrag_bytes , cfrag_signature_by_miner , requester_umbral_public_key_bytes , miner_umbral_public_key_bytes , signed_miner_umbral_public_key , evidence_data ) [EOL] [EOL] value = escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * args ) . transact ( { [string] : investigator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [comment] [EOL] assert adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] assert value == escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] assert [number] == escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] [EOL] events = evaluation_log . get_all_entries ( ) [EOL] assert [number] == len ( events ) [EOL] event_args = events [ [number] ] [ [string] ] [EOL] assert data_hash == event_args [ [string] ] [EOL] assert miner == event_args [ [string] ] [EOL] assert investigator == event_args [ [string] ] [EOL] assert event_args [ [string] ] [EOL] [EOL] [comment] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] metadata = os . urandom ( [number] ) [EOL] capsule , cfrag = fragments ( metadata ) [EOL] capsule_bytes = capsule . to_bytes ( ) [EOL] [comment] [EOL] cfrag . proof . bn_sig = CurveBN . gen_rand ( capsule . params . curve ) [EOL] cfrag_bytes = cfrag . to_bytes ( ) [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( capsule_bytes + cfrag_bytes ) [EOL] data_hash = hash_ctx . finalize ( ) [EOL] capsule_signature_by_requester = sign_data ( capsule_bytes , requester_umbral_private_key ) [EOL] capsule_signature_by_requester_and_miner = sign_data ( capsule_signature_by_requester , miner_umbral_private_key ) [EOL] cfrag_signature_by_miner = sign_data ( cfrag_bytes , miner_umbral_private_key ) [EOL] evidence = IndisputableEvidence ( capsule , cfrag , ursula = None ) [EOL] evidence_data = evidence . precompute_values ( ) [EOL] args = ( capsule_bytes , capsule_signature_by_requester , capsule_signature_by_requester_and_miner , cfrag_bytes , cfrag_signature_by_miner , requester_umbral_public_key_bytes , miner_umbral_public_key_bytes , signed_miner_umbral_public_key , evidence_data ) [EOL] [EOL] assert not adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * args ) . transact ( { [string] : investigator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [comment] [EOL] assert adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] assert value - BASE_PENALTY == escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] assert BASE_PENALTY / REWARD_COEFFICIENT == escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] [EOL] events = evaluation_log . get_all_entries ( ) [EOL] assert [number] == len ( events ) [EOL] event_args = events [ [number] ] [ [string] ] [EOL] assert data_hash == event_args [ [string] ] [EOL] assert miner == event_args [ [string] ] [EOL] assert investigator == event_args [ [string] ] [EOL] assert not event_args [ [string] ] [EOL] [EOL] [comment] [EOL] metadata = os . urandom ( [number] ) [EOL] capsule , cfrag = fragments ( metadata ) [EOL] capsule_bytes = capsule . to_bytes ( ) [EOL] [comment] [EOL] cfrag . proof . bn_sig = CurveBN . gen_rand ( capsule . params . curve ) [EOL] cfrag_bytes = cfrag . to_bytes ( ) [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( capsule_bytes + cfrag_bytes ) [EOL] data_hash = hash_ctx . finalize ( ) [EOL] capsule_signature_by_requester = sign_data ( capsule_bytes , requester_umbral_private_key ) [EOL] capsule_signature_by_requester_and_miner = sign_data ( capsule_signature_by_requester , miner_umbral_private_key ) [EOL] cfrag_signature_by_miner = sign_data ( cfrag_bytes , miner_umbral_private_key ) [EOL] evidence = IndisputableEvidence ( capsule , cfrag , ursula = None ) [EOL] evidence_data = evidence . precompute_values ( ) [EOL] args = [ capsule_bytes , capsule_signature_by_requester , capsule_signature_by_requester_and_miner , cfrag_bytes , cfrag_signature_by_miner , requester_umbral_public_key_bytes , miner_umbral_public_key_bytes , signed_miner_umbral_public_key , evidence_data ] [EOL] assert not adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] [EOL] [comment] [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = capsule_signature_by_requester [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = capsule_signature_by_requester_and_miner [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = cfrag_signature_by_miner [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = signed_miner_umbral_public_key [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = UmbralPrivateKey . gen_key ( ) . get_pubkey ( ) . to_bytes ( is_compressed = False ) [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = UmbralPrivateKey . gen_key ( ) . get_pubkey ( ) . to_bytes ( is_compressed = False ) [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = bytes ( args [ [number] ] [ [number] ] + [number] ) + args [ [number] ] [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = bytes ( args [ [number] ] [ [number] ] + [number] ) + args [ [number] ] [ [number] : ] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] address = to_canonical_address ( wrong_miner ) [EOL] sig_key = provider . ethereum_tester . backend . _key_lookup [ address ] [EOL] signed_wrong_miner_umbral_public_key = bytes ( sig_key . sign_msg_hash ( miner_umbral_public_key_hash ) ) [EOL] wrong_args = args [ : ] [EOL] wrong_args [ [number] ] = signed_wrong_miner_umbral_public_key [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * wrong_args ) . transact ( ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] value = escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] reward = escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] assert not adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * args ) . transact ( { [string] : investigator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] assert adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] [comment] [EOL] assert value - ( BASE_PENALTY + PENALTY_HISTORY_COEFFICIENT ) == escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] assert reward + ( BASE_PENALTY + PENALTY_HISTORY_COEFFICIENT ) / REWARD_COEFFICIENT == escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] [EOL] events = evaluation_log . get_all_entries ( ) [EOL] assert [number] == len ( events ) [EOL] event_args = events [ [number] ] [ [string] ] [EOL] assert data_hash == event_args [ [string] ] [EOL] assert miner == event_args [ [string] ] [EOL] assert investigator == event_args [ [string] ] [EOL] assert not event_args [ [string] ] [EOL] [EOL] [comment] [EOL] capsule , cfrag = fragments ( metadata ) [EOL] capsule_bytes = capsule . to_bytes ( ) [EOL] [comment] [EOL] cfrag . proof . bn_sig = CurveBN . gen_rand ( capsule . params . curve ) [EOL] cfrag_bytes = cfrag . to_bytes ( ) [EOL] hash_ctx = hashes . Hash ( hashes . SHA256 ( ) , backend = backend ) [EOL] hash_ctx . update ( capsule_bytes + cfrag_bytes ) [EOL] data_hash = hash_ctx . finalize ( ) [EOL] capsule_signature_by_requester = sign_data ( capsule_bytes , requester_umbral_private_key ) [EOL] capsule_signature_by_requester_and_miner = sign_data ( capsule_signature_by_requester , miner_umbral_private_key ) [EOL] cfrag_signature_by_miner = sign_data ( cfrag_bytes , miner_umbral_private_key ) [EOL] evidence = IndisputableEvidence ( capsule , cfrag , ursula = None ) [EOL] evidence_data = evidence . precompute_values ( ) [EOL] args = ( capsule_bytes , capsule_signature_by_requester , capsule_signature_by_requester_and_miner , cfrag_bytes , cfrag_signature_by_miner , requester_umbral_public_key_bytes , miner_umbral_public_key_bytes , signed_miner_umbral_public_key , evidence_data ) [EOL] [EOL] value = escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] reward = escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] assert not adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] tx = adjudicator_contract . functions . evaluateCFrag ( * args ) . transact ( { [string] : investigator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] assert adjudicator_contract . functions . evaluatedCFrags ( data_hash ) . call ( ) [EOL] [comment] [EOL] assert value - value // PERCENTAGE_PENALTY_COEFFICIENT == escrow . functions . minerInfo ( miner ) . call ( ) [ [number] ] [EOL] assert reward + value // PERCENTAGE_PENALTY_COEFFICIENT / REWARD_COEFFICIENT == escrow . functions . rewardInfo ( investigator ) . call ( ) [EOL] [EOL] events = evaluation_log . get_all_entries ( ) [EOL] assert [number] == len ( events ) [EOL] event_args = events [ [number] ] [ [string] ] [EOL] assert data_hash == event_args [ [string] ] [EOL] assert miner == event_args [ [string] ] [EOL] assert investigator == event_args [ [string] ] [EOL] assert not event_args [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . slow def test_upgrading ( testerchain ) : [EOL] creator = testerchain . interface . w3 . eth . accounts [ [number] ] [EOL] [EOL] secret_hash = testerchain . interface . w3 . keccak ( secret ) [EOL] secret2_hash = testerchain . interface . w3 . keccak ( secret2 ) [EOL] [EOL] [comment] [EOL] escrow1 , _ = testerchain . interface . deploy_contract ( [string] ) [EOL] escrow2 , _ = testerchain . interface . deploy_contract ( [string] ) [EOL] address1 = escrow1 . address [EOL] address2 = escrow2 . address [EOL] contract_library_v1 , _ = testerchain . interface . deploy_contract ( [string] , address1 , ALGORITHM_KECCAK256 , [number] , [number] , [number] , [number] ) [EOL] dispatcher , _ = testerchain . interface . deploy_contract ( [string] , contract_library_v1 . address , secret_hash ) [EOL] [EOL] [comment] [EOL] contract_library_v2 , _ = testerchain . interface . deploy_contract ( [string] , address2 , ALGORITHM_SHA256 , [number] , [number] , [number] , [number] ) [EOL] contract = testerchain . interface . w3 . eth . contract ( abi = contract_library_v2 . abi , address = dispatcher . address , ContractFactoryClass = Contract ) [EOL] [EOL] [comment] [EOL] assert address1 == contract . functions . escrow ( ) . call ( ) [EOL] assert ALGORITHM_KECCAK256 == contract . functions . hashAlgorithm ( ) . call ( ) [EOL] assert [number] == contract . functions . basePenalty ( ) . call ( ) [EOL] assert [number] == contract . functions . penaltyHistoryCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . percentagePenaltyCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . rewardCoefficient ( ) . call ( ) [EOL] tx = dispatcher . functions . upgrade ( contract_library_v2 . address , secret , secret2_hash ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [comment] [EOL] assert contract_library_v2 . address == dispatcher . functions . target ( ) . call ( ) [EOL] assert address2 == contract . functions . escrow ( ) . call ( ) [EOL] assert ALGORITHM_SHA256 == contract . functions . hashAlgorithm ( ) . call ( ) [EOL] assert [number] == contract . functions . basePenalty ( ) . call ( ) [EOL] assert [number] == contract . functions . penaltyHistoryCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . percentagePenaltyCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . rewardCoefficient ( ) . call ( ) [EOL] [comment] [EOL] tx = contract . functions . setValueToCheck ( [number] ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] assert [number] == contract . functions . valueToCheck ( ) . call ( ) [EOL] [EOL] [comment] [EOL] contract_library_bad , _ = testerchain . interface . deploy_contract ( [string] ) [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = dispatcher . functions . upgrade ( contract_library_v1 . address , secret2 , secret_hash ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = dispatcher . functions . upgrade ( contract_library_bad . address , secret2 , secret_hash ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] tx = dispatcher . functions . rollback ( secret2 , secret_hash ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] assert contract_library_v1 . address == dispatcher . functions . target ( ) . call ( ) [EOL] assert address1 == contract . functions . escrow ( ) . call ( ) [EOL] assert ALGORITHM_KECCAK256 == contract . functions . hashAlgorithm ( ) . call ( ) [EOL] assert [number] == contract . functions . basePenalty ( ) . call ( ) [EOL] assert [number] == contract . functions . penaltyHistoryCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . percentagePenaltyCoefficient ( ) . call ( ) [EOL] assert [number] == contract . functions . rewardCoefficient ( ) . call ( ) [EOL] [comment] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = contract . functions . setValueToCheck ( [number] ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ( TransactionFailed , ValueError ) ) : [EOL] tx = dispatcher . functions . upgrade ( contract_library_bad . address , secret , secret2_hash ) . transact ( { [string] : creator } ) [EOL] testerchain . wait_for_receipt ( tx ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import pytest [EOL] from web3 . contract import Contract [EOL] [EOL] [EOL] ALGORITHM_SHA256 = [number] [EOL] BASE_PENALTY = [number] [EOL] PENALTY_HISTORY_COEFFICIENT = [number] [EOL] PERCENTAGE_PENALTY_COEFFICIENT = [number] [EOL] REWARD_COEFFICIENT = [number] [EOL] [EOL] secret = [number] . to_bytes ( [number] , byteorder = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def escrow ( testerchain ) : [EOL] escrow , _ = testerchain . interface . deploy_contract ( [string] ) [EOL] return escrow [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ False , True ] ) def adjudicator_contract ( testerchain , escrow , request ) : [EOL] contract , _ = testerchain . interface . deploy_contract ( [string] , escrow . address , ALGORITHM_SHA256 , BASE_PENALTY , PENALTY_HISTORY_COEFFICIENT , PERCENTAGE_PENALTY_COEFFICIENT , REWARD_COEFFICIENT ) [EOL] [EOL] if request . param : [EOL] secret_hash = testerchain . interface . w3 . keccak ( secret ) [EOL] dispatcher , _ = testerchain . interface . deploy_contract ( [string] , contract . address , secret_hash ) [EOL] [EOL] [comment] [EOL] contract = testerchain . interface . w3 . eth . contract ( abi = contract . abi , address = dispatcher . address , ContractFactoryClass = Contract ) [EOL] [EOL] return contract [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import nucypher [EOL] [docstring] [EOL] import pytest [EOL] [EOL] from nucypher . blockchain . eth import constants [EOL] from nucypher . blockchain . eth . actors import PolicyAuthor [EOL] from nucypher . utilities . sandbox . constants import TESTING_ETH_AIRDROP_AMOUNT [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . fixture ( scope = [string] ) def author ( testerchain , three_agents ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] token_agent . ether_airdrop ( amount = TESTING_ETH_AIRDROP_AMOUNT ) [EOL] _origin , ursula , alice , * everybody_else = testerchain . interface . w3 . eth . accounts [EOL] author = PolicyAuthor ( checksum_address = alice ) [EOL] return author [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) def test_create_policy_author ( testerchain , three_agents ) : [EOL] _origin , ursula , alice , * everybody_else = testerchain . interface . w3 . eth . accounts [EOL] policy_author = PolicyAuthor ( checksum_address = alice ) [EOL] assert policy_author . checksum_public_address == alice [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Type [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] [EOL] import collections [EOL] import pytest [EOL] from eth_utils import is_checksum_address [EOL] [EOL] from nucypher . blockchain . eth . constants import MIN_ALLOWED_LOCKED , MIN_LOCKED_PERIODS [EOL] [EOL] MockPolicyMetadata = collections . namedtuple ( [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) @ pytest . mark . usefixtures ( [string] ) def policy_meta ( testerchain , three_agents ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] origin , someone , * everybody_else = testerchain . interface . w3 . eth . accounts [EOL] agent = policy_agent [EOL] [EOL] _policy_id = os . urandom ( [number] ) [EOL] node_addresses = list ( miner_agent . sample ( quantity = [number] , duration = [number] ) ) [EOL] _txhash = agent . create_policy ( policy_id = _policy_id , author_address = someone , value = MIN_ALLOWED_LOCKED , periods = [number] , initial_reward = [number] , node_addresses = node_addresses ) [EOL] [EOL] return MockPolicyMetadata ( _policy_id , someone , node_addresses ) [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . mark . usefixtures ( [string] ) def test_create_policy ( testerchain , three_agents ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] origin , someone , * everybody_else = testerchain . interface . w3 . eth . accounts [EOL] agent = policy_agent [EOL] [EOL] policy_id = os . urandom ( [number] ) [EOL] node_addresses = list ( miner_agent . sample ( quantity = [number] , duration = [number] ) ) [EOL] txhash = agent . create_policy ( policy_id = policy_id , author_address = someone , value = MIN_ALLOWED_LOCKED , periods = [number] , initial_reward = [number] , node_addresses = node_addresses ) [EOL] [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] assert receipt [ [string] ] [ [number] ] [ [string] ] == agent . contract_address [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . mark . usefixtures ( [string] ) def test_fetch_policy_arrangements ( three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] arrangements = list ( agent . fetch_policy_arrangements ( policy_id = policy_meta . policy_id ) ) [EOL] assert arrangements [EOL] assert len ( arrangements ) == len ( policy_meta . addresses ) [EOL] assert is_checksum_address ( arrangements [ [number] ] [ [number] ] ) [EOL] assert list ( record [ [number] ] for record in arrangements ) == policy_meta . addresses [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . mark . usefixtures ( [string] ) def test_revoke_arrangement ( three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] txhash = agent . revoke_arrangement ( policy_id = policy_meta . policy_id , author_address = policy_meta . author , node_address = policy_meta . addresses [ [number] ] ) [EOL] testerchain = agent . blockchain [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] assert receipt [ [string] ] [ [number] ] [ [string] ] == agent . contract_address [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . mark . usefixtures ( [string] ) def test_revoke_policy ( three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] txhash = agent . revoke_policy ( policy_id = policy_meta . policy_id , author_address = policy_meta . author ) [EOL] testerchain = agent . blockchain [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] assert receipt [ [string] ] [ [number] ] [ [string] ] == agent . contract_address [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_calculate_refund ( testerchain , three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] ursula = policy_meta . addresses [ - [number] ] [EOL] testerchain . time_travel ( hours = [number] ) [EOL] _txhash = miner_agent . confirm_activity ( node_address = ursula ) [EOL] txhash = agent . calculate_refund ( policy_id = policy_meta . policy_id , author_address = policy_meta . author ) [EOL] testerchain = agent . blockchain [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] ) def test_collect_refund ( testerchain , three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] testerchain . time_travel ( hours = [number] ) [EOL] txhash = agent . collect_refund ( policy_id = policy_meta . policy_id , author_address = policy_meta . author ) [EOL] testerchain = agent . blockchain [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] assert receipt [ [string] ] [ [number] ] [ [string] ] == agent . contract_address [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) @ pytest . mark . usefixtures ( [string] ) def test_collect_policy_reward ( testerchain , three_agents , policy_meta ) : [EOL] token_agent , miner_agent , policy_agent = three_agents [EOL] agent = policy_agent [EOL] [EOL] ursula = policy_meta . addresses [ - [number] ] [EOL] old_eth_balance = token_agent . blockchain . interface . w3 . eth . getBalance ( ursula ) [EOL] [EOL] for _ in range ( MIN_LOCKED_PERIODS ) : [EOL] _txhash = miner_agent . confirm_activity ( node_address = ursula ) [EOL] testerchain . time_travel ( periods = [number] ) [EOL] [EOL] txhash = agent . collect_policy_reward ( collector_address = ursula , miner_address = ursula ) [EOL] receipt = testerchain . wait_for_receipt ( txhash ) [EOL] assert receipt [ [string] ] == [number] , [string] [EOL] assert receipt [ [string] ] [ [number] ] [ [string] ] == agent . contract_address [EOL] new_eth_balance = token_agent . blockchain . interface . w3 . eth . getBalance ( ursula ) [EOL] assert new_eth_balance > old_eth_balance [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.blockchain.eth.entities.agents.test_policy_manager_agent.MockPolicyMetadata]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tests.blockchain.eth.entities.agents.test_policy_manager_agent.MockPolicyMetadata]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from math import log [EOL] [EOL] from nucypher . blockchain . economics import Economics [EOL] [EOL] [EOL] def test_economics ( ) : [EOL] e = Economics ( initial_supply = [number] ** [number] , initial_inflation = [number] , T_half = [number] , T_sat = [number] , small_staker_multiplier = [number] ) [EOL] [EOL] assert round ( e . total_supply / [number] , [number] ) == [number] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] initial_rate = ( e . total_supply - e . input_params [ [string] ] ) * ( e . lockedPeriodsCoefficent + [number] ) / e . miningCoefficient [EOL] [EOL] assert round ( initial_rate ) == round ( e . input_params [ [string] ] * e . input_params [ [string] ] / [number] ) [EOL] [EOL] initial_rate_small = ( e . total_supply - e . input_params [ [string] ] ) * e . lockedPeriodsCoefficent / e . miningCoefficient [EOL] [EOL] assert round ( initial_rate_small ) == round ( initial_rate / [number] ) [EOL] [EOL] [comment] [EOL] assert round ( log ( [number] ) / ( e . input_params [ [string] ] * [number] ) * ( e . total_supply - e . input_params [ [string] ] ) ) == round ( initial_rate ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import nucypher [EOL] [docstring] [EOL] import os [EOL] [EOL] import pytest [EOL] from constant_sorrow import constants [EOL] [EOL] from nucypher . blockchain . eth . agents import NucypherTokenAgent , MinerAgent [EOL] from nucypher . blockchain . eth . constants import DISPATCHER_SECRET_LENGTH [EOL] from nucypher . blockchain . eth . deployers import ( NucypherTokenDeployer , MinerEscrowDeployer , PolicyManagerDeployer , ContractDeployer ) [EOL] [EOL] [EOL] @ pytest . mark . slow ( ) def test_deploy_ethereum_contracts ( testerchain ) : [EOL] [EOL] origin , * everybody_else = testerchain . interface . w3 . eth . accounts [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] token_deployer = NucypherTokenDeployer ( blockchain = testerchain , deployer_address = origin ) [EOL] assert token_deployer . deployer_address == origin [EOL] [EOL] with pytest . raises ( ContractDeployer . ContractDeploymentError ) : [EOL] assert token_deployer . contract_address is constants . CONTRACT_NOT_DEPLOYED [EOL] assert not token_deployer . is_deployed [EOL] [EOL] token_deployer . deploy ( ) [EOL] assert token_deployer . is_deployed [EOL] assert len ( token_deployer . contract_address ) == [number] [EOL] [EOL] token_agent = NucypherTokenAgent ( blockchain = testerchain ) [EOL] assert len ( token_agent . contract_address ) == [number] [EOL] assert token_agent . contract_address == token_deployer . contract_address [EOL] [EOL] another_token_agent = token_deployer . make_agent ( ) [EOL] assert len ( another_token_agent . contract_address ) == [number] [EOL] assert another_token_agent . contract_address == token_deployer . contract_address == token_agent . contract_address [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] miners_escrow_secret = os . urandom ( DISPATCHER_SECRET_LENGTH ) [EOL] miner_escrow_deployer = MinerEscrowDeployer ( blockchain = testerchain , deployer_address = origin , secret_hash = testerchain . interface . w3 . keccak ( miners_escrow_secret ) ) [EOL] assert miner_escrow_deployer . deployer_address == origin [EOL] [EOL] with pytest . raises ( ContractDeployer . ContractDeploymentError ) : [EOL] assert miner_escrow_deployer . contract_address is constants . CONTRACT_NOT_DEPLOYED [EOL] assert not miner_escrow_deployer . is_deployed [EOL] [EOL] miner_escrow_deployer . deploy ( ) [EOL] assert miner_escrow_deployer . is_deployed [EOL] assert len ( miner_escrow_deployer . contract_address ) == [number] [EOL] [EOL] miner_agent = MinerAgent ( blockchain = testerchain ) [EOL] assert len ( miner_agent . contract_address ) == [number] [EOL] assert miner_agent . contract_address == miner_escrow_deployer . contract_address [EOL] [EOL] another_miner_agent = miner_escrow_deployer . make_agent ( ) [EOL] assert len ( another_miner_agent . contract_address ) == [number] [EOL] assert another_miner_agent . contract_address == miner_escrow_deployer . contract_address == miner_agent . contract_address [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] policy_manager_secret = os . urandom ( DISPATCHER_SECRET_LENGTH ) [EOL] policy_manager_deployer = PolicyManagerDeployer ( blockchain = testerchain , deployer_address = origin , secret_hash = testerchain . interface . w3 . keccak ( policy_manager_secret ) ) [EOL] assert policy_manager_deployer . deployer_address == origin [EOL] [EOL] with pytest . raises ( ContractDeployer . ContractDeploymentError ) : [EOL] assert policy_manager_deployer . contract_address is constants . CONTRACT_NOT_DEPLOYED [EOL] assert not policy_manager_deployer . is_deployed [EOL] [EOL] policy_manager_deployer . deploy ( ) [EOL] assert policy_manager_deployer . is_deployed [EOL] assert len ( policy_manager_deployer . contract_address ) == [number] [EOL] [EOL] policy_agent = policy_manager_deployer . make_agent ( ) [EOL] assert len ( policy_agent . contract_address ) == [number] [EOL] assert policy_agent . contract_address == policy_manager_deployer . contract_address [EOL] [EOL] another_policy_agent = policy_manager_deployer . make_agent ( ) [EOL] assert len ( another_policy_agent . contract_address ) == [number] [EOL] assert another_policy_agent . contract_address == policy_manager_deployer . contract_address == policy_agent . contract_address [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] def test_testerchain_creation ( testerchain ) : [EOL] [comment] [EOL] assert [string] in testerchain . interface . provider_uri [EOL] [EOL] [comment] [EOL] assert testerchain . interface . w3 . eth . blockNumber >= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import nucypher [EOL] import typing [EOL] from nucypher . config . characters import UrsulaConfiguration [EOL] from nucypher . network . server import status_template [EOL] [EOL] [EOL] def test_render_lonely_ursula_status_page ( tmpdir ) : [EOL] ursula_config = UrsulaConfiguration ( dev_mode = True , federated_only = True ) [EOL] ursula = ursula_config ( ) [EOL] [EOL] rendering = status_template . render ( this_node = ursula , known_nodes = ursula . known_nodes ) [EOL] assert [string] in rendering [EOL] assert ursula . nickname in rendering [EOL] [EOL] [EOL] def test_render_ursula_status_page_with_known_nodes ( tmpdir , federated_ursulas ) : [EOL] ursula_config = UrsulaConfiguration ( dev_mode = True , federated_only = True , known_nodes = federated_ursulas ) [EOL] ursula = ursula_config ( ) [EOL] [EOL] rendering = status_template . render ( this_node = ursula , known_nodes = ursula . known_nodes ) [EOL] assert [string] in rendering [EOL] assert ursula . nickname in rendering [EOL] [EOL] [comment] [EOL] for known_ursula in federated_ursulas : [EOL] assert known_ursula . checksum_public_address in rendering [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import functools [EOL] import datetime [EOL] import maya [EOL] import pytest [EOL] [EOL] from nucypher . network . nodes import Learner [EOL] from nucypher . policy . models import TreasureMap , Policy [EOL] from nucypher . utilities . sandbox . middleware import NodeIsDownMiddleware [EOL] from functools import partial [EOL] [EOL] [EOL] def test_bob_does_not_let_a_connection_error_stop_him ( enacted_federated_policy , federated_ursulas , federated_bob , federated_alice ) : [EOL] assert len ( federated_bob . known_nodes ) == [number] [EOL] ursula1 = list ( federated_ursulas ) [ [number] ] [EOL] ursula2 = list ( federated_ursulas ) [ [number] ] [EOL] [EOL] federated_bob . remember_node ( ursula1 ) [EOL] [EOL] federated_bob . network_middleware = NodeIsDownMiddleware ( ) [EOL] federated_bob . network_middleware . node_is_down ( ursula1 ) [EOL] [EOL] with pytest . raises ( TreasureMap . NowhereToBeFound ) : [EOL] federated_bob . get_treasure_map ( federated_alice . stamp , enacted_federated_policy . label ) [EOL] [EOL] federated_bob . remember_node ( ursula2 ) [EOL] [EOL] map = federated_bob . get_treasure_map ( federated_alice . stamp , enacted_federated_policy . label ) [EOL] [EOL] assert sorted ( list ( map . destinations . keys ( ) ) ) == sorted ( list ( u . checksum_public_address for u in list ( federated_ursulas ) ) ) [EOL] [EOL] [EOL] def test_alice_can_grant_even_when_the_first_nodes_she_tries_are_down ( federated_alice , federated_bob , federated_ursulas ) : [EOL] m , n = [number] , [number] [EOL] policy_end_datetime = maya . now ( ) + datetime . timedelta ( days = [number] ) [EOL] label = [string] [EOL] federated_alice . known_nodes . _nodes = { } [EOL] [EOL] federated_alice . network_middleware = NodeIsDownMiddleware ( ) [EOL] [EOL] [comment] [EOL] down_node = list ( federated_ursulas ) [ [number] ] [EOL] federated_alice . remember_node ( down_node ) [EOL] federated_alice . network_middleware . node_is_down ( down_node ) [EOL] [EOL] [comment] [EOL] alice_grant_action = partial ( federated_alice . grant , federated_bob , label , m = m , n = n , expiration = policy_end_datetime , timeout = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( down_node . NotEnoughNodes ) : [EOL] alice_grant_action ( ) [EOL] [EOL] [comment] [EOL] reliable_node = list ( federated_ursulas ) [ [number] ] [EOL] federated_alice . remember_node ( reliable_node ) [EOL] [EOL] [comment] [EOL] more_nodes = list ( federated_ursulas ) [ [number] : [number] ] [EOL] [EOL] [comment] [EOL] assert len ( federated_alice . known_nodes ) == [number] [EOL] [EOL] for node in more_nodes : [EOL] federated_alice . network_middleware . node_is_down ( node ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( Learner . NotEnoughNodes ) : [EOL] alice_grant_action ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for node in more_nodes : [EOL] federated_alice . remember_node ( node ) [EOL] with pytest . raises ( Policy . MoreKFragsThanArrangements ) : [EOL] alice_grant_action ( ) [EOL] [EOL] [comment] [EOL] for node in more_nodes [ [number] : [number] ] : [EOL] federated_alice . network_middleware . node_is_up ( node ) [EOL] [EOL] [comment] [EOL] policy = alice_grant_action ( ) [comment] [EOL] [EOL] [comment] [EOL] assert len ( policy . _accepted_arrangements ) >= n [EOL] [EOL] [comment] [EOL] assert len ( policy . _enacted_arrangements ) == n [EOL] [EOL] [EOL] def test_node_has_changed_cert ( federated_alice , federated_ursulas ) : [EOL] federated_alice . known_nodes . _nodes = { } [EOL] federated_alice . network_middleware = NodeIsDownMiddleware ( ) [EOL] federated_alice . network_middleware . client . certs_are_broken = True [EOL] [EOL] firstula = list ( federated_ursulas ) [ [number] ] [EOL] federated_alice . remember_node ( firstula ) [EOL] federated_alice . start_learning_loop ( now = True ) [EOL] federated_alice . learn_from_teacher_node ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import maya [EOL] import pytest [EOL] import pytest_twisted as pt [EOL] from twisted . internet . threads import deferToThread [EOL] [EOL] from nucypher . utilities . sandbox . ursula import make_federated_ursulas [EOL] [EOL] [EOL] @ pt . inlineCallbacks def test_one_node_stores_a_bunch_of_others ( federated_ursulas , ursula_federated_test_config ) : [EOL] the_chosen_seednode = list ( federated_ursulas ) [ [number] ] [comment] [EOL] seed_node = the_chosen_seednode . seed_node_metadata ( ) [EOL] [EOL] newcomer = make_federated_ursulas ( ursula_config = ursula_federated_test_config , quantity = [number] , know_each_other = False , save_metadata = True , seed_nodes = [ seed_node ] ) . pop ( ) [EOL] [EOL] assert not newcomer . known_nodes [EOL] [EOL] newcomer . start_learning_loop ( now = True ) [EOL] [EOL] def start_lonely_learning_loop ( ) : [EOL] newcomer . start_learning_loop ( ) [EOL] start = maya . now ( ) [EOL] [comment] [EOL] while the_chosen_seednode not in newcomer . node_storage . all ( federated_only = True ) : [EOL] passed = maya . now ( ) - start [EOL] if passed . seconds > [number] : [EOL] pytest . fail ( [string] ) [EOL] [EOL] yield deferToThread ( start_lonely_learning_loop ) [EOL] [EOL] assert list ( newcomer . known_nodes ) [EOL] assert len ( list ( newcomer . known_nodes ) ) == len ( list ( newcomer . node_storage . all ( True ) ) ) [EOL] assert set ( list ( newcomer . known_nodes ) ) == set ( list ( newcomer . node_storage . all ( True ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0