[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , List [EOL] import typing [EOL] import pkg_resources [EOL] [EOL] import cloud_sptheme as csp [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] project = [string] [EOL] copyright = [string] [EOL] author = [string] [EOL] [EOL] [comment] [EOL] project_version = pkg_resources . require ( project ) [ [number] ] . version [EOL] version_parts = project_version . split ( [string] ) [EOL] version = [string] . join ( version_parts [ [number] : [number] ] ) [EOL] [comment] [EOL] release = project_version [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] templates_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exclude_patterns = [ ] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_theme = [string] [EOL] [EOL] [comment] [EOL] html_theme_path = [ csp . get_theme_dir ( ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] html_static_path = [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] autodoc_member_order = [string] [EOL] autodoc_default_flags = [ [string] ] [EOL] napoleon_numpy_docstring = False [EOL] [EOL] [comment] [EOL] [EOL] intersphinx_mapping = { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Type [EOL] import interfaces [EOL] import typing [EOL] import plugin [EOL] from __future__ import annotations [EOL] [EOL] from typing import Type [EOL] [EOL] from . interfaces . backend import ServiceInterface [EOL] from . plugin import Plugin [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] services = Plugin ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plugin.Plugin[typing.Type[interfaces.backend.ServiceInterface]]$ 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import parsing [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod , ABCMeta [EOL] from typing import Optional [EOL] [EOL] from . parsing . specials import SearchKey [EOL] from . parsing . response import Response , ResponseCode , ResponseNo , ResponseOk , ResponseBye [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class ResponseError ( Exception , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def get_response ( self , tag ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class CloseConnection ( ResponseError ) : [EOL] [docstring] [EOL] [EOL] def get_response ( self , tag ) : [EOL] response = ResponseOk ( tag , [string] ) [EOL] response . add_untagged ( ResponseBye ( [string] ) ) [EOL] return response [EOL] [EOL] [EOL] class NotSupportedError ( ResponseError , NotImplementedError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg = [string] ) : [EOL] super ( ) . __init__ ( msg ) [EOL] self . _raw = msg . encode ( [string] ) [EOL] [EOL] def get_response ( self , tag ) : [EOL] return ResponseNo ( tag , self . _raw , ResponseCode . of ( [string] ) ) [EOL] [EOL] [EOL] class SearchNotAllowed ( NotSupportedError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key ) : [EOL] super ( ) . __init__ ( f' [string] { key . value_str } [string] ' ) [EOL] [EOL] [EOL] class InvalidAuth ( ResponseError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg = [string] , * , authorization = False ) : [EOL] super ( ) . __init__ ( msg ) [EOL] self . _raw = msg . encode ( [string] ) [EOL] if authorization : [EOL] self . _code = ResponseCode . of ( [string] ) [EOL] else : [EOL] self . _code = ResponseCode . of ( [string] ) [EOL] [EOL] def get_response ( self , tag ) : [EOL] return ResponseNo ( tag , self . _raw , self . _code ) [EOL] [EOL] [EOL] class IncompatibleData ( InvalidAuth ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg = [string] ) : [EOL] super ( ) . __init__ ( msg ) [EOL] [EOL] [EOL] class TemporaryFailure ( ResponseError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , msg ) : [EOL] super ( ) . __init__ ( msg ) [EOL] self . _raw = msg . encode ( [string] ) [EOL] [EOL] def get_response ( self , tag ) : [EOL] return ResponseNo ( tag , self . _raw , ResponseCode . of ( [string] ) ) [EOL] [EOL] [EOL] class MailboxError ( ResponseError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox , message , code = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . mailbox = mailbox [EOL] self . message = message [EOL] self . code = code [EOL] [EOL] def get_response ( self , tag ) : [EOL] return ResponseNo ( tag , self . message , self . code ) [EOL] [EOL] [EOL] class MailboxNotFound ( MailboxError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox , * , try_create = False ) : [EOL] code = ResponseCode . of ( [string] if try_create else [string] ) [EOL] super ( ) . __init__ ( mailbox , [string] , code ) [EOL] [EOL] [EOL] class MailboxConflict ( MailboxError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox ) : [EOL] super ( ) . __init__ ( mailbox , [string] , ResponseCode . of ( [string] ) ) [EOL] [EOL] [EOL] class MailboxHasChildren ( MailboxError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox ) : [EOL] super ( ) . __init__ ( mailbox , [string] ) [EOL] [EOL] [EOL] class MailboxReadOnly ( MailboxError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox = None ) : [EOL] super ( ) . __init__ ( mailbox , [string] , ResponseCode . of ( [string] ) ) [EOL] [EOL] [EOL] class AppendFailure ( MailboxError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UserNotFound ( ResponseError ) : [EOL] [docstring] [EOL] [EOL] def get_response ( self , tag ) : [EOL] return ResponseNo ( tag , [string] , ResponseCode . of ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.Response$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.Response.Ok$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $parsing.response.ResponseNo$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $parsing.specials.SearchKey$ 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.SearchKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.ResponseNo$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $parsing.response.ResponseNo$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.ResponseNo$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.ResponseNo$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , FrozenSet , List , Type , Tuple , Any , Set , Dict , AbstractSet , Sequence , MutableSet , Iterable , Iterator [EOL] import pymap [EOL] import parsing [EOL] import interfaces [EOL] import builtins [EOL] import typing [EOL] import flags [EOL] import itertools [EOL] from __future__ import annotations [EOL] [EOL] from bisect import bisect_right [EOL] from itertools import chain , groupby , islice [EOL] from typing import Any , Optional , Tuple , Dict , Set , MutableSet , AbstractSet , FrozenSet , Iterable , List , Sequence [EOL] from weakref import WeakSet [EOL] [EOL] from . flags import FlagOp , PermanentFlags , SessionFlags [EOL] from . interfaces . message import CachedMessage , FlagsKey [EOL] from . parsing . command import Command [EOL] from . parsing . primitives import ListP , Number [EOL] from . parsing . response import UntaggedResponse , ResponseBye [EOL] from . parsing . response . specials import ExistsResponse , RecentResponse , ExpungeResponse , FetchResponse [EOL] from . parsing . specials import ObjectId , FetchAttribute , FetchValue , Flag , SequenceSet [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _flags_attr = FetchAttribute ( [string] ) [EOL] _uid_attr = FetchAttribute ( [string] ) [EOL] [EOL] [EOL] class SelectedSet : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _set = WeakSet ( ) [EOL] [EOL] def add ( self , selected , * , replace = None ) : [EOL] [docstring] [EOL] if replace is not None : [EOL] self . _set . discard ( replace ) [EOL] self . _set . add ( selected ) [EOL] [EOL] @ property def any_selected ( self ) : [EOL] [docstring] [EOL] for selected in self . _set : [EOL] if not selected . readonly : [EOL] return selected [EOL] return None [EOL] [EOL] [EOL] class _Frozen : [EOL] [EOL] def __init__ ( self , selected ) : [EOL] super ( ) . __init__ ( ) [EOL] messages = selected . messages [EOL] session_flags = selected . session_flags [EOL] self . is_deleted = selected . _is_deleted [EOL] self . uids = messages . _uids . copy ( ) [EOL] self . seqs_cache = messages . _seqs_cache . copy ( ) [EOL] self . flags = messages . _flags_key_set . copy ( ) [EOL] self . recent = session_flags . recent_uids & self . uids [EOL] self . sflags = frozenset ( session_flags . flags . items ( ) ) [EOL] [EOL] [EOL] class SynchronizedMessages : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _uids = set ( ) [EOL] self . _sorted = [ ] [EOL] self . _seqs_cache = { } [EOL] self . _cache = { } [EOL] self . _flags_key_map = { } [EOL] self . _flags_key_set = set ( ) [EOL] self . _pending_remove = set ( ) [EOL] [EOL] @ property def exists ( self ) : [EOL] [docstring] [EOL] return len ( self . _uids ) [EOL] [EOL] @ property def max_uid ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . _sorted [ - [number] ] [EOL] except IndexError : [EOL] return [number] [EOL] [EOL] def _update ( self , messages ) : [EOL] lowest_idx = None [EOL] for msg in messages : [EOL] msg_uid = msg . uid [EOL] if msg_uid not in self . _uids : [EOL] self . _uids . add ( msg_uid ) [EOL] idx = bisect_right ( self . _sorted , msg_uid ) [EOL] if lowest_idx is None or lowest_idx > idx : [EOL] lowest_idx = idx [EOL] self . _sorted . insert ( idx , msg_uid ) [EOL] self . _cache [ msg_uid ] = msg [EOL] new_flags_key = msg . flags_key [EOL] old_flags_key = self . _flags_key_map . get ( msg_uid ) [EOL] if old_flags_key is not None : [EOL] self . _flags_key_set . discard ( old_flags_key ) [EOL] self . _flags_key_map [ msg_uid ] = new_flags_key [EOL] self . _flags_key_set . add ( new_flags_key ) [EOL] if lowest_idx is not None : [EOL] needs_reset = islice ( self . _sorted , lowest_idx , len ( self . _sorted ) ) [EOL] for seq , uid in enumerate ( needs_reset , lowest_idx + [number] ) : [EOL] self . _seqs_cache [ uid ] = seq [EOL] [EOL] def _remove ( self , uids , pending ) : [EOL] if pending : [EOL] self . _pending_remove . update ( uids ) [EOL] else : [EOL] any_removed = False [EOL] for msg_uid in chain ( uids , self . _pending_remove ) : [EOL] try : [EOL] self . _uids . remove ( msg_uid ) [EOL] except KeyError : [EOL] pass [EOL] else : [EOL] flags_key = self . _flags_key_map [ msg_uid ] [EOL] self . _flags_key_set . remove ( flags_key ) [EOL] del self . _flags_key_map [ msg_uid ] [EOL] del self . _cache [ msg_uid ] [EOL] any_removed = True [EOL] self . _pending_remove . clear ( ) [EOL] if any_removed : [EOL] self . _sorted = sorted_uids = sorted ( self . _uids ) [EOL] self . _seqs_cache = { uid : seq for seq , uid in enumerate ( sorted_uids , [number] ) } [EOL] [EOL] def get ( self , uid ) : [EOL] [docstring] [EOL] return self . _cache . get ( uid ) [EOL] [EOL] def get_uids ( self , seq_set ) : [EOL] [docstring] [EOL] if seq_set . uid : [EOL] all_uids = seq_set . flatten ( self . max_uid ) & self . _uids [EOL] return [ ( seq , uid ) for seq , uid in enumerate ( self . _sorted , [number] ) if uid in all_uids ] [EOL] else : [EOL] all_seqs = seq_set . flatten ( self . exists ) [EOL] return [ ( seq , uid ) for seq , uid in enumerate ( self . _sorted , [number] ) if seq in all_seqs ] [EOL] [EOL] def get_all ( self , seq_set ) : [EOL] [docstring] [EOL] if seq_set . uid : [EOL] all_uids = seq_set . flatten ( self . max_uid ) & self . _uids [EOL] return [ ( seq , self . _cache [ uid ] ) for seq , uid in enumerate ( self . _sorted , [number] ) if uid in all_uids ] [EOL] else : [EOL] all_seqs = seq_set . flatten ( self . exists ) [EOL] return [ ( seq , self . _cache [ uid ] ) for seq , uid in enumerate ( self . _sorted , [number] ) if seq in all_seqs ] [EOL] [EOL] [EOL] class SelectedMailbox : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , mailbox_id , readonly , permanent_flags , session_flags , selected_set = None , lookup = None , ** kwargs ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _mailbox_id = mailbox_id [EOL] self . _readonly = readonly [EOL] self . _permanent_flags = permanent_flags [EOL] self . _session_flags = session_flags [EOL] self . _selected_set = selected_set [EOL] self . _kwargs = kwargs [EOL] self . _lookup = lookup [EOL] self . _mod_sequence = kwargs . get ( [string] ) [EOL] self . _is_deleted = False [EOL] self . _hide_expunged = False [EOL] self . _silenced_flags = set ( ) [EOL] self . _silenced_sflags = set ( ) [EOL] self . _prev = kwargs . get ( [string] ) [EOL] try : [EOL] self . _messages = kwargs [ [string] ] [EOL] except KeyError : [EOL] self . _messages = SynchronizedMessages ( ) [EOL] if selected_set is not None : [EOL] selected_set . add ( self ) [EOL] [EOL] @ property def mailbox_id ( self ) : [EOL] [docstring] [EOL] return self . _mailbox_id [EOL] [EOL] @ property def lookup ( self ) : [EOL] [docstring] [EOL] return self . _lookup [EOL] [EOL] @ lookup . setter def lookup ( self , lookup ) : [EOL] self . _lookup = lookup [EOL] [EOL] @ property def mod_sequence ( self ) : [EOL] [docstring] [EOL] return self . _mod_sequence [EOL] [EOL] @ mod_sequence . setter def mod_sequence ( self , mod_sequence ) : [EOL] self . _mod_sequence = mod_sequence [EOL] [EOL] @ property def hide_expunged ( self ) : [EOL] [docstring] [EOL] return self . _hide_expunged [EOL] [EOL] @ hide_expunged . setter def hide_expunged ( self , hide_expunged ) : [EOL] self . _hide_expunged = hide_expunged [EOL] [EOL] def add_updates ( self , messages , expunged ) : [EOL] [docstring] [EOL] self . _messages . _update ( messages ) [EOL] self . _messages . _remove ( expunged , self . _hide_expunged ) [EOL] if not self . _hide_expunged : [EOL] self . _session_flags . remove ( expunged ) [EOL] [EOL] def set_messages ( self , messages ) : [EOL] [docstring] [EOL] uids = { msg . uid for msg in messages } [EOL] expunged = self . _messages . _uids - uids [EOL] return self . add_updates ( messages , expunged ) [EOL] [EOL] @ property def readonly ( self ) : [EOL] [docstring] [EOL] return self . _readonly [EOL] [EOL] @ property def messages ( self ) : [EOL] [docstring] [EOL] return self . _messages [EOL] [EOL] @ property def permanent_flags ( self ) : [EOL] [docstring] [EOL] return self . _permanent_flags [EOL] [EOL] @ property def session_flags ( self ) : [EOL] [docstring] [EOL] return self . _session_flags [EOL] [EOL] def set_deleted ( self ) : [EOL] [docstring] [EOL] self . _is_deleted = True [EOL] [EOL] def silence ( self , seq_set , flag_set , flag_op ) : [EOL] [docstring] [EOL] session_flags = self . session_flags [EOL] permanent_flag_set = self . permanent_flags & flag_set [EOL] session_flag_set = session_flags & flag_set [EOL] for seq , msg in self . _messages . get_all ( seq_set ) : [EOL] msg_flags = msg . permanent_flags [EOL] msg_sflags = session_flags . get ( msg . uid ) [EOL] updated_flags = flag_op . apply ( msg_flags , permanent_flag_set ) [EOL] updated_sflags = flag_op . apply ( msg_sflags , session_flag_set ) [EOL] if msg_flags != updated_flags : [EOL] self . _silenced_flags . add ( ( msg . uid , updated_flags ) ) [EOL] if msg_sflags != updated_sflags : [EOL] self . _silenced_sflags . add ( ( msg . uid , updated_sflags ) ) [EOL] [EOL] def fork ( self , command ) : [EOL] [docstring] [EOL] frozen = _Frozen ( self ) [EOL] cls = type ( self ) [EOL] copy = cls ( self . _mailbox_id , self . _readonly , self . _permanent_flags , self . _session_flags , self . _selected_set , self . _lookup , _mod_sequence = self . _mod_sequence , _prev = frozen , _messages = self . _messages ) [EOL] if self . _prev is not None : [EOL] with_uid = getattr ( command , [string] , False ) [EOL] untagged = self . _compare ( self . _prev , frozen , with_uid ) [EOL] else : [EOL] untagged = [ ] [EOL] return copy , untagged [EOL] [EOL] def _compare ( self , before , after , with_uid ) : [EOL] if after . is_deleted : [EOL] yield ResponseBye ( [string] ) [EOL] return [EOL] cache = self . _messages . _cache [EOL] session_flags = self . _session_flags [EOL] expunged_uids = before . uids - after . uids [EOL] new_uids = after . uids - before . uids [EOL] if not self . _hide_expunged and expunged_uids : [EOL] for uid in sorted ( expunged_uids , reverse = True ) : [EOL] yield ExpungeResponse ( before . seqs_cache [ uid ] ) [EOL] if new_uids : [EOL] yield ExistsResponse ( len ( after . uids ) ) [EOL] if len ( after . recent ) != len ( before . recent ) : [EOL] yield RecentResponse ( len ( after . recent ) ) [EOL] new_recent = ( after . recent - before . recent ) [EOL] new_flags = ( after . flags - before . flags - self . _silenced_flags ) [EOL] new_sflags = ( after . sflags - before . sflags - self . _silenced_sflags ) [EOL] fetch_uids = chain ( new_recent , ( uid for uid , _ in new_flags ) , ( uid for uid , _ in new_sflags ) ) [EOL] for uid , _ in groupby ( sorted ( fetch_uids ) ) : [EOL] seq = after . seqs_cache [ uid ] [EOL] msg_flags = cache [ uid ] . get_flags ( session_flags ) [EOL] fetch_data = [ FetchValue . of ( _flags_attr , ListP ( msg_flags , sort = True ) ) ] [EOL] if with_uid : [EOL] fetch_data . append ( FetchValue . of ( _uid_attr , Number ( uid ) ) ) [EOL] yield FetchResponse ( seq , fetch_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableSet[SelectedMailbox]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $SelectedMailbox$ 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 $typing.Optional[SelectedMailbox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SynchronizedMessages$ 0 $SelectedMailbox$ 0 $pymap.selected.SynchronizedMessages$ 0 $pymap.flags.SessionFlags$ 0 $SelectedMailbox$ 0 $pymap.flags.SessionFlags$ 0 0 0 0 0 $SelectedMailbox$ 0 0 0 0 0 0 0 $pymap.selected.SynchronizedMessages$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SynchronizedMessages$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SynchronizedMessages$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.flags.SessionFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.flags.SessionFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,interfaces.message.CachedMessage]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,interfaces.message.FlagsKey]$ 0 0 0 0 0 0 $typing.Set[interfaces.message.FlagsKey]$ 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[interfaces.message.CachedMessage]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Iterable[interfaces.message.CachedMessage]$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.int]$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.frozenset[pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[interfaces.message.CachedMessage]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Sequence[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 $parsing.specials.SequenceSet$ 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 0 0 0 $typing.Sequence[typing.Tuple[builtins.int,interfaces.message.CachedMessage]]$ 0 0 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 $parsing.specials.SequenceSet$ 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $parsing.specials.ObjectId$ 0 $builtins.bool$ 0 $flags.PermanentFlags$ 0 $flags.SessionFlags$ 0 $SelectedSet$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $flags.PermanentFlags$ 0 0 0 0 0 $flags.SessionFlags$ 0 0 0 0 0 $SelectedSet$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,typing.FrozenSet[parsing.specials.Flag]]]$ 0 0 0 0 0 0 0 $typing.Set[typing.Tuple[builtins.int,typing.FrozenSet[parsing.specials.Flag]]]$ 0 0 0 0 0 0 0 $typing.Optional[_Frozen]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SelectedSet$ 0 0 0 0 0 $SelectedSet$ 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $None$ 0 0 0 $typing.Iterable[interfaces.message.CachedMessage]$ 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[interfaces.message.CachedMessage]$ 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 $None$ 0 0 0 $typing.Sequence[interfaces.message.CachedMessage]$ 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Sequence[interfaces.message.CachedMessage]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 $typing.Sequence[interfaces.message.CachedMessage]$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SynchronizedMessages$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flags.PermanentFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flags.SessionFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 $parsing.specials.SequenceSet$ 0 $typing.AbstractSet[parsing.specials.Flag]$ 0 $flags.FlagOp$ 0 0 0 0 0 $pymap.flags.SessionFlags$ 0 0 0 $pymap.flags.SessionFlags$ 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 $typing.AbstractSet[parsing.specials.Flag]$ 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.SessionFlags$ 0 $typing.AbstractSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.SessionFlags$ 0 0 0 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $flags.FlagOp$ 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $flags.FlagOp$ 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 $typing.Tuple[SelectedMailbox,typing.Iterable[parsing.response.UntaggedResponse]]$ 0 0 0 $parsing.command.Command$ 0 0 0 0 0 $pymap.selected._Frozen$ 0 0 0 0 0 0 $typing.Type[pymap.selected.SelectedMailbox]$ 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 $typing.Type[pymap.selected.SelectedMailbox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected._Frozen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $parsing.command.Command$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $pymap.selected._Frozen$ 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Iterable[parsing.response.UntaggedResponse]$ 0 0 0 $_Frozen$ 0 $_Frozen$ 0 $builtins.bool$ 0 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $_Frozen$ 0 0 0 $_Frozen$ 0 0 0 $typing.Any$ 0 $_Frozen$ 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 $_Frozen$ 0 0 0 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 0 0 $_Frozen$ 0 0 0 0 0 $typing.Any$ 0 0 $_Frozen$ 0 0 0 $_Frozen$ 0 0 0 0 $typing.Any$ 0 0 $_Frozen$ 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $_Frozen$ 0 0 0 $_Frozen$ 0 0 0 0 0 0 0 0 $itertools.chain[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $itertools.chain[typing.Any]$ 0 0 0 0 $typing.Any$ 0 $_Frozen$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[parsing.specials.FetchValue]$ 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.List[parsing.specials.FetchValue]$ 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[parsing.specials.FetchValue]$ 0 0
from typing import Optional , AsyncIterator , Awaitable , MutableSet , AsyncContextManager [EOL] import concurrent [EOL] import typing [EOL] import builtins [EOL] import contextvars [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] import asyncio [EOL] import os . path [EOL] import time [EOL] from abc import abstractmethod , ABCMeta [EOL] from asyncio import Event as _asyncio_Event , Lock as _asyncio_Lock , TimeoutError [EOL] from concurrent . futures import Executor , ThreadPoolExecutor [EOL] from contextlib import asynccontextmanager [EOL] from contextvars import copy_context , Context [EOL] from threading import local , Event as _threading_Event , Lock as _threading_Lock [EOL] from typing import cast , TypeVar , Optional , Sequence , MutableSet , Awaitable , AsyncContextManager , AsyncIterator [EOL] from weakref import WeakSet [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] EventT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [comment] [EOL] RetT = TypeVar ( [string] ) [EOL] [EOL] _Delay = Sequence [ float ] [EOL] [EOL] [EOL] class Subsystem ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def for_executor ( cls , executor ) : [EOL] [docstring] [EOL] if isinstance ( executor , ThreadPoolExecutor ) : [EOL] return _ThreadingSubsystem ( executor ) [EOL] elif executor is None : [EOL] return _AsyncioSubsystem ( ) [EOL] else : [EOL] raise TypeError ( executor ) [EOL] [EOL] @ classmethod def for_asyncio ( cls ) : [EOL] [docstring] [EOL] return _AsyncioSubsystem ( ) [EOL] [EOL] @ classmethod def for_threading ( cls , executor ) : [EOL] [docstring] [EOL] return _ThreadingSubsystem ( executor ) [EOL] [EOL] @ property @ abstractmethod def subsystem ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def execute ( self , future ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def new_rwlock ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def new_event ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class _AsyncioSubsystem ( Subsystem ) : [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] def execute ( self , future ) : [EOL] return future [EOL] [EOL] def new_rwlock ( self ) : [EOL] return _AsyncioReadWriteLock ( ) [EOL] [EOL] def new_event ( self ) : [EOL] return _AsyncioEvent ( ) [EOL] [EOL] [EOL] class _ThreadingSubsystem ( Subsystem ) : [comment] [EOL] [EOL] class _EventLoopLocal ( local ) : [EOL] [EOL] def __init__ ( self ) : [EOL] self . event_loop = asyncio . new_event_loop ( ) [EOL] [EOL] def __init__ ( self , executor ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _local = self . _EventLoopLocal ( ) [EOL] self . _executor = executor [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] async def execute ( self , future ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] ctx = copy_context ( ) [EOL] return await loop . run_in_executor ( self . _executor , self . _run_in_thread , future , ctx ) [EOL] [EOL] def _run_in_thread ( self , future , ctx ) : [EOL] loop = self . _local . event_loop [EOL] ret = ctx . run ( loop . run_until_complete , future ) [EOL] return cast ( RetT , ret ) [EOL] [EOL] def new_rwlock ( self ) : [EOL] return _ThreadingReadWriteLock ( ) [EOL] [EOL] def new_event ( self ) : [EOL] return _ThreadingEvent ( ) [EOL] [EOL] [EOL] class ReadWriteLock ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def for_asyncio ( cls ) : [EOL] [docstring] [EOL] return _AsyncioReadWriteLock ( ) [EOL] [EOL] @ classmethod def for_threading ( cls ) : [EOL] [docstring] [EOL] return _ThreadingReadWriteLock ( ) [EOL] [EOL] @ property @ abstractmethod def subsystem ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def read_lock ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def write_lock ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class Event ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def for_asyncio ( cls ) : [EOL] [docstring] [EOL] return _AsyncioEvent ( ) [EOL] [EOL] @ classmethod def for_threading ( cls ) : [EOL] [docstring] [EOL] return _ThreadingEvent ( ) [EOL] [EOL] @ property @ abstractmethod def subsystem ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def or_event ( self , * events ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def is_set ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def set ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def clear ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def wait ( self , * , timeout = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class _AsyncioReadWriteLock ( ReadWriteLock ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _read_lock = _asyncio_Lock ( ) [EOL] self . _write_lock = _asyncio_Lock ( ) [EOL] self . _counter = [number] [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] async def _acquire_read ( self ) : [EOL] async with self . _read_lock : [EOL] self . _counter += [number] [EOL] return self . _counter == [number] [EOL] [EOL] async def _release_read ( self ) : [EOL] async with self . _read_lock : [EOL] self . _counter -= [number] [EOL] return self . _counter == [number] [EOL] [EOL] @ asynccontextmanager async def read_lock ( self ) : [EOL] if await self . _acquire_read ( ) : [EOL] await self . _write_lock . acquire ( ) [EOL] try : [EOL] yield [EOL] finally : [EOL] if await self . _release_read ( ) : [EOL] self . _write_lock . release ( ) [EOL] [EOL] @ asynccontextmanager async def write_lock ( self ) : [EOL] async with self . _write_lock : [EOL] yield [EOL] [EOL] [EOL] class _ThreadingReadWriteLock ( ReadWriteLock ) : [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _read_lock = _threading_Lock ( ) [EOL] self . _write_lock = _threading_Lock ( ) [EOL] self . _counter = [number] [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] def _acquire_read ( self ) : [EOL] with self . _read_lock : [EOL] self . _counter += [number] [EOL] return self . _counter == [number] [EOL] [EOL] def _release_read ( self ) : [EOL] with self . _read_lock : [EOL] self . _counter -= [number] [EOL] return self . _counter == [number] [EOL] [EOL] @ asynccontextmanager async def read_lock ( self ) : [EOL] if self . _acquire_read ( ) : [EOL] self . _write_lock . acquire ( ) [EOL] try : [EOL] yield [EOL] finally : [EOL] if self . _release_read ( ) : [EOL] self . _write_lock . release ( ) [EOL] [EOL] @ asynccontextmanager async def write_lock ( self ) : [EOL] with self . _write_lock : [EOL] yield [EOL] [EOL] [EOL] class FileLock ( ReadWriteLock ) : [comment] [EOL] [docstring] [EOL] [EOL] _DEFAULT_DELAY = ( [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] def __init__ ( self , path , expiration = [number] , read_retry_delay = _DEFAULT_DELAY , write_retry_delay = _DEFAULT_DELAY ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _path = path [EOL] self . _expiration = expiration [EOL] self . _read_retry_delay = read_retry_delay [EOL] self . _write_retry_delay = write_retry_delay [EOL] [EOL] @ property def subsystem ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def _check_lock ( self ) : [EOL] try : [EOL] statinfo = os . stat ( self . _path ) [EOL] except FileNotFoundError : [EOL] return True [EOL] else : [EOL] if time . time ( ) - statinfo . st_mtime >= self . _expiration : [EOL] try : [EOL] os . unlink ( self . _path ) [EOL] except OSError : [EOL] pass [EOL] return True [EOL] return False [EOL] [EOL] def _try_lock ( self ) : [EOL] try : [EOL] with open ( self . _path , [string] ) : [EOL] pass [EOL] except FileExistsError : [EOL] return False [EOL] else : [EOL] return True [EOL] [EOL] def _unlock ( self ) : [EOL] try : [EOL] os . unlink ( self . _path ) [EOL] except OSError : [EOL] pass [EOL] [EOL] @ asynccontextmanager async def read_lock ( self ) : [EOL] if self . _check_lock ( ) : [EOL] yield [EOL] return [EOL] for delay in self . _read_retry_delay : [EOL] await asyncio . sleep ( delay ) [EOL] if not os . path . exists ( self . _path ) : [EOL] yield [EOL] break [EOL] else : [EOL] raise TimeoutError ( ) [EOL] [EOL] @ asynccontextmanager async def write_lock ( self ) : [EOL] if self . _check_lock ( ) and self . _try_lock ( ) : [EOL] try : [EOL] yield [EOL] finally : [EOL] self . _unlock ( ) [EOL] return [EOL] for delay in self . _write_retry_delay : [EOL] await asyncio . sleep ( delay ) [EOL] if self . _try_lock ( ) : [EOL] try : [EOL] yield [EOL] finally : [EOL] self . _unlock ( ) [EOL] break [EOL] else : [EOL] raise TimeoutError ( ) [EOL] [EOL] [EOL] class _AsyncioEvent ( Event ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _event = _asyncio_Event ( ) [EOL] self . _listeners = WeakSet ( ) [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] def or_event ( self , * events ) : [EOL] or_event = _AsyncioEvent ( ) [EOL] self . _listeners . add ( or_event ) [EOL] for event in events : [EOL] event . _listeners . add ( or_event ) [EOL] return or_event [EOL] [EOL] def is_set ( self ) : [EOL] return self . _event . is_set ( ) [EOL] [EOL] def set ( self ) : [EOL] self . _event . set ( ) [EOL] for listener in self . _listeners : [EOL] listener . set ( ) [EOL] [EOL] def clear ( self ) : [EOL] self . _event . clear ( ) [EOL] [EOL] async def wait ( self , * , timeout = None ) : [EOL] task = asyncio . create_task ( self . _event . wait ( ) ) [EOL] try : [EOL] await asyncio . wait_for ( task , timeout ) [EOL] except TimeoutError : [EOL] pass [EOL] [EOL] [EOL] class _ThreadingEvent ( Event ) : [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _event = _threading_Event ( ) [EOL] self . _listeners = WeakSet ( ) [EOL] [EOL] @ property def subsystem ( self ) : [EOL] return [string] [EOL] [EOL] def or_event ( self , * events ) : [EOL] or_event = _ThreadingEvent ( ) [EOL] self . _listeners . add ( or_event ) [EOL] for event in events : [EOL] event . _listeners . add ( or_event ) [EOL] return or_event [EOL] [EOL] def is_set ( self ) : [EOL] return self . _event . is_set ( ) [EOL] [EOL] def set ( self ) : [EOL] self . _event . set ( ) [EOL] for listener in self . _listeners : [EOL] listener . set ( ) [EOL] [EOL] def clear ( self ) : [EOL] self . _event . clear ( ) [EOL] [EOL] async def wait ( self , * , timeout = None ) : [EOL] self . _event . wait ( timeout = timeout ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Subsystem$ 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[concurrent.futures.Executor]$ 0 0 0 0 0 0 $Subsystem$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Subsystem$ 0 0 0 $concurrent.futures.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 $concurrent.futures.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 0 0 0 0 0 0 0 0 $ReadWriteLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 $_AsyncioReadWriteLock$ 0 0 0 0 0 0 0 0 0 0 0 0 $_AsyncioEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $concurrent.futures.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.ThreadPoolExecutor$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $RetT$ 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 0 0 0 $RetT$ 0 0 0 $typing.Awaitable[RetT]$ 0 $contextvars.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $contextvars.Context$ 0 0 0 0 0 0 0 $typing.Awaitable[RetT]$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ThreadingReadWriteLock$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ThreadingEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ReadWriteLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ReadWriteLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncContextManager[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncContextManager[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $EventT$ 0 $EventT$ 0 0 $EventT$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.float$ 0 0 0 $_Delay$ 0 0 0 $_Delay$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $_Delay$ 0 0 0 0 0 $_Delay$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableSet[_AsyncioEvent]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $_AsyncioEvent$ 0 0 0 0 $_AsyncioEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_AsyncioEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableSet[_ThreadingEvent]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $_ThreadingEvent$ 0 0 0 0 $_ThreadingEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ThreadingEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0
[EOL] from typing import List , Mapping , Tuple , Callable , Dict , TypeVar , Iterator [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import TypeVar , Generic , Callable , Iterable , Iterator , Tuple , Mapping , Dict [EOL] [EOL] from pkg_resources import iter_entry_points , DistributionNotFound [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] PluginT = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Plugin ( Generic [ PluginT ] , Iterable [ Tuple [ str , PluginT ] ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , group = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _group = group [EOL] self . _registered = { } [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . registered . items ( ) ) [EOL] [EOL] @ property def registered ( self ) : [EOL] [docstring] [EOL] self . _load ( ) [EOL] return self . _registered [EOL] [EOL] def _load ( self ) : [EOL] if self . _group is not None : [EOL] for entry_point in iter_entry_points ( self . _group ) : [EOL] try : [EOL] plugin = entry_point . load ( ) [EOL] except DistributionNotFound : [EOL] pass [comment] [EOL] else : [EOL] self . add ( entry_point . name , plugin ) [EOL] self . _group = None [EOL] [EOL] def add ( self , name , plugin ) : [EOL] [docstring] [EOL] assert name not in self . _registered , f' [string] { name !r} [string] ' [EOL] self . _registered [ name ] = plugin [EOL] [EOL] def register ( self , name ) : [EOL] [docstring] [EOL] def deco ( plugin ) : [EOL] self . add ( name , plugin ) [EOL] return plugin [EOL] return deco [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . _group !r} [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,PluginT]$ 0 0 0 0 0 0 $typing.Iterator[typing.Tuple[builtins.str,PluginT]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,PluginT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $PluginT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PluginT$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $PluginT$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $PluginT$ 0 0 0 $typing.Callable[[PluginT],PluginT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $PluginT$ 0 $PluginT$ 0 0 0 0 0 0 0 0 0 $PluginT$ 0 0 0 $PluginT$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Type , Tuple , Sequence [EOL] import interfaces [EOL] import typing [EOL] import builtins [EOL] import plugin [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from typing import Type , Optional , Tuple , Sequence [EOL] [EOL] from . interfaces . filter import FilterValueT , FilterCompilerInterface , FilterSetInterface [EOL] from . plugin import Plugin [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] filters = Plugin ( [string] ) [EOL] [EOL] [EOL] class PluginFilterSet ( FilterSetInterface [ FilterValueT ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , plugin_name , value_type ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _plugin_name = plugin_name [EOL] self . _value_type = value_type [EOL] self . _compiler = None [EOL] [EOL] @ property def compiler ( self ) : [EOL] if self . _compiler is None : [EOL] name = self . _plugin_name [EOL] filter_cls = filters . registered [ name ] [EOL] compiler = filter_cls ( ) [EOL] if not issubclass ( compiler . value_type , self . _value_type ) : [EOL] raise TypeError ( f'{ filter_cls } [string] ' f'{ self . _value_type }' ) [EOL] self . _compiler = compiler [EOL] return self . _compiler [EOL] [EOL] [EOL] class SingleFilterSet ( FilterSetInterface [ FilterValueT ] ) : [EOL] [docstring] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] async def put ( self , name , value ) : [EOL] if name == self . name : [EOL] await self . replace_active ( value ) [EOL] [EOL] async def delete ( self , name ) : [EOL] if name == self . name : [EOL] await self . replace_active ( None ) [EOL] else : [EOL] raise KeyError ( name ) [EOL] [EOL] async def rename ( self , before_name , after_name ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] async def clear_active ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] async def set_active ( self , name ) : [EOL] if name != self . name : [EOL] raise KeyError ( name ) [EOL] [EOL] async def get ( self , name ) : [EOL] if name == self . name : [EOL] value = await self . get_active ( ) [EOL] if value is None : [EOL] raise KeyError ( name ) [EOL] else : [EOL] return value [EOL] else : [EOL] raise KeyError ( name ) [EOL] [EOL] async def get_all ( self ) : [EOL] value = await self . get_active ( ) [EOL] if value is None : [EOL] return None , [ ] [EOL] else : [EOL] return self . name , [ self . name ] [EOL] [EOL] async def replace_active ( self , value ) : [EOL] [docstring] [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ abstractmethod async def get_active ( self ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plugin.Plugin[typing.Type[interfaces.filter.FilterCompilerInterface]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Type[interfaces.filter.FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Type[interfaces.filter.FilterValueT]$ 0 0 0 $typing.Optional[interfaces.filter.FilterCompilerInterface[interfaces.filter.FilterValueT]]$ 0 0 0 0 0 0 0 $interfaces.filter.FilterCompilerInterface[interfaces.filter.FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plugin.Plugin[typing.Type[interfaces.filter.FilterCompilerInterface]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $interfaces.filter.FilterValueT$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $interfaces.filter.FilterValueT$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $interfaces.filter.FilterValueT$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[interfaces.filter.FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[interfaces.filter.FilterValueT]$ 0 0 0 0 0 0 0
from typing import List [EOL] import contextvars [EOL] import parsing [EOL] import builtins [EOL] import contextlib [EOL] import concurrent [EOL] import typing [EOL] import proxyprotocol [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] from contextlib import AsyncExitStack [EOL] from contextvars import ContextVar [EOL] [EOL] from proxyprotocol . sock import SocketInfo [EOL] [EOL] from . concurrent import Subsystem [EOL] from . parsing . command import Command [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] subsystem = ContextVar ( [string] , default = Subsystem . for_asyncio ( ) ) [EOL] current_command = ContextVar ( [string] ) [EOL] socket_info = ContextVar ( [string] ) [EOL] language_code = ContextVar ( [string] ) [EOL] connection_exit = ContextVar ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $contextvars.ContextVar[parsing.command.Command]$ 0 0 0 0 0 0 $contextvars.ContextVar[proxyprotocol.sock.SocketInfo]$ 0 0 0 0 0 0 $contextvars.ContextVar[builtins.str]$ 0 0 0 0 0 0 $contextvars.ContextVar[contextlib.AsyncExitStack]$ 0 0 0 0 0 0
from typing import FrozenSet , Mapping , AbstractSet , Set , Dict , Iterable [EOL] import typing [EOL] import parsing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] import enum [EOL] from typing import Iterable , Mapping , AbstractSet , FrozenSet , Dict , Set [EOL] [EOL] from . parsing . specials . flag import Flag , Recent , Wildcard [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _recent_set = frozenset ( { Recent } ) [EOL] [EOL] [EOL] class FlagOp ( enum . Enum ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] REPLACE = enum . auto ( ) [EOL] [EOL] [comment] [EOL] ADD = enum . auto ( ) [EOL] [EOL] [comment] [EOL] DELETE = enum . auto ( ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . name . encode ( [string] ) [EOL] [EOL] def apply ( self , flag_set , operand ) : [EOL] [docstring] [EOL] if self == FlagOp . ADD : [EOL] return frozenset ( flag_set | operand ) [EOL] elif self == FlagOp . DELETE : [EOL] return frozenset ( flag_set - operand ) [EOL] else : [comment] [EOL] return frozenset ( operand ) [EOL] [EOL] [EOL] class PermanentFlags : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , defined ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _defined = frozenset ( defined ) - _recent_set [EOL] [EOL] @ property def defined ( self ) : [EOL] [docstring] [EOL] return self . _defined [EOL] [EOL] def intersect ( self , other ) : [EOL] [docstring] [EOL] if Wildcard in self . _defined : [EOL] return frozenset ( other ) [EOL] else : [EOL] return self . _defined & frozenset ( other ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] return self . intersect ( other ) [EOL] [EOL] [EOL] class SessionFlags : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , defined ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _defined = frozenset ( defined ) - _recent_set [EOL] self . _flags = { } [EOL] self . _recent = set ( ) [EOL] [EOL] @ property def defined ( self ) : [EOL] [docstring] [EOL] return self . _defined [EOL] [EOL] def intersect ( self , other ) : [EOL] [docstring] [EOL] if Wildcard in self . _defined : [EOL] return frozenset ( other ) [EOL] else : [EOL] return self . _defined & frozenset ( other ) [EOL] [EOL] def __and__ ( self , other ) : [EOL] return self . intersect ( other ) [EOL] [EOL] def get ( self , uid ) : [EOL] [docstring] [EOL] recent = _recent_set if uid in self . _recent else frozenset ( ) [EOL] flags = self . _flags . get ( uid ) [EOL] return recent if flags is None else ( flags | recent ) [EOL] [EOL] def remove ( self , uids ) : [EOL] [docstring] [EOL] for uid in uids : [EOL] self . _recent . discard ( uid ) [EOL] self . _flags . pop ( uid , None ) [EOL] [EOL] def update ( self , uid , flag_set , op = FlagOp . REPLACE ) : [EOL] [docstring] [EOL] orig_set = self . _flags . get ( uid , frozenset ( ) ) [EOL] new_flags = op . apply ( orig_set , self & flag_set ) [EOL] if new_flags : [EOL] self . _flags [ uid ] = new_flags [EOL] else : [EOL] self . _flags . pop ( uid , None ) [EOL] return new_flags [EOL] [EOL] def add_recent ( self , uid ) : [EOL] [docstring] [EOL] self . _recent . add ( uid ) [EOL] [EOL] @ property def recent ( self ) : [EOL] [docstring] [EOL] return len ( self . _recent ) [EOL] [EOL] @ property def recent_uids ( self ) : [EOL] [docstring] [EOL] return self . _recent [EOL] [EOL] @ property def flags ( self ) : [EOL] [docstring] [EOL] return self . _flags [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.FrozenSet[parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.flag.Flag]$ 0 0 0 $builtins.int$ 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 $FlagOp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $FlagOp$ 0 0 0 0 0 0 0 $typing.Iterable[parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AbstractSet[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.int,typing.FrozenSet[parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] import pkg_resources [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] __version__ = pkg_resources . require ( __package__ ) [ [number] ] . version [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Sequence [EOL] import interfaces [EOL] import builtins [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] import argparse [EOL] import asyncio [EOL] import logging [EOL] import logging . config [EOL] import os [EOL] from argparse import ArgumentParser , Namespace , ArgumentTypeError [EOL] from contextlib import nullcontext [EOL] from string import Template [EOL] from typing import Type , Sequence , List [EOL] [EOL] from . import __version__ [EOL] from . backend import backends [EOL] from . interfaces . backend import BackendInterface , ServiceInterface [EOL] from . service import services [EOL] [EOL] try : [EOL] import systemd . daemon [comment] [EOL] except ImportError : [EOL] def notify_ready ( ) : [EOL] pass [EOL] else : [EOL] def notify_ready ( ) : [EOL] systemd . daemon . notify ( [string] ) [EOL] [EOL] try : [EOL] from pid import PidFile [comment] [EOL] except ImportError : [EOL] def PidFile ( * args , ** kwargs ) : [EOL] return nullcontext ( ) [EOL] [EOL] try : [EOL] import passlib [comment] [EOL] except ImportError : [EOL] passlib = None [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = _PymapArgumentParser ( description = __doc__ ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , version = [string] + __version__ ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = _get_pwd , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = _get_grp , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , metavar = [string] , help = [string] ) [EOL] if passlib is not None : [EOL] parser . add_argument ( [string] , metavar = [string] , help = [string] ) [EOL] subparsers = parser . add_subparsers ( dest = [string] , required = True , metavar = [string] ) [EOL] [EOL] for backend_name , backend_type in backends : [EOL] subparser = backend_type . add_subparser ( backend_name , subparsers ) [EOL] subparser . set_defaults ( run = backend_type . start ) [EOL] for _ , service_type in services : [EOL] service_type . add_arguments ( parser ) [EOL] parser . set_defaults ( skip_services = [ ] , passlib_cfg = None ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . logging_cfg : [EOL] logging . config . fileConfig ( args . logging_cfg ) [EOL] else : [EOL] logging . basicConfig ( level = logging . WARNING ) [EOL] if args . debug : [EOL] logging . getLogger ( __package__ ) . setLevel ( logging . DEBUG ) [EOL] [EOL] backend_type = backends . registered [ args . backend ] [EOL] service_types = [ service for name , service in services if name not in args . skip_services ] [EOL] [EOL] with PidFile ( force_tmpdir = True ) : [EOL] try : [EOL] return asyncio . run ( run ( args , backend_type , service_types ) , debug = False ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] [EOL] [EOL] async def run ( args , backend_type , service_types ) : [EOL] backend , config = await backend_type . init ( args ) [EOL] config . apply_context ( ) [EOL] [EOL] services = [ svc_type ( backend , config ) for svc_type in service_types ] [EOL] task = await args . run ( backend , services ) [EOL] [EOL] _drop_privileges ( args ) [EOL] notify_ready ( ) [EOL] await task [EOL] [EOL] [EOL] def _get_pwd ( setuid ) : [EOL] from pwd import getpwnam , getpwuid [EOL] try : [EOL] try : [EOL] uid = int ( setuid ) [EOL] except ValueError : [EOL] entry = getpwnam ( setuid ) [EOL] else : [EOL] entry = getpwuid ( uid ) [EOL] except KeyError as exc : [EOL] raise ArgumentTypeError ( f' [string] { setuid }' ) from exc [EOL] else : [EOL] return entry . pw_uid [EOL] [EOL] [EOL] def _get_grp ( setgid ) : [EOL] from grp import getgrnam , getgrgid [EOL] try : [EOL] try : [EOL] gid = int ( setgid ) [EOL] except ValueError : [EOL] entry = getgrnam ( setgid ) [EOL] else : [EOL] entry = getgrgid ( gid ) [EOL] except KeyError as exc : [EOL] raise ArgumentTypeError ( f' [string] { setgid }' ) from exc [EOL] else : [EOL] return entry . gr_gid [EOL] [EOL] [EOL] def _drop_privileges ( args ) : [EOL] if args . set_gid is not None : [EOL] os . setgid ( args . set_gid ) [EOL] if args . set_uid is not None : [EOL] os . setuid ( args . set_uid ) [EOL] [EOL] [EOL] class _PymapArgumentParser ( ArgumentParser ) : [EOL] [EOL] def __init__ ( self , ** extra ) : [EOL] formatter_class = argparse . ArgumentDefaultsHelpFormatter [EOL] super ( ) . __init__ ( fromfile_prefix_chars = [string] , formatter_class = formatter_class , ** extra ) [EOL] [EOL] def convert_arg_line_to_args ( self , arg_line ) : [EOL] try : [EOL] return [ Template ( arg_line ) . substitute ( os . environ ) ] [EOL] except KeyError as exc : [EOL] raise EnvironmentError ( f' [string] { exc . args [ [number] ] }' ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , FrozenSet [EOL] import typing [EOL] import parsing [EOL] import datetime [EOL] from __future__ import annotations [EOL] [EOL] from dataclasses import dataclass , field [EOL] from datetime import datetime [EOL] from typing import Optional , FrozenSet [EOL] [EOL] from . . parsing . specials import Flag , ExtensionOptions [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class AppendMessage : [EOL] [docstring] [EOL] [EOL] literal = ... [EOL] when = None [EOL] flag_set = field ( default_factory = frozenset ) [EOL] options = field ( default_factory = ExtensionOptions . empty ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 $parsing.specials.ExtensionOptions$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Tuple , Any , Dict , Sequence [EOL] import state [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod , ABCMeta [EOL] from typing import Any , Type , TypeVar , Generic , Tuple , Sequence , Dict , List [EOL] [EOL] from . exceptions import NotParseable , UnexpectedType [EOL] from . state import ParsingState [EOL] from . . bytes import rev , Writeable [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] ParseableT = TypeVar ( [string] ) [EOL] [EOL] [EOL] class Params : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , state = None , * , expected = None , list_expected = None , command_name = None , uid = False , charset = None , tag = None , max_append_len = None , allow_continuations = True ) : [EOL] super ( ) . __init__ ( ) [EOL] self . state = state or ParsingState ( ) [EOL] self . expected = expected or [ ] [EOL] self . list_expected = list_expected or [ ] [EOL] self . command_name = command_name [EOL] self . uid = uid [EOL] self . charset = charset [EOL] self . tag = tag or [string] [EOL] self . max_append_len = max_append_len [EOL] self . allow_continuations = allow_continuations [EOL] [EOL] def _set_if_none ( self , kwargs , attr , value ) : [EOL] if value is not None : [EOL] kwargs [ attr ] = value [EOL] else : [EOL] kwargs [ attr ] = getattr ( self , attr ) [EOL] [EOL] def copy ( self , state = None , * , expected = None , list_expected = None , command_name = None , uid = None , charset = None , tag = None , max_append_len = None , allow_continuations = None ) : [EOL] [docstring] [EOL] kwargs = { } [EOL] self . _set_if_none ( kwargs , [string] , state ) [EOL] self . _set_if_none ( kwargs , [string] , expected ) [EOL] self . _set_if_none ( kwargs , [string] , list_expected ) [EOL] self . _set_if_none ( kwargs , [string] , command_name ) [EOL] self . _set_if_none ( kwargs , [string] , uid ) [EOL] self . _set_if_none ( kwargs , [string] , charset ) [EOL] self . _set_if_none ( kwargs , [string] , tag ) [EOL] self . _set_if_none ( kwargs , [string] , max_append_len ) [EOL] self . _set_if_none ( kwargs , [string] , allow_continuations ) [EOL] return Params ( ** kwargs ) [EOL] [EOL] [EOL] class Parseable ( Generic [ ParseableT ] , Writeable , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] _whitespace_pattern = rev . compile ( [string] ) [EOL] _atom_pattern = rev . compile ( [string] ) [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def value ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ classmethod def _whitespace_length ( cls , buf , start = [number] ) : [EOL] match = cls . _whitespace_pattern . match ( buf , start ) [EOL] if match : [EOL] return match . end ( [number] ) - start [EOL] return [number] [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , ( bytes , memoryview ) ) : [EOL] return bytes ( self ) == other [EOL] return NotImplemented [EOL] [EOL] @ classmethod @ abstractmethod def parse ( cls , buf , params ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class ExpectedParseable ( Parseable [ None ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] raise NotImplementedError [EOL] [EOL] @ property def value ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def __bytes__ ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] [docstring] [EOL] for data_type in params . expected : [EOL] try : [EOL] return data_type . parse ( buf , params ) [EOL] except NotParseable : [EOL] pass [EOL] raise UnexpectedType ( buf ) [EOL] [EOL] [EOL] class Space ( Parseable [ int ] ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , length ) : [EOL] super ( ) . __init__ ( ) [EOL] self . length = length [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . length [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] ret = cls . _whitespace_length ( buf ) [EOL] if not ret : [EOL] raise NotParseable ( buf ) [EOL] return cls ( ret ) , buf [ ret : ] [EOL] [EOL] def __bytes__ ( self ) : [EOL] return [string] * self . length [EOL] [EOL] [EOL] class EndLine ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] _pattern = rev . compile ( [string] ) [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , preceding_spaces = [number] , carriage_return = True ) : [EOL] super ( ) . __init__ ( ) [EOL] self . preceding_spaces = preceding_spaces [EOL] self . carriage_return = carriage_return [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return [string] if self . carriage_return else [string] [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] match = cls . _pattern . match ( buf ) [EOL] if not match : [EOL] raise NotParseable ( buf ) [EOL] preceding_spaces = match . start ( [number] ) [EOL] carriage_return = bool ( match . group ( [number] ) ) [EOL] return cls ( preceding_spaces , carriage_return ) , buf [ match . end ( [number] ) : ] [EOL] [EOL] def __bytes__ ( self ) : [EOL] return [string] * self . preceding_spaces + self . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $Params$ 0 0 0 $state.ParsingState$ 0 0 0 0 0 $typing.Sequence[typing.Type[Parseable]]$ 0 0 0 $typing.Sequence[typing.Type[Parseable]]$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $state.ParsingState$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Sequence[typing.Type[Parseable]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Sequence[typing.Type[Parseable]]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $ParseableT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.memoryview$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Parseable,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Parseable,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Space,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[EndLine,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] from __future__ import annotations [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def _modified_b64encode ( src ) : [EOL] [comment] [EOL] [comment] [EOL] src_utf7 = src . encode ( [string] ) [EOL] return src_utf7 [ [number] : - [number] ] . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def _modified_b64decode ( src ) : [EOL] [comment] [EOL] [comment] [EOL] src_utf7 = [string] % src . replace ( [string] , [string] ) [EOL] return src_utf7 . decode ( [string] ) [EOL] [EOL] [EOL] def modutf7_encode ( data ) : [EOL] [docstring] [EOL] ret = bytearray ( ) [EOL] is_usascii = True [EOL] encode_start = None [EOL] for i , symbol in enumerate ( data ) : [EOL] charpoint = ord ( symbol ) [EOL] if is_usascii : [EOL] if charpoint == [number] : [EOL] ret . extend ( [string] ) [EOL] elif [number] <= charpoint <= [number] : [EOL] ret . append ( charpoint ) [EOL] else : [EOL] encode_start = i [EOL] is_usascii = False [EOL] else : [EOL] if [number] <= charpoint <= [number] : [EOL] to_encode = data [ encode_start : i ] [EOL] encoded = _modified_b64encode ( to_encode ) [EOL] ret . append ( [number] ) [EOL] ret . extend ( encoded ) [EOL] ret . extend ( ( [number] , charpoint ) ) [EOL] is_usascii = True [EOL] if not is_usascii : [EOL] to_encode = data [ encode_start : ] [EOL] encoded = _modified_b64encode ( to_encode ) [EOL] ret . append ( [number] ) [EOL] ret . extend ( encoded ) [EOL] ret . append ( [number] ) [EOL] return bytes ( ret ) [EOL] [EOL] [EOL] def modutf7_decode ( data ) : [EOL] [docstring] [EOL] parts = [ ] [EOL] is_usascii = True [EOL] buf = memoryview ( data ) [EOL] while buf : [EOL] byte = buf [ [number] ] [EOL] if is_usascii : [EOL] if buf [ [number] : [number] ] == [string] : [EOL] parts . append ( [string] ) [EOL] buf = buf [ [number] : ] [EOL] elif byte == [number] : [EOL] is_usascii = False [EOL] buf = buf [ [number] : ] [EOL] else : [EOL] parts . append ( chr ( byte ) ) [EOL] buf = buf [ [number] : ] [EOL] else : [EOL] for i , byte in enumerate ( buf ) : [EOL] if byte == [number] : [EOL] to_decode = buf [ : i ] . tobytes ( ) [EOL] decoded = _modified_b64decode ( to_decode ) [EOL] parts . append ( decoded ) [EOL] buf = buf [ i + [number] : ] [EOL] is_usascii = True [EOL] break [EOL] if not is_usascii : [EOL] to_decode = buf . tobytes ( ) [EOL] decoded = _modified_b64decode ( to_decode ) [EOL] parts . append ( decoded ) [EOL] return [string] . join ( parts ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import InvalidCommand [EOL] from typing import Optional , List , Type , Tuple , Dict , Collection [EOL] import typing [EOL] import command [EOL] import builtins [EOL] import exceptions [EOL] from __future__ import annotations [EOL] [EOL] from typing import Optional , Type , Tuple , Dict , List , Collection [EOL] [EOL] from . import Space , Params [EOL] from . command import Command [EOL] from . command . any import CapabilityCommand , LogoutCommand , NoOpCommand [EOL] from . command . auth import AppendCommand , CreateCommand , DeleteCommand , ExamineCommand , ListCommand , LSubCommand , RenameCommand , SelectCommand , StatusCommand , SubscribeCommand , UnsubscribeCommand [EOL] from . command . nonauth import AuthenticateCommand , LoginCommand , StartTLSCommand [EOL] from . command . select import CheckCommand , CloseCommand , ExpungeCommand , CopyCommand , MoveCommand , FetchCommand , StoreCommand , SearchCommand , UidCommand , UidCopyCommand , UidMoveCommand , UidExpungeCommand , UidFetchCommand , UidSearchCommand , UidStoreCommand , IdleCommand [EOL] from . exceptions import NotParseable [EOL] from . primitives import Atom [EOL] from . specials import Tag [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] builtin_commands = [ CapabilityCommand , LogoutCommand , NoOpCommand , AppendCommand , CreateCommand , DeleteCommand , ExamineCommand , ListCommand , LSubCommand , RenameCommand , SelectCommand , StatusCommand , SubscribeCommand , UnsubscribeCommand , AuthenticateCommand , LoginCommand , StartTLSCommand , CheckCommand , CloseCommand , ExpungeCommand , CopyCommand , MoveCommand , FetchCommand , StoreCommand , SearchCommand , UidCommand , UidCopyCommand , UidMoveCommand , UidExpungeCommand , UidFetchCommand , UidSearchCommand , UidStoreCommand , IdleCommand ] [EOL] [EOL] [EOL] class InvalidCommand ( Command ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , params , parse_exc , command = None , command_type = None ) : [EOL] super ( ) . __init__ ( params . tag ) [EOL] self . _parse_exc = parse_exc [EOL] self . _command = command [EOL] self . _command_type = command_type [EOL] [EOL] @ property def value ( self ) : [EOL] return self . _command or [string] [EOL] [EOL] @ property def message ( self ) : [EOL] [docstring] [EOL] if not self . command_name : [EOL] return [string] [EOL] elif not self . command_type : [EOL] return [string] % ( self . command_name , ) [EOL] else : [EOL] return [string] % ( self . command_name , ) [EOL] [EOL] @ property def command_name ( self ) : [EOL] [docstring] [EOL] return self . _command [EOL] [EOL] @ property def command_type ( self ) : [EOL] [docstring] [EOL] return self . _command_type [EOL] [EOL] @ property def parse_exc ( self ) : [EOL] [docstring] [EOL] return self . _parse_exc [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] class Commands : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . commands = { } [EOL] self . _load_commands ( ) [EOL] [EOL] def _load_commands ( self ) : [EOL] for cmd in builtin_commands : [EOL] self . register ( cmd ) [EOL] [EOL] def register ( self , cmd ) : [EOL] [docstring] [EOL] self . commands [ cmd . command ] = cmd [EOL] [EOL] def deregister ( self , name ) : [EOL] [docstring] [EOL] self . commands . pop ( name . upper ( ) , None ) [EOL] [EOL] def parse ( self , buf , params ) : [EOL] [docstring] [EOL] try : [EOL] tag , buf = Tag . parse ( buf , params ) [EOL] except NotParseable as exc : [EOL] return InvalidCommand ( params , exc ) , buf [ [number] : [number] ] [EOL] else : [EOL] params = params . copy ( tag = tag . value ) [EOL] cmd_parts = [ ] [EOL] while True : [EOL] try : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] atom , buf = Atom . parse ( buf , params ) [EOL] cmd_parts . append ( atom . value . upper ( ) ) [EOL] except NotParseable as exc : [EOL] return InvalidCommand ( params , exc ) , buf [ [number] : [number] ] [EOL] command = [string] . join ( cmd_parts ) [EOL] cmd_type = self . commands . get ( command ) [EOL] if not cmd_type : [EOL] return InvalidCommand ( params , None , command ) , buf [ [number] : [number] ] [EOL] elif not cmd_type . compound : [EOL] break [EOL] params = params . copy ( command_name = command ) [EOL] try : [EOL] return cmd_type . parse ( buf , params ) [EOL] except NotParseable as exc : [EOL] return InvalidCommand ( params , exc , command , cmd_type ) , buf [ [number] : [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Params$ 0 $typing.Optional[exceptions.NotParseable]$ 0 $typing.Optional[builtins.bytes]$ 0 0 0 $typing.Optional[typing.Type[InvalidCommand.command.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 $typing.Optional[exceptions.NotParseable]$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 $typing.Optional[typing.Type[InvalidCommand.command.Command]]$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Type[InvalidCommand.command.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[exceptions.NotParseable]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[InvalidCommand,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Type[command.Command]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Type[command.Command]$ 0 0 0 0 0 0 0 0 0 $typing.Type[command.Command]$ 0 0 0 0 $typing.Type[command.Command]$ 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[command.Command,builtins.memoryview]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Tuple , Optional [EOL] [EOL] from . import AString [EOL] from . . import Params , Parseable [EOL] from . . modutf7 import modutf7_encode , modutf7_decode [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class Mailbox ( Parseable [ str ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , mailbox ) : [EOL] super ( ) . __init__ ( ) [EOL] if mailbox . upper ( ) == [string] : [EOL] self . mailbox = [string] [EOL] self . _raw = [string] [EOL] else : [EOL] self . mailbox = mailbox [EOL] self . _raw = None [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . mailbox [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] atom , buf = AString . parse ( buf , params ) [EOL] mailbox = atom . value [EOL] if mailbox . upper ( ) == [string] : [EOL] return cls ( [string] ) , buf [EOL] return cls ( modutf7_decode ( mailbox ) ) , buf [EOL] [EOL] def __bytes__ ( self ) : [EOL] if self . _raw is not None : [EOL] return self . _raw [EOL] self . _raw = raw = bytes ( AString ( modutf7_encode ( self . value ) ) ) [EOL] return raw [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Mailbox,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , List , Mapping , Tuple , Iterable [EOL] import typing [EOL] import builtins [EOL] import primitives [EOL] from __future__ import annotations [EOL] [EOL] import re [EOL] from typing import Tuple , Optional , List , Mapping , Iterable [EOL] [EOL] from . import AString , SequenceSet [EOL] from . . import Params , Parseable [EOL] from . . exceptions import NotParseable [EOL] from . . primitives import Number , ListP [EOL] from . . . bytes import BytesFormat , rev [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class ExtensionOption ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] _opt_pattern = rev . compile ( [string] ) [EOL] [EOL] def __init__ ( self , option , arg ) : [EOL] super ( ) . __init__ ( ) [EOL] self . option = option [EOL] self . arg = arg [EOL] self . _raw_arg = None [EOL] [EOL] @ property def value ( self ) : [EOL] return self . option [EOL] [EOL] def __bytes__ ( self ) : [EOL] if self . arg . value : [EOL] return BytesFormat ( [string] ) % ( self . option , self . raw_arg ) [EOL] else : [EOL] return self . option [EOL] [EOL] @ property def raw_arg ( self ) : [EOL] if self . _raw_arg is None : [EOL] if not self . arg : [EOL] self . _raw_arg = [string] [EOL] elif len ( self . arg ) == [number] : [EOL] arg_0 = self . arg . value [ [number] ] [EOL] if isinstance ( arg_0 , ( Number , SequenceSet ) ) : [EOL] self . _raw_arg = bytes ( arg_0 ) [EOL] else : [EOL] self . _raw_arg = bytes ( self . arg ) [EOL] else : [EOL] self . _raw_arg = bytes ( self . arg ) [EOL] return self . _raw_arg [EOL] [EOL] @ classmethod def _parse_arg ( cls , buf , params ) : [EOL] try : [EOL] num , buf = Number . parse ( buf , params ) [EOL] except NotParseable : [EOL] pass [EOL] else : [EOL] arg = ListP ( [ num ] ) [EOL] return arg , buf [EOL] try : [EOL] seq_set , buf = SequenceSet . parse ( buf , params ) [EOL] except NotParseable : [EOL] pass [EOL] else : [EOL] arg = ListP ( [ seq_set ] ) [EOL] return arg , buf [EOL] try : [EOL] params_copy = params . copy ( list_expected = [ AString , ListP ] ) [EOL] return ListP . parse ( buf , params_copy ) [EOL] except NotParseable : [EOL] pass [EOL] return ListP ( [ ] ) , buf [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] start = cls . _whitespace_length ( buf ) [EOL] match = cls . _opt_pattern . match ( buf , start ) [EOL] if not match : [EOL] raise NotParseable ( buf [ start : ] ) [EOL] option = match . group ( [number] ) . upper ( ) [EOL] buf = buf [ match . end ( [number] ) : ] [EOL] arg , buf = cls . _parse_arg ( buf , params ) [EOL] return cls ( option , arg ) , buf [EOL] [EOL] [EOL] class ExtensionOptions ( Parseable [ Mapping [ bytes , ListP ] ] ) : [EOL] [docstring] [EOL] [EOL] _opt_pattern = re . compile ( [string] ) [EOL] _empty = None [EOL] [EOL] def __init__ ( self , options ) : [EOL] super ( ) . __init__ ( ) [EOL] self . options = { opt . option : opt . arg for opt in options } [EOL] self . _raw = None [EOL] [EOL] @ classmethod def empty ( cls ) : [EOL] [docstring] [EOL] if cls . _empty is None : [EOL] cls . _empty = ExtensionOptions ( { } ) [EOL] return cls . _empty [EOL] [EOL] @ property def value ( self ) : [EOL] return self . options [EOL] [EOL] def has ( self , option ) : [EOL] return option in self . options [EOL] [EOL] def get ( self , option ) : [EOL] return self . options . get ( option , None ) [EOL] [EOL] def __bool__ ( self ) : [EOL] return bool ( self . options ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . options ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] if self . _raw is None : [EOL] parts = [ ExtensionOption ( option , arg ) for option , arg in sorted ( self . options . items ( ) ) ] [EOL] self . _raw = [string] + BytesFormat ( [string] ) . join ( parts ) + [string] [EOL] return self . _raw [EOL] [EOL] @ classmethod def _parse_paren ( cls , buf , paren ) : [EOL] start = cls . _whitespace_length ( buf ) [EOL] if buf [ start : start + [number] ] != paren : [EOL] raise NotParseable ( buf ) [EOL] return buf [ start + [number] : ] [EOL] [EOL] @ classmethod def _parse ( cls , buf , params ) : [EOL] buf = cls . _parse_paren ( buf , [string] ) [EOL] result = [ ] [EOL] while True : [EOL] try : [EOL] option , buf = ExtensionOption . parse ( buf , params ) [EOL] except NotParseable : [EOL] break [EOL] else : [EOL] result . append ( option ) [EOL] buf = cls . _parse_paren ( buf , [string] ) [EOL] return cls ( result ) , buf [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] try : [EOL] return cls . _parse ( buf , params ) [EOL] except NotParseable : [EOL] return cls . empty ( ) , buf [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[primitives.ListP,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[ExtensionOption,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ExtensionOptions]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Mapping[builtins.bytes,primitives.ListP]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.bytes,primitives.ListP]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.bytes,primitives.ListP]$ 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 $ExtensionOptions$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.bytes,primitives.ListP]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Optional[primitives.ListP]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 $builtins.memoryview$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.memoryview$ 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[ExtensionOptions,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ExtensionOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ExtensionOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ExtensionOption]$ 0 0 0 0 0 0 0 0 $typing.Tuple[ExtensionOptions,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0
[EOL] from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Tuple [EOL] [EOL] from . . import Params , Parseable [EOL] from . . primitives import String , QuotedString [EOL] from . . . bytes import rev [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class AString ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] _pattern = rev . compile ( [string] ) [EOL] [EOL] def __init__ ( self , string , raw = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . string = string [EOL] self . _raw = raw [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . string [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] start = cls . _whitespace_length ( buf ) [EOL] match = cls . _pattern . match ( buf , start ) [EOL] if match : [EOL] buf = buf [ match . end ( [number] ) : ] [EOL] return cls ( match . group ( [number] ) , match . group ( [number] ) ) , buf [EOL] string , buf = String . parse ( buf , params ) [EOL] return cls ( string . value , bytes ( string ) ) , buf [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , AString ) : [EOL] return self . string == other . string [EOL] return super ( ) . __eq__ ( other ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] if self . _raw is None : [EOL] match = self . _pattern . fullmatch ( self . value ) [EOL] if match : [EOL] self . _raw = self . value [EOL] else : [EOL] self . _raw = bytes ( QuotedString ( self . value ) ) [EOL] return self . _raw [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[AString,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , AnyStr , Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import binascii [EOL] import random as _random [EOL] from typing import Optional , Tuple , AnyStr [EOL] [EOL] from . . import Params , Parseable [EOL] from . . exceptions import NotParseable [EOL] from . . . bytes import rev [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class ObjectId ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] _pattern = rev . compile ( [string] ) [EOL] [EOL] def __init__ ( self , object_id = None ) : [EOL] super ( ) . __init__ ( ) [EOL] if object_id == [string] : [EOL] raise ValueError ( object_id ) [EOL] self . object_id = object_id [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] if self . object_id is None : [EOL] raise ValueError ( self . object_id ) [EOL] return self . object_id [EOL] [EOL] @ property def parens ( self ) : [EOL] [docstring] [EOL] return [string] % ( self . value , ) [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] start = cls . _whitespace_length ( buf ) [EOL] match = cls . _pattern . match ( buf , start ) [EOL] if not match : [EOL] raise NotParseable ( buf ) [EOL] return cls ( match . group ( [number] ) ) , buf [ match . end ( [number] ) : ] [EOL] [EOL] @ classmethod def new ( cls , prefix , digest ) : [EOL] [docstring] [EOL] return cls ( prefix + binascii . hexlify ( digest ) ) [EOL] [EOL] @ classmethod def new_mailbox_id ( cls , digest ) : [EOL] [docstring] [EOL] return cls . new ( [string] , digest ) [EOL] [EOL] @ classmethod def new_email_id ( cls , digest ) : [EOL] [docstring] [EOL] return cls . new ( [string] , digest ) [EOL] [EOL] @ classmethod def new_thread_id ( cls , digest ) : [EOL] [docstring] [EOL] return cls . new ( [string] , digest ) [EOL] [EOL] @ classmethod def random ( cls , prefix ) : [EOL] [docstring] [EOL] return cls ( [string] % ( prefix , _random . getrandbits ( [number] ) ) ) [EOL] [EOL] @ classmethod def random_mailbox_id ( cls ) : [EOL] [docstring] [EOL] return cls . random ( [string] ) [EOL] [EOL] @ classmethod def random_email_id ( cls ) : [EOL] [docstring] [EOL] return cls . random ( [string] ) [EOL] [EOL] @ classmethod def random_thread_id ( cls ) : [EOL] [docstring] [EOL] return cls . random ( [string] ) [EOL] [EOL] @ classmethod def maybe ( cls , value ) : [EOL] [docstring] [EOL] if not value : [EOL] return cls ( None ) [EOL] elif isinstance ( value , str ) : [EOL] return cls ( value . encode ( [string] , [string] ) ) [EOL] else : [EOL] return cls ( value ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , ObjectId ) : [EOL] return self . object_id == other . object_id [EOL] elif isinstance ( other , bytes ) : [EOL] return self . object_id == other [EOL] return super ( ) . __eq__ ( other ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . object_id ) [EOL] [EOL] def __str__ ( self ) : [EOL] try : [EOL] return self . parens . decode ( [string] ) [EOL] except ValueError : [EOL] return [string] [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[ObjectId,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $ObjectId$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $ObjectId$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $ObjectId$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ObjectId$ 0 0 0 $typing.Optional[typing.AnyStr]$ 0 0 0 0 0 0 0 $typing.Optional[typing.AnyStr]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.AnyStr]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.AnyStr]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.AnyStr]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Tuple [EOL] [EOL] from . . import Params , Parseable , Space [EOL] from . . exceptions import NotParseable , InvalidContent [EOL] from . . primitives import Atom [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class StatusAttribute ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] valid_statuses = { [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] def __init__ ( self , status ) : [EOL] super ( ) . __init__ ( ) [EOL] status = status . upper ( ) [EOL] if status not in self . valid_statuses : [EOL] raise ValueError ( status ) [EOL] self . status = status [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . status [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] try : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] except NotParseable : [EOL] pass [EOL] atom , after = Atom . parse ( buf , params ) [EOL] try : [EOL] return cls ( atom . value ) , after [EOL] except ValueError : [EOL] raise InvalidContent ( buf ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . value ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , StatusAttribute ) : [EOL] return self . value == other . value [EOL] return super ( ) . __eq__ ( other ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[StatusAttribute,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Tuple [EOL] [EOL] from . . import Params , Parseable [EOL] from . . exceptions import NotParseable [EOL] from . . . bytes import rev [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class Tag ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] _pattern = rev . compile ( [string] [string] ) [EOL] [EOL] def __init__ ( self , tag ) : [EOL] super ( ) . __init__ ( ) [EOL] self . tag = tag [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . tag [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] start = cls . _whitespace_length ( buf ) [EOL] match = cls . _pattern . match ( buf , start ) [EOL] if not match : [EOL] raise NotParseable ( buf ) [EOL] return cls ( match . group ( [number] ) ) , buf [ match . end ( [number] ) : ] [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Tag,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] from . astring import AString [EOL] from . datetime_ import DateTime [EOL] from . fetchattr import FetchRequirement , FetchAttribute , FetchValue [EOL] from . flag import Flag [EOL] from . mailbox import Mailbox [EOL] from . objectid import ObjectId [EOL] from . searchkey import SearchKey [EOL] from . sequenceset import SequenceSet [EOL] from . statusattr import StatusAttribute [EOL] from . options import ExtensionOption , ExtensionOptions [EOL] from . tag import Tag [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Union , FrozenSet , Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from functools import total_ordering [EOL] from typing import Tuple , FrozenSet , Union [EOL] [EOL] from . . import Params , Parseable , Space [EOL] from . . exceptions import NotParseable [EOL] from . . primitives import Atom [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ total_ordering class Flag ( Parseable [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] super ( ) . __init__ ( ) [EOL] if isinstance ( value , bytes ) : [EOL] value_bytes = value [EOL] else : [EOL] value_bytes = bytes ( value , [string] ) [EOL] self . _value = self . _capitalize ( value_bytes ) [EOL] self . _hash = hash ( self . _value ) [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . _value [EOL] [EOL] @ property def is_system ( self ) : [EOL] [docstring] [EOL] return self . value . startswith ( [string] ) [EOL] [EOL] @ classmethod def _capitalize ( cls , value ) : [EOL] if value . startswith ( [string] ) : [EOL] return [string] + value [ [number] : ] . capitalize ( ) [EOL] return value [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Flag ) : [EOL] return self . _value == other . _value [EOL] elif isinstance ( other , bytes ) : [EOL] return self . _value == self . _capitalize ( other ) [EOL] return super ( ) . __eq__ ( other ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] if isinstance ( other , Flag ) : [EOL] other_bytes = bytes ( other ) [EOL] elif isinstance ( other , bytes ) : [EOL] other_bytes = self . _capitalize ( other ) [EOL] else : [EOL] return NotImplemented [EOL] if self . is_system and not other_bytes . startswith ( [string] ) : [EOL] return True [EOL] elif not self . is_system and other_bytes . startswith ( [string] ) : [EOL] return False [EOL] return bytes ( self ) < other_bytes [EOL] [EOL] def __hash__ ( self ) : [EOL] return self . _hash [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( type ( self ) . __name__ , bytes ( self ) ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . value [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value . decode ( [string] ) [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] try : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] except NotParseable : [EOL] pass [EOL] if buf : [EOL] if buf [ [number] ] == [number] : [EOL] atom , buf = Atom . parse ( buf [ [number] : ] , params ) [EOL] return cls ( [string] + atom . value ) , buf [EOL] else : [EOL] atom , buf = Atom . parse ( buf , params ) [EOL] return cls ( atom . value ) , buf [EOL] raise NotParseable ( buf ) [EOL] [EOL] [EOL] def get_system_flags ( ) : [EOL] [docstring] [EOL] return frozenset ( { Seen , Recent , Deleted , Flagged , Answered , Draft } ) [EOL] [EOL] [EOL] [comment] [EOL] Seen = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Recent = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Deleted = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Flagged = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Answered = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Draft = Flag ( [string] ) [EOL] [EOL] [comment] [EOL] Wildcard = Flag ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Flag,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , SupportsBytes , Union , List , Mapping , Any , Sequence [EOL] import bytes [EOL] import builtins [EOL] import email [EOL] import primitives [EOL] import specials [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from email . headerregistry import Address , AddressHeader , SingleAddressHeader , UnstructuredHeader , DateHeader , ContentDispositionHeader , ContentTransferEncodingHeader [EOL] from itertools import chain [EOL] from typing import Any , SupportsBytes , Optional , Mapping , Sequence , Union , List [EOL] [EOL] from . . primitives import ListP , Nil , Number , String [EOL] from . . specials import DateTime [EOL] from . . . bytes import Writeable , WriteStream [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] _CTEHeader = ContentTransferEncodingHeader [EOL] [EOL] [EOL] class _Concatenated ( Writeable ) : [EOL] [EOL] def __init__ ( self , parts ) : [EOL] super ( ) . __init__ ( ) [EOL] self . parts = parts [EOL] [EOL] def write ( self , writer ) : [EOL] for part in self . parts : [EOL] writer . write ( bytes ( part ) ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return [string] . join ( [ bytes ( part ) for part in self . parts ] ) [EOL] [EOL] [EOL] class _AddressList ( Writeable ) : [EOL] [EOL] def __init__ ( self , headers ) : [EOL] super ( ) . __init__ ( ) [EOL] self . headers = headers or [ ] [EOL] [EOL] @ classmethod def _parse ( cls , address ) : [EOL] realname = String . build ( address . display_name ) [EOL] localpart = String . build ( address . username ) [EOL] domain = String . build ( address . domain ) [EOL] return ListP ( [ realname , Nil ( ) , localpart , domain ] ) [EOL] [EOL] @ property def _value ( self ) : [EOL] if self . headers : [EOL] addresses = [ ] [EOL] for header in self . headers : [EOL] if isinstance ( header , SingleAddressHeader ) : [EOL] addresses . append ( header . address ) [EOL] else : [EOL] addresses . extend ( header . addresses ) [EOL] return ListP ( [ self . _parse ( address ) for address in addresses ] ) [EOL] else : [EOL] return Nil ( ) [EOL] [EOL] def write ( self , writer ) : [EOL] self . _value . write ( writer ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( self . _value ) [EOL] [EOL] [EOL] class _ParamsList ( Writeable ) : [EOL] [EOL] def __init__ ( self , params ) : [EOL] super ( ) . __init__ ( ) [EOL] self . params = params [EOL] [EOL] @ property def _value ( self ) : [EOL] if self . params : [EOL] values = [ ( String . build ( key ) , String . build ( value ) ) for key , value in self . params . items ( ) ] [EOL] return ListP ( chain . from_iterable ( values ) ) [EOL] else : [EOL] return Nil ( ) [EOL] [EOL] def write ( self , writer ) : [EOL] self . _value . write ( writer ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( self . _value ) [EOL] [EOL] [EOL] class EnvelopeStructure ( Writeable ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , date , subject , from_ , sender , reply_to , to , cc , bcc , in_reply_to , message_id ) : [EOL] super ( ) . __init__ ( ) [EOL] self . date = date [EOL] self . subject = subject [EOL] self . from_ = from_ [EOL] self . sender = sender [EOL] self . reply_to = reply_to [EOL] self . to = to [EOL] self . cc = cc [EOL] self . bcc = bcc [EOL] self . in_reply_to = in_reply_to [EOL] self . message_id = message_id [EOL] [EOL] @ classmethod def empty ( cls ) : [EOL] [docstring] [EOL] return _EmptyEnvelopeStructure ( ) [EOL] [EOL] def _addresses ( self , headers , fallback = None ) : [EOL] if not headers and fallback : [EOL] return self . _addresses ( fallback ) [EOL] return _AddressList ( headers ) [EOL] [EOL] @ property def _value ( self ) : [EOL] datetime = DateTime ( self . date . datetime ) if self . date else Nil ( ) [EOL] return ListP ( [ datetime , String . build ( self . subject ) , self . _addresses ( self . from_ ) , self . _addresses ( self . sender , self . from_ ) , self . _addresses ( self . reply_to , self . from_ ) , self . _addresses ( self . to ) , self . _addresses ( self . cc ) , self . _addresses ( self . bcc ) , String . build ( self . in_reply_to ) , String . build ( self . message_id ) ] ) [EOL] [EOL] def write ( self , writer ) : [EOL] self . _value . write ( writer ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( self . _value ) [EOL] [EOL] [EOL] class BodyStructure ( Writeable ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , maintype , subtype , content_type_params , content_disposition , content_language , content_location ) : [EOL] super ( ) . __init__ ( ) [EOL] self . maintype = maintype [EOL] self . subtype = subtype [EOL] self . content_type_params = content_type_params [EOL] self . content_disposition = content_disposition [EOL] self . content_language = content_language [EOL] self . content_location = content_location [EOL] [EOL] @ classmethod def empty ( cls ) : [EOL] [docstring] [EOL] return _EmptyBodyStructure ( ) [EOL] [EOL] @ property def _value ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def write ( self , writer ) : [EOL] self . _value . write ( writer ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( self . _value ) [EOL] [EOL] @ property def extended ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class MultipartBodyStructure ( BodyStructure ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , subtype , content_type_params , content_disposition , content_language , content_location , parts ) : [EOL] super ( ) . __init__ ( [string] , subtype , content_type_params , content_disposition , content_language , content_location ) [EOL] self . parts = parts [EOL] [EOL] @ property def _value ( self ) : [EOL] return ListP ( [ _Concatenated ( self . parts ) , String . build ( self . subtype ) ] ) [EOL] [EOL] @ property def extended ( self ) : [EOL] [docstring] [EOL] parts = [ part . extended for part in self . parts ] [EOL] return ListP ( [ _Concatenated ( parts ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_disposition ) , String . build ( self . content_language ) , String . build ( self . content_location ) ] ) [EOL] [EOL] [EOL] class ContentBodyStructure ( BodyStructure ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , maintype , subtype , content_type_params , content_disposition , content_language , content_location , content_id , content_description , content_transfer_encoding , body_md5 , size ) : [EOL] super ( ) . __init__ ( maintype , subtype , content_type_params , content_disposition , content_language , content_location ) [EOL] self . content_id = content_id [EOL] self . content_description = content_description [EOL] self . content_transfer_encoding = content_transfer_encoding [EOL] self . body_md5 = body_md5 [EOL] self . size = size [EOL] [EOL] @ property def _value ( self ) : [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) ] ) [EOL] [EOL] @ property def extended ( self ) : [EOL] [docstring] [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) , String . build ( self . body_md5 ) , String . build ( self . content_disposition ) , String . build ( self . content_language ) , String . build ( self . content_location ) ] ) [EOL] [EOL] [EOL] class TextBodyStructure ( ContentBodyStructure ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , subtype , content_type_params , content_disposition , content_language , content_location , content_id , content_description , content_transfer_encoding , body_md5 , size , lines ) : [EOL] super ( ) . __init__ ( [string] , subtype , content_type_params , content_disposition , content_language , content_location , content_id , content_description , content_transfer_encoding , body_md5 , size ) [EOL] self . lines = lines [EOL] [EOL] @ property def _value ( self ) : [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) , Number ( self . lines ) ] ) [EOL] [EOL] @ property def extended ( self ) : [EOL] [docstring] [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) , Number ( self . lines ) , String . build ( self . body_md5 ) , String . build ( self . content_disposition ) , String . build ( self . content_language ) , String . build ( self . content_location ) ] ) [EOL] [EOL] [EOL] class MessageBodyStructure ( ContentBodyStructure ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , content_type_params , content_disposition , content_language , content_location , content_id , content_description , content_transfer_encoding , body_md5 , size , lines , envelope_structure , body_structure ) : [EOL] super ( ) . __init__ ( [string] , [string] , content_type_params , content_disposition , content_language , content_location , content_id , content_description , content_transfer_encoding , body_md5 , size ) [EOL] self . lines = lines [EOL] self . envelope_structure = envelope_structure [EOL] self . body_structure = body_structure [EOL] [EOL] @ property def _value ( self ) : [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) , self . envelope_structure , self . body_structure , Number ( self . lines ) ] ) [EOL] [EOL] @ property def extended ( self ) : [EOL] [docstring] [EOL] return ListP ( [ String . build ( self . maintype ) , String . build ( self . subtype ) , _ParamsList ( self . content_type_params ) , String . build ( self . content_id ) , String . build ( self . content_description ) , String . build ( self . content_transfer_encoding , fallback = [string] ) , Number ( self . size ) , self . envelope_structure , self . body_structure . extended , Number ( self . lines ) , String . build ( self . body_md5 ) , String . build ( self . content_disposition ) , String . build ( self . content_language ) , String . build ( self . content_location ) ] ) [EOL] [EOL] [EOL] class _EmptyEnvelopeStructure ( EnvelopeStructure ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( None , None , None , None , None , None , None , None , None , None ) [EOL] [EOL] [EOL] class _EmptyBodyStructure ( TextBodyStructure ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] , None , None , None , None , None , None , None , None , [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[email.headerregistry.AddressHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[email.headerregistry.AddressHeader]$ 0 $typing.Sequence[email.headerregistry.AddressHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 $email.headerregistry.Address$ 0 0 0 0 0 0 0 0 0 $email.headerregistry.Address$ 0 0 0 0 0 0 0 0 0 0 $email.headerregistry.Address$ 0 0 0 0 0 0 0 0 0 0 $email.headerregistry.Address$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[email.headerregistry.Address]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[email.headerregistry.Address]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[email.headerregistry.Address]$ 0 0 0 0 0 $typing.List[email.headerregistry.Address]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[email.headerregistry.Address]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $EnvelopeStructure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.SupportsBytes$ 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Union[specials.DateTime,primitives.Nil]$ 0 0 0 0 0 0 0 $typing.Union[specials.DateTime,primitives.Nil]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[specials.DateTime,primitives.Nil]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BodyStructure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[_CTEHeader]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[_CTEHeader]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[_CTEHeader]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Mapping[builtins.str,typing.Any]]$ 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 $typing.Optional[_CTEHeader]$ 0 $typing.Optional[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Iterable , Tuple , Sequence [EOL] import typing [EOL] import builtins [EOL] import specials [EOL] import bytes [EOL] from __future__ import annotations [EOL] [EOL] from typing import Iterable , Optional , Sequence , Tuple [EOL] [EOL] from . import ResponseCode [EOL] from . . primitives import ListP [EOL] from . . specials import SequenceSet , ObjectId [EOL] from . . . bytes import MaybeBytes , BytesFormat [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Capability ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , server_capabilities ) : [EOL] super ( ) . __init__ ( ) [EOL] self . capabilities = [ bytes ( cap ) for cap in server_capabilities ] [EOL] self . _raw = None [EOL] [EOL] def __contains__ ( self , capability ) : [EOL] return capability in self . capabilities [EOL] [EOL] @ property def string ( self ) : [EOL] [docstring] [EOL] if self . _raw is not None : [EOL] return self . _raw [EOL] self . _raw = raw = BytesFormat ( [string] ) . join ( [ [string] , [string] ] + self . capabilities ) [EOL] return raw [EOL] [EOL] def __bytes__ ( self ) : [EOL] return BytesFormat ( [string] ) % self . string [EOL] [EOL] [EOL] class PermanentFlags ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , flags ) : [EOL] super ( ) . __init__ ( ) [EOL] self . flags = sorted ( flags ) [EOL] self . _raw = BytesFormat ( [string] ) % ListP ( self . flags ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class UidNext ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , next_ ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _raw = [string] % next_ [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class UidValidity ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , validity ) : [EOL] super ( ) . __init__ ( ) [EOL] self . validity = validity [EOL] self . _raw = [string] % validity [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class Unseen ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , next_ ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _raw = [string] % next_ [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class AppendUid ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , validity , uids ) : [EOL] super ( ) . __init__ ( ) [EOL] self . validity = validity [EOL] self . uids = frozenset ( uids ) [EOL] self . _raw = BytesFormat ( [string] ) % ( validity , SequenceSet . build ( self . uids ) ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class CopyUid ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , validity , uids ) : [EOL] super ( ) . __init__ ( ) [EOL] source_uids , dest_uids = zip ( * uids ) [EOL] source_uid_set = SequenceSet . build ( source_uids ) [EOL] dest_uid_set = SequenceSet . build ( dest_uids ) [EOL] self . _raw = [string] % ( validity , bytes ( source_uid_set ) , bytes ( dest_uid_set ) ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL] [EOL] [EOL] class MailboxId ( ResponseCode ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , object_id ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _raw = BytesFormat ( [string] ) % ( object_id . parens , ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return self . _raw [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.bytes]$ 0 0 0 $typing.Sequence[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.bytes]$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $typing.Iterable[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $specials.ObjectId$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Type , ClassVar , Tuple [EOL] import typing [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod , ABCMeta [EOL] from typing import Tuple , Optional , Type , ClassVar [EOL] [EOL] from . . import Params , Parseable , EndLine [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Command ( Parseable [ bytes ] , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] command = [string] [EOL] [EOL] [comment] [EOL] delegate = None [EOL] [EOL] [comment] [EOL] compound = False [EOL] [EOL] def __init__ ( self , tag ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [comment] [EOL] self . tag = tag [EOL] [EOL] @ property def value ( self ) : [EOL] [docstring] [EOL] return self . command [EOL] [EOL] @ classmethod @ abstractmethod def parse ( cls , buf , params ) : [EOL] ... [EOL] [EOL] def __bytes__ ( self ) : [EOL] return [string] . join ( ( self . tag , self . command ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] % ( type ( self ) . __name__ , self . tag ) [EOL] [EOL] [EOL] class CommandNoArgs ( Command , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag ) , buf [EOL] [EOL] [EOL] class CommandAny ( Command , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CommandAuth ( Command , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CommandNonAuth ( Command , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class CommandSelect ( CommandAuth , metaclass = ABCMeta ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bytes]$ 0 0 0 0 0 0 $typing.ClassVar[typing.Optional[typing.Type[Command]]]$ 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[Command,builtins.memoryview]$ 0 0 0 $builtins.memoryview$ 0 $Params$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[CommandNoArgs,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from __future__ import annotations [EOL] [EOL] from . import CommandAny , CommandNoArgs [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class CapabilityCommand ( CommandNoArgs , CommandAny ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [EOL] class LogoutCommand ( CommandNoArgs , CommandAny ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [EOL] class NoOpCommand ( CommandNoArgs , CommandAny ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , List , ClassVar , Tuple , Sequence , Iterable [EOL] import builtins [EOL] import message [EOL] import typing [EOL] import specials [EOL] from __future__ import annotations [EOL] [EOL] from abc import ABCMeta [EOL] from typing import ClassVar , Optional , Tuple , Sequence , Iterable , List , FrozenSet [EOL] [EOL] from . import CommandAuth [EOL] from . . import Space , EndLine , Params [EOL] from . . exceptions import NotParseable , UnexpectedType , InvalidContent [EOL] from . . message import AppendMessage [EOL] from . . modutf7 import modutf7_decode [EOL] from . . primitives import ListP , String , LiteralString [EOL] from . . specials import Mailbox , DateTime , Flag , StatusAttribute , ExtensionOption , ExtensionOptions [EOL] from . . . bytes import rev [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class CommandMailboxArg ( CommandAuth , metaclass = ABCMeta ) : [EOL] [EOL] def __init__ ( self , tag , mailbox ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . mailbox_obj = mailbox [EOL] [EOL] @ property def mailbox ( self ) : [EOL] return str ( self . mailbox_obj ) [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] mailbox , buf = Mailbox . parse ( buf , params ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , mailbox ) , buf [EOL] [EOL] [EOL] class AppendCommand ( CommandAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , mailbox , messages , cancelled = False , error = None ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . mailbox_obj = mailbox [EOL] self . messages = list ( messages ) [EOL] self . cancelled = cancelled [EOL] self . error = error [EOL] [EOL] @ property def mailbox ( self ) : [EOL] return str ( self . mailbox_obj ) [EOL] [EOL] @ classmethod def _parse_msg ( cls , name , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] try : [EOL] params_copy = params . copy ( list_expected = [ Flag ] ) [EOL] flag_list , buf = ListP . parse ( buf , params_copy ) [EOL] except UnexpectedType : [EOL] raise [EOL] except NotParseable : [EOL] flags = frozenset ( ) [EOL] else : [EOL] flags = frozenset ( flag_list . get_as ( Flag ) ) [EOL] _ , buf = Space . parse ( buf , params ) [EOL] try : [EOL] date_time_p , buf = DateTime . parse ( buf , params ) [EOL] except InvalidContent : [EOL] raise [EOL] except NotParseable : [EOL] date_time = None [EOL] else : [EOL] date_time = date_time_p . value [EOL] _ , buf = Space . parse ( buf , params ) [EOL] options_list = [ ] [EOL] while True : [EOL] try : [EOL] option , buf = ExtensionOption . parse ( buf , params ) [EOL] except NotParseable : [EOL] break [EOL] else : [EOL] options_list . append ( option ) [EOL] options = ExtensionOptions ( options_list ) [EOL] try : [EOL] message , buf = LiteralString . parse ( buf , params ) [EOL] except NotParseable as exc : [EOL] if options : [EOL] literal = [string] [EOL] else : [EOL] raise exc [EOL] else : [EOL] literal = message . value [EOL] if literal == [string] : [EOL] return None , buf [EOL] append_msg = AppendMessage ( literal , date_time , flags , options ) [EOL] return append_msg , buf [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] mailbox , buf = Mailbox . parse ( buf , params ) [EOL] messages = [ ] [EOL] error = None [EOL] cancelled = False [EOL] while True : [EOL] try : [EOL] next_msg , buf = cls . _parse_msg ( mailbox . value , buf , params ) [EOL] except NotParseable : [EOL] if not messages : [EOL] raise [EOL] break [EOL] else : [EOL] if next_msg is None : [EOL] cancelled = True [EOL] break [EOL] messages . append ( next_msg ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , mailbox , messages , cancelled , error ) , buf [EOL] [EOL] [EOL] class CreateCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , mailbox , options ) : [EOL] super ( ) . __init__ ( tag , mailbox ) [EOL] self . options = options [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] mailbox , buf = Mailbox . parse ( buf , params ) [EOL] options , buf = ExtensionOptions . parse ( buf , params ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , mailbox , options ) , buf [EOL] [EOL] [EOL] class DeleteCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [EOL] class ListCommand ( CommandAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [comment] [EOL] only_subscribed = False [EOL] [EOL] _list_mailbox_pattern = rev . compile ( [string] [string] ) [EOL] [EOL] def __init__ ( self , tag , ref_name , filter_ ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . ref_name = ref_name [EOL] self . filter = filter_ [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] ref_name , buf = Mailbox . parse ( buf , params ) [EOL] _ , buf = Space . parse ( buf , params ) [EOL] match = cls . _list_mailbox_pattern . match ( buf ) [EOL] if match : [EOL] filter_raw = match . group ( [number] ) [EOL] buf = buf [ match . end ( [number] ) : ] [EOL] filter_ = modutf7_decode ( filter_raw ) [EOL] else : [EOL] filter_str , buf = String . parse ( buf , params ) [EOL] filter_ = modutf7_decode ( filter_str . value ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , ref_name . value , filter_ ) , buf [EOL] [EOL] [EOL] class LSubCommand ( ListCommand ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] delegate = ListCommand [EOL] [EOL] [comment] [EOL] only_subscribed = True [EOL] [EOL] [EOL] class RenameCommand ( CommandAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , from_mailbox , to_mailbox , options ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . from_mailbox_obj = from_mailbox [EOL] self . to_mailbox_obj = to_mailbox [EOL] self . options = options [EOL] [EOL] @ property def from_mailbox ( self ) : [EOL] return str ( self . from_mailbox_obj ) [EOL] [EOL] @ property def to_mailbox ( self ) : [EOL] return str ( self . to_mailbox_obj ) [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] from_mailbox , buf = Mailbox . parse ( buf , params ) [EOL] _ , buf = Space . parse ( buf , params ) [EOL] to_mailbox , buf = Mailbox . parse ( buf , params ) [EOL] options , buf = ExtensionOptions . parse ( buf , params ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , from_mailbox , to_mailbox , options ) , buf [EOL] [EOL] [EOL] class SelectCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] readonly = False [EOL] [EOL] def __init__ ( self , tag , mailbox , options ) : [EOL] super ( ) . __init__ ( tag , mailbox ) [EOL] self . options = options [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] mailbox , buf = Mailbox . parse ( buf , params ) [EOL] options , buf = ExtensionOptions . parse ( buf , params ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , mailbox , options ) , buf [EOL] [EOL] [EOL] class ExamineCommand ( SelectCommand ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] delegate = SelectCommand [EOL] [EOL] [comment] [EOL] readonly = True [EOL] [EOL] [EOL] class StatusCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , mailbox , status_list ) : [EOL] super ( ) . __init__ ( tag , mailbox ) [EOL] self . status_list = status_list [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] mailbox , buf = Mailbox . parse ( buf , params ) [EOL] _ , buf = Space . parse ( buf , params ) [EOL] params_copy = params . copy ( list_expected = [ StatusAttribute ] ) [EOL] status_list_p , after = ListP . parse ( buf , params_copy ) [EOL] if not status_list_p . value : [EOL] raise NotParseable ( buf ) [EOL] _ , buf = EndLine . parse ( after , params ) [EOL] status_list = status_list_p . get_as ( StatusAttribute ) [EOL] return cls ( params . tag , mailbox , status_list ) , buf [EOL] [EOL] [EOL] class SubscribeCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] [EOL] class UnsubscribeCommand ( CommandMailboxArg ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $specials.Mailbox$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[CommandMailboxArg,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 $typing.Sequence[message.AppendMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $specials.Mailbox$ 0 0 0 $typing.Sequence[message.AppendMessage]$ 0 0 0 $typing.Sequence[message.AppendMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[message.AppendMessage],builtins.memoryview]$ 0 0 0 $builtins.str$ 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 $typing.List[specials.ExtensionOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[specials.ExtensionOption]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[specials.ExtensionOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[AppendCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 $typing.List[message.AppendMessage]$ 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 $typing.List[message.AppendMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[message.AppendMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 $typing.List[message.AppendMessage]$ 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[CreateCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Tuple[ListCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $specials.Mailbox$ 0 0 0 0 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[RenameCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[SelectCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $specials.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[StatusCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Tuple [EOL] [EOL] from . import CommandNonAuth , CommandNoArgs [EOL] from . . import Params , Space , EndLine [EOL] from . . primitives import Atom [EOL] from . . specials import AString [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class AuthenticateCommand ( CommandNonAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , mech_name ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . mech_name = mech_name [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] atom , after = Atom . parse ( buf , params ) [EOL] _ , after = EndLine . parse ( after , params ) [EOL] return cls ( params . tag , atom . value . upper ( ) ) , after [EOL] [EOL] [EOL] class LoginCommand ( CommandNonAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL] [EOL] def __init__ ( self , tag , userid , password ) : [EOL] super ( ) . __init__ ( tag ) [EOL] self . userid = userid [EOL] self . password = password [EOL] [EOL] @ classmethod def parse ( cls , buf , params ) : [EOL] _ , buf = Space . parse ( buf , params ) [EOL] userid , buf = AString . parse ( buf , params ) [EOL] _ , buf = Space . parse ( buf , params ) [EOL] password , buf = AString . parse ( buf , params ) [EOL] _ , buf = EndLine . parse ( buf , params ) [EOL] return cls ( params . tag , userid . value , password . value ) , buf [EOL] [EOL] [EOL] class StartTLSCommand ( CommandNoArgs , CommandNonAuth ) : [EOL] [docstring] [EOL] [EOL] command = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[AuthenticateCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[LoginCommand,builtins.memoryview]$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 $Params$ 0 0 0 0 0 $Params$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , List , Dict , Iterable , NoReturn [EOL] import typing [EOL] import pysasl [EOL] import builtins [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from collections import OrderedDict [EOL] from typing import Optional , Dict , List , Callable , Union , Tuple , Awaitable , Iterable , NoReturn [EOL] [EOL] from pymap . bytes import MaybeBytes [EOL] from pymap . concurrent import Event [EOL] from pymap . config import IMAPConfig [EOL] from pymap . context import socket_info , connection_exit [EOL] from pymap . exceptions import NotSupportedError , CloseConnection [EOL] from pymap . fetch import MessageAttributes [EOL] from pymap . interfaces . session import SessionInterface , LoginProtocol [EOL] from pymap . parsing . command import CommandAuth , CommandNonAuth , CommandSelect , Command [EOL] from pymap . parsing . command . any import CapabilityCommand , LogoutCommand , NoOpCommand [EOL] from pymap . parsing . command . nonauth import AuthenticateCommand , LoginCommand , StartTLSCommand [EOL] from pymap . parsing . command . auth import AppendCommand , CreateCommand , DeleteCommand , ListCommand , RenameCommand , SelectCommand , StatusCommand , SubscribeCommand , UnsubscribeCommand [EOL] from pymap . parsing . command . select import CheckCommand , CloseCommand , IdleCommand , ExpungeCommand , CopyCommand , MoveCommand , FetchCommand , StoreCommand , SearchCommand [EOL] from pymap . parsing . commands import InvalidCommand [EOL] from pymap . parsing . primitives import ListP , Number [EOL] from pymap . parsing . response import ResponseOk , ResponseNo , ResponseBad , ResponseCode , ResponsePreAuth , CommandResponse , UntaggedResponse [EOL] from pymap . parsing . response . code import Capability , PermanentFlags , UidNext , UidValidity , Unseen , MailboxId [EOL] from pymap . parsing . response . specials import FlagsResponse , ExistsResponse , RecentResponse , FetchResponse , ListResponse , LSubResponse , SearchResponse , StatusResponse [EOL] from pymap . parsing . specials import StatusAttribute , FetchAttribute , FetchValue [EOL] from pymap . selected import SelectedMailbox [EOL] from pysasl import AuthenticationCredentials [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _AuthCommands = Union [ AuthenticateCommand , LoginCommand ] [EOL] _CommandRet = Tuple [ CommandResponse , Optional [ SelectedMailbox ] ] [EOL] _CommandFunc = Callable [ [ Command ] , Awaitable [ _CommandRet ] ] [EOL] [EOL] _flags_attr = FetchAttribute ( [string] ) [EOL] _uid_attr = FetchAttribute ( [string] ) [EOL] [EOL] [EOL] class ConnectionState : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , login , config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . config = config [EOL] self . auth = config . initial_auth [EOL] self . login = login [EOL] self . _session = None [EOL] self . _selected = None [EOL] self . _capability = list ( config . initial_capability ) [EOL] [EOL] @ property def session ( self ) : [EOL] if self . _session is None : [EOL] raise RuntimeError ( ) [comment] [EOL] return self . _session [EOL] [EOL] @ property def selected ( self ) : [EOL] if self . _selected is None : [EOL] raise RuntimeError ( ) [comment] [EOL] return self . _selected [EOL] [EOL] @ property def capability ( self ) : [EOL] if self . _session : [EOL] return Capability ( self . _capability ) [EOL] else : [EOL] if self . auth . get_server ( [string] ) is None : [EOL] logindisabled = [ [string] ] [EOL] else : [EOL] logindisabled = [ ] [EOL] return Capability ( self . _capability + logindisabled + [ [string] % mech . name for mech in self . auth . server_mechanisms ] ) [EOL] [EOL] async def do_cleanup ( self ) : [EOL] try : [EOL] await self . session . cleanup ( ) [EOL] except Exception : [EOL] pass [EOL] [EOL] async def _login ( self , creds ) : [EOL] stack = connection_exit . get ( ) [EOL] return await stack . enter_async_context ( self . login ( creds ) ) [EOL] [EOL] async def do_greeting ( self ) : [EOL] preauth_creds = self . config . preauth_credentials [EOL] if preauth_creds : [EOL] self . _session = await self . _login ( preauth_creds ) [EOL] elif socket_info . get ( ) . from_localhost : [EOL] self . auth = self . config . tls_auth [EOL] resp_cls = ResponsePreAuth if preauth_creds else ResponseOk [EOL] return resp_cls ( [string] , self . config . greeting , self . capability ) [EOL] [EOL] async def do_authenticate ( self , cmd , creds ) : [EOL] if not creds : [EOL] return ResponseNo ( cmd . tag , [string] ) [EOL] self . _session = await self . _login ( creds ) [EOL] self . _capability . extend ( self . config . login_capability ) [EOL] return ResponseOk ( cmd . tag , [string] , self . capability ) [EOL] [EOL] async def do_login ( self , cmd ) : [EOL] if [string] in self . capability : [EOL] raise NotSupportedError ( [string] ) [EOL] creds = AuthenticationCredentials ( cmd . userid . decode ( [string] , [string] ) , cmd . password . decode ( [string] , [string] ) ) [EOL] return await self . do_authenticate ( cmd , creds ) , None [EOL] [EOL] async def do_starttls ( self , cmd ) : [EOL] try : [EOL] self . _capability . remove ( [string] ) [EOL] except ValueError : [EOL] raise NotSupportedError ( [string] ) [EOL] self . auth = self . config . tls_auth [EOL] return ResponseOk ( cmd . tag , [string] ) , None [EOL] [EOL] async def do_capability ( self , cmd ) : [EOL] response = ResponseOk ( cmd . tag , [string] ) [EOL] response . add_untagged ( UntaggedResponse ( self . capability . string ) ) [EOL] return response , None [EOL] [EOL] async def do_noop ( self , cmd ) : [EOL] updates = None [EOL] if self . _selected and self . _session : [EOL] updates = await self . session . check_mailbox ( self . selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_select ( self , cmd ) : [EOL] self . _selected = None [EOL] mailbox , updates = await self . session . select_mailbox ( cmd . mailbox , cmd . readonly ) [EOL] if updates . readonly : [EOL] num_recent = mailbox . recent [EOL] resp = ResponseOk ( cmd . tag , [string] , ResponseCode . of ( [string] ) ) [EOL] resp . add_untagged_ok ( [string] , PermanentFlags ( [ ] ) ) [EOL] else : [EOL] num_recent = updates . session_flags . recent [EOL] resp = ResponseOk ( cmd . tag , [string] , ResponseCode . of ( [string] ) ) [EOL] resp . add_untagged_ok ( [string] , PermanentFlags ( mailbox . permanent_flags ) ) [EOL] messages = updates . messages [EOL] resp . add_untagged ( FlagsResponse ( mailbox . flags ) ) [EOL] resp . add_untagged ( ExistsResponse ( messages . exists ) ) [EOL] resp . add_untagged ( RecentResponse ( num_recent ) ) [EOL] resp . add_untagged_ok ( [string] , UidNext ( mailbox . next_uid ) ) [EOL] resp . add_untagged_ok ( [string] , UidValidity ( mailbox . uid_validity ) ) [EOL] if mailbox . first_unseen : [EOL] resp . add_untagged_ok ( [string] , Unseen ( mailbox . first_unseen ) ) [EOL] resp . add_untagged_ok ( [string] , MailboxId ( mailbox . mailbox_id ) ) [EOL] return resp , updates [EOL] [EOL] async def do_create ( self , cmd ) : [EOL] if cmd . mailbox == [string] : [EOL] return ResponseNo ( cmd . tag , [string] ) , None [EOL] mailbox_id , updates = await self . session . create_mailbox ( cmd . mailbox , selected = self . _selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] , MailboxId ( mailbox_id ) ) , updates [EOL] [EOL] async def do_delete ( self , cmd ) : [EOL] if cmd . mailbox == [string] : [EOL] return ResponseNo ( cmd . tag , [string] ) , None [EOL] updates = await self . session . delete_mailbox ( cmd . mailbox , selected = self . _selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_rename ( self , cmd ) : [EOL] if cmd . to_mailbox == [string] : [EOL] return ResponseNo ( cmd . tag , [string] ) , None [EOL] updates = await self . session . rename_mailbox ( cmd . from_mailbox , cmd . to_mailbox , selected = self . _selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_status ( self , cmd ) : [EOL] mailbox , updates = await self . session . get_mailbox ( cmd . mailbox , selected = self . _selected ) [EOL] data = OrderedDict ( ) [EOL] for attr in cmd . status_list : [EOL] if attr == [string] : [EOL] data [ attr ] = Number ( mailbox . exists ) [EOL] elif attr == [string] : [EOL] if updates and updates . mailbox_id == mailbox . mailbox_id : [EOL] data [ attr ] = Number ( updates . session_flags . recent ) [EOL] else : [EOL] data [ attr ] = Number ( mailbox . recent ) [EOL] elif attr == [string] : [EOL] data [ attr ] = Number ( mailbox . unseen ) [EOL] elif attr == [string] : [EOL] data [ attr ] = Number ( mailbox . next_uid ) [EOL] elif attr == [string] : [EOL] data [ attr ] = Number ( mailbox . uid_validity ) [EOL] elif attr == [string] : [EOL] data [ attr ] = mailbox . mailbox_id . parens [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] resp . add_untagged ( StatusResponse ( cmd . mailbox , data ) ) [EOL] return resp , updates [EOL] [EOL] async def do_append ( self , cmd ) : [EOL] if len ( cmd . messages ) > [number] and [string] not in self . capability : [EOL] raise NotSupportedError ( [string] ) [EOL] if cmd . cancelled : [EOL] return ResponseNo ( cmd . tag , [string] ) , None [EOL] if cmd . error : [EOL] raise cmd . error [EOL] append_uid , updates = await self . session . append_messages ( cmd . mailbox , cmd . messages , selected = self . _selected ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] , append_uid ) [EOL] return resp , updates [EOL] [EOL] async def do_subscribe ( self , cmd ) : [EOL] updates = await self . session . subscribe ( cmd . mailbox , selected = self . _selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_unsubscribe ( self , cmd ) : [EOL] updates = await self . session . unsubscribe ( cmd . mailbox , selected = self . _selected ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_list ( self , cmd ) : [EOL] mailboxes , updates = await self . session . list_mailboxes ( cmd . ref_name , cmd . filter , subscribed = cmd . only_subscribed , selected = self . _selected ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] resp_type = LSubResponse if cmd . only_subscribed else ListResponse [EOL] for name , sep , attrs in mailboxes : [EOL] resp . add_untagged ( resp_type ( name , sep , attrs ) ) [EOL] return resp , updates [EOL] [EOL] async def do_check ( self , cmd ) : [EOL] updates = await self . session . check_mailbox ( self . selected , housekeeping = True ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , updates [EOL] [EOL] async def do_close ( self , cmd ) : [EOL] await self . session . expunge_mailbox ( self . selected ) [EOL] self . _selected = None [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , None [EOL] [EOL] async def do_expunge ( self , cmd ) : [EOL] updates = await self . session . expunge_mailbox ( self . selected , cmd . uid_set ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] return resp , updates [EOL] [EOL] async def do_copy ( self , cmd ) : [EOL] copy_uid , updates = await self . session . copy_messages ( self . selected , cmd . sequence_set , cmd . mailbox ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] , copy_uid ) [EOL] return resp , updates [EOL] [EOL] async def do_move ( self , cmd ) : [EOL] copy_uid , updates = await self . session . move_messages ( self . selected , cmd . sequence_set , cmd . mailbox ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] resp . add_untagged_ok ( [string] , copy_uid ) [EOL] return resp , updates [EOL] [EOL] async def do_fetch ( self , cmd ) : [EOL] if not cmd . uid : [EOL] self . selected . hide_expunged = True [EOL] set_seen = not self . selected . readonly and any ( attr . set_seen for attr in cmd . attributes ) [EOL] messages , updates = await self . session . fetch_messages ( self . selected , cmd . sequence_set , set_seen ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] for msg_seq , msg in messages : [EOL] if msg . expunged : [EOL] resp . code = ResponseCode . of ( [string] ) [EOL] msg_attrs = MessageAttributes ( msg , self . selected , cmd . attributes ) [EOL] fetch_resp = FetchResponse ( msg_seq , msg_attrs , writing_hook = msg_attrs . load_hook ( ) ) [EOL] resp . add_untagged ( fetch_resp ) [EOL] return resp , updates [EOL] [EOL] async def do_search ( self , cmd ) : [EOL] if not cmd . uid : [EOL] self . selected . hide_expunged = True [EOL] messages , updates = await self . session . search_mailbox ( self . selected , cmd . keys ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] msg_ids = [ ] [EOL] for msg_seq , msg in messages : [EOL] if msg . expunged : [EOL] resp . code = ResponseCode . of ( [string] ) [EOL] if cmd . uid : [EOL] msg_ids . append ( msg . uid ) [EOL] else : [EOL] msg_ids . append ( msg_seq ) [EOL] resp . add_untagged ( SearchResponse ( msg_ids ) ) [EOL] return resp , updates [EOL] [EOL] async def do_store ( self , cmd ) : [EOL] if not cmd . uid : [EOL] self . selected . hide_expunged = True [EOL] if cmd . silent : [EOL] self . selected . silence ( cmd . sequence_set , cmd . flag_set , cmd . mode ) [EOL] messages , updates = await self . session . update_flags ( self . selected , cmd . sequence_set , cmd . flag_set , cmd . mode ) [EOL] resp = ResponseOk ( cmd . tag , cmd . command + [string] ) [EOL] session_flags = self . selected . session_flags [EOL] for msg_seq , msg in messages : [EOL] if msg . expunged : [EOL] resp . code = ResponseCode . of ( [string] ) [EOL] elif cmd . silent : [EOL] continue [EOL] flags = msg . get_flags ( session_flags ) [EOL] fetch_data = [ FetchValue . of ( _flags_attr , ListP ( flags , sort = True ) ) ] [EOL] if cmd . uid : [EOL] fetch_data . append ( FetchValue . of ( _uid_attr , Number ( msg . uid ) ) ) [EOL] resp . add_untagged ( FetchResponse ( msg_seq , fetch_data ) ) [EOL] return resp , updates [EOL] [EOL] async def do_idle ( self , cmd ) : [EOL] if [string] not in self . capability : [EOL] raise NotSupportedError ( [string] ) [EOL] return ResponseOk ( cmd . tag , cmd . command + [string] ) , None [EOL] [EOL] @ classmethod async def do_logout ( cls , cmd ) : [EOL] raise CloseConnection ( ) [EOL] [EOL] async def receive_updates ( self , cmd , done ) : [EOL] selected = await self . session . check_mailbox ( self . selected , wait_on = done ) [EOL] self . _selected , untagged = selected . fork ( cmd ) [EOL] return untagged [EOL] [EOL] @ classmethod def _get_func_name ( cls , cmd ) : [EOL] cmd_type = type ( cmd ) [EOL] while cmd_type . delegate : [EOL] cmd_type = cmd_type . delegate [EOL] cmd_str = str ( cmd_type . command , [string] ) . lower ( ) [EOL] return [string] + cmd_str [EOL] [EOL] async def do_command ( self , cmd ) : [EOL] if isinstance ( cmd , InvalidCommand ) : [EOL] return ResponseBad ( cmd . tag , cmd . message ) [EOL] elif self . _session and isinstance ( cmd , CommandNonAuth ) : [EOL] msg = cmd . command + [string] [EOL] return ResponseBad ( cmd . tag , msg ) [EOL] elif not self . _session and isinstance ( cmd , CommandAuth ) : [EOL] msg = cmd . command + [string] [EOL] return ResponseBad ( cmd . tag , msg ) [EOL] elif not self . _selected and isinstance ( cmd , CommandSelect ) : [EOL] msg = cmd . command + [string] [EOL] return ResponseBad ( cmd . tag , msg ) [EOL] func_name = self . _get_func_name ( cmd ) [EOL] try : [EOL] func = getattr ( self , func_name ) [EOL] except AttributeError : [EOL] return ResponseNo ( cmd . tag , cmd . command + [string] ) [EOL] response , selected = await func ( cmd ) [EOL] if selected is not None : [EOL] self . _selected , untagged = selected . fork ( cmd ) [EOL] response . add_untagged ( * untagged ) [EOL] return response [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pymap.interfaces.session.SessionInterface]$ 0 0 0 0 0 $typing.Optional[pymap.selected.SelectedMailbox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 $pysasl.AuthenticationCredentials$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pysasl.AuthenticationCredentials$ 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 $_AuthCommands$ 0 $typing.Optional[pysasl.AuthenticationCredentials]$ 0 0 0 0 0 $typing.Optional[pysasl.AuthenticationCredentials]$ 0 0 0 0 0 $_AuthCommands$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pysasl.AuthenticationCredentials]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_AuthCommands$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.nonauth.LoginCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.nonauth.LoginCommand$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.nonauth.LoginCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.nonauth.LoginCommand$ 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.nonauth.StartTLSCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.nonauth.StartTLSCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.any.CapabilityCommand$ 0 0 0 0 0 0 0 $pymap.parsing.command.any.CapabilityCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.any.NoOpCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.any.NoOpCommand$ 0 0 0 $pymap.parsing.command.any.NoOpCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.SelectCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.SelectCommand$ 0 0 0 $pymap.parsing.command.auth.SelectCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.SelectCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.SelectCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 $pymap.parsing.command.auth.CreateCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 $pymap.parsing.command.auth.DeleteCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 $pymap.parsing.command.auth.RenameCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.StatusCommand$ 0 0 0 $typing.Dict[pymap.parsing.specials.StatusAttribute,pymap.bytes.MaybeBytes]$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 $pymap.parsing.command.auth.AppendCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.SubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.SubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.SubscribeCommand$ 0 0 0 $pymap.parsing.command.auth.SubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.UnsubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.UnsubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.UnsubscribeCommand$ 0 0 0 $pymap.parsing.command.auth.UnsubscribeCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.auth.ListCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.CheckCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.CheckCommand$ 0 0 0 $pymap.parsing.command.select.CheckCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.CloseCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.CloseCommand$ 0 0 0 $pymap.parsing.command.select.CloseCommand$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.ExpungeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.ExpungeCommand$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.ExpungeCommand$ 0 0 0 $pymap.parsing.command.select.ExpungeCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.CopyCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.CopyCommand$ 0 0 0 $pymap.parsing.command.select.CopyCommand$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.CopyCommand$ 0 0 0 $pymap.parsing.command.select.CopyCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.MoveCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.MoveCommand$ 0 0 0 $pymap.parsing.command.select.MoveCommand$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.MoveCommand$ 0 0 0 $pymap.parsing.command.select.MoveCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.FetchCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.SearchCommand$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pymap.parsing.specials.FetchValue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.StoreCommand$ 0 0 0 0 $typing.List[pymap.parsing.specials.FetchValue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pymap.parsing.specials.FetchValue]$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandRet$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.NoReturn$ 0 0 0 $pymap.parsing.command.any.LogoutCommand$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[pymap.parsing.response.UntaggedResponse]$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 $_CommandFunc$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 $_CommandFunc$ 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Union , List , Awaitable , Iterable [EOL] import asyncio [EOL] import argparse [EOL] import pymap [EOL] import builtins [EOL] import state [EOL] import pysasl [EOL] import typing [EOL] import proxyprotocol [EOL] from __future__ import annotations [EOL] [EOL] import asyncio [EOL] import binascii [EOL] import logging [EOL] import re [EOL] import sys [EOL] from argparse import ArgumentParser [EOL] from asyncio import shield , StreamReader , StreamWriter , AbstractServer , CancelledError , TimeoutError [EOL] from base64 import b64encode , b64decode [EOL] from contextlib import closing , AsyncExitStack [EOL] from typing import TypeVar , Union , Optional , Iterable , List , Awaitable [EOL] [EOL] from proxyprotocol import ProxyProtocolResult [EOL] from proxyprotocol . sock import SocketInfo [EOL] from proxyprotocol . version import ProxyProtocolVersion [EOL] from pymap . concurrent import Event [EOL] from pymap . config import IMAPConfig [EOL] from pymap . context import subsystem , current_command , socket_info , connection_exit [EOL] from pymap . exceptions import ResponseError [EOL] from pymap . interfaces . backend import ServiceInterface [EOL] from pymap . interfaces . session import LoginProtocol [EOL] from pymap . parsing . command import Command [EOL] from pymap . parsing . commands import Commands [EOL] from pymap . parsing . command . nonauth import AuthenticateCommand , StartTLSCommand [EOL] from pymap . parsing . command . select import IdleCommand [EOL] from pymap . parsing . response import ResponseContinuation , Response , ResponseCode , ResponseBad , ResponseNo , ResponseBye , ResponseOk , CommandResponse [EOL] from pymap . parsing . state import ParsingState , ParsingInterrupt , ExpectContinuation [EOL] from pymap . sockets import InheritedSockets [EOL] from pysasl import ServerChallenge , ChallengeResponse , AuthenticationError , AuthenticationCredentials [EOL] [EOL] from . state import ConnectionState [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _Ret = TypeVar ( [string] ) [EOL] _log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class IMAPService ( ServiceInterface ) : [comment] [EOL] [docstring] [EOL] [EOL] @ classmethod def add_arguments ( cls , parser ) : [EOL] group = parser . add_argument_group ( [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , action = [string] , help = [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , help = [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , help = [string] ) [EOL] if InheritedSockets . supports ( [string] ) : [EOL] group . add_argument ( [string] , action = [string] , dest = [string] , const = [string] , help = [string] ) [EOL] else : [EOL] parser . set_defaults ( inherited_sockets = None ) [EOL] group . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] pp_choices = [ v . name . lower ( ) for v in ProxyProtocolVersion ] [EOL] group . add_argument ( [string] , choices = pp_choices , help = [string] ) [EOL] [EOL] async def start ( self ) : [EOL] backend = self . backend [EOL] config = self . config [EOL] servers = [ ] [EOL] imap_server = IMAPServer ( backend . login , config ) [EOL] if config . args . inherited_sockets : [EOL] sockets = InheritedSockets . of ( config . args . inherited_sockets ) . get ( ) [EOL] if not sockets : [EOL] raise ValueError ( [string] ) [EOL] for sock in sockets : [EOL] server = await asyncio . start_server ( imap_server , sock = sock ) [EOL] servers . append ( server ) [EOL] else : [EOL] server = await asyncio . start_server ( imap_server , host = config . host , port = config . port ) [EOL] servers . append ( server ) [EOL] return asyncio . gather ( * [ self . _run ( server ) for server in servers ] ) [EOL] [EOL] @ classmethod async def _run ( cls , server ) : [EOL] async with server : [EOL] await server . serve_forever ( ) [EOL] [EOL] [EOL] class IMAPServer : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , login , config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . commands = config . commands [EOL] self . _login = login [EOL] self . _config = config [EOL] [EOL] async def __call__ ( self , reader , writer ) : [EOL] conn = IMAPConnection ( self . commands , self . _config , reader , writer ) [EOL] state = ConnectionState ( self . _login , self . _config ) [EOL] async with AsyncExitStack ( ) as stack : [EOL] connection_exit . set ( stack ) [EOL] stack . enter_context ( closing ( conn ) ) [EOL] await conn . run ( state ) [EOL] [EOL] [EOL] class IMAPConnection : [EOL] [docstring] [EOL] [EOL] _lines = re . compile ( [string] ) [EOL] _literal_plus = re . compile ( [string] ) [EOL] [EOL] __slots__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , commands , config , reader , writer ) : [EOL] super ( ) . __init__ ( ) [EOL] self . commands = commands [EOL] self . config = config [EOL] self . params = config . parsing_params [EOL] self . bad_command_limit = config . bad_command_limit [EOL] self . pp_result = None [EOL] self . _reset_streams ( reader , writer ) [EOL] [EOL] def _reset_streams ( self , reader , writer ) : [EOL] self . reader = reader [EOL] self . writer = writer [EOL] socket_info . set ( SocketInfo ( writer , self . pp_result ) ) [EOL] [EOL] async def _read_proxy_protocol ( self ) : [EOL] self . pp_result = await self . config . proxy_protocol . read ( self . reader ) [EOL] self . _reset_streams ( self . reader , self . writer ) [EOL] [EOL] def close ( self ) : [EOL] self . writer . close ( ) [EOL] [EOL] @ classmethod def _print ( cls , log_format , output ) : [EOL] if _log . isEnabledFor ( logging . DEBUG ) : [EOL] fd = socket_info . get ( ) . socket . fileno ( ) [EOL] if not isinstance ( output , str ) : [EOL] output = str ( output , [string] , [string] ) [EOL] lines = cls . _lines . split ( output ) [EOL] if not lines [ - [number] ] : [EOL] lines = lines [ : - [number] ] [EOL] for line in lines : [EOL] _log . debug ( log_format , fd , line ) [EOL] [EOL] def _exec ( self , future ) : [EOL] return subsystem . get ( ) . execute ( future ) [EOL] [EOL] async def readline ( self ) : [EOL] buf = bytearray ( await self . reader . readline ( ) ) [EOL] while True : [EOL] if not buf . endswith ( [string] ) : [EOL] raise EOFError ( ) [EOL] elif buf . endswith ( [string] ) or buf . endswith ( [string] ) : [EOL] lit_plus = self . _literal_plus . search ( buf ) [EOL] else : [EOL] lit_plus = None [EOL] if lit_plus : [EOL] literal_length = int ( lit_plus . group ( [number] ) ) [EOL] buf += await self . reader . readexactly ( literal_length ) [EOL] buf += await self . reader . readline ( ) [EOL] else : [EOL] self . _print ( [string] , buf ) [EOL] return memoryview ( buf ) [EOL] [EOL] async def read_continuation ( self , literal_length ) : [EOL] extra_literal = await self . reader . readexactly ( literal_length ) [EOL] self . _print ( [string] , extra_literal ) [EOL] extra_line = await self . readline ( ) [EOL] extra = extra_literal + bytes ( extra_line ) [EOL] return memoryview ( extra ) [EOL] [EOL] async def authenticate ( self , state , mech_name ) : [EOL] mech = state . auth . get_server ( mech_name ) [EOL] if not mech : [EOL] return None [EOL] responses = [ ] [EOL] while True : [EOL] try : [EOL] creds , final = mech . server_attempt ( responses ) [EOL] except ServerChallenge as chal : [EOL] chal_bytes = b64encode ( chal . data ) [EOL] cont = ResponseContinuation ( chal_bytes ) [EOL] await self . write_response ( cont ) [EOL] resp_bytes = bytes ( await self . read_continuation ( [number] ) ) [EOL] if resp_bytes . rstrip ( [string] ) == [string] : [EOL] raise AuthenticationError ( [string] ) [EOL] try : [EOL] resp_dec = b64decode ( resp_bytes ) [EOL] except binascii . Error as exc : [EOL] raise AuthenticationError ( ) from exc [EOL] else : [EOL] responses . append ( ChallengeResponse ( chal . data , resp_dec ) ) [EOL] else : [EOL] if final is not None : [EOL] cont = ResponseContinuation ( b64encode ( final ) ) [EOL] await self . write_response ( cont ) [EOL] await self . read_continuation ( [number] ) [EOL] return creds [EOL] [EOL] async def _interrupt ( self , state , interrupt , continuations ) : [EOL] expected = interrupt . expected [EOL] if isinstance ( expected , ExpectContinuation ) : [EOL] cont = ResponseContinuation ( expected . message ) [EOL] await self . write_response ( cont ) [EOL] ret = await self . read_continuation ( expected . literal_length ) [EOL] continuations . append ( ret ) [EOL] else : [EOL] raise TypeError ( expected ) from interrupt [EOL] [EOL] async def read_command ( self , state ) : [EOL] line = await self . readline ( ) [EOL] conts = [ ] [EOL] while True : [EOL] parsing_state = ParsingState ( continuations = conts ) [EOL] params = self . params . copy ( parsing_state ) [EOL] try : [EOL] cmd , _ = self . commands . parse ( line , params ) [EOL] except ParsingInterrupt as interrupt : [EOL] await self . _interrupt ( state , interrupt , conts ) [EOL] else : [EOL] return cmd [EOL] [EOL] async def read_idle_done ( self , cmd ) : [EOL] buf = await self . read_continuation ( [number] ) [EOL] ok , _ = cmd . parse_done ( buf ) [EOL] return ok [EOL] [EOL] async def write_response ( self , resp ) : [EOL] await resp . async_write ( self . writer ) [EOL] try : [EOL] await self . writer . drain ( ) [EOL] except ConnectionError : [EOL] pass [EOL] else : [EOL] self . _print ( [string] , bytes ( resp ) ) [EOL] [EOL] async def start_tls ( self ) : [EOL] loop = asyncio . get_event_loop ( ) [EOL] transport = self . writer . transport [EOL] protocol = transport . get_protocol ( ) [EOL] ssl_context = self . config . ssl_context [EOL] new_transport = await loop . start_tls ( transport , protocol , ssl_context , server_side = True ) [EOL] new_protocol = new_transport . get_protocol ( ) [EOL] new_writer = StreamWriter ( new_transport , new_protocol , self . reader , loop ) [EOL] self . _reset_streams ( self . reader , new_writer ) [EOL] self . _print ( [string] , [string] ) [EOL] [EOL] async def send_error_disconnect ( self ) : [EOL] _ , exc , _ = sys . exc_info ( ) [EOL] if isinstance ( exc , CancelledError ) : [EOL] resp = ResponseBye ( [string] , ResponseCode . of ( [string] ) ) [EOL] else : [EOL] resp = ResponseBye ( [string] , ResponseCode . of ( [string] ) ) [EOL] try : [EOL] await self . write_response ( resp ) [EOL] except IOError : [EOL] pass [EOL] [EOL] async def write_updates ( self , untagged ) : [EOL] for i , resp in enumerate ( untagged ) : [EOL] await self . write_response ( resp ) [EOL] [EOL] async def handle_updates ( self , state , done , cmd ) : [EOL] while not done . is_set ( ) : [EOL] untagged = await self . _exec ( state . receive_updates ( cmd , done ) ) [EOL] await shield ( self . write_updates ( untagged ) ) [EOL] [EOL] async def idle ( self , state , cmd ) : [EOL] response = await self . _exec ( state . do_command ( cmd ) ) [EOL] if not isinstance ( response , ResponseOk ) : [EOL] return response [EOL] await self . write_response ( ResponseContinuation ( [string] ) ) [EOL] done = subsystem . get ( ) . new_event ( ) [EOL] updates_task = asyncio . create_task ( self . handle_updates ( state , done , cmd ) ) [EOL] done_task = asyncio . create_task ( self . read_idle_done ( cmd ) ) [EOL] updates_exc = None [EOL] done_exc = None [EOL] try : [EOL] ok = await done_task [EOL] except Exception as exc : [EOL] done_exc = exc [EOL] finally : [EOL] done . set ( ) [EOL] try : [EOL] await updates_task [EOL] except Exception as exc : [EOL] updates_exc = exc [EOL] if updates_exc : [EOL] raise updates_exc [EOL] elif done_exc : [EOL] raise done_exc [EOL] elif not ok : [EOL] return ResponseBad ( cmd . tag , [string] ) [EOL] else : [EOL] return response [EOL] [EOL] async def run ( self , state ) : [EOL] [docstring] [EOL] await self . _read_proxy_protocol ( ) [EOL] self . _print ( [string] , str ( socket_info . get ( ) ) ) [EOL] bad_commands = [number] [EOL] try : [EOL] greeting = await self . _exec ( state . do_greeting ( ) ) [EOL] except ResponseError as exc : [EOL] resp = exc . get_response ( [string] ) [EOL] resp . condition = ResponseBye . condition [EOL] await self . write_response ( resp ) [EOL] return [EOL] else : [EOL] await self . write_response ( greeting ) [EOL] while True : [EOL] try : [EOL] cmd = await self . read_command ( state ) [EOL] except ( ConnectionError , EOFError ) : [EOL] break [EOL] except CancelledError : [EOL] await self . send_error_disconnect ( ) [EOL] break [EOL] except Exception : [EOL] await self . send_error_disconnect ( ) [EOL] raise [EOL] else : [EOL] prev_cmd = current_command . set ( cmd ) [EOL] try : [EOL] if isinstance ( cmd , AuthenticateCommand ) : [EOL] creds = await self . authenticate ( state , cmd . mech_name ) [EOL] response = await self . _exec ( state . do_authenticate ( cmd , creds ) ) [EOL] elif isinstance ( cmd , IdleCommand ) : [EOL] response = await self . idle ( state , cmd ) [EOL] else : [EOL] response = await self . _exec ( state . do_command ( cmd ) ) [EOL] except ResponseError as exc : [EOL] resp = exc . get_response ( cmd . tag ) [EOL] await self . write_response ( resp ) [EOL] if resp . is_terminal : [EOL] break [EOL] except AuthenticationError as exc : [EOL] msg = bytes ( str ( exc ) , [string] , [string] ) [EOL] resp = ResponseBad ( cmd . tag , msg ) [EOL] await self . write_response ( resp ) [EOL] except TimeoutError : [EOL] resp = ResponseNo ( cmd . tag , [string] , ResponseCode . of ( [string] ) ) [EOL] await self . write_response ( resp ) [EOL] except CancelledError : [EOL] await self . send_error_disconnect ( ) [EOL] break [EOL] except Exception : [EOL] await self . send_error_disconnect ( ) [EOL] raise [EOL] else : [EOL] await self . write_response ( response ) [EOL] if response . is_bad : [EOL] bad_commands += [number] [EOL] if self . bad_command_limit \ [EOL] and bad_commands >= self . bad_command_limit : [EOL] msg = [string] [EOL] response . add_untagged ( ResponseBye ( msg ) ) [EOL] else : [EOL] bad_commands = [number] [EOL] if response . is_terminal : [EOL] break [EOL] if isinstance ( cmd , StartTLSCommand ) \ [EOL] and isinstance ( response , ResponseOk ) : [EOL] await self . start_tls ( ) [EOL] finally : [EOL] await state . do_cleanup ( ) [EOL] current_command . reset ( prev_cmd ) [EOL] self . _print ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncio.AbstractServer$ 0 0 0 0 0 $asyncio.AbstractServer$ 0 0 0 $asyncio.AbstractServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.interfaces.session.LoginProtocol$ 0 $pymap.config.IMAPConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.config.IMAPConfig$ 0 0 0 0 0 0 0 $pymap.interfaces.session.LoginProtocol$ 0 0 0 0 0 $pymap.config.IMAPConfig$ 0 0 0 0 $None$ 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[proxyprotocol.ProxyProtocolResult]$ 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Awaitable[_Ret]$ 0 0 0 $typing.Awaitable[_Ret]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable[_Ret]$ 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pysasl.AuthenticationCredentials]$ 0 0 0 $state.ConnectionState$ 0 $builtins.bytes$ 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $state.ConnectionState$ 0 $pymap.parsing.state.ParsingInterrupt$ 0 $typing.List[builtins.memoryview]$ 0 0 0 0 0 $pymap.parsing.state.ParsingInterrupt$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.memoryview]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingInterrupt$ 0 0 0 0 $pymap.parsing.command.Command$ 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.memoryview]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.memoryview]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 $typing.List[builtins.memoryview]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.parsing.response.Response$ 0 0 0 0 $pymap.parsing.response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.Response$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[pymap.parsing.response.Response]$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[pymap.parsing.response.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $state.ConnectionState$ 0 $pymap.concurrent.Event$ 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 $state.ConnectionState$ 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.command.select.IdleCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.ConnectionState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , FrozenSet , List , Tuple , Sequence , Iterable [EOL] import typing [EOL] import builtins [EOL] import mailbox [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from asyncio import shield [EOL] from typing import Generic , Tuple , Optional , FrozenSet , Iterable , Sequence , List [EOL] [EOL] from pymap . concurrent import Event [EOL] from pymap . config import IMAPConfig [EOL] from pymap . exceptions import MailboxNotFound , MailboxConflict , MailboxReadOnly [EOL] from pymap . flags import FlagOp , SessionFlags , PermanentFlags [EOL] from pymap . interfaces . filter import FilterSetInterface [EOL] from pymap . interfaces . message import MessageT [EOL] from pymap . interfaces . session import SessionInterface [EOL] from pymap . interfaces . users import UsersInterface [EOL] from pymap . mailbox import MailboxSnapshot [EOL] from pymap . parsing . message import AppendMessage [EOL] from pymap . parsing . specials import SequenceSet , SearchKey , ObjectId , FetchRequirement [EOL] from pymap . parsing . specials . flag import Flag , Seen [EOL] from pymap . parsing . response . code import AppendUid , CopyUid [EOL] from pymap . search import SearchParams , SearchCriteriaSet [EOL] from pymap . selected import SelectedMailbox [EOL] [EOL] from . mailbox import MailboxDataInterface , MailboxSetInterface [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class BaseSession ( SessionInterface , Generic [ MessageT ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , owner ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _owner = owner [EOL] [EOL] @ property def owner ( self ) : [EOL] return self . _owner [EOL] [EOL] @ property def users ( self ) : [EOL] return None [comment] [EOL] [EOL] @ property @ abstractmethod def config ( self ) : [EOL] ... [EOL] [EOL] @ property @ abstractmethod def mailbox_set ( self ) : [EOL] ... [EOL] [EOL] @ property def filter_set ( self ) : [EOL] return None [EOL] [EOL] def close ( self ) : [EOL] pass [EOL] [EOL] async def cleanup ( self ) : [EOL] pass [EOL] [EOL] async def _load_updates ( self , selected , mbx ) : [EOL] if selected : [EOL] if not mbx or selected . mailbox_id != mbx . mailbox_id : [EOL] try : [EOL] mbx = await self . _get_selected ( selected ) [EOL] except MailboxNotFound : [EOL] selected . set_deleted ( ) [EOL] return selected [EOL] return await mbx . update_selected ( selected ) [EOL] return selected [EOL] [EOL] @ classmethod def _pick_selected ( cls , selected , mbx ) : [EOL] if selected and selected . mailbox_id == mbx . mailbox_id : [EOL] return selected [EOL] return mbx . selected_set . any_selected [EOL] [EOL] async def _get_mailbox ( self , name , * , try_create = False ) : [EOL] try : [EOL] return await self . mailbox_set . get_mailbox ( name ) [EOL] except KeyError as exc : [EOL] raise MailboxNotFound ( name , try_create = try_create ) from exc [EOL] [EOL] async def _get_selected ( self , selected ) : [EOL] return await self . _get_mailbox ( selected . lookup ) [EOL] [EOL] async def list_mailboxes ( self , ref_name , filter_ , subscribed = False , selected = None ) : [EOL] delimiter = self . mailbox_set . delimiter [EOL] if filter_ : [EOL] if subscribed : [EOL] list_tree = await self . mailbox_set . list_subscribed ( ) [EOL] else : [EOL] list_tree = await self . mailbox_set . list_mailboxes ( ) [EOL] ret = [ ( entry . name , delimiter , entry . attributes ) for entry in list_tree . list_matching ( ref_name , filter_ ) ] [EOL] else : [EOL] ret = [ ( [string] , delimiter , [ [string] ] ) ] [EOL] return ret , await self . _load_updates ( selected , None ) [EOL] [EOL] async def get_mailbox ( self , name , selected = None ) : [EOL] try : [EOL] mbx = await self . mailbox_set . get_mailbox ( name ) [EOL] except KeyError as exc : [EOL] raise MailboxNotFound ( name ) from exc [EOL] snapshot = await mbx . snapshot ( ) [EOL] return snapshot , await self . _load_updates ( selected , mbx ) [EOL] [EOL] async def create_mailbox ( self , name , selected = None ) : [EOL] try : [EOL] mailbox_id = await self . mailbox_set . add_mailbox ( name ) [EOL] except ValueError as exc : [EOL] raise MailboxConflict ( name ) from exc [EOL] return mailbox_id , await self . _load_updates ( selected , None ) [EOL] [EOL] async def delete_mailbox ( self , name , selected = None ) : [EOL] try : [EOL] await self . mailbox_set . delete_mailbox ( name ) [EOL] except KeyError as exc : [EOL] raise MailboxNotFound ( name ) from exc [EOL] return await self . _load_updates ( selected , None ) [EOL] [EOL] async def rename_mailbox ( self , before_name , after_name , selected = None ) : [EOL] try : [EOL] await self . mailbox_set . rename_mailbox ( before_name , after_name ) [EOL] except KeyError as exc : [EOL] raise MailboxNotFound ( before_name ) from exc [EOL] except ValueError as exc : [EOL] raise MailboxConflict ( after_name ) from exc [EOL] return await self . _load_updates ( selected , None ) [EOL] [EOL] async def subscribe ( self , name , selected = None ) : [EOL] await self . mailbox_set . set_subscribed ( name , True ) [EOL] return await self . _load_updates ( selected , None ) [EOL] [EOL] async def unsubscribe ( self , name , selected = None ) : [EOL] await self . mailbox_set . set_subscribed ( name , False ) [EOL] return await self . _load_updates ( selected , None ) [EOL] [EOL] async def append_messages ( self , name , messages , selected = None ) : [EOL] mbx = await self . _get_mailbox ( name , try_create = True ) [EOL] if mbx . readonly : [EOL] raise MailboxReadOnly ( name ) [EOL] dest_selected = self . _pick_selected ( selected , mbx ) [EOL] uids = [ ] [EOL] for append_msg in messages : [EOL] msg = await mbx . append ( append_msg , recent = not dest_selected ) [EOL] if dest_selected : [EOL] dest_selected . session_flags . add_recent ( msg . uid ) [EOL] uids . append ( msg . uid ) [EOL] return ( AppendUid ( mbx . uid_validity , uids ) , await self . _load_updates ( selected , mbx ) ) [EOL] [EOL] async def select_mailbox ( self , name , readonly = False ) : [EOL] mbx = await self . _get_mailbox ( name ) [EOL] selected = SelectedMailbox ( mbx . mailbox_id , readonly or mbx . readonly , PermanentFlags ( mbx . permanent_flags ) , SessionFlags ( mbx . session_flags ) , selected_set = mbx . selected_set , lookup = name ) [EOL] if not selected . readonly : [EOL] await mbx . claim_recent ( selected ) [EOL] snapshot = await mbx . snapshot ( ) [EOL] return snapshot , await mbx . update_selected ( selected ) [EOL] [EOL] async def check_mailbox ( self , selected , * , wait_on = None , housekeeping = False ) : [EOL] mbx = await self . _get_selected ( selected ) [EOL] if housekeeping : [EOL] await shield ( mbx . cleanup ( ) ) [EOL] return await mbx . update_selected ( selected , wait_on = wait_on ) [EOL] [EOL] async def fetch_messages ( self , selected , sequence_set , set_seen ) : [EOL] mbx = await self . _get_selected ( selected ) [EOL] ret = [ ] [EOL] for seq , cached_msg in selected . messages . get_all ( sequence_set ) : [EOL] if set_seen : [EOL] msg = await mbx . update ( cached_msg . uid , cached_msg , frozenset ( { Seen } ) , FlagOp . ADD ) [EOL] else : [EOL] msg = await mbx . get ( cached_msg . uid , cached_msg ) [EOL] if msg is not None : [EOL] ret . append ( ( seq , msg ) ) [EOL] return ret , await mbx . update_selected ( selected ) [EOL] [EOL] async def search_mailbox ( self , selected , keys ) : [EOL] mbx = await self . _get_selected ( selected ) [EOL] req = FetchRequirement . reduce ( key . requirement for key in keys ) [EOL] ret = [ ] [EOL] params = SearchParams ( selected , disabled = self . config . disable_search_keys ) [EOL] search = SearchCriteriaSet ( keys , params ) [EOL] async for seq , msg in mbx . find ( search . sequence_set , selected ) : [EOL] msg_content = await msg . load_content ( req ) [EOL] if search . matches ( seq , msg , msg_content ) : [EOL] ret . append ( ( seq , msg ) ) [EOL] return ret , await mbx . update_selected ( selected ) [EOL] [EOL] async def expunge_mailbox ( self , selected , uid_set = None ) : [EOL] if selected . readonly : [EOL] raise MailboxReadOnly ( ) [EOL] mbx = await self . _get_selected ( selected ) [EOL] if uid_set is None : [EOL] uid_set = SequenceSet . all ( uid = True ) [EOL] expunge_uids = await mbx . find_deleted ( uid_set , selected ) [EOL] await mbx . delete ( expunge_uids ) [EOL] return await mbx . update_selected ( selected ) [EOL] [EOL] async def copy_messages ( self , selected , sequence_set , mailbox ) : [EOL] mbx = await self . _get_selected ( selected ) [EOL] dest = await self . _get_mailbox ( mailbox , try_create = True ) [EOL] if dest . readonly : [EOL] raise MailboxReadOnly ( mailbox ) [EOL] dest_selected = self . _pick_selected ( selected , dest ) [EOL] uids = [ ] [EOL] for _ , source_uid in selected . messages . get_uids ( sequence_set ) : [EOL] dest_uid = await mbx . copy ( source_uid , dest , recent = not dest_selected ) [EOL] if dest_uid is not None : [EOL] if dest_selected : [EOL] dest_selected . session_flags . add_recent ( dest_uid ) [EOL] uids . append ( ( source_uid , dest_uid ) ) [EOL] if not uids : [EOL] copy_uid = None [EOL] else : [EOL] copy_uid = CopyUid ( dest . uid_validity , uids ) [EOL] return ( copy_uid , await mbx . update_selected ( selected ) ) [EOL] [EOL] async def move_messages ( self , selected , sequence_set , mailbox ) : [EOL] mbx = await self . _get_selected ( selected ) [EOL] dest = await self . _get_mailbox ( mailbox , try_create = True ) [EOL] if dest . readonly : [EOL] raise MailboxReadOnly ( mailbox ) [EOL] dest_selected = self . _pick_selected ( selected , dest ) [EOL] uids = [ ] [EOL] for _ , source_uid in selected . messages . get_uids ( sequence_set ) : [EOL] dest_uid = await mbx . move ( source_uid , dest , recent = not dest_selected ) [EOL] if dest_uid is not None : [EOL] if dest_selected : [EOL] dest_selected . session_flags . add_recent ( dest_uid ) [EOL] uids . append ( ( source_uid , dest_uid ) ) [EOL] if not uids : [EOL] copy_uid = None [EOL] else : [EOL] copy_uid = CopyUid ( dest . uid_validity , uids ) [EOL] return ( copy_uid , await mbx . update_selected ( selected ) ) [EOL] [EOL] async def update_flags ( self , selected , sequence_set , flag_set , mode = FlagOp . REPLACE ) : [EOL] if selected . readonly : [EOL] raise MailboxReadOnly ( ) [EOL] mbx = await self . _get_selected ( selected ) [EOL] permanent_flags = selected . permanent_flags & flag_set [EOL] messages = [ ] [EOL] for seq , cached_msg in selected . messages . get_all ( sequence_set ) : [EOL] uid = cached_msg . uid [EOL] msg = await mbx . update ( uid , cached_msg , permanent_flags , mode ) [EOL] if not msg . expunged : [EOL] selected . session_flags . update ( uid , flag_set , mode ) [EOL] messages . append ( ( seq , msg ) ) [EOL] return messages , await mbx . update_selected ( selected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Iterable[typing.Tuple[builtins.str,typing.Optional[builtins.str],typing.Sequence[builtins.bytes]]],typing.Optional[pymap.selected.SelectedMailbox]]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Tuple[pymap.mailbox.MailboxSnapshot,typing.Optional[pymap.selected.SelectedMailbox]]$ 0 0 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Tuple[pymap.parsing.specials.ObjectId,typing.Optional[pymap.selected.SelectedMailbox]]$ 0 0 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Optional[pymap.selected.SelectedMailbox]$ 0 0 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Optional[pymap.selected.SelectedMailbox]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Optional[pymap.selected.SelectedMailbox]$ 0 0 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Optional[pymap.selected.SelectedMailbox]$ 0 0 0 $builtins.str$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.Tuple[pymap.parsing.response.code.AppendUid,typing.Optional[pymap.selected.SelectedMailbox]]$ 0 0 0 $builtins.str$ 0 $typing.Sequence[pymap.parsing.message.AppendMessage]$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.message.AppendMessage]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 $typing.Tuple[pymap.mailbox.MailboxSnapshot,pymap.selected.SelectedMailbox]$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.concurrent.Event$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 $pymap.concurrent.Event$ 0 $pymap.concurrent.Event$ 0 0 0 0 0 $typing.Tuple[typing.Iterable[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]],pymap.selected.SelectedMailbox]$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $pymap.parsing.specials.SequenceSet$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $typing.Tuple[typing.Iterable[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]],pymap.selected.SelectedMailbox]$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $typing.FrozenSet[pymap.parsing.specials.SearchKey]$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.SearchKey]$ 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.SearchKey]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $typing.Tuple[typing.Optional[pymap.parsing.response.code.CopyUid],pymap.selected.SelectedMailbox]$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $pymap.parsing.specials.SequenceSet$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 $typing.Tuple[typing.Optional[pymap.parsing.response.code.CopyUid],pymap.selected.SelectedMailbox]$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $pymap.parsing.specials.SequenceSet$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 $typing.Tuple[typing.Iterable[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]],pymap.selected.SelectedMailbox]$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $pymap.parsing.specials.SequenceSet$ 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.FlagOp$ 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.flags.FlagOp$ 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.FlagOp$ 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT]]$ 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0
[EOL] from typing import Optional , FrozenSet , Tuple , Sequence , AsyncIterable , Iterable [EOL] import builtins [EOL] import typing [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from typing import TypeVar , Optional , Tuple , Sequence , FrozenSet , Iterable , AsyncIterable [EOL] from typing_extensions import Protocol [EOL] [EOL] from pymap . concurrent import Event [EOL] from pymap . flags import FlagOp [EOL] from pymap . interfaces . message import MessageT_co , CachedMessage [EOL] from pymap . listtree import ListTree [EOL] from pymap . mailbox import MailboxSnapshot [EOL] from pymap . parsing . message import AppendMessage [EOL] from pymap . parsing . specials import ObjectId , SequenceSet [EOL] from pymap . parsing . specials . flag import get_system_flags , Flag , Deleted , Recent [EOL] from pymap . selected import SelectedSet , SelectedMailbox [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] MailboxDataT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] MailboxDataT_co = TypeVar ( [string] , bound = [string] , covariant = True ) [EOL] [EOL] [EOL] class MailboxDataInterface ( Protocol [ MessageT_co ] ) : [EOL] [docstring] [EOL] [EOL] @ property @ abstractmethod def mailbox_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def readonly ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def uid_validity ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property def permanent_flags ( self ) : [EOL] [docstring] [EOL] return get_system_flags ( ) - { Recent } [EOL] [EOL] @ property def session_flags ( self ) : [EOL] [docstring] [EOL] return frozenset ( { Recent } ) [EOL] [EOL] @ property @ abstractmethod def selected_set ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def update_selected ( self , selected , * , wait_on = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def append ( self , append_msg , * , recent = False ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def copy ( self , uid , destination , * , recent = False ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def move ( self , uid , destination , * , recent = False ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def get ( self , uid , cached_msg ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def update ( self , uid , cached_msg , flag_set , mode ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def delete ( self , uids ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def claim_recent ( self , selected ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def cleanup ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def snapshot ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] async def find ( self , seq_set , selected ) : [EOL] [docstring] [EOL] for seq , cached_msg in selected . messages . get_all ( seq_set ) : [EOL] msg = await self . get ( cached_msg . uid , cached_msg ) [EOL] if msg is not None : [EOL] yield ( seq , msg ) [EOL] [EOL] async def find_deleted ( self , seq_set , selected ) : [EOL] [docstring] [EOL] session_flags = selected . session_flags [EOL] return [ msg . uid async for _ , msg in self . find ( seq_set , selected ) if Deleted in msg . get_flags ( session_flags ) ] [EOL] [EOL] [EOL] class MailboxSetInterface ( Protocol [ MailboxDataT_co ] ) : [EOL] [docstring] [EOL] [EOL] @ property @ abstractmethod def delimiter ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def set_subscribed ( self , name , subscribed ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def list_subscribed ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def list_mailboxes ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def get_mailbox ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def add_mailbox ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def delete_mailbox ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def rename_mailbox ( self , before , after ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.message.MessageT_co$ 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $MailboxDataT$ 0 $builtins.int$ 0 $MailboxDataT$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $MailboxDataT$ 0 $builtins.int$ 0 $MailboxDataT$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.message.MessageT_co$ 0 0 0 $builtins.int$ 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.message.MessageT_co$ 0 0 0 $builtins.int$ 0 $pymap.interfaces.message.CachedMessage$ 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.FlagOp$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.mailbox.MailboxSnapshot$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.Tuple[builtins.int,pymap.interfaces.message.MessageT_co]]$ 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.listtree.ListTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.listtree.ListTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MailboxDataT_co$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0
[EOL] from typing import Type [EOL] import interfaces [EOL] import typing [EOL] import plugin [EOL] from __future__ import annotations [EOL] [EOL] from typing import Type [EOL] [EOL] from . . interfaces . backend import BackendInterface [EOL] from . . plugin import Plugin [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [comment] [EOL] backends = Plugin ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $plugin.Plugin[typing.Type[interfaces.backend.BackendInterface]]$ 0 0 0 0 0 0
[EOL] from typing import Union , FrozenSet , Mapping , Type , Sequence , IO , Iterable [EOL] import typing [EOL] import builtins [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from typing import IO , TypeVar , Type , Iterable , Union , Mapping , FrozenSet , Sequence [EOL] [EOL] from pymap . parsing . specials . flag import Flag , Seen , Flagged , Deleted , Draft , Answered [EOL] [EOL] from . io import FileReadable [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _MFT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] class MaildirFlags ( FileReadable ) : [EOL] [docstring] [EOL] [EOL] _from_sys = { Seen : [string] , Flagged : [string] , Deleted : [string] , Draft : [string] , Answered : [string] } [EOL] [EOL] _to_sys = { [string] : Seen , [string] : Flagged , [string] : Deleted , [string] : Draft , [string] : Answered } [EOL] [EOL] def __init__ ( self , keywords ) : [EOL] super ( ) . __init__ ( ) [EOL] if len ( keywords ) > [number] : [EOL] raise ValueError ( keywords ) [EOL] self . _keywords = frozenset ( keywords ) [EOL] self . _to_kwd = { chr ( ord ( [string] ) + i ) : kwd for i , kwd in enumerate ( keywords ) } [EOL] self . _from_kwd = { kwd : chr ( ord ( [string] ) + i ) for i , kwd in enumerate ( keywords ) } [EOL] [EOL] @ property def permanent_flags ( self ) : [EOL] [docstring] [EOL] return self . system_flags | self . keywords [EOL] [EOL] @ property def system_flags ( self ) : [EOL] [docstring] [EOL] return frozenset ( self . _from_sys . keys ( ) ) [EOL] [EOL] @ property def keywords ( self ) : [EOL] [docstring] [EOL] return self . _keywords [EOL] [EOL] def to_maildir ( self , flags ) : [EOL] [docstring] [EOL] codes = [ ] [EOL] for flag in flags : [EOL] if isinstance ( flag , bytes ) : [EOL] flag = Flag ( flag ) [EOL] from_sys = self . _from_sys . get ( flag ) [EOL] if from_sys is not None : [EOL] codes . append ( from_sys ) [EOL] else : [EOL] from_kwd = self . _from_kwd . get ( flag ) [EOL] if from_kwd is not None : [EOL] codes . append ( from_kwd ) [EOL] return [string] . join ( codes ) [EOL] [EOL] def from_maildir ( self , codes ) : [EOL] [docstring] [EOL] flags = set ( ) [EOL] for code in codes : [EOL] if code == [string] : [EOL] break [EOL] to_sys = self . _to_sys . get ( code ) [EOL] if to_sys is not None : [EOL] flags . add ( to_sys ) [EOL] else : [EOL] to_kwd = self . _to_kwd . get ( code ) [EOL] if to_kwd is not None : [EOL] flags . add ( to_kwd ) [EOL] return frozenset ( flags ) [EOL] [EOL] @ classmethod def get_file ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def get_default ( cls , base_dir ) : [EOL] return cls ( [ ] ) [EOL] [EOL] @ classmethod def open ( cls , base_dir , fp ) : [EOL] ret = [ ] [EOL] for line in fp : [EOL] i , kwd = line . split ( ) [EOL] if kwd . startswith ( [string] ) : [EOL] raise ValueError ( kwd ) [EOL] ret . append ( ( i , kwd ) ) [EOL] return cls ( [ Flag ( kwd ) for _ , kwd in sorted ( ret ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[pymap.parsing.specials.flag.Flag,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Iterable[typing.Union[builtins.bytes,pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Union[builtins.bytes,pymap.parsing.specials.flag.Flag]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $_MFT$ 0 $typing.Type[_MFT]$ 0 $builtins.str$ 0 0 0 0 $typing.Type[_MFT]$ 0 0 0 0 0 0 0 0 0 $_MFT$ 0 $typing.Type[_MFT]$ 0 $builtins.str$ 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[_MFT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Mapping , Type , ClassVar , Dict , IO , Iterable [EOL] import typing [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import random [EOL] from collections import OrderedDict [EOL] from dataclasses import dataclass [EOL] from typing import IO , Optional , Iterable , Mapping , Dict , ClassVar , TypeVar , Type [EOL] [EOL] from pymap . mailbox import MailboxSnapshot [EOL] [EOL] from . io import FileWriteable [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] _UDT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] @ dataclass ( frozen = True ) class Record : [EOL] [docstring] [EOL] [EOL] uid = ... [EOL] fields = ... [EOL] filename = ... [EOL] [EOL] @ property def key ( self ) : [EOL] [docstring] [EOL] return self . filename . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] [EOL] class UidList ( FileWriteable ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] FILE_NAME = [string] [EOL] [EOL] [comment] [EOL] LOCK_FILE = [string] [EOL] [EOL] def __init__ ( self , base_dir , uid_validity , next_uid , global_uid = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _base_dir = base_dir [EOL] self . uid_validity = uid_validity [EOL] self . next_uid = next_uid [EOL] self . global_uid = global_uid or self . _create_guid ( ) [EOL] self . _records = OrderedDict ( ) [EOL] [EOL] @ property def records ( self ) : [EOL] [docstring] [EOL] return self . _records . values ( ) [EOL] [EOL] def get ( self , uid ) : [EOL] [docstring] [EOL] return self . _records [ uid ] [EOL] [EOL] def get_all ( self , uids ) : [EOL] [docstring] [EOL] return { uid : self . _records [ uid ] for uid in uids if uid in self . _records } [EOL] [EOL] def set ( self , rec ) : [EOL] [docstring] [EOL] self . _records [ rec . uid ] = rec [EOL] [EOL] def remove ( self , uid ) : [EOL] [docstring] [EOL] del self . _records [ uid ] [EOL] [EOL] @ classmethod def _build_line ( cls , rec ) : [EOL] parts = [ [string] % rec . uid ] [EOL] for key , val in sorted ( rec . fields . items ( ) ) : [EOL] if val is not None : [EOL] parts . append ( [string] ) [EOL] parts . append ( key [ [number] : [number] ] ) [EOL] parts . append ( val ) [EOL] parts . append ( [string] ) [EOL] parts . append ( rec . filename ) [EOL] parts . append ( [string] ) [EOL] return [string] . join ( parts ) [EOL] [EOL] @ classmethod def _read_line ( cls , line ) : [EOL] before , filename = line . split ( [string] , [number] ) [EOL] fields = { } [EOL] data = before . split ( [string] ) [EOL] num = int ( data [ [number] ] ) [EOL] for col in data [ [number] : ] : [EOL] if col : [EOL] fields [ col [ [number] ] ] = col [ [number] : ] [EOL] return Record ( num , fields , filename . rstrip ( ) ) [EOL] [EOL] @ classmethod def _read_header ( cls , base_dir , line ) : [EOL] data = line . split ( ) [EOL] if data [ [number] ] != [string] : [EOL] raise ValueError ( line ) [EOL] uid_validity = None [EOL] next_uid = None [EOL] global_uid = None [EOL] for field in data [ [number] : ] : [EOL] if field [ [number] ] == [string] : [EOL] uid_validity = int ( field [ [number] : ] ) [EOL] elif field [ [number] ] == [string] : [EOL] next_uid = int ( field [ [number] : ] ) [EOL] elif field [ [number] ] == [string] : [EOL] global_uid = field [ [number] : ] . encode ( [string] ) [EOL] if uid_validity is None or next_uid is None or global_uid is None : [EOL] raise ValueError ( line ) [EOL] return cls ( base_dir , uid_validity , next_uid , global_uid ) [EOL] [EOL] @ classmethod def _create_guid ( cls ) : [EOL] return [string] % random . getrandbits ( [number] ) [EOL] [EOL] def _build_header ( self ) : [EOL] global_uid = self . global_uid . decode ( [string] ) [EOL] return [string] . join ( [ [string] , str ( self . uid_validity ) , [string] , str ( self . next_uid ) , [string] , global_uid , [string] ] ) [EOL] [EOL] @ classmethod def get_file ( cls ) : [EOL] return cls . FILE_NAME [EOL] [EOL] @ classmethod def get_lock ( cls ) : [EOL] return cls . LOCK_FILE [EOL] [EOL] def get_dir ( self ) : [EOL] return self . _base_dir [EOL] [EOL] @ classmethod def get_default ( cls , base_dir ) : [EOL] return cls ( base_dir , MailboxSnapshot . new_uid_validity ( ) , [number] ) [EOL] [EOL] def write ( self , fp ) : [EOL] fp . write ( self . _build_header ( ) ) [EOL] for rec in self . records : [EOL] fp . write ( self . _build_line ( rec ) ) [EOL] [EOL] @ classmethod def open ( cls , base_dir , fp ) : [EOL] header = fp . readline ( ) [EOL] ret = cls . _read_header ( base_dir , header ) [EOL] return ret [EOL] [EOL] def read ( self , fp ) : [EOL] for line in fp : [EOL] self . set ( self . _read_line ( line ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Mapping[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.str]$ 0 0 0 0 0 0 $typing.ClassVar[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,Record]$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Record$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Mapping[builtins.int,Record]$ 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Record$ 0 0 0 0 0 0 0 0 0 $Record$ 0 0 0 0 $Record$ 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $Record$ 0 0 0 0 0 0 0 0 $Record$ 0 0 0 0 0 0 0 0 0 0 0 $Record$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Record$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Record$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $_UDT$ 0 $typing.Type[_UDT]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[_UDT]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_UDT$ 0 $typing.Type[_UDT]$ 0 $builtins.str$ 0 0 0 0 $typing.Type[_UDT]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_UDT$ 0 $typing.Type[_UDT]$ 0 $builtins.str$ 0 $typing.IO[builtins.str]$ 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 $typing.Type[_UDT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Type , Dict , Sequence , IO [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from collections import OrderedDict [EOL] from typing import TypeVar , Type , Sequence , Dict , IO , Optional [EOL] [EOL] from . io import FileWriteable [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _ST = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] class Subscriptions ( FileWriteable ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , base_dir ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _base_dir = base_dir [EOL] self . _subscribed = OrderedDict ( ) [EOL] [EOL] @ property def subscribed ( self ) : [EOL] [docstring] [EOL] return list ( self . _subscribed . keys ( ) ) [EOL] [EOL] def add ( self , folder ) : [EOL] [docstring] [EOL] self . _subscribed [ folder ] = None [EOL] [EOL] def remove ( self , folder ) : [EOL] [docstring] [EOL] try : [EOL] del self . _subscribed [ folder ] [EOL] except KeyError : [EOL] pass [EOL] [EOL] def set ( self , folder , subscribed ) : [EOL] [docstring] [EOL] if subscribed : [EOL] self . add ( folder ) [EOL] else : [EOL] self . remove ( folder ) [EOL] [EOL] @ classmethod def get_file ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def get_lock ( cls ) : [EOL] return [string] [EOL] [EOL] @ classmethod def get_default ( cls , base_dir ) : [EOL] return cls ( base_dir ) [EOL] [EOL] def get_dir ( self ) : [EOL] return self . _base_dir [EOL] [EOL] @ classmethod def open ( cls , base_dir , fp ) : [EOL] return cls ( base_dir ) [EOL] [EOL] def read ( self , fp ) : [EOL] for line in fp : [EOL] self . add ( line . rstrip ( ) ) [EOL] [EOL] def write ( self , fp ) : [EOL] for sub in self . _subscribed : [EOL] fp . write ( sub + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,None]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $_ST$ 0 $typing.Type[_ST]$ 0 $builtins.str$ 0 0 0 0 $typing.Type[_ST]$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ST$ 0 $typing.Type[_ST]$ 0 $builtins.str$ 0 $typing.IO[builtins.str]$ 0 0 0 0 $typing.Type[_ST]$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0
[EOL] from typing import Type , Iterable , Sequence [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import errno [EOL] import os [EOL] import os . path [EOL] from abc import abstractmethod , ABCMeta [EOL] from mailbox import Maildir , NoSuchMailboxError [EOL] from typing import TypeVar , Type , Sequence , Iterable [EOL] from typing_extensions import Protocol [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _Parts = Sequence [ str ] [EOL] _MaildirT = TypeVar ( [string] , bound = Maildir ) [EOL] [EOL] [EOL] class MaildirLayout ( Protocol [ _MaildirT ] ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def get ( cls , path , layout , maildir_type ) : [EOL] [docstring] [EOL] if layout == [string] : [EOL] return DefaultLayout ( path , maildir_type ) [EOL] elif layout == [string] : [EOL] return FilesystemLayout ( path , maildir_type ) [EOL] else : [EOL] raise ValueError ( layout ) [EOL] [EOL] @ property @ abstractmethod def path ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_path ( self , name , delimiter ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def list_folders ( self , delimiter , top = [string] ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_folder ( self , name , delimiter ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def add_folder ( self , name , delimiter ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def remove_folder ( self , name , delimiter ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def rename_folder ( self , source_name , dest_name , delimiter ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class _BaseLayout ( MaildirLayout [ _MaildirT ] , metaclass = ABCMeta ) : [EOL] [EOL] def __init__ ( self , path , maildir_type ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _path = path [EOL] self . _maildir = maildir_type [EOL] [EOL] @ property def path ( self ) : [EOL] return self . _path [EOL] [EOL] @ classmethod def _split ( cls , name , delimiter ) : [EOL] if name == [string] : [EOL] return [ ] [EOL] return name . split ( delimiter ) [EOL] [EOL] @ classmethod def _join ( cls , parts , delimiter ) : [EOL] if not parts : [EOL] return [string] [EOL] return delimiter . join ( parts ) [EOL] [EOL] def _can_remove ( self , parts ) : [EOL] return True [EOL] [EOL] @ abstractmethod def _get_path ( self , parts ) : [EOL] ... [EOL] [EOL] @ abstractmethod def _list_folders ( self , parts ) : [EOL] ... [EOL] [EOL] @ abstractmethod def _rename_folder ( self , source_parts , dest_parts ) : [EOL] ... [EOL] [EOL] def get_path ( self , name , delimiter ) : [EOL] parts = self . _split ( name , delimiter ) [EOL] return self . _get_path ( parts ) [EOL] [EOL] def list_folders ( self , delimiter , top = [string] ) : [EOL] parts = self . _split ( top , delimiter ) [EOL] return [ self . _join ( sub_parts , delimiter ) for sub_parts in self . _list_folders ( parts ) ] [EOL] [EOL] def get_folder ( self , name , delimiter ) : [EOL] path = self . get_path ( name , delimiter ) [EOL] try : [EOL] return self . _maildir ( path , create = False ) [EOL] except NoSuchMailboxError : [EOL] raise FileNotFoundError ( path ) [EOL] [EOL] def add_folder ( self , name , delimiter ) : [EOL] parts = self . _split ( name , delimiter ) [EOL] for i in range ( [number] , len ( parts ) - [number] ) : [EOL] path = self . _get_path ( parts [ [number] : i ] ) [EOL] if not os . path . isdir ( path ) : [EOL] raise FileNotFoundError ( path ) [EOL] path = self . _get_path ( parts ) [EOL] self . _maildir ( path , create = True ) [EOL] maildirfolder = os . path . join ( path , [string] ) [EOL] with open ( maildirfolder , [string] ) : [EOL] pass [EOL] [EOL] def remove_folder ( self , name , delimiter ) : [EOL] parts = self . _split ( name , delimiter ) [EOL] path = self . _get_path ( parts ) [EOL] if not self . _can_remove ( parts ) : [EOL] path = self . _get_path ( parts ) [EOL] raise OSError ( errno . ENOTEMPTY , [string] + repr ( path ) ) [EOL] for root , dirs , files in os . walk ( path , topdown = False ) : [EOL] for entry in files : [EOL] os . remove ( os . path . join ( root , entry ) ) [EOL] for entry in dirs : [EOL] os . rmdir ( os . path . join ( root , entry ) ) [EOL] os . rmdir ( path ) [EOL] [EOL] def rename_folder ( self , source_name , dest_name , delimiter ) : [EOL] source_parts = self . _split ( source_name , delimiter ) [EOL] dest_parts = self . _split ( dest_name , delimiter ) [EOL] for i in range ( [number] , len ( dest_parts ) - [number] ) : [EOL] parts = dest_parts [ [number] : i ] [EOL] path = self . _get_path ( parts ) [EOL] if not os . path . isdir ( path ) : [EOL] name = self . _join ( parts , delimiter ) [EOL] self . add_folder ( name , delimiter ) [EOL] self . _rename_folder ( source_parts , dest_parts ) [EOL] [EOL] [EOL] class DefaultLayout ( _BaseLayout [ _MaildirT ] ) : [EOL] [docstring] [EOL] [EOL] def _get_path ( self , parts ) : [EOL] return os . path . join ( self . _path , self . _get_subdir ( parts ) ) [EOL] [EOL] @ classmethod def _get_subdir ( cls , parts ) : [EOL] if not parts : [EOL] return [string] [EOL] return [string] + [string] . join ( parts ) [EOL] [EOL] @ classmethod def _get_parts ( cls , subdir ) : [EOL] if not subdir : [EOL] return [ ] [EOL] return subdir [ [number] : ] . split ( [string] ) [EOL] [EOL] def _list_folders ( self , parts ) : [EOL] subdir = self . _get_subdir ( parts ) [EOL] path = self . _get_path ( parts ) [EOL] if not os . path . isdir ( path ) : [EOL] return [EOL] yield parts [EOL] for elem in os . listdir ( self . _path ) : [EOL] if elem in ( [string] , [string] , [string] ) : [EOL] pass [EOL] elif not subdir or elem . startswith ( subdir + [string] ) : [EOL] elem_path = os . path . join ( self . _path , elem ) [EOL] if os . path . isdir ( elem_path ) : [EOL] yield self . _get_parts ( elem ) [EOL] [EOL] def _rename_folder ( self , source_parts , dest_parts ) : [EOL] subdir = self . _get_subdir ( source_parts ) [EOL] dest_subdir = self . _get_subdir ( dest_parts ) [EOL] for elem in os . listdir ( self . _path ) : [EOL] if elem == subdir or elem . startswith ( subdir + [string] ) : [EOL] elem_path = os . path . join ( self . _path , elem ) [EOL] if os . path . isdir ( elem_path ) : [EOL] dest_elem = dest_subdir + elem [ len ( subdir ) : ] [EOL] dest_elem_path = os . path . join ( self . _path , dest_elem ) [EOL] os . rename ( elem_path , dest_elem_path ) [EOL] [EOL] [EOL] class FilesystemLayout ( _BaseLayout [ _MaildirT ] ) : [EOL] [docstring] [EOL] [EOL] def _get_path ( self , parts ) : [EOL] return os . path . join ( self . _path , * parts ) [EOL] [EOL] def _can_remove ( self , parts ) : [EOL] path = self . _get_path ( parts ) [EOL] for elem in os . listdir ( path ) : [EOL] if elem not in ( [string] , [string] , [string] ) : [EOL] elem_path = os . path . join ( path , elem ) [EOL] if os . path . isdir ( elem_path ) : [EOL] return False [EOL] return True [EOL] [EOL] def _list_folders ( self , parts ) : [EOL] path = self . _get_path ( parts ) [EOL] if not os . path . isdir ( path ) : [EOL] return [EOL] yield parts [EOL] for elem in os . listdir ( path ) : [EOL] if elem not in ( [string] , [string] , [string] ) : [EOL] for sub_parts in self . _list_folders ( list ( parts ) + [ elem ] ) : [EOL] yield sub_parts [EOL] [EOL] def _rename_folder ( self , source_parts , dest_parts ) : [EOL] path = self . _get_path ( source_parts ) [EOL] dest_path = self . _get_path ( dest_parts ) [EOL] os . rename ( path , dest_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MaildirLayout[_MaildirT]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Type[_MaildirT]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_MaildirT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_MaildirT]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $_MaildirT$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Type[_MaildirT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Type[_MaildirT]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 $builtins.str$ 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 0 0 0 $builtins.bool$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $typing.Iterable[_Parts]$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_Parts$ 0 $_Parts$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_MaildirT$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 $_Parts$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[_Parts]$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_Parts$ 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 $builtins.bool$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[_Parts]$ 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_Parts$ 0 $_Parts$ 0 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 $_Parts$ 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , AsyncIterator , Type , IO , AsyncContextManager [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import os [EOL] import os . path [EOL] from abc import abstractmethod , ABCMeta [EOL] from contextlib import asynccontextmanager [EOL] from tempfile import NamedTemporaryFile [EOL] from typing import TypeVar , Type , Generic , Optional , IO , AsyncContextManager , AsyncIterator [EOL] [EOL] from pymap . concurrent import FileLock [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _RT = TypeVar ( [string] , bound = [string] ) [EOL] _WT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [EOL] class NoChanges ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class FileReadable ( metaclass = ABCMeta ) : [EOL] [EOL] @ classmethod @ abstractmethod def get_file ( cls ) : [EOL] ... [EOL] [EOL] @ classmethod def get_lock ( cls ) : [EOL] return None [EOL] [EOL] @ classmethod @ abstractmethod def get_default ( cls , base_dir ) : [EOL] ... [EOL] [EOL] @ classmethod @ abstractmethod def open ( cls , base_dir , fp ) : [EOL] ... [EOL] [EOL] def read ( self , fp ) : [EOL] pass [EOL] [EOL] @ classmethod @ asynccontextmanager async def _noop_lock ( cls ) : [EOL] yield [EOL] [EOL] @ classmethod def read_lock ( cls , base_dir ) : [EOL] lock_file = cls . get_lock ( ) [EOL] if lock_file : [EOL] path = os . path . join ( base_dir , lock_file ) [EOL] return FileLock ( path ) . read_lock ( ) [EOL] else : [EOL] return cls . _noop_lock ( ) [EOL] [EOL] @ classmethod def write_lock ( cls , base_dir ) : [EOL] lock_file = cls . get_lock ( ) [EOL] if lock_file : [EOL] path = os . path . join ( base_dir , lock_file ) [EOL] return FileLock ( path ) . write_lock ( ) [EOL] else : [EOL] return cls . _noop_lock ( ) [EOL] [EOL] @ classmethod def file_exists ( cls , base_dir ) : [EOL] path = os . path . join ( base_dir , cls . get_file ( ) ) [EOL] return os . path . exists ( path ) [EOL] [EOL] @ classmethod def file_open ( cls , base_dir ) : [EOL] path = os . path . join ( base_dir , cls . get_file ( ) ) [EOL] try : [EOL] with open ( path , [string] ) as in_file : [EOL] return cls . open ( base_dir , in_file ) [EOL] except FileNotFoundError : [EOL] return cls . get_default ( base_dir ) [EOL] [EOL] @ classmethod def file_read ( cls , base_dir ) : [EOL] path = os . path . join ( base_dir , cls . get_file ( ) ) [EOL] try : [EOL] with open ( path , [string] ) as in_file : [EOL] ret = cls . open ( base_dir , in_file ) [EOL] ret . read ( in_file ) [EOL] return ret [EOL] except FileNotFoundError : [EOL] return cls . get_default ( base_dir ) [EOL] [EOL] @ classmethod def with_open ( cls , base_dir ) : [EOL] return _FileReadWith ( base_dir , cls , True ) [EOL] [EOL] @ classmethod def with_read ( cls , base_dir ) : [EOL] return _FileReadWith ( base_dir , cls , False ) [EOL] [EOL] [EOL] class FileWriteable ( FileReadable , metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def get_dir ( self ) : [EOL] ... [EOL] [EOL] @ abstractmethod def write ( self , fp ) : [EOL] ... [EOL] [EOL] @ classmethod def delete ( cls , base_dir ) : [EOL] path = os . path . join ( base_dir , cls . get_file ( ) ) [EOL] try : [EOL] os . unlink ( path ) [EOL] except OSError : [EOL] pass [EOL] [EOL] def file_write ( self ) : [EOL] filename = self . get_file ( ) [EOL] base_dir = self . get_dir ( ) [EOL] tmp_dir = os . path . join ( base_dir , [string] ) [EOL] path = os . path . join ( base_dir , filename ) [EOL] with NamedTemporaryFile ( [string] , dir = tmp_dir , delete = False ) as tmp : [EOL] self . write ( tmp ) [EOL] tmp_path = os . path . join ( base_dir , tmp . name ) [EOL] os . rename ( tmp_path , path ) [EOL] [EOL] @ classmethod def with_write ( cls , base_dir ) : [EOL] return _FileWriteWith ( base_dir , cls ) [EOL] [EOL] [EOL] class _FileReadWith ( Generic [ _RT ] ) : [EOL] [EOL] def __init__ ( self , base_dir , cls , only_open ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _base_dir = base_dir [EOL] self . _cls = cls [EOL] self . _obj = None [EOL] self . _only_open = only_open [EOL] [EOL] async def __aenter__ ( self ) : [EOL] base_dir = self . _base_dir [EOL] cls = self . _cls [EOL] func = cls . file_open if self . _only_open else cls . file_read [EOL] async with cls . read_lock ( base_dir ) : [EOL] self . _obj = obj = func ( base_dir ) [EOL] return obj [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] return False [EOL] [EOL] [EOL] class _FileWriteWith ( Generic [ _WT ] ) : [EOL] [EOL] def __init__ ( self , base_dir , cls ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _base_dir = base_dir [EOL] self . _cls = cls [EOL] self . _exists = False [EOL] self . _lock = None [EOL] self . _obj = None [EOL] [EOL] async def _acquire_lock ( self ) : [EOL] self . _lock = self . _cls . write_lock ( self . _base_dir ) [EOL] await self . _lock . __aenter__ ( ) [EOL] [EOL] async def _release_lock ( self ) : [EOL] lock = self . _lock [EOL] if not lock : [EOL] raise RuntimeError ( ) [comment] [EOL] await lock . __aexit__ ( None , None , None ) [EOL] [EOL] async def __aenter__ ( self ) : [EOL] base_dir = self . _base_dir [EOL] cls = self . _cls [EOL] await self . _acquire_lock ( ) [EOL] self . _exists = cls . file_exists ( base_dir ) [EOL] self . _obj = obj = cls . file_read ( base_dir ) [EOL] return obj [EOL] [EOL] def _write_obj ( self ) : [EOL] obj = self . _obj [EOL] if not obj : [EOL] raise RuntimeError ( ) [comment] [EOL] obj . file_write ( ) [EOL] [EOL] async def __aexit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] try : [EOL] if exc_type : [EOL] if issubclass ( exc_type , NoChanges ) : [EOL] if not self . _exists : [EOL] self . _write_obj ( ) [EOL] return True [EOL] else : [EOL] return False [EOL] self . _write_obj ( ) [EOL] return False [EOL] finally : [EOL] await self . _release_lock ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_RT$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $_RT$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncContextManager[None]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncContextManager[None]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_RT$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_RT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[_RT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Type[_RT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $_RT$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_RT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[_RT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[_RT]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $_FileReadWith[_RT]$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_RT]$ 0 0 0 0 0 0 0 0 $_FileReadWith[_RT]$ 0 $typing.Type[_RT]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_RT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_FileWriteWith[_WT]$ 0 $typing.Type[_WT]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Type[_WT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Type[_RT]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Type[_RT]$ 0 0 0 $typing.Optional[_RT]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $_RT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Type[_WT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Type[_WT]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.AsyncContextManager[None]]$ 0 0 0 0 0 $typing.Optional[_WT]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_WT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Iterable [EOL] import pymap [EOL] import aioredis [EOL] import builtins [EOL] import datetime [EOL] import keys [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from datetime import datetime [EOL] from typing import Optional , Iterable [EOL] [EOL] import msgpack [comment] [EOL] from aioredis import Redis [comment] [EOL] [EOL] from pymap . message import BaseMessage , BaseLoadedMessage [EOL] from pymap . mime import MessageContent , MessageHeader , MessageBody [EOL] from pymap . parsing . specials import Flag , ObjectId , FetchRequirement [EOL] [EOL] from . keys import NamespaceKeys , ContentKeys [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class Message ( BaseMessage ) : [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , uid , internal_date , permanent_flags , * , expunged = False , email_id = None , thread_id = None , redis = None , ns_keys = None ) : [EOL] super ( ) . __init__ ( uid , internal_date , permanent_flags , expunged = expunged , email_id = email_id , thread_id = thread_id ) [EOL] self . _redis = redis [EOL] self . _ns_keys = ns_keys [EOL] [EOL] async def _load_full ( self , redis , ct_keys ) : [EOL] literal , full_json_raw = await redis . hmget ( ct_keys . data , [string] , [string] ) [EOL] if literal is None or full_json_raw is None : [EOL] raise ValueError ( f' [string] { self . email_id }' ) [EOL] full_json = msgpack . unpackb ( full_json_raw , raw = False ) [EOL] return MessageContent . from_json ( literal , full_json ) [EOL] [EOL] async def _load_header ( self , redis , ct_keys ) : [EOL] literal , header_json_raw = await redis . hmget ( ct_keys . data , [string] , [string] ) [EOL] if literal is None or header_json_raw is None : [EOL] raise ValueError ( f' [string] { self . email_id }' ) [EOL] header_json = msgpack . unpackb ( header_json_raw , raw = False ) [EOL] header = MessageHeader . from_json ( literal , header_json ) [EOL] body = MessageBody . empty ( ) [EOL] return MessageContent ( literal , header , body ) [EOL] [EOL] async def load_content ( self , requirement ) : [EOL] redis = self . _redis [EOL] ns_keys = self . _ns_keys [EOL] if redis is None or ns_keys is None : [EOL] return LoadedMessage ( self , requirement , None ) [EOL] ct_keys = ContentKeys ( ns_keys , self . email_id ) [EOL] content = None [EOL] if requirement & FetchRequirement . BODY : [EOL] content = await self . _load_full ( redis , ct_keys ) [EOL] elif requirement & FetchRequirement . HEADER : [EOL] content = await self . _load_header ( redis , ct_keys ) [EOL] return LoadedMessage ( self , requirement , content ) [EOL] [EOL] @ classmethod def copy_expunged ( cls , msg ) : [EOL] return cls ( msg . uid , msg . internal_date , msg . permanent_flags , expunged = True , email_id = msg . email_id , thread_id = msg . thread_id , redis = msg . _redis , ns_keys = msg . _ns_keys ) [EOL] [EOL] [EOL] class LoadedMessage ( BaseLoadedMessage ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $datetime.datetime$ 0 $typing.Iterable[pymap.parsing.specials.Flag]$ 0 0 0 $builtins.bool$ 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 $aioredis.Redis$ 0 0 0 $keys.NamespaceKeys$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $datetime.datetime$ 0 $typing.Iterable[pymap.parsing.specials.Flag]$ 0 $builtins.bool$ 0 $builtins.bool$ 0 $pymap.parsing.specials.ObjectId$ 0 $pymap.parsing.specials.ObjectId$ 0 $pymap.parsing.specials.ObjectId$ 0 $pymap.parsing.specials.ObjectId$ 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 $keys.NamespaceKeys$ 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 $aioredis.Redis$ 0 $keys.ContentKeys$ 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 $keys.ContentKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 $aioredis.Redis$ 0 $keys.ContentKeys$ 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 $keys.ContentKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedMessage$ 0 0 0 $pymap.parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 $Message$ 0 0 0 $Message$ 0 0 0 0 0 0 $Message$ 0 0 0 $Message$ 0 0 0 $Message$ 0 0 0 0 0 0 0 0 0 $Message$ 0 0 0 0 0 $Message$ 0 0 0 0 0 $Message$ 0 0 0 0 0 $Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Awaitable , Callable , ClassVar , NoReturn [EOL] import keys [EOL] import builtins [EOL] import aioredis [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import asyncio [EOL] import logging [EOL] from contextlib import closing [EOL] from typing import ClassVar , Callable , Awaitable , NoReturn [EOL] [EOL] from aioredis import Redis , ConnectionClosedError [comment] [EOL] [EOL] from . keys import GlobalKeys , CleanupKeys , NamespaceKeys , ContentKeys , MailboxKeys [EOL] from . scripts . cleanup import CleanupScripts [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] _log = logging . getLogger ( __name__ ) [EOL] _scripts = CleanupScripts ( ) [EOL] [EOL] [EOL] class CleanupTask : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] connection_delay = [number] [EOL] [EOL] def __init__ ( self , connect_redis , global_keys ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _connect_redis = connect_redis [EOL] self . _global_keys = global_keys [EOL] [EOL] async def start ( self ) : [EOL] return self . run_forever ( ) [EOL] [EOL] async def run_forever ( self ) : [EOL] [docstring] [EOL] while True : [EOL] try : [EOL] with closing ( await self . _connect_redis ( ) ) as redis : [EOL] await CleanupThread ( redis , self . _global_keys ) . run ( ) [EOL] except ( ConnectionClosedError , OSError ) : [EOL] _log . warning ( [string] , exc_info = True ) [EOL] await asyncio . sleep ( self . connection_delay ) [EOL] [EOL] [EOL] class CleanupThread : [EOL] [docstring] [EOL] [EOL] namespace_ttl = [number] [EOL] mailbox_ttl = [number] [EOL] content_ttl = [number] [EOL] [EOL] def __init__ ( self , redis , global_keys ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _redis = redis [EOL] self . _global_keys = global_keys [EOL] self . _keys = keys = CleanupKeys ( global_keys ) [EOL] self . _order = ( keys . mailboxes , keys . namespaces , keys . contents ) [EOL] [EOL] async def run ( self ) : [EOL] [docstring] [EOL] redis = self . _redis [EOL] while True : [EOL] await redis . unwatch ( ) [EOL] cleanup_key , cleanup_val = await redis . blpop ( * self . _order , timeout = [number] ) [EOL] try : [EOL] await asyncio . shield ( self . _run_one ( cleanup_key , cleanup_val ) ) [EOL] except Exception : [EOL] _log . warning ( [string] , cleanup_key , cleanup_val , exc_info = True ) [EOL] raise [EOL] [EOL] async def _run_one ( self , cleanup_key , cleanup_val ) : [EOL] keys = self . _keys [EOL] if cleanup_key == keys . namespaces : [EOL] namespace = cleanup_val [EOL] await self . _run_namespace ( namespace ) [EOL] elif cleanup_key == keys . mailboxes : [EOL] namespace , mailbox_id = cleanup_val . split ( [string] , [number] ) [EOL] await self . _run_mailbox ( namespace , mailbox_id ) [EOL] elif cleanup_key == keys . contents : [EOL] namespace , email_id = cleanup_val . split ( [string] , [number] ) [EOL] await self . _run_content ( namespace , email_id ) [EOL] [EOL] async def _run_namespace ( self , namespace ) : [EOL] ns_keys = NamespaceKeys ( self . _global_keys , namespace ) [EOL] await _scripts . namespace ( self . _redis , self . _keys , ns_keys , ttl = self . namespace_ttl ) [EOL] [EOL] async def _run_mailbox ( self , namespace , mailbox_id ) : [EOL] ns_keys = NamespaceKeys ( self . _global_keys , namespace ) [EOL] mbx_keys = MailboxKeys ( ns_keys , mailbox_id ) [EOL] await _scripts . mailbox ( self . _redis , self . _keys , mbx_keys , ttl = self . mailbox_ttl ) [EOL] [EOL] async def _run_content ( self , namespace , email_id ) : [EOL] ns_keys = NamespaceKeys ( self . _global_keys , namespace ) [EOL] ct_keys = ContentKeys ( ns_keys , email_id ) [EOL] await _scripts . content ( self . _redis , ns_keys , ct_keys , ttl = self . content_ttl ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.float]$ 0 0 0 0 0 $None$ 0 0 0 $typing.Callable[[],typing.Awaitable[aioredis.Redis]]$ 0 $keys.GlobalKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],typing.Awaitable[aioredis.Redis]]$ 0 0 0 0 0 $keys.GlobalKeys$ 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.NoReturn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[builtins.int]$ 0 0 0 $typing.ClassVar[builtins.int]$ 0 0 0 $typing.ClassVar[builtins.int]$ 0 0 0 0 0 $None$ 0 0 0 $aioredis.Redis$ 0 $keys.GlobalKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 $keys.GlobalKeys$ 0 0 0 0 0 0 0 0 0 $keys.GlobalKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.NoReturn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , List , Tuple , Sequence [EOL] import keys [EOL] import builtins [EOL] import aioredis [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Optional , Tuple , Sequence , List [EOL] [EOL] from aioredis import Redis , ReplyError [comment] [EOL] [EOL] from . keys import NamespaceKeys , FilterKeys [EOL] from . scripts . filter import FilterScripts [EOL] from pymap . filter import PluginFilterSet [EOL] from pymap . parsing . specials import ObjectId [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _scripts = FilterScripts ( ) [EOL] [EOL] [EOL] class FilterSet ( PluginFilterSet [ bytes ] ) : [EOL] [EOL] _active_name = [string] [EOL] [EOL] def __init__ ( self , redis , ns_keys ) : [EOL] super ( ) . __init__ ( [string] , bytes ) [EOL] self . _redis = redis [EOL] self . _keys = FilterKeys ( ns_keys ) [EOL] [EOL] async def put ( self , name , value ) : [EOL] keys = self . _keys [EOL] name_bytes = name . encode ( [string] ) [EOL] key = ObjectId . random ( [string] ) . value [EOL] pipe = self . _redis . pipeline ( ) [EOL] pipe . hset ( keys . data , key , value ) [EOL] pipe . hset ( keys . names , name_bytes , key ) [EOL] await pipe . execute ( ) [EOL] [EOL] async def delete ( self , name ) : [EOL] try : [EOL] await _scripts . delete ( self . _redis , self . _keys , name = name . encode ( [string] ) , active_name = self . _active_name ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( name ) from exc [EOL] elif [string] in str ( exc ) : [EOL] raise ValueError ( name ) from exc [EOL] raise [EOL] [EOL] async def rename ( self , before_name , after_name ) : [EOL] try : [EOL] await _scripts . rename ( self . _redis , self . _keys , before_name = before_name . encode ( [string] ) , after_name = after_name . encode ( [string] ) ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( before_name ) from exc [EOL] elif [string] in str ( exc ) : [EOL] raise KeyError ( after_name ) from exc [EOL] raise [EOL] [EOL] async def clear_active ( self ) : [EOL] keys = self . _keys [EOL] await self . _redis . hdel ( keys . names , self . _active_name ) [EOL] [EOL] async def set_active ( self , name ) : [EOL] try : [EOL] await _scripts . set_active ( self . _redis , self . _keys , name = name . encode ( [string] ) , active_name = self . _active_name ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( name ) from exc [EOL] raise [EOL] [EOL] async def get ( self , name ) : [EOL] try : [EOL] return await _scripts . get ( self . _redis , self . _keys , name = name . encode ( [string] ) ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( name ) from exc [EOL] raise [EOL] [EOL] async def get_active ( self ) : [EOL] try : [EOL] return await _scripts . get ( self . _redis , self . _keys , name = self . _active_name ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] return None [EOL] raise [EOL] [EOL] async def get_all ( self ) : [EOL] keys = self . _keys [EOL] sieve_names = await self . _redis . hgetall ( keys . names ) [EOL] active_key = sieve_names . get ( self . _active_name ) [EOL] active_name = None [EOL] names = [ ] [EOL] for name , key in sieve_names . items ( ) : [EOL] if name != self . _active_name : [EOL] name_str = name . decode ( [string] ) [EOL] names . append ( name_str ) [EOL] if key == active_key : [EOL] active_name = name_str [EOL] return active_name , names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioredis.Redis$ 0 $keys.NamespaceKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 0 0 $keys.NamespaceKeys$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0
[EOL] from typing import Optional , FrozenSet , List , Tuple , Sequence , Iterable [EOL] import pymap [EOL] import message [EOL] import aioredis [EOL] import builtins [EOL] import keys [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import hashlib [EOL] from datetime import datetime [EOL] from typing import Optional , Sequence , Mapping , Tuple , List , FrozenSet , Iterable [EOL] [EOL] import msgpack [comment] [EOL] from aioredis import Redis , ReplyError , MultiExecError [comment] [EOL] [EOL] from pymap . bytes import HashStream [EOL] from pymap . concurrent import Event [EOL] from pymap . exceptions import MailboxNotFound , MailboxConflict , TemporaryFailure [EOL] from pymap . flags import FlagOp [EOL] from pymap . interfaces . message import CachedMessage [EOL] from pymap . listtree import ListTree [EOL] from pymap . mailbox import MailboxSnapshot [EOL] from pymap . mime import MessageContent [EOL] from pymap . parsing . message import AppendMessage [EOL] from pymap . parsing . modutf7 import modutf7_encode , modutf7_decode [EOL] from pymap . parsing . specials import ObjectId , SequenceSet [EOL] from pymap . parsing . specials . flag import Flag [EOL] from pymap . selected import SelectedSet , SelectedMailbox [EOL] from pymap . threads import ThreadKey [EOL] [EOL] from . keys import CleanupKeys , NamespaceKeys , ContentKeys , MailboxKeys [EOL] from . message import Message [EOL] from . scripts . mailbox import MailboxScripts [EOL] from . scripts . namespace import NamespaceScripts [EOL] from . . mailbox import MailboxDataInterface , MailboxSetInterface [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _scripts = MailboxScripts ( ) [EOL] _ns_scripts = NamespaceScripts ( ) [EOL] [EOL] _ChangesRaw = Sequence [ Tuple [ bytes , Mapping [ bytes , bytes ] ] ] [EOL] [EOL] [EOL] class MailboxData ( MailboxDataInterface [ Message ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , redis , mailbox_id , uid_validity , keys , ns_keys , cl_keys ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _redis = redis [EOL] self . _mailbox_id = ObjectId ( mailbox_id ) [EOL] self . _uid_validity = uid_validity [EOL] self . _selected_set = SelectedSet ( ) [EOL] self . _keys = keys [EOL] self . _ns_keys = ns_keys [EOL] self . _cl_keys = cl_keys [EOL] [EOL] @ property def mailbox_id ( self ) : [EOL] return self . _mailbox_id [EOL] [EOL] @ property def readonly ( self ) : [EOL] return False [EOL] [EOL] @ property def uid_validity ( self ) : [EOL] return self . _uid_validity [EOL] [EOL] @ property def selected_set ( self ) : [EOL] return self . _selected_set [EOL] [EOL] def _get_msg ( self , uid , msg_raw ) : [EOL] msg = msgpack . unpackb ( msg_raw , raw = True ) [EOL] msg_flags = { Flag ( flag ) for flag in msg [ [string] ] } [EOL] msg_email_id = ObjectId . maybe ( msg [ [string] ] ) [EOL] msg_thread_id = ObjectId . maybe ( msg [ [string] ] ) [EOL] msg_time = datetime . fromisoformat ( msg [ [string] ] . decode ( [string] ) ) [EOL] return Message ( uid , msg_time , msg_flags , email_id = msg_email_id , thread_id = msg_thread_id , redis = self . _redis , ns_keys = self . _ns_keys ) [EOL] [EOL] async def update_selected ( self , selected , * , wait_on = None ) : [EOL] last_mod_seq = selected . mod_sequence [EOL] if wait_on is not None : [EOL] await self . _wait_updates ( selected , last_mod_seq ) [EOL] if last_mod_seq is None : [EOL] await self . _load_initial ( selected ) [EOL] else : [EOL] await self . _load_updates ( selected , last_mod_seq ) [EOL] return selected [EOL] [EOL] async def append ( self , append_msg , * , recent = False ) : [EOL] redis = self . _redis [EOL] keys = self . _keys [EOL] ns_keys = self . _ns_keys [EOL] when = append_msg . when or datetime . now ( ) [EOL] content = MessageContent . parse ( append_msg . literal ) [EOL] content_hash = HashStream ( hashlib . sha1 ( ) ) . digest ( content ) [EOL] new_email_id = ObjectId . new_email_id ( content_hash ) [EOL] ct_keys = ContentKeys ( ns_keys , new_email_id ) [EOL] new_uid , email_id , thread_id = await _scripts . add ( redis , ns_keys , ct_keys , keys , recent = recent , flags = [ str ( flag ) for flag in append_msg . flag_set ] , date = when . isoformat ( ) . encode ( [string] ) , email_id = new_email_id . value , thread_id = ObjectId . random_thread_id ( ) . value , thread_keys = [ [string] . join ( thread_key ) for thread_key in ThreadKey . get_all ( content . header ) ] , message = append_msg . literal , message_json = content . json , header = bytes ( content . header ) , header_json = content . header . json ) [EOL] return Message ( new_uid , when , append_msg . flag_set , email_id = ObjectId ( email_id ) , thread_id = ObjectId ( thread_id ) , redis = redis , ns_keys = ns_keys ) [EOL] [EOL] async def copy ( self , uid , destination , * , recent = False ) : [EOL] redis = self . _redis [EOL] keys = self . _keys [EOL] ns_keys = self . _ns_keys [EOL] dest_keys = destination . _keys [EOL] try : [EOL] dest_uid = await _scripts . copy ( redis , ns_keys , keys , dest_keys , source_uid = uid , recent = recent ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] return None [EOL] raise [EOL] return dest_uid [EOL] [EOL] async def move ( self , uid , destination , * , recent = False ) : [EOL] redis = self . _redis [EOL] keys = self . _keys [EOL] ns_keys = self . _ns_keys [EOL] dest_keys = destination . _keys [EOL] try : [EOL] dest_uid = await _scripts . move ( redis , ns_keys , keys , dest_keys , source_uid = uid , recent = recent ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] return None [EOL] raise [EOL] return dest_uid [EOL] [EOL] async def get ( self , uid , cached_msg ) : [EOL] redis = self . _redis [EOL] keys = self . _keys [EOL] message_raw = await redis . hget ( keys . uids , uid ) [EOL] if message_raw is None : [EOL] if not isinstance ( cached_msg , Message ) : [EOL] raise TypeError ( cached_msg ) [EOL] return Message . copy_expunged ( cached_msg ) [EOL] return self . _get_msg ( uid , message_raw ) [EOL] [EOL] async def update ( self , uid , cached_msg , flag_set , mode ) : [EOL] keys = self . _keys [EOL] ns_keys = self . _ns_keys [EOL] try : [EOL] message_raw = await _scripts . update ( self . _redis , ns_keys , keys , uid = uid , mode = bytes ( mode ) , flags = [ str ( flag ) for flag in flag_set ] ) [EOL] except ReplyError as exc : [EOL] if [string] not in str ( exc ) : [EOL] raise [EOL] if not isinstance ( cached_msg , Message ) : [EOL] raise TypeError ( cached_msg ) [EOL] return Message . copy_expunged ( cached_msg ) [EOL] return self . _get_msg ( uid , message_raw ) [EOL] [EOL] async def delete ( self , uids ) : [EOL] keys = self . _keys [EOL] ns_keys = self . _ns_keys [EOL] uids = list ( uids ) [EOL] if not uids : [EOL] return [EOL] await _scripts . delete ( self . _redis , ns_keys , keys , self . _cl_keys , uids = uids ) [EOL] [EOL] async def claim_recent ( self , selected ) : [EOL] keys = self . _keys [EOL] multi = self . _redis . multi_exec ( ) [EOL] multi . smembers ( keys . recent ) [EOL] multi . unlink ( keys . recent ) [EOL] recent , _ = await multi . execute ( ) [EOL] for uid_bytes in recent : [EOL] selected . session_flags . add_recent ( int ( uid_bytes ) ) [EOL] [EOL] async def find_deleted ( self , seq_set , selected ) : [EOL] if not seq_set . is_all : [EOL] return await super ( ) . find_deleted ( seq_set , selected ) [EOL] deleted = await self . _redis . smembers ( self . _keys . deleted ) [EOL] return [ int ( uid ) for uid in deleted ] [EOL] [EOL] async def cleanup ( self ) : [EOL] pass [EOL] [EOL] async def snapshot ( self ) : [EOL] next_uid , num_exists , num_recent , num_unseen , first_unseen = await _scripts . snapshot ( self . _redis , self . _keys ) [EOL] return MailboxSnapshot ( self . mailbox_id , self . readonly , self . uid_validity , self . permanent_flags , self . session_flags , num_exists , num_recent , num_unseen , first_unseen , next_uid ) [EOL] [EOL] def _get_mod_seq ( self , changes ) : [EOL] try : [EOL] ret = changes [ - [number] ] [ [number] ] [EOL] except IndexError : [EOL] return None [EOL] else : [EOL] left , right = ret . rsplit ( [string] , [number] ) [EOL] next_right = int ( right ) + [number] [EOL] return [string] % ( left , next_right ) [EOL] [EOL] async def _load_initial ( self , selected ) : [EOL] keys = self . _keys [EOL] multi = self . _redis . multi_exec ( ) [EOL] multi . hgetall ( keys . uids ) [EOL] multi . xrevrange ( keys . changes , count = [number] ) [EOL] msg_raw_map , last_changes = await multi . execute ( ) [EOL] messages = [ self . _get_msg ( int ( uid ) , msg_raw ) for uid , msg_raw in msg_raw_map . items ( ) ] [EOL] selected . mod_sequence = self . _get_mod_seq ( last_changes ) [EOL] selected . set_messages ( messages ) [EOL] [EOL] def _get_changes ( self , changes ) : [EOL] expunged = frozenset ( int ( fields [ [string] ] ) for _ , fields in changes if fields [ [string] ] == [string] ) [EOL] messages = [ ] [EOL] for _ , fields in changes : [EOL] uid = int ( fields [ [string] ] ) [EOL] if fields [ [string] ] != [string] or uid in expunged : [EOL] continue [EOL] msg = self . _get_msg ( uid , fields [ [string] ] ) [EOL] messages . append ( msg ) [EOL] return messages , expunged [EOL] [EOL] async def _load_updates ( self , selected , last_mod_seq ) : [EOL] keys = self . _keys [EOL] multi = self . _redis . multi_exec ( ) [EOL] multi . xlen ( keys . changes ) [EOL] multi . xrange ( keys . changes , start = last_mod_seq ) [EOL] multi . xrevrange ( keys . changes , count = [number] ) [EOL] changes_len , changes , last_changes = await multi . execute ( ) [EOL] if len ( changes ) == changes_len : [EOL] return await self . _load_initial ( selected ) [EOL] messages , expunged = self . _get_changes ( changes ) [EOL] selected . mod_sequence = self . _get_mod_seq ( last_changes ) [EOL] selected . add_updates ( messages , expunged ) [EOL] [EOL] async def _wait_updates ( self , selected , last_mod_seq ) : [EOL] keys = self . _keys [EOL] redis = self . _redis [EOL] await redis . xread ( [ keys . changes ] , latest_ids = [ last_mod_seq ] , timeout = [number] , count = [number] ) [EOL] [EOL] [EOL] class MailboxSet ( MailboxSetInterface [ MailboxData ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , redis , keys , cl_keys ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _redis = redis [EOL] self . _keys = keys [EOL] self . _cl_keys = cl_keys [EOL] [EOL] @ property def delimiter ( self ) : [EOL] return [string] [EOL] [EOL] async def set_subscribed ( self , name , subscribed ) : [EOL] pipe = self . _redis . pipeline ( ) [EOL] pipe . unwatch ( ) [EOL] if subscribed : [EOL] pipe . sadd ( self . _keys . subscribed , name ) [EOL] else : [EOL] pipe . srem ( self . _keys . subscribed , name ) [EOL] await pipe . execute ( ) [EOL] [EOL] async def list_subscribed ( self ) : [EOL] pipe = self . _redis . pipeline ( ) [EOL] pipe . unwatch ( ) [EOL] pipe . smembers ( self . _keys . subscribed ) [EOL] _ , mailboxes = await pipe . execute ( ) [EOL] return ListTree ( self . delimiter ) . update ( [string] , * ( modutf7_decode ( name ) for name in mailboxes ) ) [EOL] [EOL] async def list_mailboxes ( self ) : [EOL] mailboxes = await _ns_scripts . list ( self . _redis , self . _keys ) [EOL] return ListTree ( self . delimiter ) . update ( [string] , * ( modutf7_decode ( name ) for name in mailboxes ) ) [EOL] [EOL] async def get_mailbox ( self , name ) : [EOL] redis = self . _redis [EOL] name_key = modutf7_encode ( name ) [EOL] try : [EOL] mbx_id , uid_val = await _ns_scripts . get ( redis , self . _keys , name = name_key ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( name_key ) from exc [EOL] raise [EOL] mbx_keys = MailboxKeys ( self . _keys , mbx_id ) [EOL] return MailboxData ( redis , mbx_id , uid_val , mbx_keys , self . _keys , self . _cl_keys ) [EOL] [EOL] async def add_mailbox ( self , name ) : [EOL] name_key = modutf7_encode ( name ) [EOL] mbx_id = ObjectId . random_mailbox_id ( ) [EOL] try : [EOL] await _ns_scripts . add ( self . _redis , self . _keys , name = name_key , mailbox_id = mbx_id . value ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise ValueError ( name_key ) from exc [EOL] raise [EOL] return mbx_id [EOL] [EOL] async def delete_mailbox ( self , name ) : [EOL] name_key = modutf7_encode ( name ) [EOL] try : [EOL] await _ns_scripts . delete ( self . _redis , self . _keys , self . _cl_keys , name = name_key ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] raise KeyError ( name_key ) from exc [EOL] raise [EOL] [EOL] async def rename_mailbox ( self , before , after ) : [EOL] redis = self . _redis [EOL] pipe = redis . pipeline ( ) [EOL] pipe . unwatch ( ) [EOL] pipe . watch ( self . _keys . mailboxes ) [EOL] pipe . hgetall ( self . _keys . mailboxes ) [EOL] _ , _ , all_keys = await pipe . execute ( ) [EOL] all_mbx = { modutf7_decode ( key ) : ns for key , ns in all_keys . items ( ) } [EOL] tree = ListTree ( self . delimiter ) . update ( [string] , * all_mbx . keys ( ) ) [EOL] before_entry = tree . get ( before ) [EOL] after_entry = tree . get ( after ) [EOL] if before_entry is None : [EOL] raise MailboxNotFound ( before ) [EOL] elif after_entry is not None : [EOL] raise MailboxConflict ( after ) [EOL] multi = redis . multi_exec ( ) [EOL] for before_name , after_name in tree . get_renames ( before , after ) : [EOL] before_id = all_mbx [ before_name ] [EOL] before_key = modutf7_encode ( before_name ) [EOL] after_key = modutf7_encode ( after_name ) [EOL] multi . hset ( self . _keys . mailboxes , after_key , before_id ) [EOL] multi . hdel ( self . _keys . mailboxes , before_key ) [EOL] multi . hincrby ( self . _keys . uid_validity , after_key ) [EOL] if before == [string] : [EOL] inbox_id = ObjectId . random_mailbox_id ( ) [EOL] multi . hset ( self . _keys . mailboxes , [string] , inbox_id . value ) [EOL] multi . hincrby ( self . _keys . uid_validity , [string] ) [EOL] try : [EOL] await multi . execute ( ) [EOL] except MultiExecError as exc : [EOL] msg = [string] [EOL] raise TemporaryFailure ( msg ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioredis.Redis$ 0 $builtins.bytes$ 0 $builtins.int$ 0 $keys.MailboxKeys$ 0 $keys.NamespaceKeys$ 0 $keys.CleanupKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $keys.MailboxKeys$ 0 0 0 0 0 $keys.NamespaceKeys$ 0 0 0 0 0 $keys.CleanupKeys$ 0 0 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $message.Message$ 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $pymap.concurrent.Event$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 $message.Message$ 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.int$ 0 $MailboxData$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MailboxData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.int$ 0 $MailboxData$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MailboxData$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $message.Message$ 0 0 0 $builtins.int$ 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $message.Message$ 0 0 0 $builtins.int$ 0 $pymap.interfaces.message.CachedMessage$ 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 $pymap.flags.FlagOp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $pymap.flags.FlagOp$ 0 0 0 $pymap.flags.FlagOp$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[pymap.parsing.specials.flag.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 $pymap.interfaces.message.CachedMessage$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.SequenceSet$ 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $pymap.mailbox.MailboxSnapshot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $_ChangesRaw$ 0 0 0 0 0 0 0 0 $_ChangesRaw$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Sequence[message.Message],typing.FrozenSet[builtins.int]]$ 0 0 0 $_ChangesRaw$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_ChangesRaw$ 0 0 0 0 0 0 0 0 0 $typing.List[message.Message]$ 0 0 0 0 0 0 0 0 0 $_ChangesRaw$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[message.Message]$ 0 0 0 0 0 0 0 $typing.List[message.Message]$ 0 0 0 0 0 0 $None$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 $pymap.selected.SelectedMailbox$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.selected.SelectedMailbox$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $aioredis.Redis$ 0 $keys.NamespaceKeys$ 0 $keys.CleanupKeys$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 $keys.NamespaceKeys$ 0 0 0 0 0 $keys.CleanupKeys$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.listtree.ListTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.listtree.ListTree$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MailboxData$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.ObjectId$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Any , Tuple , Sequence [EOL] import builtins [EOL] import aioredis [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import hashlib [EOL] import os . path [EOL] from contextlib import closing [EOL] from typing import Generic , TypeVar , Any , Union , Optional , Tuple , Sequence [EOL] [EOL] import msgpack [comment] [EOL] from aioredis import Redis , ReplyError [comment] [EOL] from pkg_resources import resource_stream [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _Val = Union [ int , bytes ] [EOL] _RetT = TypeVar ( [string] ) [EOL] [EOL] [EOL] class ScriptBase ( Generic [ _RetT ] ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , name ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _name = name [EOL] self . _sha , _ = self . _load ( ) [EOL] [EOL] def _load ( self ) : [EOL] fname = os . path . join ( [string] , f'{ self . _name } [string] ' ) [EOL] with closing ( resource_stream ( __name__ , fname ) ) as script : [EOL] data = script . read ( ) [EOL] return hashlib . sha1 ( data ) . hexdigest ( ) , data [EOL] [EOL] def _convert ( self , ret ) : [EOL] return ret [EOL] [EOL] def _pack ( self , val ) : [EOL] return msgpack . packb ( val ) [EOL] [EOL] def _maybe_int ( self , val ) : [EOL] if val == [string] : [EOL] return None [EOL] else : [EOL] return int ( val ) [EOL] [EOL] async def eval ( self , redis , keys , args ) : [EOL] [docstring] [EOL] try : [EOL] ret = await redis . evalsha ( self . _sha , keys , args ) [EOL] except ReplyError as exc : [EOL] if [string] in str ( exc ) : [EOL] self . _sha , data = self . _load ( ) [EOL] ret = await redis . eval ( data , keys , args ) [EOL] else : [EOL] raise [EOL] return self . _convert ( ret ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_RetT$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.bytes$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $_RetT$ 0 0 0 $aioredis.Redis$ 0 $typing.Sequence[builtins.bytes]$ 0 $typing.Sequence[_Val]$ 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.bytes]$ 0 $typing.Sequence[_Val]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aioredis.Redis$ 0 0 0 0 0 $typing.Sequence[builtins.bytes]$ 0 $typing.Sequence[_Val]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Dict , Tuple , Sequence [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from typing import Optional , Tuple , Sequence , Dict [EOL] [EOL] from pymap . filter import PluginFilterSet [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class FilterSet ( PluginFilterSet [ bytes ] ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( [string] , bytes ) [EOL] self . _filters = { } [EOL] self . _active = None [EOL] [EOL] async def put ( self , name , value ) : [EOL] self . _filters [ name ] = value [EOL] [EOL] async def delete ( self , name ) : [EOL] if name not in self . _filters : [EOL] raise KeyError ( name ) [EOL] elif name == self . _active : [EOL] raise ValueError ( name ) [EOL] del self . _filters [ name ] [EOL] [EOL] async def rename ( self , before_name , after_name ) : [EOL] if before_name not in self . _filters : [EOL] raise KeyError ( before_name ) [EOL] elif after_name in self . _filters : [EOL] raise KeyError ( after_name ) [EOL] self . _filters [ after_name ] = self . _filters [ before_name ] [EOL] del self . _filters [ before_name ] [EOL] if self . _active == before_name : [EOL] self . _active = after_name [EOL] [EOL] async def clear_active ( self ) : [EOL] self . _active = None [EOL] [EOL] async def set_active ( self , name ) : [EOL] if name not in self . _filters : [EOL] raise KeyError ( name ) [EOL] else : [EOL] self . _active = name [EOL] [EOL] async def get ( self , name ) : [EOL] return self . _filters [ name ] [EOL] [EOL] async def get_active ( self ) : [EOL] if self . _active is None : [EOL] return None [EOL] else : [EOL] return self . _filters [ self . _active ] [EOL] [EOL] async def get_all ( self ) : [EOL] return self . _active , list ( self . _filters . keys ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bytes$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Union , FrozenSet [EOL] import typing [EOL] import builtins [EOL] from typing import Union , Tuple , Sequence , Iterable , FrozenSet [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] whitespace = frozenset ( [string] ) [EOL] [EOL] _Line = Tuple [ int , int , int ] [EOL] _Lines = Sequence [ _Line ] [EOL] [EOL] [EOL] def find_any ( data , end_marker , start , end , inverse , reverse ) : [EOL] if reverse : [EOL] range_iter = reversed ( range ( start , end ) ) [EOL] else : [EOL] range_iter = range ( start , end ) [EOL] for i in range_iter : [EOL] match = ( data [ i ] in end_marker ) [EOL] if ( not match and not inverse ) or ( match and inverse ) : [EOL] if reverse : [EOL] return i + [number] [EOL] else : [EOL] return i [EOL] return - [number] [EOL] [EOL] [EOL] def get_raw ( view , * lines ) : [EOL] try : [EOL] start = lines [ [number] ] [ [number] ] [ [number] ] [EOL] except IndexError : [EOL] start = [number] [EOL] try : [EOL] end = lines [ - [number] ] [ - [number] ] [ [number] ] [EOL] except IndexError : [EOL] end = - [number] [EOL] return view [ start : end ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Dict [EOL] import typing [EOL] import email [EOL] import builtins [EOL] import bytes [EOL] from __future__ import annotations [EOL] [EOL] import base64 [EOL] import quopri [EOL] from abc import abstractmethod , ABCMeta [EOL] from email . headerregistry import ContentTransferEncodingHeader [EOL] from typing import Optional , Dict [EOL] [EOL] from . import MessageHeader , MessageBody [EOL] from . . bytes import Writeable [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class MessageDecoder ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] registry = { } [EOL] [EOL] @ classmethod def of ( cls , msg_header ) : [EOL] [docstring] [EOL] cte_hdr = msg_header . parsed . content_transfer_encoding [EOL] return cls . of_cte ( cte_hdr ) [EOL] [EOL] @ classmethod def of_cte ( cls , header ) : [EOL] [docstring] [EOL] if header is None : [EOL] return _NoopDecoder ( ) [EOL] hdr_str = str ( header ) . lower ( ) [EOL] custom = cls . registry . get ( hdr_str ) [EOL] if custom is not None : [EOL] return custom [EOL] elif hdr_str in ( [string] , [string] ) : [EOL] return _NoopDecoder ( ) [EOL] elif hdr_str == [string] : [EOL] return _QuotedPrintableDecoder ( ) [EOL] elif hdr_str == [string] : [EOL] return _Base64Decoder ( ) [EOL] else : [EOL] raise NotImplementedError ( hdr_str ) [EOL] [EOL] @ abstractmethod def decode ( self , body ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class _NoopDecoder ( MessageDecoder ) : [EOL] [EOL] def decode ( self , body ) : [EOL] return body [EOL] [EOL] [EOL] class _QuotedPrintableDecoder ( MessageDecoder ) : [EOL] [EOL] def decode ( self , body ) : [EOL] raw = bytes ( body ) [EOL] ret = quopri . decodestring ( raw ) [EOL] return Writeable . wrap ( ret ) [EOL] [EOL] [EOL] class _Base64Decoder ( MessageDecoder ) : [EOL] [EOL] def decode ( self , body ) : [EOL] raw = bytes ( body ) [EOL] ret = base64 . b64decode ( raw ) [EOL] return Writeable . wrap ( ret ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,MessageDecoder]$ 0 0 0 0 0 0 0 0 $MessageDecoder$ 0 0 0 $MessageHeader$ 0 0 0 0 0 0 0 $MessageHeader$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MessageDecoder$ 0 0 0 $typing.Optional[email.headerregistry.ContentTransferEncodingHeader]$ 0 0 0 0 0 0 $typing.Optional[email.headerregistry.ContentTransferEncodingHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.ContentTransferEncodingHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $MessageBody$ 0 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 $MessageBody$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , ClassVar , Any , Dict , Sequence , Iterable , Iterator [EOL] import typing [EOL] import email [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] from email . headerregistry import HeaderRegistry , BaseHeader , UnstructuredHeader , DateHeader , AddressHeader , SingleAddressHeader , ContentDispositionHeader , ContentTransferEncodingHeader , ContentTypeHeader [EOL] from email . policy import SMTP [EOL] from typing import cast , Any , Optional , ClassVar , Iterable , Iterator , Sequence , Mapping , Dict [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _Headers = Mapping [ bytes , Sequence [ Sequence [ bytes ] ] ] [EOL] [EOL] [EOL] class ParsedHeaders ( Mapping [ bytes , Sequence [ BaseHeader ] ] ) : [EOL] [docstring] [EOL] [EOL] _registry = HeaderRegistry ( ) [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , headers ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _headers = headers [EOL] self . _parsed = { } [EOL] [EOL] def __getitem__ ( self , name ) : [EOL] name_lower = name . lower ( ) [EOL] parsed = self . _parsed . get ( name_lower ) [EOL] if parsed is not None : [EOL] return parsed [EOL] values = self . _headers [ name_lower ] [EOL] self . _parsed [ name_lower ] = parsed = list ( self . _parse ( values ) ) [EOL] return parsed [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . _headers ) [EOL] [EOL] def __contains__ ( self , name ) : [EOL] if not isinstance ( name , bytes ) : [EOL] raise TypeError ( name ) [EOL] return name . lower ( ) in self . _headers [EOL] [EOL] def __iter__ ( self ) : [EOL] return iter ( self . _headers . keys ( ) ) [EOL] [EOL] @ classmethod def _parse ( cls , values ) : [EOL] for value in values : [EOL] lines = [ line . decode ( [string] , [string] ) for line in value ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] hdr_tuple = SMTP . header_source_parse ( lines ) [EOL] yield cls . _registry ( hdr_tuple [ [number] ] , hdr_tuple [ [number] ] ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return repr ( dict ( self ) ) [EOL] [EOL] @ property def content_type ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( ContentTypeHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def date ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( DateHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def subject ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def from_ ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ AddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def sender ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ SingleAddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def reply_to ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ AddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def to ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ AddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def cc ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ AddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def bcc ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( Sequence [ AddressHeader ] , self [ [string] ] ) [EOL] except KeyError : [EOL] return None [EOL] [EOL] @ property def in_reply_to ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def references ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def message_id ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_disposition ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( ContentDispositionHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_language ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_location ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_id ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_description ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( UnstructuredHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL] [EOL] @ property def content_transfer_encoding ( self ) : [EOL] [docstring] [EOL] try : [EOL] return cast ( ContentTransferEncodingHeader , self [ [string] ] [ [number] ] ) [EOL] except ( KeyError , IndexError ) : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[email.headerregistry.HeaderRegistry]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $_Headers$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_Headers$ 0 0 0 $typing.Dict[builtins.bytes,typing.Sequence[email.headerregistry.BaseHeader]]$ 0 0 0 0 0 0 $typing.Sequence[email.headerregistry.BaseHeader]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[email.headerregistry.BaseHeader]$ 0 0 0 $typing.Sequence[typing.Sequence[builtins.bytes]]$ 0 0 0 0 0 0 $typing.Sequence[typing.Sequence[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.ContentTypeHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.DateHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.SingleAddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Sequence[email.headerregistry.AddressHeader]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.ContentDispositionHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.UnstructuredHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[email.headerregistry.ContentTransferEncodingHeader]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import re as _re [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] compile = _re . compile [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[EOL] from typing import Awaitable , Any , Tuple , Sequence [EOL] import argparse [EOL] import config [EOL] import builtins [EOL] import typing [EOL] import session [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod , ABCMeta [EOL] from argparse import Namespace , ArgumentParser [EOL] from typing import Any , Tuple , Sequence , Awaitable [EOL] from typing_extensions import Protocol [EOL] [EOL] from . session import LoginProtocol [EOL] from . . config import IMAPConfig [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class BackendInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ classmethod @ abstractmethod def add_subparser ( cls , name , subparsers ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ classmethod @ abstractmethod async def init ( cls , args ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def start ( self , services ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def login ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def config ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class ServiceInterface ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , backend , config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . backend = backend [EOL] self . config = config [EOL] [EOL] @ classmethod @ abstractmethod def add_arguments ( cls , parser ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def start ( self ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[BackendInterface,BackendInterface.config.IMAPConfig]$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 $typing.Sequence[ServiceInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $session.LoginProtocol$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BackendInterface.config.IMAPConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , FrozenSet , Sequence [EOL] import typing [EOL] import parsing [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from typing import Optional , FrozenSet , Sequence [EOL] from typing_extensions import Protocol [EOL] [EOL] from . . parsing . specials import Flag , ObjectId [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class MailboxInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def mailbox_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def readonly ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def permanent_flags ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def session_flags ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def flags ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def exists ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def recent ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def unseen ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def first_unseen ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def next_uid ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def uid_validity ( self ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
[EOL] from typing import Sequence , FrozenSet , Collection [EOL] import bytes [EOL] import parsing [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import flags [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from datetime import datetime [EOL] from typing import TypeVar , Tuple , Sequence , FrozenSet , Collection [EOL] from typing_extensions import Protocol [EOL] [EOL] from . . bytes import Writeable [EOL] from . . flags import SessionFlags [EOL] from . . parsing . response . fetch import EnvelopeStructure , BodyStructure [EOL] from . . parsing . specials import Flag , ObjectId , FetchRequirement [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] MessageT = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] [comment] [EOL] MessageT_co = TypeVar ( [string] , bound = [string] , covariant = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] FlagsKey = Tuple [ int , FrozenSet [ Flag ] ] [EOL] [EOL] [EOL] class CachedMessage ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def uid ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def internal_date ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def permanent_flags ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def email_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def thread_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def flags_key ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_flags ( self , session_flags ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class MessageInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def uid ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def expunged ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def internal_date ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def permanent_flags ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def email_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def thread_id ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_flags ( self , session_flags ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def load_content ( self , requirement ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class LoadedMessageInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def requirement ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def __bytes__ ( self ) : [EOL] ... [EOL] [EOL] @ abstractmethod def get_header ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_headers ( self , section ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_message_headers ( self , section = None , subset = None , inverse = False ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_message_text ( self , section = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_body ( self , section = None , binary = False ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_size ( self , section = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_envelope_structure ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def get_body_structure ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod def contains ( self , value ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FlagsKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 $flags.SessionFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.specials.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.FrozenSet[parsing.specials.Flag]$ 0 0 0 $flags.SessionFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 $LoadedMessageInterface$ 0 0 0 $parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $parsing.specials.FetchRequirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 $typing.Collection[builtins.bytes]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Sequence[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.fetch.EnvelopeStructure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $parsing.response.fetch.BodyStructure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0
[EOL] from typing import Optional , Type , Tuple , Sequence [EOL] import builtins [EOL] import parsing [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from typing import TypeVar , Type , Optional , Tuple , Sequence [EOL] from typing_extensions import Protocol [EOL] [EOL] from . . parsing . message import AppendMessage [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] FilterValueT = TypeVar ( [string] ) [EOL] [EOL] [EOL] class FilterInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ abstractmethod async def apply ( self , sender , recipient , mailbox , append_msg ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class FilterCompilerInterface ( Protocol [ FilterValueT ] ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def value_type ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ property @ abstractmethod def filter_type ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def compile ( self , value ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class FilterSetInterface ( Protocol [ FilterValueT ] ) : [EOL] [docstring] [EOL] [EOL] __slots__ = [ ] [EOL] [EOL] @ property @ abstractmethod def compiler ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def put ( self , name , value ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def delete ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def rename ( self , before_name , after_name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def clear_active ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def set_active ( self , name ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod async def get ( self , name ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def get_active ( self ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def get_all ( self ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],parsing.message.AppendMessage]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[FilterInterface]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FilterInterface$ 0 0 0 $FilterValueT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $FilterCompilerInterface[FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $FilterValueT$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $FilterValueT$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[FilterValueT]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Sequence[builtins.str]]$ 0 0 0 0 0 0 0 0 0
[EOL] from typing import AsyncIterable , Collection [EOL] import builtins [EOL] import user [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] from abc import abstractmethod [EOL] from typing import Collection , AsyncIterable [EOL] from typing_extensions import Protocol [EOL] [EOL] from . . user import UserMetadata [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class UsersInterface ( Protocol ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def list_users ( self , * , match = None ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def get_user ( self , user ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def set_user ( self , user , data ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] @ abstractmethod async def delete_user ( self , user ) : [EOL] [docstring] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[typing.Collection[builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $user.UserMetadata$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $user.UserMetadata$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
[EOL] from typing import Optional , Awaitable , Tuple , Sequence [EOL] import argparse [EOL] import pymap [EOL] import ssl [EOL] import grpclib [EOL] import builtins [EOL] import typing [EOL] from __future__ import annotations [EOL] [EOL] import asyncio [EOL] from argparse import ArgumentParser [EOL] from asyncio import CancelledError [EOL] from ssl import SSLContext [EOL] from typing import Optional , Tuple , Sequence , Awaitable [EOL] from urllib . parse import urlparse [EOL] [EOL] from grpclib . server import Server [EOL] from pymap . interfaces . backend import BackendInterface , ServiceInterface [EOL] from pymapadmin . local import get_admin_socket [EOL] [EOL] from . handlers import handlers [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class AdminService ( ServiceInterface ) : [comment] [EOL] [docstring] [EOL] [EOL] @ classmethod def add_arguments ( cls , parser ) : [EOL] group = parser . add_argument_group ( [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , action = [string] , default = [ ] , help = [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , action = [string] , default = [ ] , help = [string] ) [EOL] [EOL] async def start ( self ) : [EOL] backend = self . backend [EOL] private_hosts = self . config . args . admin_private [EOL] public_hosts = self . config . args . admin_public [EOL] ssl = self . config . ssl_context [EOL] servers = [ await self . _start_local ( backend ) ] [EOL] servers += [ await self . _start ( backend , False , host , None ) for host in private_hosts ] [EOL] servers += [ await self . _start ( backend , True , host , ssl ) for host in public_hosts ] [EOL] return asyncio . create_task ( self . _run ( servers ) ) [EOL] [EOL] @ classmethod def _new_server ( cls , backend , public ) : [EOL] return Server ( [ handler ( backend , public ) for _ , handler in handlers ] ) [EOL] [EOL] @ classmethod async def _start_local ( cls , backend ) : [EOL] server = cls . _new_server ( backend , False ) [EOL] path = get_admin_socket ( mkdir = True ) [EOL] await server . start ( path = path ) [EOL] return server [EOL] [EOL] @ classmethod async def _start ( cls , backend , public , host , ssl ) : [EOL] server = cls . _new_server ( backend , public ) [EOL] host , port = cls . _parse ( host ) [EOL] await server . start ( host = host , port = port , ssl = ssl , reuse_address = True ) [EOL] return server [EOL] [EOL] @ classmethod def _parse ( cls , host ) : [EOL] parsed = urlparse ( host ) [EOL] if parsed . hostname : [EOL] return parsed . hostname , parsed . port [EOL] parsed = urlparse ( f' [string] { host }' ) [EOL] if parsed . hostname : [EOL] return parsed . hostname , parsed . port [EOL] raise ValueError ( host ) [EOL] [EOL] @ classmethod async def _run ( cls , servers ) : [EOL] try : [EOL] for server in servers : [EOL] await server . wait_closed ( ) [EOL] except CancelledError : [EOL] for server in servers : [EOL] server . close ( ) [EOL] await server . wait_closed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $grpclib.server.Server$ 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $grpclib.server.Server$ 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 0 0 0 0 0 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $grpclib.server.Server$ 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 $builtins.bool$ 0 0 0 $typing.Optional[ssl.SSLContext]$ 0 0 0 0 0 0 0 0 0 $pymap.interfaces.backend.BackendInterface$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ssl.SSLContext]$ 0 $typing.Optional[ssl.SSLContext]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.Optional[builtins.int]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[grpclib.server.Server]$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[grpclib.server.Server]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[grpclib.server.Server]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from __future__ import annotations [EOL] [EOL] from grpclib . server import Stream [EOL] from pymap import __version__ as server_version [EOL] from pymapadmin . grpc . admin_grpc import SystemBase [EOL] from pymapadmin . grpc . admin_pb2 import PingRequest , PingResponse [EOL] [EOL] from . import BaseHandler [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _PingStream = Stream [ PingRequest , PingResponse ] [EOL] [EOL] [EOL] class SystemHandlers ( SystemBase , BaseHandler ) : [EOL] [docstring] [EOL] [EOL] async def Ping ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] resp = PingResponse ( server_version = server_version , public_client = self . public ) [EOL] await stream . send_message ( resp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from __future__ import annotations [EOL] [EOL] from datetime import datetime , timezone [EOL] from typing import Optional [EOL] [EOL] from grpclib . server import Stream [EOL] from pymap . parsing . message import AppendMessage [EOL] from pymap . parsing . specials import Flag , ExtensionOptions [EOL] from pymapadmin . grpc . admin_grpc import MailboxBase [EOL] from pymapadmin . grpc . admin_pb2 import AppendRequest , AppendResponse [EOL] [EOL] from . import LoginHandler [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _AppendStream = Stream [ AppendRequest , AppendResponse ] [EOL] [EOL] [EOL] class MailboxHandlers ( MailboxBase , LoginHandler ) : [EOL] [docstring] [EOL] [EOL] async def Append ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] mailbox = request . mailbox or [string] [EOL] flag_set = frozenset ( Flag ( flag ) for flag in request . flags ) [EOL] when = datetime . fromtimestamp ( request . when , timezone . utc ) [EOL] append_msg = AppendMessage ( request . data , when , flag_set , ExtensionOptions . empty ( ) ) [EOL] validity = None [EOL] uid = None [EOL] async with self . catch_errors ( [string] ) as result , self . login_as ( request . login ) as session : [EOL] if session . filter_set is not None : [EOL] filter_value = await session . filter_set . get_active ( ) [EOL] if filter_value is not None : [EOL] compiler = session . filter_set . compiler [EOL] filter_ = await compiler . compile ( filter_value ) [EOL] new_mailbox , append_msg = await filter_ . apply ( request . sender , request . recipient , mailbox , append_msg ) [EOL] if new_mailbox is None : [EOL] await stream . send_message ( AppendResponse ( ) ) [EOL] return [EOL] else : [EOL] mailbox = new_mailbox [EOL] append_uid , _ = await session . append_messages ( mailbox , [ append_msg ] ) [EOL] validity = append_uid . validity [EOL] uid = next ( iter ( append_uid . uids ) ) [EOL] resp = AppendResponse ( result = result , mailbox = mailbox , validity = validity , uid = uid ) [EOL] await stream . send_message ( resp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from __future__ import annotations [EOL] [EOL] from typing import Optional [EOL] [EOL] from grpclib . server import Stream [EOL] from pymap . exceptions import NotSupportedError [EOL] from pymap . user import UserMetadata [EOL] from pymapadmin . grpc . admin_grpc import UserBase [EOL] from pymapadmin . grpc . admin_pb2 import ListUsersRequest , ListUsersResponse , UserData , UserResponse , GetUserRequest , SetUserRequest , DeleteUserRequest [EOL] [EOL] from . import LoginHandler [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] _ListUsersStream = Stream [ ListUsersRequest , ListUsersResponse ] [EOL] _GetUserStream = Stream [ GetUserRequest , UserResponse ] [EOL] _SetUserStream = Stream [ SetUserRequest , UserResponse ] [EOL] _DeleteUserStream = Stream [ DeleteUserRequest , UserResponse ] [EOL] [EOL] [EOL] class UserHandlers ( UserBase , LoginHandler ) : [EOL] [docstring] [EOL] [EOL] async def ListUsers ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] async with self . catch_errors ( [string] ) as result , self . login_as ( request . login ) as session : [EOL] if session . users is None : [EOL] raise NotSupportedError ( ) [EOL] match = request . match or None [EOL] async for users in session . users . list_users ( match = match ) : [EOL] resp = ListUsersResponse ( users = users ) [EOL] await stream . send_message ( resp ) [EOL] resp = ListUsersResponse ( result = result ) [EOL] await stream . send_message ( resp ) [EOL] [EOL] async def GetUser ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] username = None [EOL] user_data = None [EOL] async with self . catch_errors ( [string] ) as result , self . login_as ( request . login ) as session : [EOL] if session . users is None : [EOL] raise NotSupportedError ( ) [EOL] username = session . owner [EOL] metadata = await session . users . get_user ( username ) [EOL] user_data = UserData ( password = metadata . password , params = metadata . params ) [EOL] resp = UserResponse ( result = result , username = username , data = user_data ) [EOL] await stream . send_message ( resp ) [EOL] [EOL] async def SetUser ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] async with self . catch_errors ( [string] ) as result , self . login_as ( request . login ) as session : [EOL] if session . users is None : [EOL] raise NotSupportedError ( ) [EOL] user_data = request . data [EOL] password = self . config . hash_context . hash ( user_data . password ) [EOL] metadata = UserMetadata ( self . config , password , params = user_data . params ) [EOL] await session . users . set_user ( session . owner , metadata ) [EOL] resp = UserResponse ( result = result ) [EOL] await stream . send_message ( resp ) [EOL] [EOL] async def DeleteUser ( self , stream ) : [EOL] [docstring] [EOL] request = await stream . recv_message ( ) [EOL] assert request is not None [EOL] async with self . catch_errors ( [string] ) as result , self . login_as ( request . login ) as session : [EOL] if session . users is None : [EOL] raise NotSupportedError ( ) [EOL] await session . users . delete_user ( session . owner ) [EOL] resp = UserResponse ( result = result ) [EOL] await stream . send_message ( resp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Sequence [EOL] import builtins [EOL] import sievelib [EOL] import typing [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from typing import Optional , Sequence , List [EOL] [EOL] from pymap . mime import MessageContent [EOL] from pymap . parsing . message import AppendMessage [EOL] from sievelib . commands import Command [comment] [EOL] [EOL] from . tests import SieveTest [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class StopRunning ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SieveRunner : [EOL] [EOL] def __init__ ( self , commands ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _commands = commands [EOL] [EOL] def get_actions ( self , sender , recipient , append_msg ) : [EOL] actions = [ ] [EOL] try : [EOL] content = MessageContent . parse ( append_msg . literal ) [EOL] self . _get_actions ( actions , sender , recipient , append_msg , content ) [EOL] except StopRunning : [EOL] pass [EOL] return actions [EOL] [EOL] def _get_actions ( self , actions , sender , recipient , append_msg , content ) : [EOL] running_if = None [EOL] for cmd in self . _commands : [EOL] cmd_type = cmd . get_type ( ) [EOL] if cmd_type == [string] : [EOL] actions . append ( cmd ) [EOL] elif cmd_type == [string] : [EOL] if cmd . name == [string] : [EOL] running_if = cmd [EOL] elif cmd . name in ( [string] , [string] ) : [EOL] pass [EOL] elif cmd . name == [string] : [EOL] raise StopRunning ( ) [EOL] elif cmd . name == [string] : [EOL] pass [EOL] else : [EOL] raise NotImplementedError ( cmd . name ) [EOL] else : [EOL] raise NotImplementedError ( cmd_type ) [EOL] if running_if : [EOL] if cmd . name in ( [string] , [string] ) : [EOL] test = SieveTest . of ( cmd . arguments [ [string] ] ) [EOL] test_result = test . run ( sender , recipient , append_msg , content ) [EOL] if not test_result : [EOL] continue [EOL] elif cmd . name == [string] : [EOL] pass [EOL] else : [EOL] running_if = None [EOL] continue [EOL] running_if = None [EOL] runner = SieveRunner ( cmd . children ) [EOL] runner . _get_actions ( actions , sender , recipient , append_msg , content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[sievelib.commands.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[sievelib.commands.Command]$ 0 0 0 $typing.Sequence[sievelib.commands.Command]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 0 0 $typing.List[sievelib.commands.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 $typing.List[sievelib.commands.Command]$ 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sievelib.commands.Command]$ 0 0 0 $None$ 0 0 0 $typing.List[sievelib.commands.Command]$ 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sievelib.commands.Command]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[sievelib.commands.Command]$ 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0
[EOL] from typing import Pattern , List , Sequence [EOL] import pymap [EOL] import builtins [EOL] import typing [EOL] import util [EOL] import sievelib [EOL] from __future__ import annotations [EOL] [EOL] import re [EOL] from abc import abstractmethod , ABCMeta [EOL] from email . headerregistry import Address , AddressHeader [EOL] from typing import Sequence , List , Pattern [EOL] [EOL] from pymap . mime import MessageContent [EOL] from pymap . parsing . message import AppendMessage [EOL] from sievelib . commands import Command [comment] [EOL] [EOL] from . util import AddressPart , MatchType , SizeComparator , str_list [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] class SieveTest ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classmethod def of ( cls , cmd ) : [EOL] [docstring] [EOL] if cmd . name == [string] : [EOL] return AllOfTest ( [ SieveTest . of ( test ) for test in cmd . arguments [ [string] ] ] ) [EOL] elif cmd . name == [string] : [EOL] return AnyOfTest ( [ SieveTest . of ( test ) for test in cmd . arguments [ [string] ] ] ) [EOL] elif cmd . name == [string] : [EOL] return NotTest ( SieveTest . of ( cmd . arguments [ [string] ] ) ) [EOL] elif cmd . name == [string] : [EOL] return TrueTest ( ) [EOL] elif cmd . name == [string] : [EOL] return FalseTest ( ) [EOL] elif cmd . name in ( [string] , [string] ) : [EOL] address_part = AddressPart . of ( cmd . arguments . get ( [string] ) ) [EOL] match_type = MatchType . of ( cmd . arguments . get ( [string] ) ) [EOL] case_sensitive = cmd . arguments . get ( [string] ) == [string] [EOL] header_list = str_list ( cmd . arguments [ [string] ] ) [EOL] key_list = str_list ( cmd . arguments [ [string] ] ) [EOL] if cmd . name == [string] : [EOL] return AddressTest ( header_list , key_list , address_part , match_type , case_sensitive ) [EOL] else : [EOL] return EnvelopeTest ( header_list , key_list , address_part , match_type , case_sensitive ) [EOL] elif cmd . name == [string] : [EOL] header_names = str_list ( cmd . arguments [ [string] ] ) [EOL] return ExistsTest ( header_names ) [EOL] elif cmd . name == [string] : [EOL] match_type = MatchType . of ( cmd . arguments . get ( [string] ) ) [EOL] case_sensitive = cmd . arguments . get ( [string] ) == [string] [EOL] header_names = str_list ( cmd . arguments [ [string] ] ) [EOL] key_list = str_list ( cmd . arguments [ [string] ] ) [EOL] return HeaderTest ( header_names , key_list , match_type , case_sensitive ) [EOL] elif cmd . name == [string] : [EOL] comparator = SizeComparator . of ( cmd . arguments [ [string] ] ) [EOL] limit = int ( cmd . arguments [ [string] ] ) [EOL] return SizeTest ( comparator , limit ) [EOL] else : [EOL] raise NotImplementedError ( cmd . name ) [EOL] [EOL] @ abstractmethod def run ( self , sender , recipient , append_msg , content ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] class AllOfTest ( SieveTest ) : [EOL] [EOL] def __init__ ( self , tests ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _tests = tests [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return all ( test . run ( sender , recipient , append_msg , content ) for test in self . _tests ) [EOL] [EOL] [EOL] class AnyOfTest ( SieveTest ) : [EOL] [EOL] def __init__ ( self , tests ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _tests = tests [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return any ( test . run ( sender , recipient , append_msg , content ) for test in self . _tests ) [EOL] [EOL] [EOL] class NotTest ( SieveTest ) : [EOL] [EOL] def __init__ ( self , test ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _test = test [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return not self . _test . run ( sender , recipient , append_msg , content ) [EOL] [EOL] [EOL] class TrueTest ( SieveTest ) : [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return True [EOL] [EOL] [EOL] class FalseTest ( SieveTest ) : [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return False [EOL] [EOL] [EOL] class MatchTest ( SieveTest ) : [EOL] [EOL] _wildcards = re . compile ( [string] ) [EOL] [EOL] @ classmethod def _compile ( cls , key_list , match_type , case_sensitive ) : [EOL] flags = [number] if case_sensitive else re . I [EOL] ret = [ ] [EOL] for key in key_list : [EOL] if match_type == MatchType . MATCHES : [EOL] pattern_parts = [ ] [EOL] for part in cls . _wildcards . split ( key ) : [EOL] if part == [string] : [EOL] pattern_parts . append ( [string] ) [EOL] elif part == [string] : [EOL] pattern_parts . append ( [string] ) [EOL] else : [EOL] pattern_parts . append ( re . escape ( part ) ) [EOL] pattern = [string] . join ( pattern_parts ) [EOL] else : [EOL] pattern = re . escape ( key ) [EOL] if match_type in ( MatchType . IS , MatchType . MATCHES ) : [EOL] pattern = [string] + pattern + [string] [EOL] ret . append ( re . compile ( pattern , flags ) ) [EOL] return ret [EOL] [EOL] [EOL] class AddressTest ( MatchTest ) : [EOL] [EOL] def __init__ ( self , header_list , key_list , address_part , match_type , case_sensitive ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _header_set = { hdr . encode ( [string] ) for hdr in header_list } [EOL] self . _address_part = address_part [EOL] self . _patterns = self . _compile ( key_list , match_type , case_sensitive ) [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] part = self . _address_part [EOL] for name in self . _header_set : [EOL] values = content . header . parsed . get ( name , [ ] ) [EOL] for value in values : [EOL] if isinstance ( value , AddressHeader ) : [EOL] for address in value . addresses : [EOL] if part == AddressPart . LOCALPART : [EOL] addr_part = address . username [EOL] elif part == AddressPart . DOMAIN : [EOL] addr_part = address . domain [EOL] else : [EOL] addr_part = address . addr_spec [EOL] for pattern in self . _patterns : [EOL] if pattern . match ( addr_part ) is not None : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class EnvelopeTest ( AddressTest ) : [EOL] [EOL] def _check_address ( self , envelope_part , address ) : [EOL] if envelope_part not in self . _header_set : [EOL] return False [EOL] try : [EOL] addr_obj = Address ( addr_spec = address ) [EOL] except Exception : [EOL] addr_obj = Address ( username = address ) [EOL] part = self . _address_part [EOL] if part == AddressPart . LOCALPART : [EOL] addr_part = addr_obj . username [EOL] elif part == AddressPart . DOMAIN : [EOL] addr_part = addr_obj . domain [EOL] else : [EOL] addr_part = addr_obj . addr_spec [EOL] if addr_part == [string] : [EOL] addr_part = [string] [EOL] for pattern in self . _patterns : [EOL] if pattern . match ( addr_part ) is not None : [EOL] return True [EOL] return False [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] if self . _check_address ( [string] , sender ) : [EOL] return True [EOL] elif self . _check_address ( [string] , recipient ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class ExistsTest ( SieveTest ) : [EOL] [EOL] def __init__ ( self , header_names ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _header_names = { hdr . encode ( [string] ) for hdr in header_names } [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] return all ( name in content . header . parsed for name in self . _header_names ) [EOL] [EOL] [EOL] class HeaderTest ( MatchTest ) : [EOL] [EOL] def __init__ ( self , header_names , key_list , match_type , case_sensitive ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _header_names = [ hdr . encode ( [string] ) for hdr in header_names ] [EOL] self . _patterns = self . _compile ( key_list , match_type , case_sensitive ) [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] for name in self . _header_names : [EOL] values = content . header . parsed . get ( name , [ ] ) [EOL] for value in values : [EOL] value_str = str ( value ) [EOL] for pattern in self . _patterns : [EOL] if pattern . match ( value_str ) is not None : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] class SizeTest ( SieveTest ) : [EOL] [EOL] def __init__ ( self , comparator , limit ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _comparator = comparator [EOL] self . _limit = limit [EOL] [EOL] def run ( self , sender , recipient , append_msg , content ) : [EOL] length = len ( content ) [EOL] if self . _comparator == SizeComparator . OVER : [EOL] return length > self . _limit [EOL] else : [EOL] return length < self . _limit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SieveTest$ 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sievelib.commands.Command$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[SieveTest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[SieveTest]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[SieveTest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[SieveTest]$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $SieveTest$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SieveTest$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[typing.Pattern]$ 0 0 0 $typing.Sequence[builtins.str]$ 0 $util.MatchType$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Pattern]$ 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 $util.MatchType$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $util.MatchType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $util.AddressPart$ 0 $util.MatchType$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 $util.AddressPart$ 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $util.MatchType$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bytes$ 0 $builtins.str$ 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[builtins.str]$ 0 $typing.Sequence[builtins.str]$ 0 $util.MatchType$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 $util.MatchType$ 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $util.SizeComparator$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $util.SizeComparator$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Union , Sequence [EOL] import typing [EOL] import builtins [EOL] from __future__ import annotations [EOL] [EOL] import enum [EOL] from typing import Union , Optional , Sequence [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class AddressPart ( enum . Enum ) : [EOL] LOCALPART = enum . auto ( ) [EOL] DOMAIN = enum . auto ( ) [EOL] ALL = enum . auto ( ) [EOL] [EOL] @ classmethod def of ( cls , flag ) : [EOL] if not flag : [EOL] return cls . ALL [EOL] elif flag == [string] : [EOL] return cls . LOCALPART [EOL] elif flag == [string] : [EOL] return cls . DOMAIN [EOL] elif flag == [string] : [EOL] return cls . ALL [EOL] else : [EOL] raise NotImplementedError ( flag ) [EOL] [EOL] [EOL] class MatchType ( enum . Enum ) : [EOL] IS = enum . auto ( ) [EOL] CONTAINS = enum . auto ( ) [EOL] MATCHES = enum . auto ( ) [EOL] [EOL] @ classmethod def of ( cls , flag ) : [EOL] if not flag : [EOL] return cls . IS [EOL] elif flag == [string] : [EOL] return cls . IS [EOL] elif flag == [string] : [EOL] return cls . CONTAINS [EOL] elif flag == [string] : [EOL] return cls . MATCHES [EOL] else : [EOL] raise NotImplementedError ( flag ) [EOL] [EOL] [EOL] class SizeComparator ( enum . Enum ) : [EOL] OVER = enum . auto ( ) [EOL] UNDER = enum . auto ( ) [EOL] [EOL] @ classmethod def of ( cls , flag ) : [EOL] if flag == [string] : [EOL] return cls . OVER [EOL] elif flag == [string] : [EOL] return cls . UNDER [EOL] else : [EOL] raise NotImplementedError ( flag ) [EOL] [EOL] [EOL] def str_list ( value ) : [EOL] if isinstance ( value , str ) : [EOL] return [ unquote ( value ) ] [EOL] else : [EOL] return [ unquote ( val ) for val in value ] [EOL] [EOL] [EOL] def unquote ( value ) : [EOL] if value [ [number] ] == [string] and value [ - [number] ] == [string] : [EOL] return value [ [number] : - [number] ] [EOL] else : [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $AddressPart$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MatchType$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SizeComparator$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Type , List , Tuple [EOL] import runner [EOL] import builtins [EOL] import typing [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] from typing import Type , Optional , Tuple , List [EOL] [EOL] from pymap . exceptions import AppendFailure [EOL] from pymap . interfaces . filter import FilterInterface , FilterCompilerInterface [EOL] from pymap . parsing . message import AppendMessage [EOL] from sievelib . parser import Parser [comment] [EOL] [EOL] from . runner import SieveRunner [EOL] from . util import unquote [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class SieveParseError ( ValueError ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class SieveCompiler ( FilterCompilerInterface [ bytes ] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] extensions = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . parser = Parser ( ) [EOL] [EOL] @ property def value_type ( self ) : [EOL] return bytes [EOL] [EOL] @ property def filter_type ( self ) : [EOL] return SieveFilter [EOL] [EOL] async def compile ( self , value ) : [EOL] parser = self . parser [EOL] try : [EOL] success = parser . parse ( value ) [EOL] except Exception as exc : [EOL] raise SieveParseError ( [string] ) from exc [EOL] if success : [EOL] runner = SieveRunner ( parser . result ) [EOL] return SieveFilter ( runner ) [EOL] else : [EOL] raise SieveParseError ( parser . error ) [EOL] [EOL] [EOL] class SieveFilter ( FilterInterface ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , runner ) : [EOL] super ( ) . __init__ ( ) [EOL] self . runner = runner [EOL] [EOL] async def apply ( self , sender , recipient , mailbox , append_msg ) : [EOL] for action in self . runner . get_actions ( sender , recipient , append_msg ) : [EOL] if action . name == [string] : [EOL] pass [EOL] elif action . name == [string] : [EOL] mailbox = unquote ( action . arguments [ [string] ] ) [EOL] return mailbox , append_msg [EOL] elif action . name == [string] : [EOL] msg = unquote ( action . arguments [ [string] ] ) . encode ( [string] ) [EOL] raise AppendFailure ( mailbox , msg ) [EOL] elif action . name == [string] : [EOL] return None , append_msg [EOL] else : [EOL] msg = [string] % action . name . encode ( [string] ) [EOL] raise AppendFailure ( mailbox , msg ) from KeyError ( action . name ) [EOL] return mailbox , append_msg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[SieveFilter]$ 0 0 0 0 0 0 0 0 0 0 0 $SieveFilter$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],pymap.parsing.message.AppendMessage]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.message.AppendMessage$ 0
[EOL] from typing import Optional , Sequence [EOL] import builtins [EOL] import typing [EOL] import pymap [EOL] from __future__ import annotations [EOL] [EOL] import enum [EOL] from typing import Optional , Mapping , Sequence [EOL] [EOL] from pymap . bytes import BytesFormat , MaybeBytes , WriteStream , Writeable [EOL] from pymap . parsing . exceptions import NotParseable [EOL] from pymap . parsing . primitives import String , QuotedString , LiteralString [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] _Capabilities = Mapping [ bytes , Optional [ MaybeBytes ] ] [EOL] [EOL] [EOL] class Condition ( enum . Enum ) : [EOL] OK = enum . auto ( ) [EOL] NO = enum . auto ( ) [EOL] BYE = enum . auto ( ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] return bytes ( str ( self . name ) , [string] ) [EOL] [EOL] [EOL] class Response ( Writeable ) : [EOL] [EOL] def __init__ ( self , condition , * , code = None , text = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . condition = condition [EOL] self . code = code [EOL] self . text = text [EOL] self . _raw = None [EOL] [EOL] @ property def is_bye ( self ) : [EOL] return self . condition == Condition . BYE [EOL] [EOL] def write ( self , writer ) : [EOL] writer . write ( bytes ( self . condition ) ) [EOL] if self . code is not None : [EOL] writer . write ( [string] % bytes ( self . code ) ) [EOL] if self . text is not None : [EOL] text_bytes = self . text . rstrip ( [string] ) . encode ( [string] , [string] ) [EOL] text_str = String . build ( text_bytes ) [EOL] writer . write ( [string] ) [EOL] text_str . write ( writer ) [EOL] writer . write ( [string] ) [EOL] [EOL] def __bytes__ ( self ) : [EOL] if self . _raw is None : [EOL] self . _raw = self . tobytes ( ) [EOL] return self . _raw [EOL] [EOL] def __repr__ ( self ) : [EOL] raw = bytes ( self ) . decode ( [string] ) [EOL] return f' [string] { repr ( raw ) } [string] ' [EOL] [EOL] [EOL] class BadCommandResponse ( Response ) : [EOL] [EOL] def __init__ ( self , exc ) : [EOL] super ( ) . __init__ ( Condition . NO , text = [string] % exc ) [EOL] [EOL] [EOL] class NoOpResponse ( Response ) : [EOL] [EOL] def __init__ ( self , tag ) : [EOL] if tag is None : [EOL] code = None [EOL] else : [EOL] code = BytesFormat ( [string] ) % String . build ( tag ) [EOL] super ( ) . __init__ ( Condition . OK , code = code ) [EOL] [EOL] [EOL] class CapabilitiesResponse ( Response ) : [EOL] [EOL] def __init__ ( self , capabilities , * , code = None ) : [EOL] super ( ) . __init__ ( Condition . OK , code = code ) [EOL] self . capabilities = capabilities [EOL] [EOL] def write ( self , writer ) : [EOL] for cap_name , cap_val in self . capabilities . items ( ) : [EOL] quoted_name = QuotedString ( cap_name ) [EOL] if cap_val is None : [EOL] line = BytesFormat ( [string] ) % ( quoted_name , ) [EOL] else : [EOL] quoted_val = QuotedString ( bytes ( cap_val ) ) [EOL] line = BytesFormat ( [string] ) % ( quoted_name , quoted_val ) [EOL] writer . write ( line ) [EOL] super ( ) . write ( writer ) [EOL] [EOL] [EOL] class GetScriptResponse ( Response ) : [EOL] [EOL] def __init__ ( self , script_data ) : [EOL] super ( ) . __init__ ( Condition . OK ) [EOL] self . script_data = script_data [EOL] [EOL] def write ( self , writer ) : [EOL] data_str = LiteralString ( self . script_data ) [EOL] data_str . write ( writer ) [EOL] writer . write ( [string] ) [EOL] super ( ) . write ( writer ) [EOL] [EOL] [EOL] class ListScriptsResponse ( Response ) : [EOL] [EOL] def __init__ ( self , active , names ) : [EOL] super ( ) . __init__ ( Condition . OK ) [EOL] self . active = active [EOL] self . names = names [EOL] [EOL] def write ( self , writer ) : [EOL] for name in self . names : [EOL] name_str = String . build ( name ) [EOL] name_str . write ( writer ) [EOL] if self . active and name == self . active : [EOL] writer . write ( [string] ) [EOL] else : [EOL] writer . write ( [string] ) [EOL] super ( ) . write ( writer ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.parsing.exceptions.NotParseable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.exceptions.NotParseable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $pymap.bytes.MaybeBytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.MaybeBytes$ 0 $pymap.bytes.MaybeBytes$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.WriteStream$ 0 0
[EOL] from typing import Optional , Union , List , Mapping , Awaitable , Dict [EOL] import asyncio [EOL] import argparse [EOL] import pymap [EOL] import response [EOL] import builtins [EOL] import state [EOL] import pysasl [EOL] import typing [EOL] import proxyprotocol [EOL] import command [EOL] from __future__ import annotations [EOL] [EOL] import asyncio [EOL] import binascii [EOL] import logging [EOL] import re [EOL] from argparse import ArgumentParser [EOL] from asyncio import StreamReader , StreamWriter , AbstractServer [EOL] from base64 import b64encode , b64decode [EOL] from collections import OrderedDict [EOL] from contextlib import closing , AsyncExitStack [EOL] from typing import Optional , Union , Mapping , Dict , List , Awaitable [EOL] [EOL] from proxyprotocol import ProxyProtocolResult [EOL] from proxyprotocol . sock import SocketInfo [EOL] from pymap import __version__ [EOL] from pymap . bytes import BytesFormat [EOL] from pymap . config import IMAPConfig [EOL] from pymap . context import socket_info , language_code , connection_exit [EOL] from pymap . exceptions import InvalidAuth [EOL] from pymap . interfaces . backend import ServiceInterface [EOL] from pymap . interfaces . session import LoginProtocol , SessionInterface [EOL] from pymap . parsing . exceptions import NotParseable [EOL] from pymap . parsing . primitives import String [EOL] from pysasl import ServerChallenge , ChallengeResponse , AuthenticationError , AuthenticationCredentials [EOL] [EOL] from . command import Command , NoOpCommand , LogoutCommand , CapabilityCommand , AuthenticateCommand , UnauthenticateCommand , StartTLSCommand [EOL] from . response import Condition , Response , BadCommandResponse , NoOpResponse , CapabilitiesResponse [EOL] from . state import FilterState [EOL] from . . import SieveCompiler [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] _log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class ManageSieveService ( ServiceInterface ) : [comment] [EOL] [docstring] [EOL] [EOL] @ classmethod def add_arguments ( cls , parser ) : [EOL] group = parser . add_argument_group ( [string] ) [EOL] group . add_argument ( [string] , action = [string] , metavar = [string] , help = [string] ) [EOL] group . add_argument ( [string] , metavar = [string] , default = [string] , help = [string] ) [EOL] [EOL] async def start ( self ) : [EOL] backend = self . backend [EOL] config = self . config [EOL] managesieve_server = ManageSieveServer ( backend . login , config ) [EOL] host = config . args . sieve_host [EOL] port = config . args . sieve_port [EOL] server = await asyncio . start_server ( managesieve_server , host = host , port = port ) [EOL] return asyncio . create_task ( self . _run ( server ) ) [EOL] [EOL] @ classmethod async def _run ( cls , server ) : [EOL] async with server : [EOL] await server . serve_forever ( ) [EOL] [EOL] [EOL] class ManageSieveServer : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , login , config ) : [EOL] super ( ) . __init__ ( ) [EOL] self . _login = login [EOL] self . _config = config [EOL] [EOL] async def __call__ ( self , reader , writer ) : [EOL] conn = ManageSieveConnection ( self . _login , self . _config , reader , writer ) [EOL] async with AsyncExitStack ( ) as stack : [EOL] connection_exit . set ( stack ) [EOL] stack . enter_context ( closing ( writer ) ) [EOL] await conn . run ( ) [EOL] [EOL] [EOL] class ManageSieveConnection : [EOL] [docstring] [EOL] [EOL] _lines = re . compile ( [string] ) [EOL] _literal_plus = re . compile ( [string] ) [EOL] _impl = [string] + __version__ . encode ( [string] ) [EOL] [EOL] def __init__ ( self , login , config , reader , writer ) : [EOL] super ( ) . __init__ ( ) [EOL] self . login = login [EOL] self . config = config [EOL] self . auth = config . initial_auth [EOL] self . params = config . parsing_params . copy ( allow_continuations = False ) [EOL] self . pp_result = None [EOL] self . _offer_starttls = [string] in config . initial_capability [EOL] self . _state = None [EOL] self . _reset_streams ( reader , writer ) [EOL] [EOL] def _reset_streams ( self , reader , writer ) : [EOL] self . reader = reader [EOL] self . writer = writer [EOL] socket_info . set ( SocketInfo ( writer , self . pp_result ) ) [EOL] [EOL] async def _read_proxy_protocol ( self ) : [EOL] self . pp_result = await self . config . proxy_protocol . read ( self . reader ) [EOL] self . _reset_streams ( self . reader , self . writer ) [EOL] [EOL] def _get_state ( self , session ) : [EOL] owner = session . owner . encode ( [string] ) [EOL] if session . filter_set is None : [EOL] raise ValueError ( [string] ) [EOL] return FilterState ( session . filter_set , owner , self . config ) [EOL] [EOL] @ property def capabilities ( self ) : [EOL] ret = OrderedDict ( ) [EOL] ret [ [string] ] = self . _impl [EOL] if self . _state is None : [EOL] ret [ [string] ] = [string] . join ( mech . name for mech in self . auth . server_mechanisms ) [EOL] ret [ [string] ] = [string] . join ( SieveCompiler . extensions ) [EOL] if self . _offer_starttls and self . _state is None : [EOL] ret [ [string] ] = None [EOL] try : [EOL] ret [ [string] ] = language_code . get ( ) . encode ( [string] ) [EOL] except LookupError : [EOL] pass [EOL] if self . _state is not None : [EOL] ret [ [string] ] = self . _state . owner [EOL] ret [ [string] ] = None [EOL] ret [ [string] ] = [string] [EOL] return ret [EOL] [EOL] @ classmethod def _print ( cls , log_format , output ) : [EOL] if _log . isEnabledFor ( logging . DEBUG ) : [EOL] fd = socket_info . get ( ) . socket . fileno ( ) [EOL] if not isinstance ( output , str ) : [EOL] output = str ( output , [string] , [string] ) [EOL] lines = cls . _lines . split ( output ) [EOL] if not lines [ - [number] ] : [EOL] lines = lines [ : - [number] ] [EOL] for line in lines : [EOL] _log . debug ( log_format , fd , line ) [EOL] [EOL] async def _read_data ( self ) : [EOL] data = bytearray ( ) [EOL] while True : [EOL] data += await self . reader . readline ( ) [EOL] if not data . endswith ( [string] ) : [EOL] raise EOFError ( ) [EOL] match = self . _literal_plus . search ( data ) [EOL] if not match : [EOL] break [EOL] literal_length = int ( match . group ( [number] ) ) [EOL] data += await self . reader . readexactly ( literal_length ) [EOL] self . _print ( [string] , data ) [EOL] return memoryview ( data ) [EOL] [EOL] async def _read_command ( self ) : [EOL] cmd_buf = await self . _read_data ( ) [EOL] cmd , _ = Command . parse ( cmd_buf , self . params ) [EOL] return cmd [EOL] [EOL] async def _write_response ( self , resp ) : [EOL] resp . write ( self . writer ) [EOL] try : [EOL] await self . writer . drain ( ) [EOL] except ConnectionError : [EOL] pass [EOL] else : [EOL] self . _print ( [string] , bytes ( resp ) ) [EOL] [EOL] async def _login ( self , creds ) : [EOL] stack = connection_exit . get ( ) [EOL] return await stack . enter_async_context ( self . login ( creds ) ) [EOL] [EOL] async def _do_greeting ( self ) : [EOL] preauth_creds = self . config . preauth_credentials [EOL] if preauth_creds : [EOL] session = await self . _login ( preauth_creds ) [EOL] try : [EOL] self . _state = self . _get_state ( session ) [EOL] except ValueError as exc : [EOL] return Response ( Condition . NO , text = str ( exc ) ) [EOL] return CapabilitiesResponse ( self . capabilities ) [EOL] [EOL] async def _do_authenticate ( self , cmd ) : [EOL] mech = self . auth . get_server ( cmd . mech_name ) [EOL] if not mech : [EOL] return Response ( Condition . NO , text = [string] ) [EOL] responses = [ ] [EOL] if cmd . initial_data is not None : [EOL] resp_dec = b64decode ( cmd . initial_data ) [EOL] responses . append ( ChallengeResponse ( [string] , resp_dec ) ) [EOL] while True : [EOL] try : [EOL] creds , final = mech . server_attempt ( responses ) [EOL] except ServerChallenge as chal : [EOL] chal_bytes = b64encode ( chal . data ) [EOL] chal_str = String . build ( chal_bytes ) [EOL] chal_str . write ( self . writer ) [EOL] self . writer . write ( [string] ) [EOL] await self . writer . drain ( ) [EOL] resp_bytes = await self . _read_data ( ) [EOL] resp_str , _ = String . parse ( resp_bytes , self . params ) [EOL] if resp_str . value == [string] : [EOL] raise AuthenticationError ( [string] ) [EOL] try : [EOL] resp_dec = b64decode ( resp_str . value ) [EOL] except binascii . Error as exc : [EOL] raise AuthenticationError ( ) from exc [EOL] else : [EOL] responses . append ( ChallengeResponse ( chal . data , resp_dec ) ) [EOL] except AuthenticationError as exc : [EOL] return Response ( Condition . NO , text = str ( exc ) ) [EOL] else : [EOL] break [EOL] if final is None : [EOL] code = None [EOL] else : [EOL] code = BytesFormat ( [string] ) % String . build ( final ) [EOL] try : [EOL] session = await self . _login ( creds ) [EOL] except InvalidAuth as exc : [EOL] return Response ( Condition . NO , text = str ( exc ) ) [EOL] try : [EOL] self . _state = self . _get_state ( session ) [EOL] except ValueError as exc : [EOL] return Response ( Condition . NO , text = str ( exc ) ) [EOL] return Response ( Condition . OK , code = code ) [EOL] [EOL] async def _do_unauthenticate ( self ) : [EOL] if self . _state is None : [EOL] return Response ( Condition . NO , text = [string] ) [EOL] else : [EOL] self . _state = None [EOL] return Response ( Condition . OK ) [EOL] [EOL] async def _do_starttls ( self ) : [EOL] ssl_context = self . config . ssl_context [EOL] if not self . _offer_starttls : [EOL] return Response ( Condition . NO , text = [string] ) [EOL] resp = Response ( Condition . OK ) [EOL] await self . _write_response ( resp ) [EOL] loop = asyncio . get_event_loop ( ) [EOL] transport = self . writer . transport [EOL] protocol = transport . get_protocol ( ) [EOL] new_transport = await loop . start_tls ( transport , protocol , ssl_context , server_side = True ) [EOL] new_protocol = new_transport . get_protocol ( ) [EOL] new_writer = StreamWriter ( new_transport , new_protocol , self . reader , loop ) [EOL] self . _reset_streams ( self . reader , new_writer ) [EOL] self . _print ( [string] , [string] ) [EOL] self . _offer_starttls = False [EOL] self . auth = self . config . tls_auth [EOL] return CapabilitiesResponse ( self . capabilities ) [EOL] [EOL] async def run ( self ) : [EOL] [docstring] [EOL] await self . _read_proxy_protocol ( ) [EOL] self . _print ( [string] , str ( socket_info . get ( ) ) ) [EOL] greeting = await self . _do_greeting ( ) [EOL] await self . _write_response ( greeting ) [EOL] while True : [EOL] resp = ... [EOL] try : [EOL] cmd = await self . _read_command ( ) [EOL] except ( ConnectionError , EOFError ) : [EOL] break [EOL] except NotParseable as exc : [EOL] resp = BadCommandResponse ( exc ) [EOL] else : [EOL] try : [EOL] if isinstance ( cmd , NoOpCommand ) : [EOL] resp = NoOpResponse ( cmd . tag ) [EOL] elif isinstance ( cmd , LogoutCommand ) : [EOL] resp = Response ( Condition . BYE ) [EOL] elif isinstance ( cmd , CapabilityCommand ) : [EOL] resp = CapabilitiesResponse ( self . capabilities ) [EOL] elif self . _state is None : [EOL] if isinstance ( cmd , AuthenticateCommand ) : [EOL] resp = await self . _do_authenticate ( cmd ) [EOL] elif isinstance ( cmd , StartTLSCommand ) : [EOL] resp = await self . _do_starttls ( ) [EOL] else : [EOL] resp = Response ( Condition . NO , text = [string] ) [EOL] else : [EOL] if isinstance ( cmd , UnauthenticateCommand ) : [EOL] resp = await self . _do_unauthenticate ( ) [EOL] else : [EOL] resp = await self . _state . run ( cmd ) [EOL] except Exception : [EOL] _log . exception ( [string] ) [EOL] resp = Response ( Condition . NO , text = [string] ) [EOL] await self . _write_response ( resp ) [EOL] if resp . is_bye : [EOL] break [EOL] self . _print ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Awaitable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 $typing.Union[builtins.str,builtins.int]$ 0 $typing.Union[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $asyncio.AbstractServer$ 0 0 0 0 0 $asyncio.AbstractServer$ 0 0 0 $asyncio.AbstractServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pymap.interfaces.session.LoginProtocol$ 0 $pymap.config.IMAPConfig$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.session.LoginProtocol$ 0 0 0 0 0 $pymap.config.IMAPConfig$ 0 0 0 0 $None$ 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[proxyprotocol.ProxyProtocolResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[state.FilterState]$ 0 0 0 0 0 0 0 $asyncio.StreamReader$ 0 $asyncio.StreamWriter$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $state.FilterState$ 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 0 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.bytes,typing.Optional[builtins.bytes]]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.memoryview$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $command.Command$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $response.Response$ 0 0 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $response.Response$ 0 0 0 0 0 0 $pymap.interfaces.session.SessionInterface$ 0 0 0 $pysasl.AuthenticationCredentials$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pysasl.AuthenticationCredentials$ 0 0 0 0 0 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $response.Response$ 0 0 0 $command.AuthenticateCommand$ 0 0 0 0 0 0 0 0 0 0 0 $command.AuthenticateCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 $command.AuthenticateCommand$ 0 0 0 0 0 0 0 0 0 0 0 $command.AuthenticateCommand$ 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pysasl.ChallengeResponse]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $response.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . mime import MessageContent [EOL] from pymap . mime . cte import MessageDecoder [EOL] [EOL] _7bit_body = [string] [EOL] _8bit_body = [string] [EOL] _qp_body = [string] [EOL] _b64_body = [string] [EOL] [EOL] [EOL] class TestMessageDecoder ( unittest . TestCase ) : [EOL] [EOL] def test_7bit_cte ( self ) : [EOL] data = [string] + _7bit_body [EOL] msg = MessageContent . parse ( data ) [EOL] decoded = MessageDecoder . of ( msg . header ) . decode ( msg . body ) [EOL] self . assertEqual ( [string] , bytes ( decoded ) ) [EOL] [EOL] def test_8bit_cte ( self ) : [EOL] data = [string] + _8bit_body [EOL] msg = MessageContent . parse ( data ) [EOL] decoded = MessageDecoder . of ( msg . header ) . decode ( msg . body ) [EOL] self . assertEqual ( [string] , bytes ( decoded ) ) [EOL] [EOL] def test_quopri_cte ( self ) : [EOL] data = [string] + _qp_body [EOL] msg = MessageContent . parse ( data ) [EOL] decoded = MessageDecoder . of ( msg . header ) . decode ( msg . body ) [EOL] self . assertEqual ( [string] , bytes ( decoded ) ) [EOL] [EOL] def test_base64_cte ( self ) : [EOL] data = [string] + _b64_body [EOL] msg = MessageContent . parse ( data ) [EOL] decoded = MessageDecoder . of ( msg . header ) . decode ( msg . body ) [EOL] self . assertEqual ( [string] , bytes ( decoded ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 0 $pymap.bytes.Writeable$ 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.bytes.Writeable$ 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing . response . code import Capability , PermanentFlags , UidNext , UidValidity , Unseen , AppendUid , CopyUid [EOL] [EOL] [EOL] class TestCapability ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = Capability ( [ ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] code = Capability ( [ [string] ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] code = Capability ( [ [string] , [string] ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestPermanentFlags ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = PermanentFlags ( [ [string] , [string] ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestUidNext ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = UidNext ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestUidValidity ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = UidValidity ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestUnseen ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = Unseen ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestAppendUid ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = AppendUid ( [number] , [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL] [EOL] [EOL] class TestCopyUid ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] code = CopyUid ( [number] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertEqual ( [string] , bytes ( code ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Capability$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.PermanentFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.PermanentFlags$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.UidNext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.UidNext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.UidValidity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.UidValidity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Unseen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.Unseen$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.AppendUid$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.AppendUid$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.CopyUid$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.code.CopyUid$ 0 0 0
[EOL] import unittest [EOL] [EOL] from pymap . flags import FlagOp [EOL] from pymap . parsing import Params [EOL] from pymap . parsing . exceptions import NotParseable [EOL] from pymap . parsing . command . select import ExpungeCommand , CopyCommand , MoveCommand , FetchCommand , StoreCommand , SearchCommand , UidExpungeCommand , UidCopyCommand , UidMoveCommand , UidFetchCommand , UidStoreCommand , UidSearchCommand , IdleCommand [EOL] from pymap . parsing . specials import FetchAttribute , SearchKey , Flag [EOL] [EOL] [EOL] class TestExpungeCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = ExpungeCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidExpungeCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] self . assertTrue ( ret . uid_set . uid ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . uid_set . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] [EOL] class TestCopyCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = CopyCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertFalse ( ret . sequence_set . uid ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertEqual ( [string] , ret . mailbox ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidCopyCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] self . assertTrue ( ret . sequence_set . uid ) [EOL] [EOL] [EOL] class TestMoveCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = MoveCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertFalse ( ret . sequence_set . uid ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertEqual ( [string] , ret . mailbox ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidMoveCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] self . assertTrue ( ret . sequence_set . uid ) [EOL] [EOL] [EOL] class TestFetchCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = FetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertFalse ( ret . sequence_set . uid ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertEqual ( [number] , len ( ret . attributes ) ) [EOL] self . assertListEqual ( [ FetchAttribute ( [string] ) ] , ret . attributes ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidFetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] self . assertTrue ( ret . sequence_set . uid ) [EOL] [EOL] def test_parse_list ( self ) : [EOL] ret , buf = FetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertListEqual ( [ FetchAttribute ( [string] ) , FetchAttribute ( [string] ) ] , ret . attributes ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_macro_all ( self ) : [EOL] ret , buf = FetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertListEqual ( [ FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) ] , ret . attributes ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_macro_full ( self ) : [EOL] ret , buf = FetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertListEqual ( [ FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) ] , ret . attributes ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_macro_fast ( self ) : [EOL] ret , buf = FetchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertListEqual ( [ FetchAttribute ( [string] ) , FetchAttribute ( [string] ) , FetchAttribute ( [string] ) ] , ret . attributes ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] [EOL] class TestStoreCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = StoreCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertFalse ( ret . sequence_set . uid ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertSetEqual ( { Flag ( [string] ) } , ret . flag_set ) [EOL] self . assertEqual ( FlagOp . ADD , ret . mode ) [EOL] self . assertTrue ( ret . silent ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidStoreCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] self . assertTrue ( ret . sequence_set . uid ) [EOL] [EOL] def test_parse_simple ( self ) : [EOL] ret , buf = StoreCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . sequence_set . value ) [EOL] self . assertSetEqual ( { Flag ( [string] ) } , ret . flag_set ) [EOL] self . assertEqual ( FlagOp . REPLACE , ret . mode ) [EOL] self . assertFalse ( ret . silent ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] StoreCommand . parse ( [string] , Params ( ) ) [EOL] [EOL] [EOL] class TestSearchCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse_charset ( self ) : [EOL] ret , buf = SearchCommand . _parse_charset ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_charset_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] SearchCommand . _parse_charset ( [string] , Params ( ) ) [EOL] [EOL] def test_parse_charset_default ( self ) : [EOL] ret , buf = SearchCommand . _parse_charset ( [string] , Params ( ) ) [EOL] self . assertIsNone ( ret ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = SearchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertFalse ( ret . uid ) [EOL] self . assertSetEqual ( { SearchKey ( [string] ) } , ret . keys ) [EOL] self . assertIsNone ( ret . charset ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_uid ( self ) : [EOL] ret , buf = UidSearchCommand . parse ( [string] , Params ( ) ) [EOL] self . assertTrue ( ret . uid ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] SearchCommand . parse ( [string] , Params ( ) ) [EOL] [EOL] [EOL] class TestIdleCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = IdleCommand . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , IdleCommand ) [EOL] self . assertEqual ( [string] , ret . continuation ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] IdleCommand . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_parse_done ( self ) : [EOL] ok , buf = IdleCommand ( [string] ) . parse_done ( [string] ) [EOL] self . assertTrue ( ok ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_done_bad ( self ) : [EOL] ok , buf = IdleCommand ( [string] ) . parse_done ( [string] ) [EOL] self . assertFalse ( ok ) [EOL] self . assertEqual ( [string] , buf ) [EOL] ok , buf = IdleCommand ( [string] ) . parse_done ( [string] ) [EOL] self . assertFalse ( ok ) [EOL] self . assertEqual ( [string] , buf ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing . response . specials import FlagsResponse , ExistsResponse , RecentResponse , ExpungeResponse , FetchResponse , SearchResponse , ESearchResponse , ListResponse , LSubResponse [EOL] from pymap . parsing . specials import FetchAttribute , FetchValue [EOL] [EOL] [EOL] class TestFlagsResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = FlagsResponse ( [ [string] , [string] ] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestExistsResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = ExistsResponse ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestRecentResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = RecentResponse ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestExpungeResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = ExpungeResponse ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestFetchResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = FetchResponse ( [number] , [ FetchValue . of ( FetchAttribute ( [string] ) , [string] ) ] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestSearchResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = SearchResponse ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestESearchResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = ESearchResponse ( [string] , True , { [string] : [string] , [string] : [string] } ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestListResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp1 = ListResponse ( [string] , [string] , [ ] ) [EOL] self . assertEqual ( [string] , bytes ( resp1 ) ) [EOL] resp2 = ListResponse ( [string] , [string] , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( [string] [string] , bytes ( resp2 ) ) [EOL] [EOL] [EOL] class TestLSubResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp1 = LSubResponse ( [string] , [string] , [ ] ) [EOL] self . assertEqual ( [string] , bytes ( resp1 ) ) [EOL] resp2 = LSubResponse ( [string] , [string] , [ [string] , [string] , [string] ] ) [EOL] self . assertEqual ( [string] [string] , bytes ( resp2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.FlagsResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.FlagsResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ExistsResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ExistsResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.RecentResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.RecentResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ExpungeResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ExpungeResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.FetchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.FetchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.SearchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.SearchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ESearchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ESearchResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ListResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ListResponse$ 0 0 0 $pymap.parsing.response.specials.ListResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.ListResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.LSubResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.LSubResponse$ 0 0 0 $pymap.parsing.response.specials.LSubResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.specials.LSubResponse$ 0 0 0
[EOL] import unittest [EOL] [EOL] from pymap . listtree import ListEntry , ListTree [EOL] [EOL] [EOL] class TestListEntry ( unittest . TestCase ) : [EOL] [EOL] def test_attributes ( self ) : [EOL] self . assertEqual ( [ [string] ] , ListEntry ( [string] , True , None , False ) . attributes ) [EOL] self . assertEqual ( [ [string] ] , ListEntry ( [string] , True , None , True ) . attributes ) [EOL] self . assertEqual ( [ [string] , [string] ] , ListEntry ( [string] , False , None , True ) . attributes ) [EOL] self . assertEqual ( [ [string] , [string] ] , ListEntry ( [string] , True , True , False ) . attributes ) [EOL] self . assertEqual ( [ [string] , [string] ] , ListEntry ( [string] , True , False , False ) . attributes ) [EOL] [EOL] [EOL] class TestListTree ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] tree = ListTree ( [string] ) [EOL] tree . update ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] tree . set_marked ( [string] , marked = True ) [EOL] tree . set_marked ( [string] , unmarked = True ) [EOL] self . tree = tree [EOL] [EOL] def test_list ( self ) : [EOL] self . assertEqual ( [ ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , False , None , True ) , ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , False , None , True ) , ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , True , True , True ) , ListEntry ( [string] , True , False , False ) ] , list ( self . tree . list ( ) ) ) [EOL] [EOL] def test_list_matching ( self ) : [EOL] self . assertEqual ( [ ListEntry ( [string] , False , None , True ) , ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , False , None , True ) , ListEntry ( [string] , True , None , False ) ] , list ( self . tree . list_matching ( [string] , [string] ) ) ) [EOL] self . assertEqual ( [ ListEntry ( [string] , True , None , False ) , ListEntry ( [string] , False , None , True ) ] , list ( self . tree . list_matching ( [string] , [string] ) ) ) [EOL] self . assertEqual ( [ ListEntry ( [string] , True , None , False ) ] , list ( self . tree . list_matching ( [string] , [string] ) ) ) [EOL] [EOL] def test_get_renames ( self ) : [EOL] self . assertEqual ( [ ] , self . tree . get_renames ( [string] , [string] ) ) [EOL] self . assertEqual ( [ ( [string] , [string] ) , ( [string] , [string] ) ] , self . tree . get_renames ( [string] , [string] ) ) [EOL] self . assertEqual ( [ ( [string] , [string] ) ] , self . tree . get_renames ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] from datetime import datetime , timezone , timedelta [EOL] [EOL] from pymap . parsing import Params [EOL] from pymap . parsing . exceptions import NotParseable , UnexpectedType , InvalidContent [EOL] from pymap . parsing . specials import AString , Tag , Mailbox , DateTime , Flag , StatusAttribute , SequenceSet , FetchAttribute , SearchKey , ObjectId , ExtensionOptions [EOL] from pymap . parsing . state import ParsingState [EOL] from pymap . parsing . specials . sequenceset import MaxValue [EOL] [EOL] [EOL] class TestAString ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = AString . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , AString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_quoted ( self ) : [EOL] ret , buf = AString . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , AString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_literal ( self ) : [EOL] state = ParsingState ( continuations = [ memoryview ( [string] ) ] ) [EOL] ret , buf = AString . parse ( [string] , Params ( state ) ) [EOL] self . assertIsInstance ( ret , AString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_bytes ( self ) : [EOL] a1 = AString ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( a1 ) ) [EOL] a2 = AString ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( a2 ) ) [EOL] self . assertEqual ( [string] , bytes ( a2 ) ) [EOL] [EOL] [EOL] class TestTag ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Tag . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Tag ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Tag . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] tag1 = Tag ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( tag1 ) ) [EOL] [EOL] [EOL] class TestMailbox ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Mailbox . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Mailbox ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_inbox ( self ) : [EOL] ret , buf = Mailbox . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Mailbox ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_quoted ( self ) : [EOL] ret , buf = Mailbox . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Mailbox ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Mailbox . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] mbx = Mailbox ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( mbx ) ) [EOL] self . assertEqual ( [string] , bytes ( mbx ) ) [EOL] [EOL] def test_str ( self ) : [EOL] mbx = Mailbox ( [string] ) [EOL] self . assertEqual ( [string] , str ( mbx ) ) [EOL] [EOL] [EOL] class TestObjectId ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = ObjectId . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , ObjectId ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] ObjectId . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] ret = ObjectId ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] [EOL] def test_parens ( self ) : [EOL] ret = ObjectId ( [string] ) [EOL] self . assertEqual ( [string] , ret . parens ) [EOL] [EOL] def test_maybe ( self ) : [EOL] self . assertEqual ( ObjectId ( None ) , ObjectId . maybe ( None ) ) [EOL] self . assertEqual ( ObjectId ( None ) , ObjectId . maybe ( [string] ) ) [EOL] self . assertEqual ( ObjectId ( None ) , ObjectId . maybe ( [string] ) ) [EOL] self . assertEqual ( ObjectId ( [string] ) , ObjectId . maybe ( [string] ) ) [EOL] self . assertEqual ( ObjectId ( [string] ) , ObjectId . maybe ( [string] ) ) [EOL] [EOL] def test_random ( self ) : [EOL] mailbox_id = ObjectId . random_mailbox_id ( ) [EOL] self . assertEqual ( [string] , mailbox_id . value [ [number] : [number] ] ) [EOL] self . assertTrue ( len ( mailbox_id . value ) ) [EOL] email_id = ObjectId . random_email_id ( ) [EOL] self . assertEqual ( [string] , email_id . value [ [number] : [number] ] ) [EOL] self . assertTrue ( len ( email_id . value ) ) [EOL] thread_id = ObjectId . random_thread_id ( ) [EOL] self . assertEqual ( [string] , thread_id . value [ [number] : [number] ] ) [EOL] self . assertTrue ( len ( thread_id . value ) ) [EOL] [EOL] [EOL] class TestDateTime ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = DateTime . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , DateTime ) [EOL] self . assertEqual ( [number] , ret . value . day ) [EOL] self . assertEqual ( [number] , ret . value . month ) [EOL] self . assertEqual ( [number] , ret . value . year ) [EOL] self . assertEqual ( [number] , ret . value . hour ) [EOL] self . assertEqual ( [number] , ret . value . minute ) [EOL] self . assertEqual ( [number] , ret . value . second ) [EOL] self . assertEqual ( [number] , ret . value . utcoffset ( ) . total_seconds ( ) ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( InvalidContent ) : [EOL] DateTime . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] dt1 = DateTime ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = timezone ( timedelta ( hours = [number] ) ) ) ) [EOL] self . assertEqual ( [string] , bytes ( dt1 ) ) [EOL] dt2 = DateTime ( datetime . now ( ) , [string] ) [EOL] self . assertEqual ( [string] , bytes ( dt2 ) ) [EOL] [EOL] [EOL] class TestFlag ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret1 , buf1 = Flag . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret1 . value ) [EOL] self . assertEqual ( [string] , buf1 ) [EOL] ret2 , buf2 = Flag . parse ( buf1 , Params ( ) ) [EOL] self . assertEqual ( [string] , ret2 . value ) [EOL] self . assertEqual ( [string] , buf2 ) [EOL] [EOL] def test_bytes ( self ) : [EOL] f1 = Flag ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( f1 ) ) [EOL] f2 = Flag ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( f2 ) ) [EOL] [EOL] [EOL] class TestStatusAttribute ( unittest . TestCase ) : [EOL] [EOL] def test_valueerror ( self ) : [EOL] with self . assertRaises ( ValueError ) : [EOL] StatusAttribute ( [string] ) [EOL] StatusAttribute ( [string] ) [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = StatusAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_invalid ( self ) : [EOL] with self . assertRaises ( InvalidContent ) : [EOL] StatusAttribute . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] attr = StatusAttribute ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( attr ) ) [EOL] [EOL] [EOL] class TestSequenceSet ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = SequenceSet . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [ [number] , MaxValue ( ) , ( [number] , MaxValue ( ) ) , ( MaxValue ( ) , [number] ) ] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] SequenceSet . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] SequenceSet . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] SequenceSet . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] SequenceSet . parse ( [string] , Params ( ) ) [EOL] [EOL] [EOL] class TestFetchAttribute ( unittest . TestCase ) : [EOL] [EOL] def test_hash ( self ) : [EOL] attr1 = FetchAttribute ( [string] ) [EOL] attr2 = FetchAttribute ( [string] ) [EOL] self . assertEqual ( hash ( attr1 ) , hash ( attr2 ) ) [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [ [number] , [number] ] , ret . section . parts ) [EOL] self . assertEqual ( [string] , ret . section . specifier ) [EOL] self . assertEqual ( { [string] , [string] } , ret . section . headers ) [EOL] self . assertEqual ( ( [number] , [number] ) , ret . partial ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_simple ( self ) : [EOL] ret1 , _ = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret1 . value ) [EOL] self . assertIsNone ( ret1 . section ) [EOL] self . assertIsNone ( ret1 . partial ) [EOL] ret2 , _ = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret2 . value ) [EOL] self . assertIsNone ( ret2 . section ) [EOL] self . assertIsNone ( ret2 . partial ) [EOL] [EOL] def test_parse_sections ( self ) : [EOL] ret1 , _ = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret1 . value ) [EOL] self . assertEqual ( [ [number] , [number] ] , ret1 . section . parts ) [EOL] self . assertIsNone ( ret1 . section . specifier ) [EOL] self . assertIsNone ( ret1 . section . headers ) [EOL] self . assertIsNone ( ret1 . partial ) [EOL] ret2 , _ = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret2 . value ) [EOL] self . assertEqual ( [ [number] , [number] ] , ret2 . section . parts ) [EOL] self . assertEqual ( [string] , ret2 . section . specifier ) [EOL] self . assertIsNone ( ret2 . section . headers ) [EOL] self . assertIsNone ( ret2 . partial ) [EOL] ret3 , _ = FetchAttribute . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret3 . value ) [EOL] self . assertEqual ( [ ] , ret3 . section . parts ) [EOL] self . assertEqual ( [string] , ret3 . section . specifier ) [EOL] self . assertIsNone ( ret3 . section . headers ) [EOL] self . assertIsNone ( ret3 . partial ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] FetchAttribute . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] attr1 = FetchAttribute ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( attr1 ) ) [EOL] self . assertEqual ( [string] , bytes ( attr1 ) ) [EOL] section = FetchAttribute . Section ( ( [number] , [number] ) , [string] , frozenset ( { [string] , [string] } ) ) [EOL] attr2 = FetchAttribute ( [string] , section , ( [number] , [number] ) ) [EOL] self . assertEqual ( [string] , bytes ( attr2 ) ) [EOL] self . assertEqual ( [string] , bytes ( attr2 . for_response ) ) [EOL] [EOL] [EOL] class TestSearchKey ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertIsNone ( ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_seqset ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertIsInstance ( ret . filter , SequenceSet ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . filter . value ) [EOL] self . assertTrue ( ret . inverse ) [EOL] [EOL] def test_parse_list ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertIsInstance ( ret . filter , list ) [EOL] self . assertEqual ( [number] , len ( ret . filter ) ) [EOL] self . assertEqual ( [string] , ret . filter [ [number] ] . value ) [EOL] self . assertIsInstance ( ret . filter [ [number] ] . filter , SequenceSet ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . filter [ [number] ] . filter . value ) [EOL] self . assertFalse ( ret . filter [ [number] ] . inverse ) [EOL] self . assertEqual ( [string] , ret . filter [ [number] ] . value ) [EOL] self . assertIsInstance ( ret . filter [ [number] ] . filter , SequenceSet ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . filter [ [number] ] . filter . value ) [EOL] self . assertTrue ( ret . filter [ [number] ] . inverse ) [EOL] [EOL] def test_parse_list_error ( self ) : [EOL] with self . assertRaises ( UnexpectedType ) : [EOL] SearchKey . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] SearchKey . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_parse_filter_astring ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_date ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( datetime ( [number] , [number] , [number] ) , ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_keyword ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_number ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [number] , ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_uid ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertIsInstance ( ret . filter , SequenceSet ) [EOL] self . assertEqual ( [ [number] , [number] , [number] ] , ret . filter . value ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_header ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( ( [string] , [string] ) , ret . filter ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_filter_or ( self ) : [EOL] ret , buf = SearchKey . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , ret . filter [ [number] ] . value ) [EOL] self . assertEqual ( [string] , ret . filter [ [number] ] . value ) [EOL] self . assertFalse ( ret . inverse ) [EOL] [EOL] def test_parse_error ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] SearchKey . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] SearchKey . parse ( [string] , Params ( ) ) [EOL] [EOL] [EOL] class TestExtensionOptions ( unittest . TestCase ) : [EOL] [EOL] def test_parse_empty ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { [string] : [ ] , [string] : [ ] } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_num ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ [string] ] } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_seqset ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ [string] ] } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_string ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ ] } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_nested ( self ) : [EOL] ret , buf = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( { [string] : [ [string] , [ [string] ] ] } , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_bytes ( self ) : [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] ret , _ = ExtensionOptions . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.astring.AString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.astring.AString$ 0 0 0 $pymap.parsing.specials.astring.AString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.astring.AString$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.astring.AString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.tag.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.tag.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.mailbox.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.mailbox.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.mailbox.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.mailbox.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.mailbox.Mailbox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.objectid.ObjectId$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.datetime_.DateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.datetime_.DateTime$ 0 0 0 $pymap.parsing.specials.datetime_.DateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.datetime_.DateTime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.flag.Flag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.flag.Flag$ 0 0 0 $pymap.parsing.specials.flag.Flag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.flag.Flag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.statusattr.StatusAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.statusattr.StatusAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute.Section$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute.Section$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.fetchattr.FetchAttribute$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import unittest [EOL] [EOL] from pymap . parsing import Params [EOL] from pymap . parsing . command . nonauth import AuthenticateCommand , LoginCommand [EOL] [EOL] [EOL] class TestAuthenticateCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = AuthenticateCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . mech_name ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] [EOL] class TestLoginCommand ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = LoginCommand . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , ret . userid ) [EOL] self . assertEqual ( [string] , ret . password ) [EOL] self . assertEqual ( [string] , buf ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing import Params , ExpectedParseable , Space , EndLine [EOL] from pymap . parsing . exceptions import NotParseable [EOL] from pymap . parsing . primitives import Nil , Number , Atom , String , QuotedString , ListP [EOL] [EOL] [EOL] class TestExpectedParseable ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] nil , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ Nil ] ) ) [EOL] self . assertIsInstance ( nil , Nil ) [EOL] num , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ Number ] ) ) [EOL] self . assertIsInstance ( num , Number ) [EOL] atom , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ Atom ] ) ) [EOL] self . assertIsInstance ( atom , Atom ) [EOL] qstr , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ String ] ) ) [EOL] self . assertIsInstance ( qstr , QuotedString ) [EOL] list_ , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ ListP ] ) ) [EOL] self . assertIsInstance ( list_ , ListP ) [EOL] [EOL] def test_parse_expectation_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] ExpectedParseable . parse ( [string] , Params ( expected = [ Number , Nil ] ) ) [EOL] [EOL] def test_parse_expectation_casting ( self ) : [EOL] num , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ Atom ] ) ) [EOL] self . assertIsInstance ( num , Atom ) [EOL] nil , _ = ExpectedParseable . parse ( [string] , Params ( expected = [ Atom ] ) ) [EOL] self . assertIsInstance ( num , Atom ) [EOL] [EOL] [EOL] class TestSpace ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Space . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Space ) [EOL] self . assertEqual ( [number] , ret . length ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Space . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] Space . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] ret = Space ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] [EOL] [EOL] class TestEndLine ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = EndLine . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , EndLine ) [EOL] self . assertEqual ( [number] , ret . preceding_spaces ) [EOL] self . assertTrue ( ret . carriage_return ) [EOL] [EOL] def test_parse_no_cr ( self ) : [EOL] ret , buf = EndLine . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , EndLine ) [EOL] self . assertEqual ( [number] , ret . preceding_spaces ) [EOL] self . assertFalse ( ret . carriage_return ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] EndLine . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] EndLine . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] endl1 = EndLine ( [number] , True ) [EOL] self . assertEqual ( [string] , bytes ( endl1 ) ) [EOL] endl2 = EndLine ( [number] , False ) [EOL] self . assertEqual ( [string] , bytes ( endl2 ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.Space$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.Space$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.EndLine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.EndLine$ 0 0 0 $pymap.parsing.EndLine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.EndLine$ 0 0 0
[EOL] from typing import Optional [EOL] import typing [EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing . response import CommandResponse , ResponseContinuation , ResponseBad , ResponseNo , ResponseOk , ResponseBye , ResponseCode [EOL] [EOL] [EOL] _alert = ResponseCode . of ( [string] ) [EOL] [EOL] [EOL] class TestResponse ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = CommandResponse ( [string] , [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] resp . add_untagged_ok ( [string] ) [EOL] self . assertEqual ( [string] [string] , bytes ( resp ) ) [EOL] resp . add_untagged_ok ( [string] ) [EOL] self . assertEqual ( [string] [string] [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestResponseContinuation ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = ResponseContinuation ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL] [EOL] [EOL] class TestResponseBad ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp1 = ResponseBad ( [string] , [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp1 ) ) [EOL] resp2 = ResponseBad ( [string] , [string] , _alert ) [EOL] self . assertEqual ( [string] , bytes ( resp2 ) ) [EOL] [EOL] [EOL] class TestResponseNo ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp1 = ResponseNo ( [string] , [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp1 ) ) [EOL] resp2 = ResponseNo ( [string] , [string] , _alert ) [EOL] self . assertEqual ( [string] , bytes ( resp2 ) ) [EOL] [EOL] [EOL] class TestResponseOk ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp1 = ResponseOk ( [string] , [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp1 ) ) [EOL] resp2 = ResponseOk ( [string] , [string] , _alert ) [EOL] self . assertEqual ( [string] , bytes ( resp2 ) ) [EOL] [EOL] [EOL] class TestResponseBye ( unittest . TestCase ) : [EOL] [EOL] def test_bytes ( self ) : [EOL] resp = ResponseBye ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( resp ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pymap.parsing.response.ResponseCode]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.CommandResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseContinuation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseContinuation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseBad$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseBad$ 0 0 0 $pymap.parsing.response.ResponseBad$ 0 0 0 0 0 0 0 $typing.Optional[pymap.parsing.response.ResponseCode]$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseBad$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseNo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseNo$ 0 0 0 $pymap.parsing.response.ResponseNo$ 0 0 0 0 0 0 0 $typing.Optional[pymap.parsing.response.ResponseCode]$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseNo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseOk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseOk$ 0 0 0 $pymap.parsing.response.ResponseOk$ 0 0 0 0 0 0 0 $typing.Optional[pymap.parsing.response.ResponseCode]$ 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseOk$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseBye$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.response.ResponseBye$ 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing . specials . sequenceset import MaxValue , SequenceSet [EOL] [EOL] [EOL] class TestSequenceSet ( unittest . TestCase ) : [EOL] [EOL] def test_contains ( self ) : [EOL] set1 = SequenceSet ( [ [number] ] ) [EOL] self . assertIn ( [number] , set1 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set1 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set1 . flatten ( [number] ) ) [EOL] set2 = SequenceSet ( [ MaxValue ( ) ] ) [EOL] self . assertIn ( [number] , set2 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set2 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set2 . flatten ( [number] ) ) [EOL] set3 = SequenceSet ( [ ( [number] , [number] ) ] ) [EOL] self . assertIn ( [number] , set3 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set3 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set3 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set3 . flatten ( [number] ) ) [EOL] set4 = SequenceSet ( [ ( MaxValue ( ) , [number] ) ] ) [EOL] self . assertIn ( [number] , set4 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set4 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set4 . flatten ( [number] ) ) [EOL] set5 = SequenceSet ( [ ( [number] , MaxValue ( ) ) ] ) [EOL] self . assertIn ( [number] , set5 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set5 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set5 . flatten ( [number] ) ) [EOL] set6 = SequenceSet ( [ ( MaxValue ( ) , MaxValue ( ) ) ] ) [EOL] self . assertIn ( [number] , set6 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set6 . flatten ( [number] ) ) [EOL] self . assertNotIn ( [number] , set6 . flatten ( [number] ) ) [EOL] [EOL] def test_set ( self ) : [EOL] set1 = SequenceSet ( [ [number] ] ) [EOL] self . assertEqual ( [ [number] ] , list ( set1 . flatten ( [number] ) ) ) [EOL] set2 = SequenceSet ( [ MaxValue ( ) ] ) [EOL] self . assertEqual ( [ [number] ] , list ( set2 . flatten ( [number] ) ) ) [EOL] set3 = SequenceSet ( [ ( MaxValue ( ) , MaxValue ( ) ) ] ) [EOL] self . assertEqual ( [ [number] ] , list ( set3 . flatten ( [number] ) ) ) [EOL] set4 = SequenceSet ( [ ( [number] , [number] ) ] ) [EOL] self . assertEqual ( list ( range ( [number] , [number] ) ) , list ( set4 . flatten ( [number] ) ) ) [EOL] set5 = SequenceSet ( [ ( MaxValue ( ) , [number] ) ] ) [EOL] self . assertEqual ( list ( range ( [number] , [number] ) ) , list ( set5 . flatten ( [number] ) ) ) [EOL] set6 = SequenceSet ( [ ( [number] , MaxValue ( ) ) ] ) [EOL] self . assertEqual ( list ( range ( [number] , [number] ) ) , list ( set6 . flatten ( [number] ) ) ) [EOL] set7 = SequenceSet ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertEqual ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , list ( set7 . flatten ( [number] ) ) ) [EOL] set8 = SequenceSet ( [ ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertEqual ( [ [number] , [number] , [number] , [number] ] , list ( set8 . flatten ( [number] ) ) ) [EOL] set9 = SequenceSet ( [ ( MaxValue ( ) , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertEqual ( list ( range ( [number] , [number] ) ) , list ( set9 . flatten ( [number] ) ) ) [EOL] set10 = SequenceSet ( [ ( [number] , [number] ) ] ) [EOL] self . assertEqual ( list ( range ( [number] , [number] ) ) , list ( set10 . flatten ( [number] ) ) ) [EOL] set11 = SequenceSet ( [ ( [number] , [number] ) ] ) [EOL] self . assertEqual ( [ ] , list ( set11 . flatten ( [number] ) ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] seq = SequenceSet ( [ [number] , MaxValue ( ) , ( [number] , MaxValue ( ) ) ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] [EOL] def test_build ( self ) : [EOL] seq = SequenceSet . build ( [ [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( [string] , bytes ( seq ) ) [EOL] seq = SequenceSet . build ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 $None$ 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 $pymap.parsing.specials.sequenceset.SequenceSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import builtins [EOL] from typing import Any [EOL] import typing [EOL] import pymap [EOL] import json [EOL] import unittest [EOL] [EOL] from pymap . mime import MessageContent [EOL] [EOL] [EOL] class TestMessageContents ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] header = [string] [string] [string] [string] [string] [string] [string] [string] [EOL] body = [string] [EOL] raw = header + body [EOL] msg_parsed = MessageContent . parse ( raw ) [EOL] json_obj = json . loads ( json . dumps ( msg_parsed . json ) ) [EOL] msg_json = MessageContent . from_json ( raw , json_obj ) [EOL] for msg in ( msg_parsed , msg_json ) : [EOL] self . assertEqual ( raw , bytes ( msg ) ) [EOL] self . assertEqual ( [number] , msg . lines ) [EOL] self . assertEqual ( header , bytes ( msg . header ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] ] } , msg . header . parsed ) [EOL] self . assertEqual ( [string] , msg . header . parsed . subject ) [EOL] self . assertEqual ( body , bytes ( msg . body ) ) [EOL] self . assertFalse ( msg . body . has_nested ) [EOL] [EOL] def test_parse_rfc822 ( self ) : [EOL] header = [string] [string] [string] [EOL] sub_header = [string] [string] [EOL] sub_body = [string] [EOL] body = sub_header + sub_body [EOL] raw = header + body [EOL] msg_parsed = MessageContent . parse ( raw ) [EOL] json_obj = json . loads ( json . dumps ( msg_parsed . json ) ) [EOL] msg_json = MessageContent . from_json ( raw , json_obj ) [EOL] for msg in ( msg_parsed , msg_json ) : [EOL] self . assertEqual ( raw , bytes ( msg ) ) [EOL] self . assertEqual ( [number] , msg . lines ) [EOL] self . assertEqual ( header , bytes ( msg . header ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ [string] ] } , msg . header . parsed ) [EOL] self . assertEqual ( body , bytes ( msg . body ) ) [EOL] self . assertTrue ( msg . body . has_nested ) [EOL] self . assertEqual ( [number] , len ( msg . body . nested ) ) [EOL] self . assertEqual ( body , bytes ( msg . body . nested [ [number] ] ) ) [EOL] self . assertEqual ( sub_header , bytes ( msg . body . nested [ [number] ] . header ) ) [EOL] self . assertEqual ( sub_body , bytes ( msg . body . nested [ [number] ] . body ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] } , msg . body . nested [ [number] ] . header . parsed ) [EOL] [EOL] def test_parse_multipart ( self ) : [EOL] header = [string] [string] [string] [string] [EOL] part1 = [string] [string] [string] [string] [EOL] part2 = [string] [string] [string] [EOL] body = [string] [string] + part1 + [string] + part2 + [string] [string] [EOL] raw = header + body [EOL] msg_parsed = MessageContent . parse ( raw ) [EOL] json_obj = json . loads ( json . dumps ( msg_parsed . json ) ) [EOL] msg_json = MessageContent . from_json ( raw , json_obj ) [EOL] for msg in ( msg_parsed , msg_json ) : [EOL] self . assertEqual ( raw , bytes ( msg ) ) [EOL] self . assertEqual ( [number] , msg . lines ) [EOL] self . assertEqual ( header , bytes ( msg . header ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] , [string] : [ [string] [string] ] } , msg . header . parsed ) [EOL] self . assertEqual ( body , bytes ( msg . body ) ) [EOL] self . assertTrue ( msg . body . has_nested ) [EOL] self . assertEqual ( [number] , len ( msg . body . nested ) ) [EOL] self . assertEqual ( part1 , bytes ( msg . body . nested [ [number] ] ) ) [EOL] self . assertEqual ( { } , msg . body . nested [ [number] ] . header . parsed ) [EOL] self . assertEqual ( part2 , bytes ( msg . body . nested [ [number] ] ) ) [EOL] self . assertEqual ( { [string] : [ [string] ] } , msg . body . nested [ [number] ] . header . parsed ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $pymap.mime.MessageContent$ 0 0 0 0 0 $builtins.bytes$ 0 $typing.Any$ 0 0 0 0 0 0 $pymap.mime.MessageContent$ 0 $pymap.mime.MessageContent$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Union [EOL] import typing [EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing import Params [EOL] from pymap . parsing . exceptions import NotParseable [EOL] from pymap . parsing . primitives import Nil , Number , Atom , String , QuotedString , LiteralString , ListP [EOL] from pymap . parsing . state import ParsingState , ParsingInterrupt , ExpectContinuation [EOL] [EOL] [EOL] class TestNil ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Nil . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Nil ) [EOL] self . assertIsNone ( ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Nil . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] Nil . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] nil = Nil ( ) [EOL] self . assertEqual ( [string] , bytes ( nil ) ) [EOL] [EOL] [EOL] class TestNumber ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Number . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Number ) [EOL] self . assertEqual ( [number] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Number . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] Number . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] nil = Number ( [number] ) [EOL] self . assertEqual ( [string] , bytes ( nil ) ) [EOL] [EOL] [EOL] class TestAtom ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = Atom . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , Atom ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] Atom . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] nil = Atom ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( nil ) ) [EOL] [EOL] [EOL] class TestString ( unittest . TestCase ) : [EOL] [EOL] def test_quoted_parse ( self ) : [EOL] ret , buf = String . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , QuotedString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_quoted_parse_empty ( self ) : [EOL] ret , buf = String . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , QuotedString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_quoted_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] [EOL] def test_quoted_bytes ( self ) : [EOL] qstring1 = QuotedString ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( qstring1 ) ) [EOL] qstring2 = QuotedString ( [string] , [string] ) [EOL] self . assertEqual ( [string] , bytes ( qstring2 ) ) [EOL] [EOL] def test_literal_parse ( self ) : [EOL] state = ParsingState ( continuations = [ [string] ] ) [EOL] ret , buf = String . parse ( [string] , Params ( state ) ) [EOL] self . assertIsInstance ( ret , LiteralString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertFalse ( ret . binary ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_literal_parse_empty ( self ) : [EOL] state = ParsingState ( continuations = [ [string] ] ) [EOL] ret , buf = String . parse ( [string] , Params ( state ) ) [EOL] self . assertIsInstance ( ret , LiteralString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_literal_plus ( self ) : [EOL] ret , buf = String . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , LiteralString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertFalse ( ret . binary ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_literal_binary ( self ) : [EOL] state = ParsingState ( continuations = [ [string] ] ) [EOL] ret , buf = String . parse ( [string] , Params ( state ) ) [EOL] self . assertIsInstance ( ret , LiteralString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertTrue ( ret . binary ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_literal_plus_binary ( self ) : [EOL] ret , buf = String . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , LiteralString ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertTrue ( ret . binary ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_literal_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] state = ParsingState ( continuations = [ [string] * [number] ] ) [EOL] String . parse ( [string] , Params ( state ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] String . parse ( [string] + ( [string] * [number] ) , Params ( ) ) [EOL] with self . assertRaises ( ParsingInterrupt ) as raised1 : [EOL] String . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( raised1 . exception . expected , ExpectContinuation ) [EOL] with self . assertRaises ( NotParseable ) as raised2 : [EOL] String . parse ( [string] , Params ( ) ) [EOL] self . assertEqual ( [string] , bytes ( raised2 . exception . code ) ) [EOL] [EOL] def test_literal_bytes ( self ) : [EOL] qstring1 = LiteralString ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( qstring1 ) ) [EOL] qstring2 = LiteralString ( [string] ) [EOL] self . assertEqual ( [string] , bytes ( qstring2 ) ) [EOL] [EOL] def test_build_binary ( self ) : [EOL] ret = String . build ( [string] , True ) [EOL] self . assertEqual ( [string] , ret . value ) [EOL] self . assertTrue ( ret . binary ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL] [EOL] [EOL] class TestList ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = ListP . parse ( [string] , Params ( list_expected = [ Nil , Number , Atom , String , ListP ] ) ) [EOL] self . assertIsInstance ( ret , ListP ) [EOL] self . assertEqual ( [number] , len ( ret . value ) ) [EOL] self . assertEqual ( [string] , buf ) [EOL] self . assertIsInstance ( ret . value [ [number] ] , Atom ) [EOL] self . assertEqual ( [string] , ret . value [ [number] ] . value ) [EOL] self . assertIsInstance ( ret . value [ [number] ] , Number ) [EOL] self . assertEqual ( [number] , ret . value [ [number] ] . value ) [EOL] self . assertIsInstance ( ret . value [ [number] ] , ListP ) [EOL] self . assertIsNone ( ret . value [ [number] ] . value [ [number] ] . value ) [EOL] self . assertIsInstance ( ret . value [ [number] ] , QuotedString ) [EOL] self . assertEqual ( [string] , ret . value [ [number] ] . value ) [EOL] [EOL] def test_parse_empty ( self ) : [EOL] ret , buf = ListP . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , ListP ) [EOL] self . assertEqual ( [ ] , ret . value ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_failure ( self ) : [EOL] with self . assertRaises ( NotParseable ) : [EOL] ListP . parse ( [string] , Params ( ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] ListP . parse ( [string] , Params ( list_expected = [ Atom , String ] ) ) [EOL] with self . assertRaises ( NotParseable ) : [EOL] ListP . parse ( [string] , Params ( list_expected = [ Number ] ) ) [EOL] [EOL] def test_bytes ( self ) : [EOL] ret = ListP ( [ QuotedString ( [string] ) , Number ( [number] ) , ListP ( [ Nil ( ) ] ) ] ) [EOL] self . assertEqual ( [string] , bytes ( ret ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Nil$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Nil$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Number$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Number$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Atom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.Atom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.QuotedString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.QuotedString$ 0 0 0 $pymap.parsing.primitives.QuotedString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.QuotedString$ 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.state.ParsingState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.LiteralString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.LiteralString$ 0 0 0 $pymap.parsing.primitives.LiteralString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.LiteralString$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pymap.parsing.primitives.Nil,pymap.parsing.primitives.String]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pymap.parsing.primitives.Nil,pymap.parsing.primitives.String]$ 0 0 0 0 0 0 0 0 $typing.Union[pymap.parsing.primitives.Nil,pymap.parsing.primitives.String]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[pymap.parsing.primitives.Nil,pymap.parsing.primitives.String]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.ListP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.primitives.ListP$ 0 0 0
[EOL] import pymap [EOL] import unittest [EOL] [EOL] from pymap . parsing import Params [EOL] from pymap . parsing . command import Command , CommandNoArgs [EOL] from pymap . parsing . commands import Commands [EOL] [EOL] [EOL] class TestCommandNoArgs ( unittest . TestCase ) : [EOL] [EOL] def test_parse ( self ) : [EOL] ret , buf = CommandNoArgs . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , CommandNoArgs ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] def test_parse_no_cr ( self ) : [EOL] ret , buf = CommandNoArgs . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( ret , CommandNoArgs ) [EOL] self . assertEqual ( [string] , buf ) [EOL] [EOL] [EOL] class TestCommands ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . commands = Commands ( ) [EOL] [EOL] def test_parse ( self ) : [EOL] cmd , buf = self . commands . parse ( [string] , Params ( ) ) [EOL] self . assertIsInstance ( cmd , Command ) [EOL] self . assertEqual ( [string] , cmd . tag ) [EOL] self . assertEqual ( [string] , buf ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.parsing.commands.Commands$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestCopy ( TestBase ) : [EOL] [EOL] async def test_copy ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_uid_copy ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_copy_email_id ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] [string] , ( [string] , ) , [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] assert self . matches [ [string] ] == self . matches [ [string] ] [EOL] assert self . matches [ [string] ] == self . matches [ [string] ] [EOL] [EOL] async def test_concurrent_copy_fetch ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 , event3 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_select ( [string] , [number] , [number] , set = event1 ) [EOL] concurrent . push_readline ( [string] , wait = event2 ) [EOL] concurrent . push_write ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , wait = event1 , set = event2 ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] , set = event2 ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL] [EOL] async def test_move ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] [string] [string] [string] ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_uid_move ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] [string] [string] [string] ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_move_email_id ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] assert self . matches [ [string] ] == self . matches [ [string] ] [EOL] assert self . matches [ [string] ] == self . matches [ [string] ] [EOL] [EOL] async def test_concurrent_move_fetch ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 , event3 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_select ( [string] , [number] , [number] , set = event1 ) [EOL] concurrent . push_readline ( [string] , wait = event2 ) [EOL] concurrent . push_write ( [string] [string] [string] [string] [string] ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , wait = event1 , set = event2 ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] [string] , set = event2 ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
	0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestManageSieve ( TestBase ) : [EOL] [EOL] def _push_capabilities ( self , transport ) : [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] def _push_logout ( self , transport ) : [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] [EOL] def _push_authenticate ( self , transport ) : [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] [string] ) [EOL] transport . push_write ( [string] ) [EOL] [EOL] async def test_capabilities ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_authenticate ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_capability ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] [string] [string] [string] [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_unauthenticate ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_bad_command ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_listscripts ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_getscript ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_havespace ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_putscript ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_deletescript ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_renamescript ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_checkscript ( self , managesieve_server ) : [EOL] transport = self . new_transport ( managesieve_server ) [EOL] self . _push_capabilities ( transport ) [EOL] self . _push_authenticate ( transport ) [EOL] transport . push_readline ( [string] [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] [string] ) [EOL] transport . push_write ( [string] [string] [string] ) [EOL] self . _push_logout ( transport ) [EOL] await self . run ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestSearch ( TestBase ) : [EOL] [EOL] async def test_search_disabled ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_not ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_uid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_seqset ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_and ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_or ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_seen ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_unseen ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_new ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_date_on ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_date_since ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_header_date ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_size ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_from ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_subject ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_header ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_body ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_text ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_emailid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_search_threadid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , ( [string] , [string] ) , [string] [string] , ( [string] , [string] ) , [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] from typing import Any , Dict , List [EOL] import asyncio [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] from argparse import Namespace [EOL] from typing import Dict [EOL] [EOL] import pytest [comment] [EOL] [EOL] from pymap . backend . dict import DictBackend [EOL] from pymap . context import subsystem [EOL] from pymap . imap import IMAPServer [EOL] from pymap . sieve . manage import ManageSieveServer [EOL] [EOL] from . mocktransport import MockTransport [EOL] [EOL] [EOL] class FakeArgs ( Namespace ) : [EOL] debug = True [EOL] demo_data = [string] [EOL] demo_user = [string] [EOL] demo_password = [string] [EOL] [EOL] def __getattr__ ( self , key ) : [EOL] return None [EOL] [EOL] [EOL] class TestBase : [EOL] [EOL] @ classmethod @ pytest . fixture ( autouse = True ) def init ( cls , request , backend ) : [EOL] test = request . instance [EOL] test . _fd = [number] [EOL] test . matches = { } [EOL] [EOL] @ pytest . fixture def imap_server ( self , backend ) : [EOL] return IMAPServer ( backend . login , backend . config ) [EOL] [EOL] @ pytest . fixture def managesieve_server ( self , backend ) : [EOL] return ManageSieveServer ( backend . login , backend . config ) [EOL] [EOL] @ pytest . fixture def args ( self ) : [EOL] return FakeArgs ( ) [EOL] [EOL] @ pytest . fixture async def backend ( self , args ) : [EOL] backend , config = await DictBackend . init ( args ) [EOL] config . disable_search_keys = [ [string] ] [EOL] return backend [EOL] [EOL] def _incr_fd ( self ) : [EOL] fd = self . _fd [EOL] self . _fd += [number] [EOL] return fd [EOL] [EOL] def new_transport ( self , server ) : [EOL] return MockTransport ( server , self . matches , self . _incr_fd ( ) ) [EOL] [EOL] def new_events ( self , n = [number] ) : [EOL] if n == [number] : [EOL] return subsystem . get ( ) . new_event ( ) [EOL] else : [EOL] return ( subsystem . get ( ) . new_event ( ) for _ in range ( n ) ) [EOL] [EOL] def _check_queue ( self , transport ) : [EOL] queue = transport . queue [EOL] assert [number] == len ( queue ) , [string] + repr ( queue ) [EOL] [EOL] async def _run_transport ( self , transport ) : [EOL] server = transport . server [EOL] return await server ( transport , transport ) [EOL] [EOL] async def run ( self , * transports ) : [EOL] failures = [ ] [EOL] transport_tasks = [ asyncio . create_task ( self . _run_transport ( transport ) ) for transport in transports ] [EOL] for task in transport_tasks : [EOL] try : [EOL] await task [EOL] except Exception as exc : [EOL] failures . append ( exc ) [EOL] if failures : [EOL] raise failures [ [number] ] [EOL] for transport in transports : [EOL] self . _check_queue ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[asyncio.tasks.Task[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[asyncio.tasks.Task[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestReadOnly ( TestBase ) : [EOL] [EOL] async def test_select ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , readonly = True ) [EOL] transport . push_select ( [string] , [number] , [number] , readonly = True ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_examine ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , examine = True ) [EOL] transport . push_select ( [string] , [number] , [number] , examine = True ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_append ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] message = [string] [EOL] transport . push_login ( ) [EOL] transport . push_readline ( [string] % len ( message ) ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readexactly ( message ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_copy ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_expunge ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_fetch_not_seen ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , readonly = True ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestExpunge ( TestBase ) : [EOL] [EOL] async def test_expunge ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_expunge_uid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_concurrent_expunge_responses ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_select ( [string] , [number] , [number] , set = event1 ) [EOL] concurrent . push_readline ( [string] , wait = event2 ) [EOL] concurrent . push_write ( [string] [string] [string] [string] [string] ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] [string] [string] [string] [string] ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] [string] ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] [string] [string] ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , wait = event1 ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_readline ( [string] , set = event2 ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[EOL] from typing import Optional , Any [EOL] import pymap [EOL] import pymapadmin [EOL] import builtins [EOL] import typing [EOL] import test [EOL] from typing import Any , Optional [EOL] [EOL] import pytest [comment] [EOL] from pymapadmin . grpc . admin_pb2 import Login , AppendRequest , AppendResponse , SUCCESS , FAILURE [EOL] [EOL] from pymap . admin . handlers . mailbox import MailboxHandlers [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class _Stream : [EOL] [EOL] def __init__ ( self , request ) : [EOL] self . request = request [EOL] self . response = None [EOL] [EOL] async def recv_message ( self ) : [EOL] return self . request [EOL] [EOL] async def send_message ( self , response ) : [EOL] self . response = response [EOL] [EOL] [EOL] class TestMailboxHandlers ( TestBase ) : [EOL] [EOL] async def test_append ( self , backend , imap_server ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert SUCCESS == response . result . code [EOL] assert [number] == response . uid [EOL] [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_append_user_not_found ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert FAILURE == response . result . code [EOL] assert [string] == response . result . key [EOL] [EOL] async def test_append_mailbox_not_found ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert FAILURE == response . result . code [EOL] assert [string] == response . mailbox [EOL] assert [string] == response . result . key [EOL] [EOL] async def test_append_filter_reject ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert FAILURE == response . result . code [EOL] assert [string] == response . result . key [EOL] [EOL] async def test_append_filter_discard ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert SUCCESS == response . result . code [EOL] assert not response . mailbox [EOL] assert not response . uid [EOL] [EOL] async def test_append_filter_address_is ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_address_contains ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_address_matches ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_envelope_is ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , sender = [string] , recipient = None , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_envelope_contains ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , sender = [string] , recipient = None , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_envelope_matches ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , sender = None , recipient = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_exists ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_header ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL] [EOL] async def test_append_filter_size ( self , backend ) : [EOL] handlers = MailboxHandlers ( backend , True ) [EOL] data = [string] [EOL] data = data + [string] * ( [number] - len ( data ) ) [EOL] login = Login ( authcid = [string] , secret = [string] ) [EOL] request = AppendRequest ( login = login , mailbox = [string] , flags = [ [string] , [string] ] , when = [number] , data = data ) [EOL] stream = _Stream ( request ) [EOL] await handlers . Append ( stream ) [EOL] response = stream . response [EOL] assert [string] == response . mailbox [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 0 $typing.Any$ 0 0 0 $pymap.admin.handlers.mailbox.MailboxHandlers$ 0 0 0 $test.server.test_admin_mailbox._Stream$ 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 $test.server.test_admin_mailbox._Stream$ 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0 0 $pymapadmin.grpc.admin_pb2.AppendResponse$ 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestIdle ( TestBase ) : [EOL] [EOL] async def test_idle ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readexactly ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_idle_invalid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readexactly ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_idle_noselect ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_concurrent_idle_append ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 , event3 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_select ( [string] , [number] , [number] , [number] ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_readexactly ( [string] , set = event1 , wait = event3 ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_write ( [string] , set = event3 ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_readline ( [string] , wait = event1 ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readexactly ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , None , [string] , set = event2 ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL] [EOL] async def test_concurrent_idle_expunge ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 , event3 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_select ( [string] , [number] , [number] , [number] ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_readexactly ( [string] , set = event1 , wait = event3 ) [EOL] concurrent . push_write ( [string] , set = event3 ) [EOL] concurrent . push_readline ( [string] , wait = event2 ) [EOL] concurrent . push_write ( [string] ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] , wait = event1 ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] , set = event2 ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestStore ( TestBase ) : [EOL] [EOL] async def test_store ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store_silent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_uid_store ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store_add_recent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store_remove_recent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store_set_non_recent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_store_invalid ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import base64 [EOL] [EOL] import pytest [comment] [EOL] [EOL] from . base import TestBase [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] class TestSession ( TestBase ) : [EOL] [EOL] async def test_login_logout ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_select ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_select_clears_recent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] , [number] ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] , [number] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL] [EOL] async def test_concurrent_select_clears_recent ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] concurrent = self . new_transport ( imap_server ) [EOL] event1 , event2 = self . new_events ( [number] ) [EOL] [EOL] concurrent . push_login ( ) [EOL] concurrent . push_readline ( [string] ) [EOL] concurrent . push_write ( [string] [string] , set = event1 ) [EOL] concurrent . push_select ( [string] , [number] , [number] , [number] , [number] , wait = event2 ) [EOL] concurrent . push_logout ( ) [EOL] [EOL] transport . push_login ( ) [EOL] transport . push_select ( [string] , [number] , [number] , [number] , [number] , wait = event1 , set = event2 ) [EOL] transport . push_logout ( ) [EOL] [EOL] await self . run ( transport , concurrent ) [EOL] [EOL] async def test_auth_plain ( self , imap_server ) : [EOL] transport = self . new_transport ( imap_server ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] , ( [string] , ) , [string] , ( [string] , ) , [string] ) [EOL] transport . push_readline ( [string] ) [EOL] transport . push_write ( [string] ) [EOL] transport . push_readexactly ( [string] ) [EOL] transport . push_readline ( base64 . b64encode ( [string] ) + [string] ) [EOL] transport . push_write ( [string] , ( [string] , ) , [string] ) [EOL] transport . push_logout ( ) [EOL] await self . run ( transport ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0