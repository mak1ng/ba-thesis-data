import dev [EOL] [EOL] [EOL] def test_find_files ( ) : [EOL] assert dev . find_files ( [string] , [string] ) == [ [string] ] [EOL] assert dev . find_files ( [string] , [string] ) == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import io [EOL] import builtins [EOL] import subprocess [EOL] import sys [EOL] [EOL] try : [EOL] from discordbot import generate_readme as bot_readme [EOL] except ImportError : [EOL] pass [EOL] [EOL] HEADER = [string] [EOL] [EOL] def generate_readme ( ) : [EOL] changed = [number] [EOL] readme = [string] [EOL] readme += HEADER [EOL] [EOL] fh = open ( [string] ) [EOL] old_readme = fh . read ( ) [EOL] fh . close ( ) [EOL] [EOL] if readme != old_readme : [EOL] fh = open ( [string] , mode = [string] ) [EOL] fh . write ( readme ) [EOL] fh . close ( ) [EOL] print ( [string] ) [EOL] changed += [number] [EOL] changed += bot_readme . generate_readme ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return changed [EOL] [EOL] def git_commit ( ) : [EOL] subprocess . call ( [ [string] , [string] , [string] ] ) [EOL] subprocess . call ( [ [string] , [string] , [string] , [string] ] ) [EOL] subprocess . call ( [ [string] , [string] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( generate_readme ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import os [EOL] [EOL] import setuptools [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] DESC = fh . read ( ) [EOL] [EOL] REQ_PATH = os . path . join ( os . path . dirname ( os . path . realpath ( __file__ ) ) , [string] ) [EOL] INSTALL_REQUIRES = [ ] [EOL] if os . path . isfile ( REQ_PATH ) : [EOL] with open ( REQ_PATH ) as f : [EOL] INSTALL_REQUIRES = f . read ( ) . splitlines ( ) [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , author = [string] , description = [string] , long_description = DESC , long_description_content_type = [string] , url = [string] , packages = setuptools . find_packages ( ) , classifiers = [ [string] , [string] , ] , python_requires = [string] , install_requires = INSTALL_REQUIRES , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0
[comment] [EOL] [comment] [EOL] from typing import Type , Optional , Any , List [EOL] import builtins [EOL] import subprocess [EOL] import typing [EOL] import json [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] import time [EOL] from pickle import PicklingError [EOL] from typing import List , Optional [EOL] [EOL] from shared import configuration [EOL] from shared . pd_exception import InvalidArgumentException , TestFailedException [EOL] [EOL] try : [EOL] from plumbum import FG , local [EOL] from plumbum . commands . processes import ProcessExecutionError [EOL] except ImportError : [EOL] sys . stderr . write ( [string] ) [EOL] ProcessExecutionError = subprocess . CalledProcessError [EOL] [EOL] [EOL] ON_PROD = configuration . get_bool ( [string] ) [EOL] if ON_PROD : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [EOL] ON_WINDOWS = sys . platform == [string] [EOL] [EOL] def run ( ) : [EOL] try : [EOL] try : [EOL] exit_code = None [EOL] run_dangerously ( ) [EOL] except InvalidArgumentException : [EOL] exit_code = [number] [EOL] raise [EOL] except TestFailedException : [EOL] exit_code = [number] [EOL] raise [EOL] except ProcessExecutionError : [EOL] exit_code = [number] [EOL] raise [EOL] except Exception as e : [comment] [EOL] msg = type ( e ) . __name__ + [string] + str ( sys . argv ) + [string] + [string] + str ( e . args ) + [string] + str ( e ) + [string] [EOL] sys . stderr . write ( msg ) [EOL] if not exit_code : [EOL] raise [EOL] sys . exit ( exit_code if exit_code else [number] ) [EOL] [EOL] def run_dangerously ( ) : [EOL] try : [EOL] cmd = sys . argv [ [number] ] . lower ( ) [EOL] args = sys . argv [ [number] : ] [EOL] except IndexError : [EOL] raise InvalidArgumentException ( [string] ) [EOL] if cmd == [string] : [EOL] unit ( args ) [EOL] elif cmd == [string] : [EOL] runtests ( args , [string] , True ) [EOL] elif cmd == [string] : [EOL] runtests ( args , [string] , True ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] runtests ( args , [string] , False ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] lint ( args ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] mypy ( args ) [EOL] elif cmd == [string] : [EOL] mypy ( args , strict = True ) [EOL] elif cmd == [string] : [EOL] mypy ( args , typeshedding = True ) [EOL] elif cmd == [string] : [EOL] jslint ( ) [EOL] elif cmd == [string] : [EOL] jsfix ( ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] reset_db ( ) [EOL] elif cmd in ( [string] , [string] , [string] ) : [EOL] sort ( ) [EOL] elif cmd in ( [string] , [string] , [string] ) : [EOL] sort ( True ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] pull_request ( args ) [EOL] elif cmd == [string] : [EOL] build ( ) [EOL] elif cmd == [string] : [EOL] buildjs ( ) [EOL] elif cmd == [string] : [EOL] popclean ( ) [EOL] elif cmd == [string] : [EOL] from generate_readme import generate_readme [EOL] generate_readme ( ) [EOL] elif cmd == [string] : [EOL] coverage ( ) [EOL] elif cmd == [string] : [EOL] watch ( ) [EOL] elif cmd == [string] : [EOL] branch ( args ) [EOL] elif cmd == [string] : [EOL] push ( ) [EOL] elif cmd == [string] : [EOL] check ( args ) [EOL] elif cmd in ( [string] , [string] ) : [EOL] safe_push ( args ) [EOL] elif cmd == [string] : [EOL] release ( args ) [EOL] elif cmd == [string] : [EOL] check_requirements ( ) [EOL] elif cmd == [string] : [EOL] swagger ( ) [EOL] else : [EOL] raise InvalidArgumentException ( [string] . format ( cmd = cmd ) ) [EOL] [EOL] def lint ( argv ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , str ( configuration . get_int ( [string] ) ) , ] [EOL] args . extend ( argv or find_files ( file_extension = [string] ) ) [EOL] [comment] [EOL] import pylint . lint [EOL] try : [EOL] linter = pylint . lint . Run ( args , exit = False ) [EOL] except PicklingError : [EOL] print ( [string] ) [EOL] configuration . write ( [string] , [number] ) [EOL] lint ( argv ) [EOL] return [EOL] [EOL] if linter . linter . msg_status : [EOL] raise TestFailedException ( linter . linter . msg_status ) [EOL] [EOL] def mypy ( argv , strict = False , typeshedding = False ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] args = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] if strict : [EOL] args . extend ( [ [string] , ] ) [EOL] if typeshedding : [EOL] args . extend ( [ [string] , [string] , [string] , ] ) [EOL] args . extend ( argv or [ [string] ] ) [comment] [EOL] [comment] [EOL] from mypy import api [EOL] result = api . run ( args ) [EOL] if result [ [number] ] : [EOL] print ( result [ [number] ] ) [comment] [EOL] if result [ [number] ] : [EOL] sys . stderr . write ( result [ [number] ] ) [comment] [EOL] print ( [string] . format ( code = result [ [number] ] , english = [string] if result [ [number] ] else [string] ) ) [EOL] if result [ [number] ] : [EOL] raise TestFailedException ( result [ [number] ] ) [EOL] [EOL] def unit ( argv ) : [EOL] runtests ( argv , [string] , True ) [EOL] [EOL] def runtests ( argv , m , mark ) : [EOL] [docstring] [EOL] args = argv . copy ( ) [EOL] if mark : [EOL] if args and not args [ [number] ] . startswith ( [string] ) : [EOL] to_find = args . pop ( [number] ) [EOL] args . extend ( find_files ( to_find , [string] ) ) [EOL] args . extend ( [ [string] , [string] , m ] ) [EOL] [EOL] argstr = [string] . join ( args ) [EOL] print ( f' [string] { argstr } [string] ' ) [EOL] [comment] [EOL] import pytest [EOL] [EOL] from magic import fetcher , multiverse , oracle [EOL] multiverse . init ( ) [EOL] oracle . init ( ) [EOL] try : [EOL] fetcher . sitemap ( ) [EOL] except fetcher . FetchException : [EOL] print ( f' [string] { fetcher . decksite_url ( ) } [string] ' ) [EOL] for k in [ [string] , [string] , [string] ] : [EOL] configuration . CONFIG [ k ] = configuration . DEFAULTS [ k ] [EOL] [EOL] code = pytest . main ( args ) [EOL] if os . environ . get ( [string] ) == [string] : [EOL] upload_coverage ( ) [EOL] if code : [EOL] raise TestFailedException ( code ) [EOL] [EOL] [comment] [EOL] def upload_coverage ( ) : [EOL] try : [EOL] print ( [string] ) [EOL] [comment] [EOL] from shared import fetch_tools [EOL] fetch_tools . store ( [string] , [string] ) [EOL] python3 = local [ [string] ] [EOL] python3 [ [string] , [string] , [string] , [string] ] [EOL] bash = local [ [string] ] [EOL] bash [ [string] ] & FG [EOL] [comment] [EOL] except ProcessExecutionError as e : [EOL] print ( e ) [EOL] except fetch_tools . FetchException as e : [EOL] print ( e ) [EOL] [EOL] [comment] [EOL] def sort ( fix = False ) : [EOL] print ( [string] ) [EOL] if fix : [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] ) [EOL] else : [EOL] subprocess . check_call ( [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] def reset_db ( ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] import decksite . database [EOL] decksite . database . db ( ) . nuke_database ( ) [EOL] import magic . database [EOL] magic . database . db ( ) . nuke_database ( ) [EOL] [EOL] def safe_push ( args ) : [EOL] label = stash_if_any ( ) [EOL] print ( [string] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] unit ( args ) [EOL] push ( ) [EOL] pop_if_any ( label ) [EOL] [EOL] def push ( ) : [EOL] print ( [string] ) [EOL] branch_name = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] ) . strip ( ) . decode ( ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] , branch_name ] ) [EOL] [EOL] def pull_request ( argv ) : [EOL] print ( [string] ) [EOL] try : [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] ) [EOL] except ( subprocess . CalledProcessError , FileNotFoundError ) : [EOL] subprocess . check_call ( [ [string] , [string] , * argv ] ) [EOL] [EOL] def build ( ) : [EOL] print ( [string] ) [EOL] pipargs = [ sys . executable , [string] , [string] , [string] , [string] , [string] ] [EOL] if not hasattr ( sys , [string] ) : [EOL] pipargs . append ( [string] ) [EOL] subprocess . check_call ( pipargs ) [EOL] print ( [string] ) [EOL] subprocess . check_call ( [ [string] , [string] ] , shell = ON_WINDOWS ) [EOL] buildjs ( ) [EOL] [EOL] def buildjs ( ) : [EOL] print ( [string] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] , shell = ON_WINDOWS ) [EOL] [EOL] def jslint ( fix = False ) : [EOL] print ( [string] ) [EOL] files = find_files ( file_extension = [string] , exclude = [ [string] , [string] ] ) + find_files ( file_extension = [string] ) [EOL] cmd = [ os . path . join ( [string] , [string] , [string] , [string] ) ] [EOL] if fix : [EOL] cmd . append ( [string] ) [EOL] subprocess . check_call ( cmd + files , shell = ON_WINDOWS ) [EOL] [EOL] def jsfix ( ) : [EOL] print ( [string] ) [EOL] jslint ( fix = True ) [EOL] [EOL] def coverage ( ) : [EOL] print ( [string] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] ] ) [EOL] [EOL] def watch ( ) : [EOL] print ( [string] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] , shell = ON_WINDOWS ) [EOL] [EOL] [comment] [EOL] def branch ( args ) : [EOL] if not args : [EOL] print ( [string] ) [EOL] return [EOL] branch_name = args [ [number] ] [EOL] print ( [string] ) [EOL] label = stash_if_any ( ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] ] ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , branch_name ] ) [EOL] pop_if_any ( label ) [EOL] [EOL] def stash_if_any ( ) : [EOL] print ( [string] ) [EOL] label = [string] + str ( time . time ( ) ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] , [string] , label ] ) [EOL] return label [EOL] [EOL] def pop_if_any ( label ) : [EOL] print ( [string] ) [EOL] output = subprocess . check_output ( [ [string] , [string] , [string] ] , stderr = subprocess . STDOUT ) [EOL] if label in str ( output ) : [EOL] print ( [string] ) [EOL] subprocess . call ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def popclean ( ) : [EOL] print ( [string] ) [EOL] try : [EOL] subprocess . check_output ( [ [string] , [string] , [string] ] , stderr = subprocess . STDOUT ) [EOL] return [EOL] except subprocess . CalledProcessError as e : [EOL] lines = e . output . decode ( ) . split ( [string] ) [EOL] already = [ line . split ( [string] ) [ [number] ] for line in lines if [string] in line ] [EOL] for f in already : [EOL] os . remove ( f ) [EOL] subprocess . check_call ( [ [string] , [string] , [string] ] ) [EOL] [EOL] def check ( args ) : [EOL] sort ( ) [EOL] mypy ( args ) [EOL] lint ( args ) [EOL] jslint ( ) [EOL] [EOL] def release ( args ) : [EOL] check ( [ ] ) [EOL] safe_push ( [ ] ) [EOL] pull_request ( args ) [EOL] [EOL] def find_files ( needle = [string] , file_extension = [string] , exclude = None ) : [EOL] paths = subprocess . check_output ( [ [string] , [string] ] ) . strip ( ) . decode ( ) . split ( [string] ) [EOL] paths = [ p for p in paths if [string] not in p ] [EOL] if file_extension : [EOL] paths = [ p for p in paths if p . endswith ( file_extension ) ] [EOL] if needle : [EOL] paths = [ p for p in paths if needle in os . path . basename ( p ) ] [EOL] if exclude : [EOL] paths = [ p for p in paths if p not in exclude ] [EOL] return paths [EOL] [EOL] [EOL] def check_requirements ( ) : [EOL] files = find_files ( file_extension = [string] ) [EOL] r = subprocess . call ( [ sys . executable , [string] , [string] , [string] , [string] ] + files ) [EOL] r = subprocess . call ( [ sys . executable , [string] , [string] , [string] , [string] ] + files ) or r [EOL] [EOL] def swagger ( ) : [EOL] import decksite [EOL] decksite . APP . config [ [string] ] = configuration . server_name ( ) [EOL] with decksite . APP . app_context ( ) : [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( json . dumps ( decksite . APP . api . __schema__ ) ) [EOL] [EOL] if __name__ == [string] : [EOL] run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[subprocess.CalledProcessError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[subprocess.CalledProcessError]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[subprocess.CalledProcessError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[subprocess.CalledProcessError]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import html [EOL] from typing import List [EOL] [EOL] [EOL] def sanitize ( s ) : [EOL] [docstring] [EOL] try : [EOL] s = s . encode ( [string] ) . decode ( [string] ) [EOL] except UnicodeDecodeError : [EOL] pass [EOL] return html . unescape ( s ) [EOL] [EOL] def unambiguous_prefixes ( words ) : [EOL] prefixes = [ ] [EOL] for w in words : [EOL] for i in range ( [number] , len ( w ) ) : [EOL] prefix = w [ [number] : i ] [EOL] n = [number] [EOL] for w2 in words : [EOL] if w2 . startswith ( prefix ) : [EOL] n += [number] [EOL] if n == [number] : [EOL] prefixes . append ( prefix ) [EOL] return prefixes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Optional , List , Any [EOL] import builtins [EOL] import typing_extensions [EOL] import datetime [EOL] import traceback [EOL] import github [EOL] import typing [EOL] import datetime [EOL] import hashlib [EOL] import sys [EOL] import textwrap [EOL] import traceback [EOL] from typing import Dict , List , Optional [EOL] [EOL] from flask import request , session [EOL] from github import Github , Issue , PullRequest [EOL] from github . GithubException import GithubException [EOL] from requests . exceptions import RequestException [EOL] [EOL] from shared import configuration , dtutil [EOL] [EOL] [EOL] [comment] [EOL] def create_issue ( content , author , location = [string] , repo_name = [string] , exception = None ) : [EOL] labels = [ ] [EOL] issue_hash = None [EOL] if content is None or content == [string] : [EOL] return None [EOL] body = [string] [EOL] if [string] in content : [EOL] title , body = content . split ( [string] , [number] ) [EOL] body += [string] [EOL] else : [EOL] title = content [EOL] body += [string] . format ( location = location , author = author ) [EOL] if exception : [EOL] body += [string] [EOL] body += exception . __class__ . __name__ + [string] [EOL] body += str ( exception ) + [string] [EOL] body += [string] [EOL] stack = traceback . extract_stack ( ) [ : - [number] ] + traceback . extract_tb ( exception . __traceback__ ) [EOL] pretty = traceback . format_list ( stack ) [EOL] body += [string] + [string] . join ( pretty ) + [string] [EOL] issue_hash = hashlib . sha1 ( [string] . join ( pretty ) . encode ( ) ) . hexdigest ( ) [EOL] body += f' [string] { issue_hash } [string] ' [EOL] elif repo_name == [string] : [EOL] stack = traceback . extract_stack ( ) [ : - [number] ] [EOL] pretty = traceback . format_list ( stack ) [EOL] if request : [EOL] pretty . append ( request . full_path ) [EOL] issue_hash = hashlib . sha1 ( [string] . join ( pretty ) . encode ( ) ) . hexdigest ( ) [EOL] body += f' [string] { issue_hash } [string] ' [EOL] [EOL] if request : [EOL] body += [string] [EOL] body += textwrap . dedent ( [string] . format ( method = request . method , full_path = request . full_path , cookies = request . cookies , endpoint = request . endpoint , view_args = request . view_args , id = session . get ( [string] , [string] ) , referrer = request . referrer , safe_data = str ( safe_data ( request . form ) ) ) ) [EOL] body += [string] . join ( [ [string] . format ( k = k , v = v ) for k , v in request . headers ] ) [EOL] body += [string] [EOL] ua = request . headers . get ( [string] , [string] ) [EOL] if ua == [string] : [EOL] labels . append ( ua ) [EOL] elif [string] in ua or [string] in ua or [string] in ua : [EOL] labels . append ( [string] ) [EOL] [EOL] print ( title + [string] + body , file = sys . stderr ) [EOL] [comment] [EOL] if not configuration . get ( [string] ) or not configuration . get ( [string] ) : [EOL] return None [EOL] if not configuration . get_bool ( [string] ) : [EOL] print ( f' [string] { title } [string] { body }' ) [EOL] return None [EOL] g = Github ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) ) [EOL] git_repo = g . get_repo ( repo_name ) [EOL] if repo_name == [string] : [EOL] labels . append ( location ) [EOL] if exception : [EOL] labels . append ( exception . __class__ . __name__ ) [EOL] if issue_hash : [EOL] try : [EOL] issue = g . search_issues ( issue_hash , repo = repo_name ) [ [number] ] [EOL] labelstr = [string] . join ( labels ) [EOL] issue . create_comment ( f'{ title } [string] { body } [string] { labelstr }' ) [EOL] return issue [EOL] except IndexError : [EOL] pass [EOL] try : [EOL] issue = git_repo . create_issue ( title = title , body = body , labels = labels ) [EOL] return issue [EOL] except GithubException : [EOL] return None [EOL] [EOL] def safe_data ( data ) : [EOL] safe = { } [EOL] for k , v in data . items ( ) : [EOL] if [string] not in k . lower ( ) and [string] not in k . lower ( ) : [EOL] safe [ k ] = v [EOL] return safe [EOL] [EOL] def get_pull_requests ( start_date , end_date , max_pull_requests = sys . maxsize , repo_name = [string] ) : [EOL] gh_user = configuration . get_optional_str ( [string] ) [EOL] gh_pass = configuration . get_optional_str ( [string] ) [EOL] if gh_user is None or gh_pass is None : [EOL] return [ ] [EOL] g = Github ( gh_user , gh_pass ) [EOL] git_repo = g . get_repo ( repo_name ) [EOL] pulls = [ ] [EOL] try : [EOL] for pull in git_repo . get_pulls ( state = [string] , sort = [string] , direction = [string] ) : [EOL] if not pull . merged_at : [EOL] continue [EOL] merged_dt = dtutil . UTC_TZ . localize ( pull . merged_at ) [EOL] updated_dt = dtutil . UTC_TZ . localize ( pull . updated_at ) [EOL] if merged_dt > end_date : [EOL] continue [EOL] if updated_dt < start_date : [EOL] return pulls [EOL] pulls . append ( pull ) [EOL] if len ( pulls ) >= max_pull_requests : [EOL] return pulls [EOL] except RequestException as e : [EOL] print ( [string] , e ) [EOL] except GithubException as e : [EOL] print ( [string] , e ) [EOL] return pulls [EOL] [EOL] def format_exception ( e ) : [EOL] return [string] . join ( traceback . format_exception ( type ( e ) , e , e . __traceback__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[github.Issue.Issue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[github.PullRequest.PullRequest]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Callable [EOL] import builtins [EOL] import typing [EOL] import time [EOL] from typing import Any , Callable [EOL] [EOL] from flask import current_app [EOL] [EOL] from shared import configuration , repo [EOL] [EOL] [EOL] def start ( ) : [EOL] return time . perf_counter ( ) [EOL] [EOL] def check ( start_time , kind , detail , location ) : [EOL] run_time = time . perf_counter ( ) - start_time [EOL] limit = configuration . get_float ( kind ) [EOL] if limit is not None and run_time > limit : [EOL] detail_s = detail if isinstance ( detail , str ) else [string] . join ( map ( str , list ( detail ) ) ) [EOL] msg = [string] . format ( kind = kind , run_time = round ( run_time , [number] ) , limit = limit , detail_s = detail_s , location = location ) [EOL] try : [EOL] flask_location = current_app . name [EOL] except RuntimeError : [comment] [EOL] flask_location = [string] [EOL] repo . create_issue ( msg , f'{ location } [string] ' , flask_location or location , [string] ) [EOL] [EOL] def test ( f , limit ) : [EOL] begin = time . perf_counter ( ) [EOL] f ( ) [EOL] duration = time . perf_counter ( ) - begin [EOL] print ( duration ) [EOL] assert duration <= limit [EOL] [EOL] def took ( start_time ) : [EOL] return time . perf_counter ( ) - start_time [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import functools [EOL] from typing import Any , Callable , Dict , List [EOL] [EOL] from shared . pd_exception import DatabaseException [EOL] [EOL] FuncType = Callable [ ... , Any ] [EOL] [EOL] def retry_after_calling ( retry_func ) : [EOL] def decorator ( decorated_func ) : [EOL] def wrapper ( * args , ** kwargs ) : [EOL] try : [EOL] return decorated_func ( * args , ** kwargs ) [EOL] except DatabaseException as e : [EOL] print ( f" [string] { e } [string] { decorated_func . __name__ } [string] { retry_func . __name__ } [string] " ) [EOL] retry_func ( ) [EOL] try : [EOL] return decorated_func ( * args , ** kwargs ) [EOL] except DatabaseException as e : [EOL] print ( [string] ) [EOL] raise e [EOL] return wrapper [EOL] return decorator [EOL] [EOL] def memoize ( obj ) : [EOL] cache = obj . cache = { } [comment] [EOL] [EOL] @ functools . wraps ( obj ) def memoizer ( * args , ** kwargs ) : [comment] [EOL] if args not in cache : [EOL] cache [ args ] = obj ( * args , ** kwargs ) [EOL] return cache [ args ] [EOL] return memoizer [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[FuncType],FuncType]$ 0 0 0 0 0 0 $FuncType$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FuncType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from shared . database import sqlescape [EOL] from shared . pd_exception import InvalidArgumentException [EOL] [EOL] [EOL] def test_sqlescape ( ) : [EOL] assert sqlescape ( [string] ) == [string] [EOL] assert sqlescape ( [string] ) == [string] [EOL] assert sqlescape ( [number] ) == [number] [EOL] assert sqlescape ( [number] ) != [string] [EOL] assert sqlescape ( [number] , force_string = True ) == [string] [EOL] assert sqlescape ( [number] , force_string = True ) != [number] [EOL] assert sqlescape ( [string] ) == [string] [EOL] found = False [EOL] try : [EOL] sqlescape ( { } ) [EOL] except InvalidArgumentException : [EOL] found = True [EOL] assert found [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] from typing import Any , List [EOL] [EOL] from flask import current_app , has_app_context [EOL] from typing_extensions import Protocol [EOL] [EOL] [EOL] class SupportsLogging ( Protocol ) : [EOL] def debug ( self , msg ) : [EOL] ... [EOL] [EOL] def info ( self , msg ) : [EOL] ... [EOL] [EOL] def warning ( self , msg ) : [EOL] ... [EOL] [EOL] def error ( self , msg ) : [EOL] ... [EOL] [EOL] def fatal ( self , msg ) : [EOL] ... [EOL] [EOL] [EOL] def logger ( ) : [EOL] if has_app_context ( ) : [comment] [EOL] return current_app . logger [comment] [EOL] return logging [comment] [EOL] [EOL] def fatal ( * args ) : [EOL] [docstring] [EOL] logger ( ) . fatal ( [string] . join ( map ( str , args ) ) ) [EOL] [EOL] def error ( * args ) : [EOL] [docstring] [EOL] logger ( ) . error ( [string] . join ( map ( str , args ) ) ) [EOL] [EOL] def warning ( * args ) : [EOL] [docstring] [EOL] logger ( ) . warning ( [string] . join ( map ( str , args ) ) ) [EOL] [EOL] def info ( * args ) : [EOL] [docstring] [EOL] logger ( ) . info ( [string] . join ( map ( str , args ) ) ) [EOL] [EOL] def debug ( * args ) : [EOL] [docstring] [EOL] logger ( ) . debug ( [string] . join ( map ( str , args ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $SupportsLogging$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from shared import text [EOL] [EOL] [EOL] def test_sanitize ( ) : [EOL] assert text . sanitize ( [string] ) == [string] [EOL] assert text . sanitize ( [string] ) == [string] [EOL] assert text . sanitize ( [string] ) == [string] [EOL] [EOL] def test_unambiguous_prefixes ( ) : [EOL] assert text . unambiguous_prefixes ( [ [string] ] ) == [ [string] , [string] , [string] , [string] ] [EOL] assert text . unambiguous_prefixes ( [ [string] , [string] , [string] , [string] ] ) == [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , List , Any [EOL] import builtins [EOL] import typing [EOL] import warnings [EOL] from typing import Any , Dict , List , Optional , Tuple , cast [EOL] [EOL] import MySQLdb [EOL] from MySQLdb import OperationalError [EOL] [EOL] from shared import configuration , perf [EOL] from shared . pd_exception import ( DatabaseConnectionRefusedException , DatabaseException , DatabaseMissingException , InvalidArgumentException , LockNotAcquiredException ) [EOL] [EOL] ValidSqlArgumentDescription = Any [EOL] [EOL] [comment] [EOL] class Database ( ) : [EOL] def __init__ ( self , db ) : [EOL] warnings . filterwarnings ( [string] , category = MySQLdb . Warning ) [EOL] self . name = db [EOL] self . host = configuration . get_str ( [string] ) [EOL] self . port = configuration . get_int ( [string] ) [EOL] self . user = configuration . get_str ( [string] ) [EOL] self . passwd = configuration . get_str ( [string] ) [EOL] self . open_transactions = [ ] [EOL] self . connect ( ) [EOL] [EOL] def connect ( self ) : [EOL] try : [EOL] self . connection = MySQLdb . connect ( host = self . host , port = self . port , user = self . user , passwd = self . passwd , use_unicode = True , charset = [string] , autocommit = True ) [EOL] self . cursor = self . connection . cursor ( MySQLdb . cursors . DictCursor ) [EOL] self . execute ( [string] ) [EOL] try : [EOL] self . execute ( [string] . format ( db = self . name ) ) [EOL] except DatabaseException : [EOL] print ( [string] . format ( db = self . name ) ) [EOL] self . execute ( [string] . format ( db = self . name ) ) [EOL] self . execute ( [string] . format ( db = self . name ) ) [EOL] except MySQLdb . Error as c : [EOL] msg = [string] . format ( location = self . name ) [EOL] if c . args [ [number] ] in [ [number] , [number] ] : [EOL] raise DatabaseConnectionRefusedException ( msg ) [EOL] raise DatabaseException ( msg ) [EOL] [EOL] def select ( self , sql , args = None ) : [EOL] [ _ , rows ] = self . execute_anything ( sql , args ) [EOL] return rows [EOL] [EOL] def execute ( self , sql , args = None ) : [EOL] [ n , _ ] = self . execute_anything ( sql , args , False ) [EOL] return n [EOL] [EOL] def execute_anything ( self , sql , args = None , fetch_rows = True ) : [EOL] if args is None : [EOL] args = [ ] [EOL] try : [EOL] return self . execute_with_reconnect ( sql , args , fetch_rows ) [EOL] except MySQLdb . Warning as e : [EOL] if e . args [ [number] ] in [ [number] , [number] ] : [EOL] return ( [number] , [ ] ) [comment] [EOL] if e . args [ [number] ] == [number] : [EOL] return ( [number] , [ ] ) [comment] [EOL] raise DatabaseException ( [string] . format ( sql = sql , args = args , e = e ) ) [EOL] except MySQLdb . Error as e : [EOL] raise DatabaseException ( [string] . format ( sql = sql , args = args , e = e ) ) [EOL] [EOL] def execute_with_reconnect ( self , sql , args = None , fetch_rows = False ) : [EOL] result = None [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] try : [EOL] p = perf . start ( ) [EOL] n = self . cursor . execute ( sql , args ) [EOL] perf . check ( p , [string] , ( f' [string] { sql } [string] ' , f' [string] { args } [string] ' ) , [string] ) [EOL] if fetch_rows : [EOL] rows = self . cursor . fetchall ( ) [EOL] result = ( n , rows ) [EOL] else : [EOL] result = ( n , [ ] ) [EOL] break [EOL] except OperationalError as e : [EOL] if [string] in str ( e ) : [EOL] print ( [string] ) [EOL] self . connect ( ) [EOL] else : [EOL] [comment] [EOL] raise e [EOL] else : [EOL] [comment] [EOL] raise DatabaseException ( [string] . format ( sql = sql , args = args ) ) [EOL] return result [EOL] [EOL] def insert ( self , sql , args = None ) : [EOL] self . execute ( sql , args ) [EOL] return self . last_insert_rowid ( ) [EOL] [EOL] def begin ( self , label ) : [EOL] print ( f' [string] { self . open_transactions } [string] ' ) [EOL] if len ( self . open_transactions ) == [number] : [EOL] self . execute ( [string] ) [EOL] self . open_transactions . append ( label ) [EOL] print ( f' [string] { self . open_transactions } [string] ' ) [EOL] [EOL] def commit ( self , label ) : [EOL] print ( f' [string] { self . open_transactions } [string] ' ) [EOL] if len ( self . open_transactions ) == [number] : [EOL] self . execute ( [string] ) [EOL] committed = self . open_transactions . pop ( ) [EOL] if committed != label : [EOL] raise DatabaseException ( f' [string] { committed } [string] { label } [string] ' ) [EOL] print ( f' [string] { self . open_transactions } [string] ' ) [EOL] [EOL] def rollback ( self , label ) : [EOL] print ( f' [string] { self . open_transactions } [string] { label }' ) [EOL] self . execute ( [string] ) [EOL] self . open_transactions = [ ] [EOL] print ( f' [string] { self . open_transactions } [string] { label }' ) [EOL] [EOL] def last_insert_rowid ( self ) : [EOL] return cast ( int , self . value ( [string] ) ) [EOL] [EOL] def get_lock ( self , lock_id , timeout = [number] ) : [EOL] result = self . value ( [string] , [ lock_id , timeout ] ) [EOL] if result != [number] : [EOL] raise LockNotAcquiredException [EOL] [EOL] def release_lock ( self , lock_id ) : [EOL] self . execute ( [string] , [ lock_id ] ) [EOL] [EOL] def value ( self , sql , args = None , default = None , fail_on_missing = False ) : [EOL] try : [EOL] return self . values ( sql , args ) [ [number] ] [EOL] except IndexError : [EOL] if fail_on_missing : [EOL] raise DatabaseMissingException ( [string] . format ( sql = sql , args = args ) ) [EOL] return default [EOL] [EOL] def values ( self , sql , args = None ) : [EOL] rs = self . select ( sql , args ) [EOL] return [ list ( row . values ( ) ) [ [number] ] for row in rs ] [EOL] [EOL] def close ( self ) : [EOL] if len ( self . open_transactions ) > [number] : [EOL] self . execute ( [string] ) [EOL] self . cursor . close ( ) [EOL] self . connection . close ( ) [EOL] if len ( self . open_transactions ) > [number] : [EOL] raise DatabaseException ( f' [string] { self . open_transactions } [string] ' ) [EOL] [EOL] def nuke_database ( self ) : [EOL] self . begin ( [string] ) [EOL] query = self . values ( [string] , [ self . name ] ) [EOL] self . execute ( [string] ) [EOL] self . execute ( [string] . join ( query ) ) [EOL] self . execute ( [string] ) [EOL] self . commit ( [string] ) [EOL] [EOL] def get_database ( location ) : [EOL] return Database ( location ) [EOL] [EOL] def sqlescape ( s , force_string = False , backslashed_escaped = False ) : [EOL] if s is None : [EOL] return [string] [EOL] if ( str ( s ) . isdecimal ( ) or isinstance ( s , float ) ) and not force_string : [EOL] return s [EOL] if isinstance ( s , ( str , int , float ) ) : [EOL] s = str ( s ) [EOL] encodable = s . encode ( [string] , [string] ) . decode ( [string] ) [EOL] if encodable . find ( [string] ) >= [number] : [EOL] raise Exception ( [string] ) [EOL] if not backslashed_escaped : [EOL] encodable = encodable . replace ( [string] , [string] ) [EOL] return [string] . format ( escaped = encodable . replace ( [string] , [string] ) . replace ( [string] , [string] ) ) [EOL] raise InvalidArgumentException ( [string] . format ( s = s ) ) [EOL] [EOL] def sqllikeescape ( s ) : [EOL] s = s . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] return sqlescape ( [string] . format ( s = s ) , backslashed_escaped = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[typing.List[ValidSqlArgumentDescription]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import datetime [EOL] import datetime [EOL] [EOL] from pytz import timezone [EOL] [EOL] from shared import dtutil [EOL] [EOL] [EOL] def test_ts2dt ( ) : [EOL] epoch_seconds = [number] [EOL] dt = dtutil . ts2dt ( epoch_seconds ) [EOL] assert [string] . format ( dt ) == [string] [EOL] now = datetime . datetime . now ( datetime . timezone . utc ) [EOL] dt = dtutil . ts2dt ( int ( now . timestamp ( ) ) ) [EOL] assert [string] . format ( dt ) == [string] . format ( now ) [EOL] [EOL] def test_dt2ts ( ) : [EOL] dt = timezone ( [string] ) . localize ( datetime . datetime . utcfromtimestamp ( [number] ) ) [EOL] assert dtutil . dt2ts ( dt ) == [number] [EOL] now = datetime . datetime . now ( datetime . timezone . utc ) [EOL] now_ts = round ( now . timestamp ( ) ) [EOL] assert dtutil . dt2ts ( now ) == now_ts [EOL] [EOL] def test_end_to_end ( ) : [EOL] epoch_seconds = [number] [EOL] dt = dtutil . ts2dt ( epoch_seconds ) [EOL] assert epoch_seconds == dtutil . dt2ts ( dt ) [EOL] [EOL] def test_parse ( ) : [EOL] s = [string] [EOL] dt = dtutil . parse ( s , [string] , timezone ( [string] ) ) [EOL] assert [string] . format ( dt ) == [string] [EOL] s = [string] [EOL] dt = dtutil . parse ( s , [string] , timezone ( [string] ) ) [EOL] assert [string] . format ( dt ) == [string] [EOL] dt = dtutil . parse ( s , [string] , timezone ( [string] ) ) [EOL] assert [string] . format ( dt ) == [string] [EOL] [EOL] def test_parse_rfc3339 ( ) : [EOL] s = [string] [EOL] dt = dtutil . parse_rfc3339 ( s ) [EOL] assert [string] . format ( dt ) == [string] [EOL] s = [string] [EOL] dt = dtutil . parse_rfc3339 ( s ) [EOL] assert [string] . format ( dt ) == [string] [EOL] s = [string] [EOL] dt = dtutil . parse_rfc3339 ( s ) [EOL] assert [string] . format ( dt ) == [string] [EOL] [EOL] def test_parse_to_ts ( ) : [EOL] s = [string] [EOL] assert dtutil . parse_to_ts ( s , [string] , timezone ( [string] ) ) == [number] [EOL] s = [string] [EOL] assert dtutil . parse_to_ts ( s , [string] , timezone ( [string] ) ) == [number] [EOL] assert str ( dtutil . parse_to_ts ( s , [string] , timezone ( [string] ) ) ) == [string] [EOL] [EOL] def test_now ( ) : [EOL] then = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] now = dtutil . now ( ) [EOL] assert ( now - then ) . total_seconds ( ) > [number] [EOL] [EOL] def test_display_date ( ) : [EOL] dt = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] assert dtutil . display_date ( dt ) == [string] [EOL] dt = dtutil . parse ( [string] , [string] , timezone ( [string] ) ) [EOL] assert dtutil . display_date ( dt ) == [string] [EOL] dt = datetime . datetime . now ( datetime . timezone . utc ) - datetime . timedelta ( seconds = [number] ) [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) >= [number] [EOL] dt = datetime . datetime . now ( datetime . timezone . utc ) + datetime . timedelta ( hours = [number] ) [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) >= [number] [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) >= [number] [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) == - [number] [EOL] dt = datetime . datetime . now ( datetime . timezone . utc ) [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) >= [number] [EOL] assert dtutil . display_date ( dt ) . find ( [string] ) == - [number] [EOL] dt = datetime . datetime . now ( dtutil . WOTC_TZ ) + datetime . timedelta ( days = [number] , hours = [number] , minutes = [number] ) [EOL] assert dtutil . display_date ( dt ) == [string] [EOL] dt = datetime . datetime . now ( dtutil . WOTC_TZ ) + datetime . timedelta ( days = [number] ) [EOL] assert dtutil . display_date ( dt ) == [string] [EOL] [EOL] def test_rounding ( ) : [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , granularity = [number] ) == [string] [EOL] assert dtutil . display_time ( [number] ) == [string] [EOL] assert dtutil . display_time ( [number] ) == [string] [EOL] assert dtutil . display_time ( [number] , [number] ) == [string] [EOL] [EOL] def test_round_up_preceeding_unit ( ) : [EOL] results = [ ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) ] [EOL] dtutil . round_up_preceeding_unit ( results ) [EOL] assert results == [ ( [number] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) ] [EOL] [EOL] def test_display_time ( ) : [EOL] assert dtutil . display_time ( [number] * [number] * [number] - [number] * [number] ) == [string] [EOL] assert dtutil . display_time ( [number] * [number] * [number] + [number] * [number] ) == [string] [EOL] assert dtutil . display_time ( [number] * [number] * [number] - [number] ) == [string] [EOL] assert dtutil . display_time ( [number] * [number] * [number] + [number] ) == [string] [EOL] assert dtutil . display_time ( [number] * [number] * [number] - [number] , [number] ) == [string] [EOL] assert dtutil . display_time ( [number] * [number] * [number] + [number] , [number] ) == [string] [EOL] assert dtutil . display_time ( ( [number] * [number] * [number] * [number] ) + ( [number] * [number] * [number] ) + ( [number] * [number] ) ) == [string] [EOL] assert dtutil . display_time ( ( [number] * [number] * [number] * [number] ) + ( [number] * [number] * [number] ) + ( [number] * [number] ) ) == [string] [EOL] assert dtutil . display_time ( [number] ) == [string] [EOL] [EOL] def test_round_value_appropriately ( ) : [EOL] assert dtutil . round_value_appropriately ( [number] , [number] , [number] , [number] ) == [number] [EOL] assert dtutil . round_value_appropriately ( [number] , [number] , [number] , [number] ) == [number] [EOL] assert dtutil . round_value_appropriately ( [number] * [number] * [number] * [number] , [number] * [number] * [number] , [number] , [number] ) == [number] [EOL] assert dtutil . round_value_appropriately ( [number] * [number] * [number] * [number] , [number] * [number] * [number] , [number] , [number] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union , List [EOL] import builtins [EOL] import typing [EOL] import traceback [EOL] import datetime [EOL] import decimal [EOL] import traceback [EOL] from collections . abc import KeysView [EOL] from typing import Any , Dict , List , Union [EOL] [EOL] from shared import dtutil [EOL] [EOL] [EOL] def extra_serializer ( obj ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( obj , datetime . datetime ) : [EOL] return dtutil . dt2ts ( obj ) [EOL] if isinstance ( obj , bytes ) : [EOL] return obj . decode ( [string] ) [EOL] if isinstance ( obj , decimal . Decimal ) : [EOL] return obj . to_eng_string ( ) [EOL] if isinstance ( obj , ( set , KeysView ) ) : [EOL] return list ( obj ) [EOL] if isinstance ( obj , Exception ) : [EOL] stack = traceback . extract_tb ( obj . __traceback__ ) [EOL] return traceback . format_list ( stack ) [EOL] if hasattr ( obj , [string] ) : [EOL] return obj . to_dict ( ) [EOL] if hasattr ( obj , [string] ) : [EOL] val = { } [EOL] for a in obj . __attrs_attrs__ : [EOL] val [ a . name ] = getattr ( obj , a . name ) [EOL] return val [EOL] raise TypeError ( [string] . format ( t = type ( obj ) , obj = obj ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str,typing.List[typing.Any],typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] import aiohttp [EOL] import json [EOL] import os [EOL] import urllib . request [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import aiohttp [EOL] import requests [EOL] from cachecontrol import CacheControl , CacheControlAdapter [EOL] from cachecontrol . caches . file_cache import FileCache [EOL] from cachecontrol . heuristics import ExpiresAfter [EOL] [EOL] from shared import configuration , perf [EOL] from shared . pd_exception import OperationalException [EOL] [EOL] SESSION = CacheControl ( requests . Session ( ) , cache = FileCache ( configuration . get ( [string] ) ) ) [EOL] SESSION . mount ( [string] , CacheControlAdapter ( heuristic = ExpiresAfter ( days = [number] ) ) ) [EOL] [EOL] def fetch ( url , character_encoding = None , force = False , retry = False ) : [EOL] headers = { } [EOL] if force : [EOL] headers [ [string] ] = [string] [EOL] print ( [string] . format ( url = url , cache = [string] if force else [string] ) ) [EOL] try : [EOL] p = perf . start ( ) [EOL] response = requests . get ( url , headers = headers ) [EOL] perf . check ( p , [string] , ( url , headers ) , [string] ) [EOL] if character_encoding is not None : [EOL] response . encoding = character_encoding [EOL] if response . status_code in [ [number] , [number] , [number] ] : [EOL] raise FetchException ( f' [string] { response . status_code } [string] { url }' ) [EOL] p = perf . start ( ) [EOL] t = response . text [EOL] took = round ( perf . took ( p ) , [number] ) [EOL] if took > [number] : [EOL] print ( [string] ) [EOL] return t [EOL] except ( urllib . error . HTTPError , requests . exceptions . ConnectionError , TimeoutError ) as e : [comment] [EOL] if retry : [EOL] return fetch ( url , character_encoding , force , retry = False ) [EOL] raise FetchException ( e ) [EOL] [EOL] async def fetch_async ( url ) : [EOL] print ( f' [string] { url }' ) [EOL] try : [EOL] async with aiohttp . ClientSession ( ) as aios : [EOL] response = await aios . get ( url ) [EOL] return await response . text ( ) [EOL] except ( urllib . error . HTTPError , requests . exceptions . ConnectionError ) as e : [comment] [EOL] raise FetchException ( e ) [EOL] [EOL] def fetch_json ( url , character_encoding = None ) : [EOL] try : [EOL] blob = fetch ( url , character_encoding ) [EOL] if blob : [EOL] return json . loads ( blob ) [EOL] return None [EOL] except json . decoder . JSONDecodeError as e : [EOL] print ( [string] . format ( blob ) ) [EOL] raise FetchException ( e ) [EOL] [EOL] async def fetch_json_async ( url ) : [EOL] try : [EOL] blob = await fetch_async ( url ) [EOL] if blob : [EOL] return json . loads ( blob ) [EOL] return None [EOL] except json . decoder . JSONDecodeError : [EOL] print ( [string] . format ( blob ) ) [EOL] raise [EOL] [EOL] def post ( url , data = None , json_data = None ) : [EOL] print ( [string] . format ( url = url , data = data , json_data = json_data ) ) [EOL] try : [EOL] response = requests . post ( url , data = data , json = json_data ) [EOL] return response . text [EOL] except requests . exceptions . ConnectionError as e : [EOL] raise FetchException ( e ) [EOL] [EOL] def store ( url , path ) : [EOL] print ( [string] . format ( url = url , path = path ) ) [EOL] try : [EOL] response = requests . get ( url , stream = True ) [EOL] with open ( path , [string] ) as fout : [EOL] for chunk in response . iter_content ( [number] ) : [EOL] fout . write ( chunk ) [EOL] return response [EOL] except urllib . error . HTTPError as e : [comment] [EOL] raise FetchException ( e ) [EOL] except requests . exceptions . ConnectionError as e : [comment] [EOL] raise FetchException ( e ) [EOL] [EOL] [EOL] async def store_async ( url , path ) : [EOL] print ( [string] . format ( url = url , path = path ) ) [EOL] try : [EOL] async with aiohttp . ClientSession ( ) as aios : [EOL] response = await aios . get ( url ) [EOL] with open ( path , [string] ) as fout : [EOL] while True : [EOL] chunk = await response . content . read ( [number] ) [EOL] if not chunk : [EOL] break [EOL] fout . write ( chunk ) [EOL] return response [EOL] [comment] [EOL] except ( urllib . error . HTTPError , aiohttp . ClientError ) as e : [EOL] raise FetchException ( e ) [EOL] [EOL] class FetchException ( OperationalException ) : [EOL] pass [EOL] [EOL] def acceptable_file ( filepath ) : [EOL] return os . path . isfile ( filepath ) and os . path . getsize ( filepath ) > [number] [EOL] [EOL] def escape ( str_input , skip_double_slash = False ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] s = str_input [EOL] if skip_double_slash : [EOL] s = s . replace ( [string] , [string] ) [EOL] s = urllib . parse . quote_plus ( s . replace ( [string] , [string] ) ) . lower ( ) [comment] [EOL] if skip_double_slash : [EOL] s = s . replace ( [string] , [string] ) [EOL] return s [EOL] [EOL] [comment] [EOL] def post_discord_webhook ( webhook_id , webhook_token , message = None , username = None , avatar_url = None , embeds = None ) : [EOL] if webhook_id is None or webhook_token is None : [EOL] return False [EOL] url = [string] . format ( id = webhook_id , token = webhook_token ) [EOL] post ( url , json_data = { [string] : message , [string] : username , [string] : avatar_url , [string] : embeds , } ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.ClientResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] from typing import Any [EOL] [EOL] from munch import Munch [EOL] [EOL] [EOL] [comment] [EOL] class Container ( Munch ) : [EOL] [comment] [EOL] def __getattr__ ( self , k ) : [EOL] try : [EOL] return self [ k ] [EOL] except KeyError : [EOL] try : [EOL] return object . __getattribute__ ( self , k ) [EOL] except AttributeError : [EOL] raise AttributeError ( k ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Dict , Union , Literal , Optional , Match , Tuple , List , Any , Type [EOL] import builtins [EOL] import pytz [EOL] import typing_extensions [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import re [EOL] from calendar import timegm [EOL] from collections import OrderedDict [EOL] from typing import Any , Dict , List , Match , Optional , Tuple [EOL] [EOL] import feedparser [EOL] import inflect [EOL] import pytz [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] GATHERLING_TZ = pytz . timezone ( [string] ) [EOL] WOTC_TZ = pytz . timezone ( [string] ) [EOL] APAC_SERIES_TZ = pytz . timezone ( [string] ) [EOL] UTC_TZ = pytz . timezone ( [string] ) [EOL] MTGGOLDFISH_TZ = UTC_TZ [EOL] CARDHOARDER_TZ = UTC_TZ [EOL] [EOL] FORM_FORMAT = [string] [EOL] [EOL] [comment] [EOL] def ts2dt ( ts ) : [EOL] return pytz . timezone ( [string] ) . localize ( datetime . datetime . utcfromtimestamp ( ts ) ) [EOL] [EOL] [comment] [EOL] def dt2ts ( dt ) : [EOL] assert dt . tzinfo is not None , [string] [EOL] return round ( dt . timestamp ( ) ) [EOL] [EOL] [comment] [EOL] def parse ( s , date_format , tz ) : [EOL] dt = datetime . datetime . strptime ( s , date_format ) [EOL] return tz . localize ( dt ) . astimezone ( pytz . timezone ( [string] ) ) [EOL] [EOL] def parse_rfc3339 ( s ) : [EOL] [comment] [EOL] struct = feedparser . _parse_date ( s ) [EOL] return ts2dt ( int ( timegm ( struct ) ) ) [EOL] [EOL] def parse_to_ts ( s , date_format , tz ) : [EOL] dt = parse ( s , date_format , tz ) [EOL] return dt2ts ( dt ) [EOL] [EOL] def timezone ( tzid ) : [EOL] return pytz . timezone ( tzid ) [EOL] [EOL] def now ( tz = None ) : [EOL] if tz is None : [EOL] tz = datetime . timezone . utc [EOL] return datetime . datetime . now ( tz ) [EOL] [EOL] def day_of_week ( dt , tz ) : [EOL] return dt . astimezone ( tz ) . strftime ( [string] ) [EOL] [EOL] def form_date ( dt , tz ) : [EOL] return dt . astimezone ( tz ) . strftime ( FORM_FORMAT ) [EOL] [EOL] def display_date ( dt , granularity = [number] ) : [EOL] start = now ( ) [EOL] if ( start - dt ) > datetime . timedelta ( [number] ) : [EOL] s = [string] . format ( dt . astimezone ( WOTC_TZ ) ) [EOL] return replace_day_with_ordinal ( s ) [EOL] if ( start - dt ) > datetime . timedelta ( [number] ) : [EOL] return display_date_with_date_and_year ( dt ) [EOL] suffix = [string] if start > dt else [string] [EOL] diff = round ( abs ( start - dt ) . total_seconds ( ) ) [EOL] if diff == [number] : [EOL] return [string] [EOL] return [string] . format ( duration = display_time ( diff , granularity ) , suffix = suffix ) [EOL] [EOL] def display_date_with_date_and_year ( dt , tz = WOTC_TZ ) : [EOL] s = [string] . format ( dt . astimezone ( tz ) ) [EOL] return replace_day_with_ordinal ( s ) [EOL] [EOL] def replace_day_with_ordinal ( s ) : [EOL] return re . sub ( [string] , day2ordinal , s ) [EOL] [EOL] def day2ordinal ( m ) : [EOL] p = inflect . engine ( ) [EOL] return p . ordinal ( int ( m . group ( [number] ) ) ) [EOL] [EOL] IntervalsType = Dict [ str , Tuple [ Optional [ int ] , int , Optional [ int ] ] ] [EOL] ResultsType = List [ Tuple [ int , str ] ] [EOL] [EOL] def get_intervals ( ) : [EOL] intervals = OrderedDict ( ) [EOL] intervals [ [string] ] = ( None , [number] * [number] * [number] * [number] , None ) [EOL] intervals [ [string] ] = ( [number] , [number] * [number] * [number] , [number] ) [EOL] intervals [ [string] ] = ( [number] , [number] * [number] , [number] ) [EOL] intervals [ [string] ] = ( [number] , [number] , [number] ) [EOL] intervals [ [string] ] = ( [number] , [number] , [number] ) [EOL] return intervals [EOL] [EOL] def display_time ( seconds , granularity = [number] ) : [EOL] intervals = get_intervals ( ) [EOL] result = [ ] [EOL] seconds = round ( seconds ) [comment] [EOL] if seconds == [number] : [EOL] return [string] [EOL] for unit , details in intervals . items ( ) : [EOL] max_units , seconds_per_unit , rounding_threshold = details [EOL] if len ( result ) < granularity : [comment] [EOL] value = int ( seconds // seconds_per_unit ) [comment] [EOL] else : [EOL] value = round_value_appropriately ( seconds , seconds_per_unit , max_units , rounding_threshold ) [EOL] if value == max_units and seconds < ( value * seconds_per_unit ) : [comment] [EOL] result = round_up_preceeding_unit ( result ) [EOL] seconds -= value * seconds_per_unit [EOL] value = [number] [EOL] if value > [number] or result : [comment] [EOL] result . append ( ( value , unit ) ) [EOL] seconds -= value * seconds_per_unit [EOL] return [string] . join ( [ [string] . format ( value , unit . rstrip ( [string] ) if value == [number] else unit ) for ( value , unit ) in result [ : granularity ] if value > [number] ] ) [EOL] [EOL] def round_value_appropriately ( seconds , seconds_per_unit , max_units , rounding_threshold ) : [EOL] if rounding_threshold is None or max_units is None : [EOL] return round ( seconds / seconds_per_unit ) [EOL] value = seconds // seconds_per_unit [EOL] if value >= rounding_threshold : [EOL] return max_units [EOL] return value [EOL] [EOL] def round_up_preceeding_unit ( result ) : [EOL] intervals = get_intervals ( ) [EOL] [comment] [EOL] for i in range ( [number] , len ( result ) + [number] ) : [EOL] prev_value , prev_unit = result [ - i ] [EOL] result [ - i ] = ( prev_value + [number] , prev_unit ) [EOL] if result [ - i ] [ [number] ] < intervals [ prev_unit ] [ [number] ] : [EOL] break [EOL] result [ - i ] = ( [number] , result [ - i ] [ [number] ] ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ResultsType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class PDException ( Exception ) : [EOL] pass [EOL] [EOL] class OperationalException ( PDException ) : [EOL] pass [EOL] [EOL] class ParseException ( PDException ) : [EOL] pass [EOL] [EOL] class InvalidDataException ( PDException ) : [EOL] pass [EOL] [EOL] class DatabaseException ( PDException ) : [EOL] pass [EOL] [EOL] class DatabaseMissingException ( DatabaseException ) : [EOL] pass [EOL] [EOL] class DoesNotExistException ( PDException ) : [EOL] pass [EOL] [EOL] class TooManyItemsException ( PDException ) : [EOL] pass [EOL] [EOL] class TooFewItemsException ( PDException ) : [EOL] pass [EOL] [EOL] class InvalidArgumentException ( PDException ) : [EOL] pass [EOL] [EOL] class LockNotAcquiredException ( DatabaseException ) : [EOL] pass [EOL] [EOL] class DatabaseConnectionRefusedException ( DatabaseException ) : [EOL] pass [EOL] [EOL] class AlreadyExistsException ( PDException ) : [EOL] pass [EOL] [EOL] class NotConfiguredException ( PDException ) : [EOL] pass [EOL] [EOL] class TestFailedException ( PDException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import decksite [EOL] from decksite import translation [EOL] from decksite . data . deck import RawDeckDescription [EOL] [EOL] [EOL] def test_translate ( ) : [EOL] d = { [string] : [number] , [string] : [string] } [EOL] t = translation . translate ( translation . TAPPEDOUT , d ) [EOL] assert t [ [string] ] == [number] [EOL] assert t [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Dict , Optional [EOL] [EOL] from decksite . data . deck import RawDeckDescription [EOL] [EOL] TAPPEDOUT = { [string] : [string] , [string] : [string] , } [EOL] [EOL] def translate ( mappings , data ) : [EOL] result = data . copy ( ) [comment] [EOL] for k , v in data . items ( ) : [EOL] our_key = mappings . get ( k ) [EOL] if our_key is not None : [EOL] result [ our_key ] = v [comment] [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.RawDeckDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union , List [EOL] import shared_web [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import datetime [EOL] import logging [EOL] from typing import Any , Dict , List , Tuple , Union , cast [EOL] [EOL] from flask import Blueprint , g , request , url_for [EOL] from flask_babel import gettext , ngettext [EOL] [EOL] from magic import multiverse , oracle , rotation [EOL] from shared import configuration , dtutil [EOL] from shared . pd_exception import DatabaseException [EOL] from shared_web . flask_app import PDFlask [EOL] [EOL] APP = PDFlask ( __name__ ) [EOL] APP . logger . setLevel ( logging . WARN ) [comment] [EOL] SEASONS = Blueprint ( [string] , __name__ , url_prefix = [string] ) [EOL] [EOL] def get_season_id ( ) : [EOL] season_id = g . get ( [string] , rotation . current_season_num ( ) ) [EOL] if season_id == [string] : [EOL] return [number] [EOL] return season_id [EOL] [EOL] @ SEASONS . url_defaults def add_season_id ( _endpoint , values ) : [EOL] values . setdefault ( [string] , get_season_id ( ) ) [EOL] [EOL] @ SEASONS . url_value_preprocessor def pull_season_id ( _endpoint , values ) : [EOL] v = values . pop ( [string] ) [EOL] g . season_id = rotation . season_id ( v ) [EOL] [EOL] APP . config [ [string] ] = configuration . get ( [string] ) [EOL] [EOL] def build_menu ( ) : [EOL] current_template = ( request . endpoint or [string] ) . replace ( [string] , [string] ) [EOL] archetypes_badge = { [string] : url_for ( [string] ) , [string] : [string] , [string] : [string] } [EOL] resources_submenu = [ ] [EOL] if ( rotation . next_rotation ( ) - dtutil . now ( ) ) < datetime . timedelta ( [number] ) : [EOL] resources_submenu . append ( { [string] : gettext ( [string] ) , [string] : [string] } ) [EOL] resources_submenu += [ { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } ] [EOL] menu = [ { [string] : gettext ( [string] ) , [string] : [string] , [string] : archetypes_badge , [string] : [ { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] , [string] : archetypes_badge } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , ] } , { [string] : gettext ( [string] ) , [string] : [string] , [string] : [ { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , ] } , { [string] : gettext ( [string] ) , [string] : [string] , [string] : [ { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } ] } , { [string] : gettext ( [string] ) , [string] : [string] , [string] : resources_submenu } , { [string] : gettext ( [string] ) , [string] : [string] , [string] : [ { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } , { [string] : gettext ( [string] ) , [string] : [string] } ] } , { [string] : gettext ( [string] ) , [string] : True , [string] : [string] , [string] : admin . admin_menu ( ) } ] [EOL] setup_links ( menu ) [EOL] for item in menu : [EOL] item [ [string] ] = item . get ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) == current_template or current_template in [ entry . get ( [string] , [string] ) for entry in item . get ( [string] , [ ] ) ] [EOL] item [ [string] ] = item . get ( [string] ) is not None [EOL] return menu [EOL] [EOL] def setup_links ( menu ) : [EOL] for item in menu : [EOL] if item . get ( [string] ) : [EOL] item [ [string] ] = url_for ( item . get ( [string] , [string] ) ) [EOL] item [ [string] ] = cast ( str , item . get ( [string] , [string] ) ) . startswith ( [string] ) and [string] not in item [ [string] ] [EOL] setup_links ( item . get ( [string] , [ ] ) ) [EOL] [EOL] try : [EOL] oracle . init ( ) [EOL] except DatabaseException as e : [EOL] print ( [string] , e ) [EOL] multiverse . init ( ) [EOL] oracle . init ( ) [EOL] [EOL] from decksite . controllers import admin [comment] [EOL] from . data import deck [comment] [EOL] APP . config [ [string] ] = build_menu [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import io [EOL] import typing [EOL] import builtins [EOL] import shared [EOL] import os [EOL] [EOL] from flask import g , has_request_context , request [EOL] [EOL] from shared import configuration , logger [EOL] from shared . container import Container [EOL] from shared . database import Database , get_database [EOL] [EOL] [EOL] def db ( ) : [EOL] if has_request_context ( ) : [comment] [EOL] ctx = request [EOL] elif g : [EOL] ctx = g [EOL] else : [EOL] ctx = Container ( ) [comment] [EOL] if not hasattr ( ctx , [string] ) : [EOL] ctx . database = get_database ( configuration . get_str ( [string] ) ) [comment] [EOL] return ctx . database [comment] [EOL] [EOL] def setup ( ) : [EOL] [comment] [EOL] from decksite import APP [EOL] with APP . app_context ( ) : [comment] [EOL] db ( ) . execute ( [string] ) [EOL] version = db_version ( ) [EOL] patches = os . listdir ( [string] ) [EOL] patches . sort ( key = lambda n : int ( n . split ( [string] ) [ [number] ] ) ) [EOL] for fn in patches : [EOL] path = os . path . join ( [string] , fn ) [EOL] n = int ( fn . split ( [string] ) [ [number] ] ) [EOL] if version < n : [EOL] logger . warning ( [string] . format ( n ) ) [EOL] fh = open ( path , [string] ) [EOL] sql = fh . read ( ) [EOL] for stmt in sql . split ( [string] ) : [EOL] if stmt . strip ( ) != [string] : [EOL] db ( ) . execute ( stmt ) [EOL] fh . close ( ) [EOL] db ( ) . execute ( [string] . format ( n = n ) ) [EOL] [EOL] def db_version ( ) : [EOL] return db ( ) . value ( [string] , [ ] , [number] ) [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import builtins [EOL] import magic [EOL] import flask [EOL] import werkzeug [EOL] import asyncio [EOL] import typing [EOL] import decksite [EOL] import asyncio [EOL] import logging [EOL] import os [EOL] from typing import Optional [EOL] [EOL] from flask import Response , abort , g , make_response , redirect , request , send_file , session [EOL] from werkzeug import wrappers [EOL] from werkzeug . exceptions import InternalServerError [EOL] [EOL] from decksite import APP , SEASONS , auth , deck_name , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . charts import chart [EOL] from decksite . data import card as cs [EOL] from decksite . data import deck as ds [EOL] from decksite . data import match as ms [EOL] from decksite . data import news as ns [EOL] from decksite . database import db [EOL] from decksite . views import Home [EOL] from magic import card as mc [EOL] from magic import image_fetcher , oracle [EOL] from shared import dtutil , logger , perf [EOL] from shared . pd_exception import TooFewItemsException [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def home ( ) : [EOL] view = Home ( ns . all_news ( max_items = [number] ) , ds . latest_decks ( season_id = get_season_id ( ) ) , cs . load_cards ( season_id = get_season_id ( ) ) , ms . stats ( ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . load_person def export ( deck_id ) : [EOL] d = ds . load_deck ( deck_id ) [EOL] if d . is_in_current_run ( ) : [EOL] if not session . get ( [string] ) and ( not auth . person_id ( ) or auth . person_id ( ) != d . person_id ) : [EOL] abort ( [number] ) [EOL] safe_name = deck_name . file_name ( d ) [EOL] return make_response ( mc . to_mtgo_format ( str ( d ) ) , [number] , { [string] : [string] , [string] : [string] . format ( name = safe_name ) } ) [EOL] [EOL] @ APP . route ( [string] ) def cmc_chart ( deck_id ) : [EOL] return send_file ( chart . cmc ( int ( deck_id ) ) ) [EOL] [EOL] @ APP . route ( [string] ) def discord ( ) : [EOL] return redirect ( [string] ) [EOL] [EOL] @ APP . route ( [string] ) def image ( c = [string] ) : [EOL] names = c . split ( [string] ) [EOL] try : [EOL] requested_cards = oracle . load_cards ( names ) [EOL] path = image_fetcher . download_image ( requested_cards ) [EOL] if path is None : [EOL] raise InternalServerError ( f' [string] { c }' ) [EOL] return send_file ( os . path . abspath ( path ) ) [comment] [EOL] except TooFewItemsException as e : [EOL] logger . info ( f' [string] { c } [string] { e }' ) [EOL] if len ( names ) == [number] : [EOL] return redirect ( f' [string] { c } [string] ' , code = [number] ) [EOL] return make_response ( [string] , [number] ) [EOL] [EOL] @ APP . route ( [string] ) def banner ( seasonnum ) : [EOL] nice_path = os . path . join ( str ( APP . static_folder ) , [string] , [string] , f'{ seasonnum } [string] ' ) [EOL] if os . path . exists ( nice_path ) : [EOL] return send_file ( os . path . abspath ( nice_path ) ) [EOL] cardnames = [ [string] , [string] , [string] ] [EOL] background = [string] [EOL] if seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] elif seasonnum == [string] : [EOL] cardnames = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] background = [string] [EOL] loop = asyncio . new_event_loop ( ) [EOL] path = loop . run_until_complete ( image_fetcher . generate_banner ( cardnames , background ) ) [EOL] return send_file ( os . path . abspath ( path ) ) [EOL] [EOL] @ APP . before_request def before_request ( ) : [EOL] g . p = perf . start ( ) [EOL] [EOL] @ APP . after_request def after_request ( response ) : [EOL] requests_until_no_intro = [number] [comment] [EOL] views = int ( request . cookies . get ( [string] , [number] ) ) + [number] [EOL] response . set_cookie ( [string] , str ( views ) ) [EOL] if views >= requests_until_no_intro : [EOL] response . set_cookie ( [string] , value = str ( True ) , expires = dtutil . dt2ts ( dtutil . now ( ) ) + [number] * [number] * [number] * [number] * [number] ) [EOL] return response [EOL] [EOL] @ APP . teardown_request def teardown_request ( _ ) : [EOL] if g . get ( [string] ) is not None : [EOL] perf . check ( g . p , [string] , request . path , [string] ) [EOL] db ( ) . close ( ) [EOL] [EOL] def init ( debug = True , port = None ) : [EOL] [docstring] [EOL] APP . logger . setLevel ( logging . INFO ) [comment] [EOL] APP . run ( host = [string] , debug = debug , port = port ) [EOL] [EOL] APP . register_blueprint ( SEASONS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import Enum [EOL] [EOL] [EOL] class DeckType ( Enum ) : [EOL] ALL = [string] [EOL] LEAGUE = [string] [EOL] TOURNAMENT = [string] [EOL] OTHER = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from decksite import view [EOL] from decksite . main import APP [EOL] from magic import rotation [EOL] [EOL] [EOL] def test_seasonized_url_for_app ( ) : [EOL] with APP . test_request_context ( [string] ) : [EOL] assert view . seasonized_url ( [number] ) == [string] [EOL] assert view . seasonized_url ( rotation . current_season_num ( ) ) == [string] [EOL] [EOL] def test_seasonized_url_for_seasons ( ) : [EOL] with APP . test_request_context ( [string] ) : [EOL] assert view . seasonized_url ( [number] ) == [string] [EOL] assert view . seasonized_url ( rotation . current_season_num ( ) ) == [string] [EOL] [EOL] def test_seasonized_url_simple ( ) : [EOL] with APP . test_request_context ( [string] ) : [EOL] assert view . seasonized_url ( [number] ) == [string] [EOL] assert view . seasonized_url ( rotation . current_season_num ( ) ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Optional , List , Any [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import flask [EOL] import binascii [EOL] import datetime [EOL] import functools [EOL] import os [EOL] from typing import Any , Callable , Dict , List [EOL] [EOL] from cachelib . simple import SimpleCache [EOL] from flask import make_response , request [EOL] [EOL] from decksite import get_season_id [EOL] from magic import rotation [EOL] from shared_web import localization [EOL] [EOL] CACHE = SimpleCache ( ) [comment] [EOL] [EOL] def cached ( ) : [EOL] return cached_impl ( cacheable = True , must_revalidate = True , client_only = False , client_timeout = [number] * [number] * [number] , server_timeout = [number] * [number] ) [EOL] [EOL] [comment] [EOL] def cached_impl ( cacheable = False , must_revalidate = True , client_only = True , client_timeout = [number] , server_timeout = [number] * [number] , key = [string] ) : [EOL] [docstring] [EOL] def decorator ( f ) : [EOL] @ functools . wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] cache_key = key . format ( id = request . full_path , locale = localization . get_locale ( ) ) [comment] [EOL] cache_policy = [string] [EOL] if not cacheable : [EOL] cache_policy += [string] [comment] [EOL] else : [EOL] if must_revalidate : [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cache_policy += [string] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] cache_policy += [string] [EOL] [EOL] if client_only : [EOL] cache_policy += [string] [EOL] else : [EOL] cache_policy += [string] [EOL] [EOL] actual_client_timeout = client_timeout [EOL] actual_server_timeout = server_timeout [EOL] if get_season_id ( ) and get_season_id ( ) != [number] and get_season_id ( ) < rotation . current_season_num ( ) : [EOL] actual_client_timeout = [number] * [number] * [number] * [number] [EOL] actual_server_timeout = [number] * [number] * [number] * [number] [EOL] [EOL] cache_policy += [string] . format ( client_timeout = actual_client_timeout ) [EOL] [EOL] headers = { } [EOL] cache_policy = cache_policy . strip ( [string] ) [EOL] headers [ [string] ] = cache_policy [EOL] now = datetime . datetime . utcnow ( ) [EOL] [EOL] client_etag = request . headers . get ( [string] ) [EOL] [EOL] response = CACHE . get ( cache_key ) [comment] [EOL] [comment] [EOL] [comment] [EOL] if response is not None and request . headers . get ( [string] , [string] ) != [string] : [EOL] headers [ [string] ] = [string] [EOL] cached_etag = response . headers . get ( [string] ) [EOL] if client_etag and cached_etag and client_etag == cached_etag : [EOL] headers [ [string] ] = [string] [EOL] headers [ [string] ] = response . headers . get ( [string] ) [EOL] response = make_response ( [string] , [number] ) [EOL] else : [EOL] response = make_response ( f ( * args , ** kwargs ) ) [EOL] if response . status_code == [number] and request . method in [ [string] , [string] ] : [EOL] headers [ [string] ] = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] response . headers . add ( [string] , binascii . hexlify ( os . urandom ( [number] ) ) ) [EOL] response . headers . add ( [string] , str ( now ) ) [EOL] CACHE . set ( cache_key , response , timeout = actual_server_timeout ) [EOL] [EOL] response . headers . extend ( headers ) [EOL] return response [EOL] return decorated_function [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Optional , Tuple , List , Any [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import werkzeug [EOL] from functools import wraps [EOL] from typing import Any , Callable , Dict , List , Optional , Tuple [EOL] [EOL] from flask import redirect , request , session , url_for [EOL] from werkzeug import wrappers [EOL] [EOL] from decksite . data import person [EOL] [EOL] [EOL] def login_required ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] if session . get ( [string] ) is None : [EOL] return redirect ( url_for ( [string] , target = request . url ) ) [EOL] return f ( * args , ** kwargs ) [EOL] return decorated_function [EOL] [EOL] def demimod_required ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] if session . get ( [string] ) is None and session . get ( [string] ) is None : [EOL] return redirect ( url_for ( [string] , target = request . url ) ) [EOL] if session . get ( [string] ) is False and session . get ( [string] ) is False : [EOL] return redirect ( url_for ( [string] ) ) [EOL] return f ( * args , ** kwargs ) [EOL] return decorated_function [EOL] [EOL] def admin_required ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] if session . get ( [string] ) is None : [EOL] return redirect ( url_for ( [string] , target = request . url ) ) [EOL] if session . get ( [string] ) is False : [EOL] return redirect ( url_for ( [string] ) ) [EOL] return f ( * args , ** kwargs ) [EOL] return decorated_function [EOL] [EOL] def admin_required_no_redirect ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] if not session . get ( [string] ) : [EOL] return [string] , [number] [EOL] return f ( * args , ** kwargs ) [EOL] return decorated_function [EOL] [EOL] [EOL] def load_person ( f ) : [EOL] @ wraps ( f ) def decorated_function ( * args , ** kwargs ) : [EOL] if discord_id ( ) is not None : [EOL] p = person . maybe_load_person_by_discord_id ( discord_id ( ) ) [EOL] if p : [EOL] login ( p ) [EOL] return f ( * args , ** kwargs ) [EOL] return decorated_function [EOL] [EOL] [EOL] def discord_id ( ) : [EOL] return session . get ( [string] ) [EOL] [EOL] def person_id ( ) : [EOL] return session . get ( [string] ) [EOL] [EOL] def mtgo_username ( ) : [EOL] return session . get ( [string] ) [EOL] [EOL] def login ( p ) : [EOL] session [ [string] ] = p . id [EOL] session [ [string] ] = p . id [EOL] session [ [string] ] = p . name [EOL] session . permanent = True [EOL] if p . locale != session . get ( [string] ) : [EOL] person . set_locale ( p . id , session . get ( [string] ) ) [EOL] [EOL] def hide_intro ( ) : [EOL] return session . get ( [string] , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,werkzeug.wrappers.Response]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Counter , Literal , Optional , Tuple , List , Container , Any [EOL] import builtins [EOL] import babel [EOL] import magic [EOL] import shared [EOL] import typing_extensions [EOL] import collections [EOL] import typing [EOL] import decksite [EOL] import html [EOL] from collections import Counter [EOL] from typing import Any , List , Optional , Union , cast [EOL] [EOL] import inflect [EOL] from anytree . iterators import PreOrderIter [EOL] from babel import Locale [EOL] from flask import request , url_for [EOL] from flask_babel import gettext , ngettext [EOL] from mypy_extensions import TypedDict [EOL] from werkzeug . routing import BuildError [EOL] [EOL] from decksite import APP , get_season_id , prepare [EOL] from decksite . data import archetype , competition [EOL] from decksite . data . archetype import Archetype [EOL] from decksite . deck_type import DeckType [EOL] from magic import card_price , fetcher , legality , oracle , rotation , tournaments [EOL] from magic . models import Deck [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] from shared_web . base_view import BaseView [EOL] [EOL] SeasonInfoDescription = TypedDict ( [string] , { [string] : str , [string] : str , [string] : str , [string] : Optional [ int ] , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : Optional [ str ] } , total = False ) [EOL] [EOL] [comment] [EOL] class View ( BaseView ) : [EOL] def __init__ ( self ) : [EOL] self . max_price_text = card_price . MAX_PRICE_TEXT [EOL] self . decks = [ ] [EOL] self . active_runs_text = [string] [EOL] self . hide_active_runs = True [EOL] self . show_seasons = False [EOL] self . legal_formats = None [EOL] self . cardhoarder_logo_url = url_for ( [string] , filename = [string] ) [EOL] self . mtgotraders_logo_url = url_for ( [string] , filename = [string] ) [EOL] self . is_person_page = None [EOL] self . next_tournament_name = None [EOL] self . next_tournament_time = None [EOL] self . tournaments = [ ] [EOL] self . content_class = [string] + self . __class__ . __name__ . lower ( ) [EOL] self . page_size = request . cookies . get ( [string] , [number] ) [EOL] self . tournament_only = False [EOL] self . show_matchup_grid = False [EOL] self . matchup_archetypes = [ ] [EOL] [EOL] def season_id ( self ) : [EOL] return get_season_id ( ) [EOL] [EOL] def season_name ( self ) : [EOL] return rotation . season_name ( get_season_id ( ) ) [EOL] [EOL] def season_code_lower ( self ) : [EOL] return rotation . season_code ( get_season_id ( ) ) . lower ( ) [EOL] [EOL] def all_seasons ( self ) : [EOL] seasons = [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : seasonized_url ( [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] , deck_type = DeckType . LEAGUE . value ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : url_for ( [string] , season_id = [string] ) , [string] : None } ] [EOL] num = [number] [EOL] next_rotation_set_code = rotation . next_rotation_ex ( ) . code [EOL] for code in rotation . SEASONS : [EOL] if code == next_rotation_set_code : [EOL] break [EOL] seasons . append ( { [string] : rotation . season_name ( num ) , [string] : code , [string] : code . lower ( ) , [string] : num , [string] : seasonized_url ( num ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num , deck_type = DeckType . LEAGUE . value ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num ) , [string] : url_for ( [string] , season_id = num ) , [string] : f' [string] { code } [string] ' } ) [EOL] num += [number] [EOL] seasons . reverse ( ) [EOL] return seasons [EOL] [EOL] def favicon_url ( self ) : [EOL] return url_for ( [string] , rest = [string] ) [EOL] [EOL] def favicon_152_url ( self ) : [EOL] return url_for ( [string] , rest = [string] ) [EOL] [EOL] def title ( self ) : [EOL] if not self . page_title ( ) : [EOL] return [string] [EOL] if get_season_id ( ) == rotation . current_season_num ( ) : [EOL] season = [string] [EOL] elif get_season_id ( ) == [number] : [EOL] season = [string] [EOL] else : [EOL] season = [string] . format ( n = get_season_id ( ) ) [EOL] return [string] . format ( page_title = self . page_title ( ) , season = season ) [EOL] [EOL] def page_title ( self ) : [EOL] pass [EOL] [EOL] def num_tournaments ( self ) : [EOL] return inflect . engine ( ) . number_to_words ( len ( tournaments . all_series_info ( ) ) ) [EOL] [EOL] def rotation_text ( self ) : [EOL] return rotation . message ( ) [EOL] [EOL] def learn_more_url ( self ) : [EOL] return url_for ( [string] , hide_intro = True ) [EOL] [EOL] def decks_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def current_league_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def league_info_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def league_signup_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def tournaments_info_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def show_legal_seasons ( self ) : [EOL] return get_season_id ( ) == [number] [EOL] [EOL] def prepare ( self ) : [EOL] self . prepare_decks ( ) [EOL] self . prepare_cards ( ) [EOL] self . prepare_competitions ( ) [EOL] self . prepare_people ( ) [EOL] self . prepare_archetypes ( ) [EOL] self . prepare_leaderboards ( ) [EOL] self . prepare_legal_formats ( ) [EOL] self . prepare_matches ( ) [EOL] [EOL] def prepare_decks ( self ) : [EOL] self . prepare_active_runs ( self ) [EOL] prepare . prepare_decks ( getattr ( self , [string] , [ ] ) ) [EOL] [EOL] def prepare_cards ( self ) : [EOL] prepare . prepare_cards ( getattr ( self , [string] , [ ] ) , getattr ( self , [string] , False ) ) [EOL] [EOL] def prepare_competitions ( self ) : [EOL] for c in getattr ( self , [string] , [ ] ) : [EOL] c . competition_url = [string] . format ( id = c . id ) [EOL] c . display_date = dtutil . display_date ( c . start_date ) [EOL] c . ends = [string] if c . end_date < dtutil . now ( ) else dtutil . display_date ( c . end_date ) [EOL] c . date_sort = dtutil . dt2ts ( c . start_date ) [EOL] c . league = c . type == [string] [EOL] title_safe = [string] [EOL] try : [EOL] for k , v in c . base_archetypes_data ( ) . items ( ) : [EOL] if v > [number] : [EOL] title_safe += [string] . format ( v = v , k = html . escape ( k ) ) [EOL] except KeyError : [EOL] archetype . rebuild_archetypes ( ) [EOL] [EOL] def prepare_people ( self ) : [EOL] for p in getattr ( self , [string] , [ ] ) : [EOL] if p . get ( [string] ) : [EOL] p . url = f' [string] { p . mtgo_username } [string] ' [EOL] else : [EOL] p . url = f' [string] { p . id } [string] ' [EOL] p . show_record = p . get ( [string] , None ) or p . get ( [string] , None ) or p . get ( [string] , None ) [EOL] [EOL] def prepare_archetypes ( self ) : [EOL] for a in getattr ( self , [string] , [ ] ) : [EOL] self . prepare_archetype ( a , getattr ( self , [string] , [ ] ) ) [EOL] [EOL] def prepare_archetype ( self , a , archetypes ) : [EOL] a . current = a . id == getattr ( self , [string] , { } ) . get ( [string] , None ) [EOL] a . show_record = a . get ( [string] ) is not None and ( a . get ( [string] ) or a . get ( [string] ) or a . get ( [string] ) ) [EOL] counter = Counter ( ) [comment] [EOL] a . cards = [ ] [EOL] a . most_common_cards = [ ] [EOL] [comment] [EOL] for d in a . get ( [string] , [ ] ) : [EOL] a . cards += d . maindeck + d . sideboard [EOL] for c in d . maindeck : [EOL] if not c . card . type_line . startswith ( [string] ) : [EOL] counter [ c [ [string] ] ] += c [ [string] ] [EOL] most_common_cards = counter . most_common ( prepare . NUM_MOST_COMMON_CARDS_TO_LIST ) [EOL] cs = oracle . cards_by_name ( ) [EOL] for v in most_common_cards : [EOL] prepare . prepare_card ( cs [ v [ [number] ] ] , getattr ( self , [string] , False ) ) [EOL] a . most_common_cards . append ( cs [ v [ [number] ] ] ) [EOL] a . has_most_common_cards = len ( a . most_common_cards ) > [number] [EOL] for b in [ b for b in PreOrderIter ( a ) if b . id in [ a . id for a in archetypes ] ] : [EOL] b [ [string] ] = url_for ( [string] , archetype_id = b [ [string] ] ) [EOL] [comment] [EOL] b [ [string] ] = b . depth [EOL] [EOL] def prepare_leaderboards ( self ) : [EOL] for l in getattr ( self , [string] , [ ] ) : [EOL] self . prepare_leaderboard ( l ) [EOL] [EOL] def prepare_leaderboard ( self , leaderboard ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] finish = [number] [EOL] score = None [EOL] for i , p in enumerate ( leaderboard , start = [number] ) : [EOL] if finish == [number] or p . score != score : [EOL] score = p . score [EOL] finish = i [EOL] p . finish = finish [EOL] if p . finish <= [number] : [EOL] p . position = chr ( [number] + p . finish ) [comment] [EOL] p . url = url_for ( [string] , person_id = p . person_id ) [EOL] [EOL] def prepare_legal_formats ( self ) : [EOL] if getattr ( self , [string] , None ) is not None : [EOL] self . legal_formats = list ( map ( add_season_num , list ( sorted ( self . legal_formats , key = legality . order_score ) ) ) ) [comment] [EOL] [EOL] def prepare_matches ( self ) : [EOL] for m in getattr ( self , [string] , [ ] ) : [EOL] if m . get ( [string] ) : [EOL] m . display_date = dtutil . display_date ( m . date ) [EOL] m . date_sort = dtutil . dt2ts ( m . date ) [EOL] if m . get ( [string] ) : [EOL] m . deck_url = url_for ( [string] , deck_id = m . deck_id ) [EOL] if m . get ( [string] ) : [EOL] m . opponent_url = url_for ( [string] , mtgo_username = m . opponent ) [EOL] if m . get ( [string] ) : [EOL] m . opponent_deck_url = url_for ( [string] , deck_id = m . opponent_deck_id ) [EOL] if m . get ( [string] ) : [EOL] m . log_url = fetcher . logsite_url ( [string] . format ( id = m . get ( [string] ) ) ) [EOL] [EOL] def prepare_active_runs ( self , o ) : [EOL] decks = getattr ( o , [string] , [ ] ) [EOL] active , other = [ ] , [ ] [EOL] for d in decks : [EOL] if d . is_in_current_run ( ) : [EOL] active . append ( d ) [EOL] else : [EOL] other . append ( d ) [EOL] if active and o . hide_active_runs : [EOL] o . active_runs_text = ngettext ( [string] , [string] , len ( active ) ) if active else [string] [EOL] o . decks = other [EOL] [EOL] def babel_languages ( self ) : [EOL] return APP . babel . list_translations ( ) [EOL] [EOL] def TT_HELP_TRANSLATE ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def setup_tournaments ( self ) : [EOL] info = tournaments . next_tournament_info ( ) [EOL] self . next_tournament_name = info [ [string] ] [EOL] self . next_tournament_time = info [ [string] ] [EOL] self . tournaments = sorted ( tournaments . all_series_info ( ) , key = lambda t : t . time ) [EOL] leagues = competition . load_competitions ( [string] ) [EOL] end_date , prev_month , shown_end = None , None , False [EOL] for t in self . tournaments : [EOL] month = t . time . strftime ( [string] ) [EOL] if month != prev_month : [EOL] t . month = month [EOL] prev_month = month [EOL] t . date = t . time . day [EOL] if leagues and t . time >= leagues [ - [number] ] . start_date and t . time < leagues [ - [number] ] . end_date : [EOL] t . league = leagues . pop ( - [number] ) [EOL] t . league . display = True [EOL] end_date = t . league . end_date [EOL] elif not shown_end and end_date and t . time >= end_date : [EOL] t . league = { [string] : [string] , [string] : False } [EOL] shown_end = True [EOL] elif end_date : [EOL] t . league = { [string] : [string] , [string] : False } [EOL] [EOL] def setup_matchups ( self , archetypes , matchups , min_matches ) : [EOL] for hero in archetypes : [EOL] hero . matchups = [ ] [EOL] matchups_by_enemy_id = { mu . id : mu for mu in matchups if mu . archetype_id == hero . id } [EOL] for enemy in archetypes : [EOL] mu = matchups_by_enemy_id . get ( enemy . id , Container ( { [string] : [number] , [string] : [number] } ) ) [EOL] if mu . wins + mu . losses >= min_matches : [EOL] hero . show_as_hero = True [EOL] enemy . show_as_enemy = True [EOL] self . show_matchup_grid = True [EOL] if mu and mu . wins + mu . losses > [number] : [EOL] prepare_matchup ( mu , enemy ) [EOL] hero . matchups . append ( mu ) [EOL] else : [EOL] hero . matchups . append ( empty_matchup ( enemy ) ) [EOL] for hero in archetypes : [EOL] for mu in hero . matchups : [EOL] mu . show_as_enemy = mu . opponent_archetype . get ( [string] , False ) [EOL] self . matchup_archetypes = archetypes [EOL] [EOL] [EOL] def prepare_matchup ( mu , opponent_archetype ) : [EOL] mu . has_data = True [EOL] mu . win_percent = float ( mu . win_percent ) [EOL] mu . color_cell = True [EOL] mu . hue = [number] if mu . win_percent >= [number] else [number] [EOL] mu . saturation = abs ( mu . win_percent - [number] ) + [number] [EOL] mu . lightness = [number] [EOL] mu . opponent_archetype = opponent_archetype [EOL] [EOL] def empty_matchup ( opponent_archetype ) : [EOL] mu = Container ( ) [EOL] mu . has_data = False [EOL] mu . win_percent = None [EOL] mu . color_cell = False [EOL] mu . opponent_archetype = opponent_archetype [EOL] return mu [EOL] [EOL] def seasonized_url ( season_id ) : [EOL] args = request . view_args . copy ( ) [EOL] if season_id == rotation . current_season_num ( ) : [EOL] args . pop ( [string] , None ) [EOL] endpoint = cast ( str , request . endpoint ) . replace ( [string] , [string] ) [EOL] else : [EOL] args [ [string] ] = season_id [EOL] prefix = [string] if cast ( str , request . endpoint ) . startswith ( [string] ) else [string] [EOL] endpoint = [string] . format ( prefix = prefix , endpoint = request . endpoint ) [EOL] try : [EOL] return url_for ( endpoint , ** args ) [EOL] except BuildError : [EOL] return url_for ( cast ( str , request . endpoint ) ) [EOL] [EOL] def add_season_num ( f ) : [EOL] if not [string] in f : [EOL] return f [EOL] code = f . replace ( [string] , [string] ) [EOL] num = rotation . season_num ( code ) [EOL] return f . replace ( code , f'{ code } [string] { num } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] from decksite import league [EOL] from shared import dtutil [EOL] [EOL] [EOL] def test_determine_end_of_league ( ) : [EOL] next_rotation = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = league . determine_end_of_league ( start_date , next_rotation ) [EOL] assert dtutil . dt2ts ( end_date ) == [number] [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = league . determine_end_of_league ( start_date , next_rotation ) [EOL] assert dtutil . dt2ts ( end_date ) == [number] [EOL] next_rotation = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = league . determine_end_of_league ( start_date , next_rotation ) [EOL] assert dtutil . dt2ts ( end_date ) == dtutil . dt2ts ( next_rotation ) - [number] [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = league . determine_end_of_league ( start_date , next_rotation ) [EOL] assert end_date == dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = league . determine_end_of_league ( start_date , next_rotation ) [EOL] assert end_date == dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] [EOL] def test_determine_league_name ( ) : [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] assert league . determine_league_name ( start_date , end_date ) == [string] [EOL] start_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] end_date = dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) [EOL] assert league . determine_league_name ( start_date , end_date ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Counter , List , Any [EOL] import typing [EOL] import builtins [EOL] import magic [EOL] import collections [EOL] from collections import Counter [EOL] from typing import List , Union [EOL] [EOL] from flask import g , session , url_for [EOL] [EOL] from decksite . deck_type import DeckType [EOL] from magic import oracle , rotation [EOL] from magic . models import Card , Deck [EOL] from shared import dtutil [EOL] [EOL] [comment] [EOL] [EOL] NUM_MOST_COMMON_CARDS_TO_LIST = [number] [EOL] [EOL] def prepare_cards ( cs , tournament_only = False ) : [EOL] for c in cs : [EOL] prepare_card ( c , tournament_only ) [EOL] [EOL] def prepare_card ( c , tournament_only = False ) : [EOL] prepare_card_urls ( c , tournament_only ) [EOL] c . card_img_class = [string] if c . layout in [ [string] , [string] , [string] ] else [string] [EOL] c . pd_legal = c . legalities . get ( [string] , False ) and c . legalities [ [string] ] != [string] [EOL] c . legal_formats = { k for k , v in c . legalities . items ( ) if v != [string] } [EOL] c . non_pd_legal_formats = { k for k , v in c . legalities . items ( ) if [string] not in k and v != [string] } [EOL] c . has_legal_format = len ( c . legal_formats ) > [number] [EOL] set_legal_icons ( c ) [EOL] if c . get ( [string] ) is not None : [EOL] c . show_record = c . get ( [string] ) or c . get ( [string] ) or c . get ( [string] ) [EOL] [EOL] c . has_decks = len ( c . get ( [string] , [ ] ) ) > [number] [EOL] if not c . has_decks : [EOL] c . has_most_common_cards = False [EOL] return [EOL] [EOL] counter = Counter ( ) [comment] [EOL] for d in c . get ( [string] , [ ] ) : [EOL] for c2 in d . maindeck : [EOL] if not c2 . card . type_line . startswith ( [string] ) and not c2 [ [string] ] == c . name : [EOL] counter [ c2 [ [string] ] ] += c2 [ [string] ] [EOL] most_common_cards = counter . most_common ( NUM_MOST_COMMON_CARDS_TO_LIST ) [EOL] c . most_common_cards = [ ] [EOL] cs = oracle . cards_by_name ( ) [EOL] for v in most_common_cards : [EOL] prepare_card ( cs [ v [ [number] ] ] , tournament_only ) [EOL] c . most_common_cards . append ( cs [ v [ [number] ] ] ) [EOL] c . has_most_common_cards = len ( c . most_common_cards ) > [number] [EOL] [EOL] def prepare_card_urls ( c , tournament_only = False ) : [EOL] c . url = url_for_card ( c , tournament_only ) [EOL] c . img_url = url_for_image ( c . name ) [EOL] [EOL] def url_for_image ( name ) : [EOL] if g . get ( [string] ) is None : [EOL] g . url_cache = { } [EOL] if g . url_cache . get ( [string] ) is None : [EOL] g . url_cache [ [string] ] = url_for ( [string] , c = [string] ) [EOL] return g . url_cache [ [string] ] . replace ( [string] , name ) [EOL] [EOL] def url_for_card ( c , tournament_only = False ) : [EOL] if g . get ( [string] ) is None : [EOL] g . url_cache = { } [EOL] if g . url_cache . get ( [string] ) is None : [EOL] g . url_cache [ [string] ] = url_for ( [string] , name = [string] , deck_type = DeckType . TOURNAMENT . value if tournament_only else None ) [EOL] return g . url_cache [ [string] ] . replace ( [string] , c . name ) [EOL] [EOL] def prepare_decks ( ds ) : [EOL] for d in ds : [EOL] prepare_deck ( d ) [EOL] [EOL] def prepare_deck ( d ) : [EOL] set_stars_and_top8 ( d ) [EOL] if d . get ( [string] ) is not None : [EOL] d . colors_safe = colors_html ( d . colors , d . colored_symbols ) [EOL] if d . get ( [string] ) : [EOL] d . person_url = f' [string] { d . mtgo_username } [string] ' [EOL] else : [EOL] d . person_url = f' [string] { d . person_id } [string] ' [EOL] d . date_sort = dtutil . dt2ts ( d . active_date ) [EOL] d . display_date = dtutil . display_date ( d . active_date ) [EOL] d . show_record = d . wins or d . losses or d . draws [EOL] if d . competition_id : [EOL] d . competition_url = [string] . format ( id = d . competition_id ) [EOL] d . url = [string] . format ( id = d . id ) [EOL] d . export_url = [string] . format ( id = d . id ) [EOL] d . cmc_chart_url = [string] . format ( id = d . id ) [EOL] if d . is_in_current_run ( ) : [EOL] d . active_safe = [string] [EOL] d . stars_safe = [string] . format ( active = d . active_safe , stars = d . stars_safe ) . strip ( ) [EOL] d . source_sort = [string] [EOL] d . source_is_external = not d . source_name == [string] [EOL] d . comp_row_len = len ( [string] . format ( comp_name = d . competition_name , person = d . person ) ) [EOL] if d . get ( [string] , None ) : [EOL] d . archetype_url = [string] . format ( id = d . archetype_id ) [EOL] [comment] [EOL] [comment] [EOL] if d . get ( [string] ) is None or d . omw == [string] : [EOL] d . omw = [string] [EOL] elif [string] not in str ( d . omw ) : [EOL] d . omw = str ( int ( d . omw ) ) + [string] [EOL] d . has_legal_format = len ( d . legal_formats ) > [number] [EOL] d . pd_legal = [string] in d . legal_formats [EOL] d . non_pd_legal_formats = { f for f in d . legal_formats if [string] not in f } [EOL] set_legal_icons ( d ) [EOL] if session . get ( [string] ) or session . get ( [string] ) or not d . is_in_current_run ( ) : [EOL] d . decklist = str ( d ) [EOL] else : [EOL] d . decklist = [string] [EOL] total , num_cards = [number] , [number] [EOL] for c in d . maindeck : [EOL] if c . card . cmc is None : [EOL] c . card . cmc = [number] [EOL] if [string] not in c . card . type_line : [EOL] num_cards += c [ [string] ] [EOL] total += c [ [string] ] * c . card . cmc [EOL] d . average_cmc = round ( total / max ( [number] , num_cards ) , [number] ) [EOL] [EOL] def set_stars_and_top8 ( d ) : [EOL] if d . finish == [number] and d . competition_top_n >= [number] : [EOL] d . top8_safe = [string] [EOL] d . stars_safe = [string] [EOL] elif d . finish == [number] and d . competition_top_n >= [number] : [EOL] d . top8_safe = [string] [EOL] d . stars_safe = [string] [EOL] elif d . finish == [number] and d . competition_top_n >= [number] : [EOL] d . top8_safe = [string] [EOL] d . stars_safe = [string] [EOL] elif d . finish == [number] and d . competition_top_n >= [number] : [EOL] d . top8_safe = [string] [EOL] d . stars_safe = [string] [EOL] else : [EOL] d . top8_safe = [string] [EOL] if d . get ( [string] ) is not None and d . get ( [string] ) is not None : [EOL] if d . wins - [number] >= d . losses : [EOL] d . stars_safe = [string] [EOL] elif d . wins - [number] >= d . losses : [EOL] d . stars_safe = [string] [EOL] else : [EOL] d . stars_safe = [string] [EOL] else : [EOL] d . stars_safe = [string] [EOL] [EOL] if len ( d . stars_safe ) > [number] : [EOL] d . stars_safe = [string] . format ( stars = d . stars_safe ) [EOL] [EOL] def colors_html ( colors , colored_symbols ) : [EOL] total = len ( colored_symbols ) [EOL] if total == [number] : [EOL] return [string] [EOL] s = [string] [EOL] for color in colors : [EOL] n = colored_symbols . count ( color ) [EOL] one_pixel_in_rem = [number] [comment] [EOL] width = ( [number] - one_pixel_in_rem * len ( colors ) ) / total * n [EOL] s += [string] . format ( color = color , width = width ) [EOL] return s [EOL] [EOL] def set_legal_icons ( o ) : [EOL] o . legal_icons = [string] [EOL] sets = rotation . SEASONS [EOL] if [string] in o . legal_formats : [EOL] icon = rotation . current_season_code ( ) . lower ( ) [EOL] n = sets . index ( icon . upper ( ) ) + [number] [EOL] o . legal_icons += [string] . format ( url = [string] . format ( id = n ) , code = icon , n = n ) [EOL] past_pd_formats = [ fmt . replace ( [string] , [string] ) for fmt in o . legal_formats if [string] in fmt ] [EOL] past_pd_formats . sort ( key = lambda code : - sets . index ( code ) ) [EOL] for code in past_pd_formats : [EOL] n = sets . index ( code . upper ( ) ) + [number] [EOL] o . legal_icons += [string] . format ( url = [string] . format ( id = n ) , set = code . lower ( ) , n = n ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] from decksite . data import query [EOL] from decksite . deck_type import DeckType [EOL] [EOL] [EOL] def test_decks_where_deck_type ( ) : [EOL] args = { [string] : DeckType . LEAGUE . value } [EOL] assert [string] in query . decks_where ( args , [number] ) [EOL] args = { [string] : DeckType . TOURNAMENT . value } [EOL] assert [string] in query . decks_where ( args , [number] ) [EOL] args = { [string] : DeckType . ALL . value } [EOL] assert [string] not in query . decks_where ( args , [number] ) [EOL] assert [string] not in query . decks_where ( args , [number] ) [EOL] [EOL] def test_decks_where_archetype_id ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0
import builtins [EOL] import decksite [EOL] from decksite . data import person [EOL] from decksite . database import db [EOL] from shared import guarantee [EOL] from shared . database import sqlescape [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] STARTING_ELO = [number] [EOL] ELO_WIDTH = [number] [EOL] K_FACTOR = [number] [EOL] [EOL] def adjustment ( elo1 , elo2 ) : [EOL] e = expected ( elo1 , elo2 ) [EOL] return max ( round ( K_FACTOR * ( [number] - e ) ) , [number] ) [EOL] [EOL] def expected ( elo1 , elo2 ) : [EOL] return [number] / ( [number] + [number] ** ( ( elo2 - elo1 ) / ELO_WIDTH ) ) [EOL] [EOL] def adjust_elo ( winning_deck_id , losing_deck_id ) : [EOL] if not losing_deck_id : [EOL] return [comment] [EOL] winner = guarantee . exactly_one ( person . load_people ( [string] . format ( winning_deck_id = sqlescape ( winning_deck_id ) ) ) ) [EOL] loser = guarantee . exactly_one ( person . load_people ( [string] . format ( losing_deck_id = sqlescape ( losing_deck_id ) ) ) ) [EOL] adj = adjustment ( winner . elo or STARTING_ELO , loser . elo or STARTING_ELO ) [EOL] sql = [string] . format ( starting_elo = sqlescape ( STARTING_ELO ) ) [EOL] db ( ) . begin ( [string] ) [EOL] print ( [string] , adj , winner . id , winner . mtgo_username , winner . elo , sql ) [EOL] print ( [string] , - adj , loser . id , loser . mtgo_username , loser . elo , sql ) [EOL] db ( ) . execute ( sql , [ adj , winner . id ] ) [EOL] db ( ) . execute ( sql , [ - adj , loser . id ] ) [EOL] db ( ) . commit ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from decksite . data import elo [EOL] [EOL] [EOL] def test_elo ( ) : [EOL] assert elo . expected ( elo . STARTING_ELO , elo . STARTING_ELO ) == [number] [EOL] assert elo . expected ( [number] , [number] ) > [number] [EOL] assert elo . expected ( [number] , [number] ) < [number] [EOL] assert elo . adjustment ( elo . STARTING_ELO , elo . STARTING_ELO ) == elo . K_FACTOR / [number] [EOL] assert elo . adjustment ( [number] , [number] ) == [number] [EOL] assert elo . adjustment ( [number] , [number] ) == elo . K_FACTOR [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from enum import IntEnum [EOL] [EOL] [EOL] class Top ( IntEnum ) : [EOL] EIGHT = [number] [EOL] FOUR = [number] [EOL] TWO = [number] [EOL] NONE = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import builtins [EOL] import typing [EOL] import werkzeug [EOL] from typing import Dict [EOL] [EOL] from werkzeug . datastructures import ImmutableMultiDict [EOL] [EOL] from shared . container import Container [EOL] [EOL] [EOL] class Form ( Container ) : [EOL] def __init__ ( self , form ) : [EOL] super ( ) . __init__ ( ) [EOL] self . update ( form . to_dict ( ) ) [comment] [EOL] self . errors = { } [EOL] self . warnings = { } [EOL] [EOL] def validate ( self ) : [EOL] self . do_validation ( ) [EOL] return len ( self . errors ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $werkzeug.datastructures.ImmutableMultiDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.datastructures.ImmutableMultiDict$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Optional , Set , List , Container , Any , Type [EOL] import builtins [EOL] import magic [EOL] import typing_extensions [EOL] import shared [EOL] import typing [EOL] import hashlib [EOL] import json [EOL] import time [EOL] from typing import Dict , List , Optional , Set , Union [EOL] [EOL] from mypy_extensions import TypedDict [EOL] [EOL] from decksite import deck_name [EOL] from decksite . data import query [EOL] from decksite . data . top import Top [EOL] from decksite . database import db [EOL] from magic import legality , mana , oracle [EOL] from magic . models import CardRef , Deck [EOL] from shared import dtutil , guarantee , logger [EOL] from shared import redis_wrapper as redis [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . pd_exception import InvalidDataException [EOL] [EOL] [EOL] def latest_decks ( season_id = None , ) : [EOL] return load_decks ( where = [string] , limit = [string] , season_id = season_id ) [EOL] [EOL] def load_deck ( deck_id ) : [EOL] return guarantee . exactly_one ( load_decks ( [string] . format ( deck_id = sqlescape ( deck_id ) ) ) ) [EOL] [EOL] def load_decks_count ( where = [string] , having = [string] , season_id = None ) : [EOL] columns = [string] [EOL] sql = load_decks_query ( columns , where = where , group_by = None , having = having , order_by = [string] , limit = [string] , season_id = season_id ) [EOL] return int ( db ( ) . value ( sql ) ) [EOL] [EOL] def load_decks ( where = [string] , having = [string] , order_by = None , limit = [string] , season_id = None ) : [EOL] if not redis . enabled ( ) : [EOL] return load_decks_heavy ( where , having , order_by , limit , season_id ) [EOL] columns = [string] [EOL] group_by = [string] [EOL] sql = load_decks_query ( columns , where = where , group_by = group_by , having = having , order_by = order_by , limit = limit , season_id = season_id ) [EOL] db ( ) . execute ( [string] ) [EOL] rows = db ( ) . select ( sql ) [EOL] decks_by_id = { } [EOL] heavy = [ ] [EOL] for row in rows : [EOL] d = redis . get_container ( [string] . format ( id = row [ [string] ] ) ) [EOL] if d is None or d . name is None : [EOL] heavy . append ( row [ [string] ] ) [EOL] else : [EOL] decks_by_id [ row [ [string] ] ] = deserialize_deck ( d ) [EOL] if heavy : [EOL] where = [string] . format ( deck_ids = [string] . join ( map ( sqlescape , map ( str , heavy ) ) ) ) [EOL] loaded_decks = load_decks_heavy ( where ) [EOL] for d in loaded_decks : [EOL] decks_by_id [ d . id ] = d [EOL] decks = [ ] [EOL] for row in rows : [EOL] decks . append ( decks_by_id [ row [ [string] ] ] ) [EOL] return decks [EOL] [EOL] [comment] [EOL] def load_decks_query ( columns , where = [string] , group_by = None , having = [string] , order_by = None , limit = [string] , season_id = None , ) : [EOL] if order_by is None : [EOL] order_by = [string] [EOL] if group_by is None : [EOL] group_by = [string] [EOL] else : [EOL] group_by = f' [string] { group_by }' [EOL] sql = [string] [EOL] if [string] in where or [string] in order_by : [EOL] sql += [string] [EOL] if [string] in where or [string] in order_by : [EOL] sql += [string] [EOL] if [string] in where or [string] in order_by : [EOL] sql += [string] [EOL] sql += [string] [EOL] sql = sql . format ( columns = columns , person_query = query . person_query ( ) , competition_join = query . competition_join ( ) , season_query = query . season_query ( season_id , [string] ) , season_join = query . season_join ( ) , where = where , group_by = group_by , having = having , order_by = order_by , limit = limit ) [EOL] return sql [EOL] [EOL] def deserialize_deck ( sdeck ) : [EOL] deck = Deck ( sdeck ) [EOL] deck . active_date = dtutil . ts2dt ( deck . active_date ) [EOL] deck . created_date = dtutil . ts2dt ( deck . created_date ) [EOL] deck . updated_date = dtutil . ts2dt ( deck . updated_date ) [EOL] if deck . competition_end_date is not None : [EOL] deck . competition_end_date = dtutil . ts2dt ( deck . competition_end_date ) [EOL] deck . wins = int ( deck . wins ) [EOL] deck . losses = int ( deck . losses ) [EOL] deck . draws = int ( deck . draws ) [EOL] if deck . get ( [string] ) is not None : [EOL] deck . omw = float ( deck . omw ) [EOL] deck . maindeck = [ CardRef ( ref [ [string] ] , ref [ [string] ] ) for ref in deck . maindeck ] [EOL] deck . sideboard = [ CardRef ( ref [ [string] ] , ref [ [string] ] ) for ref in deck . sideboard ] [EOL] return deck [EOL] [EOL] def load_decks_heavy ( where = [string] , having = [string] , order_by = None , limit = [string] , season_id = None ) : [EOL] if order_by is None : [EOL] order_by = [string] [EOL] sql = [string] . format ( person_query = query . person_query ( ) , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) , where = where , season_query = query . season_query ( season_id , [string] ) , having = having , order_by = order_by , limit = limit ) [EOL] db ( ) . execute ( [string] ) [EOL] rows = db ( ) . select ( sql ) [EOL] decks = [ ] [EOL] for row in rows : [EOL] d = Deck ( row ) [EOL] d . maindeck = [ ] [EOL] d . sideboard = [ ] [EOL] d . competition_top_n = Top ( d . competition_top_n or [number] ) [EOL] d . colored_symbols = json . loads ( d . colored_symbols or [string] ) [EOL] d . colors = json . loads ( d . colors or [string] ) [EOL] d . legal_formats = set ( json . loads ( d . legal_formats or [string] ) ) [EOL] d . active_date = dtutil . ts2dt ( d . active_date ) [EOL] d . created_date = dtutil . ts2dt ( d . created_date ) [EOL] d . updated_date = dtutil . ts2dt ( d . updated_date ) [EOL] if d . competition_end_date : [EOL] d . competition_end_date = dtutil . ts2dt ( d . competition_end_date ) [EOL] d . can_draw = [string] in [ card . name for card in d . all_cards ( ) ] [EOL] d . wins = int ( d . wins ) [EOL] d . losses = int ( d . losses ) [EOL] d . draws = int ( d . draws ) [EOL] decks . append ( d ) [EOL] load_cards ( decks ) [EOL] load_competitive_stats ( decks ) [EOL] for d in decks : [EOL] expiry = [number] if d . is_in_current_run ( ) else [number] [EOL] redis . store ( [string] . format ( id = d . id ) , d , ex = expiry ) [EOL] return decks [EOL] [EOL] [comment] [EOL] [comment] [EOL] def set_colors ( d ) : [EOL] deck_colors = set ( ) [EOL] deck_colored_symbols = [ ] [EOL] for c in [ entry . card for entry in d . maindeck + d . sideboard ] : [EOL] for cost in c . get ( [string] ) or ( ) : [EOL] if c . layout == [string] : [EOL] continue [comment] [EOL] card_symbols = mana . parse ( cost ) [EOL] card_colors = mana . colors ( card_symbols ) [EOL] deck_colors . update ( card_colors [ [string] ] ) [EOL] card_colored_symbols = mana . colored_symbols ( card_symbols ) [EOL] deck_colored_symbols += card_colored_symbols [ [string] ] [EOL] d . colors = mana . order ( deck_colors ) [EOL] d . colored_symbols = deck_colored_symbols [EOL] [EOL] def set_legality ( d ) : [EOL] d . legal_formats = legality . legal_formats ( d ) [EOL] [EOL] CardsDescription = Dict [ str , Dict [ str , int ] ] [EOL] RawDeckDescription = TypedDict ( [string] , { [string] : str , [string] : str , [string] : str , [string] : str , [string] : CardsDescription , [string] : Optional [ str ] , [string] : float , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ int ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ str ] , [string] : Optional [ int ] , [string] : Optional [ int ] , [string] : int , [string] : int , [string] : int , } , total = False ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def add_deck ( params ) : [EOL] if not params . get ( [string] ) and not params . get ( [string] ) and not params . get ( [string] ) : [EOL] raise InvalidDataException ( [string] . format ( params = params ) ) [EOL] person_id = get_or_insert_person_id ( params . get ( [string] ) , params . get ( [string] ) , params . get ( [string] ) ) [EOL] deck_id = get_deck_id ( params [ [string] ] , params [ [string] ] ) [EOL] cards = params [ [string] ] [EOL] if deck_id : [EOL] db ( ) . begin ( [string] ) [EOL] db ( ) . execute ( [string] , [ get_deckhash ( cards ) , deck_id ] ) [EOL] db ( ) . execute ( [string] , [ deck_id ] ) [EOL] add_cards ( deck_id , cards ) [EOL] db ( ) . commit ( [string] ) [EOL] d = load_deck ( deck_id ) [EOL] prime_cache ( d ) [EOL] return d [EOL] created_date = params . get ( [string] ) [EOL] if not created_date : [EOL] created_date = time . time ( ) [EOL] archetype_id = get_archetype_id ( params . get ( [string] ) ) [EOL] for result in [ [string] , [string] , [string] ] : [EOL] if params . get ( [string] ) and not params . get ( result ) : [EOL] params [ result ] = [number] [comment] [EOL] sql = [string] [EOL] values = [ created_date , person_id , get_source_id ( params [ [string] ] ) , params [ [string] ] , params [ [string] ] , params [ [string] ] , params . get ( [string] ) , archetype_id , params . get ( [string] ) , params . get ( [string] ) , params . get ( [string] ) , params . get ( [string] ) , params . get ( [string] ) , params . get ( [string] ) , get_deckhash ( cards ) ] [EOL] db ( ) . begin ( [string] ) [EOL] deck_id = db ( ) . insert ( sql , values ) [EOL] add_cards ( deck_id , cards ) [EOL] d = load_deck ( deck_id ) [EOL] prime_cache ( d ) [EOL] db ( ) . commit ( [string] ) [EOL] return d [EOL] [EOL] def prime_cache ( d ) : [EOL] set_colors ( d ) [EOL] colors_s = json . dumps ( d . colors ) [EOL] colored_symbols_s = json . dumps ( d . colored_symbols ) [EOL] color_sort = mana . order_score ( d . colors ) [EOL] set_legality ( d ) [EOL] legal_formats_s = json . dumps ( list ( d . legal_formats ) ) [EOL] normalized_name = deck_name . normalize ( d ) [EOL] [comment] [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ d . id , normalized_name , colors_s , colored_symbols_s , color_sort , legal_formats_s , [number] , [number] , [number] , dtutil . dt2ts ( d . created_date ) , normalized_name , colors_s , colored_symbols_s , color_sort , legal_formats_s ] ) [EOL] [comment] [EOL] redis . clear ( f' [string] { d . id }' ) [EOL] [EOL] def add_cards ( deck_id , cards ) : [EOL] try : [EOL] db ( ) . begin ( [string] ) [EOL] for name , n in cards . get ( [string] , { } ) . items ( ) : [EOL] insert_deck_card ( deck_id , name , n , False ) [EOL] for name , n in cards . get ( [string] , { } ) . items ( ) : [EOL] insert_deck_card ( deck_id , name , n , True ) [EOL] db ( ) . commit ( [string] ) [EOL] except InvalidDataException as e : [EOL] logger . warning ( [string] , e ) [EOL] db ( ) . rollback ( [string] ) [EOL] raise [EOL] [EOL] def get_deck_id ( source_name , identifier ) : [EOL] source_id = get_source_id ( source_name ) [EOL] sql = [string] [EOL] return db ( ) . value ( sql , [ source_id , identifier ] ) [EOL] [EOL] def insert_deck_card ( deck_id , name , n , in_sideboard ) : [EOL] name = oracle . valid_name ( name ) [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ deck_id , name , n , in_sideboard ] ) [EOL] [EOL] def get_or_insert_person_id ( mtgo_username , tappedout_username , mtggoldfish_username ) : [EOL] sql = [string] [EOL] person_id = db ( ) . value ( sql , [ mtgo_username , tappedout_username , mtggoldfish_username ] ) [EOL] if person_id : [EOL] return person_id [EOL] sql = [string] [EOL] return db ( ) . insert ( sql , [ mtgo_username , tappedout_username , mtggoldfish_username ] ) [EOL] [EOL] def get_source_id ( source ) : [EOL] sql = [string] [EOL] source_id = db ( ) . value ( sql , [ source ] ) [EOL] if not source_id : [EOL] raise InvalidDataException ( [string] . format ( source = source ) ) [EOL] return source_id [EOL] [EOL] def get_archetype_id ( archetype ) : [EOL] sql = [string] [EOL] return db ( ) . value ( sql , [ archetype ] ) [EOL] [EOL] def calculate_similar_decks ( ds ) : [EOL] threshold = [number] [EOL] cards_escaped = [string] . join ( sqlescape ( name ) for name in all_card_names ( ds ) ) [EOL] if not cards_escaped : [EOL] for d in ds : [EOL] d . similar_decks = [ ] [EOL] return [EOL] potentially_similar = load_decks ( [string] . format ( cards_escaped = cards_escaped ) ) [EOL] for d in ds : [EOL] for psd in potentially_similar : [EOL] psd . similarity_score = round ( similarity_score ( d , psd ) * [number] ) [EOL] d . similar_decks = [ psd for psd in potentially_similar if psd . similarity_score >= threshold and psd . id != d . id ] [EOL] d . similar_decks . sort ( key = lambda d : - ( d . similarity_score ) ) [EOL] redis . store ( [string] . format ( id = d . id ) , d . similar_decks , ex = [number] ) [EOL] [EOL] def all_card_names ( ds ) : [EOL] basic_lands = [ [string] , [string] , [string] , [string] , [string] ] [EOL] names = set ( ) [EOL] for d in ds : [EOL] for c in d . maindeck : [EOL] if c [ [string] ] not in basic_lands and c [ [string] ] : [EOL] names . add ( c [ [string] ] ) [EOL] return names [EOL] [EOL] [comment] [EOL] def similarity_score ( a , b ) : [EOL] score = [number] [EOL] for c in a . maindeck : [EOL] if c in b . maindeck : [EOL] score += [number] [EOL] return float ( score ) / float ( max ( len ( a . maindeck ) , len ( b . maindeck ) ) ) [EOL] [EOL] def load_decks_by_cards ( names , not_names ) : [EOL] sql = [string] [EOL] if names : [EOL] sql += contains_cards_clause ( names ) [EOL] if names and not_names : [EOL] sql += [string] [EOL] if not_names : [EOL] sql += contains_cards_clause ( not_names , True ) [EOL] return load_decks ( sql ) [EOL] [EOL] def contains_cards_clause ( names , negate = False ) : [EOL] negation = [string] if negate else [string] [EOL] operator = [string] if negate else [string] [EOL] n = [number] if negate else len ( names ) [EOL] return [string] . format ( negation = negation , names = [string] . join ( map ( sqlescape , names ) ) , operator = operator , n = n ) [EOL] [EOL] def load_cards ( decks ) : [EOL] if len ( decks ) == [number] : [EOL] return [EOL] decks_by_id = { d . id : d for d in decks } [EOL] sql = [string] . format ( deck_ids = [string] . join ( map ( sqlescape , map ( str , decks_by_id . keys ( ) ) ) ) ) [EOL] rs = db ( ) . select ( sql ) [EOL] for row in rs : [EOL] location = [string] if row [ [string] ] else [string] [EOL] name = row [ [string] ] [EOL] d = decks_by_id [ row [ [string] ] ] [EOL] d [ location ] = d . get ( location , [ ] ) [EOL] d [ location ] . append ( CardRef ( name , row [ [string] ] ) ) [EOL] [EOL] def load_conflicted_decks ( ) : [EOL] where = [string] [EOL] return load_decks ( where , order_by = [string] ) [EOL] [EOL] def load_queue_similarity ( decks ) : [EOL] sql = [string] [EOL] sim = { } [EOL] for row in ( Container ( r ) for r in db ( ) . select ( sql ) ) : [EOL] sim [ row . id ] = row . similarity [EOL] for deck in decks : [EOL] deck . similarity = [string] . format ( sim [ deck . id ] ) if sim [ deck . id ] is not None else [string] [EOL] [EOL] [comment] [EOL] def load_competitive_stats ( decks ) : [EOL] decks_by_id = { d . id : d for d in decks if d . get ( [string] ) is None } [EOL] if len ( decks_by_id ) == [number] : [EOL] return [EOL] if len ( decks_by_id ) < [number] : [EOL] where = [string] . format ( deck_ids = [string] . join ( map ( sqlescape , map ( str , decks_by_id . keys ( ) ) ) ) ) [EOL] else : [EOL] where = [string] [comment] [EOL] sql = [string] . format ( where = where ) [EOL] rs = db ( ) . select ( sql ) [EOL] for row in rs : [EOL] if decks_by_id . get ( row [ [string] ] ) : [EOL] decks_by_id [ row [ [string] ] ] . omw = row [ [string] ] [EOL] [EOL] def preaggregate ( ) : [EOL] preaggregate_omw ( ) [EOL] [EOL] def preaggregate_omw ( ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql ) [EOL] [EOL] def count_matches ( deck_id , opponent_deck_id ) : [EOL] sql = [string] [EOL] result = { int ( deck_id ) : [number] , int ( opponent_deck_id ) : [number] } [EOL] for row in db ( ) . select ( sql , [ deck_id , opponent_deck_id ] ) : [EOL] result [ row [ [string] ] ] = row [ [string] ] [EOL] return result [EOL] [EOL] def nwdl_join ( ) : [EOL] return [string] [EOL] [EOL] def num_decks ( deck_query = [string] ) : [EOL] sql = f' [string] { deck_query }' [EOL] return db ( ) . value ( sql ) [EOL] [EOL] [EOL] def get_deckhash ( cards ) : [EOL] return hashlib . sha1 ( repr ( cards ) . encode ( [string] ) ) . hexdigest ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from decksite . data import card [EOL] from shared import perf [EOL] [EOL] [EOL] @ pytest . mark . perf def test_load_cards_season ( ) : [EOL] perf . test ( lambda : card . load_cards ( season_id = [number] ) , [number] ) [EOL] [EOL] @ pytest . mark . perf def test_load_cards_all ( ) : [EOL] perf . test ( card . load_cards , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , Any , List [EOL] import builtins [EOL] import magic [EOL] import shared [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . data import deck [EOL] from decksite . database import db [EOL] from magic import fetcher [EOL] from magic . models import Deck [EOL] from shared import dtutil [EOL] from shared import redis_wrapper as redis [EOL] from shared import repo [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] [EOL] [EOL] def all_news ( start_date = None , end_date = None , max_items = sys . maxsize ) : [EOL] if start_date is None : [EOL] start_date = dtutil . ts2dt ( [number] ) [EOL] if end_date is None : [EOL] end_date = dtutil . now ( ) [EOL] news = [ ] [EOL] news += load_news ( start_date , end_date , max_items ) [EOL] news += tournament_winners ( start_date , end_date , max_items ) [EOL] news += perfect_league_runs ( start_date , end_date , max_items ) [EOL] news += code_merges ( start_date , end_date , max_items ) [EOL] news += subreddit ( start_date , end_date , max_items ) [EOL] news = sorted ( news , key = lambda item : item . date , reverse = True ) [EOL] results = [ ] [EOL] for item in news : [EOL] if item . date > end_date : [EOL] continue [EOL] if item . date < start_date : [EOL] break [EOL] item . display_date = dtutil . display_date ( item . date ) [EOL] results . append ( item ) [EOL] if len ( results ) >= max_items : [EOL] break [EOL] return results [EOL] [EOL] def load_news ( start_date = None , end_date = None , max_items = sys . maxsize ) : [EOL] if start_date is None : [EOL] start_date = dtutil . ts2dt ( [number] ) [EOL] if end_date is None : [EOL] end_date = dtutil . now ( ) [EOL] sql = [string] [EOL] results = [ Container ( r ) for r in db ( ) . select ( sql , [ dtutil . dt2ts ( start_date ) , dtutil . dt2ts ( end_date ) , max_items ] ) ] [EOL] for result in results : [EOL] result . date = dtutil . ts2dt ( result . date ) [EOL] result . form_date = dtutil . form_date ( result . date , dtutil . WOTC_TZ ) [EOL] result . display_date = dtutil . display_date ( result . date ) [EOL] result . type = [string] [EOL] return results [EOL] [EOL] def add_or_update_news ( news_item_id , date , title , url ) : [EOL] ts = dtutil . dt2ts ( date ) [EOL] if news_item_id is not None : [EOL] update_news ( news_item_id , ts , title , url ) [EOL] return [EOL] add_news ( ts , title , url ) [EOL] [EOL] def update_news ( news_item_id , ts , title , url ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ ts , title , url , news_item_id ] ) [EOL] [EOL] def add_news ( ts , title , url ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ ts , title , url ] ) [EOL] [EOL] def delete ( news_item_id ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ news_item_id ] ) [EOL] [EOL] def tournament_winners ( start_date , end_date , max_items = sys . maxsize ) : [EOL] where = [string] . format ( start_date = sqlescape ( dtutil . dt2ts ( start_date ) ) , end_date = sqlescape ( dtutil . dt2ts ( end_date ) ) ) [EOL] ds = deck . load_decks ( where , limit = f' [string] { max_items }' ) [EOL] return [ Container ( { [string] : d . active_date , [string] : tournament_winner_headline ( d ) , [string] : url_for ( [string] , deck_id = d . id ) , [string] : [string] } ) for d in ds ] [EOL] [EOL] def tournament_winner_headline ( d ) : [EOL] return f'{ d . person } [string] { d . competition_name } [string] { d . name }' [EOL] [EOL] def perfect_league_runs ( start_date , end_date , max_items = sys . maxsize ) : [EOL] where = [string] . format ( start_date = sqlescape ( dtutil . dt2ts ( start_date ) ) , end_date = sqlescape ( dtutil . dt2ts ( end_date ) ) ) [EOL] having = [string] [EOL] ds = deck . load_decks ( where , having = having , limit = f' [string] { max_items }' ) [EOL] return [ Container ( { [string] : d . active_date , [string] : perfect_league_run_headline ( d ) , [string] : url_for ( [string] , deck_id = d . id ) , [string] : [string] } ) for d in ds ] [EOL] [EOL] def perfect_league_run_headline ( d ) : [EOL] return f'{ d . person } [string] { d . competition_name } [string] { d . name }' [EOL] [EOL] def code_merges ( start_date , end_date , max_items = sys . maxsize ) : [EOL] try : [EOL] merges = redis . get_container_list ( [string] ) [EOL] if merges is None : [EOL] merges = [ Container ( { [string] : dtutil . UTC_TZ . localize ( pull . merged_at ) , [string] : pull . title , [string] : pull . html_url , [string] : [string] } ) for pull in repo . get_pull_requests ( start_date , end_date , max_items ) if not [string] in [ l . name for l in pull . as_issue ( ) . labels ] ] [EOL] redis . store ( [string] , merges , ex = [number] ) [EOL] else : [EOL] for merge in merges : [EOL] merge . date = dtutil . ts2dt ( merge . date ) [EOL] return merges [EOL] except ConnectionError : [EOL] return [ ] [EOL] [EOL] def subreddit ( start_date , end_date , max_items = sys . maxsize ) : [EOL] try : [EOL] redis_key = [string] [EOL] items = redis . get_container_list ( redis_key ) [EOL] if items : [EOL] for item in items : [EOL] item . date = dtutil . ts2dt ( item . date ) [EOL] return items [EOL] feed = fetcher . subreddit ( ) [EOL] items = [ ] [EOL] for entry in feed . entries : [EOL] item = Container ( { [string] : entry . title , [string] : dtutil . parse ( entry . updated , [string] , dtutil . UTC_TZ ) , [string] : entry . link , [string] : [string] } ) [EOL] if item . date > end_date : [EOL] continue [EOL] if item . date < start_date : [EOL] break [EOL] items . append ( item ) [EOL] if len ( items ) >= max_items : [EOL] break [EOL] redis . store ( redis_key , items , ex = [number] ) [EOL] return items [EOL] except ConnectionError : [EOL] return [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Optional , List , Container , Any [EOL] import builtins [EOL] import typing_extensions [EOL] import shared [EOL] import typing [EOL] import decksite [EOL] import sys [EOL] from typing import Dict , List , Optional , Union [EOL] [EOL] import titlecase [EOL] from anytree import NodeMixin [EOL] from anytree . iterators import PreOrderIter [EOL] [EOL] from decksite . data import deck , preaggregation , query [EOL] from decksite . database import db [EOL] from shared import guarantee [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . decorators import retry_after_calling [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] [EOL] class Archetype ( Container , NodeMixin ) : [EOL] pass [EOL] [EOL] BASE_ARCHETYPES = { } [EOL] [EOL] [comment] [EOL] def load_archetype ( archetype , season_id = None , tournament_only = False ) : [EOL] try : [EOL] archetype_id = int ( archetype ) [EOL] except ValueError : [EOL] name = titlecase . titlecase ( archetype ) [EOL] name_without_dashes = name . replace ( [string] , [string] ) [EOL] archetype_id = db ( ) . value ( [string] , [ name_without_dashes ] ) [EOL] if not archetype_id : [EOL] raise DoesNotExistException ( [string] . format ( name = name ) ) [EOL] where = query . archetype_where ( archetype_id ) [EOL] if tournament_only : [EOL] where = [string] . format ( where = where , tournament_only_clause = query . tournament_only_clause ( ) ) [EOL] archetypes = load_archetypes ( where = where , merge = True , season_id = season_id ) [EOL] arch = guarantee . exactly_one ( archetypes , [string] ) if archetypes else Archetype ( ) [EOL] [comment] [EOL] arch . id = int ( archetype_id ) [EOL] arch . name = db ( ) . value ( [string] , [ archetype_id ] ) [EOL] if len ( archetypes ) == [number] : [EOL] arch . decks = [ ] [EOL] return arch [EOL] [EOL] def load_archetypes ( where = [string] , merge = False , season_id = None ) : [EOL] decks = deck . load_decks ( where , season_id = season_id ) [EOL] archetypes = { } [EOL] for d in decks : [EOL] if d . archetype_id is None : [EOL] continue [EOL] key = [string] if merge else d . archetype_id [EOL] archetype = archetypes . get ( key , Archetype ( ) ) [EOL] archetype . id = d . archetype_id [EOL] archetype . name = d . archetype_name [EOL] [EOL] archetype . decks = archetype . get ( [string] , [ ] ) + [ d ] [EOL] archetype . wins = archetype . get ( [string] , [number] ) + ( d . get ( [string] ) or [number] ) [EOL] archetype . losses = archetype . get ( [string] , [number] ) + ( d . get ( [string] ) or [number] ) [EOL] archetype . draws = archetype . get ( [string] , [number] ) + ( d . get ( [string] ) or [number] ) [EOL] [EOL] if d . get ( [string] ) == [number] : [EOL] archetype . tournament_wins = archetype . get ( [string] , [number] ) + [number] [EOL] if ( d . get ( [string] ) or sys . maxsize ) <= [number] : [EOL] archetype . top8s = archetype . get ( [string] , [number] ) + [number] [EOL] archetype . perfect_runs = archetype . get ( [string] , [number] ) + [number] [EOL] archetypes [ key ] = archetype [EOL] archetype_list = list ( archetypes . values ( ) ) [EOL] return archetype_list [EOL] [EOL] def load_archetypes_deckless_for ( archetype_id , season_id = None , tournament_only = False ) : [EOL] archetypes = load_archetypes_deckless ( season_id = season_id , tournament_only = tournament_only ) [EOL] for a in archetypes : [EOL] if int ( a . id ) == int ( archetype_id ) : [EOL] return list ( a . ancestors ) + [ a ] + list ( a . descendants ) [EOL] return list ( ) [EOL] [EOL] def add ( name , parent ) : [EOL] archetype_id = db ( ) . insert ( [string] , [ name ] ) [EOL] ancestors = db ( ) . select ( [string] , [ parent ] ) [EOL] sql = [string] [EOL] for a in ancestors : [EOL] sql += [string] . format ( ancestor = sqlescape ( a [ [string] ] ) , descendant = archetype_id , depth = int ( a [ [string] ] ) + [number] ) [EOL] sql += [string] . format ( ancestor = archetype_id , descendant = archetype_id , depth = [number] ) [EOL] db ( ) . execute ( sql ) [EOL] [EOL] def assign ( deck_id , archetype_id , person_id , reviewed = True , similarity = None ) : [EOL] db ( ) . begin ( [string] ) [EOL] db ( ) . execute ( [string] , [ deck_id , archetype_id , person_id ] ) [EOL] and_clause = [string] if reviewed else [string] [EOL] db ( ) . execute ( f' [string] { and_clause }' , [ reviewed , archetype_id , deck_id ] ) [EOL] if not reviewed and similarity is not None : [EOL] db ( ) . execute ( [string] , [ similarity , deck_id ] ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def move ( archetype_id , parent_id ) : [EOL] db ( ) . begin ( [string] ) [EOL] remove_sql = [string] [EOL] db ( ) . execute ( remove_sql , [ archetype_id ] ) [EOL] add_sql = [string] [EOL] db ( ) . execute ( add_sql , [ archetype_id , parent_id ] ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def rename ( archetype_id , new_name ) : [EOL] db ( ) . execute ( [string] , [ new_name , archetype_id ] ) [EOL] [EOL] def update_description ( archetype_id , description ) : [EOL] db ( ) . execute ( [string] , [ description , archetype_id ] ) [EOL] [EOL] def base_archetypes ( ) : [EOL] return [ a for a in base_archetype_by_id ( ) . values ( ) if a . parent is None ] [EOL] [EOL] def base_archetype_by_id ( ) : [EOL] if len ( BASE_ARCHETYPES ) == [number] : [EOL] rebuild_archetypes ( ) [EOL] return BASE_ARCHETYPES [EOL] [EOL] def rebuild_archetypes ( ) : [EOL] archetypes_by_id = { a . id : a for a in load_archetypes_deckless ( ) } [EOL] for k , v in archetypes_by_id . items ( ) : [EOL] p = v [EOL] while p . parent is not None : [EOL] p = p . parent [EOL] BASE_ARCHETYPES [ k ] = p [EOL] [EOL] def preaggregate ( ) : [EOL] preaggregate_archetypes ( ) [EOL] preaggregate_archetype_person ( ) [EOL] preaggregate_matchups ( ) [EOL] preaggregate_matchups_person ( ) [EOL] [EOL] def preaggregate_archetypes ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) , nwdl_join = deck . nwdl_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_archetype_person ( ) : [EOL] [comment] [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) , nwdl_join = deck . nwdl_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_matchups ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_matchups_person ( ) : [EOL] [comment] [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] @ retry_after_calling ( preaggregate ) def load_matchups ( where = [string] , archetype_id = None , person_id = None , season_id = None , tournament_only = False ) : [EOL] if person_id : [EOL] table = [string] [EOL] where = f' [string] { where } [string] { person_id } [string] ' [EOL] else : [EOL] table = [string] [EOL] if archetype_id : [EOL] where = f' [string] { where } [string] { archetype_id } [string] ' [EOL] if tournament_only : [EOL] where = f" [string] { where } [string] " [EOL] sql = [string] . format ( table = table , where = where , season_query = query . season_query ( season_id ) ) [EOL] return [ Container ( m ) for m in db ( ) . select ( sql ) ] [EOL] [EOL] @ retry_after_calling ( preaggregate ) def load_archetypes_deckless ( order_by = None , person_id = None , season_id = None , tournament_only = False ) : [EOL] if person_id : [EOL] table = [string] [EOL] where = [string] . format ( person_id = sqlescape ( person_id ) ) [EOL] group_by = [string] [EOL] else : [EOL] table = [string] [EOL] where = [string] [EOL] group_by = [string] [EOL] if tournament_only : [EOL] where = f" [string] { where } [string] " [EOL] sql = [string] . format ( table = table , where = where , group_by = group_by , season_query = query . season_query ( season_id ) , order_by = order_by or [string] ) [EOL] archetypes = [ Archetype ( a ) for a in db ( ) . select ( sql ) ] [EOL] archetypes_by_id = { a . id : a for a in archetypes } [EOL] for a in archetypes : [EOL] a . decks = [ ] [EOL] a . decks_tournament = [ ] [EOL] a . parent = archetypes_by_id . get ( a . parent_id , None ) [EOL] if order_by is None : [EOL] archetypes = preorder ( archetypes ) [EOL] return archetypes [EOL] [EOL] def preorder ( archetypes ) : [EOL] archs = [ ] [EOL] roots = [ a for a in archetypes if a . is_root ] [EOL] for r in roots : [EOL] for a in PreOrderIter ( r ) : [EOL] archs . append ( a ) [EOL] return archs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Archetype]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Archetype]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union , List [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import datetime [EOL] from typing import Dict , Union [EOL] [EOL] from decksite . data import preaggregation , query [EOL] from decksite . database import db [EOL] from shared import dtutil [EOL] from shared . database import sqlescape [EOL] from shared . decorators import retry_after_calling [EOL] [EOL] [EOL] def preaggregate ( ) : [EOL] preaggregate_season_stats ( ) [EOL] [EOL] [comment] [EOL] def preaggregate_season_stats ( ) : [EOL] sql = [string] . format ( competition_join = query . competition_join ( ) , season_join = query . season_join ( ) ) [EOL] rs = db ( ) . select ( sql ) [EOL] stats = { r [ [string] ] : r for r in rs } [EOL] sql = [string] . format ( season_join = query . season_join ( ) ) [EOL] rs = db ( ) . select ( sql ) [EOL] for r in rs : [EOL] stats . get ( r [ [string] ] , { } ) . update ( r ) [EOL] sql = [string] . format ( season_join = query . season_join ( ) ) [EOL] rs = db ( ) . select ( sql ) [EOL] for r in rs : [EOL] stats . get ( r [ [string] ] , { } ) . update ( r ) [EOL] table = [string] [EOL] columns = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] values = [ ] [EOL] for season in stats . values ( ) : [EOL] values . append ( [string] + [string] . join ( str ( sqlescape ( season [ k ] ) ) for k in columns ) + [string] ) [EOL] sql = [string] . format ( table = table , values = [string] . join ( values ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] @ retry_after_calling ( preaggregate_season_stats ) def season_stats ( ) : [EOL] sql = [string] [EOL] stats = { r [ [string] ] : r for r in db ( ) . select ( sql ) } [EOL] for season in stats . values ( ) : [EOL] season [ [string] ] = dtutil . ts2dt ( season [ [string] ] ) [EOL] season [ [string] ] = dtutil . ts2dt ( season [ [string] ] ) if season [ [string] ] else None [EOL] return stats [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,datetime.datetime]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Iterator , Tuple , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import magic [EOL] from typing import Dict , List , Tuple [EOL] [EOL] from decksite . data import deck , preaggregation [EOL] from decksite . database import db [EOL] from magic . models import Deck [EOL] from shared import logger [EOL] from shared . container import Container [EOL] from shared . decorators import retry_after_calling [EOL] [EOL] IGNORE = [ [string] , [string] ] [EOL] [EOL] def excluded_archetype_names ( ) : [EOL] return IGNORE [EOL] [EOL] def excluded_archetype_ids ( ) : [EOL] if len ( IGNORE ) == [number] : [EOL] return [ ] [EOL] sql = [string] . format ( n = [string] . join ( IGNORE ) ) [EOL] return db ( ) . values ( sql ) [EOL] [EOL] def excluded_archetype_info ( ) : [EOL] if len ( IGNORE ) == [number] : [EOL] return [ ] [EOL] sql = [string] . format ( n = [string] . join ( IGNORE ) ) [EOL] return [ Container ( row ) for row in db ( ) . select ( sql ) ] [EOL] [EOL] def apply_rules_to_decks ( decks ) : [EOL] if len ( decks ) == [number] : [EOL] return [EOL] decks_by_id = { } [EOL] for d in decks : [EOL] decks_by_id [ d . id ] = d [EOL] id_list = [string] . join ( str ( d . id ) for d in decks ) [EOL] sql = [string] . format ( apply_rules_query = apply_rules_query ( f' [string] { id_list } [string] ' ) ) [EOL] for r in ( Container ( row ) for row in db ( ) . select ( sql ) ) : [EOL] decks_by_id [ r . deck_id ] . rule_archetype_id = r . archetype_id [EOL] decks_by_id [ r . deck_id ] . rule_archetype_name = r . archetype_name [EOL] [EOL] def cache_all_rules ( ) : [EOL] table = [string] [EOL] logger . warning ( f' [string] { table }' ) [EOL] sql = [string] . format ( table = table , apply_rules_query = apply_rules_query ( deck_query = classified_decks_query ( ) ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] logger . warning ( f' [string] { table }' ) [EOL] [EOL] @ retry_after_calling ( cache_all_rules ) def num_classified_decks ( ) : [EOL] sql = [string] [EOL] return db ( ) . value ( sql ) [EOL] [EOL] @ retry_after_calling ( cache_all_rules ) def mistagged_decks ( ) : [EOL] sql = [string] [EOL] rule_archetypes = { } [EOL] for r in ( Container ( row ) for row in db ( ) . select ( sql ) ) : [EOL] rule_archetypes [ r . deck_id ] = ( r . rule_archetype_id , r . rule_archetype_name ) [EOL] if not rule_archetypes : [EOL] return [ ] [EOL] ids_list = [string] . join ( str ( deck_id ) for deck_id in rule_archetypes ) [EOL] result = deck . load_decks ( where = f' [string] { ids_list } [string] ' ) [EOL] for d in result : [EOL] d . rule_archetype_id , d . rule_archetype_name = rule_archetypes [ d . id ] [EOL] return result [EOL] [EOL] @ retry_after_calling ( cache_all_rules ) def doubled_decks ( ) : [EOL] sql = [string] [EOL] archetypes_from_rules = { } [EOL] for r in [ Container ( row ) for row in db ( ) . select ( sql ) ] : [EOL] matching_archetypes = zip ( r . archetype_ids . split ( [string] ) , r . archetype_names . split ( [string] ) ) [EOL] archetypes_from_rules [ r . deck_id ] = [ Container ( { [string] : archetype_id , [string] : archetype_name } ) for archetype_id , archetype_name in matching_archetypes ] [EOL] if not archetypes_from_rules : [EOL] return [ ] [EOL] ids_list = [string] . join ( str ( deck_id ) for deck_id in archetypes_from_rules ) [EOL] result = deck . load_decks ( where = f' [string] { ids_list } [string] ' ) [EOL] for d in result : [EOL] d . archetypes_from_rules = archetypes_from_rules [ d . id ] [EOL] d . archetypes_from_rules_names = [string] . join ( a . archetype_name for a in archetypes_from_rules [ d . id ] ) [EOL] return result [EOL] [EOL] @ retry_after_calling ( cache_all_rules ) def overlooked_decks ( ) : [EOL] sql = [string] [EOL] deck_ids = [ str ( row [ [string] ] ) for row in db ( ) . select ( sql ) ] [EOL] if not deck_ids : [EOL] return [ ] [EOL] ids_list = [string] . join ( deck_ids ) [EOL] return deck . load_decks ( where = f' [string] { ids_list } [string] ' ) [EOL] [EOL] @ retry_after_calling ( cache_all_rules ) def load_all_rules ( ) : [EOL] result = [ ] [EOL] result_by_id = { } [EOL] sql = [string] [EOL] for r in ( Container ( row ) for row in db ( ) . select ( sql ) ) : [EOL] result . append ( r ) [EOL] result_by_id [ r . id ] = r [EOL] r . included_cards = [ ] [EOL] r . excluded_cards = [ ] [EOL] sql = [string] [EOL] for r in ( Container ( row ) for row in db ( ) . select ( sql ) ) : [EOL] if r . include : [EOL] result_by_id [ r . rule_id ] . included_cards . append ( { [string] : r . n , [string] : r . card } ) [EOL] else : [EOL] result_by_id [ r . rule_id ] . excluded_cards . append ( { [string] : r . n , [string] : r . card } ) [EOL] return result [EOL] [EOL] def add_rule ( archetype_id ) : [EOL] sql = [string] [EOL] db ( ) . insert ( sql , [ archetype_id ] ) [EOL] [EOL] [comment] [EOL] def update_cards ( rule_id , inc , exc ) : [EOL] db ( ) . begin ( [string] ) [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ rule_id ] ) [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ rule_id ] ) [EOL] for n , card in inc : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ rule_id , card , n ] ) [EOL] for n , card in exc : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ rule_id , card , n ] ) [EOL] sql = [string] . format ( arq = apply_rules_query ( rule_query = f' [string] { rule_id }' ) ) [EOL] db ( ) . execute ( sql ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def classified_decks_query ( ) : [EOL] return [string] . format ( ex = [string] . join ( str ( aid ) for aid in excluded_archetype_ids ( ) ) ) [EOL] [EOL] def apply_rules_query ( deck_query = [string] , rule_query = [string] ) : [EOL] return f""" [string] { rule_query } [string] { deck_query } [string] { rule_query } [string] """ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , List , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , Optional , Union , cast [EOL] [EOL] from decksite . deck_type import DeckType [EOL] from shared . database import sqlescape [EOL] from shared . pd_exception import InvalidArgumentException [EOL] [EOL] [EOL] def person_query ( table = [string] ) : [EOL] return [string] . format ( table = table ) [EOL] [EOL] def competition_ids_by_type_select ( competition_type ) : [EOL] return [string] . format ( competition_type_id = competition_type_id_select ( competition_type ) ) [EOL] [EOL] def competition_type_id_select ( competition_type ) : [EOL] return [string] . format ( competition_type = competition_type ) [EOL] [EOL] def competition_join ( ) : [EOL] return [string] [EOL] [EOL] def season_query ( season_id , column_name = [string] ) : [EOL] if season_id is None or season_id == [string] or season_id == [number] : [EOL] return [string] [EOL] try : [EOL] return [string] . format ( column_name = column_name , season_id = int ( season_id ) ) [EOL] except ValueError : [EOL] raise InvalidArgumentException ( [string] . format ( season_id = season_id ) ) [EOL] [EOL] def season_join ( ) : [EOL] return [string] [EOL] [EOL] def decks_order_by ( sort_by , sort_order , competition_id ) : [EOL] if not sort_by and competition_id : [EOL] sort_by = [string] [EOL] sort_order = [string] [EOL] elif not sort_by : [EOL] sort_by = [string] [EOL] sort_order = [string] [EOL] else : [EOL] sort_by = str ( sort_by ) [EOL] sort_order = str ( sort_order ) [EOL] assert sort_order in [ [string] , [string] ] [comment] [EOL] marginalia_order_by = [string] [EOL] sort_options = { [string] : marginalia_order_by , [string] : [string] , [string] : [string] , [string] : person_query ( ) , [string] : [string] , [string] : [string] , [string] : f' [string] { sort_order } [string] ' , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return sort_options [ sort_by ] + f' [string] { sort_order } [string] ' [EOL] [EOL] def cards_order_by ( sort_by , sort_order ) : [EOL] if not sort_by : [EOL] sort_by = [string] [EOL] sort_order = [string] [EOL] else : [EOL] sort_by = str ( sort_by ) [EOL] sort_order = str ( sort_order ) [EOL] assert sort_order in [ [string] , [string] ] [comment] [EOL] sort_options = { [string] : [string] , [string] : [string] , [string] : f' [string] { sort_order } [string] ' , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return sort_options [ sort_by ] + f' [string] { sort_order } [string] ' [EOL] [EOL] def exclude_active_league_runs ( except_person_id ) : [EOL] clause = [string] [EOL] if except_person_id : [EOL] clause += f' [string] { except_person_id }' [EOL] return clause [EOL] [EOL] def decks_where ( args , viewer_id ) : [EOL] parts = [ ] [EOL] parts . append ( exclude_active_league_runs ( viewer_id ) ) [EOL] if args . get ( [string] ) == DeckType . LEAGUE . value : [EOL] parts . append ( [string] ) [EOL] elif args . get ( [string] ) == DeckType . TOURNAMENT . value : [EOL] parts . append ( [string] ) [EOL] if args . get ( [string] ) : [EOL] archetype_id = cast ( int , args . get ( [string] ) ) [EOL] parts . append ( archetype_where ( archetype_id ) ) [EOL] if args . get ( [string] ) : [EOL] person_id = cast ( int , args . get ( [string] ) ) [EOL] parts . append ( f' [string] { person_id }' ) [EOL] if args . get ( [string] ) : [EOL] parts . append ( card_where ( cast ( str , args . get ( [string] ) ) ) ) [EOL] if args . get ( [string] ) : [EOL] competition_id = cast ( int , args . get ( [string] ) ) [EOL] parts . append ( f' [string] { competition_id }' ) [comment] [EOL] return [string] . join ( parts ) [EOL] [EOL] def card_name_where ( q ) : [EOL] return [string] + [string] . join ( c . replace ( [string] , [string] ) . replace ( [string] , [string] ) for c in list ( q ) ) + [string] [EOL] [EOL] def archetype_where ( archetype_id ) : [EOL] return f' [string] { archetype_id } [string] ' [EOL] [EOL] def card_where ( name ) : [EOL] return [string] . format ( name = sqlescape ( name ) ) [EOL] [EOL] def tournament_only_clause ( ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Dict , Optional , Sequence , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import Dict , List , Optional , Sequence [EOL] [EOL] from decksite . data import achievements , deck , preaggregation , query [EOL] from decksite . data . models . person import Person [EOL] from decksite . database import db [EOL] from shared import dtutil , guarantee , logger [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . decorators import retry_after_calling [EOL] from shared . pd_exception import AlreadyExistsException , DoesNotExistException [EOL] [EOL] [EOL] def load_person_by_id ( person_id , season_id = None ) : [EOL] return load_person ( f' [string] { person_id }' , season_id = season_id ) [EOL] [EOL] def load_person_by_mtgo_username ( username , season_id = None ) : [EOL] return load_person ( [string] . format ( username = sqlescape ( username , force_string = True ) ) , season_id = season_id ) [EOL] [EOL] def load_person_by_discord_id ( discord_id , season_id = None ) : [EOL] return load_person ( f' [string] { discord_id }' , season_id = season_id ) [EOL] [EOL] [comment] [EOL] def load_person_by_discord_id_or_username ( person , season_id = [number] ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] MIN_DISCORD_ID = [number] [EOL] MAX_DISCORD_ID = [number] [EOL] if person . isdigit ( ) and int ( person ) >= MIN_DISCORD_ID and int ( person ) <= MAX_DISCORD_ID : [EOL] return load_person_by_discord_id ( int ( person ) , season_id = season_id ) [EOL] return load_person_by_mtgo_username ( person , season_id = season_id ) [EOL] [EOL] [comment] [EOL] def maybe_load_person_by_discord_id ( discord_id ) : [EOL] if discord_id is None : [EOL] return None [EOL] return guarantee . at_most_one ( load_people ( f' [string] { discord_id }' ) ) [EOL] [EOL] [comment] [EOL] def maybe_load_person_by_tappedout_name ( username ) : [EOL] return guarantee . at_most_one ( load_people ( [string] . format ( username = sqlescape ( username ) ) ) ) [EOL] [EOL] [comment] [EOL] def maybe_load_person_by_mtggoldfish_name ( username ) : [EOL] return guarantee . at_most_one ( load_people ( [string] . format ( username = sqlescape ( username ) ) ) ) [EOL] [EOL] def load_person ( where , season_id = None ) : [EOL] person = guarantee . exactly_one ( load_people ( where , season_id = season_id ) ) [EOL] set_achievements ( [ person ] , season_id ) [EOL] set_head_to_head ( [ person ] , season_id ) [EOL] return person [EOL] [EOL] def load_people ( where = [string] , order_by_name = False , season_id = None ) : [EOL] [comment] [EOL] [comment] [EOL] sql = [string] . format ( person_query = query . person_query ( ) , where = where ) [EOL] people = [ Person ( r ) for r in db ( ) . select ( sql ) ] [EOL] stats = load_people_stats ( where , season_id ) [EOL] for p in people : [EOL] p . update ( stats . get ( p . id , { } ) ) [EOL] p . season_id = season_id [EOL] if order_by_name : [EOL] people . sort ( key = lambda p : p . get ( [string] ) or [string] ) [EOL] else : [EOL] people . sort ( key = lambda p : ( - p . get ( [string] , [number] ) , [number] ) ) [comment] [EOL] return people [EOL] [EOL] def load_people_stats ( where , season_id = None ) : [EOL] season_join = query . season_join ( ) if season_id else [string] [EOL] sql = [string] . format ( season_join = season_join , where = where , season_query = query . season_query ( season_id , [string] ) ) [EOL] return { r [ [string] ] : r for r in db ( ) . select ( sql ) } [EOL] [EOL] def preaggregate ( ) : [EOL] achievements . preaggregate_achievements ( ) [EOL] preaggregate_head_to_head ( ) [EOL] [EOL] def preaggregate_head_to_head ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , season_join = query . season_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] @ retry_after_calling ( achievements . preaggregate_achievements ) def set_achievements ( people , season_id = None ) : [EOL] people_by_id = { person . id : person for person in people } [EOL] sql = achievements . load_query ( people_by_id , season_id ) [EOL] results = [ Container ( r ) for r in db ( ) . select ( sql ) ] [EOL] for result in results : [EOL] people_by_id [ result [ [string] ] ] . num_achievements = len ( [ k for k , v in result . items ( ) if k != [string] and v > [number] ] ) [EOL] people_by_id [ result [ [string] ] ] . achievements = result [EOL] people_by_id [ result [ [string] ] ] . achievements . pop ( [string] ) [EOL] [EOL] @ retry_after_calling ( preaggregate_head_to_head ) def set_head_to_head ( people , season_id = None ) : [EOL] people_by_id = { person . id : person for person in people } [EOL] sql = [string] . format ( ids = [string] . join ( str ( k ) for k in people_by_id . keys ( ) ) , season_query = query . season_query ( season_id ) ) [EOL] results = [ Container ( r ) for r in db ( ) . select ( sql ) ] [EOL] for result in results : [EOL] people_by_id [ result . id ] . head_to_head = people_by_id [ result . id ] . get ( [string] , [ ] ) + [ result ] [EOL] for person in people : [EOL] if person . get ( [string] ) is None : [EOL] person . head_to_head = [ ] [EOL] [EOL] def associate ( d , discord_id ) : [EOL] person_id = db ( ) . value ( [string] , [ d . id ] , fail_on_missing = True ) [EOL] sql = [string] [EOL] return db ( ) . execute ( sql , [ discord_id , person_id ] ) [EOL] [EOL] def is_allowed_to_retire ( deck_id , discord_id ) : [EOL] if not deck_id : [EOL] return False [EOL] if not discord_id : [EOL] return True [EOL] person = maybe_load_person_by_discord_id ( discord_id ) [EOL] if person is None : [EOL] return True [EOL] return any ( int ( deck_id ) == deck . id for deck in person . decks ) [EOL] [EOL] def get_or_insert_person_id ( mtgo_username , tappedout_username , mtggoldfish_username ) : [EOL] sql = [string] [EOL] person_id = db ( ) . value ( sql , [ mtgo_username , tappedout_username , mtggoldfish_username ] ) [EOL] if person_id : [EOL] return person_id [EOL] sql = [string] [EOL] return db ( ) . insert ( sql , [ mtgo_username , tappedout_username , mtggoldfish_username ] ) [EOL] [EOL] def load_aliases ( ) : [EOL] sql = [string] [EOL] return [ Container ( r ) for r in db ( ) . select ( sql ) ] [EOL] [EOL] def add_alias ( person_id , alias ) : [EOL] db ( ) . begin ( [string] ) [EOL] try : [EOL] p = load_person_by_mtgo_username ( alias ) [EOL] db ( ) . execute ( [string] , [ person_id , p . id ] ) [EOL] db ( ) . execute ( [string] , [ p . id ] ) [EOL] except DoesNotExistException : [EOL] pass [EOL] db ( ) . execute ( [string] , [ person_id , alias ] ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def load_notes ( person_id = None ) : [EOL] where = f' [string] { person_id }' if person_id else [string] [EOL] sql = [string] . format ( creator_query = query . person_query ( [string] ) , subject_query = query . person_query ( [string] ) , where = where ) [EOL] notes = [ Container ( r ) for r in db ( ) . select ( sql ) ] [EOL] for n in notes : [EOL] n . created_date = dtutil . ts2dt ( n . created_date ) [EOL] n . display_date = dtutil . display_date ( n . created_date ) [EOL] return notes [EOL] [EOL] def add_note ( creator_id , subject_id , note ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ creator_id , subject_id , note ] ) [EOL] [EOL] def link_discord ( mtgo_username , discord_id ) : [EOL] person_id = deck . get_or_insert_person_id ( mtgo_username , None , None ) [EOL] p = load_person_by_id ( person_id ) [EOL] if p . discord_id is not None : [EOL] raise AlreadyExistsException ( [string] . format ( mtgo_username = mtgo_username , old_discord_id = p . discord_id , new_discord_id = discord_id ) ) [EOL] sql = [string] [EOL] db ( ) . execute ( sql , [ discord_id , p . id ] ) [EOL] return p [EOL] [EOL] def unlink_discord ( person_id ) : [EOL] sql = [string] [EOL] return db ( ) . execute ( sql , [ person_id ] ) [EOL] [EOL] def remove_discord_link ( discord_id ) : [EOL] sql = [string] [EOL] return db ( ) . execute ( sql , [ discord_id ] ) [EOL] [EOL] def is_banned ( mtgo_username ) : [EOL] return db ( ) . value ( [string] , [ mtgo_username ] ) == [number] [EOL] [EOL] def squash ( p1id , p2id , col1 , col2 ) : [EOL] logger . warning ( [string] . format ( p1id = p1id , p2id = p2id , col1 = col1 , col2 = col2 ) ) [EOL] db ( ) . begin ( [string] ) [EOL] new_value = db ( ) . value ( [string] . format ( col2 = col2 ) , [ p2id ] ) [EOL] db ( ) . execute ( [string] , [ p1id , p2id ] ) [EOL] db ( ) . execute ( [string] , [ p2id ] ) [EOL] db ( ) . execute ( [string] . format ( col2 = col2 ) , [ new_value , p1id ] ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def set_locale ( person_id , locale ) : [EOL] db ( ) . execute ( [string] , [ locale , person_id ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Union , Literal , List , Any [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List , Union [EOL] [EOL] from decksite . data import deck , match , query [EOL] from decksite . database import db [EOL] from shared import guarantee [EOL] [EOL] [EOL] def matchup ( hero , enemy , season_id = None ) : [EOL] where = [string] [EOL] prefix = None [EOL] args = [ ] [EOL] if season_id : [EOL] where += [string] [EOL] args . append ( season_id ) [EOL] for criteria in [ hero , enemy ] : [EOL] prefix = [string] if prefix is None else [string] [EOL] if criteria . get ( [string] ) : [EOL] where += f' [string] { prefix } [string] ' [EOL] args . append ( criteria [ [string] ] ) [EOL] if criteria . get ( [string] ) : [EOL] where += f' [string] { prefix } [string] ' [EOL] args . append ( criteria [ [string] ] ) [EOL] if criteria . get ( [string] ) : [EOL] where += f' [string] { prefix } [string] ' [EOL] args . append ( criteria [ [string] ] ) [EOL] season_join = query . season_join ( ) [EOL] sql = f""" [string] { season_join } [string] { where } [string] """ [EOL] results = guarantee . exactly_one ( db ( ) . select ( sql , args ) ) [EOL] results [ [string] ] = results [ [string] ] . split ( [string] ) if results [ [string] ] else [ ] [EOL] results [ [string] ] = deck . load_decks ( [string] + [string] . join ( results [ [string] ] ) + [string] ) if results [ [string] ] else [ ] [EOL] results [ [string] ] = results [ [string] ] . split ( [string] ) if results [ [string] ] else [ ] [EOL] results [ [string] ] = results [ [string] ] . split ( [string] ) if results [ [string] ] else [ ] [EOL] results [ [string] ] = match . load_matches ( [string] + [string] . join ( results [ [string] ] ) + [string] ) if results [ [string] ] else [ ] [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int,typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import magic [EOL] import sys [EOL] from typing import Dict , List , Optional [EOL] [EOL] from decksite . data import deck , preaggregation , query [EOL] from decksite . database import db [EOL] from magic import oracle [EOL] from magic . models import Card [EOL] from shared import guarantee [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . decorators import retry_after_calling [EOL] [EOL] [EOL] def load_card ( name , season_id = None ) : [EOL] c = guarantee . exactly_one ( oracle . load_cards ( [ name ] ) ) [EOL] c . decks = deck . load_decks ( query . card_where ( name ) , season_id = season_id ) [EOL] c . wins , c . losses , c . draws , c . tournament_wins , c . tournament_top8s , c . perfect_runs = [number] , [number] , [number] , [number] , [number] , [number] [EOL] for d in c . decks : [EOL] c . wins += d . get ( [string] , [number] ) [EOL] c . losses += d . get ( [string] , [number] ) [EOL] c . draws += d . get ( [string] , [number] ) [EOL] c . tournament_wins += [number] if d . get ( [string] ) == [number] else [number] [EOL] c . tournament_top8s += [number] if ( d . get ( [string] ) or sys . maxsize ) <= [number] else [number] [EOL] c . perfect_runs += [number] if d . get ( [string] ) == [string] and d . get ( [string] , [number] ) >= [number] and d . get ( [string] , [number] ) == [number] else [number] [EOL] if c . wins or c . losses : [EOL] c . win_percent = round ( ( c . wins / ( c . wins + c . losses ) ) * [number] , [number] ) [EOL] else : [EOL] c . win_percent = [string] [EOL] c . num_decks = len ( c . decks ) [EOL] c . played_competitively = c . wins or c . losses or c . draws [EOL] return c [EOL] [EOL] def preaggregate ( ) : [EOL] preaggregate_card ( ) [EOL] preaggregate_card_person ( ) [EOL] preaggregate_playability ( ) [EOL] preaggregate_unique ( ) [EOL] preaggregate_trailblazer ( ) [EOL] [EOL] def preaggregate_card ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) , nwdl_join = deck . nwdl_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_card_person ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) , season_join = query . season_join ( ) , nwdl_join = deck . nwdl_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_playability ( ) : [EOL] sql = [string] [EOL] rs = db ( ) . select ( sql ) [EOL] high = max ( [ r [ [string] ] for r in rs ] + [ [number] ] ) [EOL] table = [string] [EOL] sql = f""" [string] { table } [string] { high } [string] """ . format ( table = table , high = high ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_unique ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] def preaggregate_trailblazer ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , competition_join = query . competition_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] @ retry_after_calling ( preaggregate ) def load_cards_count ( additional_where = [string] , person_id = None , season_id = None ) : [EOL] if person_id : [EOL] table = [string] [EOL] where = [string] . format ( person_id = sqlescape ( person_id ) ) [EOL] else : [EOL] table = [string] [EOL] where = [string] [EOL] season_query = query . season_query ( season_id ) [EOL] sql = f' [string] { table } [string] { where } [string] { additional_where } [string] { season_query } [string] ' [EOL] return int ( db ( ) . value ( sql ) ) [EOL] [EOL] [comment] [EOL] @ retry_after_calling ( preaggregate ) def load_cards ( additional_where = [string] , order_by = [string] , limit = [string] , person_id = None , season_id = None , tournament_only = False ) : [EOL] if person_id : [EOL] table = [string] [EOL] where = [string] . format ( person_id = sqlescape ( person_id ) ) [EOL] group_by = [string] [EOL] else : [EOL] table = [string] [EOL] where = [string] [EOL] group_by = [string] [EOL] if tournament_only : [EOL] where = f" [string] { where } [string] " [EOL] sql = [string] . format ( table = table , season_query = query . season_query ( season_id ) , where = where , additional_where = additional_where , group_by = group_by , order_by = order_by , limit = limit ) [EOL] cs = [ Container ( r ) for r in db ( ) . select ( sql ) ] [EOL] cards = oracle . cards_by_name ( ) [EOL] for c in cs : [EOL] c . update ( cards [ c . name ] ) [EOL] return cs [EOL] [EOL] @ retry_after_calling ( preaggregate_playability ) def playability ( ) : [EOL] sql = [string] [EOL] return { r [ [string] ] : r [ [string] ] for r in db ( ) . select ( sql ) } [EOL] [EOL] @ retry_after_calling ( preaggregate_unique ) def unique_cards_played ( person_id ) : [EOL] sql = [string] [EOL] return db ( ) . values ( sql , [ person_id ] ) [EOL] [EOL] @ retry_after_calling ( preaggregate_trailblazer ) def trailblazer_cards ( person_id ) : [EOL] sql = [string] [EOL] return db ( ) . values ( sql , [ person_id ] ) [EOL] [EOL] def card_exists ( name ) : [EOL] sql = [string] [EOL] return bool ( db ( ) . value ( sql , [ name ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from decksite . database import db [EOL] from shared import logger [EOL] from shared . pd_exception import DatabaseException [EOL] [EOL] [EOL] def preaggregate ( table , sql ) : [EOL] lock_key = f' [string] { table }' [EOL] try : [EOL] db ( ) . get_lock ( lock_key , [number] * [number] ) [EOL] except DatabaseException as e : [EOL] logger . warning ( f' [string] { table } [string] { e }' ) [EOL] db ( ) . execute ( f' [string] { table }' ) [EOL] db ( ) . execute ( sql ) [EOL] db ( ) . execute ( f' [string] { table }' ) [EOL] db ( ) . execute ( f' [string] { table } [string] ' ) [comment] [EOL] db ( ) . execute ( f' [string] { table } [string] { table } [string] { table } [string] { table }' ) [EOL] db ( ) . execute ( f' [string] { table }' ) [EOL] db ( ) . release_lock ( lock_key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List [EOL] import typing [EOL] import decksite [EOL] from typing import List [EOL] [EOL] from decksite . data import deck [EOL] from shared . container import Container [EOL] [EOL] [EOL] class Person ( Container ) : [EOL] __decks = None [EOL] @ property def decks ( self ) : [EOL] if self . __decks is None : [EOL] self . __decks = deck . load_decks ( f' [string] { self . id }' , season_id = self . season_id ) [EOL] return self . __decks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.deck.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] import os . path [EOL] import pathlib [EOL] from typing import Dict [EOL] [EOL] import matplotlib as mpl [EOL] [comment] [EOL] [comment] [EOL] mpl . use ( [string] ) [EOL] import matplotlib . pyplot as plt [EOL] import seaborn as sns [EOL] [EOL] from decksite . data import deck [EOL] from shared import configuration , logger [EOL] from shared . pd_exception import DoesNotExistException , OperationalException [EOL] [EOL] def cmc ( deck_id , attempts = [number] ) : [EOL] if attempts > [number] : [EOL] msg = [string] . format ( id = deck_id ) [EOL] logger . error ( msg ) [EOL] raise OperationalException ( msg ) [EOL] path = determine_path ( str ( deck_id ) + [string] ) [EOL] if acceptable_file ( path ) : [EOL] return path [EOL] d = deck . load_deck ( deck_id ) [EOL] costs = { } [EOL] for ci in d . maindeck : [EOL] c = ci . card [EOL] if c . is_land ( ) : [EOL] continue [EOL] if c . mana_cost is None : [EOL] cost = [string] [EOL] elif next ( ( s for s in c . mana_cost if [string] in s ) , None ) is not None : [EOL] cost = [string] [EOL] else : [EOL] converted = int ( float ( c . cmc ) ) [EOL] cost = [string] if converted >= [number] else str ( converted ) [EOL] costs [ cost ] = ci . get ( [string] ) + costs . get ( cost , [number] ) [EOL] path = image ( path , costs ) [EOL] if acceptable_file ( path ) : [EOL] return path [EOL] return cmc ( deck_id , attempts + [number] ) [EOL] [EOL] def image ( path , costs ) : [EOL] ys = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] xs = [ costs . get ( k , [number] ) for k in ys ] [EOL] sns . set_style ( [string] ) [EOL] sns . set ( font = [string] , font_scale = [number] ) [EOL] g = sns . barplot ( ys , xs , palette = [ [string] ] * len ( ys ) ) [EOL] g . axes . yaxis . set_ticklabels ( [ ] ) [EOL] rects = g . patches [EOL] sns . set ( font = [string] , font_scale = [number] ) [EOL] for rect , label in zip ( rects , xs ) : [EOL] if label == [number] : [EOL] continue [EOL] height = rect . get_height ( ) [EOL] g . text ( rect . get_x ( ) + rect . get_width ( ) / [number] , height + [number] , label , ha = [string] , va = [string] ) [EOL] g . margins ( y = [number] , x = [number] ) [EOL] sns . despine ( left = True , bottom = True ) [EOL] g . get_figure ( ) . savefig ( path , transparent = True , pad_inches = [number] , bbox_inches = [string] ) [EOL] plt . clf ( ) [comment] [EOL] return path [EOL] [EOL] def determine_path ( name ) : [EOL] charts_dir = configuration . get_str ( [string] ) [EOL] pathlib . Path ( charts_dir ) . mkdir ( parents = True , exist_ok = True ) [EOL] if not os . path . exists ( charts_dir ) : [EOL] raise DoesNotExistException ( [string] . format ( charts_dir = charts_dir ) ) [EOL] return os . path . join ( charts_dir , name ) [EOL] [EOL] def acceptable_file ( path ) : [EOL] if not os . path . exists ( path ) : [EOL] return False [EOL] if os . path . getsize ( path ) >= [number] : [comment] [EOL] return True [EOL] logger . warning ( [string] . format ( path = path ) ) [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Optional , List , Container , Any [EOL] import builtins [EOL] import magic [EOL] import shared [EOL] import typing [EOL] import decksite [EOL] import json [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import titlecase [EOL] from flask import url_for [EOL] [EOL] from decksite . data import person as ps [EOL] from decksite . data . achievements import Achievement [EOL] from decksite . data . archetype import Archetype [EOL] from decksite . view import View [EOL] from magic . models import Card [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Person ( View ) : [EOL] def __init__ ( self , person , cards , archetypes , all_archetypes , matchups , your_cards , season_id ) : [EOL] super ( ) . __init__ ( ) [EOL] min_matches_for_matchups_grid = [number] [EOL] self . all_archetypes = all_archetypes [EOL] self . person = person [EOL] self . people = [ person ] [EOL] self . decks = person . decks [EOL] self . archetypes = archetypes [EOL] self . hide_person = True [EOL] self . cards = cards [EOL] for record in person . head_to_head : [EOL] record . show_record = True [EOL] record . opp_url = url_for ( [string] , mtgo_username = record . opp_mtgo_username ) [EOL] self . show_head_to_head = len ( person . head_to_head ) > [number] [EOL] self . show_seasons = True [EOL] self . displayed_achievements = [ { [string] : a . title , [string] : titlecase . titlecase ( a . display ( self . person ) ) } for a in Achievement . all_achievements if a . display ( self . person ) ] [EOL] self . achievements_url = url_for ( [string] ) [EOL] self . person_achievements_url = url_for ( [string] , person_id = person . id ) [EOL] colors = { } [EOL] for d in self . decks : [EOL] for c in d . colors : [EOL] colors [ c ] = colors . get ( c , [number] ) + [number] [EOL] self . charts = [ { [string] : [string] , [string] : [string] , [string] : json . dumps ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , [string] : json . dumps ( [ colors . get ( [string] ) , colors . get ( [string] ) , colors . get ( [string] ) , colors . get ( [string] ) , colors . get ( [string] ) , colors . get ( [string] ) ] ) , [string] : json . dumps ( { [string] : True , [string] : { [string] : [ { [string] : { [string] : [number] } } ] } } ) } ] [EOL] self . add_note_url = url_for ( [string] ) [EOL] self . matches_url = url_for ( [string] , person_id = person . id , season_id = season_id ) [EOL] self . is_person_page = True [EOL] self . trailblazer_cards = your_cards [ [string] ] [EOL] self . has_trailblazer_cards = len ( self . trailblazer_cards ) > [number] [EOL] self . unique_cards = your_cards [ [string] ] [EOL] self . has_unique_cards = len ( self . unique_cards ) > [number] [EOL] self . setup_matchups ( self . all_archetypes , matchups , min_matches_for_matchups_grid ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . person , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return self . person . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.models.person.Person$ 0 $typing.List[magic.models.card.Card]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[shared.container.Container]$ 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 $decksite.data.models.person.Person$ 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[magic.models.card.Card]$ 0 $typing.List[magic.models.card.Card]$ 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[shared.container.Container]$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Any , Dict [EOL] [EOL] from decksite . data . competition import Competition as Comp [EOL] from decksite . view import View [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Competition ( View ) : [EOL] def __init__ ( self , competition ) : [EOL] super ( ) . __init__ ( ) [EOL] self . competition = competition [EOL] self . competitions = [ self . competition ] [EOL] self . decks = competition . decks [EOL] self . hide_source = True [EOL] if competition . type == [string] : [EOL] self . show_omw = True [EOL] self . hide_top8 = True [EOL] leaderboard = { } [EOL] for d in competition . decks : [EOL] if d . banned : [EOL] continue [EOL] bonus = [number] [EOL] if d . wins >= [number] : [EOL] bonus = [number] [EOL] points = d . wins + bonus [EOL] if d . person_id not in leaderboard : [EOL] leaderboard [ d . person_id ] = Container ( { [string] : d . person , [string] : d . person_id , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] leaderboard [ d . person_id ] [ [string] ] += points [EOL] leaderboard [ d . person_id ] [ [string] ] += d . wins + d . draws + d . losses [EOL] leaderboard [ d . person_id ] [ [string] ] += [number] if d . retired else [number] [EOL] if len ( leaderboard ) > [number] : [EOL] self . has_leaderboard = True [EOL] self . leaderboard = sorted ( leaderboard . values ( ) , key = lambda k : ( k [ [string] ] , k [ [string] ] , - k [ [string] ] ) , reverse = True ) [EOL] [EOL] for p in self . leaderboard : [EOL] p . score = ( p . points , p . played , p . retirements ) [EOL] self . leaderboards = [ self . leaderboard ] [comment] [EOL] self . date = dtutil . display_date ( competition . start_date ) [EOL] self . sponsor_name = competition . sponsor_name [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . competition , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return self . competition . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Set [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . view import View [EOL] from magic import tournaments [EOL] from magic . models import Deck [EOL] from shared import dtutil [EOL] [EOL] [EOL] [comment] [EOL] class PD500 ( View ) : [EOL] def __init__ ( self , tournament_winning_decks ) : [EOL] super ( ) . __init__ ( ) [EOL] people = set ( d . person for d in tournament_winning_decks ) [EOL] self . people_with_byes = [ { [string] : person , [string] : url_for ( [string] , mtgo_username = person ) } for person in people ] [EOL] self . people_with_byes = sorted ( self . people_with_byes , key = lambda k : k [ [string] ] ) [EOL] self . next_pd500_date = dtutil . display_date_with_date_and_year ( tournaments . next_pd500_date ( ) ) [EOL] self . faqs_url = url_for ( [string] ) [EOL] self . cardhoarder_loan_url = [string] [EOL] self . tournaments_url = url_for ( [string] ) [EOL] self . discord_url = url_for ( [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Union , Literal [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class Decks ( View ) : [EOL] def __init__ ( self , league_only = False ) : [EOL] super ( ) . __init__ ( ) [EOL] self . show_seasons = True [EOL] self . league_only = self . hide_top8 = self . show_omw = self . hide_source = league_only [EOL] [EOL] def page_title ( self ) : [EOL] deck_type = [string] if self . league_only else [string] [EOL] return [string] . format ( season_name = self . season_name ( ) , deck_type = deck_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Container , Any , List [EOL] import builtins [EOL] import shared [EOL] import datetime [EOL] import typing [EOL] import decksite [EOL] import datetime [EOL] from typing import Any , Dict , List [EOL] [EOL] from dateutil . relativedelta import FR , relativedelta [EOL] [EOL] from decksite . data . competition import Competition [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] from magic import tournaments [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Prizes ( View ) : [EOL] def __init__ ( self , competitions , first_runs ) : [EOL] super ( ) . __init__ ( ) [EOL] self . weeks = [ ] [EOL] weeks = split_by_week ( competitions ) [EOL] for week in weeks : [EOL] prizes = { } [EOL] if week . end_date > dtutil . now ( dtutil . WOTC_TZ ) : [EOL] pass [EOL] for c in week . get ( [string] , [ ] ) : [EOL] for d in c . decks : [EOL] prizes [ d . person ] = prizes . get ( d . person , [number] ) + tournaments . prize ( d ) [EOL] subject = [string] . format ( date = week . end_date ) [EOL] body = [string] . join ( [ c . name for c in week . get ( [string] , [ ] ) ] ) + [string] [EOL] body += [string] . join ( [ [string] . format ( username = k , prize = prizes [ k ] ) for k in sorted ( prizes ) if prizes [ k ] > [number] ] ) [EOL] self . weeks . append ( Container ( { [string] : subject , [string] : body , [string] : len ( week . get ( [string] , [ ] ) ) } ) ) [EOL] self . months = [ ] [EOL] current_competition_id = None [EOL] for p in first_runs : [EOL] if current_competition_id != p . competition_id : [EOL] self . months . append ( { [string] : p . competition_name , [string] : [ ] } ) [EOL] current_competition_id = p . competition_id [EOL] self . months [ - [number] ] [ [string] ] . append ( p ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL] [EOL] def split_by_week ( competitions ) : [EOL] dt = ( dtutil . now ( dtutil . WOTC_TZ ) + relativedelta ( weekday = FR ( - [number] ) ) ) . replace ( hour = [number] , minute = [number] , second = [number] ) [EOL] weeks = [ ] [EOL] while True : [EOL] week = Container ( ) [EOL] week . start_date = dt [EOL] week . end_date = dt + datetime . timedelta ( weeks = [number] ) - datetime . timedelta ( seconds = [number] ) [EOL] week . competitions = [ ] [EOL] while len ( competitions ) > [number] and competitions [ [number] ] . start_date > dt : [EOL] week . competitions = week . competitions + [ competitions . pop ( [number] ) ] [EOL] weeks . append ( week ) [EOL] dt = dt - datetime . timedelta ( weeks = [number] ) [EOL] if len ( competitions ) == [number] : [EOL] break [EOL] return weeks [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import decksite [EOL] from decksite import league [EOL] from decksite . data . form import Form [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class LeagueForm ( View ) : [EOL] def __init__ ( self , form ) : [EOL] super ( ) . __init__ ( ) [EOL] self . form = form [EOL] self . league = league . active_league ( ) [EOL] self . competitions = [ self . league ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import magic [EOL] from typing import Any [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . deck_type import DeckType [EOL] from decksite . view import View [EOL] from magic . models import Card as CardContainer [EOL] [EOL] [EOL] [comment] [EOL] class Card ( View ) : [EOL] def __init__ ( self , card , tournament_only = False ) : [EOL] super ( ) . __init__ ( ) [EOL] self . decks = card . decks [EOL] self . legal_formats = ( [ x for x , y in card . legalities . items ( ) if y == [string] ] + [ x + [string] for x , y in card . legalities . items ( ) if y == [string] ] ) [EOL] self . show_seasons = True [EOL] self . show_archetype = True [EOL] self . show_tournament_toggle = True [EOL] self . tournament_only = self . hide_source = tournament_only [EOL] self . public = True [comment] [EOL] self . toggle_results_url = url_for ( [string] , name = card . name , deck_type = None if tournament_only else DeckType . TOURNAMENT . value ) [EOL] self . card = card [EOL] self . cards = [ self . card ] [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . card , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return self . card . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Container , Any , List [EOL] import builtins [EOL] import magic [EOL] import shared [EOL] import datetime [EOL] import typing [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . view import View [EOL] from magic . models import Deck [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class EditMatches ( View ) : [EOL] def __init__ ( self , decks , matches ) : [EOL] super ( ) . __init__ ( ) [EOL] self . matches = matches [EOL] self . hide_active_runs = False [EOL] far_future = dtutil . parse ( [string] , [string] , dtutil . UTC_TZ ) [EOL] self . decks = sorted ( decks , key = lambda d : d . person + str ( far_future - d . created_date ) ) [EOL] decks_by_id = { d . id : d for d in decks } [EOL] for m in self . matches : [EOL] m . display_date = dtutil . display_date ( m . date ) [EOL] m . left_deck = decks_by_id . get ( int ( m . left_id ) ) [EOL] m . right_deck = decks_by_id . get ( int ( m . right_id ) ) [EOL] m . left_url = url_for ( [string] , deck_id = m . left_id ) [EOL] if m . get ( [string] ) : [EOL] m . right_url = url_for ( [string] , deck_id = m . right_id ) [EOL] else : [EOL] m . right_url = None [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , Any , Iterable [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import Iterable [EOL] [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class PlayerNotes ( View ) : [EOL] def __init__ ( self , notes , people ) : [EOL] super ( ) . __init__ ( ) [EOL] for n in notes : [EOL] n . date_sort = dtutil . dt2ts ( n . created_date ) [EOL] n . display_date = dtutil . display_date ( n . created_date ) [EOL] self . notes = notes [EOL] self . people = people [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[shared.container.Container]$ 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[shared.container.Container]$ 0 $typing.Iterable[shared.container.Container]$ 0 0 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from decksite . view import View [EOL] [EOL] [EOL] class AddForm ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . error = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] import decksite [EOL] from decksite . league import Status [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class EditLeague ( View ) : [EOL] def __init__ ( self , status ) : [EOL] super ( ) . __init__ ( ) [EOL] is_open = status == Status . OPEN [EOL] self . status = [string] if is_open else [string] [EOL] self . action_display = [string] if is_open else [string] [EOL] self . action = self . action_display . lower ( ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import List [EOL] [EOL] from decksite . data import person as ps [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class PersonAchievements ( View ) : [EOL] def __init__ ( self , person , achievements ) : [EOL] super ( ) . __init__ ( ) [EOL] self . person = person [EOL] self . achievements = achievements [EOL] self . show_seasons = True [EOL] self . decks = [ ] [EOL] for a in achievements : [EOL] if a . detail is not None : [EOL] a . detail . hide_active_runs = True [EOL] self . prepare_active_runs ( a . detail ) [EOL] self . decks += a . detail . decks [EOL] if len ( [ a for a in achievements if a . legend ] ) == [number] : [EOL] self . no_achievements = True [EOL] [EOL] def page_title ( self ) : [EOL] return f'{ self . person . name } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.models.person.Person$ 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 $decksite.data.models.person.Person$ 0 0 0 $typing.List[shared.container.Container]$ 0 $typing.List[shared.container.Container]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import decksite [EOL] from flask import url_for [EOL] [EOL] from decksite . data import match [EOL] from decksite . data . form import Form [EOL] from decksite . views . league_form import LeagueForm [EOL] [EOL] [EOL] [comment] [EOL] class Retire ( LeagueForm ) : [EOL] def __init__ ( self , form ) : [EOL] super ( ) . __init__ ( form ) [EOL] self . logout_url = url_for ( [string] , target = [string] ) [EOL] if len ( form . decks ) == [number] : [EOL] self . show_matches = True [EOL] self . matches = match . load_matches_by_deck ( form . decks [ [number] ] , should_load_decks = True ) [EOL] self . has_matches = len ( self . matches ) > [number] [EOL] self . report_url = url_for ( [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Container , Any , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import Any , List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . data import archetype as archs [EOL] from decksite . deck_type import DeckType [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] [EOL] [comment] [EOL] class Archetype ( View ) : [EOL] [comment] [EOL] def __init__ ( self , archetype , archetypes , matchups , season_id , tournament_only = False ) : [EOL] super ( ) . __init__ ( ) [EOL] if not archetype : [EOL] raise DoesNotExistException ( [string] ) [EOL] self . archetype = next ( a for a in archetypes if a . id == archetype . id ) if archetypes else archetype [EOL] self . archetype . decks = archetype . decks [EOL] [comment] [EOL] self . archetypes = archetypes [EOL] self . tournament_only = self . hide_source = tournament_only [EOL] matchup_archetypes = archs . load_archetypes_deckless ( season_id = season_id ) [EOL] matchups_by_id = { m . id : m for m in matchups } [EOL] for m in matchup_archetypes : [EOL] [comment] [EOL] m . update ( matchups_by_id . get ( m . id , { [string] : True } ) ) [EOL] [comment] [EOL] for m in matchup_archetypes : [EOL] self . prepare_archetype ( m , matchup_archetypes ) [EOL] [comment] [EOL] self . matchups_container = [ { [string] : True , [string] : matchup_archetypes , } ] [EOL] self . show_seasons = True [EOL] self . show_tournament_toggle = True [EOL] self . toggle_results_url = url_for ( [string] , archetype_id = self . archetype . id , deck_type = None if tournament_only else DeckType . TOURNAMENT . value ) [EOL] self . show_archetype = any ( d . archetype_id != self . archetype . id for d in self . decks ) [EOL] self . show_archetype_tree = len ( self . archetypes ) > [number] [EOL] [EOL] def og_title ( self ) : [EOL] return self . archetype . name [EOL] [EOL] def og_url ( self ) : [EOL] return url_for ( [string] , archetype_id = self . archetype . id , _external = True ) [EOL] [EOL] def og_description ( self ) : [EOL] return [string] . format ( name = self . archetype . name ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . archetype , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return self . archetype . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Sequence [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Sequence [EOL] [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class People ( View ) : [EOL] def __init__ ( self , people ) : [EOL] super ( ) . __init__ ( ) [EOL] self . people = people [EOL] self . show_seasons = True [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Sequence[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[decksite.data.models.person.Person]$ 0 $typing.Sequence[decksite.data.models.person.Person]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import magic [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite import prepare [EOL] from decksite . data import archetype , deck , rule [EOL] from decksite . data . archetype import Archetype [EOL] from decksite . view import View [EOL] from magic . models import Deck [EOL] [EOL] [EOL] [comment] [EOL] class EditArchetypes ( View ) : [EOL] def __init__ ( self , archetypes , search_results , q , notq ) : [EOL] super ( ) . __init__ ( ) [EOL] self . archetypes = archetypes [EOL] self . archetypes_preordered = archetype . preorder ( archetypes ) [EOL] self . queue = deck . load_decks ( where = [string] , order_by = [string] ) [EOL] deck . load_queue_similarity ( self . queue ) [EOL] rule . apply_rules_to_decks ( self . queue ) [EOL] for d in self . queue : [EOL] prepare . prepare_deck ( d ) [EOL] d . archetype_url = url_for ( [string] , archetype_id = d . archetype_name ) [EOL] if d . get ( [string] ) : [EOL] d . rule_archetype_url = url_for ( [string] , archetype_id = d . rule_archetype_name ) [EOL] d . archetypes = [ ] [EOL] for a in self . archetypes : [EOL] if a . id == d . rule_archetype_id : [EOL] d . archetypes . append ( { [string] : a . id , [string] : a . name , [string] : True } ) [EOL] else : [EOL] d . archetypes . append ( a ) [EOL] self . has_search_results = len ( search_results ) > [number] [EOL] self . search_results = search_results [EOL] for d in self . search_results : [EOL] prepare . prepare_deck ( d ) [EOL] self . query = q [EOL] self . notquery = notq [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[magic.models.deck.Deck]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.deck.Deck]$ 0 0 0 0 0 0 $typing.List[magic.models.deck.Deck]$ 0 $typing.List[magic.models.deck.Deck]$ 0 0 0 0 0 0 $typing.List[magic.models.deck.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask import url_for [EOL] from flask_babel import gettext [EOL] [EOL] from decksite . data . form import Form [EOL] from decksite . views . league_form import LeagueForm [EOL] [EOL] [EOL] [comment] [EOL] class Report ( LeagueForm ) : [EOL] def __init__ ( self , form , person_id = None ) : [EOL] super ( ) . __init__ ( form ) [EOL] self . retire_url = url_for ( [string] ) [EOL] self . person_id = person_id [EOL] self . logout_url = url_for ( [string] , target = [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] . format ( league = self . league [ [string] ] ) [EOL] [EOL] def TT_REPORT ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_YOUR_DECK ( self ) : [EOL] return gettext ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import builtins [EOL] import typing [EOL] from typing import Dict , List [EOL] [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class Admin ( View ) : [EOL] def __init__ ( self , admin_menu ) : [EOL] super ( ) . __init__ ( ) [EOL] self . admin_menu = admin_menu [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
import builtins [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class Faqs ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . hide_intro = True [comment] [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Iterable , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Iterable , List [EOL] [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class Unlink ( View ) : [EOL] def __init__ ( self , people , num_affected_people = None , errors = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . people = people [EOL] if num_affected_people is not None : [EOL] self . message = f'{ num_affected_people } [string] ' [EOL] self . errors = errors or [ ] [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 $typing.Iterable[decksite.data.models.person.Person]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . deck_type import DeckType [EOL] from decksite . view import View [EOL] from magic . models import Card [EOL] [EOL] [EOL] [comment] [EOL] class Cards ( View ) : [EOL] def __init__ ( self , cards , tournament_only = False , query = [string] ) : [EOL] super ( ) . __init__ ( ) [EOL] self . show_seasons = True [EOL] self . show_tournament_toggle = True [EOL] self . tournament_only = self . hide_source = tournament_only [EOL] self . query = query [EOL] self . toggle_results_url = url_for ( [string] , deck_type = None if tournament_only else DeckType . TOURNAMENT . value ) [EOL] self . cards = cards [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[magic.models.card.Card]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.card.Card]$ 0 $typing.List[magic.models.card.Card]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] from typing import List [EOL] [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class EditNews ( View ) : [EOL] def __init__ ( self , news ) : [EOL] super ( ) . __init__ ( ) [EOL] self . news = news [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 $typing.List[shared.container.Container]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import Any , cast [EOL] [EOL] from flask import request [EOL] from flask_babel import gettext [EOL] [EOL] from decksite import auth [EOL] from decksite . data import person [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] from shared . pd_exception import AlreadyExistsException [EOL] [EOL] [EOL] [comment] [EOL] class LinkAccounts ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . mtgo_name = auth . mtgo_username ( ) [EOL] self . person = person . maybe_load_person_by_discord_id ( auth . discord_id ( ) ) [EOL] self . form = Container ( ) [EOL] for k in request . form . keys ( ) : [comment] [EOL] self . form [ k ] = request . form [ k ] . strip ( ) [EOL] self . form . errors = Container ( ) [EOL] if self . person and self . person . mtgo_username : [EOL] if self . form . get ( [string] , None ) is None and self . person . tappedout_username is not None : [EOL] self . form [ [string] ] = self . person . tappedout_username [EOL] self . disable_to = True [EOL] if self . form . get ( [string] , None ) is None and self . person . mtggoldfish_username is not None : [EOL] self . form [ [string] ] = self . person . mtggoldfish_username [EOL] self . disable_gf = True [EOL] self . process ( ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . person , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def process ( self ) : [EOL] if self . person and self . person . mtgo_username : [EOL] self . link_tappedout ( ) [EOL] self . link_mtggoldfish ( ) [EOL] elif self . form . get ( [string] , None ) : [comment] [EOL] self . link_discord ( ) [EOL] [EOL] def link_discord ( self ) : [EOL] did = auth . discord_id ( ) [EOL] if did is None : [EOL] self . form . errors . mtgo_username = [string] [EOL] return [EOL] try : [EOL] self . person = person . link_discord ( self . form [ [string] ] , did ) [EOL] except AlreadyExistsException : [EOL] self . form . errors . mtgo_username = [string] . format ( mtgo_username = self . form [ [string] ] ) [EOL] [EOL] def link_mtggoldfish ( self ) : [EOL] if self . person is None : [EOL] return [EOL] mtggoldfish_name = self . form . get ( [string] , None ) [EOL] if mtggoldfish_name and self . person . mtggoldfish_username != mtggoldfish_name : [EOL] mtggoldfish_user = person . maybe_load_person_by_mtggoldfish_name ( mtggoldfish_name ) [EOL] if mtggoldfish_user is None : [EOL] self . form . errors . gf_username = [string] . format ( mtggoldfish_name = mtggoldfish_name ) [EOL] elif mtggoldfish_user . mtgo_username is not None : [EOL] self . form . errors . gf_username = [string] . format ( mtggoldfish_name = mtggoldfish_name ) [EOL] else : [EOL] person . squash ( self . person . id , mtggoldfish_user . id , [string] , [string] ) [EOL] self . disable_gf = True [EOL] [EOL] def link_tappedout ( self ) : [EOL] if self . person is None : [EOL] return [EOL] tapped_name = self . form . get ( [string] , None ) [EOL] if tapped_name and self . person . tappedout_username != tapped_name : [EOL] tapped_user = person . maybe_load_person_by_tappedout_name ( tapped_name ) [EOL] if tapped_user is None : [EOL] self . form . errors . to_username = [string] . format ( tapped_name = tapped_name ) [EOL] elif tapped_user . id is not None : [EOL] self . form . errors . to_username = [string] . format ( tapped_name = tapped_name ) [EOL] else : [EOL] person . squash ( self . person . id , cast ( int , tapped_user . id ) , [string] , [string] ) [EOL] self . disable_to = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[decksite.data.models.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import datetime [EOL] import datetime [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite import league [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class LeagueInfo ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . current = league . active_league ( ) [EOL] self . end_date = custom_strftime ( [string] , self . current . end_date ) [EOL] self . signup_url = url_for ( [string] ) [EOL] self . report_url = url_for ( [string] ) [EOL] self . records_url = url_for ( [string] ) [EOL] self . retire_url = url_for ( [string] ) [EOL] self . bugs_url = url_for ( [string] , _anchor = [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL] [EOL] def discord_url ( self ) : [EOL] return [string] [comment] [EOL] [EOL] def suffix ( d ) : [EOL] return [string] if [number] <= d <= [number] else { [number] : [string] , [number] : [string] , [number] : [string] } . get ( d % [number] , [string] ) [EOL] [EOL] def custom_strftime ( fmt , t ) : [EOL] return t . strftime ( fmt ) . replace ( [string] , str ( t . day ) + suffix ( t . day ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from flask import url_for [EOL] [EOL] from decksite . view import View [EOL] from magic import oracle [EOL] [EOL] [EOL] [comment] [EOL] class Bugs ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . github_icon = url_for ( [string] , filename = [string] ) [EOL] self . cards = oracle . bugged_cards ( ) [EOL] self . tournament_bugs_url = url_for ( [string] , _anchor = [string] ) [EOL] self . bug_blog_url = [string] [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
import builtins [EOL] from flask_babel import gettext [EOL] [EOL] from decksite . views . decklist_form import DecklistForm [EOL] [EOL] [EOL] [comment] [EOL] class DeckCheck ( DecklistForm ) : [EOL] def page_title ( self ) : [EOL] return [string] [EOL] [EOL] def TT_DECKLIST ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_ENTER_OR_UPLOAD ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_YOUR_RECENT_DECKS ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_CHOOSE_DECK ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_DECKCHECK ( self ) : [EOL] return gettext ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import decksite [EOL] from flask import url_for [EOL] [EOL] from decksite . data . form import Form [EOL] from decksite . views . league_form import LeagueForm [EOL] [EOL] [EOL] [comment] [EOL] class AdminRetire ( LeagueForm ) : [EOL] def __init__ ( self , form ) : [EOL] super ( ) . __init__ ( form ) [EOL] self . logout_url = url_for ( [string] , target = [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import magic [EOL] import datetime [EOL] from typing import Optional [EOL] [EOL] from flask import session [EOL] [EOL] from decksite . data import card [EOL] from decksite . view import View [EOL] from magic import rotation [EOL] from magic . models import Card [EOL] from shared import configuration , dtutil [EOL] [EOL] [EOL] [comment] [EOL] class Rotation ( View ) : [EOL] def __init__ ( self , interestingness = None , query = [string] ) : [EOL] super ( ) . __init__ ( ) [EOL] until_rotation = rotation . next_rotation ( ) - dtutil . now ( ) [EOL] in_rotation = configuration . get_bool ( [string] ) [EOL] if until_rotation < datetime . timedelta ( [number] ) : [EOL] in_rotation = True [EOL] self . rotation_msg = [string] + dtutil . display_date ( rotation . next_rotation ( ) , [number] ) [EOL] else : [EOL] self . rotation_msg = [string] + dtutil . display_date ( rotation . next_rotation ( ) , [number] ) [EOL] if in_rotation : [EOL] self . in_rotation = in_rotation [EOL] self . show_interestingness_filter = True [EOL] self . runs , self . runs_percent , self . cards = rotation . read_rotation_files ( ) [EOL] [comment] [EOL] playability = card . playability ( ) [EOL] c = ... [EOL] for c in self . cards : [EOL] c . interestingness = rotation . interesting ( playability , c ) [EOL] else : [EOL] self . cards = [ ] [EOL] self . show_interesting = True [EOL] if interestingness : [EOL] self . cards = [ c for c in self . cards if c . get ( [string] ) == interestingness ] [EOL] self . num_cards = len ( self . cards ) [EOL] self . query = query [EOL] self . show_filters_toggle = True [EOL] self . cards = [ c for c in self . cards if visible ( c ) ] [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] def visible ( c ) : [EOL] return c . status != [string] or session . get ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $magic.models.Card$ 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 0 $typing.Any$ 0 $magic.models.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.Card$ 0 $magic.models.Card$ 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $magic.models.Card$ 0 $magic.models.Card$ 0 0 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , Union , List , Literal [EOL] import builtins [EOL] import typing_extensions [EOL] import shared [EOL] import typing [EOL] import decksite [EOL] from typing import List [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . data import archetype as archs [EOL] from decksite . deck_type import DeckType [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Archetypes ( View ) : [EOL] def __init__ ( self , archetypes , all_matchups , tournament_only = False ) : [EOL] min_matches_for_matchups_grid = [number] if not tournament_only else [number] [EOL] super ( ) . __init__ ( ) [EOL] self . archetypes = archetypes [EOL] self . decks = [ ] [EOL] self . show_seasons = True [EOL] self . tournament_only = self . hide_source = self . hide_perfect_runs = tournament_only [EOL] self . show_tournament_toggle = True [EOL] self . toggle_results_url = url_for ( [string] , deck_type = None if tournament_only else DeckType . TOURNAMENT . value ) [EOL] self . setup_matchups ( archetypes , all_matchups , min_matches_for_matchups_grid ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
import builtins [EOL] from flask import url_for [EOL] [EOL] from decksite . view import View [EOL] from magic import tournaments [EOL] [EOL] [EOL] [comment] [EOL] class Tournaments ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . setup_tournaments ( ) [EOL] self . leaderboards_url = url_for ( [string] ) [EOL] self . bugs_url = url_for ( [string] ) [EOL] self . prizes = tournaments . prizes_by_finish ( ) [EOL] self . pd500_url = url_for ( [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Optional , List , Container , Any [EOL] import builtins [EOL] import magic [EOL] import shared [EOL] import typing [EOL] import decksite [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import inflect [EOL] import titlecase [EOL] from flask import session , url_for [EOL] [EOL] from decksite import prepare [EOL] from decksite . data import archetype , deck , match [EOL] from decksite . view import View [EOL] from magic import card , oracle [EOL] from shared import dtutil , fetch_tools [EOL] from shared . container import Container [EOL] from shared . pd_exception import InvalidDataException [EOL] [EOL] [EOL] [comment] [EOL] class Deck ( View ) : [EOL] def __init__ ( self , d , person_id = None , discord_id = None ) : [EOL] super ( ) . __init__ ( ) [EOL] self . deck = d [EOL] prepare . prepare_deck ( self . deck ) [EOL] self . cards = d . all_cards ( ) [EOL] self . matches = match . load_matches_by_deck ( d , should_load_decks = True ) [EOL] for m in self . matches : [EOL] m . display_date = dtutil . display_date ( m . date ) [EOL] if m . opponent : [EOL] m . opponent_url = url_for ( [string] , mtgo_username = m . opponent ) [EOL] else : [EOL] m . opponent = [string] [EOL] m . opponent_url = False [EOL] if m . opponent_deck_id : [EOL] m . opponent_deck_url = url_for ( [string] , deck_id = m . opponent_deck_id ) [EOL] else : [EOL] m . opponent_deck_url = False [EOL] if m . opponent_deck and m . opponent_deck . is_in_current_run ( ) : [EOL] m . opponent_deck_name = [string] [EOL] elif m . opponent_deck : [EOL] m . opponent_deck_name = m . opponent_deck . name [EOL] else : [EOL] m . opponent_deck_name = [string] [EOL] if self . has_rounds ( ) : [EOL] m . display_round = display_round ( m ) [EOL] self . deck [ [string] ] . sort ( key = lambda x : oracle . deck_sort ( x . card ) ) [EOL] self . deck [ [string] ] . sort ( key = lambda x : oracle . deck_sort ( x . card ) ) [EOL] self . archetypes = archetype . load_archetypes_deckless ( order_by = [string] ) [EOL] self . edit_archetype_url = url_for ( [string] ) [EOL] self . legal_formats = d . legal_formats [EOL] self . is_in_current_run = d . is_in_current_run ( ) [EOL] self . person_id = person_id [EOL] self . discord_id = discord_id [EOL] [EOL] def has_matches ( self ) : [EOL] return len ( self . matches ) > [number] [EOL] [EOL] def has_rounds ( self ) : [EOL] return self . has_matches ( ) and self . matches [ [number] ] . get ( [string] ) [EOL] [EOL] def og_title ( self ) : [EOL] return self . deck . name if self . public ( ) else [string] [EOL] [EOL] def og_url ( self ) : [EOL] return url_for ( [string] , deck_id = self . deck . id , _external = True ) [EOL] [EOL] def og_description ( self ) : [EOL] if self . public ( ) and self . archetype_name : [EOL] p = inflect . engine ( ) [EOL] archetype_s = titlecase . titlecase ( p . a ( self . archetype_name ) ) [EOL] else : [EOL] archetype_s = [string] [EOL] description = [string] . format ( archetype_s = archetype_s , author = self . person ) [EOL] return description [EOL] [EOL] def oembed_url ( self ) : [EOL] return url_for ( [string] , deck_id = self . deck . id , _external = True ) [EOL] [EOL] def authenticate_url ( self ) : [EOL] return url_for ( [string] , target = self . og_url ( ) ) [EOL] [EOL] def logout_url ( self ) : [EOL] return url_for ( [string] , target = self . og_url ( ) ) [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] return getattr ( self . deck , attr ) [EOL] [EOL] def page_title ( self ) : [EOL] return self . deck . name if self . public ( ) else [string] [EOL] [EOL] def sections ( self ) : [EOL] sections = [ ] [EOL] if self . creatures ( ) : [EOL] sections . append ( { [string] : [string] , [string] : self . creatures ( ) , [string] : sum ( [ c [ [string] ] for c in self . creatures ( ) ] ) } ) [EOL] if self . spells ( ) : [EOL] sections . append ( { [string] : [string] , [string] : self . spells ( ) , [string] : sum ( [ c [ [string] ] for c in self . spells ( ) ] ) } ) [EOL] if self . lands ( ) : [EOL] sections . append ( { [string] : [string] , [string] : self . lands ( ) , [string] : sum ( [ c [ [string] ] for c in self . lands ( ) ] ) } ) [EOL] if self . sideboard ( ) : [EOL] sections . append ( { [string] : [string] , [string] : self . sideboard ( ) , [string] : sum ( [ c [ [string] ] for c in self . sideboard ( ) ] ) } ) [EOL] return sections [EOL] [EOL] def creatures ( self ) : [EOL] return [ entry for entry in self . deck . maindeck if entry . card . is_creature ( ) ] [EOL] [EOL] def spells ( self ) : [EOL] return [ entry for entry in self . deck . maindeck if entry . card . is_spell ( ) ] [EOL] [EOL] def lands ( self ) : [EOL] return [ entry for entry in self . deck . maindeck if entry . card . is_land ( ) ] [EOL] [EOL] def sideboard ( self ) : [EOL] return self . deck . sideboard [EOL] [EOL] def public ( self ) : [EOL] if not self . is_in_current_run : [EOL] return True [EOL] if self . person_id is None : [EOL] return False [EOL] if session . get ( [string] ) : [EOL] return True [EOL] if session . get ( [string] ) : [EOL] return True [EOL] if self . person_id != self . deck . person_id : [EOL] return False [EOL] return True [EOL] [EOL] def cardhoarder_url ( self ) : [comment] [EOL] d = self . deck [EOL] cs = { } [EOL] for entry in d . maindeck + d . sideboard : [EOL] name = entry . name [EOL] cs [ name ] = cs . get ( name , [number] ) + entry [ [string] ] [EOL] deck_s = [string] . join ( [ str ( v ) + [string] + card . to_mtgo_format ( k ) . replace ( [string] , [string] ) for k , v in cs . items ( ) ] ) [EOL] return [string] . format ( deck = fetch_tools . escape ( deck_s ) ) [EOL] [EOL] def display_round ( m ) : [EOL] if not m . get ( [string] ) : [EOL] return m . round [EOL] if int ( m . elimination ) == [number] : [EOL] return [string] [EOL] if int ( m . elimination ) == [number] : [EOL] return [string] [EOL] if int ( m . elimination ) == [number] : [EOL] return [string] [EOL] raise InvalidDataException ( [string] . format ( m = m ) ) [EOL] [EOL] class DeckEmbed ( Deck ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.deck.Deck$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $magic.models.deck.Deck$ 0 0 0 $magic.models.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class RotationChecklist ( View ) : [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] import random [EOL] from typing import List , Optional [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . view import View [EOL] from magic import legality , oracle [EOL] from magic . models import Card , Deck [EOL] [EOL] [EOL] [comment] [EOL] class About ( View ) : [EOL] def __init__ ( self , src , last_season_tournament_winners ) : [EOL] super ( ) . __init__ ( ) [EOL] if src == [string] : [EOL] self . show_gp_card = True [EOL] self . gp_card_url = url_for ( [string] , filename = [string] ) [EOL] self . cards = exciting_cards ( ) [EOL] self . num_tournaments_title_case = self . num_tournaments ( ) . title ( ) [EOL] s = [string] . join ( set ( d . archetype_name for d in last_season_tournament_winners ) ) [EOL] self . tournament_winning_archetypes_s = s . replace ( [string] , [string] , s . count ( [string] ) - [number] ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL] [EOL] def exciting_cards ( ) : [EOL] cards = fancy_cards ( ) [EOL] random . shuffle ( cards ) [EOL] return cards [ : [number] ] [EOL] [EOL] def fancy_cards ( ) : [EOL] return legality . cards_legal_in_format ( oracle . load_cards ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import List [EOL] [EOL] from decksite . data . competition import Competition [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class Competitions ( View ) : [EOL] def __init__ ( self , competitions ) : [EOL] super ( ) . __init__ ( ) [EOL] self . competitions = competitions [EOL] self . show_seasons = True [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[decksite.data.competition.Competition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.competition.Competition]$ 0 $typing.List[decksite.data.competition.Competition]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask import url_for [EOL] [EOL] from decksite . data . form import Form [EOL] from decksite . views . league_form import LeagueForm [EOL] [EOL] [EOL] [comment] [EOL] class DecklistForm ( LeagueForm ) : [EOL] def __init__ ( self , form , person_id ) : [EOL] super ( ) . __init__ ( form ) [EOL] self . person_id = person_id [EOL] self . classify_illegal_cards ( ) [EOL] [EOL] def classify_illegal_cards ( self ) : [EOL] if self . form . card_errors is not None : [EOL] self . has_not_legal = [string] in self . form . card_errors and len ( self . form . card_errors [ [string] ] ) > [number] [EOL] self . has_banned = [string] in self . form . card_errors and len ( self . form . card_errors [ [string] ] ) > [number] [EOL] self . has_bugs = [string] in self . form . card_errors and len ( self . form . card_errors [ [string] ] ) > [number] [EOL] self . has_too_many = [string] in self . form . card_errors and len ( self . form . card_errors [ [string] ] ) > [number] [EOL] if self . form . card_warnings is not None : [EOL] self . has_warnings = [string] in self . form . card_warnings and len ( self . form . card_warnings [ [string] ] ) > [number] [EOL] self . bugged_cards_url = url_for ( [string] , _anchor = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.form.Form$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $decksite.data.form.Form$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Sequence , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import List , Sequence [EOL] [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class EditAliases ( View ) : [EOL] def __init__ ( self , aliases , all_people ) : [EOL] super ( ) . __init__ ( ) [EOL] people_by_id = { p . id : p for p in all_people } [EOL] for entry in aliases : [EOL] entry . mtgo_username = people_by_id [ entry . person_id ] . mtgo_username [EOL] self . people = all_people [EOL] self . aliases = aliases [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[decksite.data.models.person.Person]$ 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 $typing.List[shared.container.Container]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , Any , List [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] from typing import List [EOL] [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Achievements ( View ) : [EOL] def __init__ ( self , achievements ) : [EOL] super ( ) . __init__ ( ) [EOL] self . achievements = achievements [EOL] self . leaderboards = [ ] [EOL] for a in self . achievements : [EOL] if a . leaderboard : [EOL] self . leaderboards . append ( a . leaderboard ) [EOL] a . has_leaderboard = True [EOL] self . show_seasons = True [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import datetime [EOL] from typing import Any , Dict , List , Union , cast [EOL] [EOL] from decksite . view import View [EOL] from shared import dtutil [EOL] [EOL] [EOL] [comment] [EOL] class Seasons ( View ) : [EOL] def __init__ ( self , stats ) : [EOL] super ( ) . __init__ ( ) [EOL] seasons = self . all_seasons ( ) [EOL] seasons . pop ( ) [comment] [EOL] self . seasons = [ ] [EOL] for season_info in seasons : [EOL] season = { } [EOL] season . update ( season_info ) [EOL] season_stats = stats . get ( cast ( int , season [ [string] ] ) , { } ) [EOL] season . update ( season_stats ) [EOL] if season . get ( [string] ) is None : [EOL] continue [EOL] for k , v in season . items ( ) : [EOL] if isinstance ( v , int ) : [EOL] season [ k ] = [string] . format ( v ) [comment] [EOL] season [ [string] ] = dtutil . display_date ( season [ [string] ] ) [EOL] season [ [string] ] = season [ [string] ] + [string] [EOL] if season . get ( [string] ) : [EOL] season [ [string] ] = dtutil . display_date ( season [ [string] ] ) [EOL] else : [EOL] season [ [string] ] = [string] [EOL] season [ [string] ] += [string] [EOL] self . seasons . append ( season ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , List [EOL] [EOL] from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class TournamentLeaderboards ( View ) : [EOL] def __init__ ( self , series ) : [EOL] super ( ) . __init__ ( ) [EOL] self . series = series [EOL] self . leaderboards = [ s [ [string] ] for s in series ] [comment] [EOL] self . show_seasons = True [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import shared [EOL] from typing import List [EOL] [EOL] from decksite . data import person as ps [EOL] from decksite . view import View [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class PersonMatches ( View ) : [EOL] def __init__ ( self , person , matches ) : [EOL] super ( ) . __init__ ( ) [EOL] self . person = person [EOL] self . matches = matches [EOL] [EOL] def page_title ( self ) : [EOL] return f'{ self . person . name } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $decksite.data.models.person.Person$ 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.models.person.Person$ 0 $decksite.data.models.person.Person$ 0 0 0 $typing.List[shared.container.Container]$ 0 $typing.List[shared.container.Container]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] from mypy_extensions import TypedDict [EOL] [EOL] from decksite . view import View [EOL] from magic import fetcher [EOL] [EOL] ResourceDescription = TypedDict ( [string] , { [string] : str , [string] : str , [string] : bool , } ) [EOL] SectionDescription = TypedDict ( [string] , { [string] : str , [string] : List [ ResourceDescription ] , } ) [EOL] [EOL] [comment] [EOL] class Resources ( View ) : [EOL] def sections ( self ) : [EOL] raw_resources = fetcher . resources ( ) [EOL] sections = [ ] [EOL] for title , raw_section in raw_resources . items ( ) : [EOL] section = { [string] : title , [string] : [ ] } [EOL] sections . append ( section ) [EOL] for text , url in raw_section . items ( ) : [EOL] item = { [string] : text , [string] : url , [string] : url . startswith ( [string] ) and [string] not in url } [EOL] section [ [string] ] . append ( item ) [EOL] return sections [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Container , Any , List [EOL] import magic [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] from typing import Dict , List [EOL] [EOL] from flask import url_for [EOL] from flask_babel import gettext [EOL] [EOL] from decksite . view import View [EOL] from magic import rotation , tournaments [EOL] from magic . models import Card , Deck [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Home ( View ) : [EOL] def __init__ ( self , news , decks , cards , matches_stats ) : [EOL] super ( ) . __init__ ( ) [EOL] self . setup_news ( news ) [EOL] self . setup_decks ( decks ) [EOL] self . setup_cards ( cards ) [EOL] self . setup_rotation ( ) [EOL] self . setup_stats ( matches_stats ) [EOL] self . setup_tournaments ( ) [EOL] self . pd500_url = url_for ( [string] ) [EOL] self . pd500_date = dtutil . display_date_with_date_and_year ( tournaments . next_pd500_date ( ) ) [EOL] [EOL] def setup_news ( self , news ) : [EOL] self . news = news [EOL] self . has_news = len ( news ) > [number] [EOL] [EOL] def setup_decks ( self , decks ) : [EOL] min_decks = [number] [EOL] tournament_id , league_id = None , None [EOL] tournament_decks = [ ] [EOL] league_decks = [ ] [EOL] latest_decks = [ ] [EOL] for d in decks : [EOL] if d . source_name == [string] and tournament_id is None : [EOL] tournament_id = d . competition_id [EOL] if d . source_name == [string] and league_id is None : [EOL] league_id = d . competition_id [EOL] if d . competition_id is not None and d . competition_id == tournament_id and d . finish <= [number] : [EOL] tournament_decks . append ( d ) [EOL] if d . competition_id is not None and d . competition_id == league_id and d . wins >= [number] and ( d . losses + d . draws ) == [number] and len ( league_decks ) < [number] : [EOL] league_decks . append ( d ) [EOL] if len ( latest_decks ) < min_decks and not d . is_in_current_run ( ) : [EOL] latest_decks . append ( d ) [EOL] if len ( tournament_decks ) >= [number] and len ( league_decks ) >= [number] and len ( latest_decks ) >= min_decks : [EOL] break [EOL] self . deck_tables = [ ] [EOL] if league_decks : [EOL] self . deck_tables . append ( { [string] : gettext ( [string] ) , [string] : url_for ( [string] ) , [string] : gettext ( [string] ) , [string] : league_decks , [string] : True , [string] : True } ) [EOL] if tournament_decks : [EOL] self . deck_tables . append ( { [string] : gettext ( [string] ) , [string] : url_for ( [string] , competition_id = tournament_id ) , [string] : gettext ( [string] ) , [string] : tournament_decks } ) [EOL] if latest_decks : [EOL] self . deck_tables . append ( { [string] : gettext ( [string] ) , [string] : self . decks_url ( ) , [string] : gettext ( [string] ) , [string] : latest_decks } ) [EOL] self . decks = league_decks + tournament_decks + latest_decks [EOL] [EOL] def setup_cards ( self , cards ) : [EOL] cards = [ c for c in cards if [string] not in c . type_line ] [EOL] self . top_cards = cards [ [number] : [number] ] [EOL] self . cards = self . top_cards [comment] [EOL] self . cards_url = url_for ( [string] ) [EOL] [EOL] def setup_rotation ( self ) : [EOL] self . season_start_display = dtutil . display_date ( rotation . last_rotation ( ) ) [EOL] self . season_end_display = dtutil . display_date ( rotation . next_rotation ( ) ) [EOL] self . scryfall_url = [string] [EOL] self . legal_cards_url = [string] [EOL] self . in_rotation = rotation . in_rotation ( ) [EOL] self . rotation_msg = [string] [EOL] self . rotation_url = url_for ( [string] ) [EOL] [EOL] def setup_stats ( self , matches_stats ) : [EOL] [comment] [EOL] matches_stats_display = { } [EOL] for k , v in matches_stats . items ( ) : [EOL] matches_stats_display [ k ] = [string] . format ( v ) if v is not None else [string] [EOL] self . community_stats = [ { [string] : [string] , [string] : [ { [string] : f"{ matches_stats_display [ [string] ] } [string] " } , { [string] : f"{ matches_stats_display [ [string] ] } [string] " } , { [string] : f"{ matches_stats_display [ [string] ] } [string] " } , { [string] : f"{ matches_stats_display [ [string] ] } [string] " } , { [string] : f"{ matches_stats_display [ [string] ] } [string] " } ] } ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[shared.container.Container]$ 0 $typing.List[magic.models.Deck]$ 0 $typing.List[magic.models.Card]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[shared.container.Container]$ 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 $typing.List[typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 0 0 0 0 0 0 $typing.List[magic.models.Deck]$ 0 $typing.List[magic.models.Deck]$ 0 $typing.List[magic.models.Deck]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
from . about import About [EOL] from . about_pdm import AboutPdm [EOL] from . achievements import Achievements [EOL] from . add_form import AddForm [EOL] from . admin import Admin [EOL] from . admin_retire import AdminRetire [EOL] from . archetype import Archetype [EOL] from . archetypes import Archetypes [EOL] from . bugs import Bugs [EOL] from . card import Card [EOL] from . cards import Cards [EOL] from . community_guidelines import CommunityGuidelines [EOL] from . competition import Competition [EOL] from . competitions import Competitions [EOL] from . deck import Deck , DeckEmbed [EOL] from . deck_check import DeckCheck [EOL] from . decks import Decks [EOL] from . edit_aliases import EditAliases [EOL] from . edit_archetypes import EditArchetypes [EOL] from . edit_league import EditLeague [EOL] from . edit_matches import EditMatches [EOL] from . edit_news import EditNews [EOL] from . edit_rules import EditRules [EOL] from . faqs import Faqs [EOL] from . home import Home [EOL] from . league_form import LeagueForm [EOL] from . league_info import LeagueInfo [EOL] from . link_accounts import LinkAccounts [EOL] from . matchups import Matchups [EOL] from . pd500 import PD500 [EOL] from . people import People [EOL] from . person import Person [EOL] from . person_achievements import PersonAchievements [EOL] from . person_matches import PersonMatches [EOL] from . player_notes import PlayerNotes [EOL] from . prizes import Prizes [EOL] from . report import Report [EOL] from . resources import Resources [EOL] from . retire import Retire [EOL] from . rotation import Rotation [EOL] from . rotation_changes import RotationChanges [EOL] from . rotation_checklist import RotationChecklist [EOL] from . seasons import Seasons [EOL] from . signup import SignUp [EOL] from . tournament_hosting import TournamentHosting [EOL] from . tournament_leaderboards import TournamentLeaderboards [EOL] from . tournaments import Tournaments [EOL] from . unlink import Unlink [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from flask import url_for [EOL] from flask_babel import gettext [EOL] [EOL] from decksite . view import View [EOL] [EOL] from . . import APP [EOL] [EOL] [EOL] [comment] [EOL] class AboutPdm ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . about_url = url_for ( [string] ) [EOL] [EOL] def page_title ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def languages ( self ) : [EOL] return [string] . join ( [ locale . display_name for locale in APP . babel . list_translations ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask_babel import gettext [EOL] [EOL] from decksite . data . form import Form [EOL] from decksite . views . decklist_form import DecklistForm [EOL] [EOL] [EOL] [comment] [EOL] class SignUp ( DecklistForm ) : [EOL] def __init__ ( self , form , is_closed , person_id ) : [EOL] super ( ) . __init__ ( form , person_id ) [EOL] self . is_closed = is_closed [EOL] [EOL] def page_title ( self ) : [EOL] return [string] . format ( league = self . league [ [string] ] ) [EOL] [EOL] def TT_MTGOTRADERS_SIGNUP_TIK ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_MTGO_USERNAME ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_DECK_NAME ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_DECKLIST ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_ENTER_OR_UPLOAD ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_SIGNUP ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_YOUR_RECENT_DECKS ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def TT_CHOOSE_DECK ( self ) : [EOL] return gettext ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from decksite . view import View [EOL] [EOL] [EOL] [comment] [EOL] class CommunityGuidelines ( View ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from decksite . view import View [EOL] from magic import tournaments [EOL] [EOL] [EOL] [comment] [EOL] class TournamentHosting ( View ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] hosts = [ host for series in tournaments . all_series_info ( ) for host in series [ [string] ] ] [EOL] hosts += [ [string] ] [EOL] self . hosts = [string] . join ( set ( hosts ) ) [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , List , Any , Type [EOL] import builtins [EOL] import magic [EOL] import flask [EOL] import datetime [EOL] import typing [EOL] import decksite [EOL] import datetime [EOL] import json [EOL] from math import ceil [EOL] from typing import Any , Dict , List , Optional , cast [EOL] [EOL] from flask import Response , request , session , url_for [EOL] from flask_restx import Resource , fields [EOL] [EOL] from decksite import APP , auth , league [EOL] from decksite . data import archetype as archs [EOL] from decksite . data import card [EOL] from decksite . data import competition as comp [EOL] from decksite . data import deck , match [EOL] from decksite . data import person as ps [EOL] from decksite . data import query [EOL] from decksite . data import rule as rs [EOL] from decksite . data . achievements import Achievement [EOL] from decksite . prepare import prepare_cards , prepare_decks [EOL] from decksite . views import DeckEmbed [EOL] from magic import oracle , rotation , tournaments [EOL] from magic . decklist import parse_line [EOL] from magic . models import Deck [EOL] from shared import configuration , dtutil , guarantee [EOL] from shared import redis_wrapper as redis [EOL] from shared . pd_exception import DoesNotExistException , InvalidDataException , TooManyItemsException [EOL] from shared_web import template [EOL] from shared_web . api import generate_error , return_json , validate_api_key [EOL] from shared_web . decorators import fill_args , fill_form [EOL] [EOL] [comment] [EOL] [EOL] SearchItem = Dict [ str , str ] [EOL] [EOL] DEFAULT_LIVE_TABLE_PAGE_SIZE = [number] [EOL] SEARCH_CACHE = [ ] [EOL] [EOL] DECK_ENTRY = APP . api . model ( [string] , { [string] : fields . Integer ( ) , [string] : fields . String ( ) } ) [EOL] [EOL] DECK = APP . api . model ( [string] , { [string] : fields . Integer ( readonly = True ) , [string] : fields . String ( ) , [string] : fields . DateTime ( ) , [string] : fields . DateTime ( ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . String ( ) , [string] : fields . String ( ) , [string] : fields . Integer ( ) , [string] : fields . String ( ) , [string] : fields . String ( ) , [string] : fields . String ( ) , [string] : fields . Boolean ( ) , [string] : fields . List ( fields . String ( ) ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . List ( fields . Nested ( DECK_ENTRY ) ) , [string] : fields . List ( fields . Nested ( DECK_ENTRY ) ) , } ) [EOL] [EOL] COMPETITION = APP . api . model ( [string] , { [string] : fields . Integer ( readonly = True ) , [string] : fields . String ( ) , [string] : fields . DateTime ( ) , [string] : fields . DateTime ( ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . Integer ( ) , [string] : fields . String ( ) , [string] : fields . String ( ) , [string] : fields . String ( ) , [string] : fields . Integer ( ) , [string] : fields . List ( fields . Nested ( DECK ) ) } ) [EOL] [EOL] @ APP . route ( [string] ) def decks_api ( ) : [EOL] [docstring] [EOL] order_by = query . decks_order_by ( request . args . get ( [string] ) , request . args . get ( [string] ) , request . args . get ( [string] ) ) [EOL] page_size = int ( request . args . get ( [string] , DEFAULT_LIVE_TABLE_PAGE_SIZE ) ) [EOL] page = int ( request . args . get ( [string] , [number] ) ) [EOL] start = page * page_size [EOL] limit = f' [string] { start } [string] { page_size }' [EOL] [comment] [EOL] season_id = [string] if request . args . get ( [string] ) else rotation . season_id ( str ( request . args . get ( [string] ) ) , None ) [EOL] where = query . decks_where ( request . args , session . get ( [string] ) ) [EOL] total = deck . load_decks_count ( where = where , season_id = season_id ) [EOL] pages = max ( ceil ( total / page_size ) - [number] , [number] ) [comment] [EOL] ds = deck . load_decks ( where = where , order_by = order_by , limit = limit , season_id = season_id ) [EOL] prepare_decks ( ds ) [EOL] r = { [string] : page , [string] : pages , [string] : ds } [EOL] resp = return_json ( r , camelize = True ) [EOL] resp . set_cookie ( [string] , str ( page_size ) ) [EOL] return resp [EOL] [EOL] @ APP . route ( [string] ) def cards2_api ( ) : [EOL] [docstring] [EOL] order_by = query . cards_order_by ( request . args . get ( [string] ) , request . args . get ( [string] ) ) [EOL] page_size = int ( request . args . get ( [string] , DEFAULT_LIVE_TABLE_PAGE_SIZE ) ) [EOL] page = int ( request . args . get ( [string] , [number] ) ) [EOL] start = page * page_size [EOL] limit = f' [string] { start } [string] { page_size }' [EOL] person_id = request . args . get ( [string] ) or None [EOL] tournament_only = request . args . get ( [string] ) == [string] [EOL] season_id = rotation . season_id ( str ( request . args . get ( [string] ) ) , None ) [EOL] additional_where = query . card_name_where ( request . args . get ( [string] , [string] ) . strip ( ) ) [EOL] cs = card . load_cards ( additional_where = additional_where , order_by = order_by , limit = limit , person_id = person_id , tournament_only = tournament_only , season_id = season_id ) [EOL] prepare_cards ( cs , tournament_only = tournament_only ) [EOL] total = card . load_cards_count ( additional_where = additional_where , person_id = person_id , season_id = season_id ) [EOL] pages = max ( ceil ( total / page_size ) - [number] , [number] ) [comment] [EOL] r = { [string] : page , [string] : pages , [string] : cs } [EOL] resp = return_json ( r , camelize = True ) [EOL] resp . set_cookie ( [string] , str ( page_size ) ) [EOL] return resp [EOL] [EOL] @ APP . api . route ( [string] ) class LoadDeck ( Resource ) : [EOL] @ APP . api . marshal_with ( DECK ) def get ( self , deck_id ) : [EOL] return deck . load_deck ( deck_id ) [EOL] [EOL] @ APP . api . route ( [string] ) class LoadRandomDeck ( Resource ) : [EOL] @ APP . api . marshal_with ( DECK ) def get ( self ) : [EOL] blob = league . random_legal_deck ( ) [EOL] if blob is None : [EOL] APP . api . abort ( [number] , [string] ) [EOL] return None [EOL] blob [ [string] ] = url_for ( [string] , deck_id = blob [ [string] ] , _external = True ) [EOL] return blob [EOL] [EOL] @ APP . route ( [string] ) def competitions_api ( ) : [EOL] [comment] [EOL] [comment] [EOL] comps = comp . load_competitions ( having = [string] , should_load_decks = True ) [EOL] r = [ ] [EOL] for c in comps : [EOL] if c . decks : [EOL] cr = { } [EOL] cr [ [string] ] = c . id [EOL] cr [ [string] ] = c . name [EOL] cr [ [string] ] = url_for ( [string] , competition_id = c . id , _external = True ) [EOL] r . append ( cr ) [EOL] return return_json ( r ) [comment] [EOL] [EOL] @ APP . route ( [string] ) def competition_api ( competition_id ) : [EOL] return return_json ( comp . load_competition ( competition_id ) ) [EOL] [EOL] @ APP . api . route ( [string] ) class League ( Resource ) : [EOL] @ APP . api . marshal_with ( COMPETITION ) def get ( self ) : [EOL] lg = league . active_league ( should_load_decks = True ) [EOL] pdbot = request . form . get ( [string] , None ) == configuration . get ( [string] ) [EOL] if not pdbot : [EOL] lg . decks = [ d for d in lg . decks if not d . is_in_current_run ( ) ] [EOL] return lg [EOL] [EOL] @ APP . route ( [string] ) @ fill_args ( [string] ) def person_api ( person , season_id = - [number] ) : [EOL] if season_id == - [number] : [EOL] season_id = rotation . current_season_num ( ) [EOL] try : [EOL] p = ps . load_person_by_discord_id_or_username ( person , season_id ) [EOL] p . decks_url = url_for ( [string] , person = person , season_id = season_id ) [EOL] p . head_to_head = url_for ( [string] , person = person , season_id = season_id ) [EOL] return return_json ( p ) [EOL] except DoesNotExistException : [EOL] return return_json ( generate_error ( [string] , [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ fill_args ( [string] ) def person_decks_api ( person , season_id = [number] ) : [EOL] p = ps . load_person_by_discord_id_or_username ( person , season_id = season_id ) [EOL] blob = { [string] : p . name , [string] : p . decks , } [EOL] return return_json ( blob ) [EOL] [EOL] @ APP . route ( [string] ) @ fill_args ( [string] ) def person_h2h_api ( person , season_id = [number] ) : [EOL] p = ps . load_person_by_discord_id_or_username ( person , season_id = season_id ) [EOL] return return_json ( p . head_to_head ) [EOL] [EOL] @ APP . route ( [string] ) def league_run_api ( person ) : [EOL] decks = league . active_decks_by ( person ) [EOL] if len ( decks ) == [number] : [EOL] return return_json ( None ) [EOL] [EOL] run = guarantee_at_most_one_or_retire ( decks ) [EOL] if run is None : [EOL] return return_json ( None ) [EOL] [EOL] decks = league . active_decks ( ) [EOL] already_played = [ m . opponent_deck_id for m in match . load_matches_by_deck ( run ) ] [EOL] run . can_play = [ d . person for d in decks if d . person != person and d . id not in already_played ] [EOL] [EOL] return return_json ( run ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def drop ( person ) : [EOL] error = validate_api_key ( ) [EOL] if error : [EOL] return error [EOL] [EOL] decks = league . active_decks_by ( person ) [EOL] if len ( decks ) == [number] : [EOL] return return_json ( generate_error ( [string] , [string] ) ) [EOL] [EOL] run = guarantee . exactly_one ( decks ) [EOL] [EOL] league . retire_deck ( run ) [EOL] result = { [string] : True } [EOL] return return_json ( result ) [EOL] [EOL] @ APP . route ( [string] ) def rotation_api ( ) : [EOL] now = dtutil . now ( ) [EOL] diff = rotation . next_rotation ( ) - now [EOL] result = { [string] : rotation . last_rotation_ex ( ) , [string] : rotation . next_rotation_ex ( ) , [string] : diff . total_seconds ( ) , [string] : dtutil . display_time ( int ( diff . total_seconds ( ) ) ) } [EOL] return return_json ( result ) [EOL] [EOL] @ APP . route ( [string] ) def rotation_clear_cache ( ) : [EOL] rotation . clear_redis ( ) [EOL] rotation . rotation_redis_store ( ) [EOL] return return_json ( { [string] : True } ) [EOL] [EOL] @ APP . route ( [string] ) def cards_api ( ) : [EOL] blob = { [string] : card . load_cards ( ) } [EOL] return return_json ( blob ) [EOL] [EOL] @ APP . route ( [string] ) def card_api ( c ) : [EOL] return return_json ( oracle . load_card ( c ) ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . demimod_required @ fill_form ( [string] , [string] ) def post_reassign ( deck_id , archetype_id ) : [EOL] archs . assign ( deck_id , archetype_id , auth . person_id ( ) ) [EOL] redis . clear ( f' [string] { deck_id }' ) [EOL] return return_json ( { [string] : True , [string] : deck_id } ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ fill_form ( [string] ) @ auth . demimod_required def post_rule_update ( rule_id = None ) : [EOL] if rule_id is not None and request . form . get ( [string] ) is not None and request . form . get ( [string] ) is not None : [EOL] inc = [ ] [EOL] exc = [ ] [EOL] for line in cast ( str , request . form . get ( [string] ) ) . strip ( ) . splitlines ( ) : [EOL] try : [EOL] inc . append ( parse_line ( line ) ) [EOL] except InvalidDataException : [EOL] return return_json ( { [string] : False , [string] : f" [string] { line }" } ) [EOL] if not card . card_exists ( inc [ - [number] ] [ [number] ] ) : [EOL] return return_json ( { [string] : False , [string] : f' [string] { line }' } ) [EOL] for line in cast ( str , request . form . get ( [string] ) ) . strip ( ) . splitlines ( ) : [EOL] try : [EOL] exc . append ( parse_line ( line ) ) [EOL] except InvalidDataException : [EOL] return return_json ( { [string] : False , [string] : f" [string] { line }" } ) [EOL] if not card . card_exists ( exc [ - [number] ] [ [number] ] ) : [EOL] return return_json ( { [string] : False , [string] : f' [string] { line }' } ) [EOL] rs . update_cards ( rule_id , inc , exc ) [EOL] return return_json ( { [string] : True } ) [EOL] return return_json ( { [string] : False , [string] : [string] } ) [EOL] [EOL] @ APP . route ( [string] ) def sitemap ( ) : [EOL] urls = [ url_for ( rule . endpoint ) for rule in APP . url_map . iter_rules ( ) if [string] in rule . methods and len ( rule . arguments ) == [number] ] [EOL] return return_json ( { [string] : urls } ) [EOL] [EOL] @ APP . route ( [string] ) def intro ( ) : [EOL] return return_json ( not request . cookies . get ( [string] , False ) and not auth . hide_intro ( ) ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def hide_intro ( ) : [EOL] r = Response ( response = [string] ) [EOL] r . set_cookie ( [string] , value = str ( True ) , expires = dtutil . dt2ts ( dtutil . now ( ) ) + [number] * [number] * [number] * [number] * [number] ) [EOL] return r [EOL] [EOL] @ APP . route ( [string] ) @ auth . load_person def person_status ( ) : [EOL] username = auth . mtgo_username ( ) [EOL] r = { [string] : username , [string] : auth . discord_id ( ) , [string] : session . get ( [string] , False ) , [string] : session . get ( [string] , False ) , [string] : request . cookies . get ( [string] , False ) or auth . hide_intro ( ) or username or auth . discord_id ( ) , [string] : session . get ( [string] , False ) , } [EOL] if username : [EOL] d = guarantee_at_most_one_or_retire ( league . active_decks_by ( username ) ) [EOL] if d is not None : [EOL] r [ [string] ] = { [string] : d . name , [string] : url_for ( [string] , deck_id = d . id ) , [string] : d . get ( [string] , [number] ) , [string] : d . get ( [string] , [number] ) } [comment] [EOL] if r [ [string] ] or r [ [string] ] : [EOL] r [ [string] ] = len ( deck . load_decks ( [string] ) ) [EOL] active_league = league . active_league ( ) [EOL] if active_league : [EOL] time_until_league_end = active_league . end_date - datetime . datetime . now ( tz = datetime . timezone . utc ) [EOL] if time_until_league_end <= datetime . timedelta ( days = [number] ) : [EOL] r [ [string] ] = dtutil . display_time ( time_until_league_end / datetime . timedelta ( seconds = [number] ) , granularity = [number] ) [EOL] return return_json ( r ) [EOL] [EOL] def guarantee_at_most_one_or_retire ( decks ) : [EOL] try : [EOL] run = guarantee . at_most_one ( decks ) [EOL] except TooManyItemsException : [EOL] league . retire_deck ( decks [ [number] ] ) [EOL] run = decks [ [number] ] [EOL] return run [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required_no_redirect def person_notes ( person_id ) : [EOL] return return_json ( { [string] : ps . load_notes ( person_id ) } ) [EOL] [EOL] @ APP . route ( [string] ) def deck_embed ( deck_id ) : [EOL] [comment] [EOL] d = deck . load_deck ( deck_id ) [EOL] view = DeckEmbed ( d , None , None ) [EOL] width = [number] [EOL] height = [number] [EOL] embed = { [string] : [string] , [string] : [string] , [string] : view . page_title ( ) , [string] : width , [string] : height , [string] : template . render ( view ) } [EOL] return return_json ( embed ) [EOL] [EOL] @ APP . route ( [string] ) def test_500 ( ) : [EOL] if configuration . get_bool ( [string] ) : [EOL] return return_json ( generate_error ( [string] , [string] ) , status = [number] ) [EOL] raise TooManyItemsException ( ) [EOL] [EOL] @ APP . route ( [string] ) def all_achievements ( ) : [EOL] data = { } [EOL] data [ [string] ] = [ { [string] : a . key , [string] : a . title , [string] : a . description_safe } for a in Achievement . all_achievements ] [EOL] return return_json ( data ) [EOL] [EOL] @ APP . route ( [string] ) def all_tournaments ( ) : [EOL] data = { } [EOL] data [ [string] ] = ( tournaments . all_series_info ( ) ) [EOL] return return_json ( data ) [EOL] [EOL] @ APP . route ( [string] ) def search ( ) : [EOL] init_search_cache ( ) [EOL] q = request . args . get ( [string] , [string] ) . lower ( ) [EOL] results = [ ] [EOL] if len ( q ) < [number] : [EOL] return return_json ( results ) [EOL] for item in SEARCH_CACHE : [EOL] if q in item [ [string] ] . lower ( ) : [EOL] results . append ( item ) [EOL] return return_json ( results ) [EOL] [EOL] def init_search_cache ( ) : [EOL] if len ( SEARCH_CACHE ) > [number] : [EOL] return [EOL] submenu_entries = [ ] [comment] [EOL] for entry in APP . config . get ( [string] , lambda : [ ] ) ( ) : [EOL] if entry . get ( [string] ) : [EOL] continue [EOL] SEARCH_CACHE . append ( menu_item_to_search_item ( entry ) ) [EOL] for subentry in entry . get ( [string] , [ ] ) : [EOL] submenu_entries . append ( menu_item_to_search_item ( subentry , entry . get ( [string] ) ) ) [EOL] for entry in submenu_entries : [EOL] if entry . get ( [string] ) : [EOL] continue [EOL] SEARCH_CACHE . append ( menu_item_to_search_item ( entry ) ) [EOL] with open ( configuration . get_str ( [string] ) ) as f : [EOL] for item in json . load ( f ) : [EOL] SEARCH_CACHE . append ( item ) [EOL] [EOL] def menu_item_to_search_item ( menu_item , parent_name = None ) : [EOL] name = [string] [EOL] if parent_name : [EOL] name += f'{ parent_name } [string] ' [EOL] name += menu_item . get ( [string] , [string] ) [EOL] if menu_item . get ( [string] ) : [EOL] url = menu_item . get ( [string] ) [EOL] else : [EOL] url = url_for ( menu_item . get ( [string] , [string] ) ) [EOL] return { [string] : name , [string] : [string] , [string] : url } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , List , Any [EOL] import builtins [EOL] import magic [EOL] import werkzeug [EOL] import typing [EOL] import decksite [EOL] import urllib . parse [EOL] from typing import List , Optional [EOL] [EOL] from flask import redirect , request , url_for [EOL] from werkzeug import wrappers [EOL] [EOL] from decksite import APP , SEASONS , auth , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . data import archetype as archs [EOL] from decksite . data import card as cs [EOL] from decksite . data import deck as ds [EOL] from decksite . data import matchup as mus [EOL] from decksite . data import person as ps [EOL] from decksite . data import season as ss [EOL] from decksite . deck_type import DeckType [EOL] from decksite . views import Archetype , Archetypes , Card , Cards , Deck , Decks , Matchups , Seasons [EOL] from magic import oracle [EOL] from shared . pd_exception import DoesNotExistException , InvalidDataException [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def decks ( deck_type = None ) : [EOL] league_only = validate_deck_type ( deck_type , [ DeckType . ALL , DeckType . LEAGUE ] ) == DeckType . LEAGUE [EOL] view = Decks ( league_only ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . load_person def deck ( deck_id ) : [EOL] d = ds . load_deck ( deck_id ) [EOL] view = Deck ( d , auth . person_id ( ) , auth . discord_id ( ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def seasons ( ) : [EOL] stats = ss . season_stats ( ) [EOL] view = Seasons ( stats ) [EOL] return view . page ( ) [EOL] [EOL] @ SEASONS . route ( [string] ) @ cached ( ) def season ( ) : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def cards ( deck_type = None ) : [EOL] tournament_only = validate_deck_type ( deck_type , [ DeckType . ALL , DeckType . TOURNAMENT ] ) == DeckType . TOURNAMENT [EOL] query = request . args . get ( [string] ) [EOL] if query is None : [EOL] query = [string] [EOL] all_cards = cs . load_cards ( season_id = get_season_id ( ) , tournament_only = tournament_only ) [EOL] view = Cards ( all_cards , query = query , tournament_only = tournament_only ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def card ( name , deck_type = None ) : [EOL] tournament_only = validate_deck_type ( deck_type , [ DeckType . ALL , DeckType . TOURNAMENT ] ) == DeckType . TOURNAMENT [EOL] try : [EOL] c = cs . load_card ( oracle . valid_name ( urllib . parse . unquote_plus ( name ) ) , season_id = get_season_id ( ) ) [EOL] view = Card ( c , tournament_only ) [EOL] return view . page ( ) [EOL] except InvalidDataException as e : [EOL] raise DoesNotExistException ( e ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def archetypes ( deck_type = None ) : [EOL] tournament_only = validate_deck_type ( deck_type , [ DeckType . ALL , DeckType . TOURNAMENT ] ) == DeckType . TOURNAMENT [EOL] season_id = get_season_id ( ) [EOL] deckless_archetypes = archs . load_archetypes_deckless ( season_id = season_id , tournament_only = tournament_only ) [EOL] all_matchups = archs . load_matchups ( season_id = season_id , tournament_only = tournament_only ) [EOL] view = Archetypes ( deckless_archetypes , all_matchups , tournament_only = tournament_only ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def archetype ( archetype_id , deck_type = None ) : [EOL] tournament_only = validate_deck_type ( deck_type , [ DeckType . ALL , DeckType . TOURNAMENT ] ) == DeckType . TOURNAMENT [EOL] season_id = get_season_id ( ) [EOL] a = archs . load_archetype ( archetype_id . replace ( [string] , [string] ) , season_id = season_id , tournament_only = tournament_only ) [EOL] deckless_archetypes = archs . load_archetypes_deckless_for ( a . id , season_id = season_id , tournament_only = tournament_only ) [EOL] archetype_matchups = archs . load_matchups ( archetype_id = a . id , season_id = season_id , tournament_only = tournament_only ) [EOL] view = Archetype ( a , deckless_archetypes , archetype_matchups , tournament_only = tournament_only , season_id = season_id ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) def matchups ( ) : [EOL] hero , enemy = { } , { } [EOL] for k , v in request . args . items ( ) : [EOL] if k . startswith ( [string] ) : [EOL] k = k . replace ( [string] , [string] ) [EOL] hero [ k ] = v [EOL] else : [EOL] k = k . replace ( [string] , [string] ) [EOL] enemy [ k ] = v [EOL] season_id = request . args . get ( [string] ) [EOL] results = mus . matchup ( hero , enemy , season_id = season_id ) if [string] in request . args else { } [EOL] matchup_archetypes = archs . load_archetypes_deckless ( ) [EOL] matchup_archetypes . sort ( key = lambda a : a . name ) [EOL] matchup_people = list ( ps . load_people ( where = [string] ) ) [EOL] matchup_people . sort ( key = lambda p : p . name ) [EOL] matchup_cards = cs . load_cards ( ) [EOL] matchup_cards . sort ( key = lambda c : c . name ) [EOL] view = Matchups ( hero , enemy , season_id , matchup_archetypes , matchup_people , matchup_cards , results ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] def validate_deck_type ( s , allowed_values = None ) : [EOL] if not s : [EOL] return DeckType . ALL [EOL] try : [EOL] deck_type = DeckType ( s ) [EOL] if allowed_values and deck_type not in allowed_values : [EOL] raise DoesNotExistException ( f' [string] { deck_type }' ) [EOL] except ValueError as e : [EOL] raise DoesNotExistException ( e ) [EOL] return deck_type [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.deck_type.DeckType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import magic [EOL] import werkzeug [EOL] import flask [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask import Response , make_response , redirect , request , session , url_for [EOL] from werkzeug import wrappers [EOL] [EOL] from decksite import APP , auth [EOL] from decksite import league as lg [EOL] from decksite . cache import cached [EOL] from decksite . data import deck as ds [EOL] from decksite . data import person as ps [EOL] from decksite . league import ReportForm , RetireForm , SignUpForm [EOL] from decksite . views import LeagueInfo , Report , Retire , SignUp [EOL] from shared_web . decorators import fill_cookies [EOL] [EOL] [EOL] @ APP . route ( [string] ) def league ( ) : [EOL] view = LeagueInfo ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def current_league ( ) : [EOL] url = url_for ( [string] , competition_id = lg . active_league ( ) . id ) [EOL] return redirect ( url ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . load_person def signup ( form = None ) : [EOL] if form is None : [EOL] form = SignUpForm ( request . form , auth . person_id ( ) , auth . mtgo_username ( ) ) [EOL] view = SignUp ( form , lg . get_status ( ) == lg . Status . CLOSED , auth . person_id ( ) ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ cached ( ) def add_signup ( ) : [EOL] if lg . get_status ( ) == lg . Status . CLOSED : [EOL] return signup ( ) [EOL] form = SignUpForm ( request . form , auth . person_id ( ) , auth . mtgo_username ( ) ) [EOL] if form . validate ( ) : [EOL] d = lg . signup ( form ) [EOL] response = make_response ( redirect ( url_for ( [string] , deck_id = d . id ) ) ) [EOL] response . set_cookie ( [string] , str ( d . id ) ) [EOL] return response [EOL] return signup ( form ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ auth . load_person @ fill_cookies ( [string] ) def report ( form = None , deck_id = None ) : [EOL] if form is None : [EOL] form = ReportForm ( request . form , deck_id , auth . person_id ( ) ) [EOL] view = Report ( form , auth . person_id ( ) ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def add_report ( ) : [EOL] form = ReportForm ( request . form ) [EOL] if form . validate ( ) and lg . report ( form ) : [EOL] response = make_response ( redirect ( url_for ( [string] , deck_id = form . entry ) ) ) [EOL] response . set_cookie ( [string] , form . entry ) [EOL] return response [EOL] return report ( form ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ fill_cookies ( [string] ) @ auth . login_required def retire ( form = None , deck_id = None ) : [EOL] if form is None : [EOL] form = RetireForm ( request . form , deck_id , session . get ( [string] ) ) [EOL] view = Retire ( form ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . login_required def retire_deck ( ) : [EOL] form = RetireForm ( request . form , discord_user = session . get ( [string] ) ) [EOL] if form . validate ( ) : [EOL] d = ds . load_deck ( form . entry ) [EOL] ps . associate ( d , session [ [string] ] ) [EOL] lg . retire_deck ( d ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] return make_response ( retire ( form ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , List , Container , Any [EOL] import builtins [EOL] import werkzeug [EOL] import shared [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask import redirect , url_for [EOL] from werkzeug import wrappers [EOL] [EOL] from decksite import APP , SEASONS , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . data import achievements as achs [EOL] from decksite . data import archetype as archs [EOL] from decksite . data import card as cs [EOL] from decksite . data import match as ms [EOL] from decksite . data import person as ps [EOL] from decksite . views import People , Person , PersonAchievements , PersonMatches [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def people ( ) : [EOL] view = People ( ps . load_people ( season_id = get_season_id ( ) ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def person ( mtgo_username = None , person_id = None ) : [EOL] p = load_person ( mtgo_username , person_id , season_id = get_season_id ( ) ) [EOL] person_cards = cs . load_cards ( person_id = p . id , season_id = get_season_id ( ) ) [EOL] person_archetypes = archs . load_archetypes_deckless ( person_id = p . id , season_id = get_season_id ( ) ) [EOL] all_archetypes = archs . load_archetypes_deckless ( season_id = get_season_id ( ) ) [EOL] trailblazer_cards = cs . trailblazer_cards ( p . id ) [EOL] unique_cards = cs . unique_cards_played ( p . id ) [EOL] your_cards = { [string] : unique_cards , [string] : trailblazer_cards } [EOL] person_matchups = archs . load_matchups ( person_id = p . id , season_id = get_season_id ( ) ) [EOL] view = Person ( p , person_cards , person_archetypes , all_archetypes , person_matchups , your_cards , get_season_id ( ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) def person_achievements ( mtgo_username = None , person_id = None ) : [EOL] p = load_person ( mtgo_username , person_id , season_id = get_season_id ( ) ) [EOL] view = PersonAchievements ( p , achs . load_achievements ( p , season_id = get_season_id ( ) , with_detail = True ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) def achievements_redirect ( ) : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def person_matches ( mtgo_username = None , person_id = None ) : [EOL] p = load_person ( mtgo_username , person_id , season_id = get_season_id ( ) ) [EOL] matches = ms . load_matches_by_person ( person_id = p . id , season_id = get_season_id ( ) ) [EOL] matches . reverse ( ) [comment] [EOL] view = PersonMatches ( p , matches ) [EOL] return view . page ( ) [EOL] [EOL] def load_person ( mtgo_username = None , person_id = None , season_id = None ) : [EOL] if mtgo_username : [EOL] return ps . load_person_by_mtgo_username ( mtgo_username , season_id = season_id ) [EOL] if person_id : [EOL] return ps . load_person_by_id ( person_id , season_id = season_id ) [EOL] raise DoesNotExistException ( f" [string] { mtgo_username } [string] { person_id } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.person.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Optional , Sequence , List , Container , Any [EOL] import builtins [EOL] import magic [EOL] import werkzeug [EOL] import shared [EOL] import datetime [EOL] import typing_extensions [EOL] import typing [EOL] import decksite [EOL] from typing import Any , Dict , List , Optional , Union , cast [EOL] [EOL] import titlecase [EOL] from flask import make_response , redirect , request , session , url_for [EOL] from flask_babel import gettext [EOL] from werkzeug import wrappers [EOL] [EOL] from decksite import APP , auth [EOL] from decksite import league as lg [EOL] from decksite . data import archetype as archs [EOL] from decksite . data import competition as comp [EOL] from decksite . data import deck as ds [EOL] from decksite . data import match as ms [EOL] from decksite . data import news as ns [EOL] from decksite . data import person as ps [EOL] from decksite . data import rule as rs [EOL] from decksite . league import RetireForm [EOL] from decksite . views import ( Admin , AdminRetire , EditAliases , EditArchetypes , EditLeague , EditMatches , EditNews , EditRules , PlayerNotes , Prizes , RotationChecklist , Unlink ) [EOL] from magic . models import Deck [EOL] from shared import dtutil [EOL] from shared import redis_wrapper as redis [EOL] from shared . container import Container [EOL] from shared . pd_exception import InvalidArgumentException [EOL] from shared_web . decorators import fill_form [EOL] [EOL] [EOL] def admin_menu ( ) : [EOL] m = [ ] [EOL] endpoints = sorted ( [ rule . endpoint for rule in APP . url_map . iter_rules ( ) if [string] in rule . methods and rule . rule . startswith ( [string] ) ] ) [EOL] for endpoint in endpoints : [EOL] name = titlecase . titlecase ( endpoint . replace ( [string] , [string] ) ) if endpoint else [string] [EOL] m . append ( { [string] : name , [string] : endpoint , [string] : url_for ( endpoint ) } ) [EOL] m . append ( { [string] : gettext ( [string] ) , [string] : [string] } ) [EOL] return m [EOL] [EOL] @ APP . route ( [string] ) @ auth . demimod_required def admin_home ( ) : [EOL] view = Admin ( admin_menu ( ) ) [EOL] return view . response ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def edit_aliases ( ) : [EOL] aliases = ps . load_aliases ( ) [EOL] all_people = ps . load_people ( order_by_name = True ) [EOL] view = EditAliases ( aliases , all_people ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ fill_form ( [string] , [string] ) @ auth . admin_required def post_aliases ( person_id = None , alias = None ) : [EOL] if person_id is not None and alias is not None and len ( alias ) > [number] : [EOL] ps . add_alias ( person_id , alias ) [EOL] return edit_aliases ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . demimod_required def edit_archetypes ( search_results = None , q = [string] , notq = [string] ) : [EOL] if search_results is None : [EOL] search_results = [ ] [EOL] view = EditArchetypes ( archs . load_archetypes_deckless ( order_by = [string] ) , search_results , q , notq ) [EOL] return view . response ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . demimod_required def post_archetypes ( ) : [EOL] search_results = [ ] [EOL] if request . form . get ( [string] ) is not None : [EOL] archetype_ids = request . form . getlist ( [string] ) [EOL] [comment] [EOL] if len ( archetype_ids ) == [number] and len ( request . form . getlist ( [string] ) ) > [number] : [EOL] archetype_ids = archetype_ids * len ( request . form . getlist ( [string] ) ) [EOL] for deck_id in request . form . getlist ( [string] ) : [EOL] archetype_id = archetype_ids . pop ( [number] ) [EOL] if archetype_id : [EOL] archs . assign ( deck_id , archetype_id , auth . person_id ( ) ) [EOL] redis . clear ( f' [string] { deck_id }' ) [EOL] elif request . form . get ( [string] ) is not None and request . form . get ( [string] ) is not None : [EOL] search_results = ds . load_decks_by_cards ( cast ( str , request . form . get ( [string] ) ) . splitlines ( ) , cast ( str , request . form . get ( [string] ) ) . splitlines ( ) ) [EOL] elif request . form . get ( [string] ) is not None : [EOL] search_results = ds . load_conflicted_decks ( ) [EOL] elif request . form . get ( [string] ) is not None : [EOL] archs . rename ( cast_int ( request . form . get ( [string] ) ) , cast ( str , request . form . get ( [string] ) ) ) [EOL] elif request . form . get ( [string] ) is not None : [EOL] archs . update_description ( cast_int ( request . form . get ( [string] ) ) , cast ( str , request . form . get ( [string] ) ) ) [EOL] elif request . form . getlist ( [string] ) is not None and len ( request . form . getlist ( [string] ) ) == [number] : [EOL] archs . move ( request . form . getlist ( [string] ) [ [number] ] , request . form . getlist ( [string] ) [ [number] ] ) [EOL] elif request . form . get ( [string] ) is not None : [EOL] archs . add ( cast ( str , request . form . get ( [string] ) ) , cast_int ( request . form . get ( [string] ) ) ) [EOL] else : [EOL] raise InvalidArgumentException ( [string] . format ( f = request . form ) ) [EOL] return edit_archetypes ( search_results , request . form . get ( [string] , [string] ) , request . form . get ( [string] , [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . demimod_required def edit_rules ( ) : [EOL] cnum = rs . num_classified_decks ( ) [EOL] tnum = ds . num_decks ( rs . classified_decks_query ( ) ) [EOL] archetypes = archs . load_archetypes_deckless ( order_by = [string] ) [EOL] view = EditRules ( cnum , tnum , rs . doubled_decks ( ) , rs . mistagged_decks ( ) , rs . overlooked_decks ( ) , rs . load_all_rules ( ) , archetypes , rs . excluded_archetype_info ( ) ) [EOL] return view . response ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . demimod_required def post_rules ( ) : [EOL] if request . form . get ( [string] ) is not None : [EOL] rs . add_rule ( cast_int ( request . form . get ( [string] ) ) ) [EOL] else : [EOL] raise InvalidArgumentException ( [string] . format ( f = request . form ) ) [EOL] return edit_rules ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def admin_retire_deck ( form = None ) : [EOL] if form is None : [EOL] form = RetireForm ( request . form ) [EOL] view = AdminRetire ( form ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . admin_required def do_admin_retire_deck ( ) : [EOL] form = RetireForm ( request . form ) [EOL] if form . validate ( ) : [EOL] d = ds . load_deck ( form . entry ) [EOL] lg . retire_deck ( d ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] return make_response ( admin_retire_deck ( form ) ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def edit_matches ( ) : [EOL] view = EditMatches ( lg . active_league ( should_load_decks = True ) . decks , lg . load_latest_league_matches ( ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . admin_required def post_matches ( ) : [EOL] if request . form . get ( [string] ) : [EOL] match_id = cast_int ( request . form . get ( [string] ) ) [EOL] if request . form . get ( [string] ) == [string] : [EOL] ms . delete_match ( match_id ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] left_id = cast_int ( request . form . get ( [string] ) ) [EOL] left_games = cast_int ( request . form . get ( [string] ) ) [EOL] right_id = cast_int ( request . form . get ( [string] ) ) [EOL] right_games = cast_int ( request . form . get ( [string] ) ) [EOL] if request . form . get ( [string] ) == [string] : [EOL] ms . update_match ( match_id , left_id , left_games , right_id , right_games ) [EOL] elif request . form . get ( [string] ) == [string] : [EOL] ms . insert_match ( dtutil . now ( ) , left_id , left_games , right_id , right_games , None , None , None ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def edit_news ( ) : [EOL] new_item = Container ( { [string] : dtutil . form_date ( dtutil . now ( dtutil . WOTC_TZ ) , dtutil . WOTC_TZ ) , [string] : [string] , [string] : [string] } ) [EOL] news_items = [ new_item ] + ns . load_news ( ) [EOL] view = EditNews ( news_items ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ fill_form ( [string] , [string] , [string] ) @ auth . admin_required def post_news ( news_id , title = None , url = None , date = None ) : [EOL] if request . form . get ( [string] ) == [string] : [EOL] ns . delete ( news_id ) [EOL] else : [EOL] if date is not None and title is not None and url is not None : [EOL] date_dt = dtutil . parse ( date , dtutil . FORM_FORMAT , dtutil . WOTC_TZ ) [EOL] ns . add_or_update_news ( news_id , date_dt , title , url ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) def prizes ( ) : [EOL] tournaments_with_prizes = comp . tournaments_with_prizes ( ) [EOL] first_runs = lg . first_runs ( ) [EOL] view = Prizes ( tournaments_with_prizes , first_runs ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) def rotation_checklist ( ) : [EOL] view = RotationChecklist ( ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def player_notes ( ) : [EOL] notes = ps . load_notes ( ) [EOL] all_people = ps . load_people ( order_by_name = True ) [EOL] view = PlayerNotes ( notes , all_people ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . admin_required def post_player_note ( ) : [EOL] if not request . form . get ( [string] ) or not request . form . get ( [string] ) : [EOL] raise InvalidArgumentException ( f' [string] { request . form }' ) [EOL] creator = ps . load_person_by_discord_id ( session [ [string] ] ) [EOL] ps . add_note ( creator . id , request . form [ [string] ] , request . form [ [string] ] ) [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def unlink ( num_affected_people = None , errors = None ) : [EOL] all_people = ps . load_people ( order_by_name = True ) [EOL] view = Unlink ( all_people , num_affected_people , errors ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . admin_required def post_unlink ( ) : [EOL] n , errors = [number] , [ ] [EOL] person_id = request . form . get ( [string] ) [EOL] if person_id : [EOL] n += ps . unlink_discord ( person_id ) [EOL] discord_id = request . form . get ( [string] ) [EOL] if discord_id : [EOL] try : [EOL] discord_id = int ( discord_id ) [EOL] n += ps . remove_discord_link ( discord_id ) [EOL] except ValueError : [EOL] errors . append ( [string] ) [EOL] return unlink ( n , errors ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def edit_league ( ) : [EOL] view = EditLeague ( lg . get_status ( ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . admin_required def post_league ( ) : [EOL] status = lg . Status . CLOSED if request . form . get ( [string] ) == [string] else lg . Status . OPEN [EOL] lg . set_status ( status ) [EOL] return edit_league ( ) [EOL] [EOL] def cast_int ( param ) : [EOL] return int ( cast ( str , param ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import magic [EOL] from decksite import APP , SEASONS , auth , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . data import achievements as achs [EOL] from decksite . data import competition as comp [EOL] from decksite . data import deck as ds [EOL] from decksite . data import person as ps [EOL] from decksite . views import ( PD500 , Achievements , Competition , Competitions , TournamentHosting , TournamentLeaderboards , Tournaments ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def competitions ( ) : [EOL] view = Competitions ( comp . load_competitions ( season_id = get_season_id ( ) ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def competition ( competition_id ) : [EOL] view = Competition ( comp . load_competition ( competition_id ) ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) def tournaments ( ) : [EOL] view = Tournaments ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def hosting ( ) : [EOL] view = TournamentHosting ( ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) @ cached ( ) def tournament_leaderboards ( ) : [EOL] leaderboards = comp . leaderboards ( season_id = get_season_id ( ) ) [EOL] view = TournamentLeaderboards ( leaderboards ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def pd500 ( ) : [EOL] tournament_winning_decks = ds . load_decks ( where = [string] , season_id = get_season_id ( ) ) [EOL] view = PD500 ( tournament_winning_decks ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) def achievements ( ) : [EOL] username = auth . mtgo_username ( ) [EOL] p = None [EOL] if username is not None : [EOL] p = ps . load_person_by_mtgo_username ( username , season_id = get_season_id ( ) ) [EOL] view = Achievements ( achs . load_achievements ( p , season_id = get_season_id ( ) ) ) [EOL] return view . page ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import magic [EOL] import flask [EOL] import typing [EOL] import decksite [EOL] from flask import Response , make_response , redirect , request , url_for [EOL] [EOL] from decksite import APP , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . data import deck [EOL] from decksite . views import About , AboutPdm , CommunityGuidelines , Faqs [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def about_pdm ( ) : [EOL] view = AboutPdm ( ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def about_gp ( ) : [EOL] return make_response ( redirect ( url_for ( [string] , src = [string] ) ) ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def about ( ) : [EOL] season_id = max ( get_season_id ( ) - [number] , [number] ) [EOL] last_season_tournament_winners = deck . load_decks ( [string] , season_id = season_id ) [EOL] view = About ( request . args . get ( [string] ) , last_season_tournament_winners ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def faqs ( ) : [EOL] view = Faqs ( ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ cached ( ) def community_guidelines ( ) : [EOL] view = CommunityGuidelines ( ) [EOL] return view . page ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import about , admin , api , competitions , league , metagame , people , resources [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from decksite . data import match [EOL] from shared import dtutil [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def disabled ( ) : [EOL] [comment] [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL] match . insert_match ( dtutil . parse ( [string] , [string] , dtutil . WOTC_TZ ) , [number] , [number] , [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List [EOL] import bs4 [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from decksite . data import competition [EOL] from decksite . scrapers import gatherling [EOL] [EOL] [EOL] def test_top_n ( ) : [EOL] for n in [ [number] , [number] ] : [EOL] filename = [string] . format ( n = n ) [EOL] soup = get_soup ( filename ) [EOL] assert competition . Top ( n ) == gatherling . find_top_n ( soup ) [EOL] [EOL] def test_get_dt_and_series ( ) : [EOL] dt , competition_series = gatherling . get_dt_and_series ( [string] , [string] ) [EOL] assert dt . strftime ( [string] ) == [string] [EOL] assert competition_series == [string] [EOL] [EOL] dt , competition_series = gatherling . get_dt_and_series ( [string] , [string] ) [EOL] assert competition_series == [string] [EOL] assert dt . strftime ( [string] ) == [string] [EOL] [EOL] dt , competition_series = gatherling . get_dt_and_series ( [string] , [string] ) [EOL] assert competition_series == [string] [EOL] assert dt . strftime ( [string] ) == [string] [EOL] [EOL] dt , competition_series = gatherling . get_dt_and_series ( [string] , [string] ) [EOL] assert competition_series == [string] [EOL] assert dt . strftime ( [string] ) == [string] [EOL] [EOL] dt , competition_series = gatherling . get_dt_and_series ( [string] , [string] ) [EOL] assert competition_series == [string] [EOL] assert dt . strftime ( [string] ) == [string] [EOL] [EOL] def test_rankings ( ) : [EOL] soup = get_soup ( [string] ) [EOL] rankings = gatherling . rankings ( soup ) [EOL] assert len ( rankings ) == [number] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] [EOL] soup = get_soup ( [string] ) [EOL] rankings = gatherling . rankings ( soup ) [EOL] assert len ( rankings ) == [number] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] [EOL] soup = get_soup ( [string] ) [EOL] rankings = gatherling . rankings ( soup ) [EOL] assert len ( rankings ) == [number] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] assert rankings [ [number] ] == [string] [EOL] [EOL] def test_medal_winners ( ) : [EOL] html = get_html ( [string] ) [EOL] winners = gatherling . medal_winners ( html ) [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] [EOL] html = get_html ( [string] ) [EOL] winners = gatherling . medal_winners ( html ) [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] [EOL] html = get_html ( [string] ) [EOL] winners = gatherling . medal_winners ( html ) [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] assert winners [ [string] ] == [number] [EOL] [EOL] def test_finishes ( ) : [EOL] fs = gatherling . finishes ( { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] assert fs [ [string] ] == [number] [EOL] [EOL] def get_html ( filename ) : [EOL] path = [string] . format ( path = os . path . dirname ( __file__ ) , filename = filename ) [EOL] with open ( path , [string] ) as f : [EOL] return f . read ( ) [EOL] [EOL] def get_soup ( filename ) : [EOL] page = get_html ( filename ) [EOL] return BeautifulSoup ( page , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] import decksite [EOL] from typing import Any , Dict [EOL] [EOL] from decksite . data import competition , deck , top [EOL] from magic import decklist [EOL] from shared import dtutil , fetch_tools [EOL] [EOL] [EOL] def disabled ( ) : [EOL] competitions = fetch_tools . fetch_json ( [string] ) [EOL] competitions . reverse ( ) [EOL] for c in competitions : [EOL] tournament ( c ) [EOL] [EOL] [EOL] def tournament ( comp ) : [EOL] comp = fetch_tools . fetch_json ( comp [ [string] ] ) [EOL] dt = dtutil . ts2dt ( comp [ [string] ] ) [EOL] de = dtutil . ts2dt ( comp [ [string] ] ) [EOL] competition_id = competition . get_or_insert_competition ( dt , de , comp [ [string] ] , comp [ [string] ] , comp [ [string] ] , top . Top ( comp [ [string] ] ) ) [EOL] loaded_competition = competition . load_competition ( competition_id ) [EOL] if loaded_competition . num_decks < comp [ [string] ] : [EOL] for d in comp [ [string] ] : [EOL] store_deck ( d ) [EOL] [EOL] def store_deck ( d ) : [EOL] d [ [string] ] = d [ [string] ] [EOL] d [ [string] ] = d [ [string] ] [EOL] existing = deck . get_deck_id ( d [ [string] ] , d [ [string] ] ) [EOL] if existing is not None : [EOL] return deck . load_deck ( existing ) [EOL] d [ [string] ] = d [ [string] ] [EOL] d [ [string] ] = decklist . unvivify ( d ) [EOL] return deck . add_deck ( d ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , Set , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import magic [EOL] import re [EOL] import urllib [EOL] from typing import Dict , List , Optional , Set [EOL] [EOL] from bs4 import BeautifulSoup [EOL] [EOL] from decksite import translation [EOL] from decksite . data import deck [EOL] from magic import decklist , legality [EOL] from shared import configuration , fetch_tools , logger [EOL] from shared . pd_exception import InvalidDataException [EOL] [EOL] RawDeckType = deck . RawDeckDescription [EOL] [EOL] def ad_hoc ( ) : [EOL] login ( ) [EOL] logger . warning ( [string] . format ( is_authorised = is_authorised ( ) ) ) [EOL] raw_decks = fetch_decks ( ) [EOL] for raw_deck in raw_decks : [EOL] try : [EOL] if is_authorised ( ) : [EOL] details = fetch_deck_details ( raw_deck ) [EOL] if details is None : [EOL] logger . warning ( f' [string] { raw_deck }' ) [EOL] else : [EOL] raw_deck . update ( details ) [comment] [EOL] raw_deck = set_values ( raw_deck ) [EOL] deck . add_deck ( raw_deck ) [EOL] except InvalidDataException as e : [EOL] logger . warning ( [string] . format ( slug = raw_deck . get ( [string] , [string] ) , e = e ) ) [EOL] [EOL] def fetch_decks ( ) : [EOL] return fetch_tools . fetch_json ( [string] ) [EOL] [EOL] def fetch_deck_details ( raw_deck ) : [EOL] return fetch_tools . fetch_json ( [string] . format ( slug = raw_deck [ [string] ] ) ) [EOL] [EOL] def set_values ( raw_deck ) : [EOL] raw_deck = translation . translate ( translation . TAPPEDOUT , raw_deck ) [EOL] raw_decklist = fetch_tools . fetch ( [string] . format ( base_url = raw_deck [ [string] ] ) ) [EOL] raw_deck [ [string] ] = decklist . parse ( raw_decklist ) [EOL] raw_deck [ [string] ] = [string] [EOL] raw_deck [ [string] ] = raw_deck [ [string] ] [EOL] return raw_deck [EOL] [EOL] def is_authorised ( ) : [EOL] return fetch_tools . SESSION . cookies . get ( [string] ) is not None [EOL] [EOL] def login ( user = None , password = None ) : [EOL] if user is None : [EOL] user = configuration . get_str ( [string] ) [EOL] if password is None : [EOL] password = configuration . get_str ( [string] ) [EOL] if user == [string] or password == [string] : [EOL] logger . warning ( [string] ) [EOL] return [EOL] url = [string] [EOL] session = fetch_tools . SESSION [EOL] response = session . get ( url ) [EOL] [EOL] match = re . search ( [string] , response . text ) [EOL] if match is None : [EOL] [comment] [EOL] return [EOL] csrf = match . group ( [number] ) [EOL] [EOL] data = { [string] : csrf , [string] : [string] , [string] : user , [string] : password , } [EOL] headers = { [string] : url , } [EOL] logger . warning ( [string] . format ( user ) ) [EOL] response = session . post ( url , data = data , headers = headers ) [EOL] if response . status_code == [number] : [EOL] logger . warning ( [string] ) [EOL] [EOL] def scrape_url ( url ) : [EOL] if not url . endswith ( [string] ) : [EOL] url += [string] [EOL] path = urllib . parse . urlparse ( url ) . path [EOL] slug = path . split ( [string] ) [ [number] ] [EOL] raw_deck = { } [EOL] raw_deck [ [string] ] = slug [EOL] raw_deck [ [string] ] = url [EOL] if is_authorised ( ) : [EOL] raw_deck . update ( fetch_deck_details ( raw_deck ) ) [comment] [EOL] else : [EOL] raw_deck . update ( parse_printable ( raw_deck ) ) [comment] [EOL] raw_deck = set_values ( raw_deck ) [EOL] vivified = decklist . vivify ( raw_deck [ [string] ] ) [EOL] errors = { } [EOL] if [string] not in legality . legal_formats ( vivified , None , errors ) : [EOL] raise InvalidDataException ( [string] . format ( error = errors . get ( [string] ) ) ) [EOL] return deck . add_deck ( raw_deck ) [EOL] [EOL] def parse_printable ( raw_deck ) : [EOL] [docstring] [EOL] s = fetch_tools . fetch ( raw_deck [ [string] ] + [string] ) [EOL] soup = BeautifulSoup ( s , [string] ) [EOL] raw_deck [ [string] ] = soup . find ( [string] ) . string . strip ( [string] ) [EOL] infobox = soup . find ( [string] , { [string] : [string] } ) [EOL] if not infobox : [EOL] raise InvalidDataException ( [string] ) [EOL] user = infobox . find ( [string] , string = [string] ) [EOL] if not user : [EOL] raise InvalidDataException ( [string] ) [EOL] raw_deck [ [string] ] = user . find_next_sibling ( [string] ) . string [EOL] return raw_deck [EOL] [EOL] def scrape_user ( username ) : [EOL] parsed = { } [EOL] parsed [ [string] ] = username [EOL] s = fetch_tools . fetch ( [string] . format ( username ) ) [EOL] soup = BeautifulSoup ( s , [string] ) [EOL] mtgo = soup . find ( [string] , string = [string] ) [EOL] if mtgo is not None : [EOL] parsed [ [string] ] = mtgo . find_next_sibling ( [string] ) . string [EOL] else : [EOL] parsed [ [string] ] = None [EOL] return parsed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RawDeckType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , List , Any , Type [EOL] import bs4 [EOL] import builtins [EOL] import magic [EOL] import datetime [EOL] import typing [EOL] import decksite [EOL] import datetime [EOL] import re [EOL] import urllib . parse [EOL] from typing import Any , Dict , List , Optional , Tuple [EOL] [EOL] import bs4 [EOL] from bs4 import BeautifulSoup , ResultSet [EOL] [EOL] from decksite . data import archetype , competition , deck , match , person [EOL] from decksite . database import db [EOL] from magic import decklist [EOL] from shared import dtutil , fetch_tools , logger [EOL] from shared . pd_exception import InvalidDataException [EOL] [EOL] WINNER = [string] [EOL] SECOND = [string] [EOL] TOP_4 = [string] [EOL] TOP_8 = [string] [EOL] [EOL] ALIASES = { } [EOL] [EOL] def scrape ( limit = [number] ) : [EOL] soup = BeautifulSoup ( fetch_tools . fetch ( [string] , character_encoding = [string] ) , [string] ) [EOL] tournaments = [ ( gatherling_url ( link [ [string] ] ) , link . string ) for link in soup . find_all ( [string] ) if link [ [string] ] . find ( [string] ) >= [number] ] [EOL] n = [number] [EOL] for ( url , name ) in tournaments : [EOL] i = tournament ( url , name ) [EOL] n = n + i [EOL] if n > limit : [EOL] return [EOL] [EOL] def tournament ( url , name ) : [EOL] s = fetch_tools . fetch ( url , character_encoding = [string] , retry = True ) [EOL] [EOL] [comment] [EOL] soup = BeautifulSoup ( s , [string] ) [EOL] cell = soup . find ( [string] , { [string] : [string] } ) . find_all ( [string] ) [ [number] ] [EOL] [EOL] name = cell . find ( [string] ) . string . strip ( ) [EOL] day_s = cell . find ( [string] ) . next . strip ( ) [EOL] if [string] in day_s : [EOL] [comment] [EOL] return [number] [EOL] [EOL] dt , competition_series = get_dt_and_series ( name , day_s ) [EOL] top_n = find_top_n ( soup ) [EOL] if top_n == competition . Top . NONE : [comment] [EOL] logger . info ( [string] ) [EOL] return [number] [EOL] db ( ) . begin ( [string] ) [EOL] competition_id = competition . get_or_insert_competition ( dt , dt , name , competition_series , url , top_n ) [EOL] ranks = rankings ( soup ) [EOL] medals = medal_winners ( s ) [EOL] final = finishes ( medals , ranks ) [EOL] n = add_decks ( dt , competition_id , final , s ) [EOL] db ( ) . commit ( [string] ) [EOL] return n [EOL] [EOL] [comment] [EOL] def get_dt_and_series ( name , day_s ) : [EOL] if [string] in name : [EOL] competition_series = [string] [EOL] start_time = [string] [EOL] dt = get_dt ( day_s , start_time , dtutil . APAC_SERIES_TZ ) [EOL] elif [string] in name : [EOL] competition_series = [string] [EOL] start_time = [string] [EOL] dt = get_dt ( day_s , start_time , dtutil . GATHERLING_TZ ) [EOL] else : [EOL] if [string] in name or [string] in name or [string] in name : [EOL] start_time = [string] [EOL] else : [EOL] start_time = [string] [EOL] dt = get_dt ( day_s , start_time , dtutil . GATHERLING_TZ ) [EOL] competition_series = [string] . format ( day = dtutil . day_of_week ( dt , dtutil . GATHERLING_TZ ) ) [EOL] return ( dt , competition_series ) [EOL] [EOL] def get_dt ( day_s , start_time , timezone ) : [EOL] date_s = day_s + [string] . format ( start_time = start_time ) [EOL] return dtutil . parse ( date_s , [string] , timezone ) [EOL] [EOL] def find_top_n ( soup ) : [EOL] event_tables = soup . find ( [string] , { [string] : [string] } ) . find_all ( [string] ) [EOL] if len ( event_tables ) < [number] : [comment] [EOL] return competition . Top . NONE [EOL] return competition . Top ( int ( event_tables [ [number] ] . find_all ( [string] ) [ [number] ] . string . strip ( ) . replace ( [string] , [string] ) ) ) [EOL] [EOL] def add_decks ( dt , competition_id , final , s ) : [EOL] [comment] [EOL] rows = re . findall ( [string] , s , re . MULTILINE | re . DOTALL ) [EOL] decks_added , ds = [number] , [ ] [EOL] matches = [ ] [EOL] for row in rows : [EOL] cells = BeautifulSoup ( row , [string] ) . find_all ( [string] ) [EOL] d = tournament_deck ( cells , competition_id , dt , final ) [EOL] if d is not None : [EOL] if d . get ( [string] ) is None or not match . load_matches_by_deck ( d ) : [EOL] decks_added += [number] [EOL] ds . append ( d ) [EOL] matches += tournament_matches ( d ) [EOL] add_ids ( matches , ds ) [EOL] insert_matches_without_dupes ( dt , matches ) [EOL] guess_archetypes ( ds ) [EOL] return decks_added [EOL] [EOL] def guess_archetypes ( ds ) : [EOL] deck . calculate_similar_decks ( ds ) [EOL] for d in ds : [EOL] if d . similar_decks and d . similar_decks [ [number] ] . archetype_id is not None : [EOL] archetype . assign ( d . id , d . similar_decks [ [number] ] . archetype_id , None , False ) [EOL] [EOL] def rankings ( soup ) : [EOL] rows = soup . find ( text = [string] ) . find_parent ( [string] ) . find_all ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] rows = rows [ [number] : - [number] ] [EOL] ranks = [ ] [EOL] for row in rows : [EOL] cells = row . find_all ( [string] ) [EOL] mtgo_username = aliased ( cells [ [number] ] . string ) [EOL] ranks . append ( mtgo_username ) [EOL] return ranks [EOL] [EOL] def medal_winners ( s ) : [EOL] winners = { } [EOL] [comment] [EOL] rows = re . findall ( [string] , s , re . MULTILINE | re . DOTALL ) [EOL] for row in rows : [EOL] player = BeautifulSoup ( row , [string] ) . find_all ( [string] ) [ [number] ] [EOL] if player . find ( [string] ) : [EOL] mtgo_username = aliased ( player . a . contents [ [number] ] ) [EOL] img = re . sub ( [string] , [string] , player . img [ [string] ] ) [EOL] if img == WINNER : [EOL] winners [ mtgo_username ] = [number] [EOL] elif img == SECOND : [EOL] winners [ mtgo_username ] = [number] [EOL] elif img == TOP_4 : [EOL] winners [ mtgo_username ] = [number] [EOL] elif img == TOP_8 : [EOL] winners [ mtgo_username ] = [number] [EOL] elif img == [string] : [EOL] pass [EOL] else : [EOL] raise InvalidDataException ( [string] . format ( img = img ) ) [EOL] return winners [EOL] [EOL] def finishes ( winners , ranks ) : [EOL] final = winners . copy ( ) [EOL] r = len ( final ) [EOL] for p in ranks : [EOL] if p not in final . keys ( ) : [EOL] r += [number] [EOL] final [ p ] = r [EOL] return final [EOL] [EOL] def tournament_deck ( cells , competition_id , date , final ) : [EOL] d = { [string] : [string] , [string] : competition_id , [string] : dtutil . dt2ts ( date ) } [EOL] player = cells [ [number] ] [EOL] username = aliased ( player . a . contents [ [number] ] . string ) [EOL] d [ [string] ] = username [EOL] d [ [string] ] = final . get ( username ) [EOL] link = cells [ [number] ] . a [EOL] d [ [string] ] = gatherling_url ( link [ [string] ] ) [EOL] d [ [string] ] = link . string [EOL] if cells [ [number] ] . find ( [string] ) : [EOL] d [ [string] ] = cells [ [number] ] . a . string [EOL] else : [EOL] d [ [string] ] = cells [ [number] ] . string [EOL] gatherling_id = urllib . parse . parse_qs ( urllib . parse . urlparse ( str ( d [ [string] ] ) ) . query ) [ [string] ] [ [number] ] [EOL] d [ [string] ] = gatherling_id [EOL] existing = deck . get_deck_id ( d [ [string] ] , d [ [string] ] ) [EOL] if existing is not None : [EOL] return deck . load_deck ( existing ) [EOL] dlist = decklist . parse ( fetch_tools . post ( gatherling_url ( [string] ) , { [string] : gatherling_id } ) ) [EOL] d [ [string] ] = dlist [EOL] if len ( dlist [ [string] ] ) + len ( dlist [ [string] ] ) == [number] : [EOL] logger . warning ( [string] . format ( id = gatherling_id ) ) [EOL] return None [EOL] return deck . add_deck ( d ) [EOL] [EOL] def tournament_matches ( d ) : [EOL] url = [string] . format ( identifier = d . identifier ) [EOL] s = fetch_tools . fetch ( url , character_encoding = [string] , retry = True ) [EOL] soup = BeautifulSoup ( s , [string] ) [EOL] anchor = soup . find ( string = [string] ) [EOL] if anchor is None : [EOL] logger . warning ( [string] . format ( id = d . id ) ) [EOL] return [ ] [EOL] table = anchor . findParents ( [string] ) [ [number] ] [EOL] rows = table . find_all ( [string] ) [EOL] rows . pop ( [number] ) [comment] [EOL] rows . pop ( ) [comment] [EOL] return find_matches ( d , rows ) [EOL] [EOL] MatchListType = List [ Dict [ str , Any ] ] [EOL] [EOL] def find_matches ( d , rows ) : [EOL] matches = [ ] [EOL] for row in rows : [EOL] tds = row . find_all ( [string] ) [EOL] if [string] in tds [ [number] ] . renderContents ( ) . decode ( [string] ) : [EOL] logger . warning ( [string] . format ( identifier = d . identifier ) ) [EOL] break [EOL] round_type , num = re . findall ( [string] , tds [ [number] ] . string ) [ [number] ] [EOL] num = int ( num ) [EOL] if round_type == [string] : [EOL] elimination = [number] [EOL] round_num = num [EOL] elif round_type == [string] : [EOL] elimination = num [EOL] round_num += [number] [EOL] else : [EOL] raise InvalidDataException ( [string] . format ( round_type = round_type , id = d . id ) ) [EOL] if [string] in tds [ [number] ] . renderContents ( ) . decode ( [string] ) or [string] in tds [ [number] ] . renderContents ( ) . decode ( [string] ) : [EOL] left_games , right_games , right_identifier = [number] , [number] , None [EOL] else : [EOL] left_games , right_games = tds [ [number] ] . string . split ( [string] ) [EOL] href = tds [ [number] ] . find ( [string] ) [ [string] ] [EOL] right_identifier = re . findall ( [string] , href ) [ [number] ] [EOL] matches . append ( { [string] : round_num , [string] : elimination , [string] : left_games , [string] : d . identifier , [string] : right_games , [string] : right_identifier } ) [EOL] return matches [EOL] [EOL] def insert_matches_without_dupes ( dt , matches ) : [EOL] db ( ) . begin ( [string] ) [EOL] inserted = { } [EOL] for m in matches : [EOL] reverse_key = str ( m [ [string] ] ) + [string] + str ( m [ [string] ] ) + [string] + str ( m [ [string] ] ) [EOL] if inserted . get ( reverse_key ) : [EOL] continue [EOL] match . insert_match ( dt , m [ [string] ] , m [ [string] ] , m [ [string] ] , m [ [string] ] , m [ [string] ] , m [ [string] ] ) [EOL] key = str ( m [ [string] ] ) + [string] + str ( m [ [string] ] ) + [string] + str ( m [ [string] ] ) [EOL] inserted [ key ] = True [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] def add_ids ( matches , ds ) : [EOL] decks_by_identifier = { d . identifier : d for d in ds } [EOL] def lookup ( gatherling_id ) : [EOL] try : [EOL] return decks_by_identifier [ gatherling_id ] [EOL] except KeyError : [EOL] raise InvalidDataException ( [string] . format ( gatherling_id ) ) [EOL] for m in matches : [EOL] m [ [string] ] = lookup ( m [ [string] ] ) . id [EOL] m [ [string] ] = lookup ( m [ [string] ] ) . id if m [ [string] ] else None [EOL] [EOL] def gatherling_url ( href ) : [EOL] if href . startswith ( [string] ) : [EOL] return href [EOL] return [string] . format ( href = href ) [EOL] [EOL] def aliased ( username ) : [EOL] if not ALIASES : [EOL] load_aliases ( ) [EOL] return ALIASES . get ( username , username ) [EOL] [EOL] def load_aliases ( ) : [EOL] ALIASES [ [string] ] = [string] [comment] [EOL] for entry in person . load_aliases ( ) : [EOL] ALIASES [ entry . alias ] = entry . mtgo_username [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[datetime.datetime,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.competition.Top$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[decksite.data.deck.Deck]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[bs4.element.Tag]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MatchListType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $decksite.data.deck.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import asyncio [EOL] import asyncio [EOL] [EOL] from magic import multiverse [EOL] [EOL] [EOL] def scrape ( ) : [EOL] event_loop = None [EOL] try : [EOL] event_loop = asyncio . get_event_loop ( ) [EOL] except RuntimeError : [EOL] event_loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( event_loop ) [EOL] [EOL] event_loop . run_until_complete ( multiverse . update_bugged_cards_async ( ) ) [EOL] multiverse . rebuild_cache ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] import vcr [EOL] [EOL] from decksite import APP [EOL] from decksite . scrapers import gatherling , mtggoldfish , tappedout [EOL] from shared import configuration [EOL] [EOL] TEST_VCR = vcr . VCR ( record_mode = configuration . get ( [string] ) , path_transformer = vcr . VCR . ensure_suffix ( [string] ) , ) [EOL] [EOL] @ pytest . mark . xfail ( reason = [string] ) @ pytest . mark . functional @ pytest . mark . tappedout @ pytest . mark . external @ TEST_VCR . use_cassette def test_tappedout ( ) : [EOL] prev = APP . config [ [string] ] [EOL] APP . config [ [string] ] = configuration . server_name ( ) [EOL] with APP . app_context ( ) : [comment] [EOL] [comment] [EOL] tappedout . ad_hoc ( ) [EOL] APP . config [ [string] ] = prev [EOL] [EOL] @ pytest . mark . xfail ( reason = [string] ) @ pytest . mark . functional @ pytest . mark . gatherling @ pytest . mark . external @ TEST_VCR . use_cassette def test_gatherling ( ) : [EOL] with APP . app_context ( ) : [comment] [EOL] gatherling . scrape ( [number] ) [EOL] [EOL] @ pytest . mark . functional @ pytest . mark . tappedout @ pytest . mark . external @ TEST_VCR . use_cassette def test_manual_tappedout ( ) : [EOL] with APP . app_context ( ) : [comment] [EOL] tappedout . scrape_url ( [string] ) [EOL] [EOL] @ pytest . mark . functional @ pytest . mark . goldfish @ pytest . mark . external @ TEST_VCR . use_cassette def test_goldfish ( ) : [EOL] with APP . app_context ( ) : [comment] [EOL] mtggoldfish . scrape ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , Any [EOL] import data [EOL] import builtins [EOL] import flask [EOL] import logsite [EOL] import datetime [EOL] import typing [EOL] from typing import Any , Dict [EOL] [EOL] from flask import Response [EOL] from sqlalchemy import func , text [EOL] [EOL] from shared import dtutil , logger [EOL] [EOL] from . import APP , db [EOL] from . api import return_json [EOL] from . data import match [EOL] from . db import Format [EOL] [EOL] [EOL] @ APP . route ( [string] ) def stats ( ) : [EOL] val = { } [EOL] try : [EOL] last_switcheroo = calc_last_switcheroo ( ) [EOL] if last_switcheroo : [EOL] start = last_switcheroo . start_time_aware ( ) [EOL] if start : [EOL] val [ [string] ] = dtutil . dt2ts ( start ) [EOL] except AttributeError as e : [EOL] logger . warning ( f' [string] { e }' ) [EOL] [EOL] val [ [string] ] = { } [EOL] base_query = db . DB . session . query ( match . Match . format_id , Format . name , func . count ( match . Match . format_id ) ) . join ( match . Match . format ) . group_by ( match . Match . format_id ) [EOL] for m in base_query . order_by ( func . count ( match . Match . format_id ) . desc ( ) ) . all ( ) : [EOL] ( format_id , format_name , num_matches ) = m [EOL] val [ [string] ] [ format_name ] = { } [EOL] val [ [string] ] [ format_name ] [ [string] ] = format_name [EOL] val [ [string] ] [ format_name ] [ [string] ] = num_matches [EOL] last_week = dtutil . now ( ) - dtutil . ts2dt ( [number] * [number] * [number] * [number] ) [EOL] for m in base_query . filter ( match . Match . start_time > last_week ) . order_by ( func . count ( match . Match . format_id ) . desc ( ) ) . all ( ) : [EOL] ( format_id , format_name , num_matches ) = m [EOL] val [ [string] ] [ format_name ] [ [string] ] = { } [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = num_matches [EOL] stmt = text ( [string] ) [EOL] players = db . DB . session . query ( db . User ) . from_statement ( stmt ) . params ( fid = format_id ) . all ( ) [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = [ p . name for p in players ] [EOL] last_last_week = dtutil . now ( ) - dtutil . ts2dt ( [number] * [number] * [number] * [number] * [number] ) [EOL] for m in base_query . filter ( match . Match . start_time < last_week ) . filter ( match . Match . start_time > last_last_week ) . order_by ( func . count ( match . Match . format_id ) . desc ( ) ) . all ( ) : [EOL] ( format_id , format_name , num_matches ) = m [EOL] val [ [string] ] [ format_name ] [ [string] ] = { } [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = num_matches [EOL] stmt = text ( [string] ) [EOL] players = db . DB . session . query ( db . User ) . from_statement ( stmt ) . params ( fid = format_id ) . all ( ) [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = [ p . name for p in players ] [EOL] [EOL] last_month = dtutil . now ( ) - dtutil . ts2dt ( [number] * [number] * [number] * [number] ) [EOL] for m in base_query . filter ( match . Match . start_time > last_month ) . order_by ( func . count ( match . Match . format_id ) . desc ( ) ) . all ( ) : [EOL] ( format_id , format_name , num_matches ) = m [EOL] val [ [string] ] [ format_name ] [ [string] ] = { } [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = num_matches [EOL] stmt = text ( [string] ) [EOL] players = db . DB . session . query ( db . User ) . from_statement ( stmt ) . params ( fid = format_id ) . all ( ) [EOL] val [ [string] ] [ format_name ] [ [string] ] [ [string] ] = [ p . name for p in players ] [EOL] return return_json ( val ) [EOL] [EOL] def calc_last_switcheroo ( ) : [EOL] return match . Match . query . filter ( match . Match . has_unexpected_third_game ) . order_by ( match . Match . id . desc ( ) ) . first ( ) [EOL] [EOL] @ APP . route ( [string] ) def recent_json ( ) : [EOL] last_week = dtutil . now ( ) - dtutil . ts2dt ( [number] * [number] * [number] * [number] ) [EOL] val = { } [EOL] val [ [string] ] = { } [EOL] last_f = { } [EOL] for m in match . Match . query . filter ( match . Match . start_time > last_week ) . all ( ) : [EOL] f = m . format [EOL] if val [ [string] ] . get ( f . name , None ) is None : [EOL] val [ [string] ] [ f . name ] = { } [EOL] time = dtutil . dt2ts ( m . start_time_aware ( ) . replace ( microsecond = [number] , second = [number] , minute = [number] ) ) [EOL] last = last_f . get ( f . name , None ) [EOL] if last is not None : [EOL] while last < time : [EOL] last = last + [number] [EOL] val [ [string] ] [ f . name ] [ last ] = val [ [string] ] [ f . name ] . get ( last , [number] ) [EOL] else : [EOL] last = time [EOL] last_f [ f . name ] = last [EOL] val [ [string] ] [ f . name ] [ time ] = val [ [string] ] [ f . name ] . get ( time , [number] ) + [number] [EOL] [EOL] return return_json ( val ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , Tuple , Any [EOL] import logsite [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] from typing import Dict , Tuple [EOL] [EOL] from flask import Response , request , session [EOL] [EOL] from shared_web . api import return_json , validate_api_key [EOL] [EOL] from . import APP , db , importing [EOL] from . data import game , match [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) def admin ( ) : [EOL] return return_json ( session . get ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) @ APP . route ( [string] ) def person_status ( ) : [EOL] r = { [string] : session . get ( [string] ) , [string] : session . get ( [string] ) , [string] : session . get ( [string] , False ) , [string] : request . cookies . get ( [string] , False ) , } [EOL] return return_json ( r ) [EOL] [EOL] @ APP . route ( [string] ) def match_exists ( match_id ) : [EOL] return return_json ( match . get_match ( match_id ) is not None ) [EOL] [EOL] @ APP . route ( [string] ) def person_data ( person ) : [EOL] return return_json ( list ( match . Match . query . filter ( match . Match . players . any ( db . User . name == person ) ) ) ) [EOL] [EOL] @ APP . route ( [string] ) def match_data ( match_id ) : [EOL] return return_json ( match . get_match ( match_id ) ) [EOL] [EOL] @ APP . route ( [string] ) def game_data ( game_id ) : [EOL] return return_json ( game . get_game ( game_id ) ) [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def upload ( ) : [EOL] error = validate_api_key ( ) [EOL] if error : [EOL] return error [EOL] match_id = int ( request . form [ [string] ] ) [EOL] if match_id == [number] : [EOL] return return_json ( { [string] : True } ) [comment] [EOL] if request . form . get ( [string] ) : [EOL] lines = request . form [ [string] ] [EOL] importing . import_log ( lines . split ( [string] ) , match_id ) [EOL] else : [EOL] importing . import_from_pdbot ( match_id ) [EOL] start_time = int ( request . form [ [string] ] ) [EOL] end_time = int ( request . form [ [string] ] ) [EOL] match . get_match ( match_id ) . set_times ( start_time , end_time ) [EOL] [EOL] return return_json ( { [string] : True } ) [EOL] [EOL] @ APP . route ( [string] ) def export ( match_id ) : [EOL] local = match . get_match ( match_id ) [EOL] text = [string] . format ( format = local . format . name , comment = local . comment , mods = [string] . join ( [ m . name for m in local . modules ] ) , players = [string] . join ( [ p . name for p in local . players ] ) ) [EOL] n = [number] [EOL] for g in local . games : [EOL] text += [string] . format ( n = n , id = g . id ) [EOL] n = n + [number] [EOL] text += g . sanitized_log ( ) . strip ( ) [EOL] text += [string] [EOL] text = text . replace ( [string] , [string] ) [EOL] return ( text , [number] , { [string] : [string] , [string] : [string] . format ( match_id = match_id ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.int,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , Any [EOL] import typing [EOL] import shared [EOL] from shared import configuration [EOL] from shared . container import Container [EOL] from shared . database import Database , get_database [EOL] [EOL] DATABASE = Container ( ) [EOL] [EOL] def db ( ) : [EOL] if not DATABASE . get ( [string] ) : [EOL] DATABASE . logsite_database = get_database ( configuration . get_str ( [string] ) ) [EOL] return DATABASE . logsite_database [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import shared_web [EOL] import builtins [EOL] import typing [EOL] import subprocess [EOL] from typing import Dict , List , Union [EOL] [EOL] from flask import url_for [EOL] from sqlalchemy import create_engine [EOL] from sqlalchemy_utils import create_database , database_exists [EOL] [EOL] from shared import configuration [EOL] from shared_web . flask_app import PDFlask [EOL] [EOL] APP = PDFlask ( __name__ ) [EOL] [EOL] APP . config [ [string] ] = False [EOL] APP . config [ [string] ] = [string] . format ( user = configuration . get ( [string] ) , password = configuration . get ( [string] ) , host = configuration . get ( [string] ) , port = configuration . get ( [string] ) , db = configuration . get ( [string] ) ) [EOL] [EOL] from . import db , stats , api , views [comment] [EOL] [EOL] def __create_schema ( ) : [EOL] engine = create_engine ( APP . config [ [string] ] ) [EOL] if not database_exists ( engine . url ) : [EOL] create_database ( engine . url ) [EOL] db . DB . create_all ( ) [EOL] engine . dispose ( ) [EOL] [EOL] APP . config [ [string] ] = subprocess . check_output ( [ [string] , [string] , [string] ] ) [EOL] APP . config [ [string] ] = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] ) . strip ( ) . decode ( ) [EOL] APP . config [ [string] ] = configuration . get ( [string] ) [EOL] [EOL] def build_menu ( ) : [EOL] menu = [ { [string] : [string] , [string] : url_for ( [string] ) } , { [string] : [string] , [string] : url_for ( [string] ) } , { [string] : [string] , [string] : url_for ( [string] ) } , { [string] : [string] , [string] : url_for ( [string] ) } , { [string] : [string] , [string] : url_for ( [string] ) } , ] [EOL] return menu [EOL] [EOL] APP . config [ [string] ] = build_menu [EOL] [EOL] __create_schema ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from flask import url_for [EOL] [EOL] from shared_web . base_view import BaseView [EOL] [EOL] [EOL] [comment] [EOL] class View ( BaseView ) : [EOL] def js_extra_url ( self ) : [EOL] pass [EOL] [EOL] def favicon_url ( self ) : [EOL] return url_for ( [string] , rest = [string] ) [EOL] [EOL] def favicon_152_url ( self ) : [EOL] return url_for ( [string] , rest = [string] ) [EOL] [EOL] def title ( self ) : [EOL] if not self . subtitle ( ) : [EOL] return [string] [EOL] return [string] . format ( subtitle = self . subtitle ( ) ) [EOL] [EOL] def subtitle ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0
import shared_web [EOL] import unittest [EOL] [EOL] import pytest [EOL] [EOL] from logsite import APP [EOL] from shared_web . smoke import SmokeTester [EOL] [EOL] [EOL] class LogsiteSmokeTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . tester = SmokeTester ( APP ) [EOL] [EOL] @ pytest . mark . functional def test_home ( self ) : [EOL] self . tester . data_test ( [string] , [string] ) [EOL] [EOL] @ pytest . mark . functional def test_some_pages ( self ) : [EOL] for path in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] self . tester . response_test ( path , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $shared_web.smoke.SmokeTester$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Type [EOL] import logsite [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] [EOL] import sqlalchemy as sa [comment] [EOL] [EOL] from . . import db [EOL] from . . db import DB as fsa [comment] [EOL] [EOL] [EOL] class TournamentInfo ( fsa . Model ) : [comment] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] match_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] tournament_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] round_num = sa . Column ( sa . Integer ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . match_id , [string] : self . tournament_id , [string] : self . round_num , } [EOL] [EOL] [EOL] class Tournament ( fsa . Model ) : [comment] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String ( length = [number] ) , unique = True , index = True ) [EOL] active = sa . Column ( sa . Boolean ) [EOL] [EOL] [EOL] def get_tournament ( name ) : [EOL] return Tournament . query . filter_by ( name = name ) . one_or_none ( ) [EOL] [EOL] [EOL] def create_tournament ( name ) : [EOL] local = Tournament ( name = name , active = True ) [EOL] db . add ( local ) [EOL] db . commit ( ) [EOL] return local [EOL] [EOL] [EOL] def create_tournament_info ( match_id , tournament_id ) : [EOL] local = TournamentInfo ( match_id = match_id , tournament_id = tournament_id ) [EOL] db . add ( local ) [EOL] db . commit ( ) [EOL] return local [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[logsite.data.tournament.TournamentInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.tournament.TournamentInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.tournament.TournamentInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.tournament.TournamentInfo]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[logsite.data.tournament.Tournament]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.tournament.Tournament]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.tournament.Tournament]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Tournament$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Tournament$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TournamentInfo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , List , Any , Type [EOL] import builtins [EOL] import db [EOL] import logsite [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import pytz [EOL] import sqlalchemy as sa [comment] [EOL] from flask import url_for [EOL] [EOL] from shared import dtutil [EOL] [EOL] from . . import db [EOL] from . . db import DB as fsa [comment] [EOL] [EOL] [comment] [EOL] [EOL] class Match ( fsa . Model ) : [comment] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True , autoincrement = False ) [EOL] format_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) ) [EOL] comment = sa . Column ( sa . String ( [number] ) ) [EOL] start_time = sa . Column ( sa . DateTime ) [EOL] end_time = sa . Column ( sa . DateTime ) [EOL] [EOL] has_unexpected_third_game = sa . Column ( sa . Boolean ) [EOL] is_league = sa . Column ( sa . Boolean ) [EOL] is_tournament = sa . Column ( sa . Boolean ) [EOL] [comment] [EOL] [EOL] players = fsa . relationship ( [string] , secondary = db . MATCH_PLAYERS ) [EOL] modules = fsa . relationship ( [string] , secondary = db . MATCH_MODULES ) [EOL] games = fsa . relationship ( [string] , backref = [string] ) [EOL] format = fsa . relationship ( [string] ) [EOL] tournament = fsa . relationship ( [string] , backref = [string] ) [EOL] [EOL] def url ( self ) : [EOL] return url_for ( [string] , match_id = self . id ) [EOL] [EOL] def format_name ( self ) : [EOL] return self . format . get_name ( ) [EOL] [EOL] def host ( self ) : [EOL] return self . players [ [number] ] [EOL] [EOL] def other_players ( self ) : [EOL] return self . players [ [number] : ] [EOL] [EOL] def other_player_names ( self ) : [EOL] return [ p . name for p in self . other_players ( ) ] [EOL] [EOL] def set_times ( self , start_time , end_time ) : [EOL] self . start_time = dtutil . ts2dt ( start_time ) [EOL] self . end_time = dtutil . ts2dt ( end_time ) [EOL] db . commit ( ) [EOL] [EOL] def start_time_aware ( self ) : [EOL] if self . start_time is None : [EOL] return None [EOL] return pytz . utc . localize ( self . start_time ) [EOL] [EOL] def end_time_aware ( self ) : [EOL] if self . end_time is None : [EOL] return None [EOL] return pytz . utc . localize ( self . end_time ) [EOL] [EOL] def display_date ( self ) : [EOL] start = self . start_time_aware ( ) [EOL] if start is None : [EOL] return [string] [EOL] return dtutil . display_date ( start ) [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . format . get_name ( ) , [string] : self . comment , [string] : self . start_time_aware ( ) , [string] : self . end_time_aware ( ) , [string] : [ p . name for p in self . players ] , [string] : [ { [string] : g . id , [string] : url_for ( [string] , game_id = g . id , _external = True ) } for g in self . games ] , [string] : self . tournament if self . tournament is not None else None , [string] : url_for ( [string] , match_id = self . id , _external = True ) , [string] : url_for ( [string] , match_id = self . id , _external = True ) , } [EOL] [EOL] def create_match ( match_id , format_name , comment , modules , players ) : [EOL] format_id = db . get_or_insert_format ( format_name ) . id [EOL] local = Match ( id = match_id , format_id = format_id , comment = comment ) [EOL] modules = [ db . get_or_insert_module ( mod ) for mod in modules ] [EOL] local . modules = modules [EOL] local . players = [ db . get_or_insert_user ( user ) for user in set ( players ) ] [EOL] db . add ( local ) [EOL] db . commit ( ) [EOL] return local [EOL] [EOL] def get_match ( match_id ) : [EOL] return Match . query . filter_by ( id = match_id ) . one_or_none ( ) [EOL] [EOL] def get_recent_matches ( ) : [EOL] return Match . query . order_by ( Match . id . desc ( ) ) [EOL] [EOL] def get_recent_matches_by_player ( name ) : [EOL] return Match . query . filter ( Match . players . any ( db . User . name == name ) ) . order_by ( Match . id . desc ( ) ) [EOL] [EOL] def get_recent_matches_by_format ( format_id ) : [EOL] return Match . query . filter ( Match . format_id == format_id ) . order_by ( Match . id . desc ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[logsite.data.match.Match]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $db.User$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[db.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Match , List [EOL] import data [EOL] import logsite [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] from . . import importing [EOL] from . . data . match import Match [EOL] [EOL] [EOL] def import_log ( match_id ) : [EOL] fname = [string] . format ( path = os . path . dirname ( __file__ ) , filename = [string] . format ( match_id ) ) [EOL] with open ( fname ) as fhandle : [EOL] lines = fhandle . readlines ( ) [EOL] return importing . import_log ( lines , match_id ) [EOL] [EOL] def test_import_league ( ) : [EOL] import_log ( [number] ) [EOL] [EOL] def test_import_tourney ( ) : [EOL] local = import_log ( [number] ) [EOL] assert local . is_tournament [EOL] assert local . tournament is not None [EOL] [EOL] def test_import_switcheroo ( ) : [EOL] local = import_log ( [number] ) [EOL] assert local . has_unexpected_third_game [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . about import About [EOL] from . charts import Charts [EOL] from . home import Home [EOL] from . internal_server_error import InternalServerError [EOL] from . match_view import Match [EOL] from . matches import Matches [EOL] from . not_found import NotFound [EOL] from . people import People [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , Optional , Any [EOL] import logsite [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] from flask import url_for [EOL] from sqlalchemy import text [EOL] [EOL] from logsite . view import View [EOL] from shared import redis_wrapper as redis [EOL] [EOL] from . . import APP , db [EOL] from . . data import match [EOL] [EOL] [EOL] @ APP . route ( [string] ) def people ( ) : [EOL] view = People ( ) [EOL] return view . page ( ) [EOL] [EOL] [comment] [EOL] class People ( View ) : [EOL] def __init__ ( self ) : [EOL] people_query = db . User . query . order_by ( db . User . name . asc ( ) ) . paginate ( ) [EOL] self . people = people_query . items [EOL] self . has_next = people_query . has_next [EOL] self . has_prev = people_query . has_prev [EOL] self . has_pagination = self . has_next or self . has_prev [EOL] if people_query . has_next : [EOL] self . next_url = url_for ( [string] , page = people_query . next_num ) [EOL] if people_query . has_prev : [EOL] self . prev_url = url_for ( [string] , page = people_query . prev_num ) [EOL] [EOL] def prepare ( self ) : [EOL] for p in self . people : [EOL] key = f' [string] { p . id }' [EOL] data = redis . get_container ( key , ex = [number] ) [EOL] if data : [EOL] p . fav_format = data . fav_format [EOL] p . num_matches = data . num_matches [EOL] else : [EOL] p . num_matches = match . get_recent_matches_by_player ( p . name ) . count ( ) [EOL] stmt = text ( [string] ) [EOL] p . formats = db . DB . session . query ( [string] , [string] ) . from_statement ( stmt ) . params ( pid = p . id ) . all ( ) [EOL] if p . formats : [EOL] p . fav_format = [string] . format ( p . formats [ [number] ] [ [number] ] , p . formats [ [number] ] [ [number] ] ) [EOL] else : [EOL] p . fav_format = [string] [EOL] redis . store ( key , { [string] : p . fav_format , [string] : p . num_matches } , ex = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Optional[shared.container.Container]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Optional[shared.container.Container]$ 0 0 0 0 0 0 $typing.Optional[shared.container.Container]$ 0 0 0 0 0 0 0 $typing.Optional[shared.container.Container]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from logsite . views . error import Error [EOL] [EOL] [EOL] [comment] [EOL] class NotFound ( Error ) : [EOL] def message ( self ) : [EOL] return [string] [EOL] [EOL] def subtitle ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
import builtins [EOL] from logsite . view import View [EOL] [EOL] [EOL] class Error ( View ) : [EOL] def __init__ ( self , exception ) : [EOL] self . exception = str ( exception ) [EOL] self . card = None [EOL] self . cards = [ self . card ] [EOL] [EOL] def template ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Match , Any [EOL] import data [EOL] import logsite [EOL] import builtins [EOL] import typing [EOL] import html [EOL] [EOL] import inflect [EOL] import titlecase [EOL] from flask import url_for [EOL] [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] from . . import APP , importing [EOL] from . . data import match [EOL] from . . view import View [EOL] [EOL] [EOL] @ APP . route ( [string] ) def show_match ( match_id ) : [EOL] view = Match ( match . get_match ( match_id ) ) [EOL] return view . page ( ) [EOL] [EOL] [comment] [EOL] class Match ( View ) : [EOL] def __init__ ( self , viewed_match ) : [EOL] if not viewed_match : [EOL] raise DoesNotExistException ( ) [EOL] self . match = viewed_match [EOL] self . id = viewed_match . id [EOL] self . comment = viewed_match . comment [EOL] self . format_name = viewed_match . format_name ( ) [EOL] self . players_string = [string] . join ( [ p . name for p in viewed_match . players ] ) [EOL] self . players_string_safe = [string] . join ( [ player_link ( p . name ) for p in viewed_match . players ] ) [EOL] self . module_string = [string] . join ( [ m . name for m in viewed_match . modules ] ) [EOL] if not viewed_match . games : [EOL] self . no_games = True [EOL] return [EOL] self . game_one = viewed_match . games [ [number] ] [EOL] self . has_game_two = False [EOL] self . has_game_three = False [EOL] if len ( viewed_match . games ) > [number] : [EOL] self . has_game_two = True [EOL] self . game_two = viewed_match . games [ [number] ] [EOL] if len ( viewed_match . games ) > [number] : [EOL] self . has_game_three = True [EOL] self . game_three = viewed_match . games [ [number] ] [EOL] if viewed_match . has_unexpected_third_game is None : [EOL] importing . reimport ( viewed_match ) [EOL] self . has_unexpected_third_game = viewed_match . has_unexpected_third_game [EOL] if viewed_match . is_tournament is None : [EOL] importing . reimport ( viewed_match ) [EOL] self . is_tournament = viewed_match . is_tournament [EOL] [EOL] def og_title ( self ) : [EOL] return self . players_string [EOL] [EOL] def og_url ( self ) : [EOL] return url_for ( [string] , match_id = self . id , _external = True ) [EOL] [EOL] def og_description ( self ) : [EOL] p = inflect . engine ( ) [EOL] fmt = titlecase . titlecase ( p . a ( self . format_name ) ) [EOL] description = [string] . format ( fmt = fmt ) [EOL] return description [EOL] [EOL] def player_link ( name ) : [EOL] url = url_for ( [string] , person = name ) [EOL] return [string] . format ( url = html . escape ( url ) , name = html . escape ( name ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $data.match.Match$ 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 $logsite.data.match.Match$ 0 $data.match.Match$ 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 0 $data.match.Match$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logsite [EOL] import builtins [EOL] from flask import url_for [EOL] [EOL] from logsite . view import View [EOL] [EOL] from . . import APP , db [EOL] from . . data import match [EOL] [EOL] [EOL] @ APP . route ( [string] ) def home ( ) : [EOL] view = Home ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] class Home ( View ) : [EOL] def __init__ ( self ) : [EOL] pd = db . get_or_insert_format ( [string] ) [EOL] self . matches = match . get_recent_matches_by_format ( pd . id ) . paginate ( per_page = [number] ) . items [EOL] self . matches_url = url_for ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logsite [EOL] import builtins [EOL] from flask_babel import gettext [EOL] [EOL] from logsite . view import View [EOL] [EOL] from . . import APP [EOL] [EOL] [EOL] @ APP . route ( [string] ) def about ( ) : [EOL] view = About ( ) [EOL] return view . page ( ) [EOL] [EOL] [comment] [EOL] class About ( View ) : [EOL] def subtitle ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def languages ( self ) : [EOL] return [string] . join ( [ locale . display_name for locale in APP . babel . list_translations ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from logsite . views . error import Error [EOL] [EOL] [EOL] [comment] [EOL] class InternalServerError ( Error ) : [EOL] def message ( self ) : [EOL] return [string] [EOL] [EOL] def subtitle ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional , Match [EOL] import builtins [EOL] import werkzeug [EOL] import logsite [EOL] import datetime [EOL] import typing [EOL] from flask import redirect , url_for [EOL] from flask_babel import gettext [EOL] from werkzeug . wrappers import Response [EOL] [EOL] from logsite . view import View [EOL] from shared import dtutil [EOL] [EOL] from . . import APP , stats [EOL] [EOL] [EOL] @ APP . route ( [string] ) def old_charts ( ) : [EOL] return redirect ( url_for ( [string] ) ) [EOL] [EOL] @ APP . route ( [string] ) def charts ( ) : [EOL] view = Charts ( ) [EOL] return view . page ( ) [EOL] [EOL] [comment] [EOL] class Charts ( View ) : [EOL] def subtitle ( self ) : [EOL] return gettext ( [string] ) [EOL] [EOL] def js_extra_url ( self ) : [EOL] return url_for ( [string] , filename = [string] , v = self . commit_id ( ) ) [EOL] [EOL] def last_switcheroo ( self ) : [EOL] last_switcheroo = stats . calc_last_switcheroo ( ) [EOL] if last_switcheroo : [EOL] start = last_switcheroo . start_time_aware ( ) [EOL] diff = - [number] [EOL] if start is not None : [EOL] diff = dtutil . dt2ts ( dtutil . now ( ) ) - dtutil . dt2ts ( start ) [EOL] return dtutil . display_time ( diff ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Dict , Tuple , List , Any , Type [EOL] import builtins [EOL] import typing [EOL] import html [EOL] import re [EOL] import traceback [EOL] from typing import Dict , List , Tuple [EOL] [EOL] from magic import card , card_price , multiverse [EOL] from magic . database import db [EOL] from shared . pd_exception import DatabaseException , InvalidDataException [EOL] [EOL] PriceListType = List [ Tuple [ str , str , str ] ] [EOL] [EOL] CARDS = { } [EOL] [EOL] [EOL] def parse_cardhoarder_prices ( s ) : [EOL] details = [ ] [EOL] for line in s . splitlines ( ) [ [number] : ] : [comment] [EOL] if line . count ( [string] ) != [number] : [EOL] raise InvalidDataException ( [string] . format ( line = line ) ) [EOL] _mtgo_id , mtgo_set , _mtgjson_set , set_number , name , p , quantity = line . split ( [string] ) [comment] [EOL] name = html . unescape ( name . strip ( ) ) [EOL] if int ( quantity ) > [number] and not mtgo_set . startswith ( [string] ) and mtgo_set != [string] and mtgo_set != [string] and not re . search ( [string] , name ) : [EOL] details . append ( ( name , p , mtgo_set ) ) [EOL] return [ ( name_lookup ( name ) , html . unescape ( p . strip ( ) ) , mtgo_set ) for name , p , mtgo_set in details if name_lookup ( name ) is not None ] [EOL] [EOL] def parse_mtgotraders_prices ( s ) : [EOL] details = [ ] [EOL] for line in s . splitlines ( ) : [EOL] if line . count ( [string] ) != [number] : [EOL] raise InvalidDataException ( [string] . format ( line = line ) ) [EOL] mtgo_set , rarity , premium , name , number , p , image_path , in_stock_str = line . split ( [string] ) [comment] [EOL] in_stock_str = in_stock_str . replace ( [string] , [string] ) [EOL] assert in_stock_str in ( [string] , [string] ) [EOL] in_stock = in_stock_str == [string] [EOL] if name . endswith ( [string] ) or name . endswith ( [string] ) : [comment] [EOL] name = name [ : - [number] ] [EOL] if float ( p ) <= card_price . MAX_PRICE_TIX and in_stock and not is_exceptional_name ( name ) : [EOL] details . append ( ( name , p , mtgo_set ) ) [EOL] return [ ( name_lookup ( name ) , p , mtgo_set ) for name , p , mtgo_set in details if name_lookup ( name ) is not None ] [EOL] [EOL] def is_exceptional_name ( name ) : [EOL] return name . startswith ( [string] ) or [string] in name or name . startswith ( [string] ) or name . startswith ( [string] ) or [string] in name [EOL] [EOL] def name_lookup ( name ) : [EOL] if name == [string] : [EOL] name = [string] [EOL] elif name == [string] : [EOL] name = [string] [EOL] try : [EOL] if not CARDS : [EOL] rs = db ( ) . select ( multiverse . base_query ( ) ) [EOL] for row in rs : [EOL] CARDS [ card . canonicalize ( row [ [string] ] ) ] = row [ [string] ] [EOL] except DatabaseException : [EOL] tb = traceback . format_exc ( ) [EOL] print ( tb ) [EOL] if not CARDS : [EOL] CARDS [ [string] ] = [string] [comment] [EOL] [EOL] canonical = card . canonicalize ( name ) [EOL] if canonical not in CARDS : [EOL] if CARDS . get ( [string] , None ) is None : [EOL] print ( [string] . format ( name = name , canonical = canonical ) ) [EOL] return name [EOL] return CARDS [ canonical ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $PriceListType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PriceListType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0
	0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import json [EOL] from typing import Optional [EOL] [EOL] from flask import Flask [EOL] [EOL] from magic import multiverse , oracle [EOL] from price_grabber import price [EOL] from shared . serialization import extra_serializer [EOL] [EOL] SRV = Flask ( __name__ ) [EOL] [EOL] @ SRV . route ( [string] ) def cardprice ( card ) : [EOL] if card == [string] : [EOL] return None [EOL] card = card . replace ( [string] , [string] ) [EOL] return json . dumps ( price . info_cached ( name = card ) , default = extra_serializer ) [EOL] [EOL] def init ( ) : [EOL] multiverse . init ( ) [EOL] oracle . init ( ) [EOL] SRV . run ( port = [number] , host = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.app.Flask$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import magic [EOL] import time [EOL] from typing import Optional [EOL] [EOL] from magic import card_price , rotation [EOL] from magic . abc import PriceDataType [EOL] from magic . models import Card [EOL] from shared import configuration , database [EOL] [EOL] [EOL] def info ( card , force = False ) : [EOL] if not force : [EOL] r = info_cached ( card ) [EOL] if r is not None : [EOL] return r [EOL] cache ( ) [EOL] return info_cached ( card ) [EOL] [EOL] def info_cached ( card = None , name = None ) : [EOL] if name is None and card is not None : [EOL] name = card . name [EOL] sql = [string] [EOL] db = database . get_database ( configuration . get_str ( [string] ) ) [EOL] try : [EOL] return db . select ( sql , [ name ] ) [ [number] ] [comment] [EOL] except IndexError : [EOL] return None [EOL] [EOL] def cache ( ) : [EOL] db = database . get_database ( configuration . get_str ( [string] ) ) [EOL] [EOL] now = round ( time . time ( ) ) [EOL] week = now - [number] * [number] * [number] * [number] [EOL] month = now - [number] * [number] * [number] * [number] [EOL] last_rotation = int ( rotation . last_rotation ( ) . timestamp ( ) ) [EOL] [EOL] sql = [string] [EOL] latest = db . value ( sql ) [EOL] [EOL] db . begin ( [string] ) [EOL] db . execute ( [string] ) [EOL] sql = f""" [string] { card_price . MAX_PRICE_CENTS } [string] { card_price . MAX_PRICE_CENTS } [string] { card_price . MAX_PRICE_CENTS } [string] """ [EOL] db . execute ( sql , [ latest , last_rotation , last_rotation , week , week , month , month , last_rotation , last_rotation ] ) [EOL] db . commit ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[magic.abc.PriceDataType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[magic.abc.PriceDataType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , List , Any [EOL] import builtins [EOL] import shared [EOL] import datetime [EOL] import price_grabber [EOL] import typing [EOL] import datetime [EOL] import itertools [EOL] import sys [EOL] from typing import Dict , List , Optional [EOL] [EOL] import ftfy [EOL] [EOL] from magic import multiverse , oracle , rotation [EOL] from price_grabber import parser , price [EOL] from shared import configuration , dtutil , fetch_tools [EOL] from shared . database import get_database [EOL] from shared . pd_exception import DatabaseException , TooFewItemsException [EOL] [EOL] DATABASE = get_database ( configuration . get_str ( [string] ) ) [EOL] [EOL] def run ( ) : [EOL] multiverse . init ( ) [EOL] oracle . init ( ) [EOL] fetch ( ) [EOL] price . cache ( ) [EOL] [EOL] def fetch ( ) : [EOL] all_prices , timestamps = { } , [ ] [EOL] ch_urls = configuration . get_list ( [string] ) [EOL] if ch_urls : [EOL] for _ , url in enumerate ( ch_urls ) : [EOL] s = fetch_tools . fetch ( url ) [EOL] s = ftfy . fix_encoding ( s ) [EOL] timestamps . append ( dtutil . parse_to_ts ( s . split ( [string] , [number] ) [ [number] ] . replace ( [string] , [string] ) , [string] , dtutil . CARDHOARDER_TZ ) ) [EOL] all_prices [ url ] = parser . parse_cardhoarder_prices ( s ) [EOL] url = configuration . get_str ( [string] ) [EOL] if url : [EOL] s = fetch_tools . fetch ( url ) [EOL] timestamps . append ( dtutil . dt2ts ( dtutil . now ( ) ) ) [EOL] all_prices [ [string] ] = parser . parse_mtgotraders_prices ( s ) [EOL] if not timestamps : [EOL] raise TooFewItemsException ( [string] . format ( urls = itertools . chain ( configuration . get_list ( [string] ) , [ configuration . get_str ( [string] ) ] ) , all_prices = all_prices ) ) [EOL] count = store ( min ( timestamps ) , all_prices ) [EOL] cleanup ( count ) [EOL] [EOL] def store ( timestamp , all_prices ) : [EOL] DATABASE . begin ( [string] ) [EOL] lows = { } [EOL] for code in all_prices : [EOL] prices = all_prices [ code ] [EOL] for name , p , _ in prices : [EOL] cents = int ( float ( p ) * [number] ) [EOL] if cents < lows . get ( name , sys . maxsize ) : [EOL] lows [ name ] = cents [EOL] count = [number] [EOL] while lows : [EOL] count = count + [number] [EOL] sql = [string] [EOL] chunk = [ ] [EOL] try : [EOL] for _ in range ( [number] , [number] ) : [comment] [EOL] chunk . append ( lows . popitem ( ) ) [EOL] except KeyError : [EOL] pass [comment] [EOL] sql += [string] . join ( [ [string] ] * len ( chunk ) ) [EOL] values = [ ] [EOL] for name , cents in chunk : [EOL] values . extend ( [ timestamp , name , cents ] ) [EOL] execute ( sql , values ) [EOL] DATABASE . commit ( [string] ) [EOL] return count * [number] [EOL] [EOL] def cleanup ( count = [number] ) : [EOL] beginning_of_season = rotation . last_rotation ( ) [EOL] one_month_ago = dtutil . now ( dtutil . WOTC_TZ ) - datetime . timedelta ( [number] ) [EOL] oldest_needed = min ( beginning_of_season , one_month_ago ) [EOL] limit = [string] [EOL] if count > [number] : [EOL] limit = f' [string] { count * [number] }' [EOL] execute ( [string] + limit , [ dtutil . dt2ts ( oldest_needed ) ] ) [EOL] [EOL] def execute ( sql , values = None ) : [EOL] if values is None : [EOL] values = [ ] [EOL] try : [EOL] DATABASE . execute ( sql , values ) [EOL] except DatabaseException as e : [EOL] print ( e ) [EOL] [comment] [EOL] create_tables ( ) [EOL] execute ( sql , values ) [EOL] [EOL] def create_tables ( ) : [EOL] print ( [string] ) [EOL] sql = [string] [EOL] execute ( sql ) [EOL] sql = [string] [EOL] execute ( sql ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Set , Tuple , List , Any [EOL] import io [EOL] import builtins [EOL] import pathlib [EOL] import datetime [EOL] import price_grabber [EOL] import typing [EOL] import datetime [EOL] import fileinput [EOL] import os [EOL] import pathlib [EOL] import shutil [EOL] import subprocess [EOL] from collections import Counter [EOL] from typing import Dict , List , Set [EOL] [EOL] import ftfy [EOL] [EOL] from magic import card_price , fetcher , rotation [EOL] from price_grabber . parser import PriceListType , parse_cardhoarder_prices , parse_mtgotraders_prices [EOL] from shared import configuration , dtutil , fetch_tools [EOL] from shared import redis_wrapper as redis [EOL] from shared import repo , text [EOL] [EOL] TIME_UNTIL_ROTATION = rotation . next_rotation ( ) - dtutil . now ( ) [EOL] BANNED_CARDS = [ [string] , [string] ] [comment] [EOL] [EOL] def run ( ) : [EOL] files = rotation . files ( ) [EOL] n = len ( files ) [EOL] time_until = TIME_UNTIL_ROTATION - datetime . timedelta ( weeks = [number] ) [EOL] if n >= rotation . TOTAL_RUNS : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] if n == [number] and TIME_UNTIL_ROTATION > datetime . timedelta ( [number] ) : [EOL] print ( [string] ) [EOL] print ( [string] . format ( t = dtutil . display_time ( int ( time_until . total_seconds ( ) ) ) ) ) [EOL] return [EOL] [EOL] if n == [number] : [EOL] rotation . clear_redis ( clear_files = True ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] all_prices = { } [EOL] for url in configuration . get_list ( [string] ) : [EOL] s = fetch_tools . fetch ( url ) [EOL] s = ftfy . fix_encoding ( s ) [EOL] all_prices [ url ] = parse_cardhoarder_prices ( s ) [EOL] url = configuration . get_str ( [string] ) [EOL] if url : [EOL] s = fetch_tools . fetch ( url ) [EOL] all_prices [ [string] ] = parse_mtgotraders_prices ( s ) [EOL] [EOL] run_number = process ( all_prices ) [EOL] if run_number == rotation . TOTAL_RUNS : [EOL] make_final_list ( ) [EOL] [EOL] try : [EOL] url = f'{ fetcher . decksite_url ( ) } [string] ' [EOL] fetch_tools . fetch ( url ) [EOL] except Exception as c : [comment] [EOL] print ( c ) [EOL] [EOL] def process ( all_prices ) : [EOL] seen_sets = set ( ) [EOL] used_sets = set ( ) [EOL] [EOL] hits = set ( ) [EOL] for code in all_prices : [EOL] prices = all_prices [ code ] [EOL] for name , p , mtgo_set in prices : [EOL] cents = int ( float ( p ) * [number] ) [EOL] seen_sets . add ( mtgo_set ) [EOL] if cents <= card_price . MAX_PRICE_CENTS : [EOL] hits . add ( name ) [EOL] used_sets . add ( mtgo_set ) [EOL] ignored = seen_sets - used_sets [EOL] return process_sets ( seen_sets , used_sets , hits , ignored ) [EOL] [EOL] [EOL] def process_sets ( seen_sets , used_sets , hits , ignored ) : [EOL] files = rotation . files ( ) [EOL] n = len ( files ) + [number] [EOL] path = os . path . join ( configuration . get_str ( [string] ) , [string] ) . format ( n = str ( n ) . zfill ( [number] ) ) [EOL] path = os . path . expanduser ( path ) [EOL] h = open ( path , mode = [string] , encoding = [string] ) [EOL] for card in hits : [EOL] line = card + [string] [EOL] h . write ( line ) [EOL] h . close ( ) [EOL] print ( [string] . format ( n = n , ccards = len ( hits ) , csets = len ( used_sets ) , tsets = len ( seen_sets ) ) ) [EOL] print ( [string] . format ( sets = repr ( used_sets ) ) ) [EOL] print ( [string] . format ( sets = repr ( ignored ) ) ) [EOL] return n [EOL] [EOL] def make_final_list ( ) : [EOL] planes = fetch_tools . fetch_json ( [string] ) [ [string] ] [EOL] bad_names = [ p [ [string] ] for p in planes ] [EOL] bad_names . extend ( BANNED_CARDS ) [EOL] files = rotation . files ( ) [EOL] lines = [ ] [EOL] for line in fileinput . input ( files ) : [EOL] line = text . sanitize ( line ) [EOL] if line . strip ( ) in bad_names : [EOL] continue [EOL] lines . append ( line ) [EOL] scores = Counter ( lines ) . most_common ( ) [EOL] [EOL] passed = [ ] [EOL] for name , count in scores : [EOL] if count >= rotation . TOTAL_RUNS / [number] : [EOL] passed . append ( name ) [EOL] final = list ( passed ) [EOL] final . sort ( ) [EOL] h = open ( os . path . join ( configuration . get_str ( [string] ) , [string] ) , mode = [string] , encoding = [string] ) [EOL] h . write ( [string] . join ( final ) ) [EOL] h . close ( ) [EOL] print ( [string] . format ( len ( passed ) , len ( scores ) ) ) [EOL] setcode = rotation . next_rotation_ex ( ) . mtgo_code [EOL] h = open ( os . path . join ( configuration . get_str ( [string] ) , f'{ setcode } [string] ' ) , mode = [string] , encoding = [string] ) [EOL] h . write ( [string] . join ( final ) ) [EOL] h . close ( ) [EOL] [EOL] do_push ( ) [EOL] [EOL] def do_push ( ) : [EOL] gh_repo = os . path . join ( configuration . get_str ( [string] ) , [string] ) [EOL] if not os . path . exists ( gh_repo ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , gh_repo ] , check = True ) [EOL] setcode = rotation . next_rotation_ex ( ) . mtgo_code [EOL] files = [ [string] , f'{ setcode } [string] ' ] [EOL] for fn in files : [EOL] source = os . path . join ( configuration . get_str ( [string] ) , fn ) [EOL] dest = os . path . join ( gh_repo , fn ) [EOL] shutil . copy ( source , dest ) [EOL] [EOL] os . chdir ( gh_repo ) [EOL] subprocess . run ( [ [string] , [string] ] + files , check = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] , f'{ setcode } [string] ' ] , check = True ) [EOL] subprocess . run ( [ [string] , [string] ] , check = True ) [EOL] checklist = f"""{ setcode } [string] { setcode } [string] """ [EOL] if redis . get_str ( [string] ) : [EOL] redis . store ( [string] , True ) [EOL] else : [EOL] checklist += [string] [EOL] ds = os . path . expanduser ( [string] ) [EOL] failed = False [EOL] try : [EOL] if os . path . exists ( ds ) : [EOL] os . chdir ( ds ) [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL] else : [EOL] failed = True [EOL] except Exception : [comment] [EOL] failed = True [EOL] if failed : [EOL] checklist += [string] [EOL] [EOL] try : [EOL] fetch_tools . post ( [string] ) [EOL] except fetch_tools . FetchException : [EOL] checklist += [string] [EOL] [EOL] for path in [ [string] , [string] ] : [EOL] srv = pathlib . Path ( path ) [EOL] if srv . exists ( ) : [EOL] srv . touch ( ) [EOL] break [EOL] else : [EOL] checklist += [string] [EOL] repo . create_issue ( checklist , [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Set , List , Container , Any [EOL] import builtins [EOL] import magic [EOL] import typing_extensions [EOL] import shared [EOL] import typing [EOL] from typing import Dict , List , Set [EOL] [EOL] from magic import oracle , rotation [EOL] from magic . database import db [EOL] from magic . models import Card [EOL] from shared . container import Container [EOL] [EOL] FORMATS = set ( ) [EOL] [EOL] def legal_in_format ( d , f ) : [EOL] return f in legal_formats ( d , set ( [ f ] ) ) [EOL] [EOL] def legal_formats ( d , formats_to_check = None , errors = None ) : [EOL] init ( ) [EOL] if formats_to_check is None : [EOL] formats_to_check = FORMATS [EOL] if errors is None : [EOL] errors = { } [EOL] formats_to_discard = set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] if ( sum ( e [ [string] ] for e in d . maindeck ) + sum ( e [ [string] ] for e in d . sideboard ) ) <= [number] : [EOL] for f in formats_to_check : [EOL] add_error ( errors , f , [string] , [string] ) [EOL] formats_to_discard . add ( f ) [EOL] [comment] [EOL] return formats_to_check - formats_to_discard [EOL] [EOL] if sum ( e [ [string] ] for e in d . maindeck ) < [number] : [EOL] for f in formats_to_check : [EOL] add_error ( errors , f , [string] , [string] ) [EOL] formats_to_discard . add ( f ) [EOL] if sum ( e [ [string] ] for e in d . sideboard ) > [number] : [EOL] for f in formats_to_check : [EOL] add_error ( errors , f , [string] , [string] ) [EOL] formats_to_discard . add ( f ) [EOL] if ( sum ( e [ [string] ] for e in d . maindeck ) + sum ( e [ [string] ] for e in d . sideboard ) ) != [number] : [EOL] add_error ( errors , [string] , [string] , [string] ) [EOL] formats_to_discard . add ( [string] ) [EOL] card_count = { } [EOL] for c in d . all_cards ( ) : [EOL] if not c . type_line . startswith ( [string] ) and not [string] in c . oracle_text : [EOL] card_count [ c . name ] = card_count . get ( c . name , [number] ) + [number] [EOL] if card_count . values ( ) and max ( card_count . values ( ) ) > [number] : [EOL] affected_cards = [ ] [EOL] for k , v in card_count . items ( ) : [EOL] max_allowed = [number] if k == [string] else [number] [EOL] if v > max_allowed : [EOL] affected_cards . append ( k ) [EOL] if affected_cards : [EOL] for f in formats_to_check : [EOL] for card in affected_cards : [EOL] add_error ( errors , f , [string] , card ) [EOL] formats_to_discard . add ( f ) [EOL] elif card_count . values ( ) and max ( card_count . values ( ) ) > [number] : [EOL] add_error ( errors , [string] , [string] , [string] ) [EOL] formats_to_discard . add ( [string] ) [EOL] for c in set ( d . all_cards ( ) ) : [EOL] for f in formats_to_check : [EOL] if f not in c . legalities . keys ( ) or c . legalities [ f ] == [string] : [EOL] illegal = [string] if c . legalities . get ( f , None ) == [string] else [string] [EOL] add_error ( errors , f , [string] + illegal , c . name ) [EOL] formats_to_discard . add ( f ) [EOL] elif c . legalities [ f ] == [string] : [EOL] if card_count [ c . name ] > [number] : [EOL] formats_to_discard . add ( f ) [EOL] add_error ( errors , f , [string] , c . name ) [EOL] [EOL] return formats_to_check - formats_to_discard [EOL] [EOL] def add_error ( errors , fmt , error_type , card ) : [EOL] if fmt not in errors : [EOL] errors [ fmt ] = dict ( ) [EOL] if error_type not in errors [ fmt ] : [EOL] errors [ fmt ] [ error_type ] = set ( ) [EOL] errors [ fmt ] [ error_type ] . add ( card ) [EOL] [EOL] def cards_legal_in_format ( cardlist , f ) : [EOL] init ( ) [EOL] results = [ ] [EOL] for c in cardlist : [EOL] if f in c . legalities . keys ( ) and c . legalities [ f ] != [string] : [EOL] results . append ( c ) [EOL] return results [EOL] [EOL] def order_score ( fmt ) : [EOL] if fmt == [string] : [EOL] return [number] [EOL] if [string] in fmt : [EOL] return [number] - rotation . SEASONS . index ( fmt . replace ( [string] , [string] ) ) [EOL] if fmt == [string] : [EOL] return [number] [EOL] if fmt == [string] : [EOL] return [number] [EOL] if fmt == [string] : [EOL] return [number] [EOL] if fmt == [string] : [EOL] return [number] [EOL] if [string] in fmt : [EOL] return [number] [EOL] if fmt == [string] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] def init ( ) : [EOL] if FORMATS : [EOL] return [EOL] print ( [string] ) [EOL] oracle . legal_cards ( ) [EOL] [EOL] FORMATS . clear ( ) [EOL] for v in db ( ) . values ( [string] ) : [EOL] FORMATS . add ( v ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , List , Any , Type [EOL] import builtins [EOL] import whoosh [EOL] import typing [EOL] import itertools [EOL] import re [EOL] from typing import Any , List , Optional , Tuple [EOL] [EOL] import pygtrie [EOL] from whoosh . index import open_dir [EOL] from whoosh . query import And , FuzzyTerm , Or , Term [EOL] [EOL] from magic . whoosh_constants import WhooshConstants [EOL] [EOL] [EOL] [comment] [EOL] class SearchResult ( ) : [EOL] def __init__ ( self , exact , prefix_whole_word , other_prefixed , fuzzy ) : [EOL] self . exact = [ exact ] if exact else [ ] [EOL] self . prefix_whole_word = prefix_whole_word if prefix_whole_word else [ ] [EOL] self . other_prefixed = other_prefixed if other_prefixed else [ ] [EOL] self . fuzzy = prune_fuzzy_by_score ( fuzzy if fuzzy else [ ] ) [EOL] self . remove_duplicates ( ) [EOL] [EOL] def has_match ( self ) : [EOL] return bool ( has ( self . exact ) or has ( self . prefix_whole_word ) or has ( self . other_prefixed ) or has ( self . fuzzy ) ) [EOL] [EOL] def is_ambiguous ( self ) : [EOL] return bool ( not has ( self . exact ) and ( ( len ( self . prefix_whole_word ) > [number] ) or ( ( len ( self . prefix_whole_word ) == [number] ) and ( len ( self . other_prefixed ) > [number] ) ) or ( len ( self . prefix_whole_word ) == [number] and len ( self . other_prefixed ) == [number] and len ( self . fuzzy ) > [number] ) ) ) [EOL] [EOL] def get_best_match ( self ) : [EOL] if not self . has_match ( ) or self . is_ambiguous ( ) : [EOL] return None [EOL] if self . exact : [EOL] return self . exact [ [number] ] [EOL] if has ( self . prefix_whole_word ) : [EOL] return self . prefix_whole_word [ [number] ] [EOL] if has ( self . other_prefixed ) : [EOL] return self . other_prefixed [ [number] ] [EOL] return self . fuzzy [ [number] ] [EOL] [EOL] def get_ambiguous_matches ( self ) : [EOL] if not self . is_ambiguous ( ) : [EOL] return [ ] [EOL] if has ( self . prefix_whole_word ) : [EOL] return self . prefix_whole_word [EOL] if has ( self . other_prefixed ) : [EOL] return self . other_prefixed [EOL] return self . fuzzy [EOL] [EOL] def get_all_matches ( self ) : [EOL] if not self . has_match ( ) : [EOL] return [ ] [EOL] return [ r for r in itertools . chain ( self . exact , self . prefix_whole_word , self . other_prefixed , self . fuzzy ) if r is not None ] [EOL] [EOL] def remove_duplicates ( self ) : [EOL] for n in itertools . chain ( self . exact , self . prefix_whole_word , self . other_prefixed ) : [EOL] try : [EOL] self . fuzzy . remove ( n ) [EOL] except ValueError : [EOL] pass [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( e = self . exact , r = self . prefix_whole_word , o = self . other_prefixed , f = self . fuzzy ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return self . __str__ ( ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . get_all_matches ( ) ) [EOL] [EOL] class WhooshSearcher ( ) : [EOL] DIST = [number] [EOL] def __init__ ( self ) : [EOL] self . ix = open_dir ( WhooshConstants . index_dir ) [EOL] self . initialize_trie ( ) [EOL] [EOL] def initialize_trie ( self ) : [EOL] self . trie = pygtrie . CharTrie ( ) [EOL] with self . ix . reader ( ) as reader : [EOL] for doc in reader . iter_docs ( ) : [EOL] self . trie [ list ( WhooshConstants . normalized_analyzer ( doc [ [number] ] [ [string] ] ) ) [ [number] ] . text ] = doc [ [number] ] [ [string] ] [EOL] [EOL] def search ( self , w ) : [EOL] if not self . ix . up_to_date ( ) : [EOL] self . initialize_trie ( ) [comment] [EOL] [EOL] normalized = list ( WhooshConstants . normalized_analyzer ( w ) ) [ [number] ] . text [EOL] [EOL] [comment] [EOL] exact , prefix_whole_word , other_prefixed = self . find_matches_by_prefix ( normalized ) [EOL] if exact or len ( prefix_whole_word ) > [number] or len ( other_prefixed ) > [number] : [EOL] return SearchResult ( exact , prefix_whole_word , other_prefixed , [ ] ) [EOL] [EOL] [comment] [EOL] query_normalized = fuzzy_term ( normalized , self . DIST , [string] ) [EOL] query_stemmed = And ( [ Term ( [string] , q . text ) for q in WhooshConstants . stem_analyzer ( w ) ] ) [EOL] query_tokenized = And ( [ fuzzy_term ( q . text , self . DIST , [string] ) for q in WhooshConstants . tokenized_analyzer ( w ) ] ) [EOL] if len ( query_tokenized ) == [number] : [comment] [EOL] query = Or ( [ query_normalized , query_stemmed ] ) [EOL] else : [EOL] query = Or ( [ query_normalized , query_tokenized , query_stemmed ] ) [EOL] [EOL] with self . ix . searcher ( ) as searcher : [EOL] fuzzy = [ ( r [ [string] ] , r . score ) for r in searcher . search ( query , limit = [number] ) ] [EOL] return SearchResult ( exact , prefix_whole_word , other_prefixed , fuzzy ) [EOL] [EOL] def find_matches_by_prefix ( self , query ) : [EOL] exact = None [EOL] prefix_as_whole_word = [ ] [EOL] other_prefixed = [ ] [EOL] if self . trie . has_key ( query ) : [EOL] exact = self . trie . get ( query ) [EOL] if self . trie . has_subtrie ( query ) : [EOL] matches = self . trie . values ( query ) [ ( [number] if exact else [number] ) : ] [EOL] whole_word , subword = classify ( matches , query ) [EOL] prefix_as_whole_word . extend ( whole_word ) [EOL] other_prefixed . extend ( subword ) [EOL] return ( exact , prefix_as_whole_word , other_prefixed ) [EOL] [EOL] def has ( elements ) : [EOL] return bool ( elements and len ( elements ) > [number] ) [EOL] [EOL] WordSubwordType = Tuple [ List [ str ] , List [ str ] ] [EOL] [EOL] def classify ( matches , word ) : [EOL] regex = [string] . format ( w = word ) [EOL] acc = ( [ ] , [ ] ) [comment] [EOL] for match in matches : [EOL] if re . match ( regex , match . lower ( ) ) : [EOL] acc [ [number] ] . append ( match ) [EOL] else : [EOL] acc [ [number] ] . append ( match ) [EOL] return acc [EOL] [EOL] def fuzzy_term ( q , dist , field ) : [EOL] if len ( q ) <= [number] : [EOL] return Term ( field , q ) [EOL] return FuzzyTerm ( field , q , maxdist = dist , prefixlength = [number] ) [EOL] [EOL] def prune_fuzzy_by_score ( fuzzy ) : [EOL] if len ( fuzzy ) == [number] : [EOL] return [ ] [EOL] if len ( fuzzy ) == [number] : [EOL] return [ fuzzy [ [number] ] [ [number] ] ] [EOL] top = [ ] [EOL] low = fuzzy [ [number] ] [ [number] ] [EOL] for k , v in fuzzy : [EOL] if v >= fuzzy [ [number] ] [ [number] ] : [EOL] top . append ( k ) [EOL] else : [EOL] low = v [EOL] break [EOL] if fuzzy [ [number] ] [ [number] ] >= low * [number] : [EOL] return top [EOL] return [ f [ [number] ] for f in fuzzy ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.List[builtins.str],typing.List[builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Set , Sequence , Tuple , Iterable , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import magic [EOL] from typing import Dict , Iterable , List , Optional , Sequence , Tuple [EOL] [EOL] from magic import card , mana , multiverse , rotation [EOL] from magic . abc import CardDescription [EOL] from magic . database import db [EOL] from magic . models import Card , Printing [EOL] from shared import configuration , fetch_tools , guarantee [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . pd_exception import ( InvalidArgumentException , InvalidDataException , TooFewItemsException ) [EOL] [EOL] [comment] [EOL] [EOL] LEGAL_CARDS = [ ] [EOL] CARDS_BY_NAME = { } [EOL] [EOL] def init ( force = False ) : [EOL] if len ( CARDS_BY_NAME ) == [number] or force : [EOL] for c in load_cards ( ) : [EOL] CARDS_BY_NAME [ c . name ] = c [EOL] [EOL] def valid_name ( name ) : [EOL] if name in CARDS_BY_NAME : [EOL] return name [EOL] canonicalized = card . canonicalize ( name ) [EOL] for k in CARDS_BY_NAME : [EOL] if canonicalized == card . canonicalize ( k ) : [EOL] return k [EOL] raise InvalidDataException ( [string] . format ( name = name ) ) [EOL] [EOL] def load_card ( name ) : [EOL] return CARDS_BY_NAME . get ( name , load_cards ( [ name ] ) [ [number] ] ) [EOL] [EOL] def load_cards ( names = None , where = None ) : [EOL] if names : [EOL] setnames = set ( names ) [EOL] else : [EOL] setnames = set ( ) [EOL] if setnames : [EOL] names_clause = [string] . format ( names = [string] . join ( sqlescape ( name ) for name in setnames ) ) [EOL] else : [EOL] names_clause = [string] [EOL] if where is None : [EOL] where = [string] [EOL] sql = multiverse . cached_base_query ( [string] . format ( where = where , names = names_clause ) ) [EOL] rs = db ( ) . select ( sql ) [EOL] if setnames and len ( setnames ) != len ( rs ) : [EOL] missing = setnames . symmetric_difference ( [ r [ [string] ] for r in rs ] ) [EOL] raise TooFewItemsException ( [string] . format ( namelen = len ( setnames ) , rslen = len ( rs ) , names = setnames , missing = missing ) ) [EOL] return [ Card ( r ) for r in rs ] [EOL] [EOL] def cards_by_name ( ) : [EOL] return CARDS_BY_NAME [EOL] [EOL] def bugged_cards ( ) : [EOL] sql = multiverse . cached_base_query ( [string] ) [EOL] rs = db ( ) . select ( sql ) [EOL] return [ Card ( r ) for r in rs ] [EOL] [EOL] def legal_cards ( force = False ) : [EOL] if len ( LEGAL_CARDS ) == [number] or force : [EOL] db ( ) . execute ( [string] ) [EOL] sql = [string] [EOL] new_list = db ( ) . values ( sql ) [EOL] LEGAL_CARDS . clear ( ) [EOL] for name in new_list : [EOL] LEGAL_CARDS . append ( name ) [EOL] return LEGAL_CARDS [EOL] [EOL] def get_printings ( generalized_card ) : [EOL] sql = [string] + ( [string] . join ( [string] + property for property in card . printing_properties ( ) ) ) + [string] + [string] + [string] + [string] [EOL] rs = db ( ) . select ( sql , [ generalized_card . id ] ) [EOL] return [ Printing ( r ) for r in rs ] [EOL] [EOL] def get_printing ( generalized_card , setcode ) : [EOL] if setcode is None : [EOL] return None [EOL] sql = [string] + ( [string] . join ( [string] + property for property in card . printing_properties ( ) ) ) + [string] + [string] + [string] + [string] [EOL] rs = db ( ) . select ( sql , [ generalized_card . id , setcode ] ) [EOL] if rs : [EOL] return [ Printing ( r ) for r in rs ] [ [number] ] [EOL] return None [EOL] [EOL] def get_set ( set_id ) : [EOL] rs = db ( ) . select ( [string] + ( [string] . join ( property for property in card . set_properties ( ) ) ) + [string] , [ set_id ] ) [EOL] return guarantee . exactly_one ( [ Container ( r ) for r in rs ] ) [EOL] [EOL] def deck_sort ( c ) : [EOL] s = [string] [EOL] if c . is_creature ( ) : [EOL] s += [string] [EOL] elif c . is_land ( ) : [EOL] s += [string] [EOL] else : [EOL] s += [string] [EOL] m = [string] [EOL] for cost in c . get ( [string] ) or ( ) : [EOL] if mana . has_x ( cost ) : [EOL] m = [string] [EOL] s += m [EOL] s += str ( c . cmc ) . zfill ( [number] ) [EOL] s += c . name [EOL] return s [EOL] [EOL] async def scryfall_import_async ( name ) : [EOL] sfcard = await fetch_tools . fetch_json_async ( [string] . format ( name = name ) ) [EOL] if sfcard [ [string] ] == [string] : [EOL] raise Exception ( ) [EOL] try : [EOL] valid_name ( sfcard [ [string] ] ) [EOL] print ( f" [string] { sfcard [ [string] ] } [string] " ) [EOL] return False [EOL] except InvalidDataException : [EOL] print ( f" [string] { sfcard [ [string] ] } [string] " ) [EOL] await add_cards_and_update_async ( [ sfcard ] ) [EOL] return True [EOL] [EOL] def pd_rotation_changes ( season_id ) : [EOL] [comment] [EOL] if season_id == [number] : [EOL] season_id = rotation . current_season_num ( ) [EOL] try : [EOL] from_format_id = multiverse . get_format_id_from_season_id ( int ( season_id ) - [number] ) [EOL] except InvalidArgumentException : [EOL] from_format_id = - [number] [EOL] try : [EOL] to_format_id = multiverse . get_format_id_from_season_id ( season_id ) [EOL] except InvalidArgumentException : [EOL] to_format_id = - [number] [EOL] return changes_between_formats ( from_format_id , to_format_id ) [EOL] [EOL] [EOL] [comment] [EOL] def changes_between_formats ( f1 , f2 ) : [EOL] return ( query_diff_formats ( f2 , f1 ) , query_diff_formats ( f1 , f2 ) ) [EOL] [EOL] def query_diff_formats ( f1 , f2 ) : [EOL] where = [string] . format ( format1 = f1 , format2 = f2 ) [EOL] [EOL] rs = db ( ) . select ( multiverse . cached_base_query ( where = where ) ) [EOL] out = [ Card ( r ) for r in rs ] [EOL] return sorted ( out , key = lambda card : card [ [string] ] ) [EOL] [EOL] def if_todays_prices ( out = True ) : [EOL] current_format = multiverse . get_format_id ( [string] ) [EOL] if out : [EOL] not_clause = [string] [EOL] compare = [string] [EOL] else : [EOL] not_clause = [string] [EOL] compare = [string] [EOL] [EOL] where = [string] . format ( not_clause = not_clause , format = current_format , prices_database = configuration . get ( [string] ) , compare = compare , layouts = [string] . join ( [ sqlescape ( layout ) for layout in multiverse . playable_layouts ( ) ] ) ) [EOL] [EOL] rs = db ( ) . select ( multiverse . cached_base_query ( where = where ) ) [EOL] cards = [ Card ( r ) for r in rs ] [EOL] return sorted ( cards , key = lambda card : card [ [string] ] ) [EOL] [EOL] async def add_cards_and_update_async ( printings ) : [EOL] if not printings : [EOL] return [EOL] ids = await multiverse . insert_cards_async ( printings ) [EOL] multiverse . add_to_cache ( ids ) [EOL] cs = [ Card ( r ) for r in db ( ) . select ( multiverse . cached_base_query ( [string] + [string] . join ( [ str ( id ) for id in ids ] ) + [string] ) ) ] [EOL] multiverse . reindex_specific_cards ( cs ) [EOL] for c in cs : [EOL] CARDS_BY_NAME [ c . name ] = c [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,magic.models.Card]$ 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Printing]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[magic.models.Printing]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Sequence[magic.models.Card],typing.Sequence[magic.models.Card]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Sequence[magic.models.Card],typing.Sequence[magic.models.Card]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from magic import card [EOL] [EOL] [EOL] def test_canonicalize ( ) : [EOL] assert card . canonicalize ( [string] ) == [string] [EOL] assert card . canonicalize ( [string] ) == [string] [EOL] assert card . canonicalize ( [string] ) == [string] [EOL] assert card . canonicalize ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Set [EOL] import typing [EOL] import magic [EOL] from magic import legality [EOL] from magic . models import CardRef , Deck [EOL] [EOL] [EOL] def test_legal_formats ( ) : [EOL] d = Deck ( { [string] : [number] } ) [EOL] d . maindeck = [ CardRef ( [string] , [number] ) ] [EOL] d . sideboard = [ ] [EOL] assert len ( d . all_cards ( ) ) == [number] [EOL] formats = legality . legal_formats ( d ) [EOL] assert len ( formats ) == [number] [EOL] [EOL] d . maindeck = [ CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] [EOL] formats = legality . legal_formats ( d , { [string] } ) [EOL] assert len ( formats ) == [number] [EOL] assert [string] in formats [EOL] assert [string] not in formats [EOL] [EOL] d . maindeck = [ CardRef ( [string] , [number] ) , CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert len ( d . all_cards ( ) ) == [number] [EOL] assert len ( legality . legal_formats ( d ) ) == [number] [EOL] [EOL] d . maindeck = [ CardRef ( [string] , [number] ) , CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] [EOL] d . sideboard = [ CardRef ( [string] , [number] ) , CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert len ( legality . legal_formats ( d ) ) == [number] [EOL] [EOL] d . maindeck = [ CardRef ( [string] , [number] ) , CardRef ( [string] , [number] ) ] [EOL] d . sideboard = [ CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert [string] in formats [EOL] assert [string] not in formats [EOL] [EOL] d . maindeck = [ CardRef ( [string] , [number] ) ] [EOL] d . sideboard = [ CardRef ( [string] , [number] ) ] [EOL] formats = legality . legal_formats ( d ) [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL] assert [string] in formats [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Optional , Match , Set , Tuple , List , Any , Type [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] [docstring] [EOL] import re [EOL] import xml [EOL] from typing import Any , Dict , Tuple [EOL] [EOL] import untangle [EOL] [EOL] from magic import oracle [EOL] from magic . models import CardRef , Deck [EOL] from shared . pd_exception import InvalidDataException [EOL] [EOL] SectionType = Dict [ str , int ] [EOL] DecklistType = Dict [ str , SectionType ] [EOL] [EOL] def parse_line ( line ) : [EOL] match = re . match ( [string] , line ) [EOL] if match is None : [EOL] raise InvalidDataException ( [string] . format ( line = line ) ) [EOL] n , name = match . groups ( ) [EOL] return ( int ( n ) , name ) [EOL] [EOL] def parse_chunk ( chunk , section ) : [EOL] for line in chunk . splitlines ( ) : [EOL] if [string] in line . lower ( ) . strip ( ) . strip ( [string] ) or line . strip ( ) == [string] : [EOL] continue [EOL] if line . lower ( ) . strip ( ) . strip ( [string] ) == [string] : [EOL] continue [EOL] n , name = parse_line ( line ) [EOL] add_card ( section , int ( n ) , name ) [EOL] [EOL] [comment] [EOL] def parse ( s ) : [EOL] s = s . lstrip ( ) . rstrip ( ) [EOL] if looks_doublespaced ( s ) : [EOL] s = remove_doublespacing ( s ) [EOL] maindeck = { } [EOL] sideboard = { } [EOL] chunks = re . split ( [string] , s , flags = re . IGNORECASE | re . MULTILINE ) [EOL] if len ( chunks ) > [number] and ( len ( chunks [ - [number] ] ) > [number] or len ( chunks [ - [number] ] [ [number] ] ) > [number] ) or [string] in s : [EOL] for chunk in chunks [ : - [number] ] : [EOL] parse_chunk ( chunk , maindeck ) [EOL] parse_chunk ( chunks [ - [number] ] , sideboard ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] lines = s . splitlines ( ) [EOL] while sum ( maindeck . values ( ) ) < [number] and len ( lines ) > [number] : [EOL] n , name = parse_line ( lines . pop ( [number] ) ) [EOL] add_card ( maindeck , n , name ) [EOL] [EOL] while len ( lines ) > [number] : [EOL] n , name = parse_line ( lines . pop ( - [number] ) ) [EOL] if sum ( sideboard . values ( ) ) + n <= [number] : [EOL] add_card ( sideboard , n , name ) [EOL] if sum ( sideboard . values ( ) ) == [number] : [EOL] break [EOL] else : [EOL] add_card ( maindeck , n , name ) [EOL] break [EOL] [EOL] while len ( lines ) > [number] : [EOL] n , name = parse_line ( lines . pop ( [number] ) ) [EOL] add_card ( maindeck , n , name ) [EOL] [EOL] [comment] [EOL] if sum ( maindeck . values ( ) ) + sum ( sideboard . values ( ) ) == [number] : [EOL] new_maindeck , is_commander = { } , True [EOL] for name in set ( maindeck ) | set ( sideboard ) : [EOL] new_maindeck [ name ] = maindeck . get ( name , [number] ) + sideboard . get ( name , [number] ) [EOL] if new_maindeck [ name ] > [number] and name not in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] is_commander = False [EOL] if is_commander : [EOL] maindeck = new_maindeck [EOL] sideboard = { } [EOL] [EOL] return { [string] : maindeck , [string] : sideboard } [EOL] [EOL] def looks_doublespaced ( s ) : [EOL] return len ( re . findall ( [string] , s ) ) >= len ( re . findall ( [string] , s ) ) / [number] - [number] [EOL] [EOL] def remove_doublespacing ( s ) : [EOL] return re . sub ( [string] , [string] , s ) [EOL] [EOL] [comment] [EOL] def parse_xml ( s ) : [EOL] d = { [string] : { } , [string] : { } } [EOL] try : [EOL] doc = untangle . parse ( s ) [EOL] for c in doc . Deck . Cards : [EOL] section = [string] if c [ [string] ] == [string] else [string] [EOL] d [ section ] [ c [ [string] ] ] = d [ section ] . get ( c [ [string] ] , [number] ) + int ( c [ [string] ] ) [EOL] return d [EOL] except xml . sax . SAXException as e : [comment] [EOL] raise InvalidDataException ( e ) [EOL] except AttributeError as e : [EOL] raise InvalidDataException ( e ) [comment] [EOL] [EOL] [comment] [EOL] def vivify ( decklist ) : [EOL] validated = { [string] : { } , [string] : { } } [EOL] invalid_names = set ( ) [EOL] for section in [ [string] , [string] ] : [EOL] for name , n in decklist . get ( section , { } ) . items ( ) : [EOL] try : [EOL] validated [ section ] [ oracle . valid_name ( name ) ] = n [EOL] except InvalidDataException : [EOL] invalid_names . add ( name ) [EOL] if invalid_names : [EOL] raise InvalidDataException ( [string] . format ( invalid_names = [string] . join ( invalid_names ) ) ) [EOL] d = Deck ( { [string] : [ ] , [string] : [ ] } ) [EOL] for section in [ [string] , [string] ] : [EOL] for name , n in validated . get ( section , { } ) . items ( ) : [EOL] d [ section ] . append ( CardRef ( name , n ) ) [EOL] return d [EOL] [EOL] def unvivify ( deck ) : [EOL] decklist = { } [EOL] decklist [ [string] ] = { c [ [string] ] : c [ [string] ] for c in deck [ [string] ] } [EOL] decklist [ [string] ] = { c [ [string] ] : c [ [string] ] for c in deck [ [string] ] } [EOL] return decklist [EOL] [EOL] def add_card ( section , n , name ) : [EOL] if n > [number] : [EOL] section [ name ] = n + section . get ( name , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DecklistType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.Deck$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $DecklistType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] from typing import Optional [EOL] [EOL] from magic import fetcher [EOL] from magic . models import Card [EOL] from shared import dtutil [EOL] from shared . fetch_tools import FetchException [EOL] [EOL] MAX_PRICE_CENTS = [number] [EOL] MAX_PRICE_TIX = MAX_PRICE_CENTS / [number] [EOL] MAX_PRICE_TEXT = [string] [EOL] [EOL] def card_price_string ( card , short = False ) : [EOL] def price_info ( c ) : [EOL] try : [EOL] p = fetcher . card_price ( c . name ) [EOL] except FetchException : [EOL] return [string] [EOL] if p is None : [EOL] return [string] [EOL] [comment] [EOL] s = [string] . format ( price = format_price ( p [ [string] ] ) ) [EOL] try : [EOL] if float ( p [ [string] ] ) <= [number] : [EOL] s += [string] . format ( low = format_price ( p [ [string] ] ) , high = format_price ( p [ [string] ] ) ) [EOL] if float ( p [ [string] ] ) <= MAX_PRICE_TIX and not short : [EOL] s += [string] . format ( week = round ( float ( p [ [string] ] ) * [number] ) , month = round ( float ( p [ [string] ] ) * [number] ) , season = round ( float ( p [ [string] ] ) * [number] ) ) [EOL] s += [string] [EOL] age = dtutil . dt2ts ( dtutil . now ( ) ) - p [ [string] ] [EOL] if age > [number] * [number] * [number] : [EOL] s += [string] . format ( display = dtutil . display_time ( age , [number] ) ) [EOL] except TypeError as e : [EOL] print ( f' [string] { p } [string] { e }' ) [EOL] return [string] [EOL] return s [EOL] def format_price ( p ) : [EOL] if p is None : [EOL] return [string] [EOL] dollars , cents = str ( round ( float ( p ) , [number] ) ) . split ( [string] ) [EOL] return [string] . format ( dollars = dollars , cents = cents . ljust ( [number] , [string] ) ) [EOL] return price_info ( card ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import textwrap [EOL] [EOL] from magic import decklist [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] [EOL] def test_parse2 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] [EOL] def test_parse3 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] def test_parse4 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] def test_parse5 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] [comment] [EOL] def test_parse6 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] [comment] [EOL] def test_parse7 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] [comment] [EOL] def test_parse8 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert d [ [string] ] [ [string] ] == [number] [EOL] assert d [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] def test_parse9 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert d [ [string] ] [ [string] ] == [number] [EOL] [EOL] def test_parse10 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] [EOL] [comment] [EOL] def test_parse11 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert d [ [string] ] [ [string] ] == [number] [EOL] [EOL] [comment] [EOL] def test_parse12 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] [EOL] [comment] [EOL] def test_parse13 ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] def test_parse_tappedout_commander ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] assert len ( d [ [string] ] ) == [number] [EOL] [EOL] def test_parse_scryfall ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] [EOL] def test_parse_double_blank_line ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] [EOL] def test_explicit_main_sb ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] [EOL] def test_sideboard_with_sb ( ) : [EOL] s = [string] [EOL] s = textwrap . dedent ( s ) [EOL] d = decklist . parse ( s ) [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL] assert sum ( d [ [string] ] . values ( ) ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] from magic import multiverse [EOL] from magic . database import db [EOL] [EOL] [EOL] def test_base_query_legalities ( ) : [EOL] sql = multiverse . base_query ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] rs = db ( ) . select ( sql ) [EOL] assert len ( rs ) == [number] [EOL] legalities = rs [ [number] ] [ [string] ] [EOL] assert [string] in legalities [EOL] assert [string] not in legalities [EOL] [EOL] def test_supertypes ( ) : [EOL] assert multiverse . supertypes ( [string] ) == [ [string] ] [EOL] assert multiverse . supertypes ( [string] ) == [ ] [EOL] assert multiverse . supertypes ( [string] ) == [ [string] , [string] ] [EOL] assert multiverse . supertypes ( [string] ) == [ ] [EOL] assert multiverse . supertypes ( [string] ) == [ ] [EOL] [EOL] def test_subtypes ( ) : [EOL] assert multiverse . subtypes ( [string] ) == [ [string] ] [EOL] assert multiverse . subtypes ( [string] ) == [ [string] ] [EOL] assert multiverse . subtypes ( [string] ) == [ [string] ] [EOL] assert multiverse . subtypes ( [string] ) == [ ] [EOL] assert multiverse . subtypes ( [string] ) == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Literal , Tuple , List , Container , Any , Type [EOL] import builtins [EOL] import magic [EOL] import typing_extensions [EOL] import datetime [EOL] import shared [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] from enum import Enum [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] import inflect [EOL] from dateutil import rrule [comment] [EOL] [EOL] from magic import rotation [EOL] from magic . models import Deck [EOL] from shared import dtutil , guarantee [EOL] from shared . container import Container [EOL] [EOL] TournamentDateType = Tuple [ str , datetime . datetime ] [EOL] [EOL] class TimeDirection ( Enum ) : [EOL] BEFORE = [number] [EOL] AFTER = [number] [EOL] [EOL] def next_tournament_info ( ) : [EOL] return tournament_info ( TimeDirection . AFTER ) [EOL] [EOL] def previous_tournament_info ( ) : [EOL] return tournament_info ( TimeDirection . BEFORE , units = [number] ) [EOL] [EOL] def tournament_info ( time_direction , units = [number] ) : [EOL] name , time = get_nearest_tournament ( time_direction ) [EOL] next_tournament_time_precise = abs ( dtutil . dt2ts ( time ) - dtutil . dt2ts ( dtutil . now ( ) ) ) [EOL] near = next_tournament_time_precise < [number] [comment] [EOL] next_tournament_time = dtutil . display_time ( next_tournament_time_precise , units ) [EOL] info = { [string] : name , [string] : next_tournament_time , [string] : next_tournament_time_precise , [string] : near } [EOL] info . update ( series_info ( name ) ) [EOL] return info [EOL] [EOL] def get_nearest_tournament ( time_direction = TimeDirection . AFTER ) : [EOL] start = dtutil . now ( dtutil . GATHERLING_TZ ) [EOL] if time_direction == TimeDirection . AFTER : [EOL] index = [number] [EOL] else : [EOL] index = - [number] [EOL] start = start - datetime . timedelta ( days = [number] ) [EOL] [EOL] dates = get_all_next_tournament_dates ( start , index = index ) [EOL] return sorted ( dates , key = lambda t : t [ [number] ] ) [ index ] [EOL] [EOL] def get_all_next_tournament_dates ( start , index = [number] ) : [EOL] apac_start = start . astimezone ( tz = dtutil . APAC_SERIES_TZ ) [EOL] until = start + datetime . timedelta ( days = [number] ) [EOL] pdfnm_time = ( [string] , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = start , until = until , byweekday = rrule . FR ) [ index ] ) [comment] [EOL] if is_pd500_week ( start ) : [EOL] pdsat_name = [string] [EOL] else : [EOL] pdsat_name = [string] [EOL] pdsat_time = ( pdsat_name , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = start , until = until , byweekday = rrule . SA ) [ index ] ) [comment] [EOL] apds_time = ( [string] , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = apac_start , until = until , byweekday = rrule . SU ) [ index ] ) [comment] [EOL] pds_time = ( [string] , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = start , until = until , byweekday = rrule . SU ) [ index ] ) [comment] [EOL] pdm_time = ( [string] , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = start , until = until , byweekday = rrule . MO ) [ index ] ) [comment] [EOL] pdt_time = ( [string] , rrule . rrule ( rrule . WEEKLY , byhour = [number] , byminute = [number] , bysecond = [number] , dtstart = start , until = until , byweekday = rrule . TH ) [ index ] ) [comment] [EOL] return [ pdfnm_time , pdsat_time , apds_time , pds_time , pdm_time , pdt_time ] [EOL] [EOL] def next_pd500_date ( ) : [EOL] end_of_season = rotation . next_rotation ( ) [EOL] return end_of_season - datetime . timedelta ( days = [number] , hours = [number] , minutes = [number] ) [comment] [EOL] [EOL] def is_pd500_week ( start ) : [EOL] date_of_pd500 = next_pd500_date ( ) [EOL] return start <= date_of_pd500 <= start + datetime . timedelta ( days = [number] ) [EOL] [EOL] def prize ( d ) : [EOL] return prize_by_finish ( d . get ( [string] ) or sys . maxsize ) [EOL] [EOL] def prize_by_finish ( f ) : [EOL] if f == [number] : [EOL] return [number] [EOL] if f == [number] : [EOL] return [number] [EOL] if f <= [number] : [EOL] return [number] [EOL] if f <= [number] : [EOL] return [number] [EOL] return [number] [EOL] [EOL] def prizes_by_finish ( multiplier = [number] ) : [EOL] prizes , finish , p = [ ] , [number] , inflect . engine ( ) [EOL] while True : [EOL] pz = prize_by_finish ( finish ) [EOL] if not pz : [EOL] break [EOL] prizes . append ( { [string] : p . ordinal ( finish ) , [string] : pz * multiplier } ) [EOL] finish += [number] [EOL] return prizes [EOL] [EOL] def series_info ( name ) : [EOL] return guarantee . exactly_one ( [ s for s in all_series_info ( ) if s . name == name ] ) [EOL] [EOL] def all_series_info ( ) : [EOL] info = get_all_next_tournament_dates ( dtutil . now ( dtutil . GATHERLING_TZ ) ) [EOL] return [ Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) , Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) , Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) , Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) , Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) , Container ( { [string] : info [ [number] ] [ [number] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : info [ [number] ] [ [number] ] , [string] : [string] } ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Type [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] import copy [EOL] import re [EOL] import unicodedata [EOL] from typing import Dict , List , Optional , Tuple [EOL] [EOL] from mypy_extensions import TypedDict [EOL] [EOL] [comment] [EOL] ColumnDescription = TypedDict ( [string] , { [string] : str , [string] : bool , [string] : bool , [string] : str , [string] : bool , [string] : Optional [ Tuple [ str , str ] ] , [string] : Optional [ str ] , [string] : bool , [string] : Optional [ List [ str ] ] , } ) [EOL] TableDescription = Dict [ str , ColumnDescription ] [EOL] [EOL] MAX_LEN_TEXT = [number] [EOL] MAX_LEN_VARCHAR = [number] [EOL] [EOL] BOOLEAN = [string] [EOL] DATE = [string] [EOL] INTEGER = [string] [EOL] REAL = [string] [EOL] TEXT = [string] [EOL] VARCHAR = [string] . format ( n = MAX_LEN_VARCHAR ) [EOL] [EOL] BASE = { [string] : VARCHAR , [string] : True , [string] : False , [string] : [string] , [string] : True , [string] : None , [string] : None , [string] : False , [string] : None } [EOL] [EOL] def base_query_properties ( ) : [EOL] [comment] [EOL] props = face_properties ( ) [EOL] props . update ( card_properties ( ) ) [EOL] props . update ( base_query_specific_properties ( ) ) [EOL] return props [EOL] [EOL] def base_query_lite_properties ( ) : [EOL] [comment] [EOL] props = face_properties ( ) [EOL] props . update ( card_properties ( ) ) [EOL] props [ [string] ] = copy . deepcopy ( BASE ) [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = [string] [EOL] return props [EOL] [EOL] def base_query_specific_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = [string] [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = [string] [EOL] props [ [string] ] [ [string] ] = BOOLEAN [EOL] props [ [string] ] [ [string] ] = [string] [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = [string] [EOL] return props [EOL] [EOL] def card_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = False [EOL] return props [EOL] [EOL] def face_properties ( ) : [EOL] props = { } [EOL] base = copy . deepcopy ( BASE ) [EOL] base [ [string] ] = [string] [EOL] for k in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( base ) [EOL] for k in [ [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = False [EOL] for k in [ [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = False [EOL] for k in [ [string] , [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = INTEGER [EOL] props [ k ] [ [string] ] = [string] [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = [string] [EOL] props [ [string] ] [ [string] ] = REAL [EOL] props [ [string] ] [ [string] ] = [string] . format ( name_query = name_query ( ) ) [EOL] props [ [string] ] [ [string] ] = [string] . format ( cmc_query = cmc_query ( ) ) [EOL] props [ [string] ] [ [string] ] = [string] . format ( mana_cost_query = mana_cost_query ( ) ) [EOL] props [ [string] ] [ [string] ] = [string] . format ( type_query = type_query ( ) ) [EOL] for k in [ [string] ] : [EOL] props [ k ] [ [string] ] = [string] [EOL] props [ k ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] return props [EOL] [EOL] def set_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] for k in [ [string] , [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = DATE [EOL] props [ [string] ] [ [string] ] = BOOLEAN [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = True [EOL] return props [EOL] [EOL] def printing_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] for k in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = False [EOL] for k in [ [string] , [string] , [string] , [string] ] : [EOL] props [ k ] [ [string] ] = INTEGER [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = BOOLEAN [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] return props [EOL] [EOL] def color_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] return props [EOL] [EOL] def card_color_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = INTEGER [EOL] props [ k ] [ [string] ] = False [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = [ [string] ] [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] return props [EOL] [EOL] def card_type_properties ( typetype ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , typetype ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = [ typetype ] [EOL] return props [EOL] [EOL] def format_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = True [EOL] return props [EOL] [EOL] def card_legality_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = [ [string] ] [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = True [EOL] return props [EOL] [EOL] def card_alias_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = [ [string] ] [EOL] return props [EOL] [EOL] def card_bug_properties ( ) : [EOL] props = { } [EOL] for k in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] props [ k ] = copy . deepcopy ( BASE ) [EOL] props [ k ] [ [string] ] = False [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = True [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = ( [string] , [string] ) [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = INTEGER [EOL] props [ [string] ] [ [string] ] = TEXT [EOL] props [ [string] ] [ [string] ] = BOOLEAN [EOL] props [ [string] ] [ [string] ] = BOOLEAN [EOL] return props [EOL] [EOL] def name_query ( column = [string] ) : [EOL] return [string] . format ( column = column , table = [string] ) [EOL] [EOL] def cmc_query ( ) : [EOL] return [string] [EOL] [EOL] def mana_cost_query ( ) : [EOL] return [string] [EOL] [EOL] def type_query ( ) : [EOL] return [string] [EOL] [EOL] def unaccent ( s ) : [EOL] return [string] . join ( ( c for c in unicodedata . normalize ( [string] , s ) if unicodedata . category ( c ) != [string] ) ) [EOL] [EOL] def canonicalize ( name ) : [EOL] if name . find ( [string] ) >= [number] and name . find ( [string] ) == - [number] : [EOL] name = name . replace ( [string] , [string] ) [EOL] if name . find ( [string] ) >= [number] and name . find ( [string] ) == - [number] : [EOL] name = name . replace ( [string] , [string] ) [EOL] name = re . sub ( [string] , [string] , name ) [EOL] [comment] [EOL] name = name . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] return unaccent ( name . strip ( ) . lower ( ) ) [EOL] [EOL] def to_mtgo_format ( s ) : [EOL] return s . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $ColumnDescription$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TableDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ColumnDescription$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Literal , Tuple , List , Container [EOL] import builtins [EOL] import magic [EOL] import typing_extensions [EOL] import datetime [EOL] import shared [EOL] import typing [EOL] import datetime [EOL] from typing import List , Tuple [EOL] [EOL] import flask [EOL] [EOL] from magic import card [EOL] from shared import configuration , dtutil [EOL] from shared . container import Container [EOL] from shared . database import Database , get_database [EOL] from shared . pd_exception import DatabaseException [EOL] [EOL] [comment] [EOL] SCHEMA_VERSION = [number] [EOL] DATABASE = Container ( ) [EOL] [EOL] def db ( ) : [EOL] if flask . current_app : [EOL] context = flask . g [EOL] else : [EOL] context = DATABASE [EOL] if hasattr ( context , [string] ) : [EOL] return context . get ( [string] ) [EOL] context . magic_database = get_database ( configuration . get_str ( [string] ) ) [EOL] init ( ) [EOL] return context . get ( [string] ) [EOL] [EOL] def init ( ) : [EOL] try : [EOL] if db_version ( ) < SCHEMA_VERSION : [EOL] delete ( ) [EOL] setup ( ) [EOL] except DatabaseException : [EOL] setup ( ) [EOL] [EOL] def last_updated ( ) : [EOL] return dtutil . ts2dt ( db ( ) . value ( [string] , [ ] , [number] ) ) [EOL] [EOL] def db_version ( ) : [EOL] return db ( ) . value ( [string] , [ ] , [number] ) [EOL] [EOL] def setup ( ) : [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] sql = create_table_def ( [string] , card . card_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . face_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . set_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . color_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_color_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_color_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_type_properties ( [string] ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_type_properties ( [string] ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . format_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_legality_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_alias_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . card_bug_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] sql = create_table_def ( [string] , card . format_properties ( ) ) [comment] [EOL] db ( ) . execute ( sql ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] sql = create_table_def ( [string] , card . printing_properties ( ) ) [EOL] db ( ) . execute ( sql ) [EOL] [comment] [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] . format ( SCHEMA_VERSION ) ) [EOL] [EOL] [comment] [EOL] def delete ( ) : [EOL] db ( ) . nuke_database ( ) [EOL] [EOL] def column_def ( name , prop ) : [EOL] nullable = [string] if not prop [ [string] ] else [string] [EOL] primary_key = [string] if prop [ [string] ] else [string] [EOL] default = [string] . format ( default = prop [ [string] ] ) if prop [ [string] ] is not None else [string] [EOL] unique = [string] if prop [ [string] ] else [string] [EOL] return [string] . format ( name = name , type = prop [ [string] ] , primary_key = primary_key , nullable = nullable , unique = unique , default = default ) [EOL] [EOL] def foreign_key_def ( name , fk ) : [EOL] return [string] . format ( name = name , table = fk [ [number] ] , column = fk [ [number] ] ) [EOL] [EOL] def unique_constraint_def ( name , cols ) : [EOL] cols = [ name ] + cols [EOL] return [string] . format ( name = [string] . join ( cols ) , cols = [string] . join ( [string] . format ( col = col ) for col in cols ) ) [EOL] [EOL] def create_table_def ( name , props , from_query = [string] ) : [EOL] sql = [string] [EOL] sql += [string] . join ( column_def ( name , prop ) for name , prop in props . items ( ) ) [EOL] fk = [string] . join ( foreign_key_def ( name , prop [ [string] ] ) for name , prop in props . items ( ) if prop [ [string] ] is not None ) [EOL] uc = [string] . join ( unique_constraint_def ( name , prop [ [string] ] ) for name , prop in props . items ( ) if prop [ [string] ] is not None ) [EOL] if fk : [EOL] sql += [string] + fk [EOL] if uc : [EOL] sql += [string] + uc [EOL] sql += [string] [EOL] if from_query : [EOL] sql += f' [string] { from_query }' [EOL] return sql . format ( name = name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] import magic [EOL] from whoosh . analysis import ( IDTokenizer , LowercaseFilter , StandardAnalyzer , StemmingAnalyzer , SubstitutionFilter ) [EOL] [EOL] from shared import configuration [EOL] [EOL] [EOL] class WhooshConstants ( ) : [EOL] index_dir = configuration . get_str ( [string] ) [EOL] tokenized_analyzer = StandardAnalyzer ( stoplist = None ) [EOL] normalized_analyzer = IDTokenizer ( ) | SubstitutionFilter ( [string] , [string] ) | LowercaseFilter ( ) [EOL] stem_analyzer = StemmingAnalyzer ( [string] , gaps = True , stoplist = None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[magic.whoosh_constants.WhooshConstants]$ 0 0 0 0 0 0 0 0 $typing.Type[magic.whoosh_constants.WhooshConstants]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[magic.whoosh_constants.WhooshConstants]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import typing [EOL] import magic [EOL] import pytest [EOL] [EOL] from magic import oracle [EOL] [EOL] [EOL] def test_legality ( ) : [EOL] card = oracle . load_card ( [string] ) [EOL] assert card is not None [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert card . legalities [ [string] ] == [string] [EOL] card = oracle . load_card ( [string] ) [EOL] assert card is not None [EOL] assert [string] not in card . legalities . keys ( ) [EOL] assert [string] not in card . legalities . keys ( ) [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert card . legalities [ [string] ] == [string] [EOL] assert [string] not in card . legalities . keys ( ) [EOL] [EOL] def test_valid_name ( ) : [EOL] assert oracle . valid_name ( [string] ) == [string] [EOL] assert oracle . valid_name ( [string] ) == [string] [EOL] [EOL] def test_load_cards ( ) : [EOL] cards = oracle . load_cards ( [ [string] , [string] ] ) [EOL] assert len ( cards ) == [number] [EOL] assert [string] in [ c . name for c in cards ] [EOL] assert [string] in [ c . name for c in cards ] [EOL] [EOL] def test_deck_sort_x_last ( ) : [EOL] cards = oracle . load_cards ( [ [string] , [string] , [string] ] ) [EOL] assert len ( cards ) == [number] [EOL] cards_by_name = { c . name : c for c in cards } [EOL] assert oracle . deck_sort ( cards_by_name [ [string] ] ) < oracle . deck_sort ( cards_by_name [ [string] ] ) [EOL] assert oracle . deck_sort ( cards_by_name [ [string] ] ) > oracle . deck_sort ( cards_by_name [ [string] ] ) [EOL] [EOL] [comment] [EOL] @ pytest . mark . functional def test_legality_list ( ) : [EOL] legal_cards = oracle . legal_cards ( ) [EOL] assert len ( legal_cards ) > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from magic import rotation [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] [EOL] def test_seasons_enum_uptodate ( ) : [EOL] [docstring] [EOL] if rotation . next_rotation_ex ( ) . code in [ [string] , None ] : [EOL] return [EOL] assert rotation . next_rotation_ex ( ) . code in rotation . SEASONS [EOL] [EOL] def test_season_id ( ) : [EOL] assert rotation . season_id ( [number] ) == [number] [EOL] found = False [EOL] try : [EOL] rotation . season_id ( [number] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] found = False [EOL] try : [EOL] assert rotation . season_id ( [string] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] assert rotation . season_id ( [string] ) == [number] [EOL] assert rotation . season_id ( [string] ) == [number] [EOL] assert rotation . season_id ( [string] ) == [string] [EOL] assert rotation . season_id ( [string] ) == [string] [EOL] [EOL] def test_season_code ( ) : [EOL] assert rotation . season_code ( [number] ) == [string] [EOL] found = False [EOL] try : [EOL] rotation . season_code ( [number] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] found = False [EOL] try : [EOL] assert rotation . season_code ( [string] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] assert rotation . season_code ( [string] ) == [string] [EOL] assert rotation . season_code ( [string] ) == [string] [EOL] assert rotation . season_code ( [string] ) == [string] [EOL] assert rotation . season_code ( [string] ) == [string] [EOL] [EOL] def test_season_name ( ) : [EOL] assert rotation . season_name ( [number] ) == [string] [EOL] found = False [EOL] try : [EOL] rotation . season_name ( [number] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] found = False [EOL] try : [EOL] assert rotation . season_name ( [string] ) [EOL] except DoesNotExistException : [EOL] found = True [EOL] assert found [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [string] ) == [string] [EOL] assert rotation . season_name ( [number] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import whoosh [EOL] import typing [EOL] import magic [EOL] import os [EOL] from typing import List [EOL] [EOL] from whoosh . fields import NUMERIC , STORED , TEXT , Schema [EOL] from whoosh . index import Index , create_in , open_dir [EOL] [EOL] from magic import multiverse [EOL] from magic . models import Card [EOL] from magic . whoosh_constants import WhooshConstants [EOL] [EOL] [EOL] class WhooshWriter ( ) : [EOL] def __init__ ( self ) : [EOL] self . schema = Schema ( id = NUMERIC ( unique = True , stored = True ) , canonical_name = STORED ( ) , name = STORED ( ) , name_tokenized = TEXT ( stored = False , analyzer = WhooshConstants . tokenized_analyzer ) , name_stemmed = TEXT ( stored = False , analyzer = WhooshConstants . stem_analyzer ) , name_normalized = TEXT ( stored = False , analyzer = WhooshConstants . normalized_analyzer , field_boost = [number] ) ) [EOL] [EOL] def rewrite_index ( self , cards ) : [EOL] print ( [string] . format ( d = WhooshConstants . index_dir ) ) [EOL] ensure_dir_exists ( WhooshConstants . index_dir ) [EOL] ix = create_in ( WhooshConstants . index_dir , self . schema ) [EOL] update_index ( ix , cards ) [EOL] [EOL] [comment] [EOL] def update_card ( self , card ) : [EOL] ix = open_dir ( WhooshConstants . index_dir ) [EOL] update_index ( ix , [ card ] ) [EOL] [EOL] def ensure_dir_exists ( directory ) : [EOL] if not os . path . exists ( directory ) : [EOL] os . makedirs ( directory ) [EOL] [EOL] def update_index ( index , cards ) : [EOL] writer = index . writer ( ) [EOL] [comment] [EOL] [comment] [EOL] cards = [ c for c in cards if multiverse . is_playable_layout ( c . layout ) ] [EOL] for card in cards : [EOL] names = card . names [EOL] if card . name not in names : [EOL] names . append ( card . name ) [comment] [EOL] for name in names : [EOL] document = { } [EOL] document [ [string] ] = card . id [EOL] document [ [string] ] = name [EOL] document [ [string] ] = card . name [EOL] document [ [string] ] = name [EOL] document [ [string] ] = name [EOL] document [ [string] ] = name [EOL] writer . update_document ( ** document ) [EOL] writer . commit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 $None$ 0 0 0 $magic.models.Card$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $magic.models.Card$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import unittest [EOL] from typing import List [EOL] [EOL] import whoosh [EOL] [EOL] from magic import multiverse [EOL] from magic . whoosh_search import WhooshSearcher [EOL] [EOL] [EOL] [comment] [EOL] class WhooshSearchTest ( unittest . TestCase ) : [EOL] @ classmethod def setUpClass ( cls ) : [EOL] try : [EOL] cls . searcher = WhooshSearcher ( ) [comment] [EOL] except whoosh . index . EmptyIndexError : [comment] [EOL] multiverse . reindex ( ) [EOL] cls . searcher = WhooshSearcher ( ) [comment] [EOL] [EOL] [EOL] def best_match_is ( self , query , expected_best_match , * additional_matches ) : [EOL] result = self . searcher . search ( query ) [comment] [EOL] assert result . get_best_match ( ) == expected_best_match [EOL] all_matches = result . get_all_matches ( ) [EOL] for r in additional_matches : [EOL] assert is_included ( r , all_matches ) [EOL] [EOL] def finds_at_least ( self , query , card_name ) : [EOL] result = self . searcher . search ( query ) [comment] [EOL] cards = result . get_all_matches ( ) [EOL] cards = [ c for c in cards if c is not None ] [EOL] assert len ( cards ) >= [number] [EOL] assert is_included ( card_name , cards ) [EOL] [EOL] def aliases_are_exact ( self ) : [EOL] for q , card in ( ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] result = self . searcher . search ( q ) [comment] [EOL] assert result . get_best_match ( ) == card [EOL] [EOL] def test_assorted_typos ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def test_split_cards ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def test_special_chars ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def test_2_typos_in_the_same_word ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def test_2_typos_in_2_words ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def best_match_without_prefix ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def test_stem_finds_variations ( self ) : [EOL] self . finds_at_least ( [string] , [string] ) [EOL] self . finds_at_least ( [string] , [string] ) [EOL] [EOL] def test_exact_match ( self ) : [EOL] for card in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] self . best_match_is ( card , card ) [EOL] [EOL] def test_prefix_match ( self ) : [EOL] for q , card in ( ( [string] , [string] ) , ( [string] , [string] ) ) : [EOL] self . best_match_is ( q , card ) [EOL] [EOL] def test_whole_word ( self ) : [EOL] self . best_match_is ( [string] , [string] , [string] ) [EOL] [EOL] def test_normalized_beats_tokenized ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def test_10_cycles_are_returned ( self ) : [EOL] result = self . searcher . search ( [string] ) [comment] [EOL] assert len ( result . fuzzy ) == [number] [EOL] [EOL] def test_dfc ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def test_flip ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def test_meld ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def test_aliases ( self ) : [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] self . best_match_is ( [string] , [string] ) [EOL] [EOL] def is_included ( name , cards ) : [EOL] return len ( [ x for x in cards if x == name ] ) >= [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , Set , List , Any [EOL] import builtins [EOL] import magic [EOL] import asyncio [EOL] import datetime [EOL] import typing [EOL] import asyncio [EOL] import datetime [EOL] from typing import Any , Dict , List , Optional , Set , Union [EOL] [EOL] from github . GithubException import GithubException [EOL] [EOL] from magic import card , database , fetcher , mana , rotation [EOL] from magic . abc import CardDescription [EOL] from magic . card import TableDescription [EOL] from magic . database import create_table_def , db [EOL] from magic . models import Card [EOL] from magic . whoosh_write import WhooshWriter [EOL] from shared import dtutil , repo [EOL] from shared . database import sqlescape [EOL] from shared . pd_exception import InvalidArgumentException , InvalidDataException [EOL] [EOL] [comment] [EOL] [EOL] FORMAT_IDS = { } [EOL] [EOL] def init ( ) : [EOL] event_loop = None [EOL] try : [EOL] event_loop = asyncio . get_event_loop ( ) [EOL] except RuntimeError : [EOL] event_loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( event_loop ) [EOL] return event_loop . run_until_complete ( init_async ( ) ) [EOL] [EOL] async def init_async ( ) : [EOL] try : [EOL] last_updated = await fetcher . scryfall_last_updated_async ( ) [EOL] if last_updated > database . last_updated ( ) : [EOL] print ( [string] ) [EOL] try : [EOL] await update_database_async ( last_updated ) [EOL] await set_legal_cards_async ( ) [EOL] finally : [EOL] [comment] [EOL] [comment] [EOL] rebuild_cache ( ) [EOL] reindex ( ) [EOL] except fetcher . FetchException : [EOL] print ( [string] ) [EOL] [EOL] def layouts ( ) : [EOL] return { [string] : True , [string] : False , [string] : False , [string] : False , [string] : False , [string] : True , [string] : False , [string] : True , [string] : True , [string] : True , [string] : True , [string] : False , [string] : True , [string] : False , [string] : True , [string] : False , [string] : True , [string] : False } [EOL] [EOL] def playable_layouts ( ) : [EOL] return [ layout for layout , playable in layouts ( ) . items ( ) if playable ] [EOL] [EOL] def is_playable_layout ( layout ) : [EOL] v = layouts ( ) . get ( layout ) [EOL] if v is not None : [EOL] return v [EOL] cache_key = [string] [EOL] if not hasattr ( is_playable_layout , cache_key ) : [comment] [EOL] try : [EOL] repo . create_issue ( f' [string] { layout } [string] ' , [string] , [string] , [string] ) [EOL] except GithubException : [EOL] pass [comment] [EOL] setattr ( is_playable_layout , cache_key , list ( ) ) [comment] [EOL] return False [EOL] [EOL] def cached_base_query ( where = [string] ) : [EOL] return [string] . format ( where = where ) [EOL] [EOL] def base_query ( where = [string] ) : [EOL] return [string] . format ( base_query_props = [string] . join ( prop [ [string] ] . format ( table = [string] , column = name ) for name , prop in card . base_query_properties ( ) . items ( ) ) , format_id = get_format_id ( [string] , True ) , card_props = [string] . join ( [string] . format ( name = name ) for name in card . card_properties ( ) ) , face_props = [string] . join ( [string] . format ( name = name ) for name in card . face_properties ( ) if name not in [ [string] , [string] ] ) , where = where ) [EOL] [EOL] def base_query_lite ( ) : [EOL] return [string] . format ( base_query_props = [string] . join ( prop [ [string] ] . format ( table = [string] , column = name ) for name , prop in card . base_query_lite_properties ( ) . items ( ) ) , card_props = [string] . join ( [string] . format ( name = name ) for name in card . card_properties ( ) ) , face_props = [string] . join ( [string] . format ( name = name ) for name in card . face_properties ( ) if name not in [ [string] , [string] ] ) , ) [EOL] [EOL] [EOL] async def update_database_async ( new_date ) : [EOL] db ( ) . begin ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [comment] [EOL] db ( ) . execute ( [string] ) [EOL] for s in await fetcher . all_sets_async ( ) : [EOL] insert_set ( s ) [EOL] every_card_printing = await fetcher . all_cards_async ( ) [EOL] await insert_cards_async ( every_card_printing ) [EOL] await update_pd_legality_async ( ) [EOL] db ( ) . execute ( [string] , [ dtutil . dt2ts ( new_date ) ] ) [EOL] db ( ) . execute ( [string] ) [comment] [EOL] rebuild_cache ( ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] [comment] [EOL] async def insert_cards_async ( printings ) : [EOL] next_card_id = ( db ( ) . value ( [string] ) or [number] ) + [number] [EOL] values = await determine_values_async ( printings , next_card_id ) [EOL] insert_many ( [string] , card . card_properties ( ) , values [ [string] ] , [ [string] ] ) [EOL] if values [ [string] ] : [comment] [EOL] insert_many ( [string] , card . card_color_properties ( ) , values [ [string] ] ) [EOL] insert_many ( [string] , card . card_color_properties ( ) , values [ [string] ] ) [EOL] insert_many ( [string] , card . printing_properties ( ) , values [ [string] ] ) [EOL] insert_many ( [string] , card . face_properties ( ) , values [ [string] ] , [ [string] ] ) [EOL] if values [ [string] ] : [EOL] insert_many ( [string] , card . card_legality_properties ( ) , values [ [string] ] , [ [string] ] ) [EOL] [comment] [EOL] get_format_id ( [string] , True ) [EOL] await update_bugged_cards_async ( ) [EOL] return [ c [ [string] ] for c in values [ [string] ] ] [EOL] [EOL] async def determine_values_async ( printings , next_card_id ) : [EOL] [comment] [EOL] cards = { } [EOL] card_values = [ ] [EOL] face_values = [ ] [EOL] meld_result_printings = [ ] [EOL] card_color_values = [ ] [EOL] card_color_identity_values = [ ] [EOL] printing_values = [ ] [EOL] card_legality_values = [ ] [EOL] rarity_ids = { x [ [string] ] : x [ [string] ] for x in db ( ) . select ( [string] ) } [EOL] scryfall_to_internal_rarity = { [string] : rarity_ids [ [string] ] , [string] : rarity_ids [ [string] ] , [string] : rarity_ids [ [string] ] , [string] : rarity_ids [ [string] ] } [EOL] sets = load_sets ( ) [EOL] colors = { c [ [string] ] . upper ( ) : c [ [string] ] for c in db ( ) . select ( [string] ) } [EOL] [EOL] for p in printings : [EOL] if not valid_layout ( p ) : [EOL] continue [EOL] [EOL] if p [ [string] ] == [string] : [EOL] continue [EOL] [EOL] rarity_id = scryfall_to_internal_rarity [ p [ [string] ] . strip ( ) ] [EOL] [EOL] try : [EOL] set_id = sets [ p [ [string] ] ] [EOL] except KeyError : [EOL] print ( f" [string] { p [ [string] ] } [string] { sets } [string] { p } [string] " ) [EOL] sets = await update_sets_async ( ) [EOL] set_id = sets [ p [ [string] ] ] [EOL] [EOL] [comment] [EOL] if p [ [string] ] in cards : [EOL] card_id = cards [ p [ [string] ] ] [EOL] printing_values . append ( printing_value ( p , card_id , set_id , rarity_id ) ) [EOL] continue [EOL] [EOL] card_id = next_card_id [EOL] next_card_id += [number] [EOL] cards [ p [ [string] ] ] = card_id [EOL] card_values . append ( { [string] : card_id , [string] : p [ [string] ] } ) [EOL] [EOL] if is_meld_result ( p ) : [comment] [EOL] meld_result_printings . append ( p ) [EOL] elif p . get ( [string] ) and p . get ( [string] ) != [string] : [EOL] face_values += multiple_faces_values ( p , card_id ) [EOL] else : [EOL] face_values . append ( single_face_value ( p , card_id ) ) [EOL] for color in p . get ( [string] , [ ] ) : [EOL] color_id = colors [ color ] [EOL] card_color_values . append ( { [string] : card_id , [string] : color_id } ) [EOL] for color in p . get ( [string] , [ ] ) : [EOL] color_id = colors [ color ] [EOL] card_color_identity_values . append ( { [string] : card_id , [string] : color_id } ) [EOL] for format_ , status in p . get ( [string] , { } ) . items ( ) : [EOL] if status == [string] or format_ . capitalize ( ) == [string] : [comment] [EOL] continue [EOL] [comment] [EOL] format_id = get_format_id ( format_ . capitalize ( ) , True ) [EOL] card_legality_values . append ( { [string] : card_id , [string] : format_id , [string] : status . capitalize ( ) } ) [EOL] [EOL] cards [ p [ [string] ] ] = card_id [EOL] printing_values . append ( printing_value ( p , card_id , set_id , rarity_id ) ) [EOL] [EOL] for p in meld_result_printings : [EOL] face_values += meld_face_values ( p , cards ) [EOL] [EOL] return { [string] : card_values , [string] : card_color_values , [string] : card_color_identity_values , [string] : face_values , [string] : printing_values , [string] : card_legality_values } [EOL] [EOL] def valid_layout ( p ) : [EOL] [comment] [EOL] [comment] [EOL] return p [ [string] ] not in [ [string] , [string] ] [EOL] [EOL] def insert_many ( table , properties , values , additional_columns = None ) : [EOL] columns = additional_columns or [ ] [EOL] columns += [ k for k , v in properties . items ( ) if v . get ( [string] ) ] [EOL] columns += [ name for name , prop in properties . items ( ) if prop [ [string] ] ] [EOL] query = f' [string] { table } [string] ' [EOL] query += [string] . join ( columns ) [EOL] query += [string] [EOL] query += [string] . join ( [string] . join ( str ( sqlescape ( entry [ column ] ) ) for column in columns ) for entry in values ) [EOL] query += [string] [EOL] db ( ) . execute ( query ) [EOL] [EOL] async def update_bugged_cards_async ( ) : [EOL] bugs = await fetcher . bugged_cards_async ( ) [EOL] if bugs is None : [EOL] return [EOL] db ( ) . begin ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] for bug in bugs : [EOL] last_confirmed_ts = dtutil . parse_to_ts ( bug [ [string] ] , [string] , dtutil . UTC_TZ ) [EOL] name = bug [ [string] ] . split ( [string] ) [ [number] ] [comment] [EOL] card_id = db ( ) . value ( [string] , [ name ] ) [EOL] if card_id is None : [EOL] print ( [string] . format ( card = bug [ [string] ] ) ) [EOL] continue [EOL] db ( ) . execute ( [string] , [ card_id , bug [ [string] ] , bug [ [string] ] , last_confirmed_ts , bug [ [string] ] , bug [ [string] ] , bug [ [string] ] ] ) [EOL] db ( ) . commit ( [string] ) [EOL] [EOL] async def update_pd_legality_async ( ) : [EOL] for s in rotation . SEASONS : [EOL] if s == rotation . current_season_code ( ) : [EOL] break [EOL] await set_legal_cards_async ( season = s ) [EOL] [EOL] def single_face_value ( p , card_id , position = [number] ) : [EOL] if not card_id : [EOL] raise InvalidDataException ( f' [string] { p }' ) [EOL] result = { } [EOL] result [ [string] ] = card_id [EOL] result [ [string] ] = p [ [string] ] [comment] [EOL] result [ [string] ] = p [ [string] ] [comment] [EOL] result [ [string] ] = p [ [string] ] [comment] [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] , [string] ) [EOL] result [ [string] ] = p . get ( [string] , [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = position [EOL] return result [EOL] [EOL] def multiple_faces_values ( p , card_id ) : [EOL] card_faces = p . get ( [string] ) [EOL] if card_faces is None : [EOL] raise InvalidArgumentException ( f' [string] { p } [string] { card_id } [string] ' ) [EOL] first_face_cmc = mana . cmc ( card_faces [ [number] ] [ [string] ] ) [EOL] position = [number] [EOL] face_values = [ ] [EOL] for face in card_faces : [EOL] [comment] [EOL] face [ [string] ] = mana . cmc ( face [ [string] ] ) if face [ [string] ] else first_face_cmc [EOL] face_values . append ( single_face_value ( face , card_id , position ) ) [EOL] position += [number] [EOL] return face_values [EOL] [EOL] def meld_face_values ( p , cards ) : [EOL] values = [ ] [EOL] all_parts = p . get ( [string] ) [EOL] if all_parts is None : [EOL] raise InvalidArgumentException ( f' [string] { p }' ) [EOL] front_face_names = [ part [ [string] ] for part in all_parts if part [ [string] ] == [string] ] [EOL] card_ids = [ cards [ name ] for name in front_face_names ] [EOL] for card_id in card_ids : [EOL] values . append ( single_face_value ( p , card_id , [number] ) ) [EOL] return values [EOL] [EOL] def is_meld_result ( p ) : [EOL] all_parts = p . get ( [string] ) [EOL] if all_parts is None or not p [ [string] ] == [string] : [EOL] return False [EOL] meld_result_name = next ( part [ [string] ] for part in all_parts if part [ [string] ] == [string] ) [EOL] return p [ [string] ] == meld_result_name [EOL] [EOL] def load_sets ( ) : [EOL] return { s [ [string] ] : s [ [string] ] for s in db ( ) . select ( [string] ) } [EOL] [EOL] def insert_set ( s ) : [EOL] sql = [string] [EOL] sql += [string] . join ( name for name , prop in card . set_properties ( ) . items ( ) if prop [ [string] ] ) [comment] [EOL] sql += [string] [EOL] sql += [string] . join ( [string] for name , prop in card . set_properties ( ) . items ( ) if prop [ [string] ] ) [EOL] sql += [string] [EOL] values = [ date2int ( s . get ( database2json ( name ) ) , name ) for name , prop in card . set_properties ( ) . items ( ) if prop [ [string] ] ] [EOL] db ( ) . execute ( sql , values ) [EOL] return db ( ) . last_insert_rowid ( ) [EOL] [EOL] async def update_sets_async ( ) : [EOL] sets = load_sets ( ) [EOL] for s in await fetcher . all_sets_async ( ) : [EOL] if s [ [string] ] not in sets . keys ( ) : [EOL] insert_set ( s ) [EOL] return load_sets ( ) [EOL] [EOL] def printing_value ( p , card_id , set_id , rarity_id ) : [EOL] [comment] [EOL] if not card_id or not set_id : [EOL] raise InvalidDataException ( f' [string] { card_id } [string] { set_id } [string] { p }' ) [EOL] result = { } [EOL] result [ [string] ] = card_id [EOL] result [ [string] ] = set_id [EOL] result [ [string] ] = rarity_id [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = p . get ( [string] ) [EOL] result [ [string] ] = [number] if p . get ( [string] ) else [number] [comment] [EOL] return result [EOL] [EOL] async def set_legal_cards_async ( season = None ) : [EOL] new_list = set ( ) [EOL] try : [EOL] new_list = set ( await fetcher . legal_cards_async ( season = season ) ) [EOL] except fetcher . FetchException : [EOL] pass [EOL] if season is None : [EOL] format_id = get_format_id ( [string] ) [EOL] else : [EOL] format_id = get_format_id ( [string] . format ( season = season ) , True ) [EOL] [EOL] if new_list == set ( ) or new_list is None : [EOL] return [EOL] if season is not None : [EOL] [comment] [EOL] populated = db ( ) . select ( [string] , [ format_id ] ) [EOL] if populated : [EOL] return [EOL] [EOL] [comment] [EOL] new_list = set ( c . rstrip ( ) for c in new_list ) [EOL] [EOL] db ( ) . begin ( [string] ) [EOL] db ( ) . execute ( [string] , [ format_id ] ) [EOL] db ( ) . execute ( [string] ) [EOL] [EOL] all_cards = db ( ) . select ( base_query_lite ( ) ) [EOL] legal_cards = [ ] [EOL] for row in all_cards : [EOL] if row [ [string] ] in new_list : [EOL] legal_cards . append ( [string] . format ( format_id = format_id , card_id = row [ [string] ] ) ) [EOL] sql = [string] . format ( values = [string] . join ( legal_cards ) ) [EOL] [EOL] db ( ) . execute ( sql ) [EOL] db ( ) . commit ( [string] ) [EOL] [comment] [EOL] n = db ( ) . value ( [string] , [ format_id ] ) [EOL] if n != len ( new_list ) : [EOL] print ( [string] . format ( n = n , len = len ( new_list ) ) ) [EOL] sql = [string] . format ( base_query = base_query ( ) , format_id = format_id ) [EOL] db_legal_list = [ row [ [string] ] for row in db ( ) . select ( sql ) ] [EOL] print ( set ( new_list ) . symmetric_difference ( set ( db_legal_list ) ) ) [EOL] [EOL] def rebuild_cache ( ) : [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( create_table_def ( [string] , card . base_query_properties ( ) , base_query ( ) ) ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [comment] [EOL] db ( ) . execute ( [string] ) [EOL] db ( ) . execute ( [string] ) [EOL] [EOL] def add_to_cache ( ids ) : [EOL] if not ids : [EOL] return [EOL] values = [string] . join ( [ str ( id ) for id in ids ] ) [EOL] query = base_query ( f' [string] { values } [string] ' ) [EOL] sql = f' [string] { query }' [EOL] db ( ) . execute ( sql ) [EOL] [EOL] def reindex ( ) : [EOL] writer = WhooshWriter ( ) [EOL] cs = get_all_cards ( ) [EOL] for alias , name in fetcher . card_aliases ( ) : [EOL] for c in cs : [EOL] if c . name == name : [EOL] c . names . append ( alias ) [EOL] writer . rewrite_index ( cs ) [EOL] [EOL] def reindex_specific_cards ( cs ) : [EOL] writer = WhooshWriter ( ) [EOL] for c in cs : [EOL] writer . update_card ( c ) [EOL] [EOL] def database2json ( propname ) : [EOL] if propname == [string] : [EOL] propname = [string] [EOL] return propname [EOL] [EOL] def date2int ( s , name ) : [EOL] if name == [string] : [EOL] return dtutil . parse_to_ts ( s , [string] , dtutil . WOTC_TZ ) [EOL] return s [EOL] [EOL] [comment] [EOL] def get_format_id ( name , allow_create = False ) : [EOL] if len ( FORMAT_IDS ) == [number] : [EOL] rs = db ( ) . select ( [string] ) [EOL] for row in rs : [EOL] FORMAT_IDS [ row [ [string] ] ] = row [ [string] ] [EOL] if name not in FORMAT_IDS . keys ( ) and allow_create : [EOL] db ( ) . execute ( [string] , [ name ] ) [EOL] FORMAT_IDS [ name ] = db ( ) . last_insert_rowid ( ) [EOL] if name not in FORMAT_IDS . keys ( ) : [EOL] raise InvalidArgumentException ( [string] . format ( name = name ) ) [EOL] return FORMAT_IDS [ name ] [EOL] [EOL] def get_format_id_from_season_id ( season_id ) : [EOL] season_code = rotation . SEASONS [ int ( season_id ) - [number] ] [EOL] if season_code == rotation . current_season_code ( ) : [EOL] format_name = [string] [EOL] else : [EOL] format_name = [string] . format ( f = season_code ) [EOL] return get_format_id ( format_name ) [EOL] [EOL] def get_all_cards ( ) : [EOL] rs = db ( ) . select ( cached_base_query ( ) ) [EOL] return [ Card ( r ) for r in rs ] [EOL] [EOL] def supertypes ( type_line ) : [EOL] types = type_line . split ( [string] ) [ [number] ] [EOL] possible_supertypes = [ [string] , [string] , [string] , [string] , [string] ] [EOL] sts = [ ] [EOL] for possible in possible_supertypes : [EOL] if possible in types : [EOL] sts . append ( possible ) [EOL] return sts [EOL] [EOL] def subtypes ( type_line ) : [EOL] if [string] not in type_line : [EOL] return [ ] [EOL] return type_line . split ( [string] ) [ [number] ] . split ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , Match , Tuple , List , Container , Any [EOL] import io [EOL] import builtins [EOL] import magic [EOL] import shared [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] import csv [EOL] import datetime [EOL] import json [EOL] import os [EOL] import re [EOL] from collections import OrderedDict [EOL] from time import sleep [EOL] from typing import Any , Dict , List , Optional , Tuple , Union , cast [EOL] from urllib import parse [EOL] [EOL] import feedparser [EOL] import pytz [EOL] from mypy_extensions import TypedDict [EOL] [EOL] from magic . abc import CardDescription , PriceDataType [EOL] from magic . models import Deck [EOL] from shared import configuration , dtutil , fetch_tools [EOL] from shared import redis_wrapper as redis [EOL] from shared . container import Container [EOL] from shared . fetch_tools import FetchException [EOL] from shared . pd_exception import InvalidDataException , NotConfiguredException , TooFewItemsException [EOL] [EOL] [EOL] async def achievement_cache_async ( ) : [EOL] data = await fetch_tools . fetch_json_async ( decksite_url ( [string] ) ) [EOL] return { a [ [string] ] : a for a in data [ [string] ] } [EOL] [EOL] async def all_cards_async ( ) : [EOL] try : [EOL] f = open ( [string] ) [EOL] return json . load ( f ) [EOL] except FileNotFoundError : [EOL] endpoints = await fetch_tools . fetch_json_async ( [string] ) [EOL] for e in endpoints [ [string] ] : [EOL] if e [ [string] ] == [string] : [EOL] return await fetch_tools . fetch_json_async ( e [ [string] ] ) [EOL] raise FetchException ( [string] ) [EOL] [EOL] async def all_sets_async ( ) : [EOL] try : [EOL] d = json . load ( open ( [string] ) ) [EOL] except FileNotFoundError : [EOL] d = await fetch_tools . fetch_json_async ( [string] ) [EOL] assert not d [ [string] ] [EOL] return d [ [string] ] [EOL] [EOL] async def bugged_cards_async ( ) : [EOL] try : [EOL] bugs = fetch_tools . fetch_json ( [string] ) [EOL] except FetchException : [EOL] print ( [string] ) [EOL] bugs = None [EOL] if bugs is None : [EOL] return None [EOL] return bugs [EOL] [EOL] def card_aliases ( ) : [EOL] with open ( configuration . get_str ( [string] ) , newline = [string] , encoding = [string] ) as f : [EOL] return list ( csv . reader ( f , dialect = [string] ) ) [EOL] [EOL] def card_price ( cardname ) : [EOL] return fetch_tools . fetch_json ( [string] . format ( cardname . replace ( [string] , [string] ) ) ) [EOL] [EOL] def current_time ( timezone , twentyfour ) : [EOL] if twentyfour : [EOL] return dtutil . now ( timezone ) . strftime ( [string] ) [EOL] try : [EOL] return dtutil . now ( timezone ) . strftime ( [string] ) [EOL] except ValueError : [comment] [EOL] return dtutil . now ( timezone ) . strftime ( [string] ) [EOL] [EOL] def decksite_url ( path = [string] ) : [EOL] return site_url ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) , configuration . get_int ( [string] ) , path ) [EOL] [EOL] def logsite_url ( path = [string] ) : [EOL] return site_url ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) , configuration . get_int ( [string] ) , path ) [EOL] [EOL] def site_url ( protocol , hostname , port , path ) : [EOL] if port != [number] : [EOL] base = [string] . format ( hostname = hostname , port = port ) [EOL] else : [EOL] base = hostname [EOL] url = parse . urlunparse ( ( protocol , base , path , [string] , [string] , [string] ) ) [EOL] assert url is not None [EOL] return url [EOL] [EOL] def downtimes ( ) : [EOL] return fetch_tools . fetch ( [string] ) [EOL] [EOL] def gatherling_deck_comments ( d ) : [EOL] url = f' [string] { d . identifier }' [EOL] s = fetch_tools . fetch ( url ) [EOL] result = re . search ( [string] , s , re . MULTILINE | re . DOTALL ) [EOL] if result : [EOL] return result . group ( [number] ) . replace ( [string] , [string] ) . split ( [string] ) [EOL] return [ ] [EOL] [EOL] async def legal_cards_async ( season = None ) : [EOL] if season is None : [EOL] url = [string] [EOL] else : [EOL] url = [string] . format ( season = season ) [EOL] encoding = [string] [EOL] cached_path = os . path . join ( os . path . abspath ( os . path . dirname ( __file__ ) ) , [string] ) [EOL] if os . path . exists ( os . path . join ( cached_path , url ) ) : [EOL] h = open ( os . path . join ( cached_path , url ) , encoding = encoding ) [EOL] legal = h . readlines ( ) [EOL] h . close ( ) [EOL] return [ l . strip ( ) for l in legal ] [EOL] [EOL] url = [string] + url [EOL] legal_txt = await fetch_tools . fetch_async ( url ) [EOL] if season is not None and configuration . get_bool ( [string] ) : [EOL] with open ( os . path . join ( cached_path , f'{ season } [string] ' ) , [string] , encoding = encoding ) as h : [EOL] h . write ( legal_txt ) [EOL] [EOL] return legal_txt . strip ( ) . split ( [string] ) [EOL] [EOL] async def mtgo_status ( ) : [EOL] try : [EOL] return cast ( str , ( await fetch_tools . fetch_json_async ( [string] ) ) [ [string] ] ) [EOL] except ( FetchException , json . decoder . JSONDecodeError ) : [EOL] return [string] [EOL] [EOL] async def person_data_async ( person ) : [EOL] try : [EOL] data = await fetch_tools . fetch_json_async ( decksite_url ( [string] . format ( person ) ) ) [EOL] except ( FetchException , json . decoder . JSONDecodeError ) : [EOL] return { } [EOL] return data [EOL] [EOL] def post_discord_webhook ( webhook_id , webhook_token , message , name = None ) : [EOL] if webhook_id is None or webhook_token is None : [EOL] return False [EOL] url = [string] . format ( id = webhook_id , token = webhook_token ) [EOL] fetch_tools . post ( url , json_data = { [string] : message , [string] : name , } ) [EOL] return True [EOL] [EOL] [comment] [EOL] def resources ( ) : [EOL] with open ( [string] ) as resources_file : [EOL] return json . load ( resources_file , object_pairs_hook = OrderedDict ) [EOL] [EOL] async def scryfall_last_updated_async ( ) : [EOL] d = await fetch_tools . fetch_json_async ( [string] ) [EOL] for o in d [ [string] ] : [EOL] if o [ [string] ] == [string] : [EOL] return dtutil . parse_rfc3339 ( o [ [string] ] ) [EOL] raise InvalidDataException ( f' [string] { d }' ) [EOL] [EOL] def search_scryfall ( query , exhaustive = False ) : [EOL] [docstring] [EOL] if query == [string] : [EOL] return False , [ ] [EOL] redis_key = f' [string] { query } [string] ' + ( [string] if exhaustive else [string] ) [EOL] cached = redis . get_list ( redis_key ) [EOL] result_data = ... [EOL] if cached : [EOL] total_cards , result_data = int ( cached [ [number] ] ) , cached [ [number] ] [EOL] else : [EOL] url = [string] + fetch_tools . escape ( query ) [EOL] result_data = [ ] [EOL] while True : [EOL] for _ in range ( [number] ) : [EOL] try : [EOL] result_json = fetch_tools . fetch_json ( url ) [EOL] break [EOL] except FetchException as c : [EOL] print ( c ) [EOL] if [string] in result_json . keys ( ) : [comment] [EOL] if result_json [ [string] ] == [number] : [comment] [EOL] return False , [ ] [EOL] print ( [string] , result_json ) [EOL] return False , [ ] [EOL] for warning in result_json . get ( [string] , [ ] ) : [comment] [EOL] print ( warning ) [comment] [EOL] result_data += result_json [ [string] ] [EOL] total_cards = int ( result_json [ [string] ] ) [EOL] if not exhaustive or len ( result_data ) >= total_cards : [EOL] break [EOL] sleep ( [number] ) [EOL] url = result_json [ [string] ] [EOL] redis . store ( redis_key , [ total_cards , result_data ] , ex = [number] ) [EOL] result_data . sort ( key = lambda x : x [ [string] ] [ [string] ] ) [EOL] def get_frontside ( scr_card ) : [EOL] [docstring] [EOL] [comment] [EOL] if scr_card [ [string] ] in [ [string] , [string] , [string] , [string] ] : [EOL] return scr_card [ [string] ] [ [number] ] [ [string] ] [EOL] return scr_card [ [string] ] [EOL] result_cardnames = [ get_frontside ( obj ) for obj in result_data ] [EOL] return total_cards , result_cardnames [EOL] [EOL] def rulings ( cardname ) : [EOL] card = fetch_tools . fetch_json ( [string] . format ( name = cardname ) ) [EOL] return fetch_tools . fetch_json ( card [ [string] ] + [string] ) [ [string] ] [EOL] [EOL] def sitemap ( ) : [EOL] return fetch_tools . fetch_json ( decksite_url ( [string] ) ) [ [string] ] [EOL] [EOL] def subreddit ( ) : [EOL] url = [string] [EOL] return feedparser . parse ( url ) [EOL] [EOL] def time ( q , twentyfour ) : [EOL] return times_from_timezone_code ( q , twentyfour ) if len ( q ) <= [number] else times_from_location ( q , twentyfour ) [EOL] [EOL] def times_from_timezone_code ( q , twentyfour ) : [EOL] possibles = list ( filter ( lambda x : datetime . datetime . now ( pytz . timezone ( x ) ) . strftime ( [string] ) == q . upper ( ) , pytz . common_timezones ) ) [EOL] if not possibles : [EOL] raise TooFewItemsException ( f' [string] { q . upper ( ) }' ) [EOL] results = { } [EOL] for possible in possibles : [EOL] timezone = dtutil . timezone ( possible ) [EOL] t = current_time ( timezone , twentyfour ) [EOL] results [ t ] = results . get ( t , [ ] ) + [ possible ] [EOL] return results [EOL] [EOL] def times_from_location ( q , twentyfour ) : [EOL] api_key = configuration . get ( [string] ) [EOL] if not api_key : [EOL] raise NotConfiguredException ( [string] ) [EOL] url = [string] . format ( q = fetch_tools . escape ( q ) , api_key = api_key ) [EOL] info = fetch_tools . fetch_json ( url ) [EOL] if [string] in info : [EOL] return info [ [string] ] [EOL] try : [EOL] location = info [ [string] ] [ [number] ] [ [string] ] [ [string] ] [EOL] except IndexError as e : [EOL] raise TooFewItemsException ( e ) [EOL] url = [string] . format ( lat = fetch_tools . escape ( str ( location [ [string] ] ) ) , lng = fetch_tools . escape ( str ( location [ [string] ] ) ) , timestamp = fetch_tools . escape ( str ( dtutil . dt2ts ( dtutil . now ( ) ) ) ) , api_key = api_key ) [EOL] timezone_info = fetch_tools . fetch_json ( url ) [EOL] if [string] in timezone_info : [EOL] return timezone_info [ [string] ] [EOL] if timezone_info [ [string] ] == [string] : [EOL] raise TooFewItemsException ( timezone_info [ [string] ] ) [EOL] try : [EOL] timezone = dtutil . timezone ( timezone_info [ [string] ] ) [EOL] except KeyError as e : [EOL] raise TooFewItemsException ( f' [string] { timezone_info }' ) [EOL] return { current_time ( timezone , twentyfour ) : [ info [ [string] ] [ [number] ] [ [string] ] ] } [EOL] [EOL] WISDateType = TypedDict ( [string] , { [string] : str , [string] : str , } ) [EOL] [EOL] WISSetInfoType = TypedDict ( [string] , { [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : WISDateType , [string] : WISDateType , } ) [EOL] [EOL] WISSchemaType = TypedDict ( [string] , { [string] : bool , [string] : List [ WISSetInfoType ] , } ) [EOL] [EOL] def whatsinstandard ( ) : [EOL] cached = redis . get_container ( [string] ) [EOL] if cached is not None : [EOL] return cached [EOL] [EOL] try : [EOL] info = fetch_tools . fetch_json ( [string] ) [EOL] except FetchException : [EOL] cached = redis . get_container ( [string] ) [EOL] if cached is not None : [EOL] return cached [EOL] raise [EOL] redis . store ( [string] , info , ex = [number] ) [EOL] redis . store ( [string] , info ) [EOL] return info [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $WISSchemaType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] from magic import database , mana [EOL] [EOL] [EOL] def test_simple ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] do_test ( [string] , [ [string] ] ) [EOL] try : [EOL] do_test ( [string] , [ ] ) [EOL] assert False [EOL] except mana . InvalidManaCostException : [EOL] assert True [EOL] [EOL] def test_twobrid ( ) : [EOL] do_test ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_twodigit ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_gleemax ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_x ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_y ( ) : [EOL] do_test ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_multicolor_x ( ) : [EOL] do_test ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_phyrexian ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_porcelain_legionnaire ( ) : [EOL] do_test ( [string] , [ [string] , [string] ] ) [EOL] [EOL] def test_norns_annex ( ) : [EOL] do_test ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_slitherhead ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_little_girl ( ) : [EOL] do_test ( [string] , [ [string] ] ) [EOL] [EOL] def test_everything ( ) : [EOL] rs = database . db ( ) . select ( [string] ) [EOL] for row in rs : [EOL] if row [ [string] ] : [EOL] mana . parse ( row [ [string] ] ) [EOL] [EOL] def test_colors ( ) : [EOL] assert mana . colors ( [ [string] , [string] , [string] , [string] ] ) == { [string] : { [string] , [string] } , [string] : set ( ) } [EOL] assert mana . colors ( [ [string] , [string] , [string] ] ) == { [string] : { [string] } , [string] : { [string] } } [EOL] assert mana . colors ( [ [string] , [string] ] ) == { [string] : set ( ) , [string] : { [string] , [string] } } [EOL] assert mana . colors ( [ [string] ] ) == { [string] : set ( ) , [string] : set ( ) } [EOL] assert mana . colors ( [ [string] ] ) == { [string] : set ( ) , [string] : { [string] , [string] } } [EOL] [EOL] def test_colored_symbols ( ) : [EOL] assert mana . colored_symbols ( [ [string] , [string] , [string] , [string] ] ) == { [string] : [ [string] , [string] , [string] ] , [string] : [ ] } [EOL] assert mana . colored_symbols ( [ [string] , [string] , [string] ] ) == { [string] : [ [string] ] , [string] : [ [string] ] } [EOL] assert mana . colored_symbols ( [ [string] , [string] ] ) == { [string] : [ ] , [string] : [ [string] , [string] ] } [EOL] assert mana . colored_symbols ( [ [string] ] ) == { [string] : [ ] , [string] : [ ] } [EOL] assert mana . colored_symbols ( [ [string] ] ) == { [string] : [ ] , [string] : [ [string] , [string] ] } [EOL] assert mana . colored_symbols ( [ [string] , [string] , [string] ] ) == { [string] : [ [string] , [string] ] , [string] : [ ] } [EOL] [EOL] def test_has_x ( ) : [EOL] assert mana . has_x ( [string] ) [EOL] assert not mana . has_x ( [string] ) [EOL] assert mana . has_x ( [string] ) [EOL] assert not mana . has_x ( [string] ) [EOL] assert mana . has_x ( [string] ) [EOL] [EOL] def test_order ( ) : [EOL] assert mana . order ( [ [string] ] ) == [ [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] ] ) == [ [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] ] ) == [ [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] ] ) == [ [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] ] ) == [ [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] ] ) == [ [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] , [string] ] ) == [ [string] , [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] , [string] , [string] , [string] ] ) == [ [string] , [string] , [string] , [string] ] [EOL] assert mana . order ( [ [string] ] ) == [ [string] ] [EOL] assert mana . order ( [ [string] ] ) == [ [string] ] [EOL] [EOL] def test_colorless ( ) : [EOL] assert mana . colored_symbols ( [ [string] ] ) == { [string] : [ [string] ] , [string] : [ ] } [EOL] [EOL] def test_snow ( ) : [EOL] assert mana . colored_symbols ( [ [string] ] ) == { [string] : [ [string] ] , [string] : [ ] } [EOL] [EOL] def test_cmc ( ) : [EOL] assert mana . cmc ( [string] ) == [number] [EOL] assert mana . cmc ( [string] ) == [number] [EOL] assert mana . cmc ( [string] ) == [number] [EOL] assert mana . cmc ( [string] ) == [number] [EOL] [EOL] def do_test ( s , expected ) : [EOL] symbols = mana . parse ( s ) [EOL] works = symbols == expected [EOL] if not works : [EOL] print ( [string] . format ( s = s , expected = expected , actual = symbols ) ) [EOL] assert works [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , List , Any [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] from typing import Any , Dict , List , Optional , cast [EOL] [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] class Card ( Container ) : [EOL] def __init__ ( self , params , predetermined_values = False ) : [EOL] super ( ) . __init__ ( ) [EOL] for k in params . keys ( ) : [EOL] if predetermined_values : [EOL] setattr ( self , k , params [ k ] ) [EOL] else : [EOL] setattr ( self , k , determine_value ( k , params ) ) [EOL] if not hasattr ( self , [string] ) : [EOL] setattr ( self , [string] , [ self . name ] ) [EOL] [EOL] def is_double_sided ( self ) : [EOL] return self . layout in [ [string] , [string] , [string] ] [EOL] [EOL] def is_creature ( self ) : [EOL] return [string] in self . type_line [EOL] [EOL] def is_land ( self ) : [EOL] return [string] in self . type_line [EOL] [EOL] def is_spell ( self ) : [EOL] return not self . is_creature ( ) and not self . is_land ( ) [EOL] [EOL] def is_split ( self ) : [EOL] return self . name . find ( [string] ) >= [number] [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . name ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( self , other . __class__ ) : [EOL] return self . name == other . name [EOL] return False [EOL] [EOL] def determine_value ( k , params ) : [EOL] v = params [ k ] [EOL] if k in ( [string] , [string] ) : [EOL] return cast ( str , v ) . split ( [string] ) if v is not None else None [EOL] if k == [string] : [EOL] v = determine_legalities ( cast ( str , v ) ) [EOL] elif k == [string] : [EOL] v = determine_bugs ( cast ( str , v ) ) [EOL] return v [EOL] [EOL] def determine_legalities ( s ) : [EOL] if s is None : [EOL] return { } [EOL] formats = s . split ( [string] ) [EOL] v = { } [EOL] for f in formats : [EOL] name , status = f . split ( [string] ) [EOL] v [ name ] = status [EOL] return v [EOL] [EOL] def determine_bugs ( s ) : [EOL] if s is None : [EOL] return None [EOL] bugs = s . split ( [string] ) [EOL] v = [ ] [EOL] for b in bugs : [EOL] description , classification , last_confirmed , url , from_bug_blog , bannable_str = b . split ( [string] ) [EOL] bb = from_bug_blog == [string] [EOL] bannable = bannable_str == [string] [EOL] bug = { [string] : description , [string] : classification , [string] : dtutil . ts2dt ( int ( last_confirmed ) ) , [string] : url , [string] : bb , [string] : bannable } [EOL] v . append ( bug ) [EOL] if v : [EOL] return v [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[typing.Dict[builtins.str,builtins.object]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . printing import Printing [comment] [EOL] from . card import Card [EOL] from . cardref import CardRef [EOL] from . deck import Deck [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] from typing import Any , Dict , List [EOL] [EOL] from magic import oracle [EOL] from magic . models import Card [EOL] from shared import dtutil [EOL] from shared . container import Container [EOL] [EOL] [EOL] [comment] [EOL] class Deck ( Container ) : [EOL] def __init__ ( self , params ) : [EOL] super ( ) . __init__ ( ) [EOL] for k in params . keys ( ) : [EOL] self [ k ] = params [ k ] [EOL] self . sorted = False [EOL] [EOL] def all_cards ( self ) : [EOL] cards = [ ] [EOL] for entry in self . maindeck + self . sideboard : [EOL] cards += [ entry . card ] * entry [ [string] ] [EOL] return cards [EOL] [EOL] def sort ( self ) : [EOL] if not self . sorted and ( len ( self . maindeck ) > [number] or len ( self . sideboard ) > [number] ) : [EOL] self . maindeck . sort ( key = lambda x : oracle . deck_sort ( x . card ) ) [EOL] self . sideboard . sort ( key = lambda x : oracle . deck_sort ( x . card ) ) [EOL] self . sorted = True [EOL] [EOL] def is_in_current_run ( self ) : [EOL] if ( ( self . wins or [number] ) + ( self . draws or [number] ) + ( self . losses or [number] ) >= [number] ) or self . retired : [EOL] return False [EOL] if self . competition_type_name != [string] : [EOL] return False [EOL] if self . competition_end_date < dtutil . now ( ) : [EOL] return False [EOL] return True [EOL] [EOL] def __str__ ( self ) : [EOL] self . sort ( ) [EOL] s = [string] [EOL] for entry in self . maindeck : [EOL] s += [string] . format ( n = entry [ [string] ] , name = entry [ [string] ] ) [EOL] s += [string] [EOL] for entry in self . sideboard : [EOL] s += [string] . format ( n = entry [ [string] ] , name = entry [ [string] ] ) [EOL] return s . strip ( ) [EOL] [EOL] def is_person_associated ( self ) : [EOL] return self . discord_id is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import CardRef [EOL] from typing import Any , Type [EOL] import magic [EOL] import builtins [EOL] import typing [EOL] import card [EOL] from typing import Any [EOL] [EOL] from magic import oracle [EOL] from shared . container import Container [EOL] [EOL] from . card import Card [EOL] [EOL] [EOL] class CardRef ( Container ) : [EOL] __card = None [EOL] [EOL] def __init__ ( self , name , count ) : [EOL] super ( ) . __init__ ( ) [EOL] self [ [string] ] = count [EOL] self . name = name [EOL] [EOL] def __contains__ ( self , key ) : [EOL] if key == [string] : [EOL] return True [EOL] return super ( ) . __contains__ ( key ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] if key == [string] : [EOL] return self . card [EOL] return super ( ) . __getitem__ ( key ) [EOL] [EOL] @ property def card ( self ) : [EOL] if self . __card is None : [EOL] self . __card = oracle . cards_by_name ( ) [ self . name ] [EOL] return self . __card [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $CardRef.card.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from shared . container import Container [EOL] [EOL] [EOL] class Printing ( Container ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] from typing import Any , Dict , List [EOL] [EOL] from mypy_extensions import TypedDict [EOL] [EOL] SetCode = str [EOL] [EOL] [comment] [EOL] CardDescription = TypedDict ( [string] , { [string] : List [ Dict [ str , str ] ] , [string] : str , [string] : List [ Any ] , [string] : float , [string] : str , [string] : List [ str ] , [string] : List [ str ] , [string] : str , [string] : str , [string] : str , [string] : str , [string] : Dict [ str , str ] , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : bool , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : List [ str ] , [string] : bool , [string] : str , [string] : str , [string] : str , [string] : bool , [string] : int , [string] : bool , [string] : str , [string] : List [ str ] , [string] : bool , [string] : List [ str ] , [string] : bool , [string] : str , [string] : Dict [ str , str ] , [string] : str , [string] : int , [string] : int , [string] : List [ int ] , [string] : bool , [string] : str , [string] : str , [string] : bool , [string] : str , [string] : str , [string] : str , [string] : str , [string] : bool , [string] : List [ str ] , [string] : Dict [ str , str ] , [string] : str , [string] : bool , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : str , [string] : bool , [string] : int , [string] : bool , [string] : str , [string] : bool , [string] : str } , total = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from mypy_extensions import TypedDict [EOL] [EOL] from . card_description import CardDescription [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] PriceDataType = TypedDict ( [string] , { [string] : int , [string] : str , [string] : str , [string] : str , [string] : float , [string] : float , [string] : float , } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Optional , Match , List , Iterable , Any [EOL] import builtins [EOL] import typing [EOL] import itertools [EOL] import re [EOL] from typing import Any , Iterable , List , Match , Optional [EOL] [EOL] METACATS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] CATEGORIES = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] BADCATS = [ [string] ] [EOL] [EOL] CODE_REGEX = [string] [EOL] BBT_REGEX = [string] [EOL] [EOL] DISCORD_REGEX = [string] [EOL] IMAGES_REGEX = [string] [EOL] REGEX_CARDREF = [string] [EOL] REGEX_SEARCHREF = [string] [EOL] [EOL] REGEX_BBCAT = [string] [EOL] [EOL] BAD_AFFECTS_REGEX = [string] [EOL] [EOL] [EOL] def remove_smartquotes ( text ) : [EOL] return text . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] def strip_squarebrackets ( title ) : [EOL] def get_name ( match ) : [EOL] return match . group ( [number] ) . strip ( ) [EOL] title = re . sub ( REGEX_CARDREF , get_name , title ) [EOL] return title [EOL] [EOL] def grouper ( n , iterable , fillvalue = None ) : [EOL] [docstring] [EOL] args = [ iter ( iterable ) ] * n [EOL] return itertools . zip_longest ( * args , fillvalue = fillvalue ) [EOL] [EOL] def get_cards_from_string ( item ) : [EOL] cards = re . findall ( REGEX_CARDREF , item ) [EOL] return cards [EOL] [EOL] def set_body_field ( body , field , value ) : [EOL] regex = [string] + field + [string] [EOL] line = f'{ field } [string] { value }' [EOL] m = re . search ( regex , body , re . MULTILINE ) [EOL] if m : [EOL] return re . sub ( regex , line , body , flags = re . MULTILINE ) [EOL] return f'{ body } [string] { line }' [EOL] [EOL] def get_body_field ( body , field ) : [EOL] regex = [string] + field + [string] [EOL] m = re . search ( regex , body , re . MULTILINE ) [EOL] if m : [EOL] return m . group ( [number] ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] import github [EOL] from typing import Dict , Optional [EOL] [EOL] from github import Github [EOL] from github . Issue import Issue [EOL] from github . IssueComment import IssueComment [EOL] from github . Project import Project [EOL] from github . Repository import Repository [EOL] [EOL] from shared import configuration , decorators [EOL] from shared import redis_wrapper as redis [EOL] [EOL] from . import strings [EOL] [EOL] ISSUE_CODES = { } [EOL] [EOL] @ decorators . memoize def get_github ( ) : [EOL] if not configuration . get_str ( [string] ) or not configuration . get_str ( [string] ) : [EOL] return None [EOL] return Github ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) ) [EOL] [EOL] @ decorators . memoize def get_repo ( ) : [EOL] gh = get_github ( ) [EOL] if gh is not None : [EOL] return gh . get_repo ( [string] ) [EOL] return None [EOL] [EOL] def get_verification_project ( ) : [EOL] return get_repo ( ) . get_projects ( ) [ [number] ] [EOL] [EOL] def create_comment ( issue , body ) : [EOL] set_issue_bbt ( issue . number , None ) [EOL] return issue . create_comment ( strings . remove_smartquotes ( body ) ) [EOL] [EOL] def set_issue_bbt ( number , text ) : [EOL] key = f' [string] { number }' [EOL] if text is None : [EOL] ISSUE_CODES . pop ( number , None ) [EOL] redis . clear ( key ) [EOL] else : [EOL] ISSUE_CODES [ number ] = text [EOL] redis . store ( key , text , ex = [number] ) [EOL] [EOL] def get_issue_bbt ( issue ) : [EOL] key = f' [string] { issue . number }' [EOL] bbt = ISSUE_CODES . get ( issue . number , None ) [EOL] if bbt is not None : [EOL] return bbt [EOL] bbt = redis . get_str ( key , ex = [number] ) [EOL] if bbt is not None : [EOL] return bbt [EOL] return None [EOL] [EOL] def is_issue_from_bug_blog ( issue ) : [EOL] return [string] in [ i . name for i in issue . labels ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[github.Repository.Repository]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $github.Project.Project$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $github.IssueComment.IssueComment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Optional , Match , List [EOL] import bs4 [EOL] import github [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import List , Match , Optional [EOL] [EOL] import requests [EOL] from bs4 import BeautifulSoup , Comment [EOL] from bs4 . element import Tag [EOL] from github . Issue import Issue [EOL] [EOL] from . import fetcher , repo , strings [EOL] from . strings import BBT_REGEX , strip_squarebrackets [EOL] [EOL] [EOL] def main ( changes ) : [EOL] ( link , new ) = fetcher . find_bug_blog ( ) [EOL] if new and link is not None : [EOL] scrape_bb ( link ) [EOL] changes . append ( [string] ) [EOL] [EOL] [EOL] def scrape_bb ( url ) : [EOL] soup = BeautifulSoup ( requests . get ( url ) . text , [string] ) [EOL] for b in soup . find_all ( [string] , class_ = [string] ) : [EOL] parse_block ( b ) [EOL] [EOL] def parse_block ( collapsible_block ) : [EOL] title = collapsible_block . find_all ( [string] ) [ [number] ] . get_text ( ) [EOL] print ( title ) [EOL] handle_autocards ( collapsible_block ) [EOL] if title == [string] : [EOL] parse_changelog ( collapsible_block ) [EOL] elif title == [string] : [EOL] parse_knownbugs ( collapsible_block ) [EOL] else : [EOL] print ( [string] . format ( title ) ) [EOL] [EOL] def parse_changelog ( collapsible_block ) : [EOL] [comment] [EOL] [comment] [EOL] for added in collapsible_block . find_all ( [string] ) : [EOL] for item in added . find_all ( [string] ) : [EOL] print ( item ) [EOL] bbt = strings . remove_smartquotes ( item . get_text ( ) ) [EOL] [EOL] issue = find_issue_by_code ( bbt ) [EOL] if issue is not None : [EOL] if not repo . is_issue_from_bug_blog ( issue ) : [EOL] print ( [string] ) [EOL] issue . add_to_labels ( [string] ) [EOL] elif find_issue_by_name ( bbt ) : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] text = [string] . format ( bbt ) [EOL] repo . get_repo ( ) . create_issue ( bbt , body = strings . remove_smartquotes ( text ) , labels = [ [string] ] ) [EOL] [EOL] def parse_knownbugs ( b ) : [EOL] [comment] [EOL] all_codes = b . find_all ( string = lambda text : isinstance ( text , Comment ) ) [EOL] all_codes = [ str ( code ) . replace ( [string] , [string] ) for code in all_codes ] [EOL] for issue in repo . get_repo ( ) . get_issues ( ) : [EOL] [comment] [EOL] bbt = re . search ( BBT_REGEX , issue . body , re . MULTILINE ) [EOL] if bbt is None : [EOL] cards = strings . get_cards_from_string ( issue . title ) [EOL] if repo . is_issue_from_bug_blog ( issue ) : [EOL] find_bbt_in_body_or_comments ( issue ) [EOL] find_bbt_in_issue_title ( issue , b ) [EOL] bbt = re . search ( BBT_REGEX , issue . body , re . MULTILINE ) [EOL] if bbt is None : [EOL] print ( [string] . format ( id = issue . number , cards = cards ) ) [EOL] issue . add_to_labels ( [string] ) [EOL] continue [EOL] [EOL] if not cards : [EOL] continue [EOL] lines = b . find_all ( string = re . compile ( [string] + cards [ [number] ] + [string] ) ) [EOL] if not lines : [EOL] continue [EOL] for line in lines : [EOL] parent = line . parent [EOL] bb_text = parent . get_text ( ) . strip ( ) [EOL] if find_issue_by_code ( bb_text ) is not None : [EOL] print ( [string] ) [EOL] continue [EOL] text = [string] . join ( parent . strings ) [EOL] print ( text ) [EOL] repo . create_comment ( issue , [string] . format ( text ) ) [EOL] if not repo . is_issue_from_bug_blog ( issue ) : [EOL] issue . add_to_labels ( [string] ) [EOL] continue [EOL] if [string] in [ i . name for i in issue . labels ] : [EOL] issue . remove_from_labels ( [string] ) [EOL] [EOL] if repo . is_issue_from_bug_blog ( issue ) : [EOL] [comment] [EOL] check_if_removed_from_bugblog ( bbt , b , issue ) [EOL] [EOL] check_for_missing_bugs ( b ) [EOL] [EOL] def check_if_removed_from_bugblog ( bbt , b , issue ) : [EOL] if bbt is not None : [EOL] text = strings . remove_smartquotes ( bbt . group ( [number] ) . strip ( ) ) [EOL] for row in b . find_all ( [string] ) : [EOL] data = row . find_all ( [string] ) [EOL] rowtext = strings . remove_smartquotes ( data [ [number] ] . text . strip ( ) ) [EOL] if rowtext == text : [EOL] break [EOL] if strip_squarebrackets ( rowtext ) == strip_squarebrackets ( text ) : [EOL] [comment] [EOL] print ( [string] . format ( id = issue . number ) ) [EOL] old_bbt = strings . get_body_field ( issue . body , [string] ) [EOL] body = re . sub ( BBT_REGEX , [string] . format ( rowtext ) , issue . body , flags = re . MULTILINE ) [EOL] new_bbt = strings . get_body_field ( body , [string] ) [EOL] issue . edit ( body = body ) [EOL] print ( [string] . format ( rowtext ) ) [EOL] issue . create_comment ( f' [string] { old_bbt } [string] { new_bbt } [string] ' ) [EOL] break [EOL] else : [EOL] print ( [string] . format ( id = issue . number ) ) [EOL] repo . create_comment ( issue , [string] ) [EOL] issue . edit ( state = [string] ) [EOL] [EOL] def check_for_missing_bugs ( b ) : [EOL] for row in b . find_all ( [string] ) : [EOL] data = row . find_all ( [string] ) [EOL] row_text = data [ [number] ] . text . strip ( ) [EOL] if row_text == [string] : [EOL] [comment] [EOL] continue [EOL] issue = find_issue_by_code ( row_text ) [EOL] if issue : [EOL] labels = [ c . name for c in issue . labels ] [EOL] categories = [ c for c in labels if c in strings . METACATS ] [EOL] if categories : [EOL] continue [EOL] bbcat = re . match ( strings . REGEX_BBCAT , data [ [number] ] . text . strip ( ) ) [EOL] if bbcat is None : [EOL] continue [EOL] g1 = bbcat . group ( [number] ) . strip ( ) [EOL] if g1 in strings . METACATS : [EOL] issue . add_to_labels ( g1 ) [EOL] continue [EOL] if bbcat . group ( [number] ) is not None : [EOL] g2 = bbcat . group ( [number] ) . strip ( ) [EOL] if g2 in strings . METACATS : [EOL] issue . add_to_labels ( g2 ) [EOL] continue [EOL] print ( f' [string] { bbcat . group ( [number] ) }' ) [EOL] continue [EOL] print ( [string] . format ( row = row_text ) ) [EOL] text = [string] . format ( row_text ) [EOL] repo . get_repo ( ) . create_issue ( strings . remove_smartquotes ( row_text ) , body = strings . remove_smartquotes ( text ) , labels = [ [string] ] ) [EOL] [EOL] [EOL] def find_bbt_in_issue_title ( issue , known_issues ) : [EOL] title = strip_squarebrackets ( issue . title ) . replace ( [string] , [string] ) [EOL] for row in known_issues . find_all ( [string] ) : [EOL] data = row . find_all ( [string] ) [EOL] row_text = strip_squarebrackets ( data [ [number] ] . text . strip ( ) ) . replace ( [string] , [string] ) [EOL] if row_text == title : [EOL] body = issue . body [EOL] body += [string] . format ( data [ [number] ] . text . strip ( ) ) [EOL] if body != issue . body : [EOL] issue . edit ( body = body ) [EOL] return [EOL] [EOL] def handle_autocards ( soup ) : [EOL] for link in soup . find_all ( [string] , class_ = [string] ) : [EOL] name = link . get_text ( ) [EOL] link . replace_with ( [string] . format ( name ) ) [EOL] [EOL] def find_issue_by_code ( code ) : [EOL] if code is None : [EOL] return None [EOL] def scan ( issue_list ) : [EOL] for issue in issue_list : [EOL] if not repo . is_issue_from_bug_blog ( issue ) : [EOL] [comment] [EOL] repo . set_issue_bbt ( issue . number , None ) [EOL] continue [EOL] icode = repo . get_issue_bbt ( issue ) [EOL] if icode == code : [EOL] return issue [EOL] if icode is not None : [EOL] continue [EOL] found = code in issue . body [EOL] if not found : [EOL] icode = find_bbt_in_body_or_comments ( issue ) [EOL] found = code in issue . body [EOL] if icode is not None : [EOL] repo . set_issue_bbt ( issue . number , icode . strip ( ) ) [EOL] else : [EOL] repo . set_issue_bbt ( issue . number , None ) [EOL] if found : [EOL] repo . set_issue_bbt ( issue . number , code ) [EOL] return issue [EOL] return None [EOL] _repo = repo . get_repo ( ) [EOL] if _repo is None : [EOL] return None [EOL] res = scan ( _repo . get_issues ( state = [string] ) ) [EOL] if res : [EOL] return res [EOL] return scan ( _repo . get_issues ( state = [string] ) ) [EOL] [EOL] def find_bbt_in_body_or_comments ( issue ) : [EOL] body = issue . body [EOL] bbt = re . search ( BBT_REGEX , issue . body , re . MULTILINE ) [EOL] if not bbt : [EOL] for comment in issue . get_comments ( ) : [EOL] if bbt is None : [EOL] bbt = re . search ( BBT_REGEX , comment . body , re . MULTILINE ) [EOL] if bbt is not None : [EOL] body += [string] . format ( bbt . groups ( ) [ [number] ] . strip ( ) ) [EOL] if body != issue . body : [EOL] issue . edit ( body = body ) [EOL] if bbt is not None : [EOL] return bbt . groups ( ) [ [number] ] . strip ( ) [EOL] return None [EOL] [EOL] def find_issue_by_name ( name ) : [EOL] if name is None : [comment] [EOL] return None [EOL] all_issues = repo . get_repo ( ) . get_issues ( state = [string] ) [EOL] for issue in all_issues : [EOL] if issue . title == name : [EOL] return issue [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[github.Issue.Issue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[github.Issue.Issue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[github.Issue.Issue]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import bs4 [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] from bs4 import BeautifulSoup [EOL] from bs4 . element import Tag [EOL] [EOL] from shared import configuration , fetch_tools [EOL] [EOL] from . import fetcher [EOL] [EOL] [EOL] def main ( changes ) : [EOL] ( link , new ) = fetcher . find_announcements ( ) [EOL] if new : [EOL] scrape ( link ) [EOL] changes . append ( [string] ) [EOL] [EOL] [EOL] def scrape ( url ) : [EOL] soup = BeautifulSoup ( fetch_tools . fetch ( url ) , [string] ) [EOL] for b in soup . find_all ( [string] ) : [EOL] parse_header ( b ) [EOL] [EOL] def parse_header ( h ) : [EOL] txt = h . text [EOL] if txt . startswith ( [string] ) : [EOL] parse_downtimes ( h ) [EOL] elif txt . startswith ( [string] ) : [EOL] parse_build_notes ( h ) [EOL] [EOL] def parse_build_notes ( h ) : [EOL] entries = [ ] [EOL] for n in h . next_elements : [EOL] if isinstance ( n , Tag ) and n . name == [string] : [EOL] if [string] in n . attrs . get ( [string] , [ ] ) : [EOL] break [EOL] if n . text : [EOL] entries . append ( n . text ) [EOL] [EOL] embed = { [string] : [string] , [string] : [string] , [string] : [string] . join ( entries ) , [string] : fetcher . find_announcements ( ) [ [number] ] , } [EOL] if configuration . get_optional_str ( [string] ) is not None : [EOL] fetch_tools . post_discord_webhook ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) , embeds = [ embed ] , username = [string] , avatar_url = [string] ) [EOL] [EOL] def parse_downtimes ( h ) : [EOL] for n in h . next_elements : [EOL] if isinstance ( n , Tag ) and n . text : [EOL] with open ( [string] , [string] , encoding = [string] ) as f : [EOL] txt = n . text . strip ( ) [EOL] txt = txt . replace ( [string] , [string] ) [EOL] print ( txt ) [EOL] f . write ( txt ) [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import requests [EOL] import typing [EOL] import json [EOL] [EOL] import requests [EOL] from lxml import etree [EOL] [EOL] from . import repo [EOL] [EOL] [EOL] def main ( ) : [EOL] manifest = requests . get ( [string] ) [EOL] tree = etree . fromstring ( manifest . content ) [EOL] identity = tree . find ( [string] ) [EOL] version = identity . attrib [ [string] ] [EOL] [EOL] print ( [string] . format ( version ) ) [EOL] [EOL] data = { [string] : version } [EOL] with open ( [string] , mode = [string] ) as f : [EOL] json . dump ( data , f ) [EOL] [EOL] project = repo . get_verification_project ( ) [EOL] current = [ c for c in project . get_columns ( ) if c . name == version ] [EOL] if not current : [EOL] print ( f' [string] { version }' ) [EOL] project . create_column ( version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Union [EOL] import shared_web [EOL] import builtins [EOL] import typing [EOL] import werkzeug [EOL] from typing import Any , Dict , Union [EOL] [EOL] from flask import redirect [EOL] from github_webhook import Webhook [EOL] from werkzeug import wrappers [EOL] [EOL] from shared_web . flask_app import PDFlask [EOL] [EOL] from . import webhooks [EOL] [EOL] APP = PDFlask ( __name__ ) [EOL] WEBHOOK = Webhook ( APP , endpoint = [string] ) [EOL] [EOL] @ APP . route ( [string] ) def home ( ) : [EOL] return [string] + APP . config [ [string] ] [EOL] [EOL] @ WEBHOOK . hook ( ) def on_push ( data ) : [EOL] ref = data [ [string] ] [EOL] print ( f' [string] { ref }' ) [EOL] return data [EOL] [EOL] @ WEBHOOK . hook ( event_type = [string] ) def on_status ( data ) : [EOL] sha = data . get ( [string] ) [EOL] context = data . get ( [string] ) [EOL] state = data . get ( [string] ) [EOL] print ( f' [string] { sha } [string] { context } [string] { state }' ) [EOL] if context == webhooks . PDM_CHECK_CONTEXT : [EOL] return [string] [EOL] pr = webhooks . get_pr_from_status ( data ) [EOL] if pr is None : [EOL] return [string] [EOL] print ( f' [string] { pr . number }' ) [EOL] webhooks . check_pr_for_mergability ( pr ) [EOL] return data [EOL] [EOL] @ WEBHOOK . hook ( event_type = [string] ) def on_check_suite ( data ) : [EOL] print ( [string] ) [EOL] return data [EOL] [EOL] @ WEBHOOK . hook ( event_type = [string] ) def on_pull_request ( data ) : [EOL] org , repo , pr_number = webhooks . parse_pr_url ( data [ [string] ] [ [string] ] ) [EOL] print ( [ org , repo , pr_number ] ) [EOL] if data [ [string] ] == [string] or data [ [string] ] == [string] : [EOL] webhooks . set_check ( data , [string] , [string] ) [EOL] pr = webhooks . load_pr ( data ) [EOL] webhooks . check_for_changelogs ( pr ) [EOL] if data [ [string] ] == [string] or data [ [string] ] == [string] : [EOL] pr = webhooks . load_pr ( data ) [EOL] if pr . state == [string] : [EOL] return webhooks . check_pr_for_mergability ( pr ) [EOL] if pr . state == [string] and [string] in [ l . name for l in pr . as_issue ( ) . labels ] : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] import uwsgi [comment] [EOL] uwsgi . reload ( ) [EOL] except ImportError : [EOL] pass [EOL] return [string] [EOL] return [string] [EOL] [EOL] @ APP . route ( [string] ) def card ( name ) : [EOL] return redirect ( [string] . format ( name = name ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Set , Tuple , List , Any [EOL] import github [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , List , Optional , Set , Tuple [EOL] [EOL] import changelogs [EOL] import packaging . version [EOL] import whatthepatch [EOL] from github import Github [EOL] from github . Commit import Commit [EOL] from github . File import File [EOL] from github . GithubException import UnknownObjectException [EOL] from github . PullRequest import PullRequest [EOL] from github . Repository import Repository [EOL] from requirements . requirement import Requirement [EOL] [EOL] from shared import configuration , decorators [EOL] from shared import redis_wrapper as redis [EOL] [EOL] PDM_CHECK_CONTEXT = [string] [EOL] [EOL] @ decorators . memoize def get_github ( ) : [EOL] if not configuration . get_str ( [string] ) or not configuration . get_str ( [string] ) : [EOL] return None [EOL] return Github ( configuration . get_str ( [string] ) , configuration . get_str ( [string] ) ) [EOL] [EOL] def parse_pr_url ( url ) : [EOL] split_url = url . split ( [string] ) [EOL] return split_url [ [number] ] , split_url [ [number] ] , int ( split_url [ [number] ] ) [EOL] [EOL] def load_pr ( data ) : [EOL] org , repo , pr_number = parse_pr_url ( data . get ( [string] , data . get ( [string] ) ) [ [string] ] ) [EOL] g = get_github ( ) [EOL] return g . get_repo ( f'{ org } [string] { repo }' ) . get_pull ( pr_number ) [EOL] [EOL] def load_commit ( data ) : [EOL] pr_data = data . get ( [string] ) [EOL] if pr_data is None : [EOL] return None [EOL] org , repo , _ = parse_pr_url ( pr_data [ [string] ] ) [EOL] head = pr_data . get ( [string] ) [EOL] g = get_github ( ) [EOL] return g . get_repo ( f'{ org } [string] { repo }' ) . get_commit ( head . get ( [string] ) ) [EOL] [EOL] def get_pr_from_status ( data ) : [EOL] g = get_github ( ) [EOL] repo = g . get_repo ( data [ [string] ] ) [EOL] return get_pr_from_commit ( repo , data [ [string] ] ) [EOL] [EOL] def get_pr_from_commit ( repo , sha ) : [EOL] cached = redis . get_int ( f' [string] { sha }' ) [EOL] if cached : [EOL] try : [EOL] pr = repo . get_pull ( cached ) [EOL] if pr . head . sha == sha and pr . state == [string] : [EOL] return pr [EOL] except UnknownObjectException : [EOL] pass [EOL] for pr in repo . get_pulls ( ) : [EOL] head = pr . head . sha [EOL] redis . store ( f' [string] { head }' , pr . number , ex = [number] ) [EOL] if head == sha : [EOL] return pr [EOL] return None [EOL] [EOL] def set_check ( data , status , message ) : [EOL] commit = load_commit ( data ) [EOL] if commit is not None : [EOL] commit . create_status ( state = status , description = message , context = PDM_CHECK_CONTEXT ) [EOL] [EOL] def check_for_changelogs ( pr ) : [EOL] for change in pr . get_files ( ) : [EOL] if change . filename == [string] : [EOL] lines = build_changelog ( change ) [EOL] for comment in pr . get_issue_comments ( ) : [EOL] if comment . body . startswith ( [string] ) : [EOL] [comment] [EOL] comment . edit ( body = [string] . join ( lines ) ) [EOL] break [EOL] else : [EOL] pr . create_issue_comment ( [string] . join ( lines ) ) [EOL] [EOL] def build_changelog ( change ) : [EOL] lines = [ [string] ] [EOL] patch = whatthepatch . parse_patch ( change . patch ) . __next__ ( ) [EOL] oldversions = { } [EOL] newversions = { } [EOL] for p in patch . changes : [EOL] if len ( p ) > [number] : [EOL] if p [ [number] ] is None : [EOL] req = Requirement . parse ( p [ [number] ] ) [EOL] if req . specs : [EOL] oldversions [ req . name ] = req . specs [ [number] ] [ [number] ] [EOL] else : [EOL] lines . append ( f' [string] { p [ [number] ] } [string] ' ) [EOL] elif p [ [number] ] is None : [EOL] req = Requirement . parse ( p [ [number] ] ) [EOL] if req . specs : [EOL] newversions [ req . name ] = req . specs [ [number] ] [ [number] ] [EOL] else : [EOL] lines . append ( f' [string] { p [ [number] ] } [string] ' ) [EOL] else : [EOL] lines . append ( [string] ) [EOL] for package in newversions : [EOL] old = packaging . version . parse ( oldversions . get ( package , [string] ) ) [EOL] new = packaging . version . parse ( newversions . get ( package , [string] ) ) [EOL] changes = changelogs . get ( package ) [EOL] logged = False [EOL] for version_string in changes . keys ( ) : [EOL] v = packaging . version . parse ( version_string ) [EOL] if old < v <= new : [EOL] lines . append ( f' [string] { package } [string] { version_string }' ) [EOL] lines . append ( changes [ version_string ] ) [EOL] logged = True [EOL] if not logged : [EOL] lines . append ( f' [string] { package } [string] { new }' ) [EOL] lines . append ( [string] ) [EOL] return lines [EOL] [EOL] def check_pr_for_mergability ( pr ) : [EOL] repo = pr . base . repo [EOL] commit = repo . get_commit ( pr . head . sha ) [EOL] checks = { } [EOL] blocked = False [EOL] for status in commit . get_statuses ( ) : [EOL] print ( status ) [EOL] if status . context == PDM_CHECK_CONTEXT : [EOL] continue [EOL] if checks . get ( status . context ) is None : [EOL] checks [ status . context ] = status . state [EOL] if status . state == [string] and status . context == [string] : [EOL] [comment] [EOL] continue [EOL] if status . state != [string] and not blocked : [EOL] commit . create_status ( state = [string] , description = f' [string] { status . context }' , context = PDM_CHECK_CONTEXT ) [EOL] blocked = True [EOL] travis_push = [string] [EOL] travis_pr = [string] [EOL] if blocked : [EOL] [comment] [EOL] if checks . get ( travis_push ) == [string] and checks . get ( travis_pr ) == [string] : [EOL] update_pr ( pr ) [EOL] return [string] [EOL] [EOL] if travis_pr not in checks . keys ( ) and travis_push in checks . keys ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] commit . create_status ( state = [string] , description = f' [string] { travis_pr }' , context = PDM_CHECK_CONTEXT ) [EOL] return f' [string] { travis_pr }' [EOL] [EOL] labels = [ l . name for l in pr . as_issue ( ) . labels ] [EOL] if [string] in labels : [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] return [string] [EOL] [EOL] whitelisted = pr . user in repo . get_collaborators ( ) [EOL] [EOL] if [string] in labels : [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] pr . merge ( merge_method = [string] ) [EOL] return [string] [EOL] [EOL] if not whitelisted and not [string] in labels : [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] return [string] [EOL] [EOL] if [string] in labels : [EOL] trying = repo . get_git_ref ( [string] ) [EOL] if trying . object . sha == commit . sha : [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] return [string] [EOL] trying . edit ( commit . sha , True ) [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] return [string] [EOL] [EOL] commit . create_status ( state = [string] , description = [string] , context = PDM_CHECK_CONTEXT ) [EOL] pr . merge ( ) [EOL] return [string] [EOL] [EOL] def update_pr ( pull ) : [EOL] repo = pull . base . repo [EOL] print ( f' [string] { pull . number } [string] ' ) [EOL] master = repo . get_branch ( [string] ) [EOL] base , head = get_common_tree ( repo , master . commit . sha , pull . head . sha ) [EOL] if head . issuperset ( base ) : [EOL] print ( [string] ) [EOL] return [EOL] print ( f' [string] { pull . number } [string] { pull . head . ref } [string] ' ) [EOL] repo . merge ( pull . head . ref , [string] , f' [string] { pull . number }' ) [EOL] [EOL] [EOL] def get_parents ( repo , sha ) : [EOL] value = redis . get_list ( f' [string] { repo . full_name } [string] { sha }' ) [EOL] if value is None : [EOL] [comment] [EOL] commit = repo . get_commit ( sha ) [EOL] parents = [ p . sha for p in commit . parents ] [EOL] redis . store ( f' [string] { repo . full_name } [string] { sha }' , list ( parents ) , ex = [number] ) [EOL] return parents [EOL] return value [EOL] [EOL] def get_tree ( repo , head , max_depth = [number] ) : [EOL] full_tree = set ( ) [EOL] to_walk = [ head ] [EOL] depth = [number] [EOL] while to_walk : [EOL] commit = to_walk . pop ( ) [EOL] if commit in full_tree : [EOL] continue [EOL] full_tree . add ( commit ) [EOL] to_walk . extend ( get_parents ( repo , commit ) ) [EOL] if max_depth : [EOL] depth = depth + [number] [EOL] if depth > max_depth : [EOL] break [EOL] return full_tree [EOL] [EOL] def get_common_tree ( repo , a , b ) : [EOL] depth = [number] [EOL] a_tree = set ( ) [EOL] b_tree = set ( ) [EOL] while a_tree . isdisjoint ( b_tree ) : [EOL] depth = depth + [number] [EOL] a_tree = get_tree ( repo , a , depth ) [EOL] b_tree = get_tree ( repo , b , depth ) [EOL] return a_tree , b_tree [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Set[builtins.str],typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import babel [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import re [EOL] from typing import Optional [EOL] [EOL] from babel . messages import pofile [EOL] from babel . messages . catalog import Catalog , Message [EOL] [EOL] [EOL] def ad_hoc ( ) : [EOL] for directory , _ , files in os . walk ( os . path . join ( [string] , [string] ) ) : [EOL] for path in [ os . path . join ( directory , f ) for f in files if os . path . splitext ( f ) [ [number] ] == [string] ] : [EOL] print ( path ) [EOL] validate_pofile ( path ) [EOL] [EOL] def validate_pofile ( path ) : [EOL] with open ( path , mode = [string] ) as f : [EOL] catalog = pofile . read_po ( f ) [EOL] messages = list ( catalog ) [EOL] for message in messages : [EOL] if message . id and message . string : [EOL] validate_string ( message , catalog ) [EOL] f . seek ( [number] ) [EOL] f . truncate ( ) [EOL] pofile . write_po ( f , catalog ) [EOL] [EOL] def validate_string ( message , catalog ) : [EOL] if isinstance ( message . string , str ) : [EOL] warning = has_missing_var ( message . id , message . string ) [EOL] if warning : [EOL] error ( message , catalog , warning ) [EOL] else : [EOL] for x in range ( len ( message . string ) ) : [EOL] s = message . string [ x ] [EOL] try : [EOL] warning = has_missing_var ( message . id [ x ] , s ) [EOL] except IndexError : [EOL] [comment] [EOL] warning = has_missing_var ( message . id [ - [number] ] , s ) [EOL] if warning : [EOL] error ( message , catalog , warning ) [EOL] return [EOL] [EOL] [EOL] def has_missing_var ( english , string ) : [EOL] for m in re . findall ( [string] , english ) : [EOL] if not m in string : [EOL] return [string] . format ( m = m ) [EOL] nums = len ( re . findall ( [string] , english ) ) [EOL] if len ( re . findall ( [string] , string ) ) != nums : [EOL] return [string] [EOL] return None [EOL] [EOL] def error ( message , catalog , warning ) : [EOL] print ( [string] . format ( message = message . id , lang = catalog . locale , warning = warning , str = message . string ) ) [EOL] [comment] [EOL] catalog . add ( message . id , message . string , flags = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , List [EOL] import typing [EOL] import shared [EOL] from decksite . data import person [EOL] from decksite . database import db [EOL] from shared import logger [EOL] from shared . container import Container [EOL] [EOL] from . import elo [EOL] [EOL] USERNAME_COLUMNS = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] def run ( ) : [EOL] run_elo = False [EOL] [comment] [EOL] for i in range ( [number] , len ( USERNAME_COLUMNS ) ) : [EOL] [comment] [EOL] for j in range ( i + [number] , len ( USERNAME_COLUMNS ) ) : [EOL] sql = [string] . format ( col1 = USERNAME_COLUMNS [ i ] , col2 = USERNAME_COLUMNS [ j ] ) [EOL] pairs = [ Container ( row ) for row in db ( ) . select ( sql ) ] [EOL] if len ( pairs ) > [number] : [EOL] run_elo = True [EOL] for pair in pairs : [EOL] person . squash ( pair . p1_id , pair . p2_id , pair . col1 , pair . col2 ) [EOL] if run_elo : [EOL] logger . warning ( [string] ) [EOL] elo . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from analysis import analysis [EOL] [EOL] [EOL] [comment] [EOL] def ad_hoc ( ) : [EOL] analysis . process_logs ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List , Any , Generator [EOL] import builtins [EOL] import distutils [EOL] import typing [EOL] import subprocess [EOL] from distutils . dist import Distribution [comment] [EOL] from typing import Any , Dict , Generator , List [EOL] [EOL] import pystache [EOL] from babel . messages import frontend [EOL] from poeditor . client import POEditorAPI [EOL] [EOL] from shared import configuration [EOL] from shared_web import template [EOL] [EOL] [EOL] def ad_hoc ( ) : [EOL] dist = Distribution ( dict ( name = [string] ) ) [EOL] dist . message_extractors = { [string] : [ ( [string] , [string] , { } ) , ( [string] , extract_mustache , { } ) ] , [string] : [ ( [string] , [string] , { } ) , ( [string] , extract_mustache , { } ) ] } [EOL] compiler = frontend . extract_messages ( dist ) [EOL] compiler . initialize_options ( ) [EOL] compiler . output_file = [string] [EOL] compiler . input_paths = [ [string] , [string] ] [EOL] compiler . finalize_options ( ) [EOL] compiler . run ( ) [EOL] [EOL] api_key = configuration . get ( [string] ) [EOL] if api_key is None : [EOL] return exitcode ( ) [EOL] client = POEditorAPI ( api_token = api_key ) [EOL] client . update_terms ( [string] , [string] ) [EOL] return exitcode ( ) [EOL] [EOL] def exitcode ( ) : [EOL] numstat = subprocess . check_output ( [ [string] , [string] , [string] ] ) . strip ( ) . decode ( ) . split ( [string] ) [EOL] for line in numstat : [EOL] added , deleted , path = line . split ( [string] ) [EOL] if path . endswith ( [string] ) : [EOL] if int ( added ) > [number] : [EOL] [comment] [EOL] return max ( int ( added ) , int ( deleted ) ) - [number] [EOL] return [number] [EOL] [EOL] [comment] [EOL] def extract_mustache ( fileobj , keywords , comment_tags , options ) : [EOL] [docstring] [EOL] source = fileobj . read ( ) . decode ( options . get ( [string] , [string] ) ) [EOL] tree = template . insert_gettext_nodes ( pystache . parse ( source ) ) [EOL] for node in tree . _parse_tree : [EOL] if isinstance ( node , template . _GettextNode ) : [EOL] yield [number] , None , node . key , [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import io [EOL] import builtins [EOL] import typing [EOL] import re [EOL] import subprocess [EOL] from typing import List [EOL] [EOL] from shared import fetch_tools [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] PATH = [string] [EOL] [EOL] def ad_hoc ( ) : [EOL] tags = [ fetch_script_tag ( library ) + [string] for library in get_dependencies ( ) if len ( library ) > [number] ] [EOL] output = [string] . join ( tags ) [EOL] write_dependencies ( output ) [EOL] send_pr_if_updated ( ) [EOL] [EOL] def get_dependencies ( ) : [EOL] f = open ( [string] , [string] ) [EOL] return [ line . strip ( ) for line in f . readlines ( ) ] [EOL] [EOL] def write_dependencies ( s ) : [EOL] f = open ( PATH , [string] ) [EOL] f . write ( s ) [EOL] [EOL] def send_pr_if_updated ( ) : [EOL] subprocess . call ( [ [string] , [string] , PATH ] ) [EOL] if subprocess . call ( [ [string] , [string] , [string] , [string] ] ) == [number] : [EOL] subprocess . call ( [ [string] , [string] ] ) [EOL] subprocess . call ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def fetch_script_tag ( entry ) : [EOL] parts = entry . split ( [string] ) [EOL] library = parts [ [number] ] [EOL] file = parts [ [number] ] if len ( parts ) == [number] else parts [ [number] ] [EOL] info = fetch_tools . fetch_json ( f' [string] { library }' ) [EOL] version = info . get ( [string] ) [EOL] if not version and library . lower ( ) != library : [EOL] library = library . lower ( ) [EOL] info = fetch_tools . fetch_json ( f' [string] { library }' ) [EOL] version = info . get ( [string] ) [EOL] if not version : [EOL] raise DoesNotExistException ( f' [string] { library }' ) [EOL] path = None [EOL] for a in info [ [string] ] : [EOL] if a . get ( [string] ) == version : [EOL] for f in a [ [string] ] : [EOL] if minified_path ( f , file ) : [EOL] path = f [EOL] break [EOL] if unminified_path ( f , file ) : [EOL] path = f [EOL] if not path : [EOL] raise DoesNotExistException ( f' [string] { library }' ) [EOL] return f' [string] { library } [string] { version } [string] { path } [string] ' [EOL] [EOL] def minified_path ( path , library ) : [EOL] return test_path ( path , library , [string] ) [EOL] [EOL] def unminified_path ( path , library ) : [EOL] return test_path ( path , library ) [EOL] [EOL] def test_path ( path , library , required = [string] ) : [EOL] [comment] [EOL] if [string] in path : [EOL] return False [EOL] name_without_js = library . replace ( [string] , [string] ) [EOL] regex = fr'{ name_without_js } [string] { required } [string] ' [EOL] return bool ( re . search ( regex , path , re . IGNORECASE ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , List [EOL] import typing [EOL] import magic [EOL] import hashlib [EOL] [EOL] from decksite . data import deck [EOL] from decksite . database import db [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] def run ( ) : [EOL] all_decks = deck . load_decks ( ) [EOL] for d in all_decks : [EOL] [comment] [EOL] cards = { [string] : d [ [string] ] , [string] : d [ [string] ] } [EOL] deckhash = hashlib . sha1 ( repr ( cards ) . encode ( [string] ) ) . hexdigest ( ) [EOL] if d [ [string] ] != deckhash : [EOL] print ( f"{ d . id } [string] { d [ [string] ] } [string] { deckhash }" ) [EOL] db ( ) . execute ( [string] , [ deckhash , d [ [string] ] ] ) [EOL] redis . clear ( f' [string] { d . id }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from decksite . database import db [EOL] [EOL] [EOL] def run ( ) : [EOL] sql = [string] [EOL] db ( ) . execute ( sql ) [EOL]	0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List [EOL] import typing [EOL] import os [EOL] [EOL] from babel . messages . frontend import compile_catalog [EOL] from poeditor . client import POEditorAPI [EOL] [EOL] from shared import configuration , logger [EOL] [EOL] from . import validate_translations [EOL] [EOL] [EOL] def run ( ) : [EOL] api_key = configuration . get ( [string] ) [EOL] if api_key is None : [EOL] logger . warning ( [string] ) [EOL] return [EOL] client = POEditorAPI ( api_token = api_key ) [EOL] languages = client . list_project_languages ( [string] ) [EOL] [comment] [EOL] for locale in languages : [EOL] logger . warning ( [string] . format ( code = locale [ [string] ] , percent = locale [ [string] ] ) ) [EOL] if locale [ [string] ] > [number] : [EOL] path = os . path . join ( [string] , [string] , locale [ [string] ] . replace ( [string] , [string] ) , [string] ) [EOL] if not os . path . exists ( path ) : [EOL] os . makedirs ( path ) [EOL] pofile = os . path . join ( path , [string] ) [EOL] logger . warning ( [string] . format ( pofile ) ) [EOL] if os . path . exists ( pofile ) : [EOL] os . remove ( pofile ) [EOL] client . export ( project_id = [string] , language_code = locale [ [string] ] , local_file = pofile , filters = [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] validate_translations . ad_hoc ( ) [EOL] compiler = compile_catalog ( ) [EOL] compiler . directory = os . path . join ( [string] , [string] ) [EOL] compiler . domain = [ [string] ] [EOL] compiler . run ( ) [EOL] [comment] [EOL] path = os . path . join ( [string] , [string] , [string] , [string] ) [EOL] if not os . path . exists ( path ) : [EOL] os . makedirs ( path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from maintenance import validate_translations [EOL] [EOL] [EOL] def test_has_missing_var ( ) : [EOL] english_s = [string] [EOL] correct_s = [string] [EOL] assert validate_translations . has_missing_var ( english_s , correct_s ) is None [EOL] incorrect_s = [string] [EOL] assert validate_translations . has_missing_var ( english_s , incorrect_s ) is not None [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import magic [EOL] from decksite . data import archetype , card , deck , person , season [EOL] from magic import multiverse , oracle [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] def run ( ) : [EOL] multiverse . rebuild_cache ( ) [EOL] oracle . init ( ) [EOL] ds = deck . load_decks ( ) [EOL] for d in ds : [EOL] redis . clear ( f' [string] { d . id }' ) [EOL] deck . prime_cache ( d ) [EOL] redis . clear ( f' [string] { d . id }' ) [EOL] archetype . preaggregate ( ) [EOL] person . preaggregate ( ) [EOL] card . preaggregate ( ) [EOL] deck . preaggregate ( ) [EOL] season . preaggregate ( ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Sequence [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] from typing import Dict [EOL] [EOL] from decksite . data import elo , person [EOL] from decksite . database import db [EOL] from shared import logger [EOL] [EOL] PEOPLE = { } [EOL] [EOL] def run ( ) : [EOL] sql = [string] [EOL] matches = db ( ) . select ( sql ) [EOL] for m in matches : [EOL] match ( m ) [EOL] current = person . load_people ( ) [EOL] people_by_id = { p . id : p for p in current } [EOL] sql = [string] [EOL] for person_id , new_elo in sorted ( PEOPLE . items ( ) , key = lambda x : - x [ [number] ] ) : [EOL] p = people_by_id [ int ( person_id ) ] [EOL] if p . elo != new_elo : [EOL] logger . warning ( [string] . format ( id = p . id , current_elo = p . elo , new_elo = new_elo ) ) [EOL] db ( ) . execute ( sql , [ new_elo , p . id ] ) [EOL] [EOL] def match ( m ) : [EOL] if [string] not in m [ [string] ] : [EOL] return [comment] [EOL] if int ( m [ [string] ] . split ( [string] ) [ [number] ] ) == [number] : [EOL] winner = m [ [string] ] . split ( [string] ) [ [number] ] [EOL] loser = m [ [string] ] . split ( [string] ) [ [number] ] [EOL] elif int ( m [ [string] ] . split ( [string] ) [ [number] ] ) == [number] : [EOL] winner = m [ [string] ] . split ( [string] ) [ [number] ] [EOL] loser = m [ [string] ] . split ( [string] ) [ [number] ] [EOL] else : [EOL] return [comment] [EOL] adjust ( winner , loser ) [EOL] [EOL] def adjust ( winner , loser ) : [EOL] winner_elo = get_elo ( winner ) [EOL] loser_elo = get_elo ( loser ) [EOL] change = elo . adjustment ( winner_elo , loser_elo ) [EOL] PEOPLE [ winner ] = winner_elo + change [EOL] PEOPLE [ loser ] = loser_elo - change [EOL] [EOL] def get_elo ( person_id ) : [EOL] return PEOPLE . get ( person_id , elo . STARTING_ELO ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import magic [EOL] from decksite . data import archetype , deck [EOL] [EOL] HOURLY = True [EOL] [EOL] def run ( ) : [EOL] decks = deck . load_decks ( [string] ) [EOL] deck . calculate_similar_decks ( decks ) [EOL] for d in decks : [EOL] for s in d . similar_decks : [EOL] if s . reviewed and s . archetype_id is not None : [EOL] sim = int ( [number] * deck . similarity_score ( d , s ) ) [EOL] if d . archetype_id != s . archetype_id : [EOL] archetype . assign ( d . id , s . archetype_id , None , False , sim ) [EOL] break [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Union , List , Literal [EOL] import typing_extensions [EOL] import typing [EOL] import gzip [EOL] import subprocess [EOL] [EOL] from shared import configuration [EOL] from shared . pd_exception import InvalidArgumentException [EOL] [EOL] [EOL] def run ( ) : [EOL] [docstring] [EOL] host = configuration . get_str ( [string] ) [EOL] port = configuration . get_int ( [string] ) [EOL] usr = configuration . get_str ( [string] ) [EOL] pwd = configuration . get_str ( [string] ) [EOL] db = configuration . get_str ( [string] ) [EOL] if not ( host or port or usr or pwd or db ) : [EOL] safe_pwd = [string] if pwd else [string] [EOL] raise InvalidArgumentException ( f' [string] { host } [string] { port } [string] { usr } [string] { safe_pwd } [string] { db }' ) [EOL] base_command = [ [string] , [string] , host , [string] , str ( port ) , [string] , usr , f' [string] { pwd }' ] [EOL] structure = subprocess . check_output ( base_command + [ [string] , db ] ) [EOL] data = subprocess . check_output ( base_command + [ f' [string] { db } [string] ' , db ] ) [EOL] with gzip . open ( [string] , [string] ) as f : [EOL] f . write ( structure ) [EOL] f . write ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import decksite [EOL] import time [EOL] [EOL] from decksite . data import archetype , deck [EOL] [EOL] [EOL] def ad_hoc ( ) : [EOL] archetypes = archetype . load_archetypes ( ) [EOL] for a in archetypes : [EOL] print ( f' [string] { a . name } [string] { len ( a . decks ) } [string] ' ) [EOL] s = time . perf_counter ( ) [EOL] deck . calculate_similar_decks ( a . decks ) [EOL] t = time . perf_counter ( ) - s [EOL] print ( f' [string] { len ( a . decks ) } [string] { t }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import time [EOL] [EOL] from magic import multiverse [EOL] [EOL] REQUIRES_APP_CONTEXT = False [EOL] [EOL] def run ( ) : [EOL] start = time . time ( ) [EOL] multiverse . reindex ( ) [EOL] end = time . time ( ) [EOL] print ( [string] . format ( t = ( end - start ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] [EOL] from decksite import league [EOL] from magic import multiverse [EOL] from shared import dtutil [EOL] from shared import redis_wrapper as redis [EOL] [EOL] from . import insert_seasons , reprime_cache [EOL] [EOL] [EOL] def ad_hoc ( ) : [EOL] try : [EOL] event_loop = asyncio . get_event_loop ( ) [EOL] except RuntimeError : [EOL] event_loop = asyncio . new_event_loop ( ) [EOL] asyncio . set_event_loop ( event_loop ) [EOL] [EOL] league . set_status ( league . Status . CLOSED ) [EOL] multiverse . init ( ) [comment] [EOL] event_loop . run_until_complete ( multiverse . set_legal_cards_async ( ) ) [comment] [EOL] event_loop . run_until_complete ( multiverse . update_pd_legality_async ( ) ) [comment] [EOL] insert_seasons . run ( ) [comment] [EOL] if redis . REDIS : [comment] [EOL] redis . REDIS . flushdb ( ) [EOL] league_end = league . active_league ( ) . end_date [EOL] diff = league_end - dtutil . now ( ) [EOL] if diff . days > [number] : [EOL] league . set_status ( league . Status . OPEN ) [EOL] print ( [string] ) [EOL] reprime_cache . run ( ) [comment] [EOL] if redis . REDIS : [comment] [EOL] redis . REDIS . flushdb ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import datetime [EOL] import magic [EOL] from decksite . database import db [EOL] from magic import rotation [EOL] from shared import dtutil [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] [EOL] def run ( ) : [EOL] existing = list ( map ( lambda s : s [ [string] ] , db ( ) . select ( [string] ) ) ) [EOL] for season , setcode in enumerate ( rotation . SEASONS , start = [number] ) : [EOL] if not season in existing : [EOL] try : [EOL] info = rotation . get_set_info ( setcode ) [EOL] except DoesNotExistException as e : [EOL] print ( f' [string] { setcode } [string] { e }' ) [EOL] continue [EOL] if info . enter_date_dt < dtutil . now ( ) : [EOL] print ( [string] . format ( setcode ) ) [EOL] season_start = info . enter_date_dt + rotation . ROTATION_OFFSET [EOL] db ( ) . execute ( [string] , [ season , setcode , dtutil . dt2ts ( season_start ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import shared_web [EOL] import builtins [EOL] import typing [EOL] from shared import redis_wrapper as redis [EOL] from shared_web . flask_app import PDFlask [EOL] [EOL] APP = PDFlask ( __name__ ) [EOL] [EOL] @ APP . route ( [string] ) def home ( ) : [EOL] cid = redis . get_str ( [string] ) [EOL] return f' [string] { cid }' [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) def rotate ( ) : [EOL] redis . store ( [string] , True ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pylint [EOL] from pylint . lint import PyLinter [EOL] [EOL] from . await_checker import AsyncAwaitChecker [EOL] from . l18n_check import TranslationStringConstantsChecker [EOL] from . monolith_checker import MonolithChecker [EOL] [EOL] [EOL] def register ( linter ) : [EOL] [docstring] [EOL] linter . register_checker ( MonolithChecker ( linter ) ) [EOL] linter . register_checker ( TranslationStringConstantsChecker ( linter ) ) [EOL] linter . register_checker ( AsyncAwaitChecker ( linter ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import pylint_monolith [EOL] import pylint [EOL] import typing [EOL] import astroid [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import astroid [EOL] import six [EOL] from astroid . node_classes import NodeNG [EOL] from pylint . checkers import BaseChecker , utils [EOL] from pylint . interfaces import IAstroidChecker [EOL] from pylint . lint import PyLinter [EOL] [EOL] BASE_ID = [number] [EOL] [EOL] [EOL] def register_checkers ( linter ) : [EOL] [docstring] [EOL] linter . register_checker ( TranslationStringConstantsChecker ( linter ) ) [EOL] [EOL] [EOL] class TranslationStringConstantsChecker ( BaseChecker ) : [EOL] [docstring] [EOL] [EOL] __implements__ = IAstroidChecker [EOL] [EOL] name = [string] [EOL] [EOL] TRANSLATION_FUNCTIONS = set ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] [EOL] MESSAGE_ID = [string] [EOL] msgs = { [string] : ( [string] , MESSAGE_ID , [string] , ) , } [EOL] [EOL] @ utils . check_messages ( * ( msgs . keys ( ) ) ) def visit_call ( self , node ) : [EOL] [docstring] [EOL] if not isinstance ( node . func , astroid . Name ) : [EOL] [comment] [EOL] return [EOL] [EOL] if node . func . name not in self . TRANSLATION_FUNCTIONS : [EOL] [comment] [EOL] return [EOL] [EOL] if not self . linter . is_message_enabled ( self . MESSAGE_ID , line = node . fromlineno ) : [EOL] return [EOL] [EOL] first = node . args [ [number] ] [EOL] if isinstance ( first , astroid . Const ) : [EOL] if isinstance ( first . value , six . string_types ) : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] self . add_message ( self . MESSAGE_ID , args = node . func . name , node = node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 $astroid.node_classes.NodeNG$ 0 0
from typing import Type [EOL] import pylint_monolith [EOL] import pylint [EOL] import typing [EOL] import astroid [EOL] [docstring] [EOL] [EOL] import astroid [EOL] from astroid . node_classes import NodeNG [EOL] from pylint . checkers import BaseChecker , utils [EOL] from pylint . interfaces import IAstroidChecker [EOL] [EOL] [EOL] def register ( linter ) : [EOL] linter . register_checker ( AsyncAwaitChecker ( linter ) ) [EOL] [EOL] [EOL] class AsyncAwaitChecker ( BaseChecker ) : [EOL] [docstring] [EOL] [EOL] __implements__ = IAstroidChecker [EOL] [EOL] name = [string] [EOL] [EOL] MESSAGE_ID = [string] [EOL] msgs = { [string] : ( [string] , MESSAGE_ID , [string] , ) , } [EOL] [EOL] [comment] [EOL] @ utils . check_messages ( MESSAGE_ID ) def visit_callfunc ( self , node ) : [EOL] [docstring] [EOL] if not self . linter . is_message_enabled ( self . MESSAGE_ID ) : [EOL] return [EOL] [EOL] func_def = utils . safe_infer ( node . func ) [EOL] if isinstance ( func_def , astroid . BoundMethod ) : [EOL] func_def = func_def . _proxied [EOL] if isinstance ( func_def , astroid . UnboundMethod ) : [EOL] func_def = func_def . _proxied [EOL] if isinstance ( func_def , astroid . AsyncFunctionDef ) : [EOL] if not isinstance ( node . parent , astroid . Await ) : [EOL] self . add_message ( self . MESSAGE_ID , args = func_def . name , node = node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $astroid.node_classes.NodeNG$ 0 $astroid.node_classes.NodeNG$ 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import magic [EOL] import discord [EOL] import re [EOL] from typing import Optional [EOL] [EOL] from discord import Client , Emoji [EOL] [EOL] from magic import oracle , rotation [EOL] from magic . models import Card [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] def find_emoji ( emoji , client ) : [EOL] try : [EOL] for guild in client . guilds : [EOL] emojis = guild . emojis [EOL] res = next ( ( x for x in emojis if x . name == emoji ) , None ) [EOL] if res is not None : [EOL] return res [EOL] return None [EOL] except AttributeError : [EOL] return None [EOL] [EOL] def replace_emoji ( text , client ) : [EOL] if text is None : [EOL] return [string] [EOL] output = text [EOL] symbols = re . findall ( [string] , text ) [EOL] for symbol in symbols : [EOL] name = symbol [EOL] name = name . replace ( [string] , [string] ) [EOL] if len ( name ) == [number] : [EOL] if re . fullmatch ( [string] , name ) : [EOL] name = [string] + name [EOL] else : [EOL] name = name + name [EOL] emoji = find_emoji ( name , client ) [EOL] if emoji is not None : [EOL] output = output . replace ( [string] + symbol + [string] , str ( emoji ) ) [EOL] return output [EOL] [EOL] def info_emoji ( c , verbose = False , show_legality = True , no_rotation_hype = False ) : [EOL] s = [string] [EOL] rot_emoji = [string] [EOL] if show_legality : [EOL] legal = c . name in oracle . legal_cards ( ) [EOL] if legal : [EOL] s += [string] [EOL] else : [EOL] s += [string] [EOL] if rotation . in_rotation ( ) and not no_rotation_hype : [EOL] rot_emoji = get_future_legality ( c , legal ) [EOL] s += rot_emoji [EOL] if not legal and verbose and not rot_emoji : [EOL] s += [string] [EOL] [EOL] if c . bugs : [EOL] s += [string] [EOL] return s [EOL] [EOL] def get_future_legality ( c , legal ) : [EOL] out_emoji = [string] [EOL] for status , symbol in { [string] : [string] , [string] : [string] , [string] : out_emoji } . items ( ) : [EOL] if redis . sismember ( f' [string] { status }' , c . name ) : [EOL] return symbol [EOL] if rotation . read_rotation_files ( ) [ [number] ] <= ( rotation . TOTAL_RUNS / [number] ) : [EOL] return [string] [EOL] if legal : [EOL] return out_emoji [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[discord.Emoji]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import ContextForTests [EOL] from typing import Dict , Optional , Tuple , List , Any [EOL] import discordbot [EOL] import builtins [EOL] import magic [EOL] import discord [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from typing import Any , Dict , List , Optional , Tuple , cast [EOL] [EOL] import discord [EOL] import pytest [EOL] [EOL] from discordbot . bot import Bot [EOL] from discordbot . command import MtgContext [EOL] from discordbot . commands import CardConverter [EOL] from magic . models import Card [EOL] from shared . container import Container [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def discordbot ( ) : [EOL] bot = Bot ( ) [EOL] return bot [EOL] [EOL] class ContextForTests ( MtgContext ) : [EOL] def __init__ ( self , ** attrs ) : [comment] [EOL] self . sent = False [EOL] self . sent_args = False [EOL] self . sent_file = False [EOL] self . content = None [EOL] [EOL] async def send ( self , content , * args , ** kwargs ) : [comment] [EOL] self . sent = True [EOL] self . sent_args = bool ( args ) [EOL] self . sent_file = [string] in kwargs . keys ( ) [EOL] self . content = content [EOL] [EOL] def typing ( self ) : [EOL] return self [EOL] [EOL] def __enter__ ( self ) : [EOL] pass [EOL] [EOL] async def __aenter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc , tb ) : [comment] [EOL] pass [EOL] [EOL] async def __aexit__ ( self , exc_type , exc , tb ) : [comment] [EOL] pass [EOL] [EOL] async def card ( param ) : [EOL] ctx = ContextForTests ( ) [EOL] return cast ( Card , await CardConverter . convert ( ctx , param ) ) [EOL] [EOL] [EOL] def get_params ( ) : [EOL] async def params ( ) : [EOL] return [ ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { [string] : None } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { [string] : await card ( [string] ) } , [string] ) , ( [string] , { [string] : await card ( [string] ) } , [string] ) , ( [string] , { [string] : await card ( [string] ) } , [string] ) , ( [string] , { [string] : await card ( [string] ) } , [string] ) , ( [string] , { [string] : await card ( [string] ) } , [string] ) , ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { [string] : await card ( [string] ) } , None ) , pytest . param ( [string] , { } , None , marks = pytest . mark . functional ) , ( [string] , { } , None ) , ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { } , None ) , pytest . param ( [string] , { } , None , marks = pytest . mark . functional ) , ( [string] , { [string] : await card ( [string] ) } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { } , None ) , ( [string] , { } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { [string] : [string] } , None ) , ( [string] , { [string] : [string] } , None ) ] [EOL] loop = asyncio . new_event_loop ( ) [EOL] return loop . run_until_complete ( params ( ) ) [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , get_params ( ) ) async def test_command ( discordbot , cmd , kwargs , expected_content ) : [comment] [EOL] command = discordbot . all_commands [ cmd ] [EOL] ctx = ContextForTests ( ) [EOL] ctx . bot = discordbot [EOL] ctx . message = Container ( ) [EOL] ctx . message . channel = Container ( { [string] : [string] } ) [EOL] ctx . message . channel . typing = ctx . typing [EOL] ctx . message . channel . send = ctx . send [EOL] ctx . author = Container ( ) [EOL] ctx . author . mention = [string] [EOL] await command . callback ( ctx , ** kwargs ) [EOL] assert ctx . sent [EOL] if expected_content is not None and ctx . content is not None : [EOL] assert expected_content in ctx . content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $discordbot.bot.Bot$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $ContextForTests.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $ContextForTests.typing.Any$ 0 0 $ContextForTests.typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $ContextForTests.typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $ContextForTests.typing.Any$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $'ContextForTests'$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $'ContextForTests'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple]$ 0 0 0 0 0 0 $typing.List[typing.Tuple]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import magic [EOL] from discordbot import command [EOL] from discordbot . commands import resources [EOL] [EOL] [EOL] def test_roughly_matches ( ) : [EOL] assert command . roughly_matches ( [string] , [string] ) [EOL] assert command . roughly_matches ( [string] , [string] ) [EOL] assert not command . roughly_matches ( [string] , [string] ) [EOL] assert command . roughly_matches ( [string] , [string] ) [EOL] assert command . roughly_matches ( [string] , [string] ) [EOL] [EOL] def test_results_from_queries ( ) : [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] result = command . results_from_queries ( [ [string] ] ) [ [number] ] [ [number] ] [EOL] assert result . has_match ( ) [EOL] assert not result . is_ambiguous ( ) [EOL] assert result . get_best_match ( ) == [string] [EOL] [EOL] [EOL] def test_do_not_choke_on_unicode ( ) : [EOL] s = [string] [EOL] [comment] [EOL] result = command . results_from_queries ( [ s ] ) [ [number] ] [ [number] ] [EOL] assert not result . has_match ( ) [EOL] [comment] [EOL] for result , _ , _ in command . results_from_queries ( list ( s ) ) : [EOL] assert not result . has_match ( ) [EOL] [EOL] def test_resources_matching_in_url ( ) : [EOL] results = resources . resources_resources ( [string] ) [EOL] assert results [ [string] ] == [string] [EOL] [EOL] results = resources . resources_resources ( [string] ) [EOL] assert results [ [string] ] == [string] [EOL] [EOL] def test_escape_underscores ( ) : [EOL] r = command . escape_underscores ( [string] ) [EOL] assert r == [string] [EOL] r = command . escape_underscores ( [string] ) [EOL] assert r == [string] [EOL] r = command . escape_underscores ( [string] ) [EOL] assert r == [string] [EOL] r = command . escape_underscores ( [string] ) [EOL] assert r == [string] [EOL] r = command . escape_underscores ( [string] ) [EOL] assert r == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from discordbot import emoji [EOL] from shared . container import Container [EOL] [EOL] [EOL] def test_info_emoji ( ) : [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ ] } ) , verbose = False , show_legality = True , no_rotation_hype = True ) [EOL] assert r == [string] [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ ] } ) , verbose = True , show_legality = True , no_rotation_hype = True ) [EOL] assert r == [string] [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ { } , { } ] } ) , verbose = False , show_legality = False , no_rotation_hype = True ) [EOL] assert r == [string] [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ ] } ) , verbose = False , show_legality = False , no_rotation_hype = True ) [EOL] assert r == [string] [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ { } ] } ) , verbose = False , show_legality = True , no_rotation_hype = True ) [EOL] assert r == [string] [EOL] r = emoji . info_emoji ( Container ( { [string] : [string] , [string] : [ { } ] } ) , verbose = False , show_legality = True , no_rotation_hype = True ) [EOL] assert r == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Set [EOL] import io [EOL] import discordbot [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from typing import Set [EOL] [EOL] from discordbot import commands [EOL] from discordbot . bot import Bot [EOL] [EOL] HEADER = [string] [EOL] [EOL] USAGE = [string] [EOL] [EOL] FOOTER = [string] [EOL] [EOL] def generate_readme ( ) : [EOL] readme = [string] [EOL] readme += HEADER [EOL] readme += USAGE [EOL] readme += [string] [EOL] readme += print_commands ( ) [EOL] [EOL] readme += [string] [EOL] readme += FOOTER [EOL] [EOL] fh = open ( os . path . join ( [string] , [string] ) ) [EOL] old_readme = fh . read ( ) [EOL] fh . close ( ) [EOL] [EOL] if readme != old_readme : [EOL] fh = open ( os . path . join ( [string] , [string] ) , mode = [string] ) [EOL] fh . write ( readme ) [EOL] fh . close ( ) [EOL] print ( [string] ) [EOL] return [number] [EOL] return [number] [EOL] [EOL] def print_commands ( ) : [EOL] bot = Bot ( ) [EOL] commands . setup ( bot ) [EOL] text = [string] [EOL] done = set ( ) [EOL] for c in bot . walk_commands ( ) : [EOL] if not c . name in done : [EOL] text += f' [string] { c . name }' [EOL] if c . aliases : [EOL] aliases = [string] . join ( c . aliases ) [EOL] text += f' [string] { aliases } [string] ' [EOL] done . add ( c . name ) [EOL] text += f' [string] { c . help } [string] ' [EOL] return text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from discord import FFmpegPCMAudio , Member [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] @ commands . command ( ) async def modofail ( ctx , args ) : [EOL] [docstring] [EOL] if args is not None and args . lower ( ) == [string] : [EOL] redis . clear ( f' [string] { ctx . guild }' ) [EOL] author = ctx . author [EOL] if isinstance ( author , Member ) and hasattr ( author , [string] ) and author . voice is not None and author . voice . channel is not None : [EOL] voice_channel = ctx . author . voice . channel [EOL] voice = ctx . channel . guild . voice_client [EOL] if voice is None : [EOL] voice = await voice_channel . connect ( ) [EOL] elif voice . channel != voice_channel : [EOL] voice . move_to ( voice_channel ) [EOL] voice . play ( FFmpegPCMAudio ( [string] ) ) [EOL] n = redis . increment ( f' [string] { ctx . guild }' ) [EOL] redis . expire ( f' [string] { ctx . guild }' , [number] ) [EOL] await ctx . send ( f' [string] { n }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import magic [EOL] import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher , rotation [EOL] from magic . models import Card [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def history ( ctx , * , c ) : [EOL] [docstring] [EOL] await ctx . single_card_text ( c , card_history , show_legality = False ) [EOL] [EOL] def card_history ( c ) : [EOL] seasons = { } [EOL] for format_name , status in c . legalities . items ( ) : [EOL] if [string] in format_name and status == [string] : [EOL] season_id = rotation . SEASONS . index ( format_name . replace ( [string] , [string] ) ) + [number] [EOL] seasons [ season_id ] = True [EOL] seasons [ rotation . current_season_num ( ) ] = c . legalities . get ( [string] , None ) == [string] [EOL] s = [string] [EOL] for i in range ( [number] , rotation . current_season_num ( ) + [number] ) : [EOL] s += f'{ i } [string] ' [EOL] s += [string] if seasons . get ( i , False ) else [string] [EOL] s += [string] [EOL] s = s . strip ( ) [EOL] s += [string] + fetcher . decksite_url ( [string] . format ( name = fetch_tools . escape ( c . name , skip_double_slash = True ) ) ) + [string] [EOL] return s [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] import re [EOL] from typing import Dict , Optional [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext , roughly_matches [EOL] from magic import fetcher [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def resources ( ctx , * , args ) : [EOL] [docstring] [EOL] results = { } [EOL] if args is None : [EOL] args = [string] [EOL] if len ( args ) > [number] : [EOL] results . update ( resources_resources ( args ) ) [EOL] results . update ( site_resources ( args ) ) [EOL] s = [string] [EOL] if len ( results ) == [number] : [EOL] s = [string] . format ( url = fetcher . decksite_url ( [string] ) ) [EOL] elif len ( results ) > [number] : [EOL] s = [string] . format ( author = ctx . author . mention ) [EOL] else : [EOL] for url , text in results . items ( ) : [EOL] s += [string] . format ( text = text , url = url ) [EOL] await ctx . send ( s ) [EOL] [EOL] def site_resources ( args ) : [EOL] results = { } [EOL] match = re . match ( [string] , args ) [EOL] if match : [EOL] season_prefix = [string] + match . group ( [number] ) [EOL] args = args . replace ( match . group ( [number] ) , [string] , [number] ) . strip ( ) [EOL] else : [EOL] season_prefix = [string] [EOL] if [string] in args : [EOL] area , detail = args . split ( [string] , [number] ) [EOL] else : [EOL] area , detail = args , [string] [EOL] if area == [string] : [EOL] area = [string] [EOL] if area == [string] : [EOL] area = [string] [EOL] if area == [string] : [EOL] area = [string] [EOL] sitemap = fetcher . sitemap ( ) [EOL] matches = [ endpoint for endpoint in sitemap if endpoint . startswith ( [string] . format ( area = area ) ) ] [EOL] if len ( matches ) > [number] : [EOL] detail = [string] . format ( detail = fetch_tools . escape ( detail , True ) ) if detail else [string] [EOL] url = fetcher . decksite_url ( [string] . format ( season_prefix = season_prefix , area = fetch_tools . escape ( area ) , detail = detail ) ) [EOL] results [ url ] = args [EOL] return results [EOL] [EOL] [EOL] def resources_resources ( args ) : [EOL] results = { } [EOL] words = args . split ( ) [EOL] for title , items in fetcher . resources ( ) . items ( ) : [EOL] for text , url in items . items ( ) : [EOL] asked_for_this_section_only = len ( words ) == [number] and roughly_matches ( title , words [ [number] ] ) [EOL] asked_for_this_section_and_item = len ( words ) == [number] and roughly_matches ( title , words [ [number] ] ) and roughly_matches ( text , words [ [number] ] ) [EOL] asked_for_this_item_only = len ( words ) == [number] and roughly_matches ( text , words [ [number] ] ) [EOL] the_whole_thing_sounds_right = roughly_matches ( text , [string] . join ( words ) ) [EOL] the_url_matches = roughly_matches ( url , [string] . join ( words ) ) [EOL] if asked_for_this_section_only or asked_for_this_section_and_item or asked_for_this_item_only or the_whole_thing_sounds_right or the_url_matches : [EOL] results [ url ] = text [EOL] return results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import discordbot [EOL] import typing [EOL] import builtins [EOL] from typing import Optional [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def quality ( ctx , * , product = None ) : [EOL] [docstring] [EOL] if product is None : [EOL] product = [string] [EOL] await ctx . send ( f' [string] { product } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] import random [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import oracle [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] , [string] ] ) async def randomcard ( ctx , number = [number] ) : [EOL] [docstring] [EOL] additional_text = [string] [EOL] if number > [number] : [EOL] additional_text = [string] . format ( number = number ) [EOL] number = [number] [EOL] cards = [ oracle . cards_by_name ( ) [ name ] for name in random . sample ( oracle . legal_cards ( ) , number ) ] [EOL] await ctx . post_cards ( cards , None , additional_text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import magic [EOL] import re [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import image_fetcher [EOL] from magic . models import Card [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def art ( ctx , * , c ) : [EOL] [docstring] [EOL] if c is not None : [EOL] file_path = re . sub ( [string] , [string] , image_fetcher . determine_filepath ( [ c ] ) ) [EOL] success = await image_fetcher . download_scryfall_card_image ( c , file_path , version = [string] ) [EOL] if success : [EOL] await ctx . send_image_with_retry ( file_path ) [EOL] else : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MAX_CARDS_SHOWN , MtgContext [EOL] from magic import fetcher , oracle [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] , [string] ] ) async def search ( ctx , * , args ) : [EOL] [docstring] [EOL] how_many , cardnames = fetcher . search_scryfall ( args ) [EOL] cbn = oracle . cards_by_name ( ) [EOL] cards = [ cbn [ name ] for name in cardnames if cbn . get ( name ) is not None ] [EOL] await ctx . post_cards ( cards , ctx . author , more_results_link ( args , how_many ) ) [EOL] [EOL] def more_results_link ( args , total ) : [EOL] return [string] . format ( n = total - [number] , q = fetch_tools . escape ( args ) ) if total > MAX_CARDS_SHOWN else [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import magic [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import card_price [EOL] from magic . models import Card [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def price ( ctx , * , c ) : [EOL] [docstring] [EOL] await ctx . single_card_text ( c , card_price . card_price_string ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import discordbot [EOL] import builtins [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import configuration [EOL] [EOL] [EOL] @ commands . command ( ) async def notpenny ( ctx , args ) : [EOL] [docstring] [EOL] existing = configuration . get_list ( [string] ) [EOL] if args == [string] and getattr ( ctx . channel , [string] , None ) is not None : [EOL] cid = ctx . channel . guild . id [EOL] else : [EOL] cid = ctx . channel . id [EOL] if str ( cid ) not in existing : [EOL] existing . append ( str ( cid ) ) [EOL] configuration . write ( [string] , set ( existing ) ) [EOL] if args == [string] : [EOL] await ctx . send ( [string] ) [EOL] else : [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import builtins [EOL] from discord . ext import commands [EOL] [EOL] from discordbot import emoji [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def echo ( ctx , * , args ) : [EOL] [docstring] [EOL] s = emoji . replace_emoji ( args , ctx . bot ) [EOL] if not s : [EOL] s = [string] [EOL] await ctx . send ( s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , List [EOL] import discordbot [EOL] import typing [EOL] import builtins [EOL] from discord . ext import commands [EOL] from googleapiclient . discovery import build [EOL] from googleapiclient . errors import HttpError [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import configuration [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def google ( ctx , * , args ) : [EOL] [docstring] [EOL] api_key = configuration . get ( [string] ) [EOL] cse_id = configuration . get ( [string] ) [EOL] if api_key is None or cse_id is None : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] [EOL] if len ( args ) == [number] : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL] return [EOL] [EOL] try : [EOL] service = build ( [string] , [string] , developerKey = api_key ) [EOL] res = service . cse ( ) . list ( q = args , cx = cse_id , num = [number] ) . execute ( ) [comment] [EOL] if [string] in res : [EOL] r = res [ [string] ] [ [number] ] [EOL] s = [string] . format ( title = r [ [string] ] , url = r [ [string] ] , abstract = r [ [string] ] ) [EOL] else : [EOL] s = [string] . format ( author = ctx . author . mention ) [EOL] except HttpError as e : [EOL] if e . resp [ [string] ] == [string] : [EOL] s = [string] [EOL] else : [EOL] raise e [EOL] [EOL] await ctx . send ( s ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import builtins [EOL] import magic [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import oracle [EOL] from magic . models import Card [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def flavor ( ctx , * , c ) : [EOL] [docstring] [EOL] await ctx . single_card_text ( c , flavor_text ) [EOL] [EOL] def flavor_text ( c ) : [EOL] for printing in oracle . get_printings ( c ) : [EOL] if c . preferred_printing is not None and c . preferred_printing != printing . set_code : [EOL] continue [EOL] if printing . flavor is not None : [EOL] return [string] + printing . flavor + [string] + oracle . get_set ( printing . set_id ) . name + [string] [EOL] if c . preferred_printing is not None : [EOL] return f' [string] { c . preferred_printing }' [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import builtins [EOL] import discordbot [EOL] import typing [EOL] import magic [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher [EOL] from magic . models import Card [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def rulings ( ctx , * , c ) : [EOL] [docstring] [EOL] await ctx . single_card_text ( c , card_rulings ) [EOL] [EOL] [EOL] def card_rulings ( c ) : [EOL] raw_rulings = fetcher . rulings ( c . name ) [EOL] comments = [ r [ [string] ] for r in raw_rulings ] [EOL] if len ( comments ) > [number] : [EOL] n = len ( comments ) - [number] [EOL] comments = comments [ : [number] ] [EOL] comments . append ( [string] . format ( n = n , cardname = fetch_tools . escape ( c . name ) ) ) [EOL] return [string] . join ( comments ) or [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List [EOL] import discordbot [EOL] import typing [EOL] import glob [EOL] import os [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import configuration [EOL] [EOL] [EOL] @ commands . is_owner ( ) @ commands . command ( ) async def clearimagecache ( ctx ) : [EOL] [docstring] [EOL] image_dir = configuration . get ( [string] ) [EOL] if not image_dir : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] files = glob . glob ( [string] . format ( dir = image_dir ) ) [EOL] for file in files : [EOL] os . remove ( file ) [EOL] await ctx . send ( [string] . format ( n = len ( files ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def invite ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import multiverse [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] @ commands . is_owner ( ) @ commands . command ( ) async def rotate ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL] await multiverse . init_async ( ) [comment] [EOL] await multiverse . set_legal_cards_async ( ) [comment] [EOL] await multiverse . update_pd_legality_async ( ) [comment] [EOL] if redis . REDIS : [comment] [EOL] redis . REDIS . flushdb ( ) [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import typing [EOL] import discordbot [EOL] import builtins [EOL] import logging [EOL] import re [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext , guild_or_channel_id [EOL] from magic import fetcher [EOL] from shared import configuration [EOL] from shared . pd_exception import NotConfiguredException , TooFewItemsException [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def time ( ctx , * , args ) : [EOL] [docstring] [EOL] if len ( args ) == [number] : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL] return [EOL] try : [EOL] twentyfour = configuration . get_bool ( f'{ guild_or_channel_id ( ctx . channel ) } [string] ' ) or configuration . get_bool ( f'{ ctx . channel . id } [string] ' ) [EOL] ts = fetcher . time ( args , twentyfour ) [EOL] times_s = [string] [EOL] for t , zones in ts . items ( ) : [EOL] cities = sorted ( set ( re . sub ( [string] , [string] , zone ) . replace ( [string] , [string] ) for zone in zones ) ) [EOL] times_s += [string] . format ( cities = [string] . join ( cities ) , t = t ) [EOL] await ctx . send ( times_s ) [EOL] except NotConfiguredException : [EOL] await ctx . send ( [string] ) [EOL] except TooFewItemsException : [EOL] logging . exception ( [string] , args ) [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import discordbot [EOL] import typing [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher , tournaments [EOL] from shared import dtutil [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def tournament ( ctx ) : [EOL] [docstring] [EOL] t = tournaments . next_tournament_info ( ) [EOL] prev = tournaments . previous_tournament_info ( ) [EOL] if prev [ [string] ] : [EOL] started = [string] [EOL] else : [EOL] started = [string] [EOL] prev_message = [string] . format ( name = prev [ [string] ] , started = started , time = prev [ [string] ] ) [EOL] next_time = [string] + t [ [string] ] if t [ [string] ] != dtutil . display_time ( [number] , [number] ) else t [ [string] ] [EOL] await ctx . send ( [string] . format ( name = t [ [string] ] , next_time = next_time , prev_message = prev_message , url = fetcher . decksite_url ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import rotation [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] , [string] ] ) async def nextrotation ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( rotation . message ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] import magic [EOL] import random [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import image_fetcher , oracle [EOL] from shared import redis_wrapper as redis [EOL] [EOL] [EOL] @ commands . command ( ) async def p1p1 ( ctx ) : [EOL] [docstring] [EOL] [EOL] if is_p1p1_ready ( ctx . channel . id ) : [EOL] with ctx . typing ( ) : [EOL] lock ( ctx . channel . id ) [comment] [EOL] cards = [ oracle . cards_by_name ( ) [ name ] for name in random . sample ( oracle . legal_cards ( ) , [number] ) ] [EOL] await image_fetcher . download_image_async ( cards ) [comment] [EOL] await ctx . send ( [string] ) [EOL] await ctx . post_cards ( cards [ [number] : [number] ] ) [EOL] await ctx . post_cards ( cards [ [number] : [number] ] ) [EOL] await ctx . post_cards ( cards [ [number] : ] ) [EOL] unlock ( ctx . channel . id ) [EOL] else : [EOL] print ( [string] ) [comment] [EOL] [EOL] def is_p1p1_ready ( channel_id ) : [EOL] return not redis . get_bool ( f' [string] { channel_id }' ) [EOL] [EOL] def lock ( channel_id ) : [EOL] redis . store ( f' [string] { channel_id }' , True , ex = [number] ) [EOL] [EOL] def unlock ( channel_id ) : [EOL] redis . clear ( f' [string] { channel_id }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def modobug ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import discordbot [EOL] import typing [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def randomdeck ( ctx ) : [EOL] [docstring] [EOL] blob = fetch_tools . fetch_json ( fetcher . decksite_url ( [string] ) ) [EOL] if [string] in blob or [string] not in blob : [EOL] await ctx . send ( blob . get ( [string] , [string] ) ) [EOL] else : [EOL] ctn = blob . get ( [string] , None ) [EOL] if ctn is not None : [EOL] if ctn == [string] and blob [ [string] ] == [number] : [EOL] record = [string] [EOL] elif ctn == [string] and blob [ [string] ] <= blob [ [string] ] : [EOL] record = f" [string] { blob [ [string] ] } [string] " [EOL] else : [EOL] draws = f" [string] { blob [ [string] ] }" if blob [ [string] ] > [number] else [string] [EOL] record = f" [string] { blob [ [string] ] } [string] { blob [ [string] ] }{ draws } [string] " [EOL] preamble = f"{ blob [ [string] ] } [string] { record } [string] { blob [ [string] ] } [string] " [EOL] else : [EOL] preamble = f"{ blob [ [string] ] } [string] { blob [ [string] ] } [string] " [EOL] await ctx . send ( preamble + blob [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import discordbot [EOL] import builtins [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import configuration [EOL] [EOL] [EOL] @ commands . command ( ) async def configure ( ctx , scope , setting ) : [EOL] if scope == [string] : [EOL] if not ctx . author . permissions_in ( ctx . channel ) . manage_channels : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] configuring = ctx . channel . id [EOL] elif scope in [ [string] , [string] ] : [EOL] if not ctx . author . guild_permissions . manage_channels : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] configuring = ctx . channel . guild . id [EOL] else : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] try : [EOL] key , value = setting . split ( [string] , [number] ) [EOL] except ValueError : [EOL] await ctx . send ( [string] ) [EOL] return [EOL] [EOL] configuration . write ( f'{ configuring } [string] { key }' , value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def status ( ctx ) : [EOL] [docstring] [EOL] mtgo_status = await fetcher . mtgo_status ( ) [EOL] await ctx . send ( [string] . format ( status = mtgo_status ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , Any [EOL] import discordbot [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Any , Dict [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def whois ( ctx , * , args ) : [EOL] [docstring] [EOL] mention = re . match ( [string] , args ) [EOL] async with ctx . typing ( ) : [EOL] if mention : [EOL] person = await fetcher . person_data_async ( mention . group ( [number] ) ) [EOL] if not_found ( person ) or person . get ( [string] ) is None : [EOL] msg = f" [string] { mention . group ( [number] ) } [string] " [EOL] else : [EOL] msg = f"{ mention . group ( [number] ) } [string] { person [ [string] ] } [string] " [EOL] else : [EOL] person = await fetcher . person_data_async ( args ) [EOL] if not_found ( person ) or person . get ( [string] ) is None : [EOL] msg = f" [string] { args } [string] " [EOL] else : [EOL] msg = f" [string] { person [ [string] ] } [string] { person [ [string] ] } [string] " [EOL] await ctx . send ( msg ) [EOL] [EOL] def not_found ( person ) : [EOL] return person is None or ( person . get ( [string] ) is not None and person . get ( [string] ) == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . is_owner ( ) @ commands . command ( aliases = [ [string] , [string] ] ) async def restartbot ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL] await ctx . bot . logout ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def patreon ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import fetcher [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def downtimes ( ctx ) : [EOL] await ctx . send ( fetcher . downtimes ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import datetime [EOL] import subprocess [EOL] import sys [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import database [EOL] [EOL] [EOL] @ commands . command ( hidden = True ) async def version ( ctx ) : [EOL] [docstring] [EOL] commit = subprocess . check_output ( [ [string] , [string] , [string] ] , universal_newlines = True ) . strip ( [string] ) . strip ( [string] ) [EOL] scryfall = database . last_updated ( ) [EOL] await ctx . send ( f' [string] { commit } [string] { scryfall } [string] { sys . version } [string] ' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import magic [EOL] import builtins [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic . models import Card [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def oracle ( ctx , * , c ) : [EOL] [docstring] [EOL] await ctx . single_card_text ( c , oracle_text ) [EOL] [EOL] def oracle_text ( c ) : [EOL] return c . oracle_text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] [EOL] [EOL] @ commands . command ( ) async def barbs ( ctx ) : [EOL] [docstring] [EOL] msg = [string] [EOL] await ctx . send ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Tuple , List , Any [EOL] import discordbot [EOL] import builtins [EOL] import typing [EOL] import discord [EOL] import textwrap [EOL] from typing import Dict , Optional , Tuple [EOL] [EOL] import inflect [EOL] from discord import TextChannel [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import card_price , fetcher , tournaments [EOL] from shared import configuration [EOL] [EOL] [EOL] @ commands . command ( ) async def explain ( ctx , * , thing ) : [EOL] [docstring] [EOL] num_tournaments = inflect . engine ( ) . number_to_words ( len ( tournaments . all_series_info ( ) ) ) [EOL] explanations = { [string] : ( [string] , { } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) , [string] : fetcher . decksite_url ( [string] ) , [string] : [string] } ) , [string] : ( [string] , { [string] : [string] , [string] : fetcher . decksite_url ( [string] ) , [string] : [string] } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( [string] , { } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) , [string] : fetcher . decksite_url ( [string] ) , [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) , [string] : fetcher . decksite_url ( [string] ) , } ) , [string] : ( [string] , { } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( [string] , { } ) , [string] : ( f""" [string] { card_price . MAX_PRICE_TEXT } [string] { card_price . MAX_PRICE_TEXT } [string] """ , { } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( [string] , { } ) , [string] : ( [string] , { } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) , [string] : ( f""" [string] { card_price . MAX_PRICE_TEXT } [string] """ , { } ) , [string] : ( [string] , { } ) , [string] : ( [string] . format ( num_tournaments = num_tournaments ) , { [string] : fetcher . decksite_url ( [string] ) , [string] : [string] , } ) , [string] : ( [string] , { } ) , [string] : ( [string] , { } ) , } [EOL] reporting_explanations = { [string] : ( [string] , { [string] : [string] , } ) , [string] : ( [string] , { [string] : fetcher . decksite_url ( [string] ) } ) } [EOL] keys = sorted ( explanations . keys ( ) ) [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] explanations [ [string] ] = explanations [ [string] ] [EOL] [comment] [EOL] if thing is None : [EOL] thing = [string] [EOL] word = thing . lower ( ) . replace ( [string] , [string] ) . rstrip ( [string] ) [EOL] if len ( word ) > [number] : [EOL] for k in explanations : [EOL] if k . startswith ( word ) : [EOL] word = k [EOL] try : [EOL] if word == [string] : [EOL] if is_tournament_channel ( ctx . channel ) : [EOL] explanation = reporting_explanations [ [string] ] [EOL] else : [EOL] explanation = reporting_explanations [ [string] ] [EOL] else : [EOL] explanation = explanations [ word ] [EOL] [EOL] s = [string] . format ( text = textwrap . dedent ( explanation [ [number] ] ) ) [EOL] except KeyError : [EOL] usage = [string] . format ( things = [string] . join ( sorted ( keys ) ) ) [EOL] await ctx . send ( usage ) [EOL] return [EOL] for k in sorted ( explanation [ [number] ] . keys ( ) ) : [EOL] s += [string] . format ( k = k , v = explanation [ [number] ] [ k ] ) [EOL] await ctx . send ( s ) [EOL] [EOL] [EOL] def is_tournament_channel ( channel ) : [EOL] tournament_channel_id = configuration . get_int ( [string] ) [EOL] if not tournament_channel_id : [EOL] return False [EOL] return channel . id == tournament_channel_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic import multiverse , oracle [EOL] [EOL] [EOL] @ commands . command ( hidden = True ) async def update ( ctx ) : [EOL] [docstring] [EOL] await ctx . send ( [string] ) [EOL] await multiverse . set_legal_cards_async ( ) [EOL] oracle . legal_cards ( force = True ) [EOL] await multiverse . update_bugged_cards_async ( ) [EOL] multiverse . rebuild_cache ( ) [EOL] multiverse . reindex ( ) [EOL] oracle . init ( force = True ) [EOL] await ctx . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import magic [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from magic . models import Card [EOL] from shared import fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] ] ) async def buglink ( ctx , * , c ) : [EOL] [docstring] [EOL] base_url = [string] [EOL] if c is None : [EOL] await ctx . send ( base_url ) [EOL] return [EOL] msg = [string] . format ( base_url = base_url , name = fetch_tools . escape ( c . name ) ) [EOL] if not c . bugs or len ( c . bugs ) == [number] : [EOL] msg = [string] . format ( name = c . name , link = msg ) [EOL] await ctx . send ( msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import builtins [EOL] import magic [EOL] import discord [EOL] import _importlib_modulespec [EOL] import typing [EOL] import glob [EOL] import importlib [EOL] import inspect [EOL] import logging [EOL] from os import path [EOL] from typing import List , Optional [EOL] [EOL] from discord . ext . commands import Bot , Command , Context [EOL] from discord . ext . commands . errors import BadArgument [EOL] [EOL] from discordbot import command [EOL] from magic . models import Card [EOL] from shared import text [EOL] [EOL] [EOL] def setup ( bot ) : [EOL] Card . convert = CardConverter . convert [EOL] modules = glob . glob ( path . join ( path . dirname ( __file__ ) , [string] ) ) [EOL] files = [ path . basename ( f ) [ : - [number] ] for f in modules if path . isfile ( f ) and not f . endswith ( [string] ) ] [EOL] [EOL] commands , names = [ ] , [ ] [EOL] for mod in files : [EOL] n = [number] [EOL] m = importlib . import_module ( f' [string] { mod }' , package = __name__ ) [EOL] for _ , obj in inspect . getmembers ( m ) : [EOL] if isinstance ( obj , Command ) : [EOL] names . append ( obj . name ) [EOL] names += obj . aliases [EOL] commands . append ( obj ) [EOL] n += [number] [EOL] if n == [number] : [EOL] print ( f' [string] { m . __name__ }' ) [EOL] [EOL] aliases = text . unambiguous_prefixes ( names ) [EOL] for cmd in commands : [EOL] to_add = [ ] [EOL] for prefix in aliases : [EOL] if cmd . name . startswith ( prefix ) : [EOL] to_add . append ( prefix ) [EOL] for alias in cmd . aliases : [EOL] if alias . startswith ( prefix ) : [EOL] to_add . append ( prefix ) [EOL] cmd . aliases += to_add [EOL] bot . add_command ( cmd ) [EOL] [EOL] class CardConverter : [EOL] @ classmethod async def convert ( cls , ctx , argument ) : [EOL] try : [EOL] result , mode , printing = command . results_from_queries ( [ argument ] ) [ [number] ] [EOL] if result . has_match ( ) and not result . is_ambiguous ( ) : [EOL] return command . cards_from_names_with_mode ( [ result . get_best_match ( ) ] , mode , printing ) [ [number] ] [EOL] if result . is_ambiguous ( ) : [EOL] message = await ctx . send ( [string] . format ( author = ctx . author . mention , c = ctx . command , s = command . disambiguation ( result . get_ambiguous_matches ( ) [ [number] : [number] ] ) ) ) [EOL] await command . disambiguation_reactions ( message , result . get_ambiguous_matches ( ) [ [number] : [number] ] ) [EOL] else : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL] return None [EOL] except Exception as exc : [EOL] raise BadArgument ( [string] ) from exc [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[magic.models.Card]$ 0 0 0 $discord.ext.commands.Context$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $discord.ext.commands.Context$ 0 0 0 0 0 0 0 0 0 $discord.ext.commands.Context$ 0 0 0 0 0 0 0 $discord.ext.commands.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $discord.ext.commands.Context$ 0 0 0 0 0 0 0 0 0 $discord.ext.commands.Context$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import discordbot [EOL] import builtins [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext [EOL] from shared import repo [EOL] [EOL] [EOL] @ commands . command ( ) async def bug ( ctx , * , text ) : [EOL] [docstring] [EOL] issue = repo . create_issue ( text , ctx . author ) [EOL] if issue is None : [EOL] await ctx . send ( [string] ) [EOL] else : [EOL] await ctx . send ( [string] . format ( url = issue . html_url ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import discordbot [EOL] import magic [EOL] import builtins [EOL] import random [EOL] [EOL] from discord . ext import commands [EOL] [EOL] from discordbot . command import MtgContext , complex_search [EOL] from magic import oracle [EOL] from magic . models import Card [EOL] [EOL] [EOL] @ commands . command ( ) async def rhinos ( ctx ) : [EOL] [docstring] [EOL] rhino_name = [string] [EOL] if random . random ( ) < [number] : [EOL] rhino_name = [string] [EOL] og_rhino = oracle . cards_by_name ( ) [ rhino_name ] [EOL] [EOL] def find_rhino ( query ) : [EOL] cards = complex_search ( [string] . format ( query ) ) [EOL] if len ( cards ) == [number] : [EOL] cards = complex_search ( query ) [EOL] return random . choice ( cards ) [EOL] copy_rhino = find_rhino ( [string] ) [EOL] zombie_rhino = find_rhino ( [string] ) [EOL] tutor_rhino = find_rhino ( [string] ) [EOL] msg = f' [string] { og_rhino . name } [string] ' [EOL] msg += f" [string] { copy_rhino . name } [string] " [EOL] msg += f" [string] { zombie_rhino . name } [string] " [EOL] msg += f" [string] { tutor_rhino . name } [string] " [EOL] await ctx . post_cards ( [ og_rhino , copy_rhino , zombie_rhino , tutor_rhino ] , additional_text = msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $magic.models.Card$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import discordbot [EOL] import typing [EOL] import builtins [EOL] from discord import File [EOL] from discord . ext import commands [EOL] [EOL] from discordbot import emoji [EOL] from discordbot . command import MtgContext [EOL] from magic import oracle [EOL] from shared import configuration , fetch_tools [EOL] [EOL] [EOL] @ commands . command ( aliases = [ [string] , [string] ] ) async def spoiler ( ctx , * , args ) : [EOL] [docstring] [EOL] if len ( args ) == [number] : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention ) ) [EOL] return [EOL] sfcard = fetch_tools . fetch_json ( [string] . format ( name = args ) ) [EOL] if sfcard [ [string] ] == [string] : [EOL] await ctx . send ( [string] . format ( author = ctx . author . mention , details = sfcard [ [string] ] ) ) [EOL] return [EOL] imagename = [string] . format ( set = sfcard [ [string] ] , number = sfcard [ [string] ] ) [EOL] imagepath = [string] . format ( image_dir = configuration . get ( [string] ) , imagename = imagename ) [EOL] if sfcard . get ( [string] ) and sfcard . get ( [string] , [string] ) != [string] : [EOL] c = sfcard [ [string] ] [ [number] ] [EOL] else : [EOL] c = sfcard [EOL] fetch_tools . store ( c [ [string] ] [ [string] ] , imagepath ) [EOL] text = emoji . replace_emoji ( [string] . format ( name = sfcard [ [string] ] , mana = c [ [string] ] ) , ctx . bot ) [EOL] await ctx . send ( file = File ( imagepath ) , content = text ) [EOL] await oracle . scryfall_import_async ( sfcard [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Callable [EOL] import builtins [EOL] import typing [EOL] from functools import wraps [EOL] from typing import Any , Callable [EOL] [EOL] from flask import request [EOL] [EOL] [EOL] def fill_args ( * props ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] for arg in props : [EOL] reqval = request . args . get ( arg , None ) [EOL] if kwargs . get ( arg , None ) is None and reqval is not None : [EOL] kwargs [ arg ] = reqval [EOL] return f ( * args , ** kwargs ) [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] def fill_cookies ( * props ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] for arg in props : [EOL] reqval = request . cookies . get ( arg , None ) [EOL] if kwargs . get ( arg , None ) is None and reqval is not None : [EOL] kwargs [ arg ] = reqval [EOL] return f ( * args , ** kwargs ) [EOL] return wrapper [EOL] return decorator [EOL] [EOL] [EOL] def fill_form ( * props ) : [EOL] def decorator ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] for arg in props : [EOL] reqval = request . form . get ( arg , None ) [EOL] if kwargs . get ( arg , None ) is None and reqval is not None : [EOL] kwargs [ arg ] = reqval [EOL] return f ( * args , ** kwargs ) [EOL] return wrapper [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import shared [EOL] import json [EOL] import subprocess [EOL] import sys [EOL] from typing import Any , Dict , List , Optional , Union [EOL] [EOL] import humps [EOL] from flask import Response , current_app , request [EOL] [EOL] from shared import configuration [EOL] from shared . container import Container [EOL] from shared . serialization import extra_serializer [EOL] [EOL] [EOL] def process_github_webhook ( ) : [EOL] if request . headers . get ( [string] ) == [string] : [EOL] payload = json . loads ( request . data ) [EOL] expected = [string] . format ( current_app . config [ [string] ] ) [EOL] if payload [ [string] ] == expected : [EOL] try : [EOL] subprocess . check_output ( [ [string] , [string] ] ) [EOL] subprocess . check_output ( [ [string] , [string] , [string] , [string] . format ( current_app . config [ [string] ] ) ] ) [EOL] try : [EOL] subprocess . check_output ( [ sys . executable , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] except subprocess . CalledProcessError : [EOL] pass [EOL] try : [EOL] subprocess . check_output ( [ [string] , [string] , [string] ] ) [EOL] except subprocess . CalledProcessError : [EOL] pass [EOL] import uwsgi [comment] [EOL] uwsgi . reload ( ) [EOL] return return_json ( { [string] : True } ) [EOL] except ImportError : [EOL] pass [EOL] return return_json ( { [string] : False , [string] : current_app . config [ [string] ] , [string] : current_app . config [ [string] ] , [string] : payload [ [string] ] , [string] : expected } ) [EOL] [EOL] def commit_id ( ) : [EOL] return return_json ( current_app . config [ [string] ] ) [EOL] [EOL] def validate_api_key ( ) : [EOL] if request . form . get ( [string] , None ) == configuration . get ( [string] ) : [EOL] return None [EOL] return return_json ( generate_error ( [string] , [string] ) , status = [number] ) [EOL] [EOL] def generate_error ( code , msg , ** more ) : [EOL] return { [string] : True , [string] : code , [string] : msg , ** more } [EOL] [EOL] def return_json ( content , status = [number] , camelize = False ) : [EOL] if camelize : [EOL] content = humps . camelize ( content ) [EOL] s = json . dumps ( content , default = extra_serializer ) [EOL] r = Response ( response = s , status = status , mimetype = [string] ) [EOL] return r [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[flask.Response]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Optional , Tuple , Any [EOL] import builtins [EOL] import flask [EOL] import werkzeug [EOL] import shared_web [EOL] import typing [EOL] import os [EOL] import subprocess [EOL] import urllib [EOL] from typing import Any , Dict , Optional , Tuple , Union [EOL] [EOL] from flask import ( Blueprint , Flask , Request , Response , redirect , request , send_from_directory , session , url_for ) [EOL] from flask_babel import Babel [EOL] from flask_restx import Api [EOL] from github . GithubException import GithubException [EOL] from werkzeug import exceptions , wrappers [EOL] [EOL] from shared import configuration , logger , repo [EOL] from shared . pd_exception import DoesNotExistException [EOL] [EOL] from . import api , localization , oauth [EOL] from . api import generate_error , return_json [EOL] from . views import InternalServerError , NotFound , Unauthorized [EOL] [EOL] [EOL] [comment] [EOL] class PDFlask ( Flask ) : [EOL] def __init__ ( self , import_name ) : [EOL] shared_web_path = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] static_folder = os . path . join ( shared_web_path , [string] ) [EOL] super ( ) . __init__ ( import_name , static_folder = static_folder ) [EOL] super ( ) . register_error_handler ( DoesNotExistException , self . not_found ) [EOL] super ( ) . register_error_handler ( exceptions . NotFound , self . not_found ) [EOL] super ( ) . register_error_handler ( exceptions . InternalServerError , self . internal_server_error ) [EOL] super ( ) . route ( [string] ) ( self . unauthorized ) [EOL] super ( ) . route ( [string] ) ( self . logout ) [EOL] super ( ) . route ( [string] ) ( self . authenticate ) [EOL] super ( ) . route ( [string] ) ( self . authenticate_callback ) [EOL] super ( ) . route ( [string] , methods = [ [string] ] ) ( api . process_github_webhook ) [EOL] super ( ) . route ( [string] ) ( api . commit_id ) [EOL] super ( ) . route ( [string] ) ( self . robots_txt ) [EOL] super ( ) . route ( [string] ) ( self . favicon ) [EOL] self . url_build_error_handlers . append ( self . external_url_handler ) [EOL] if self . config . get ( [string] ) is None : [EOL] self . config [ [string] ] = configuration . get_optional_str ( [string] ) [EOL] self . config [ [string] ] = [ ] [EOL] self . config [ [string] ] = [string] [EOL] self . config [ [string] ] = [string] [EOL] self . config [ [string] ] = subprocess . check_output ( [ [string] , [string] , [string] ] ) . strip ( ) . decode ( ) [EOL] self . config [ [string] ] = subprocess . check_output ( [ [string] , [string] , [string] , [string] ] ) . strip ( ) . decode ( ) [EOL] self . config [ [string] ] = configuration . get_optional_str ( [string] ) [EOL] [EOL] translations = os . path . abspath ( os . path . join ( shared_web_path , [string] ) ) [EOL] self . config [ [string] ] = translations [EOL] self . babel = Babel ( self ) [EOL] localization . init ( self . babel ) [EOL] self . api_root = Blueprint ( [string] , import_name , url_prefix = [string] ) [EOL] self . api = Api ( self . api_root , title = f'{ import_name } [string] ' , default = import_name ) [EOL] self . register_blueprint ( self . api_root ) [EOL] [EOL] def not_found ( self , e ) : [EOL] if request . path . startswith ( [string] ) : [EOL] return return_json ( generate_error ( [string] , [string] ) , status = [number] ) [EOL] log_exception ( request , e ) [EOL] if request . path . startswith ( [string] ) : [EOL] return return_json ( generate_error ( [string] , [string] ) , status = [number] ) [EOL] view = NotFound ( e ) [EOL] return view . page ( ) , [number] [EOL] [EOL] def internal_server_error ( self , e ) : [EOL] log_exception ( request , e ) [EOL] path = request . path [EOL] try : [EOL] repo . create_issue ( [string] . format ( path = path , e = e ) , session . get ( [string] , session . get ( [string] , [string] ) ) , self . name , [string] , exception = e ) [EOL] except GithubException : [EOL] logger . error ( [string] , e ) [EOL] if request . path . startswith ( [string] ) : [EOL] return return_json ( generate_error ( [string] , [string] , exception = e ) , status = [number] ) [EOL] view = InternalServerError ( e ) [EOL] return view . page ( ) , [number] [EOL] [EOL] def unauthorized ( self , error = None ) : [EOL] view = Unauthorized ( error ) [EOL] return view . page ( ) [EOL] [EOL] def logout ( self ) : [EOL] oauth . logout ( ) [EOL] target = request . args . get ( [string] , [string] ) [EOL] if bool ( urllib . parse . urlparse ( target ) . netloc ) : [EOL] return redirect ( target ) [EOL] return redirect ( url_for ( target ) ) [EOL] [EOL] def authenticate ( self ) : [EOL] target = request . args . get ( [string] ) [EOL] authorization_url , state = oauth . setup_authentication ( ) [EOL] session [ [string] ] = state [EOL] if target is not None : [EOL] session [ [string] ] = target [EOL] response = redirect ( authorization_url ) [EOL] [comment] [EOL] [comment] [EOL] response . headers [ [string] ] = [string] [EOL] return response [EOL] [EOL] def authenticate_callback ( self ) : [EOL] if request . values . get ( [string] ) : [EOL] return redirect ( url_for ( [string] , error = request . values [ [string] ] ) ) [EOL] oauth . setup_session ( request . url ) [EOL] url = session . get ( [string] ) [EOL] if url is None : [EOL] url = url_for ( [string] ) [EOL] session [ [string] ] = None [EOL] return redirect ( url ) [EOL] [EOL] def robots_txt ( self ) : [EOL] [docstring] [EOL] if configuration . get_bool ( [string] ) : [EOL] return send_from_directory ( self . static_folder , [string] ) [EOL] return send_from_directory ( self . static_folder , [string] ) [EOL] [EOL] def favicon ( self , rest ) : [EOL] if not self . static_folder : [EOL] raise DoesNotExistException ( ) [EOL] return send_from_directory ( os . path . join ( self . static_folder , [string] , [string] ) , [string] . format ( rest = rest ) ) [EOL] [EOL] def external_url_handler ( self , error , endpoint , values ) : [EOL] [docstring] [EOL] url = self . lookup_external_url ( endpoint , ** values ) [EOL] if url is None : [EOL] [comment] [EOL] [comment] [EOL] raise error [EOL] [comment] [EOL] return url [EOL] [EOL] def lookup_external_url ( self , endpoint , ** values ) : [EOL] if endpoint == [string] : [comment] [EOL] return [string] . format ( name = values [ [string] ] ) [EOL] return None [EOL] [EOL] def log_exception ( r , e ) : [EOL] logger . error ( f' [string] { r . path }' , repo . format_exception ( e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 $typing.Union[flask.Response,typing.Tuple[builtins.str,builtins.int]]$ 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.Exception$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[builtins.str,builtins.int],flask.Response]$ 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.Exception$ 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 0 0 0 $shared_web.views.internal_server_error.InternalServerError$ 0 0 0 $builtins.Exception$ 0 0 0 $shared_web.views.internal_server_error.InternalServerError$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $shared_web.views.unauthorized.Unauthorized$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $shared_web.views.unauthorized.Unauthorized$ 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 $werkzeug.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.Exception$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.Exception$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import shared_web [EOL] import builtins [EOL] import typing [EOL] from shared_web . flask_app import PDFlask [EOL] [EOL] [EOL] class SmokeTester : [EOL] def __init__ ( self , app ) : [EOL] self . test_client = app . test_client ( ) [EOL] [comment] [EOL] self . test_client . testing = True [comment] [EOL] self . base_tests ( ) [EOL] [EOL] def base_tests ( self ) : [EOL] self . response_test ( [string] , [number] ) [EOL] self . response_test ( [string] , [number] ) [EOL] [EOL] def data_test ( self , path , expected ) : [EOL] result = self . test_client . get ( path ) [comment] [EOL] assert expected in result . data . decode ( [string] ) [EOL] [EOL] def response_test ( self , path , expected_code ) : [EOL] result = self . test_client . get ( path ) [comment] [EOL] assert result . status_code == expected_code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 $shared_web.flask_app.PDFlask$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0
	0
from typing import Dict , Union , Optional , Callable , Match , Tuple , List , Any , Type [EOL] import builtins [EOL] import xml [EOL] import shared_web [EOL] import markdown [EOL] import pystache [EOL] import typing [EOL] import re [EOL] import xml . etree . ElementTree as etree [EOL] from typing import TYPE_CHECKING , Callable , Dict , List , Match , Optional , Tuple , Union [EOL] [EOL] import flask [EOL] import pystache [EOL] import pystache . parsed [EOL] from flask_babel import gettext [EOL] from markdown import Markdown , markdown [EOL] from markdown . extensions import Extension [EOL] from markdown . treeprocessors import Treeprocessor [EOL] from pystache . common import TemplateNotFoundError [EOL] from pystache . context import ContextStack [EOL] [EOL] [comment] [EOL] if TYPE_CHECKING : [EOL] from shared_web . base_view import BaseView [EOL] [EOL] __SEARCHPATH = [ ] [EOL] [EOL] StringConverterFunction = Optional [ Callable [ [ str ] , str ] ] [EOL] [EOL] def render_name ( template , * context ) : [EOL] try : [EOL] renderer = CachedRenderer ( search_dirs = [ [string] . format ( flask . current_app . name ) , [string] ] ) [EOL] except TemplateNotFoundError : [EOL] renderer = CachedRenderer ( search_dirs = __SEARCHPATH ) [EOL] return renderer . render_name ( template , * context ) [EOL] [EOL] def render ( view ) : [EOL] view . prepare ( ) [EOL] return render_name ( view . template ( ) , view ) [EOL] [EOL] [comment] [EOL] class CachedRenderer ( pystache . Renderer ) : [EOL] def _make_loader ( self ) : [EOL] return CachedLoader ( file_encoding = self . file_encoding , extension = self . file_extension , to_unicode = self . str , search_dirs = self . search_dirs ) [EOL] [EOL] def _make_render_engine ( self ) : [EOL] resolve_context = self . _make_resolve_context ( ) [EOL] resolve_partial = self . _make_resolve_partial ( ) [EOL] engine = CachedRenderEngine ( literal = self . _to_unicode_hard , escape = self . _escape_to_unicode , resolve_context = resolve_context , resolve_partial = resolve_partial , to_str = self . str_coerce ) [EOL] return engine [EOL] [EOL] [comment] [EOL] [comment] [EOL] class CachedLoader ( pystache . loader . Loader ) : [EOL] def __init__ ( self , file_encoding = None , extension = None , to_unicode = None , search_dirs = None ) : [EOL] super ( ) . __init__ ( file_encoding , extension , to_unicode , search_dirs ) [EOL] self . templates = { } [EOL] [EOL] def read ( self , path , encoding = None ) : [EOL] if self . templates . get ( path ) is None : [EOL] self . templates [ path ] = super ( ) . read ( path , encoding ) [EOL] return self . templates [ path ] [EOL] [EOL] [comment] [EOL] class CachedRenderEngine ( pystache . renderengine . RenderEngine ) : [EOL] [comment] [EOL] def __init__ ( self , literal = None , escape = None , resolve_context = None , resolve_partial = None , to_str = None ) : [EOL] super ( ) . __init__ ( literal , escape , resolve_context , resolve_partial , to_str ) [EOL] self . parsed_templates = { } [EOL] [EOL] def render ( self , template , context_stack , delimiters = None ) : [EOL] if self . parsed_templates . get ( template ) is None : [EOL] self . parsed_templates [ template ] = insert_gettext_nodes ( pystache . parser . parse ( template , delimiters ) ) [EOL] return self . parsed_templates [ template ] . render ( self , context_stack ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def insert_gettext_nodes ( parsed_template ) : [EOL] new_template = pystache . parsed . ParsedTemplate ( ) [EOL] for node in parsed_template . _parse_tree : [EOL] if isinstance ( node , pystache . parser . _EscapeNode ) : [EOL] if node . key [ [number] : [number] ] == [string] : [EOL] key = node . key [ [number] : ] . strip ( ) [EOL] new_template . add ( _GettextNode ( key ) ) [EOL] else : [EOL] new_template . add ( node ) [EOL] elif isinstance ( node , pystache . parser . _InvertedNode ) : [EOL] new_template . add ( pystache . parser . _InvertedNode ( node . key , insert_gettext_nodes ( node . parsed_section ) ) ) [EOL] elif isinstance ( node , pystache . parser . _SectionNode ) : [EOL] new_template . add ( pystache . parser . _SectionNode ( node . key , insert_gettext_nodes ( node . parsed ) , node . delimiters , node . template , node . index_begin , node . index_end ) ) [EOL] else : [EOL] new_template . add ( node ) [EOL] [comment] [EOL] return new_template [EOL] [EOL] class _GettextNode ( ) : [EOL] def __init__ ( self , key ) : [EOL] self . key = key [EOL] [EOL] def __repr__ ( self ) : [EOL] return pystache . parser . _format ( self ) [EOL] [EOL] def render ( self , engine , context ) : [EOL] s = gettext ( self . key ) [comment] [EOL] def lookup ( match ) : [EOL] return engine . fetch_string ( context , match . group ( [number] ) ) [EOL] s = re . sub ( [string] , lookup , s ) [EOL] return markdown ( engine . escape ( s ) , extensions = [ NoParaTagsExtension ( ) ] ) [EOL] [EOL] [comment] [EOL] class NoParaTagProcessor ( Treeprocessor ) : [EOL] def run ( self , root ) : [EOL] root [ [number] ] . tag = [string] [EOL] [EOL] [comment] [EOL] class NoParaTagsExtension ( Extension ) : [EOL] [comment] [EOL] def extendMarkdown ( self , md ) : [EOL] md . treeprocessors . register ( NoParaTagProcessor ( ) , [string] , - [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $markdown.Markdown$ 0 0 0 $markdown.Markdown$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , Union , List [EOL] import builtins [EOL] import requests_oauthlib [EOL] import typing [EOL] import os [EOL] from typing import List , Tuple [EOL] [EOL] from flask import session , url_for [EOL] from requests_oauthlib import OAuth2Session [EOL] [EOL] from shared import configuration , logger [EOL] [EOL] API_BASE_URL = [string] [EOL] AUTHORIZATION_BASE_URL = API_BASE_URL + [string] [EOL] TOKEN_URL = API_BASE_URL + [string] [EOL] OAUTH2_CLIENT_ID = configuration . get ( [string] ) [EOL] OAUTH2_CLIENT_SECRET = configuration . get ( [string] ) [EOL] [EOL] def setup_authentication ( ) : [EOL] scope = [ [string] , [string] , [string] ] [EOL] discord = make_session ( scope = scope ) [EOL] return discord . authorization_url ( AUTHORIZATION_BASE_URL ) [EOL] [EOL] [EOL] def setup_session ( url ) : [EOL] discord = make_session ( state = session . get ( [string] ) ) [EOL] token = discord . fetch_token ( TOKEN_URL , client_secret = OAUTH2_CLIENT_SECRET , authorization_response = url ) [EOL] session . permanent = True [EOL] session [ [string] ] = token [EOL] discord = make_session ( token = session . get ( [string] ) ) [EOL] user = discord . get ( API_BASE_URL + [string] ) . json ( ) [EOL] session [ [string] ] = user [ [string] ] [EOL] session [ [string] ] = user [ [string] ] [EOL] session [ [string] ] = user [ [string] ] [EOL] guilds = discord . get ( API_BASE_URL + [string] ) . json ( ) [EOL] wrong_guilds = False [comment] [EOL] session [ [string] ] = False [EOL] session [ [string] ] = False [EOL] session [ [string] ] = False [EOL] for guild in guilds : [EOL] if isinstance ( guild , dict ) and [string] in guild : [EOL] if guild [ [string] ] == configuration . get ( [string] ) : [EOL] session [ [string] ] = ( guild [ [string] ] & [number] ) != [number] [comment] [EOL] session [ [string] ] = ( guild [ [string] ] & [number] ) != [number] [comment] [EOL] session [ [string] ] = True [EOL] else : [EOL] wrong_guilds = True [EOL] if wrong_guilds : [EOL] logger . warning ( [string] . format ( g = guilds ) ) [EOL] [EOL] def add_to_guild ( ) : [EOL] discord = make_session ( token = session . get ( [string] ) ) [EOL] if not session [ [string] ] : [EOL] discord . put ( [string] . format ( guild = configuration . get ( [string] ) , user = session [ [string] ] ) ) [EOL] [EOL] [EOL] def make_session ( token = None , state = None , scope = None ) : [EOL] return OAuth2Session ( client_id = OAUTH2_CLIENT_ID , token = token , state = state , scope = scope , redirect_uri = redirect_uri ( ) , auto_refresh_kwargs = { [string] : OAUTH2_CLIENT_ID , [string] : OAUTH2_CLIENT_SECRET , } , auto_refresh_url = TOKEN_URL , token_updater = token_updater ) [EOL] [EOL] def token_updater ( token ) : [EOL] session [ [string] ] = token [EOL] [EOL] def redirect_uri ( ) : [EOL] uri = url_for ( [string] , _external = True ) [EOL] if [string] in uri : [EOL] os . environ [ [string] ] = [string] [EOL] return uri [EOL] [EOL] def logout ( ) : [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL] session [ [string] ] = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests_oauthlib.OAuth2Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 $typing.Union[None,typing.List[builtins.str],builtins.float,builtins.int,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import glob [EOL] import os . path [EOL] [EOL] import pytest [EOL] [EOL] from shared_web import template [EOL] [EOL] [EOL] [comment] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_render_name ( module ) : [EOL] template . __SEARCHPATH . clear ( ) [EOL] template . __SEARCHPATH . append ( [string] . format ( module ) ) [EOL] templates = glob . glob ( [string] . format ( module ) , recursive = True ) [EOL] print ( templates ) [EOL] for t in templates : [EOL] template . render_name ( os . path . basename ( t ) . replace ( [string] , [string] ) , { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Pattern , List [EOL] import builtins [EOL] import flask_babel [EOL] import typing [EOL] import re [EOL] from typing import List , Optional [EOL] [EOL] from flask import request , session [EOL] from flask_babel import Babel [EOL] [EOL] LANGUAGES = [ ] [EOL] SPLIT_REGEX = re . compile ( [string] ) [EOL] VALID_LOCALE = re . compile ( [string] ) [EOL] [EOL] def get_locale ( ) : [EOL] result = check_sql_injection ( request . args . get ( [string] , None ) ) [EOL] if result : [EOL] session [ [string] ] = result [EOL] return result [EOL] result = session . get ( [string] , None ) [EOL] if not result : [EOL] result = request . accept_languages . best_match ( LANGUAGES ) [EOL] return result [EOL] [EOL] def check_sql_injection ( locale ) : [EOL] if locale is None : [EOL] return None [EOL] if not VALID_LOCALE . match ( locale ) : [EOL] return None [EOL] return locale [EOL] [EOL] def init ( babel ) : [EOL] LANGUAGES . extend ( [ str ( locale ) for locale in babel . list_translations ( ) ] ) [EOL] babel . localeselector ( get_locale ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Union , List [EOL] import builtins [EOL] import typing [EOL] import flask [EOL] import subprocess [EOL] from typing import Dict , List , Optional , Union [EOL] [EOL] from flask import current_app , make_response , url_for , wrappers [EOL] [EOL] from . import template [EOL] [EOL] [EOL] [comment] [EOL] class BaseView : [EOL] def home_url ( self ) : [EOL] return url_for ( [string] ) [EOL] [EOL] def template ( self ) : [EOL] return self . __class__ . __name__ . lower ( ) [EOL] [EOL] def content ( self ) : [EOL] return template . render ( self ) [EOL] [EOL] def page ( self ) : [EOL] return template . render_name ( [string] , self ) [EOL] [EOL] def response ( self ) : [EOL] return make_response ( self . page ( ) ) [EOL] [EOL] def prepare ( self ) : [EOL] pass [EOL] [EOL] def commit_id ( self , path = None ) : [EOL] if not path : [EOL] return current_app . config [ [string] ] [EOL] key = f' [string] { path }' [EOL] commit = current_app . config . get ( key , None ) [EOL] if commit is None : [EOL] args = [ [string] , [string] , [string] , [string] , [string] , path ] [EOL] commit = subprocess . check_output ( args , universal_newlines = True ) . strip ( [string] ) . strip ( [string] ) [EOL] current_app . config [ key ] = commit [EOL] return commit [EOL] [EOL] def git_branch ( self ) : [EOL] return current_app . config [ [string] ] [EOL] [EOL] def css_url ( self ) : [EOL] return current_app . config [ [string] ] or url_for ( [string] , filename = [string] , v = self . commit_id ( [string] ) ) [EOL] [EOL] def tooltips_url ( self ) : [EOL] [comment] [EOL] [comment] [EOL] if not hasattr ( self , [string] ) or len ( getattr ( self , [string] ) ) > [number] : [EOL] return None [EOL] return url_for ( [string] , filename = [string] , v = self . commit_id ( ) ) [EOL] [EOL] def js_url ( self ) : [EOL] return current_app . config [ [string] ] or url_for ( [string] , filename = [string] , v = self . commit_id ( [string] ) ) [EOL] [EOL] def bundle_url ( self ) : [EOL] return url_for ( [string] , filename = [string] , v = self . commit_id ( [string] ) ) [EOL] [EOL] def language_icon ( self ) : [EOL] return url_for ( [string] , filename = [string] ) [EOL] [EOL] def menu ( self ) : [EOL] return current_app . config [ [string] ] ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.wrappers.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[builtins.str,typing.Dict[builtins.str,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . internal_server_error import InternalServerError [EOL] from . not_found import NotFound [EOL] from . unauthorized import Unauthorized [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Container , Union [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import urllib . parse [EOL] from typing import Union [EOL] [EOL] from flask import url_for [EOL] [EOL] from shared . container import Container [EOL] [EOL] from . . base_view import BaseView [EOL] [EOL] [EOL] [comment] [EOL] class ErrorView ( BaseView ) : [EOL] def make_card ( self , c ) : [EOL] [comment] [EOL] [comment] [EOL] if not isinstance ( c , str ) : [EOL] return c [EOL] container = Container ( { [string] : c , [string] : url_for ( [string] , name = c ) , [string] : [string] . format ( name = urllib . parse . quote ( c ) ) } ) [EOL] return container [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import random [EOL] [EOL] from . error import ErrorView [EOL] [EOL] [EOL] [comment] [EOL] class InternalServerError ( ErrorView ) : [EOL] def __init__ ( self , exception ) : [EOL] super ( ) . __init__ ( ) [EOL] self . exception = str ( exception ) [EOL] self . card = super ( ) . make_card ( random . choice ( [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] self . cards = [ self . card ] [EOL] [EOL] def message ( self ) : [EOL] return [string] [EOL] [EOL] def template ( self ) : [EOL] return [string] [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from . error import ErrorView [EOL] [EOL] [EOL] [comment] [EOL] class Unauthorized ( ErrorView ) : [EOL] def __init__ ( self , error ) : [EOL] super ( ) . __init__ ( ) [EOL] if error : [EOL] self . error = error [EOL] [EOL] def page_title ( self ) : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
	0
from typing import Dict , Tuple , List , Container , Any [EOL] import builtins [EOL] import typing [EOL] import shared [EOL] import magic [EOL] import re [EOL] from typing import List , Tuple [EOL] [EOL] from decksite . data import preaggregation , query [EOL] from decksite . database import db as decksite_db [EOL] from logsite . database import db as logsite_db [EOL] from magic import oracle [EOL] from magic . models . card import Card [EOL] from shared import configuration [EOL] from shared . container import Container [EOL] from shared . database import sqlescape [EOL] from shared . decorators import retry_after_calling [EOL] [EOL] [EOL] def preaggregate ( ) : [EOL] preaggregate_played_person ( ) [EOL] [EOL] def preaggregate_played_person ( ) : [EOL] table = [string] [EOL] sql = [string] . format ( table = table , logsite_database = configuration . get ( [string] ) , season_join = query . season_join ( ) ) [EOL] preaggregation . preaggregate ( table , sql ) [EOL] [EOL] @ retry_after_calling ( preaggregate_played_person ) def played_cards_by_person ( person_id , season_id ) : [EOL] sql = [string] . format ( season_query = query . season_query ( season_id ) ) [EOL] cs = [ Container ( r ) for r in decksite_db ( ) . select ( sql , [ person_id ] ) ] [EOL] print ( len ( cs ) ) [EOL] cards = oracle . cards_by_name ( ) [EOL] for c in cs : [EOL] c . update ( cards [ c . name ] ) [EOL] return cs [EOL] [EOL] [comment] [EOL] def process_logs ( ) : [EOL] init ( ) [EOL] ids_to_process = next_ids ( ) [EOL] if not ids_to_process : [EOL] return [EOL] placeholders = [string] . join ( [string] for v in ids_to_process ) [EOL] sql = f""" [string] { placeholders } [string] """ [EOL] rs = logsite_db ( ) . select ( sql , ids_to_process ) [EOL] values = [ ] [EOL] for r in rs : [EOL] entries = process_log ( r [ [string] ] ) [EOL] for entry in entries : [EOL] values . append ( [ r [ [string] ] ] + list ( entry ) ) [EOL] sql = [string] [EOL] sql += [string] . join ( [string] + [string] . join ( str ( sqlescape ( v ) ) for v in vs ) + [string] for vs in values ) [EOL] logsite_db ( ) . execute ( sql ) [EOL] [EOL] def next_ids ( ) : [EOL] sql = [string] [EOL] return logsite_db ( ) . values ( sql ) [EOL] [EOL] def process_log ( log ) : [EOL] return re . findall ( [string] , log , re . MULTILINE ) [EOL] [EOL] def init ( ) : [EOL] sql = [string] [EOL] logsite_db ( ) . execute ( sql ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] from analysis import analysis [EOL] [EOL] [EOL] def test_process_log ( ) : [EOL] s = [string] [EOL] values = analysis . process_log ( s ) [EOL] print ( values ) [EOL] assert values == [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Sequence [EOL] import builtins [EOL] import magic [EOL] import flask [EOL] import typing [EOL] import decksite [EOL] from typing import Optional [EOL] [EOL] from flask import Response , make_response , request [EOL] [EOL] from decksite import APP , SEASONS , auth , get_season_id [EOL] from decksite . cache import cached [EOL] from decksite . data import card as cs [EOL] from decksite . league import DeckCheckForm [EOL] from decksite . views import Bugs , DeckCheck , LinkAccounts , Resources , Rotation , RotationChanges [EOL] from magic import card , oracle [EOL] [EOL] [EOL] @ cached ( ) @ APP . route ( [string] ) @ APP . route ( [string] ) def rotation ( interestingness = None ) : [EOL] query = request . args . get ( [string] ) [EOL] if query is None : [EOL] query = [string] [EOL] view = Rotation ( interestingness , query ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ cached ( ) @ APP . route ( [string] ) def resources ( ) : [EOL] view = Resources ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ cached ( ) @ APP . route ( [string] ) def bugs ( ) : [EOL] view = Bugs ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ auth . load_person @ APP . route ( [string] ) def deck_check ( form = None ) : [EOL] if form is None : [EOL] form = DeckCheckForm ( request . form , auth . person_id ( ) , auth . mtgo_username ( ) ) [EOL] view = DeckCheck ( form , auth . person_id ( ) ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ cached ( ) def do_deck_check ( ) : [EOL] form = DeckCheckForm ( request . form , auth . person_id ( ) , auth . mtgo_username ( ) ) [EOL] form . validate ( ) [EOL] return deck_check ( form ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) def rotation_changes ( ) : [EOL] query = request . args . get ( [string] ) [EOL] if query is None : [EOL] query = [string] [EOL] view = RotationChanges ( * oracle . pd_rotation_changes ( get_season_id ( ) ) , cs . playability ( ) , query = query ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ SEASONS . route ( [string] ) def rotation_changes_files ( changes_type ) : [EOL] changes = oracle . pd_rotation_changes ( get_season_id ( ) ) [ [number] if changes_type == [string] else [number] ] [EOL] s = [string] . join ( [string] . format ( name = card . to_mtgo_format ( c . name ) ) for c in changes ) [EOL] return make_response ( s , [number] , { [string] : [string] , [string] : f' [string] { changes_type } [string] ' } ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def rotation_speculation ( ) : [EOL] query = request . args . get ( [string] ) [EOL] if query is None : [EOL] query = [string] [EOL] view = RotationChanges ( oracle . if_todays_prices ( out = False ) , oracle . if_todays_prices ( out = True ) , cs . playability ( ) , speculation = True , query = query ) [EOL] return view . page ( ) [EOL] [EOL] @ APP . route ( [string] ) @ auth . admin_required def rotation_speculation_files ( changes_type ) : [EOL] out = changes_type != [string] [EOL] changes = oracle . if_todays_prices ( out = out ) [EOL] s = [string] . join ( [string] . format ( name = card . to_mtgo_format ( c . name ) ) for c in changes ) [EOL] return make_response ( s , [number] , { [string] : [string] , [string] : f' [string] { changes_type } [string] ' } ) [EOL] [EOL] [EOL] @ APP . route ( [string] ) @ auth . login_required def link ( ) : [EOL] view = LinkAccounts ( ) [EOL] return view . page ( ) [EOL] [EOL] [EOL] @ APP . route ( [string] , methods = [ [string] ] ) @ auth . login_required def link_post ( ) : [EOL] view = LinkAccounts ( ) [EOL] return view . page ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Mapping , Optional , List [EOL] import builtins [EOL] import typing [EOL] import decksite [EOL] import magic [EOL] from typing import Dict , List , Mapping , Optional , Union [EOL] [EOL] from decksite . data . archetype import Archetype [EOL] from decksite . data . person import Person [EOL] from decksite . view import View [EOL] from magic . models import Card , Deck [EOL] [EOL] [EOL] [comment] [EOL] class Matchups ( View ) : [EOL] def __init__ ( self , hero , enemy , season_id , archetypes , people , cards , results ) : [EOL] super ( ) . __init__ ( ) [EOL] self . results = results [EOL] if results : [EOL] self . results [ [string] ] = len ( results [ [string] ] ) [comment] [EOL] self . results [ [string] ] = str ( round ( ( results [ [string] ] / ( results [ [string] ] + results [ [string] ] ) ) * [number] , [number] ) ) if results . get ( [string] ) else [string][comment] [EOL] self . criteria = [ { [string] : [string] , [string] : [string] , [string] : hero } , { [string] : [string] , [string] : [string] , [string] : enemy } ] [EOL] [comment] [EOL] for c in self . criteria : [EOL] c [ [string] ] = [ { [string] : a . name , [string] : a . id , [string] : str ( c [ [string] ] . get ( [string] ) ) == str ( a . id ) } for a in archetypes ] [comment] [EOL] c [ [string] ] = [ { [string] : p . mtgo_username . lower ( ) , [string] : p . id , [string] : str ( c [ [string] ] . get ( [string] ) ) == str ( p . id ) } for p in people ] [comment] [EOL] c [ [string] ] = [ { [string] : card . name , [string] : c [ [string] ] . get ( [string] ) == card . name } for card in cards ] [comment] [EOL] self . seasons = [ { [string] : s [ [string] ] or [string] , [string] : s [ [string] ] , [string] : str ( season_id ) == str ( s [ [string] ] ) } for s in self . all_seasons ( ) ] [EOL] self . decks = results . get ( [string] , [ ] ) [comment] [EOL] self . show_decks = len ( self . decks ) > [number] [EOL] self . matches = results . get ( [string] , [ ] ) [EOL] self . show_matches = False [EOL] self . search_season_id = season_id [EOL] [EOL] def show_legal_seasons ( self ) : [EOL] return not self . search_season_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int]]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int]]$ 0 $typing.Optional[builtins.int]$ 0 $typing.List[decksite.data.archetype.Archetype]$ 0 $typing.List[decksite.data.person.Person]$ 0 $typing.List[magic.models.Card]$ 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.str,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.archetype.Archetype]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[decksite.data.person.Person]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[magic.models.Card]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Union[typing.List[builtins.int],typing.List[magic.models.deck.Deck],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0