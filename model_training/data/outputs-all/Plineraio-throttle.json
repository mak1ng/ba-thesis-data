from typing import Callable , Any , Type [EOL] import typing [EOL] import aiohttp [EOL] import aio_throttle [EOL] from typing import Awaitable , Callable [EOL] [EOL] from aiohttp import web [EOL] from aiohttp . web_middlewares import middleware [EOL] from aiohttp . web_request import Request [EOL] from aiohttp . web_response import StreamResponse [EOL] [EOL] from aio_throttle import Throttler , ThrottlePriority [EOL] [EOL] Handler = Callable [ [ Request ] , Awaitable [ StreamResponse ] ] [EOL] [EOL] [EOL] @ middleware async def middleware ( request , handler ) : [EOL] throttler = request . app [ [string] ] [EOL] consumer = request . headers . get ( [string] , [string] ) [EOL] priority = ThrottlePriority ( request . headers . get ( [string] , ThrottlePriority . NORMAL ) ) [EOL] async with throttler . throttle ( consumer , priority ) as result : [EOL] if not result : [EOL] return web . Response ( status = [number] ) [EOL] return await handler ( request ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aiohttp.web_response.StreamResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [EOL] logging . basicConfig ( level = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Counter , Tuple , Any , Coroutine , List [EOL] import collections [EOL] import aio_throttle [EOL] import logging [EOL] import typing [EOL] import tests [EOL] import logging [EOL] import time [EOL] from asyncio import sleep , gather [EOL] from collections import Counter [EOL] [EOL] import pytest [EOL] [EOL] from aio_throttle import MaxFractionCapacityQuota [EOL] from aio_throttle import Throttler [EOL] [EOL] DELAY = [number] [EOL] SUCCEED = [string] [EOL] FAILED = [string] [EOL] FIRST_CONSUMER = [string] [EOL] SECOND_CONSUMER = [string] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Server : [EOL] def __init__ ( self , delay , throttler ) : [EOL] self . throttler = throttler [EOL] self . delay = delay [EOL] [EOL] async def handle ( self , consumer = None ) : [EOL] async with self . throttler . throttle ( consumer ) as result : [EOL] logger . debug ( self . throttler . stats ) [EOL] if not result : [EOL] return FAILED [EOL] await sleep ( self . delay ) [EOL] return SUCCEED [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) ] , ) async def test_any_consumer_quota_workload ( capacity_limit , max_any_consumer_fraction , succeed_count , failed_count , multiplier ) : [EOL] consumer_quotas = [ MaxFractionCapacityQuota ( max_any_consumer_fraction ) ] [EOL] throttler = Throttler ( capacity_limit , [number] , consumer_quotas ) [EOL] server = Server ( DELAY , throttler ) [EOL] handle_tasks = list ( map ( lambda x : server . handle ( [string] ) , range ( [number] , succeed_count + failed_count ) ) ) [EOL] [EOL] start = time . monotonic ( ) [EOL] statuses = await gather ( * handle_tasks ) [EOL] end = time . monotonic ( ) [EOL] [EOL] counter = Counter ( statuses ) [EOL] assert counter [ SUCCEED ] == succeed_count [EOL] assert counter [ FAILED ] == failed_count [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) , ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) , ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) ] , ) async def test_consumers_quota_workload ( capacity_limit , max_consumer_fractions , first_consumer_counts , second_consumer_counts , multiplier ) : [EOL] max_first_consumer_fraction , max_second_consumer_fraction = max_consumer_fractions [EOL] first_consumer_succeed_count , first_consumer_failed_count = first_consumer_counts [EOL] second_consumer_succeed_count , second_consumer_failed_count = second_consumer_counts [EOL] consumer_quotas = [ MaxFractionCapacityQuota ( max_first_consumer_fraction , FIRST_CONSUMER ) , MaxFractionCapacityQuota ( max_second_consumer_fraction , SECOND_CONSUMER ) , ] [EOL] throttler = Throttler ( capacity_limit , [number] , consumer_quotas ) [EOL] server = Server ( DELAY , throttler ) [EOL] [EOL] first_consumer_handle_tasks = list ( map ( lambda x : server . handle ( FIRST_CONSUMER ) , range ( [number] , first_consumer_succeed_count + first_consumer_failed_count ) , ) ) [EOL] second_consumer_handle_tasks = list ( map ( lambda x : server . handle ( SECOND_CONSUMER ) , range ( [number] , second_consumer_succeed_count + second_consumer_failed_count ) , ) ) [EOL] [EOL] start = time . monotonic ( ) [EOL] first_consumer_statuses , second_consumer_statuses = await gather ( gather ( * first_consumer_handle_tasks ) , gather ( * second_consumer_handle_tasks ) ) [EOL] end = time . monotonic ( ) [EOL] [EOL] counter = Counter ( first_consumer_statuses ) [EOL] assert counter [ SUCCEED ] == first_consumer_succeed_count [EOL] assert counter [ FAILED ] == first_consumer_failed_count [EOL] [EOL] counter = Counter ( second_consumer_statuses ) [EOL] assert counter [ SUCCEED ] == second_consumer_succeed_count [EOL] assert counter [ FAILED ] == second_consumer_failed_count [EOL] [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Counter , Tuple , Any , Coroutine , List [EOL] import collections [EOL] import aio_throttle [EOL] import logging [EOL] import typing [EOL] import tests [EOL] import logging [EOL] import time [EOL] from asyncio import sleep , gather [EOL] from collections import Counter [EOL] [EOL] import pytest [EOL] [EOL] from aio_throttle import ThrottlePriority , MaxFractionCapacityQuota , Throttler [EOL] [EOL] DELAY = [number] [EOL] SUCCEED = [string] [EOL] FAILED = [string] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Server : [EOL] def __init__ ( self , delay , throttler ) : [EOL] self . throttler = throttler [EOL] self . delay = delay [EOL] [EOL] async def handle ( self , priority ) : [EOL] async with self . throttler . throttle ( None , priority ) as result : [EOL] logger . debug ( [string] , priority , result , self . throttler . stats ) [EOL] if not result : [EOL] return FAILED [EOL] await sleep ( self . delay ) [EOL] return SUCCEED [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) , ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) , ( [number] , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , [number] ) ] , ) async def test ( capacity_limit , max_priority_fractions , normal_counts , critical_counts , multiplier ) : [EOL] max_normal_fraction , max_critical_fraction = max_priority_fractions [EOL] priority_quotas = [ MaxFractionCapacityQuota ( max_normal_fraction , ThrottlePriority . NORMAL ) , MaxFractionCapacityQuota ( max_critical_fraction , ThrottlePriority . HIGH ) , ] [EOL] throttler = Throttler ( capacity_limit , [number] , [ ] , priority_quotas ) [EOL] server = Server ( DELAY , throttler ) [EOL] [EOL] normal_tasks = list ( map ( lambda x : server . handle ( ThrottlePriority . NORMAL ) , range ( [number] , sum ( normal_counts ) ) ) ) [EOL] critical_tasks = list ( map ( lambda x : server . handle ( ThrottlePriority . HIGH ) , range ( [number] , sum ( critical_counts ) ) ) ) [EOL] [EOL] start = time . monotonic ( ) [EOL] normal_statuses , critical_statuses = await gather ( gather ( * normal_tasks ) , gather ( * critical_tasks ) ) [EOL] end = time . monotonic ( ) [EOL] [EOL] normal_counter = Counter ( normal_statuses ) [EOL] assert ( normal_counter [ SUCCEED ] , normal_counter [ FAILED ] ) == normal_counts [EOL] [EOL] critical_counter = Counter ( critical_statuses ) [EOL] assert ( critical_counter [ SUCCEED ] , critical_counter [ FAILED ] ) == critical_counts [EOL] [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , ( [number] , [number] ) , [number] ) , ( [number] , [number] , ( [number] , [number] ) , [number] ) , ( [number] , [number] , ( [number] , [number] ) , [number] ) ] ) async def test_sheddable_queueing ( capacity_limit , queue_limit , counts , multiplier ) : [EOL] throttler = Throttler ( capacity_limit , queue_limit ) [EOL] server = Server ( DELAY , throttler ) [EOL] [EOL] handle_tasks = list ( map ( lambda x : server . handle ( ThrottlePriority . LOW ) , range ( [number] , sum ( counts ) ) ) ) [EOL] start = time . monotonic ( ) [EOL] statuses = await gather ( * handle_tasks ) [EOL] end = time . monotonic ( ) [EOL] [EOL] statuses_counter = Counter ( statuses ) [EOL] assert ( statuses_counter [ SUCCEED ] , statuses_counter [ FAILED ] ) == counts [EOL] [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Counter , Tuple , Any , Coroutine , List [EOL] import collections [EOL] import aio_throttle [EOL] import typing [EOL] import logging [EOL] import tests [EOL] import logging [EOL] import time [EOL] from asyncio import sleep , gather [EOL] from collections import Counter [EOL] [EOL] import pytest [EOL] [EOL] from aio_throttle import Throttler , RandomRejectThrottleQuota [EOL] [EOL] DELAY = [number] [EOL] SUCCEED = [string] [EOL] FAILED = [string] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Server : [EOL] def __init__ ( self , delay , throttler ) : [EOL] self . throttler = throttler [EOL] self . delay = delay [EOL] [EOL] async def handle ( self ) : [EOL] async with self . throttler . throttle ( None , None ) as result : [EOL] logger . debug ( [string] , result , self . throttler . stats ) [EOL] if not result : [EOL] return FAILED [EOL] await sleep ( self . delay ) [EOL] return SUCCEED [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) ] , ) async def test ( capacity_limit , reject_probability , succeed_count , failed_count , multiplier ) : [EOL] throttler = Throttler ( capacity_limit , [number] , [ ] , [ ] , [ RandomRejectThrottleQuota ( reject_probability , [number] ) ] ) [EOL] server = Server ( DELAY , throttler ) [EOL] [EOL] handle_tasks = list ( map ( lambda x : server . handle ( ) , range ( [number] , succeed_count + failed_count ) ) ) [EOL] [EOL] start = time . monotonic ( ) [EOL] statuses = await gather ( * handle_tasks ) [EOL] end = time . monotonic ( ) [EOL] [EOL] counter = Counter ( statuses ) [EOL] assert counter [ SUCCEED ] == succeed_count [EOL] assert counter [ FAILED ] == failed_count [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Counter , Tuple , Any , Coroutine , List [EOL] import collections [EOL] import tests [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import time [EOL] from asyncio import sleep , gather [EOL] from collections import Counter [EOL] [EOL] import pytest [EOL] [EOL] from aio_throttle import Throttler [EOL] [EOL] DELAY = [number] [EOL] SUCCEED = [string] [EOL] FAILED = [string] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class Server : [EOL] def __init__ ( self , delay , throttler ) : [EOL] self . throttler = throttler [EOL] self . delay = delay [EOL] [EOL] async def handle ( self , consumer = None ) : [EOL] async with self . throttler . throttle ( consumer ) as result : [EOL] logger . debug ( self . throttler . stats ) [EOL] if not result : [EOL] return FAILED [EOL] await sleep ( self . delay ) [EOL] return SUCCEED [EOL] [EOL] [EOL] @ pytest . mark . asyncio @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] , [number] ) , ] , ) async def test ( capacity_limit , queue_limit , succeed_count , failed_count , multiplier ) : [EOL] server = Server ( DELAY , Throttler ( capacity_limit , queue_limit ) ) [EOL] [EOL] handle_tasks = list ( map ( lambda x : server . handle ( ) , range ( [number] , succeed_count + failed_count ) ) ) [EOL] [EOL] start = time . monotonic ( ) [EOL] statuses = await gather ( * handle_tasks ) [EOL] end = time . monotonic ( ) [EOL] [EOL] counter = Counter ( statuses ) [EOL] assert counter [ SUCCEED ] == succeed_count [EOL] assert counter [ FAILED ] == failed_count [EOL] assert multiplier * DELAY <= end - start <= ( [number] * multiplier * DELAY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
import pytest [EOL] [EOL] from aio_throttle import MaxFractionCapacityQuota [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ] , ) def test_max_fraction_any_consumer_quota ( max_fraction , used , limit , accept ) : [EOL] assert accept == MaxFractionCapacityQuota ( max_fraction ) . can_be_accepted ( [string] , used , limit ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ] , ) def test_max_fraction_consumer_quota_match ( max_fraction , used , limit , accept ) : [EOL] assert accept == MaxFractionCapacityQuota ( max_fraction , [string] ) . can_be_accepted ( [string] , used , limit ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ] , ) def test_max_fraction_consumer_quota_not_match ( max_fraction , used , limit , accept ) : [EOL] assert accept == MaxFractionCapacityQuota ( max_fraction , [string] ) . can_be_accepted ( [string] , used , limit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . throttle import ThrottlePriority , ThrottleStats , ThrottleResult , Throttler [comment] [EOL] from . quotas import ThrottleCapacityQuota , MaxFractionCapacityQuota , ThrottleQuota , RandomRejectThrottleQuota [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import asyncio [EOL] import typing [EOL] import asyncio [EOL] from asyncio import Future [EOL] from typing import List [EOL] [EOL] [EOL] class LifoSemaphore : [EOL] __slots__ = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def __init__ ( self , initial = [number] ) : [EOL] if initial < [number] : [EOL] raise ValueError ( [string] ) [EOL] self . _limit = initial [EOL] self . _available = initial [EOL] self . _waiters = [ ] [EOL] self . _loop = asyncio . get_event_loop ( ) [EOL] [EOL] def _wake_up_next ( self ) : [EOL] while self . _waiters : [EOL] waiter = self . _waiters . pop ( ) [EOL] if not waiter . done ( ) : [EOL] waiter . set_result ( None ) [EOL] return [EOL] [EOL] @ property def available ( self ) : [EOL] return self . _available [EOL] [EOL] @ property def waiting ( self ) : [EOL] return len ( self . _waiters ) [EOL] [EOL] def acquire_no_wait ( self ) : [EOL] if self . _available <= [number] : [EOL] return False [EOL] [EOL] self . _available -= [number] [EOL] return True [EOL] [EOL] async def acquire ( self ) : [EOL] while self . _available <= [number] : [EOL] future = self . _loop . create_future ( ) [EOL] self . _waiters . append ( future ) [EOL] try : [EOL] await future [EOL] except : [comment] [EOL] future . cancel ( ) [EOL] if self . _available > [number] and not future . cancelled ( ) : [EOL] self . _wake_up_next ( ) [EOL] raise [EOL] self . _available -= [number] [EOL] return [EOL] [EOL] def release ( self ) : [EOL] if self . _available >= self . _limit : [EOL] raise ValueError ( [string] ) [EOL] self . _available += [number] [EOL] self . _wake_up_next ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[asyncio.Future[None]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , TypeVar , Any , Optional [EOL] import builtins [EOL] import random [EOL] import typing [EOL] from abc import abstractmethod , ABC [EOL] from random import Random [EOL] from typing import TypeVar , Generic , List , Optional , Any [EOL] [EOL] TResource = TypeVar ( [string] ) [EOL] [EOL] [EOL] class ThrottleCapacityQuota ( Generic [ TResource ] ) : [EOL] __slots__ = [ ] [EOL] [EOL] @ abstractmethod def can_be_accepted ( self , resource , capacity_used , capacity_limit ) : [EOL] ... [EOL] [EOL] [EOL] class CompositeThrottleCapacityQuota ( ThrottleCapacityQuota [ TResource ] ) : [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , quotas ) : [EOL] self . _quotas = quotas [EOL] [EOL] def can_be_accepted ( self , resource , capacity_used , capacity_limit ) : [EOL] for quota in self . _quotas : [EOL] if not quota . can_be_accepted ( resource , capacity_used , capacity_limit ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] class MaxFractionCapacityQuota ( ThrottleCapacityQuota [ TResource ] ) : [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , max_fraction , resource = None ) : [EOL] if max_fraction < [number] or max_fraction > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _matched_resource = resource [EOL] self . _max_fraction = max_fraction [EOL] [EOL] def can_be_accepted ( self , resource , used_capacity , capacity_limit ) : [EOL] if self . _matched_resource is not None and resource != self . _matched_resource : [EOL] return True [EOL] return ( used_capacity * [number] / capacity_limit ) <= self . _max_fraction [EOL] [EOL] [EOL] class ThrottleQuota ( ABC ) : [EOL] @ abstractmethod def can_be_accepted ( self ) : [EOL] ... [EOL] [EOL] [EOL] class CompositeThrottleQuota ( ThrottleQuota ) : [EOL] __slots__ = [ [string] ] [EOL] [EOL] def __init__ ( self , quotas ) : [EOL] self . _quotas = quotas [EOL] [EOL] def can_be_accepted ( self ) : [EOL] for quota in self . _quotas : [EOL] if not quota . can_be_accepted ( ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] class RandomRejectThrottleQuota ( ThrottleQuota ) : [EOL] __slots__ = [ [string] , [string] ] [EOL] [EOL] def __init__ ( self , reject_probability , seed = None ) : [EOL] if reject_probability < [number] or reject_probability > [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] self . _reject_probability = reject_probability [EOL] self . _random = Random ( seed ) [EOL] [EOL] def can_be_accepted ( self ) : [EOL] return self . _reject_probability == [number] or self . _random . random ( ) < self . _reject_probability [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $TResource$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ThrottleCapacityQuota[TResource]]$ 0 0 0 0 0 0 0 $typing.List[ThrottleCapacityQuota[TResource]]$ 0 0 0 $builtins.bool$ 0 0 0 $TResource$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TResource$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Optional[TResource]$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[TResource]$ 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.bool$ 0 0 0 $TResource$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $TResource$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[ThrottleQuota]$ 0 0 0 0 0 0 0 $typing.List[ThrottleQuota]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $random.Random$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0