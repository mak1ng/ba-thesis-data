import builtins [EOL] from typing import Dict [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] import os [EOL] [EOL] [comment] [EOL] ROOT_DIR = os . path . dirname ( os . path . abspath ( __file__ ) ) [comment] [EOL] root_dir = Path ( ROOT_DIR ) [EOL] [EOL] temp_dir = root_dir / [string] [EOL] static_dir = root_dir / [string] [EOL] test_dir = root_dir / [string] [EOL] [EOL] [comment] [EOL] dirs = { [string] : temp_dir / [string] , [string] : temp_dir / [string] , [string] : temp_dir / [string] , [string] : temp_dir / [string] , [string] : temp_dir / [string] , [string] : temp_dir / [string] , [string] : static_dir / [string] , [string] : root_dir / [string] , [string] : root_dir / [string] , [string] : temp_dir / [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] paths = { [string] : dirs [ [string] ] / [string] , [string] : dirs [ [string] ] / [string] , [string] : dirs [ [string] ] / [string] , [string] : dirs [ [string] ] / [string] , [string] : dirs [ [string] ] / [string] , [string] : dirs [ [string] ] / [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pathlib.Path]$ 0 0 0 0 0 0 0 0
	0
	0
	0
import unittest [EOL] from selenium import webdriver [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from modules . initialize import initialize_driver [EOL] from locations import paths , root_dir [EOL] from logs . config . logging import logs_config [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [EOL] class TestInitialize ( unittest . TestCase ) : [EOL] def test_chrome_driver_initializes ( self ) : [EOL] [docstring] [EOL] driver = initialize_driver ( ) [EOL] self . assertIsInstance ( driver , webdriver . Chrome ) [EOL] driver . close ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import pathlib [EOL] import unittest [EOL] from pathlib import Path [EOL] from shutil import rmtree [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from tests . fixtures . dict_list . docket_list_with_duplicates import docket_list [EOL] from modules . misc import pdf_path_gen , clean_list_of_dicts , create_folders [EOL] from logs . config . logging import logs_config [EOL] from locations import paths , root_dir , test_dir [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dir = { [string] : test_dir / [string] , [string] : test_dir / [string] , } [EOL] [EOL] [EOL] class TestPdfPathGen ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] if mock_dir [ [string] ] . is_dir ( ) : [EOL] rmtree ( mock_dir [ [string] ] ) [EOL] mock_dir [ [string] ] . mkdir ( exist_ok = True , parents = True ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_generate_unique_pdf_names ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] docket1 = [string] [EOL] docket2 = [string] [EOL] docketnum_list = [ docket1 , docket1 , docket2 , docket1 ] [EOL] [EOL] [comment] [EOL] desired_output = [ mock_dir [ [string] ] / f"{ docket1 } [string] " , mock_dir [ [string] ] / f"{ docket1 } [string] " , mock_dir [ [string] ] / f"{ docket2 } [string] " , mock_dir [ [string] ] / f"{ docket1 } [string] " , ] [EOL] [EOL] [comment] [EOL] pdf_paths = [ ] [EOL] for docketnum in docketnum_list : [EOL] path = pdf_path_gen ( mock_dir [ [string] ] , docketnum ) [EOL] with open ( path , [string] ) as fout : [EOL] fout . write ( [string] ) [EOL] pdf_paths . append ( path ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( pdf_paths , desired_output ) [EOL] [EOL] [EOL] class TestCleanList ( unittest . TestCase ) : [EOL] def test_duplicates_are_removed ( self ) : [EOL] [docstring] [EOL] expected_list = docket_list [ [number] : ] [EOL] test_list = clean_list_of_dicts ( docket_list ) [EOL] self . assertEqual ( expected_list , test_list ) [EOL] [EOL] def test_no_duplicates_in_results ( self ) : [EOL] [docstring] [EOL] expected_list = docket_list [EOL] test_list = clean_list_of_dicts ( docket_list ) [EOL] self . assertNotEqual ( expected_list , test_list ) [EOL] [EOL] def test_handles_empty_list ( self ) : [EOL] empty_list = [ ] [EOL] test_list = clean_list_of_dicts ( empty_list ) [EOL] self . assertFalse ( test_list ) [EOL] [EOL] [EOL] class TestCreateFolders ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] if mock_dir [ [string] ] . is_dir ( ) : [EOL] rmtree ( mock_dir [ [string] ] ) [EOL] mock_dir [ [string] ] . mkdir ( ) [EOL] self . output_dir = mock_dir [ [string] ] [EOL] self . list_of_subdirs_to_create = [ self . output_dir / [string] , self . output_dir / [string] , self . output_dir / [string] , ] [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_directories_are_created ( self ) : [EOL] [comment] [EOL] create_folders ( self . list_of_subdirs_to_create ) [EOL] [comment] [EOL] list_of_dirs_created = [ subdir for subdir in self . output_dir . iterdir ( ) if subdir . is_dir ( ) ] [EOL] print ( [string] , self . list_of_subdirs_to_create ) [EOL] print ( [string] , list_of_dirs_created ) [EOL] self . assertCountEqual ( list_of_dirs_created , self . list_of_subdirs_to_create ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $pathlib.Path$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Optional [EOL] import typing [EOL] import boto3 [EOL] import logging [EOL] import os [EOL] [EOL] [EOL] [EOL] [EOL] def check_file_exists_in_s3_bucket ( bucket_name , dst_path ) : [EOL] [EOL] [comment] [EOL] keyID = os . environ . get ( [string] ) [EOL] sKeyID = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] logging . info ( f" [string] { dst_path } [string] { bucket_name }" ) [EOL] session = boto3 . Session ( aws_access_key_id = keyID , aws_secret_access_key = sKeyID , ) [EOL] s3 = session . resource ( [string] ) [EOL] [EOL] [comment] [EOL] bucket = s3 . Bucket ( bucket_name ) [EOL] objs = list ( bucket . objects . filter ( Prefix = dst_path ) ) [EOL] if len ( objs ) > [number] and objs [ [number] ] . key == dst_path : [EOL] logging . info ( [string] ) [EOL] return True [EOL] else : [EOL] logging . info ( [string] ) [EOL] return False [EOL] [EOL] def delete_key_in_bucket ( bucket_name , dst_path ) : [EOL] [EOL] [comment] [EOL] keyID = os . environ . get ( [string] ) [EOL] sKeyID = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] logging . info ( f" [string] { dst_path } [string] { bucket_name }" ) [EOL] session = boto3 . Session ( aws_access_key_id = keyID , aws_secret_access_key = sKeyID , ) [EOL] s3 = session . resource ( [string] ) [EOL] bucket = s3 . Bucket ( bucket_name ) [EOL] try : [EOL] bucket . objects . filter ( Prefix = dst_path ) . delete ( ) [EOL] except Exception as e : [EOL] logging . error ( f" [string] " f"{ dst_path }" ) [EOL] logging . exception ( e ) [EOL] raise	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import os [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] import dotenv [EOL] import os [EOL] import logging [EOL] [EOL] [comment] [EOL] from logs . config . logging import logs_config [EOL] from locations import paths , dirs , root_dir , test_dir [EOL] from modules . move_s3 import copy_file_to_s3_bucket [EOL] from tests . modules . test_move_s3 . helper import check_file_exists_in_s3_bucket , delete_key_in_bucket [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dirs = { [string] : test_dir / [string] , } [EOL] [EOL] mock_paths = { [string] : mock_dirs [ [string] ] / [string] , } [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mock_env = os . environ [EOL] mock_env [ [string] ] = [string] [EOL] mock_env [ [string] ] = [string] [EOL] [EOL] class TestMoveS3 ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def tearDown ( self ) : [EOL] delete_key_in_bucket ( mock_env [ [string] ] , mock_env [ [string] ] ) [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) @ mock . patch . dict ( os . environ , mock_env , clear = True ) def test_file_is_moved_to_s3_bucket ( self ) : [EOL] [docstring] [EOL] copy_file_to_s3_bucket ( ) [EOL] file_exists = check_file_exists_in_s3_bucket ( mock_env [ [string] ] , mock_env [ [string] ] ) [EOL] self . assertTrue ( file_exists ) [EOL] [EOL] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] from datetime import datetime , timedelta [EOL] from shutil import rmtree [EOL] import os [EOL] import json [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from logs . config . logging import logs_config [EOL] from locations import paths , dirs , root_dir , test_dir [EOL] from modules . email import email_notification , login_to_gmail_and_send [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dirs = { [string] : test_dir / [string] , [string] : dirs [ [string] ] , [string] : test_dir / [string] , [string] : test_dir / [string] , } [EOL] [EOL] mock_paths = { [string] : mock_dirs [ [string] ] / [string] , [string] : mock_dirs [ [string] ] / [string] , [string] : mock_dirs [ [string] ] / [string] , } [EOL] [EOL] [EOL] class TestEmailHomicideAndMurder ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] if mock_dirs [ [string] ] . is_dir ( ) : [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [comment] [EOL] self . scrape_start_datetime = datetime . now ( ) - timedelta ( hours = [number] ) [EOL] self . scrape_end_datetime = datetime . now ( ) [EOL] self . target_scrape_day = [string] [EOL] self . county_list = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) @ mock . patch . dict ( dirs , mock_dirs , clear = True ) def test_email_with_homicide_and_murder_sends ( self ) : [EOL] [docstring] [EOL] email_notification ( self . scrape_start_datetime , self . scrape_end_datetime , self . target_scrape_day , self . county_list ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import unittest [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from modules . email import email_error_notification [EOL] from locations import paths , root_dir , test_dir [EOL] from logs . config . logging import logs_config [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [EOL] class TestEmailError ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] pass [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] def test_error_email_runs_without_errors ( self ) : [EOL] [docstring] [EOL] error_summary = [string] [EOL] full_error_msg = ( [string] [string] ) [EOL] email_error_notification ( error_summary , full_error_msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] from shutil import rmtree [EOL] [EOL] [comment] [EOL] from locations import dirs , root_dir , test_dir [EOL] from modules . convert import convert_pdf_to_text [EOL] [EOL] mock_dirs = { [string] : test_dir / [string] , [string] : test_dir / [string] , } [EOL] [EOL] [EOL] class TestConvertPdfToText ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] [comment] [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] @ mock . patch . dict ( dirs , mock_dirs , clear = True ) def test_text_file_is_generated ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] docketnum = [string] [EOL] pdf_path = mock_dirs [ [string] ] / ( docketnum + [string] ) [EOL] expected_path = mock_dirs [ [string] ] / ( docketnum + [string] ) [EOL] [comment] [EOL] convert_pdf_to_text ( pdf_path , docketnum ) [EOL] [comment] [EOL] self . assertTrue ( expected_path . is_file ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import requests [EOL] import typing [EOL] import requests [EOL] [EOL] def helper_delete ( s , rest_api , list_of_docketnums ) : [EOL] [docstring] [EOL] hostname = rest_api [ [string] ] [EOL] delete_count = [number] [EOL] for docketnum in list_of_docketnums : [EOL] delete_endpoint = hostname + [string] + docketnum [EOL] r = s . delete ( delete_endpoint ) [EOL] status_code = r . status_code [EOL] data = r . json ( ) if r . content else None [EOL] [comment] [EOL] if status_code != [number] : [comment] [EOL] print ( data ) [EOL] else : [EOL] [comment] [EOL] print ( f" [string] { docketnum }" ) [EOL] delete_count += [number] [EOL] print ( f"{ delete_count } [string] " ) [EOL] return s [EOL] [EOL] [EOL] def helper_get_docketnums_in_db ( rest_api ) : [EOL] [docstring] [EOL] [EOL] hostname = rest_api [ [string] ] [EOL] [EOL] print ( [string] ) [EOL] get_cases_endpoint = hostname + [string] [EOL] r = requests . get ( get_cases_endpoint ) [EOL] status_code = r . status_code [EOL] data = r . json ( ) [EOL] [comment] [EOL] if status_code != [number] : [comment] [EOL] print ( data ) [EOL] return [EOL] [comment] [EOL] cases = data [ [string] ] [EOL] return [ case [ [string] ] for case in cases ]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import os [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] [comment] [EOL] import os [EOL] import pandas as pd [EOL] import requests [EOL] [EOL] [comment] [EOL] from modules . upload import upload_to_rest_api , login , logout [EOL] from locations import paths , root_dir , test_dir [EOL] from logs . config . logging import logs_config [EOL] from tests . modules . test_upload . helpers import helper_delete , helper_get_docketnums_in_db [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] mock_paths = { [string] : test_dir / [string] } [EOL] mock_env = os . environ [EOL] mock_env [ [string] ] = [string] [EOL] [EOL] [EOL] class TestUpload ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [EOL] [docstring] [EOL] self . rest_api = { [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , } [EOL] [EOL] [comment] [EOL] df = pd . read_csv ( mock_paths [ [string] ] , dtype = { [string] : str } ) [EOL] print ( df ) [EOL] self . list_of_docketnums_to_be_uploaded = df [ [string] ] . to_list ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] [comment] [EOL] s = requests . Session ( ) [EOL] try : [EOL] [comment] [EOL] s = login ( s , self . rest_api ) [EOL] [comment] [EOL] s = helper_delete ( s , self . rest_api , self . list_of_docketnums_to_be_uploaded ) [EOL] [comment] [EOL] logout ( s , self . rest_api ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] s . close ( ) [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) @ mock . patch . dict ( os . environ , mock_env , clear = True ) def test_upload_cases_to_db ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] upload_to_rest_api ( ) [EOL] [EOL] [comment] [EOL] list_of_dockets_in_db = [ ] [EOL] try : [EOL] list_of_dockets_in_db = helper_get_docketnums_in_db ( self . rest_api ) [EOL] except Exception as error : [EOL] print ( error ) [EOL] test_bool = all ( elem in list_of_dockets_in_db for elem in self . list_of_docketnums_to_be_uploaded ) [EOL] [EOL] [comment] [EOL] self . assertTrue ( test_bool ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $os._Environ[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] from dotenv import load_dotenv [EOL] [EOL] [comment] [EOL] from modules . initialize import initialize_driver [EOL] from modules . misc import yesterday_date [EOL] from modules . scrape import scrape [EOL] from locations import paths , root_dir [EOL] from logs . config . logging import logs_config [EOL] import logging [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] load_dotenv ( root_dir / [string] ) [EOL] [EOL] [EOL] class TestScrape ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . driver = initialize_driver ( ) [EOL] [EOL] def test_scrape_without_error ( self ) : [EOL] [docstring] [EOL] scrape_date = yesterday_date ( ) [comment] [EOL] docket_list = scrape ( [string] , scrape_date ) [EOL] logging . info ( docket_list ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] import pandas as pd [EOL] from shutil import rmtree [EOL] from pathlib import Path [EOL] import logging [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from tests . fixtures . dict_list . docket_list_with_homicide import docket_list [EOL] [EOL] [comment] [EOL] from modules . export import ( convert_dict_into_df , save_html_county_payload , convert_df_to_html , ) [EOL] from logs . config . logging import logs_config [EOL] from locations import paths , dirs , root_dir , test_dir [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dirs = { [string] : test_dir / [string] , [string] : dirs [ [string] ] , } [EOL] [EOL] mock_paths = { [string] : mock_dirs [ [string] ] / [string] , } [EOL] [EOL] [EOL] class TestSaveHtmlPayload ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [comment] [EOL] logging . info ( f" [string] { mock_dirs [ [string] ] } [string] " ) [EOL] if mock_dirs [ [string] ] . is_dir ( ) : [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] [comment] [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] [comment] [EOL] pd . set_option ( [string] , [number] ) [EOL] pd . set_option ( [string] , [number] ) [EOL] pd . set_option ( [string] , [number] ) [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) def test_html_file_is_created ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] df = convert_dict_into_df ( docket_list , [string] ) [EOL] [comment] [EOL] styled_df = convert_df_to_html ( df ) [EOL] [comment] [EOL] save_html_county_payload ( [string] , styled_df ) [EOL] [comment] [EOL] self . assertTrue ( mock_paths [ [string] ] . is_file ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] import pandas as pd [EOL] from shutil import rmtree [EOL] import dotenv [EOL] [EOL] [comment] [EOL] from tests . fixtures . dict_list . docket_list import docket_list [EOL] from locations import paths , dirs , root_dir , test_dir [EOL] from logs . config . logging import logs_config [EOL] from modules . export import ( convert_dict_into_df , convert_df_to_csv , save_html_county_payload , convert_df_to_html , ) [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] dotenv . load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dirs = { [string] : test_dir / [string] , [string] : test_dir / [string] , [string] : dirs [ [string] ] , } [EOL] [EOL] mock_paths = { [string] : mock_dirs [ [string] ] / [string] , [string] : mock_dirs [ [string] ] / [string] , } [EOL] [EOL] [EOL] class TestConvertDictToDf ( unittest . TestCase ) : [EOL] def test_convert_dict_into_df ( self ) : [EOL] [docstring] [EOL] [EOL] df = convert_dict_into_df ( docket_list , [string] ) [EOL] self . assertIsInstance ( df , pd . core . frame . DataFrame ) [EOL] [EOL] def test_convert_empty_dict_into_df ( self ) : [EOL] [docstring] [EOL] empty_dict = { } [EOL] df = convert_dict_into_df ( empty_dict , [string] ) [EOL] self . assertIsInstance ( df , pd . core . frame . DataFrame ) [EOL] [EOL] [EOL] class TestConvertDfToCsv ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [comment] [EOL] self . df = convert_dict_into_df ( docket_list , [string] ) [comment] [EOL] [EOL] def tearDown ( self ) : [EOL] print ( f" [string] { mock_dirs [ [string] ] }" ) [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) def test_csv_file_is_created ( self ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] convert_df_to_csv ( self . df ) [EOL] [comment] [EOL] self . assertTrue ( mock_paths [ [string] ] . is_file ( ) ) [EOL] [EOL] [EOL] class TestSaveHtmlPayload ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [EOL] [comment] [EOL] df = convert_dict_into_df ( docket_list , [string] ) [EOL] self . styled_df = convert_df_to_html ( df ) [EOL] [EOL] def tearDown ( self ) : [EOL] print ( f" [string] { mock_dirs [ [string] ] }" ) [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] [EOL] @ mock . patch . dict ( paths , mock_paths , clear = True ) def test_html_file_is_created ( self ) : [EOL] [docstring] [EOL] save_html_county_payload ( [string] , self . styled_df ) [EOL] [comment] [EOL] self . assertTrue ( mock_paths [ [string] ] . is_file ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] from unittest import mock [EOL] from pathlib import Path [EOL] from shutil import rmtree [EOL] from dotenv import load_dotenv [EOL] [EOL] [comment] [EOL] from modules . download import download_pdf [EOL] from modules . initialize import initialize_driver [EOL] from locations import dirs , paths , root_dir , test_dir [EOL] from logs . config . logging import logs_config [EOL] [EOL] [comment] [EOL] logs_config ( paths [ [string] ] ) [EOL] [EOL] [comment] [EOL] load_dotenv ( root_dir / [string] ) [EOL] [EOL] [comment] [EOL] mock_dirs = { [string] : test_dir / [string] } [comment] [EOL] [EOL] [comment] [EOL] @ mock . patch . dict ( dirs , mock_dirs , clear = True ) def initialize_test_driver ( ) : [EOL] [docstring] [EOL] return initialize_driver ( ) [EOL] [EOL] [EOL] [comment] [EOL] class TestPdfDownload ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] [comment] [EOL] if mock_dirs [ [string] ] . is_dir ( ) : [EOL] rmtree ( mock_dirs [ [string] ] ) [EOL] mock_dirs [ [string] ] . mkdir ( parents = True , exist_ok = True ) [EOL] [comment] [EOL] self . driver = initialize_test_driver ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] pass [EOL] [EOL] @ mock . patch . dict ( dirs , mock_dirs , clear = True ) def test_download_pdf ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] url = [string] [EOL] docketnum = [string] [EOL] [comment] [EOL] pdf_path = download_pdf ( self . driver , url , docketnum ) [EOL] [comment] [EOL] self . assertTrue ( pdf_path . is_file ( ) ) [EOL] [EOL] @ mock . patch . dict ( dirs , mock_dirs , clear = True ) def test_error_raised_when_pdf_download_fails ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] url = [string] [EOL] docketnum = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . assertRaises ( Exception , lambda : download_pdf ( self . driver , url , docketnum ) ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
from typing import List , Literal , Union , Any [EOL] import typing_extensions [EOL] import typing [EOL] def docket_list_gen ( num_of_items ) : [EOL] docket_list = [ ] [EOL] for count in range ( num_of_items ) : [EOL] case_caption = ( [string] [EOL] if ( count % [number] == [number] ) [EOL] else [string] ) [EOL] charges = ( [string] [EOL] if ( count % [number] == [number] ) [EOL] else [string] [string] [string] ) [EOL] [EOL] defendant = [string] if ( count % [number] == [number] ) else [string] [EOL] docket_list . append ( { [string] : [string] , [string] : defendant , [string] : count , [string] : [string] , [string] : [string] , [string] : case_caption , [string] : [string] , [string] : [string] , [string] : charges , [string] : count * [number] , [string] : [string] , } ) [EOL] return docket_list [EOL] [EOL] [EOL] docket_list = docket_list_gen ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import boto3 [EOL] import logging [EOL] import os [EOL] [EOL] [comment] [EOL] from locations import paths [EOL] from modules . email import email_error_notification [EOL] [EOL] def copy_file_to_s3_bucket ( ) : [EOL] [EOL] try : [EOL] [comment] [EOL] if not paths [ [string] ] . is_file ( ) : [EOL] logging . error ( f" [string] { paths [ [string] ] } [string] " [string] ) [EOL] raise [EOL] [EOL] [comment] [EOL] bucket_name = os . environ . get ( [string] ) [EOL] keyID = os . environ . get ( [string] ) [EOL] sKeyID = os . environ . get ( [string] ) [EOL] source_path = str ( paths [ [string] ] . resolve ( ) ) [EOL] destination_path = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] logging . info ( f" [string] { source_path } [string] { bucket_name } [string] " ) [EOL] logging . info ( f" [string] { destination_path }" ) [EOL] [EOL] [comment] [EOL] session = boto3 . Session ( aws_access_key_id = keyID , aws_secret_access_key = sKeyID , ) [EOL] s3 = session . resource ( [string] ) [EOL] [EOL] [comment] [EOL] s3 . Bucket ( bucket_name ) . upload_file ( source_path , destination_path ) [EOL] logging . info ( f" [string] { destination_path }" ) [EOL] except Exception as e : [EOL] error_summary = [string] [string] [EOL] logging . exception ( e ) [EOL] email_error_notification ( error_summary , e ) [EOL] return [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any [EOL] import io [EOL] import builtins [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [EOL] [comment] [EOL] from pdfminer . pdfparser import PDFParser [EOL] from pdfminer . pdfdocument import PDFDocument [EOL] from pdfminer . pdfpage import PDFPage [EOL] from pdfminer . pdfinterp import PDFResourceManager , PDFPageInterpreter [EOL] from pdfminer . pdfpage import PDFTextExtractionNotAllowed [EOL] from pdfminer . layout import LAParams , LTTextBox , LTTextLine [EOL] from pdfminer . converter import PDFPageAggregator [EOL] import logging [EOL] from typing import Union [EOL] [EOL] [comment] [EOL] from modules . misc import extracted_text_path_gen [EOL] from locations import dirs [EOL] [EOL] [EOL] def convert_pdf_to_text ( pdf_path , docketnum ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] extracted_text_path = extracted_text_path_gen ( dirs [ [string] ] , docketnum ) [EOL] [EOL] logging . info ( f" [string] { docketnum } [string] " ) [EOL] password = [string] [EOL] extracted_text = [string] [EOL] [EOL] [comment] [EOL] fp = open ( pdf_path , [string] ) [EOL] [EOL] [comment] [EOL] parser = PDFParser ( fp ) [EOL] [EOL] [comment] [EOL] try : [EOL] document = PDFDocument ( parser , password ) [EOL] except Exception as e : [EOL] logging . error ( [string] ) [EOL] logging . exception ( e ) [EOL] logging . info ( [string] . format ( docketnum ) ) [EOL] return extracted_text [EOL] [EOL] [comment] [EOL] if not document . is_extractable : [EOL] raise PDFTextExtractionNotAllowed [EOL] [EOL] [comment] [EOL] rsrcmgr = PDFResourceManager ( ) [EOL] [EOL] [comment] [EOL] laparams = LAParams ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] device = PDFPageAggregator ( rsrcmgr , laparams = laparams ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] interpreter = PDFPageInterpreter ( rsrcmgr , device ) [EOL] [EOL] [comment] [EOL] for page in PDFPage . create_pages ( document ) : [EOL] [comment] [EOL] interpreter . process_page ( page ) [EOL] [comment] [EOL] layout = device . get_result ( ) [EOL] [comment] [EOL] for lt_obj in layout : [EOL] if isinstance ( lt_obj , LTTextBox ) or isinstance ( lt_obj , LTTextLine ) : [EOL] extracted_text += lt_obj . get_text ( ) [EOL] [comment] [EOL] fp . close ( ) [EOL] [EOL] with open ( extracted_text_path , [string] ) as fout : [EOL] fout . write ( extracted_text . encode ( [string] ) ) [EOL] logging . info ( [string] ) [EOL] return extracted_text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Union , Optional , Literal [EOL] import typing_extensions [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import smtplib [EOL] from email . mime . text import MIMEText [EOL] from email . mime . multipart import MIMEMultipart [EOL] from email . mime . base import MIMEBase [EOL] from email import encoders [EOL] from datetime import datetime , timedelta [EOL] import os [EOL] import json [EOL] import logging [EOL] from typing import List , Union , Optional [EOL] import pandas as pd [EOL] import time [EOL] [EOL] [comment] [EOL] from modules import export [EOL] from modules . misc import get_datetime_now_formatted , detect_keyword_in_df [EOL] from locations import dirs , paths [EOL] [EOL] [EOL] def email_error_notification ( error_summary , full_error_msg ) : [EOL] [EOL] [docstring] [EOL] [EOL] error_emails_enabled = False if os . environ . get ( [string] ) == [string] else True [EOL] if not error_emails_enabled : [EOL] logging . info ( [string] ) [EOL] return [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] error_datetime = get_datetime_now_formatted ( ) [EOL] dir_email_template = dirs [ [string] ] [EOL] county_list = [ x . title ( ) for x in json . loads ( os . environ . get ( [string] ) ) ] [comment] [EOL] target_scrape_day = os . environ . get ( [string] , [string] ) . lower ( ) [EOL] [EOL] pluralize_county = [string] if len ( county_list ) == [number] else [string] [EOL] mobile_tease_content = error_summary [EOL] intro_content = ( f" [string] { error_summary } [string] " f" [string] { target_scrape_day } [string] { [string] . join ( county_list ) } [string] { pluralize_county }" f" [string] { error_datetime } [string] " ) [EOL] body_content = ( f" [string] " f"{ full_error_msg } [string] " ) [EOL] footer_content = [string] [EOL] subject_line = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] dir_latest_logs = dirs [ [string] ] / [string] [EOL] attachments = list ( dir_latest_logs . glob ( [string] ) ) [comment] [EOL] [EOL] [comment] [EOL] message = create_final_email_payload ( dir_email_template , mobile_tease_content , intro_content , body_content , footer_content , ) [EOL] [EOL] [comment] [EOL] recipients = os . environ . get ( [string] ) [EOL] if recipients : [EOL] recipients = json . loads ( recipients ) [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] recipients = json . loads ( os . environ . get ( [string] ) ) [EOL] [EOL] login_to_gmail_and_send ( recipients , message , subject_line , attachments ) [EOL] [EOL] [EOL] def email_notification ( scrape_start_datetime , scrape_end_datetime , target_scrape_day , county_list ) : [EOL] [EOL] [docstring] [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] scrape_end_date = scrape_end_datetime . strftime ( [string] ) [EOL] yesterday_date = ( datetime . now ( ) - timedelta ( [number] ) ) . strftime ( [string] ) [EOL] [EOL] [comment] [EOL] if paths [ [string] ] . is_file ( ) : [EOL] df = pd . read_csv ( paths [ [string] ] ) [EOL] num_of_cases = len ( df . index ) [EOL] else : [EOL] num_of_cases = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] mobile_tease_content = gen_mobile_tease_content ( county_list , num_of_cases ) [EOL] intro_content = gen_intro_content ( county_list , num_of_cases , target_scrape_day , scrape_end_datetime , yesterday_date ) [EOL] footer_content = gen_footer_content ( scrape_start_datetime , scrape_end_datetime , county_list ) [EOL] subject_line = create_subject_line ( target_scrape_day , scrape_end_date , yesterday_date , county_list ) [EOL] [EOL] [comment] [EOL] scraped_data_content = paths [ [string] ] . read_text ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] subject_line , mobile_tease_content = insert_special_message ( mobile_tease_content , subject_line ) [EOL] [comment] [EOL] [comment] [EOL] message = create_final_email_payload ( dirs [ [string] ] , mobile_tease_content , intro_content , scraped_data_content , footer_content , ) [EOL] [EOL] [comment] [EOL] export . save_copy_of_final_email ( paths [ [string] ] , message ) [EOL] [EOL] [comment] [EOL] recipients = json . loads ( os . environ . get ( [string] ) ) [EOL] login_to_gmail_and_send ( recipients , message , subject_line ) [EOL] [EOL] [EOL] def gen_mobile_tease_content ( county_list , num_of_cases ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] case_plural = [string] if num_of_cases == [number] else [string] [EOL] [EOL] [comment] [EOL] if len ( county_list ) == [number] : [EOL] mobile_tease_content = f"{ num_of_cases } [string] { case_plural } [string] " f" [string] { county_list [ [number] ] } [string] " [EOL] else : [EOL] mobile_tease_content = ( f"{ num_of_cases } [string] { case_plural } [string] " f" [string] { [string] . join ( county_list ) } [string] " ) [EOL] return mobile_tease_content [EOL] [EOL] [EOL] def gen_intro_content ( county_list , num_of_cases , target_scrape_day , scrape_end_datetime , yesterday_date , ) : [EOL] [docstring] [EOL] [EOL] formatted_date = scrape_end_datetime . strftime ( [string] ) [EOL] formatted_time = scrape_end_datetime . strftime ( [string] ) [EOL] [EOL] [comment] [EOL] if num_of_cases == [number] : [EOL] num_cases_text = [string] [EOL] elif num_of_cases == [number] : [EOL] num_cases_text = [string] [EOL] else : [EOL] num_cases_text = f" [string] { num_of_cases } [string] " f" [string] " [EOL] [EOL] [comment] [EOL] [comment] [EOL] if len ( county_list ) == [number] : [EOL] if target_scrape_day == [string] : [EOL] intro_description = f" [string] { num_cases_text } [string] " f" [string] { county_list [ [number] ] } [string] { formatted_date } [string] " f" [string] { formatted_time } [string] " [EOL] elif target_scrape_day == [string] : [EOL] intro_description = f" [string] { num_cases_text } [string] { county_list [ [number] ] } [string] " f" [string] { yesterday_date } [string] " [EOL] else : [EOL] if target_scrape_day == [string] : [EOL] intro_description = f" [string] { num_cases_text } [string] " f" [string] { formatted_date } [string] " f" [string] { formatted_time } [string] " [EOL] elif target_scrape_day == [string] : [EOL] intro_description = f" [string] { num_cases_text } [string] " f" [string] { yesterday_date } [string] "\ [EOL] [EOL] scrape_name = os . getenv ( [string] , [string] ) [EOL] intro_subheading = f' [string] { scrape_name } [string] ' [EOL] return intro_subheading + intro_description [EOL] [EOL] [EOL] def gen_footer_content ( scrape_start_datetime , scrape_end_datetime , county_list ) : [EOL] [EOL] [comment] [EOL] scrape_start_date = scrape_start_datetime . strftime ( [string] ) [EOL] scrape_start_time = scrape_start_datetime . strftime ( [string] ) [EOL] scrape_end_date = scrape_end_datetime . strftime ( [string] ) [EOL] scrape_end_time = scrape_end_datetime . strftime ( [string] ) [EOL] scrape_duration = int ( int ( time . mktime ( scrape_end_datetime . timetuple ( ) ) - time . mktime ( scrape_start_datetime . timetuple ( ) ) ) / [number] ) [EOL] duration_per_county = round ( scrape_duration / len ( county_list ) , [number] ) [EOL] [EOL] if scrape_start_datetime . date ( ) == scrape_end_datetime . date ( ) : [EOL] date_text = f"{ scrape_start_time } [string] { scrape_end_time } [string] { scrape_end_date }" [EOL] else : [EOL] date_text = f"{ scrape_start_time } [string] { scrape_start_date } [string] " f"{ scrape_end_time } [string] { scrape_end_date }" [EOL] [EOL] [comment] [EOL] return f" [string] { date_text } [string] " f" [string] " f" [string] { scrape_duration } [string] " f" [string] { duration_per_county } [string] " f" [string] " f" [string] " f" [string] " f" [string] " f" [string] " [EOL] [EOL] [EOL] def insert_special_message ( mobile_tease_content , subject_line ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] keyword_list = os . getenv ( [string] ) [EOL] if not keyword_list : [EOL] logging . info ( [string] [string] ) [EOL] return subject_line , mobile_tease_content [EOL] else : [EOL] keyword_list = json . loads ( keyword_list ) [EOL] logging . info ( f" [string] { keyword_list } [string] " ) [EOL] logging . info ( [string] [string] ) [EOL] [EOL] [comment] [EOL] if not paths [ [string] ] . is_file ( ) : [EOL] logging . info ( [string] [string] ) [EOL] return subject_line , mobile_tease_content [EOL] [EOL] [comment] [EOL] df = pd . read_csv ( paths [ [string] ] ) [EOL] keywords_found = [ ] [EOL] logging . info ( f" [string] " [string] ) [EOL] for keyword in keyword_list : [EOL] keyword_found = detect_keyword_in_df ( df , [string] , keyword ) [EOL] if keyword_found : [EOL] keywords_found . append ( keyword_found ) [EOL] if keywords_found : [EOL] special_msg = ( keywords_found [ [number] ] [EOL] if len ( keywords_found ) == [number] [EOL] else [string] [string] . join ( keywords_found ) ) [EOL] logging . info ( f" [string] { keyword_list } [string] " ) [EOL] logging . info ( f" [string] { special_msg }" ) [EOL] subject_line = subject_line + f" [string] { special_msg }" [EOL] mobile_tease_content = [string] + special_msg [EOL] else : [EOL] logging . info ( f" [string] { keyword_list } [string] " ) [EOL] return subject_line , mobile_tease_content [EOL] [EOL] [EOL] def create_final_email_payload ( dir_email_template , mobile_tease_content , intro_content , body_content , footer_content , ) : [EOL] [docstring] [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] component_list = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [comment] [EOL] parts = { } [EOL] for component in component_list : [EOL] path_to_component = dir_email_template / [string] . format ( component ) [EOL] parts [ component ] = path_to_component . read_text ( ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] mobile_tease = ( parts [ [string] ] + mobile_tease_content + parts [ [string] ] ) [EOL] html_top = ( parts [ [string] ] + parts [ [string] ] + mobile_tease + parts [ [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] intro_container_bottom = [string] [EOL] intro = ( parts [ [string] ] + parts [ [string] ] + intro_content + intro_container_bottom ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] email_body_bottom = [string] [EOL] email_body = parts [ [string] ] + body_content + email_body_bottom [EOL] [EOL] [comment] [EOL] [EOL] footer_bottom = [string] [EOL] html_bottom = [string] [EOL] footer = parts [ [string] ] + footer_content + footer_bottom + html_bottom [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] message = html_top + intro + email_body + footer [EOL] [EOL] logging . info ( [string] ) [EOL] return message [EOL] [EOL] [EOL] def create_subject_line ( target_scrape_date , formatted_date , yesterday_date , county_list , ) : [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] if len ( county_list ) == [number] : [EOL] if target_scrape_date == [string] : [EOL] subject = [string] . format ( county_list [ [number] ] , formatted_date ) [EOL] elif target_scrape_date == [string] : [EOL] subject = [string] . format ( county_list [ [number] ] , yesterday_date ) [EOL] else : [EOL] if target_scrape_date == [string] : [EOL] subject = [string] . format ( formatted_date ) [EOL] elif target_scrape_date == [string] : [EOL] subject = [string] . format ( yesterday_date ) [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] return subject [EOL] [EOL] [EOL] def login_to_gmail_and_send ( recipients , html_msg , subject_line , attachments = [ ] , ) : [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] mime_msg = MIMEMultipart ( ) [EOL] mime_msg . attach ( MIMEText ( html_msg , [string] ) ) [EOL] [EOL] [comment] [EOL] sender_email_username = os . environ . get ( [string] ) [EOL] sender_email_password = os . environ . get ( [string] ) [EOL] [EOL] [comment] [EOL] mime_msg [ [string] ] = f" [string] { sender_email_username } [string] " [EOL] mime_msg [ [string] ] = [string] . join ( recipients ) [EOL] mime_msg [ [string] ] = subject_line [EOL] [EOL] [comment] [EOL] if attachments : [EOL] logging . info ( f" [string] { attachments }" ) [EOL] for attachment_path in attachments : [EOL] with open ( attachment_path , [string] ) as attachment : [EOL] p = MIMEBase ( [string] , [string] ) [EOL] p . set_payload ( attachment . read ( ) ) [EOL] encoders . encode_base64 ( p ) [EOL] p . add_header ( [string] , f" [string] { attachment_path . name }" , ) [EOL] mime_msg . attach ( p ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] mime_msg = mime_msg . as_string ( ) [EOL] server = smtplib . SMTP ( [string] , [number] ) [EOL] server . starttls ( ) [EOL] server . login ( sender_email_username , sender_email_password ) [EOL] server . sendmail ( sender_email_username , recipients , mime_msg ) [EOL] server . quit ( ) [EOL] logging . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union , Tuple , Dict , Literal [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import numpy as np [EOL] [EOL] [EOL] table_style = [ { [string] : [string] , [string] : [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , } , { [string] : [string] , [string] : [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , } , ] [EOL] [EOL] table_attribs = [string] [EOL] [EOL] formats = { [string] : [string] } [EOL] [EOL] [EOL] def make_clickable ( val ) : [EOL] return [string] . format ( val , [string] ) [EOL] [EOL] [EOL] def currency_convert ( value ) : [EOL] [docstring] [EOL] if np . isnan ( value ) : [EOL] return [string] [EOL] else : [EOL] return [string] . format ( value ) [EOL] [EOL] [EOL] def highlight ( s ) : [EOL] color = [string] [EOL] return [string] % color [EOL] [EOL] [EOL] def color_negative_red ( val ) : [EOL] [docstring] [EOL] color = [string] if val == [number] else [string] [EOL] return [string] % color [EOL] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[typing.Tuple[builtins.str,builtins.str]],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Any , Optional [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import pandas as pd [EOL] import requests [EOL] import os [EOL] import logging [EOL] import json [EOL] [EOL] [comment] [EOL] from modules . misc import clean_df [EOL] from modules . email import email_error_notification [EOL] from locations import paths [EOL] [EOL] ERROR_SUMMARY = [string] [EOL] ABORTING_UPLOAD = [string] [EOL] [EOL] [EOL] def upload_to_rest_api ( ) : [EOL] [EOL] [comment] [EOL] rest_api = { [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , [string] : os . getenv ( [string] ) , } [EOL] [EOL] [comment] [EOL] for key , value in rest_api . items ( ) : [EOL] if value is None : [EOL] full_error = f" [string] { key } [string] " [EOL] logging . error ( full_error ) [EOL] email_error_notification ( ERROR_SUMMARY , full_error ) [EOL] logging . error ( ABORTING_UPLOAD ) [EOL] return [EOL] [EOL] logging . info ( f" [string] " f"{ rest_api [ [string] ] } [string] " ) [EOL] [EOL] [comment] [EOL] csv_payload_path = paths [ [string] ] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] logging . info ( [string] ) [EOL] df = pd . read_csv ( csv_payload_path , dtype = { [string] : str , [string] : str , [string] : str } ) [comment] [EOL] df = clean_df ( df ) [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] fields = os . getenv ( [string] , None ) [EOL] if fields : [EOL] fields = json . loads ( fields ) [EOL] fields = [ x . lower ( ) . replace ( [string] , [string] ) for x in fields ] [comment] [EOL] df = df [ fields ] [EOL] [EOL] [comment] [EOL] logging . info ( [string] ) [EOL] cases_json = df . to_dict ( orient = [string] ) [EOL] logging . debug ( cases_json ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with requests . Session ( ) as s : [EOL] try : [EOL] s = login ( s , rest_api ) [EOL] s = add_cases ( s , rest_api , cases_json ) [EOL] logout ( s , rest_api ) [EOL] except Exception as e : [EOL] logging . exception ( e ) [EOL] logging . error ( ABORTING_UPLOAD ) [EOL] email_error_notification ( ERROR_SUMMARY , e ) [EOL] return [EOL] [EOL] [comment] [EOL] logging . info ( [string] . format ( rest_api [ [string] ] ) ) [EOL] [EOL] [EOL] def login ( s , rest_api ) : [EOL] action = [string] [EOL] logging . info ( f"{ action } [string] " ) [EOL] login_data = { [string] : rest_api [ [string] ] , [string] : rest_api [ [string] ] } [EOL] full_login_path = rest_api [ [string] ] + rest_api [ [string] ] [EOL] [EOL] r = s . post ( full_login_path , json = login_data ) [EOL] data = r . json ( ) [EOL] status_code = r . status_code [EOL] [EOL] [comment] [EOL] [comment] [EOL] if status_code != [number] : [comment] [EOL] failure_output ( action , status_code , data ) [EOL] assert status_code == [number] , data [EOL] [EOL] [comment] [EOL] success_output ( action , data ) [EOL] [EOL] [comment] [EOL] logging . info ( [string] ) [EOL] access_token = data [ [string] ] [EOL] s . headers . update ( { [string] : f" [string] { access_token }" } ) [EOL] return s [EOL] [EOL] [EOL] def add_cases ( s , rest_api , json_data ) : [EOL] action = [string] [EOL] logging . info ( f"{ action } [string] " ) [EOL] full_post_path = rest_api [ [string] ] + rest_api [ [string] ] [EOL] r = s . post ( full_post_path , json = json_data ) [EOL] status_code = r . status_code [EOL] data = r . json ( ) [EOL] [EOL] [comment] [EOL] if status_code != [number] : [comment] [EOL] failure_output ( action , status_code , data ) [EOL] assert status_code == [number] , data [EOL] [EOL] [comment] [EOL] success_output ( action ) [EOL] return s [EOL] [EOL] [EOL] def logout ( s , rest_api ) : [EOL] action = [string] [EOL] logging . info ( f"{ action } [string] " ) [EOL] full_logout_path = rest_api [ [string] ] + rest_api [ [string] ] [EOL] r = s . post ( full_logout_path ) [EOL] status_code = r . status_code [EOL] data = r . json ( ) [EOL] [EOL] [comment] [EOL] if status_code != [number] : [comment] [EOL] failure_output ( action , status_code , data ) [EOL] assert status_code == [number] , data [EOL] [EOL] [comment] [EOL] success_output ( action , data ) [EOL] return s [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def failure_output ( action , status , data ) : [EOL] logging . error ( f" [string] { action }" ) [EOL] logging . error ( f" [string] { status } [string] { data }" ) [EOL] [EOL] [EOL] def success_output ( action , data = None ) : [EOL] logging . info ( f"{ action } [string] " ) [EOL] [EOL] if data : [EOL] logging . debug ( data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import time [EOL] import logging [EOL] [EOL] [comment] [EOL] from modules . misc import pdf_path_gen [EOL] from locations import dirs [EOL] [EOL] [EOL] def download_pdf ( driver , docket_url , docketnum ) : [EOL] [EOL] [comment] [EOL] path_downloaded_docket = ( dirs [ [string] ] / [string] ) [comment] [EOL] new_path_downloaded_docket = pdf_path_gen ( dirs [ [string] ] , docketnum ) [comment] [EOL] [EOL] [comment] [EOL] logging . info ( [string] . format ( docketnum ) ) [EOL] logging . info ( [string] . format ( docket_url ) ) [EOL] try : [EOL] driver . get ( docket_url ) [EOL] except Exception as e : [EOL] logging . error ( [string] ) [EOL] logging . exception ( e ) [EOL] driver . quit ( ) [EOL] raise [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] counter = [number] [EOL] cycles = [number] [EOL] sleep_interval = [number] [EOL] logging . info ( f" [string] { cycles * sleep_interval } [string] " f" [string] " ) [EOL] while counter < cycles and not path_downloaded_docket . is_file ( ) : [EOL] logging . debug ( f" [string] { counter } [string] { round ( ( counter * sleep_interval ) , [number] ) } [string] " ) [EOL] time . sleep ( sleep_interval ) [EOL] counter += [number] [EOL] if path_downloaded_docket . is_file ( ) : [EOL] logging . info ( [string] ) [EOL] else : [EOL] [comment] [EOL] logging . error ( [string] ) [EOL] driver . quit ( ) [EOL] raise [EOL] [EOL] [comment] [EOL] [comment] [EOL] logging . info ( [string] ) [EOL] logging . info ( [string] . format ( path_downloaded_docket ) ) [EOL] path_downloaded_docket . rename ( new_path_downloaded_docket ) [EOL] logging . info ( [string] . format ( new_path_downloaded_docket ) ) [EOL] return new_path_downloaded_docket [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import selenium [EOL] import typing [EOL] import pathlib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from selenium import webdriver [EOL] import os [EOL] import logging [EOL] from pathlib import Path [EOL] [EOL] [comment] [EOL] from locations import dirs [EOL] [EOL] [EOL] def initialize_driver ( ) : [EOL] [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] chrome_driver_path = Path ( os . environ . get ( [string] ) ) [EOL] logging . info ( f" [string] { chrome_driver_path }" ) [EOL] if not chrome_driver_path . is_file ( ) : [EOL] logging . error ( [string] ) [EOL] raise [EOL] [EOL] [comment] [EOL] download_path = str ( dirs [ [string] ] ) [comment] [EOL] logging . info ( f" [string] { download_path }" ) [EOL] logging . info ( [string] ) [EOL] [EOL] [comment] [EOL] options = webdriver . ChromeOptions ( ) [EOL] options . add_argument ( [string] ) [comment] [EOL] try : [EOL] driver = webdriver . Chrome ( executable_path = chrome_driver_path , options = options ) [comment] [EOL] except Exception as e : [EOL] logging . error ( [string] [string] ) [EOL] logging . exception ( e ) [EOL] raise [EOL] [EOL] [comment] [EOL] driver . command_executor . _commands [ [string] ] = ( [string] , [string] , ) [EOL] params = { [string] : [string] , [string] : { [string] : [string] , [string] : download_path } , } [EOL] command_result = driver . execute ( [string] , params ) [EOL] logging . info ( [string] ) [EOL] for key in command_result : [EOL] logging . info ( [string] + key + [string] + str ( command_result [ key ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] driver . implicitly_wait ( [number] ) [EOL] [EOL] logging . info ( [string] ) [EOL] return driver [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any , Optional [EOL] import typing [EOL] import logging [EOL] import logging . config [EOL] import os [EOL] import pathlib [EOL] import yaml [EOL] from locations import dirs , paths [EOL] [EOL] [EOL] def logs_config ( default_path = paths [ [string] ] , default_level = logging . INFO , env_key = [string] ) : [EOL] [EOL] [comment] [EOL] log_output = dirs [ [string] ] [EOL] [EOL] [docstring] [EOL] path = default_path [EOL] value = os . getenv ( env_key , None ) [comment] [EOL] if value : [EOL] path = value [EOL] if os . path . exists ( path ) : [EOL] with open ( path , [string] ) as f : [EOL] config = yaml . safe_load ( f . read ( ) ) [comment] [EOL] [comment] [EOL] for handler in config [ [string] ] : [EOL] if [string] in config [ [string] ] [ handler ] [ [string] ] : [EOL] config [ [string] ] [ handler ] [ [string] ] = ( log_output / config [ [string] ] [ handler ] [ [string] ] ) [EOL] config [ [string] ] [ handler ] [ [string] ] . parent . mkdir ( exist_ok = True , parents = True ) [comment] [EOL] [comment] [EOL] logging . config . dictConfig ( config ) [EOL] else : [EOL] logging . basicConfig ( level = default_level ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0