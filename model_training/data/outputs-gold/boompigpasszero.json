from typing import Any , List [EOL] import argparse [EOL] import typing [EOL] from argparse import ArgumentParser [EOL] import os [EOL] import random [EOL] [EOL] [EOL] DIRNAME = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] ANIMALS_FILE = os . path . join ( DIRNAME , [string] ) [EOL] ADJ_FILE = os . path . join ( DIRNAME , [string] ) [EOL] [EOL] [EOL] def replace_first_line ( fname , new_line ) : [EOL] with open ( fname ) as f : [EOL] lines = f . readlines ( ) [EOL] if len ( lines ) > [number] : [EOL] lines [ [number] ] = new_line + [string] ; [EOL] else : [EOL] lines . append ( new_line + [string] ) [EOL] with open ( fname , [string] ) as f : [EOL] for line in lines : [EOL] f . write ( line ) [EOL] [EOL] [EOL] def get_build_name ( animals , adj ) : [EOL] return [string] % ( random . choice ( adj ) , random . choice ( animals ) ) [EOL] [EOL] [EOL] def read_list ( fname ) : [EOL] l = [ ] [EOL] with open ( fname , [string] ) as f : [EOL] for line in f : [EOL] l . append ( line . strip ( ) ) [EOL] return l [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] animals = read_list ( ANIMALS_FILE ) [EOL] adj = read_list ( ADJ_FILE ) [EOL] build_name = get_build_name ( animals , adj ) [EOL] parser = ArgumentParser ( ) [EOL] parser . add_argument ( [string] ) [EOL] args = parser . parse_args ( ) [EOL] assert os . path . exists ( args . fname ) , [string] % args . fname [EOL] line = [string] % build_name [EOL] replace_first_line ( args . fname , line ) [EOL] print ( [string] % build_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Dict , Union , Literal , Optional , Match , List , Any , Pattern [EOL] import typing_extensions [EOL] import _ast [EOL] import argparse [EOL] import scripts [EOL] import typing [EOL] [docstring] [EOL] [EOL] import ast [EOL] [comment] [EOL] import json [EOL] import logging [EOL] import os [EOL] import re [EOL] from argparse import ArgumentParser [EOL] [EOL] import coloredlogs [EOL] from bs4 import BeautifulSoup [EOL] from rst_utils import parse_rst , get_bullet_list_children , has_child_with_tag [EOL] [EOL] class DocstringParseException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Function : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] [comment] [EOL] self . about = [string] [EOL] [comment] [EOL] [comment] [EOL] self . arguments = [ ] [EOL] [comment] [EOL] self . status_codes = { } [EOL] self . response = [ ] [EOL] [EOL] [comment] [EOL] self . routes = [ ] [EOL] self . http_methods = [ ] [EOL] self . requires_auth = False [EOL] self . requires_csrf_token = False [EOL] self . requires_jwt = False [EOL] [EOL] def add_argument ( self , arg_name , arg_type , is_required ) : [EOL] assert isinstance ( is_required , bool ) [EOL] self . arguments . append ( { [string] : arg_name , [string] : arg_type , [string] : is_required } ) [EOL] [EOL] def set_docstring ( self , docstring ) : [EOL] assert docstring is not None , self . name + [string] [EOL] [comment] [EOL] self . _parse_docstring_rst ( docstring ) [EOL] assert self . about != [string] [EOL] if self . status_codes == { } : [EOL] raise DocstringParseException ( [string] % self . name ) [EOL] if self . response == [ ] : [EOL] raise DocstringParseException ( [string] , self . name ) [EOL] [EOL] def _parse_param ( self , arg ) : [EOL] pattern = re . compile ( [string] ) [EOL] m = pattern . match ( arg ) [EOL] try : [EOL] arg_name = m . group ( [number] ) [EOL] arg_type = m . group ( [number] ) [EOL] is_required = m . group ( [number] ) == [string] [EOL] return { [string] : arg_name , [string] : arg_type , [string] : is_required } [EOL] except Exception as e : [EOL] print ( pattern ) [EOL] print ( arg ) [EOL] raise e [EOL] [EOL] def _parse_docstring_rst ( self , docstring ) : [EOL] [docstring] [EOL] doc = parse_rst ( docstring ) [EOL] for i , section in enumerate ( doc . children ) : [EOL] if i == [number] : [EOL] self . about = section . astext ( ) [EOL] elif section . tagname == [string] : [EOL] [comment] [EOL] title = [ c for c in section . children if c . tagname == [string] ] [ [number] ] . astext ( ) [EOL] if title == [string] : [EOL] if has_child_with_tag ( section , [string] ) : [EOL] for child in get_bullet_list_children ( section ) : [EOL] arg = self . _parse_param ( child . astext ( ) ) [EOL] self . add_argument ( arg [ [string] ] , arg [ [string] ] , arg [ [string] ] ) [EOL] elif title == [string] : [EOL] for child in get_bullet_list_children ( section ) : [EOL] arg = child . astext ( ) [EOL] head , tail = arg . split ( [string] , [number] ) [EOL] self . status_codes [ int ( head ) ] = tail [EOL] elif title == [string] : [EOL] l = [ c for c in section . children if c . tagname != [string] ] [EOL] for child in l : [EOL] if child . tagname == [string] : [EOL] self . response . append ( { [string] : [string] , [string] : child . astext ( ) } ) [EOL] elif child . tagname == [string] : [EOL] self . response . append ( { [string] : [string] , [string] : child . astext ( ) } ) [EOL] else : [EOL] print ( self . name ) [EOL] print ( child ) [EOL] raise Exception [EOL] [comment] [EOL] self . response . append ( child ) [EOL] else : [EOL] raise Exception [EOL] [EOL] [EOL] def parse_child_function ( child , api_method_annotation , is_api_method = False , api_doc_annotation = None ) : [EOL] [docstring] [EOL] fn = Function ( child . name ) [EOL] for decorator in child . decorator_list : [EOL] print ( decorator . id ) [EOL] if isinstance ( decorator , ast . Name ) : [EOL] [comment] [EOL] if decorator . id == [string] : [EOL] fn . requires_auth = True [EOL] elif decorator . id == [string] : [EOL] fn . requires_csrf_token = True [EOL] elif decorator . id == [string] : [EOL] fn . requires_jwt = True [EOL] elif decorator . id == api_doc_annotation : [EOL] raise AssertionError ( [string] ) [EOL] else : [EOL] raise Exception ( [string] % decorator . id ) [EOL] elif isinstance ( decorator , ast . Call ) : [EOL] if isinstance ( decorator . func , ast . Name ) : [EOL] if decorator . func . id == [string] : [EOL] [comment] [EOL] pass [EOL] elif decorator . id == api_doc_annotation : [EOL] raise AssertionError ( [string] ) [EOL] else : [EOL] raise Exception ( ) [EOL] elif isinstance ( decorator . func , ast . Attribute ) : [EOL] if decorator . func . value . id == api_method_annotation : [EOL] is_api_method = True [EOL] [comment] [EOL] assert len ( decorator . args ) == [number] [EOL] [comment] [EOL] fn . routes . append ( decorator . args [ [number] ] . s ) [EOL] assert len ( decorator . keywords ) == [number] [EOL] assert decorator . keywords [ [number] ] . arg == [string] [EOL] [comment] [EOL] l = decorator . keywords [ [number] ] . value [EOL] methods = [ x . s for x in l . elts ] [EOL] fn . http_methods = methods [EOL] elif decorator . id == api_doc_annotation : [EOL] raise AssertionError ( [string] ) [EOL] else : [EOL] [comment] [EOL] logging . debug ( [string] % fn . name ) [EOL] return None [EOL] else : [EOL] raise Exception ( ) [EOL] else : [EOL] raise Exception ( ) [EOL] if not is_api_method : [EOL] logging . debug ( [string] % fn . name ) [EOL] return None [EOL] print ( child . __dict__ ) [EOL] [comment] [EOL] [comment] [EOL] fn . set_docstring ( ast . get_docstring ( child ) ) [EOL] return fn [EOL] [EOL] class ApiParser : [EOL] def __init__ ( self , fname ) : [EOL] self . fname = fname [EOL] self . http_verbs = frozenset ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def parse_tree ( self , root , api_method_annotation ) : [EOL] [docstring] [EOL] f1 = self . parse_tree_functions ( root , api_method_annotation ) [EOL] f2 = self . parse_tree_class ( root ) [EOL] return f1 + f2 [EOL] [EOL] def parse_tree_class ( self , root , base_class = [string] , api_doc_annotation = [string] ) : [EOL] functions = [ ] [EOL] for child in ast . iter_child_nodes ( root ) : [EOL] if isinstance ( child , ast . ClassDef ) : [EOL] bases = [ base . id for base in child . bases ] [EOL] if base_class not in bases : [EOL] logging . warning ( [string] , child . name ) [EOL] continue [EOL] for fn in ast . iter_child_nodes ( child ) : [EOL] if not isinstance ( fn , ast . FunctionDef ) : [EOL] continue [EOL] if fn . name not in self . http_verbs : [EOL] logging . warning ( [string] , fn . name ) [EOL] continue [EOL] parsed_fn = parse_child_function ( fn , api_method_annotation = None , is_api_method = True , api_doc_annotation = api_doc_annotation ) [EOL] try : [EOL] assert parsed_fn is not None [EOL] except AssertionError as e : [EOL] logging . error ( [string] , fn . name ) [EOL] raise e [EOL] functions . append ( parsed_fn ) [EOL] return functions [EOL] [EOL] def parse_tree_functions ( self , root , api_method_annotation ) : [EOL] functions = [ ] [EOL] for child in ast . iter_child_nodes ( root ) : [EOL] if not isinstance ( child , ast . FunctionDef ) : [EOL] continue [EOL] if child . name == [string] : [EOL] logging . debug ( [string] ) [EOL] continue [EOL] try : [EOL] fn = parse_child_function ( child , api_method_annotation ) [EOL] except Exception as e : [EOL] logging . error ( [string] , child . name , self . fname ) [EOL] logging . error ( [string] , child . __dict__ ) [EOL] raise e [EOL] if fn is None : [EOL] continue [EOL] assert fn . routes != [ ] , [string] [EOL] functions . append ( fn ) [EOL] return functions [EOL] [EOL] [EOL] def is_parametrized_component ( item ) : [EOL] [comment] [EOL] return item in [ [string] , [string] ] [EOL] [EOL] [EOL] def generate_docs_for_function ( fn , expected_route_prefix ) : [EOL] [docstring] [EOL] html = [string] [EOL] [comment] [EOL] html += ( [string] ) [EOL] assert fn . routes [ - [number] ] . startswith ( expected_route_prefix ) , fn . routes [ - [number] ] [EOL] l = fn . routes [ - [number] ] . replace ( expected_route_prefix , [string] ) . split ( [string] ) [EOL] if is_parametrized_component ( l [ - [number] ] ) : [EOL] l [ - [number] ] = [string] [EOL] mangled_route = [string] . join ( l ) [EOL] internal_anchor = [string] . format ( method = fn . http_methods [ [number] ] . lower ( ) , mangled_route = mangled_route ) [EOL] http_method = fn . http_methods [ [number] ] . lower ( ) [EOL] uri = fn . routes [ - [number] ] [EOL] table = str . maketrans ( { [string] : [string] , [string] : [string] } ) [EOL] uri = uri . translate ( table ) [EOL] html += ( [string] . format ( internal_anchor = internal_anchor , http_method = http_method . upper ( ) , uri = uri ) ) [EOL] [EOL] html += ( [string] . format ( about = fn . about . rstrip ( ) ) ) [EOL] [EOL] html += ( [string] ) [EOL] if fn . arguments == [ ] and not fn . requires_csrf_token : [EOL] html += ( [string] ) [EOL] else : [EOL] [comment] [EOL] html += ( [string] ) [EOL] html += [string] [EOL] if fn . requires_csrf_token : [EOL] html += [string] [EOL] if fn . requires_csrf_token and fn . arguments != [ ] : [EOL] html += [string] [EOL] for arg in fn . arguments : [EOL] required_s = ( [string] if arg [ [string] ] else [string] ) [EOL] html += [string] . format ( name = arg [ [string] ] , val = [string] % ( arg [ [string] ] , required_s ) ) [EOL] [comment] [EOL] html = html [ : - [number] ] [EOL] html += [string] [EOL] html += ( [string] ) [EOL] [EOL] html += ( [string] ) [EOL] html += [string] [EOL] for block in fn . response : [EOL] if block [ [string] ] == [string] : [EOL] html += [string] . format ( text = block [ [string] ] ) [EOL] else : [EOL] code = block [ [string] ] . strip ( ) [EOL] html += [string] . format ( code = code ) [EOL] html += [string] [EOL] [EOL] html += ( [string] ) [EOL] html += ( [string] ) [EOL] for status_code in sorted ( fn . status_codes ) : [EOL] html += [string] . format ( code = status_code , s = fn . status_codes [ status_code ] ) [EOL] html += ( [string] ) [EOL] [EOL] html += ( [string] ) [EOL] [EOL] soup = BeautifulSoup ( html , [string] ) [EOL] return soup [EOL] [comment] [EOL] [EOL] [EOL] def get_internal_anchor_for_function ( fn , expected_route_prefix ) : [EOL] assert expected_route_prefix . endswith ( [string] ) [EOL] assert fn . routes [ - [number] ] . startswith ( expected_route_prefix ) , fn . routes [ - [number] ] [EOL] l = fn . routes [ - [number] ] . replace ( expected_route_prefix , [string] ) . split ( [string] ) [EOL] if is_parametrized_component ( l [ - [number] ] ) : [EOL] l [ - [number] ] = [string] [EOL] mangled_route = [string] . join ( l ) [EOL] internal_anchor = [string] . format ( method = fn . http_methods [ [number] ] . lower ( ) , mangled_route = mangled_route ) [EOL] return [string] + internal_anchor [EOL] [EOL] [EOL] def filename_from_function ( fn , expected_route_prefix ) : [EOL] assert expected_route_prefix . endswith ( [string] ) [EOL] assert fn . routes [ - [number] ] . startswith ( expected_route_prefix ) , fn . routes [ - [number] ] [EOL] l = fn . routes [ - [number] ] . replace ( expected_route_prefix , [string] ) . split ( [string] ) [EOL] if is_parametrized_component ( l [ - [number] ] ) : [EOL] l [ - [number] ] = [string] [EOL] mangled_route = [string] . join ( l ) [EOL] internal_anchor = [string] . format ( method = fn . http_methods [ [number] ] . lower ( ) , mangled_route = mangled_route ) [EOL] return internal_anchor + [string] [EOL] [EOL] [EOL] def generate_method_table ( functions , expected_route_prefix ) : [EOL] rows = [ ] [EOL] glyphs = { True : [string] , False : [string] } [EOL] for function in sorted ( functions , key = lambda fn : fn . routes [ - [number] ] ) : [EOL] trans_table = str . maketrans ( { [string] : [string] , [string] : [string] } ) [EOL] route = function . routes [ - [number] ] . translate ( trans_table ) [EOL] row = [string] . format ( internal_anchor = get_internal_anchor_for_function ( function , expected_route_prefix ) , method = function . http_methods [ [number] ] , route = route , about = function . about , requires_login_glyph = glyphs [ function . requires_auth ] , requires_csrf_token_glyph = glyphs [ function . requires_csrf_token ] ) [EOL] rows . append ( row ) [EOL] template = [string] . format ( body = [string] . join ( rows ) ) [EOL] return BeautifulSoup ( template , [string] ) [EOL] [EOL] [EOL] def write_method_table ( method_table_soup , output_folder ) : [EOL] fname = os . path . join ( output_folder , [string] ) [EOL] with open ( fname , [string] ) as fp : [EOL] fp . write ( method_table_soup . prettify ( ) ) [EOL] logging . info ( [string] % fname ) [EOL] [EOL] [EOL] def write_function_docs_html ( fn , expected_route_prefix , output_folder ) : [EOL] function_soup = generate_docs_for_function ( fn , expected_route_prefix ) [EOL] fname = os . path . join ( output_folder , filename_from_function ( fn , expected_route_prefix ) ) [EOL] with open ( fname , [string] ) as fp : [EOL] fp . write ( function_soup . prettify ( ) ) [EOL] logging . info ( [string] + fname ) [EOL] [EOL] [EOL] def write_function_docs_json ( functions , expected_route_prefix , output_fname ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] swagger = { [string] : [string] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : { } , } [EOL] for fn in functions : [EOL] for route in fn . routes : [EOL] if route not in swagger [ [string] ] : [EOL] swagger [ [string] ] [ route ] = { } [EOL] for method in fn . http_methods : [EOL] method = method . lower ( ) [EOL] if method in swagger [ [string] ] [ route ] : [EOL] logging . error ( [string] , route , method ) [EOL] logging . error ( swagger [ [string] ] [ route ] ) [EOL] raise AssertionError ( [string] ) [EOL] [comment] [EOL] swagger_fn = { [string] : fn . about . strip ( ) , [string] : fn . arguments , [string] : { } } [EOL] if fn . requires_csrf_token : [EOL] swagger_fn [ [string] ] . append ( { [string] : [string] , [string] : [string] , [string] : True } ) [EOL] on_success_index = None [EOL] on_error_index = None [EOL] for i , block in enumerate ( fn . response ) : [EOL] if block [ [string] ] . startswith ( [string] ) : [EOL] on_success_index = i [EOL] elif block [ [string] ] . startswith ( [string] ) : [EOL] on_error_index = i [EOL] for code , description in fn . status_codes . items ( ) : [EOL] response_obj = { [string] : description . strip ( ) , } [EOL] if code == [number] : [EOL] if on_success_index is None : [EOL] content_arr = fn . response [EOL] else : [EOL] if fn . response [ on_success_index ] [ [string] ] == [string] : [EOL] on_success_index += [number] [EOL] content_arr = fn . response [ on_success_index : on_error_index ] [EOL] else : [EOL] if on_error_index is None : [EOL] [comment] [EOL] content_arr = [ ] [EOL] else : [EOL] if len ( fn . response ) == [number] : [EOL] content_arr = fn . response [EOL] else : [EOL] assert on_error_index > on_success_index [EOL] if fn . response [ on_error_index ] [ [string] ] == [string] : [EOL] on_error_index += [number] [EOL] content_arr = fn . response [ on_error_index : ] [EOL] [EOL] if content_arr == [ ] : [EOL] pass [EOL] elif len ( content_arr ) == [number] : [EOL] if content_arr [ [number] ] [ [string] ] == [string] : [EOL] [comment] [EOL] response_obj [ [string] ] = content_arr [ [number] ] [ [string] ] . strip ( ) . replace ( [string] , [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] response_obj [ [string] ] = content_arr [ [number] ] [ [string] ] . strip ( ) [EOL] else : [EOL] response_obj [ [string] ] = content_arr [EOL] swagger_fn [ [string] ] [ code ] = response_obj [EOL] [EOL] [comment] [EOL] swagger [ [string] ] [ route ] [ method ] = swagger_fn [EOL] with open ( output_fname , [string] ) as fp : [EOL] json . dump ( swagger , fp , indent = [number] , sort_keys = True ) [EOL] logging . debug ( [string] , output_fname ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] parser . add_argument ( [string] , choices = [ [string] , [string] ] , default = [string] , help = [string] + [string] + [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] logging . basicConfig ( level = logging . DEBUG , format = [string] ) [EOL] coloredlogs . install ( level = logging . DEBUG ) [EOL] [EOL] assert args . route_prefix . endswith ( [string] ) [EOL] with open ( args . fname ) as fp : [EOL] contents = fp . read ( ) [EOL] root = ast . parse ( contents ) [EOL] api_parser = ApiParser ( args . fname ) [EOL] functions = api_parser . parse_tree ( root , args . api_method_annotation ) [EOL] if args . output_format == [string] : [EOL] [comment] [EOL] soup = generate_method_table ( functions , args . route_prefix ) [EOL] write_method_table ( soup , args . dest ) [EOL] [EOL] [comment] [EOL] [EOL] for fn in sorted ( functions , key = lambda fn : fn . routes [ - [number] ] ) : [EOL] try : [EOL] write_function_docs_html ( fn , args . route_prefix , args . dest ) [EOL] except Exception as e : [EOL] logging . error ( [string] , fn . name ) [EOL] raise e [EOL] else : [EOL] write_function_docs_json ( functions , args . route_prefix , args . dest + [string] + args . api_method_annotation + [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $_ast.Module$ 0 0 0 0 0 $builtins.str$ 0 0 $scripts.api_doc_builder.create_api_docs.ApiParser$ 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.Any$ 0 $scripts.api_doc_builder.create_api_docs.ApiParser$ 0 0 0 $_ast.Module$ 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from parsimonious . grammar import Grammar [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] grammar = Grammar ( [string] ) [EOL] [EOL] code_block = [string] [EOL] [docstring] [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] result = grammar . parse ( code_block ) [EOL] print ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0
from typing import Optional , Match , List , Any , Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] import logging [EOL] import re [EOL] [EOL] from enum import Enum , unique [EOL] [EOL] [EOL] def parse_docstring ( docstring ) : [EOL] [docstring] [EOL] [EOL] @ unique class State ( Enum ) : [EOL] INSIDE_ABOUT = [number] [EOL] EXPECT_SECTION_HEADER = [number] [EOL] INSIDE_ARGUMENTS = [number] [EOL] INSIDE_RESPONSE = [number] [EOL] INSIDE_STATUS_CODES = [number] [EOL] INSIDE_RESPONSE_CODE = [number] [EOL] [EOL] valid_section_headers = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] state = State . INSIDE_ABOUT [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] for i , line in enumerate ( docstring . split ( [string] ) ) : [EOL] [comment] [EOL] while line . startswith ( [string] * [number] ) : [EOL] line = line . replace ( [string] * [number] , [string] , [number] ) [EOL] [comment] [EOL] indentation_level = [number] [EOL] for c in line : [EOL] if c == [string] : [EOL] indentation_level += [number] [EOL] else : [EOL] break [EOL] if indentation_level == [number] and state not in [ State . INSIDE_ABOUT , State . EXPECT_SECTION_HEADER ] \ [EOL] and line != [string] : [EOL] state = State . EXPECT_SECTION_HEADER [EOL] [EOL] if state == State . INSIDE_ABOUT : [EOL] if line . strip ( ) == [string] : [EOL] state = State . EXPECT_SECTION_HEADER [EOL] else : [EOL] self . about += line + [string] [EOL] elif state == State . EXPECT_SECTION_HEADER : [EOL] try : [EOL] assert line . rstrip ( ) . endswith ( [string] ) [EOL] except AssertionError as e : [EOL] logging . error ( [string] , self . name ) [EOL] logging . error ( [string] , line , i ) [EOL] raise SystemExit ( [number] ) [EOL] section_name = line . strip ( ) . rstrip ( [string] ) [EOL] assert section_name in valid_section_headers , [string] % section_name [EOL] if section_name == [string] : [EOL] state = State . INSIDE_ARGUMENTS [EOL] elif section_name == [string] : [EOL] state = State . INSIDE_STATUS_CODES [EOL] elif section_name == [string] : [EOL] state = State . INSIDE_RESPONSE [EOL] elif state == State . INSIDE_ARGUMENTS : [EOL] if line . strip ( ) == [string] : [EOL] state = State . EXPECT_SECTION_HEADER [EOL] continue [EOL] if not line . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] arg = line . lstrip ( ) . lstrip ( [string] ) [EOL] pattern = re . compile ( [string] ) [EOL] m = pattern . match ( arg ) [EOL] try : [EOL] arg_name = m . group ( [number] ) [EOL] arg_type = m . group ( [number] ) [EOL] required = m . group ( [number] ) == [string] [EOL] self . add_argument ( arg_name , arg_type , required ) [EOL] except Exception as e : [EOL] print ( pattern ) [EOL] print ( arg ) [EOL] raise e [EOL] elif state == State . INSIDE_STATUS_CODES : [EOL] if line . strip ( ) == [string] : [EOL] state = State . EXPECT_SECTION_HEADER [EOL] continue [EOL] if not line . lstrip ( ) . startswith ( [string] ) : [EOL] continue [EOL] arg = line . lstrip ( ) . lstrip ( [string] ) [EOL] head , tail = arg . split ( [string] , [number] ) [EOL] status_code = int ( head ) [EOL] self . status_codes [ status_code ] = tail [EOL] elif state == State . INSIDE_RESPONSE : [EOL] if line . strip ( ) == [string] : [EOL] [comment] [EOL] [comment] [EOL] continue [EOL] l = line . strip ( ) [EOL] if l == [string] : [EOL] state = State . INSIDE_RESPONSE_CODE [EOL] self . response . append ( { [string] : [string] , [string] : [string] } ) [EOL] continue [EOL] m = re . match ( [string] , l ) [EOL] if m : [EOL] self . response . append ( { [string] : [string] , [string] : m . group ( [number] ) } ) [EOL] continue [EOL] [comment] [EOL] if self . response == [ ] or self . response [ - [number] ] [ [string] ] == [string] : [EOL] self . response . append ( { [string] : [string] , [string] : [string] } ) [EOL] self . response [ - [number] ] [ [string] ] += line . lstrip ( ) + [string] [EOL] elif state == State . INSIDE_RESPONSE_CODE : [EOL] l = line . strip ( ) [EOL] if l == [string] : [EOL] state = State . INSIDE_RESPONSE [EOL] continue [EOL] else : [EOL] assert self . response [ - [number] ] [ [string] ] == [string] [EOL] self . response [ - [number] ] [ [string] ] += line . lstrip ( ) + [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from passzero . api import api [EOL] from flask import json [EOL] [EOL] print ( json . dumps ( api . __schema__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import docutils . parsers . rst [EOL] import docutils [EOL] import logging [EOL] [EOL] [EOL] def parse_rst ( text ) : [EOL] parser = docutils . parsers . rst . Parser ( ) [EOL] components = ( docutils . parsers . rst . Parser , ) [EOL] settings = docutils . frontend . OptionParser ( components = components ) . get_default_values ( ) [EOL] document = docutils . utils . new_document ( [string] , settings = settings ) [EOL] parser . parse ( text , document ) [EOL] return document [EOL] [EOL] [EOL] def get_bullet_list_children ( node ) : [EOL] l = [ c for c in node . children if c . tagname == [string] ] [EOL] if l == [ ] : [EOL] logging . error ( [string] ) [EOL] logging . error ( [string] , str ( node ) ) [EOL] raise AssertionError [EOL] return l [ [number] ] . children [EOL] [EOL] [EOL] def has_child_with_tag ( node , tag ) : [EOL] return tag in [ c . tagname for c in node . children ] [EOL] [EOL] [EOL] def get_text_child ( node ) : [EOL] i = node . first_child_matching_class ( docutils . nodes . TextElement ) [EOL] return node . children [ i ] [EOL] [EOL] [EOL] def get_bullet_list_item_text ( node ) : [EOL] i = node . first_child_matching_class ( docutils . nodes . TextElement ) [EOL] text_elem = node . children [ i ] [EOL] return text_elem . astext ( ) [EOL] [EOL] [EOL] def get_section_title ( section ) : [EOL] title = [ c for c in section . children if c . tagname == [string] ] [ [number] ] . astext ( ) [EOL] return title [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import sys [EOL] from bs4 import BeautifulSoup [EOL] [EOL] def compare ( ) : [EOL] l = [ ] [EOL] for arg in sys . argv [ [number] : ] : [EOL] with open ( arg ) as fp : [EOL] contents = fp . read ( ) [EOL] soup = BeautifulSoup ( contents , [string] ) [EOL] l . append ( soup ) [EOL] [EOL] assert l [ [number] ] . prettify ( ) == l [ [number] ] . prettify ( ) [EOL] [EOL] def bs_prettify ( ) : [EOL] with open ( sys . argv [ [number] ] ) as fp : [EOL] contents = fp . read ( ) [EOL] soup = BeautifulSoup ( contents , [string] ) [EOL] print ( soup . prettify ( ) ) [EOL] [EOL] bs_prettify ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Match , List , Any , Pattern [EOL] import argparse [EOL] import builtins [EOL] import scripts [EOL] import typing [EOL] [docstring] [EOL] [EOL] import logging [EOL] import re [EOL] from argparse import ArgumentParser [EOL] from pprint import pprint [EOL] [EOL] import coloredlogs [EOL] import docutils [EOL] import yaml [EOL] [EOL] from rst_utils import ( get_bullet_list_children , get_bullet_list_item_text , get_text_child , has_child_with_tag , parse_rst , get_section_title ) [EOL] [EOL] [EOL] class ParsedDoc : [EOL] def __init__ ( self ) : [EOL] self . summary = None [EOL] self . parameters = [ ] [EOL] self . response = [ ] [EOL] self . status_codes = { } [EOL] [EOL] def add_parameter ( self , name , type , is_required , subtypes = None ) : [EOL] if subtypes : [EOL] self . parameters . append ( { [string] : name , [string] : type , [string] : is_required , [string] : subtypes } ) [EOL] else : [EOL] self . parameters . append ( { [string] : name , [string] : type , [string] : is_required } ) [EOL] [EOL] def add_response ( self , type , val , tag = None ) : [EOL] if tag : [EOL] self . response . append ( { [string] : type , [string] : val , [string] : tag } ) [EOL] else : [EOL] self . response . append ( { [string] : type , [string] : val } ) [EOL] [EOL] def add_status_code ( self , status_code , description ) : [EOL] assert status_code not in self . status_codes [EOL] self . status_codes [ status_code ] = description [EOL] [EOL] [EOL] def parse_param ( arg ) : [EOL] pattern = re . compile ( [string] ) [EOL] m = pattern . match ( arg ) [EOL] try : [EOL] arg_name = m . group ( [number] ) [EOL] arg_type = m . group ( [number] ) [EOL] is_required = m . group ( [number] ) == [string] [EOL] return { [string] : arg_name , [string] : arg_type , [string] : is_required } [EOL] except Exception as e : [EOL] print ( [string] ) [EOL] print ( pattern ) [EOL] print ( [string] ) [EOL] print ( arg ) [EOL] print ( [string] ) [EOL] raise e [EOL] [EOL] [EOL] def parse_rst_docstring_response ( node , parsed_doc , tag = None ) : [EOL] l = [ c for c in node . children if c . tagname != [string] ] [EOL] for child in l : [EOL] if child . tagname == [string] : [EOL] parsed_doc . add_response ( type = [string] , val = child . astext ( ) , tag = tag ) [EOL] elif child . tagname == [string] : [EOL] parsed_doc . add_response ( type = [string] , val = child . astext ( ) , tag = tag ) [EOL] elif child . tagname == [string] : [EOL] parse_rst_docstring_response ( child , parsed_doc , tag = get_section_title ( child ) ) [EOL] else : [EOL] print ( child ) [EOL] raise Exception [EOL] [EOL] [EOL] def parse_docstring_rst ( docstring , http_method , route ) : [EOL] [docstring] [EOL] doc = parse_rst ( docstring ) [EOL] parsed_doc = ParsedDoc ( ) [EOL] logging . debug ( [string] . format ( method = http_method , route = route ) ) [EOL] for i , section in enumerate ( doc . children ) : [EOL] if section . tagname == [string] : [EOL] [comment] [EOL] title = get_section_title ( section ) [EOL] if title == [string] : [EOL] if has_child_with_tag ( section , [string] ) : [EOL] for child in get_bullet_list_children ( section ) : [EOL] [comment] [EOL] if has_child_with_tag ( child , [string] ) : [EOL] l = [ ] [EOL] for subchild in get_bullet_list_children ( child ) : [EOL] arg = parse_param ( get_bullet_list_item_text ( subchild ) ) [EOL] d = { [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : arg [ [string] ] } [EOL] l . append ( d ) [EOL] arg = parse_param ( get_bullet_list_item_text ( child ) ) [EOL] parsed_doc . add_parameter ( name = arg [ [string] ] , type = arg [ [string] ] , is_required = arg [ [string] ] , subtypes = l ) [EOL] else : [EOL] arg = parse_param ( child . astext ( ) ) [EOL] parsed_doc . add_parameter ( name = arg [ [string] ] , type = arg [ [string] ] , is_required = arg [ [string] ] ) [EOL] else : [EOL] logging . debug ( [string] . format ( method = http_method , route = route ) ) [EOL] elif title == [string] : [EOL] for child in get_bullet_list_children ( section ) : [EOL] arg = child . astext ( ) [EOL] head , tail = arg . split ( [string] , [number] ) [EOL] parsed_doc . add_status_code ( int ( head ) , tail ) [EOL] elif title == [string] : [EOL] parse_rst_docstring_response ( section , parsed_doc ) [EOL] elif title == [string] : [EOL] [comment] [EOL] child = get_text_child ( section ) [EOL] parsed_doc . authentication = child . astext ( ) [EOL] else : [EOL] logging . error ( [string] , title ) [EOL] raise Exception [EOL] else : [EOL] if isinstance ( section , docutils . nodes . TextElement ) : [EOL] parsed_doc . summary = section . astext ( ) [EOL] return parsed_doc [EOL] [EOL] [EOL] def docs_from_swagger_file ( fname ) : [EOL] with open ( fname ) as fp : [EOL] swagger_conf = yaml . load ( fp ) [EOL] for path in swagger_conf [ [string] ] : [EOL] [comment] [EOL] for method , method_conf in swagger_conf [ [string] ] [ path ] . items ( ) : [EOL] if method == [string] : [EOL] continue [EOL] try : [EOL] description = method_conf [ [string] ] [EOL] except Exception as e : [EOL] print ( method_conf ) [EOL] raise e [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] parsed_description = parse_docstring_rst ( description , method , path ) [EOL] pprint ( parsed_description . __dict__ ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = ArgumentParser ( ) [EOL] parser . add_argument ( [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] logging . basicConfig ( level = logging . DEBUG ) [EOL] coloredlogs . install ( level = logging . DEBUG ) [EOL] docs_from_swagger_file ( args . filename ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import json [EOL] from typing import Dict [EOL] import copy [EOL] json_header = { [string] : [string] } [EOL] import requests [EOL] [EOL] requests . packages . urllib3 . disable_warnings ( ) [EOL] [EOL] [comment] [EOL] BASE_URL = [string] [EOL] [EOL] def login ( app , email , password , check_status = True ) : [EOL] data = { [string] : email , [string] : password } [EOL] r = app . post ( BASE_URL + [string] , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] if check_status : [EOL] assert r . status_code == [number] [EOL] return r [EOL] [EOL] [EOL] def logout ( app ) : [EOL] return app . post ( BASE_URL + [string] , headers = json_header , allow_redirects = True ) [EOL] [EOL] [EOL] def get_csrf_token ( app ) : [EOL] r = app . get ( BASE_URL + [string] , headers = json_header , allow_redirects = True ) [EOL] assert r . status_code == [number] [EOL] token = json . loads ( r . text ) [EOL] [comment] [EOL] return token [EOL] [EOL] [EOL] def get_entries ( app , check_status = True ) : [EOL] r = app . get ( BASE_URL + [string] , headers = json_header , allow_redirects = True ) [EOL] if check_status : [EOL] assert r . status_code == [number] [EOL] return json . loads ( r . text ) [EOL] else : [EOL] return r [EOL] [EOL] [EOL] def create_entry ( app , entry , token , check_status = True ) : [EOL] [docstring] [EOL] data = entry [EOL] data [ [string] ] = token [EOL] r = app . post ( BASE_URL + [string] , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] if check_status : [EOL] [comment] [EOL] assert r . status_code == [number] [EOL] return json . loads ( r . text ) [ [string] ] [EOL] else : [EOL] return r [EOL] [EOL] [EOL] def delete_entry ( app , entry_id , token ) : [EOL] url = BASE_URL + [string] . format ( entry_id , token ) [EOL] r = app . delete ( url , headers = json_header , allow_redirects = True ) [EOL] [comment] [EOL] assert r . status_code == [number] [EOL] return r [EOL] [EOL] [EOL] def edit_entry ( app , entry_id , entry , token ) : [EOL] url = BASE_URL + [string] . format ( entry_id ) [EOL] data = entry [EOL] data [ [string] ] = token [EOL] return app . post ( BASE_URL + url , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] [EOL] [EOL] def signup ( app , email , password ) : [EOL] url = BASE_URL + [string] [EOL] data = { [string] : email , [string] : password , [string] : password } [EOL] return app . post ( BASE_URL + url , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] [EOL] [EOL] def recover_account ( app , email , csrf_token ) : [EOL] url = BASE_URL + [string] [EOL] data = { [string] : email , [string] : csrf_token } [EOL] r = app . post ( BASE_URL + url , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] print ( r . text ) [EOL] assert r . status_code == [number] [EOL] return r [EOL] [EOL] [EOL] def recover_account_confirm ( app , password , recovery_token , csrf_token ) : [EOL] url = BASE_URL + [string] [EOL] data = { [string] : password , [string] : password , [string] : csrf_token , [string] : recovery_token } [EOL] r = app . post ( BASE_URL + url , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] print ( r . text ) [EOL] assert r . status_code == [number] [EOL] return r [EOL] [EOL] [EOL] def activate_account ( app , token ) : [EOL] return app . post ( BASE_URL + [string] , data = json . dumps ( { [string] : token } ) , headers = json_header , allow_redirects = True ) [EOL] [EOL] [EOL] def update_user_password ( app , old_password , new_password , csrf_token , check_status = True ) : [EOL] url = BASE_URL + [string] [EOL] data = { [string] : csrf_token , [string] : old_password , [string] : new_password , [string] : new_password } [EOL] r = app . put ( url , data = json . dumps ( data ) , headers = json_header , allow_redirects = True ) [EOL] if check_status : [EOL] print ( r . text ) [EOL] assert r . status_code == [number] [EOL] return r [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def get_json ( app , url ) : [EOL] return app . get ( url , headers = json_header , allow_redirects = True ) [EOL] [EOL] [EOL] def json_header_with_token ( token ) : [EOL] assert token is not None [EOL] h = copy . copy ( json_header ) [EOL] h [ [string] ] = [string] % token [EOL] return h [EOL] [EOL] [EOL] def json_post ( session , relative_url , data = { } , token = None ) : [EOL] if token : [EOL] headers = json_header_with_token ( token ) [EOL] else : [EOL] headers = json_header [EOL] return session . post ( BASE_URL + relative_url , data = json . dumps ( data ) , headers = headers , verify = False ) [EOL] [EOL] [EOL] def json_get ( session , relative_url , token = None ) : [EOL] if token : [EOL] headers = json_header_with_token ( token ) [EOL] else : [EOL] headers = json_header [EOL] return session . get ( BASE_URL + relative_url , headers = headers , verify = False ) [EOL] [EOL] [EOL] def get_entries_v2 ( app ) : [EOL] r = get_json ( app , BASE_URL + [string] ) [EOL] assert r . status_code == [number] [EOL] [comment] [EOL] return json . loads ( r . text ) [EOL] [EOL] [EOL] def get_entry_v2 ( app , entry_id , check_status = True ) : [EOL] r = get_json ( app , BASE_URL + [string] . format ( entry_id ) ) [EOL] if check_status : [EOL] [comment] [EOL] assert r . status_code == [number] [EOL] return json . loads ( r . text ) [EOL] else : [EOL] return r [EOL] [EOL] [comment] [EOL] [EOL] def login_with_token ( app , email , password , check_status = True ) : [EOL] r = json_post ( app , [string] , data = { [string] : email , [string] : password } ) [EOL] if check_status : [EOL] assert r . status_code == [number] [EOL] return r . json ( ) [ [string] ] [EOL] else : [EOL] return r [EOL] [EOL] [EOL] def get_encrypted_entries_with_token ( app , token , check_status = True ) : [EOL] r = json_get ( app , [string] , token = token ) [EOL] if check_status : [EOL] assert r . status_code == [number] [EOL] return r . json ( ) [EOL] else : [EOL] return r [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] import logging [EOL] import os [EOL] import sys [EOL] [EOL] import sendgrid [EOL] import six [EOL] from flask import request [EOL] from sendgrid . helpers . mail import Mail [EOL] [EOL] [EOL] def send_email_sendgrid ( to_email , subject , msg ) : [EOL] [docstring] [EOL] assert isinstance ( to_email , six . text_type ) [EOL] assert isinstance ( subject , six . text_type ) [EOL] assert isinstance ( msg , six . text_type ) [EOL] try : [EOL] assert os . environ . get ( [string] , None ) [EOL] except AssertionError : [EOL] print ( [string] , file = sys . stderr ) [EOL] return False [EOL] try : [EOL] sg = sendgrid . SendGridAPIClient ( os . environ [ [string] ] ) [EOL] from_email = [string] [EOL] message = Mail ( from_email = from_email , subject = subject , to_emails = to_email , plain_text_content = msg ) [EOL] response = sg . send ( message ) [EOL] except Exception as e : [EOL] logging . error ( [string] ) [EOL] logging . error ( str ( e ) ) [EOL] return False [EOL] if response . status_code in [ [number] , [number] ] : [EOL] return True [EOL] else : [EOL] [comment] [EOL] logging . error ( [string] , response . status_code ) [EOL] logging . error ( [string] , response . body ) [EOL] logging . error ( [string] , str ( response . headers ) ) [EOL] return False [EOL] [EOL] [EOL] def send_email ( email , subject , msg ) : [EOL] return send_email_sendgrid ( email , subject , msg ) [EOL] [EOL] [EOL] def send_recovery_email ( email , token ) : [EOL] link = request . url_root + [string] % token [EOL] return send_email ( email , [string] , [string] % link ) [EOL] [EOL] [EOL] def send_confirmation_email ( email , token ) : [EOL] link = request . url_root + [string] % token [EOL] return send_email ( email , [string] , [string] % link ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import passzero [EOL] import typing [EOL] from flask_wtf import FlaskForm [EOL] from flask_wtf . file import FileField , FileRequired [EOL] from wtforms import BooleanField , Form , PasswordField , StringField , validators , IntegerField [EOL] [EOL] from passzero . limits import MAX_ENTRY_PASSWORD_LENGTH , MAX_GEN_PASSPHRASE_WORDS [EOL] [EOL] [EOL] class SignupForm ( Form ) : [EOL] email = StringField ( [string] , [ validators . DataRequired ( ) , validators . Email ( ) ] ) [EOL] password = PasswordField ( [string] , [ validators . DataRequired ( ) , validators . EqualTo ( [string] , message = [string] ) ] ) [EOL] confirm_password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class LoginForm ( Form ) : [EOL] email = StringField ( [string] , [ validators . DataRequired ( ) , validators . Email ( ) ] ) [EOL] password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class DeleteUserForm ( Form ) : [EOL] password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class NewEntryForm ( Form ) : [EOL] account = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] username = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] password = PasswordField ( [string] , [ validators . DataRequired ( ) , validators . Length ( max = MAX_ENTRY_PASSWORD_LENGTH ) ] ) [EOL] extra = StringField ( [string] ) [EOL] has_2fa = BooleanField ( [string] , [ validators . AnyOf ( [ True , False ] ) ] ) [EOL] [EOL] [EOL] class UpdatePasswordForm ( Form ) : [EOL] old_password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] new_password = PasswordField ( [string] , [ validators . DataRequired ( ) , validators . EqualTo ( [string] , message = [string] ) ] ) [EOL] confirm_new_password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class RecoverPasswordForm ( Form ) : [EOL] email = StringField ( [string] , [ validators . DataRequired ( ) , validators . Email ( ) ] ) [EOL] [EOL] [EOL] class UpdatePreferencesForm ( Form ) : [EOL] default_random_password_length = IntegerField ( [string] , [ validators . Optional ( ) , validators . NumberRange ( [number] , MAX_ENTRY_PASSWORD_LENGTH ) , ] ) [EOL] default_random_passphrase_length = IntegerField ( [string] , [ validators . Optional ( ) , validators . NumberRange ( [number] , MAX_GEN_PASSPHRASE_WORDS ) , ] ) [EOL] [EOL] [EOL] class ActivateAccountForm ( Form ) : [EOL] token = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class ConfirmRecoverPasswordForm ( Form ) : [EOL] token = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] password = PasswordField ( [string] , [ validators . DataRequired ( ) , validators . EqualTo ( [string] , message = [string] ) ] ) [EOL] confirm_password = PasswordField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] [EOL] [EOL] class NewDocumentForm ( FlaskForm ) : [EOL] name = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] mimetype = StringField ( [string] , [ validators . DataRequired ( ) ] ) [EOL] document = FileField ( [string] , [ FileRequired ( ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.SignupForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.SignupForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.SignupForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.LoginForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.LoginForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.DeleteUserForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewEntryForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewEntryForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewEntryForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewEntryForm]$ 0 0 0 0 0 0 $typing.Type[passzero.forms.NewEntryForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.UpdatePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.UpdatePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.UpdatePasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.RecoverPasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.UpdatePreferencesForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.UpdatePreferencesForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.ActivateAccountForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.ConfirmRecoverPasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.ConfirmRecoverPasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.ConfirmRecoverPasswordForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewDocumentForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewDocumentForm]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[passzero.forms.NewDocumentForm]$ 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from zxcvbn import zxcvbn [EOL] [EOL] [EOL] def password_strength ( password , user_inputs ) : [EOL] return zxcvbn ( password , user_inputs = user_inputs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
MAX_ENTRY_PASSWORD_LENGTH = [number] [EOL] MAX_GEN_PASSPHRASE_WORDS = [number] [EOL]	$builtins.int$ 0 0 0 $builtins.int$ 0 0 0
BUILD_ID = [string] [EOL] SALT_SIZE = [number] [EOL] PORT = [number] [EOL] TOKEN_SIZE = [number] [EOL] CSRF_TOKEN_LENGTH = [number] [EOL] DEFAULT_ENTRY_VERSION = [number] [EOL]	$builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
import builtins [EOL] import base64 [EOL] [EOL] [EOL] def base64_encode ( bin_data ) : [EOL] [docstring] [EOL] assert isinstance ( bin_data , bytes ) [EOL] return base64 . b64encode ( bin_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Optional , Any [EOL] import builtins [EOL] import typing [EOL] from typing import Optional , Dict , Any [EOL] [EOL] [EOL] def get_test_decrypted_entry ( i = None ) : [EOL] if i is None : [EOL] return { [string] : f" [string] " , [string] : f" [string] " , [string] : f" [string] " , [string] : False , [string] : f" [string] " } [EOL] else : [EOL] return { [string] : f" [string] { i }" , [string] : f" [string] { i }" , [string] : f" [string] { i }" , [string] : i % [number] == [number] , [string] : f" [string] { i }" } [EOL] [EOL] [EOL] def assert_decrypted_entries_equal ( actual , expected ) : [EOL] for field in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] print ( actual ) [EOL] print ( expected ) [EOL] assert actual [ field ] == expected [ field ] , [string] % field [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import unittest [EOL] import typing [EOL] import flask [EOL] from passzero import email [EOL] from unittest . mock import patch , MagicMock [EOL] import os [EOL] from flask import Flask [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { } , clear = True ) def test_send_email_no_api_key ( ) : [EOL] assert not email . send_email ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { [string] : [string] } , clear = True ) @ patch ( [string] ) def test_send_email_post_failed ( m ) : [EOL] [docstring] [EOL] m . side_effect = Exception ( [string] ) [EOL] assert not email . send_email ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { [string] : [string] } , clear = True ) @ patch ( [string] ) def test_send_email ( m ) : [EOL] [comment] [EOL] mock_client = MagicMock ( ) [EOL] mock_response = MagicMock ( ) [EOL] mock_client . send . return_value = mock_response [EOL] m . SendGridAPIClient . return_value = mock_client [EOL] [comment] [EOL] mock_response . status_code = [number] [EOL] assert not email . send_email ( [string] , [string] , [string] ) [EOL] [comment] [EOL] mock_response . status_code = [number] [EOL] assert email . send_email ( [string] , [string] , [string] ) [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { [string] : [string] } , clear = True ) def test_send_recovery_email ( ) : [EOL] [comment] [EOL] app = Flask ( __name__ ) [EOL] with app . test_request_context ( [string] ) : [EOL] with patch ( [string] , return_value = True ) : [EOL] assert email . send_recovery_email ( [string] , [string] ) [EOL] with patch ( [string] , return_value = False ) : [EOL] assert not email . send_recovery_email ( [string] , [string] ) [EOL] [EOL] [EOL] @ patch . dict ( os . environ , { [string] : [string] } , clear = True ) def test_send_confirmation_email ( ) : [EOL] [comment] [EOL] app = Flask ( __name__ ) [EOL] with app . test_request_context ( [string] ) : [EOL] with patch ( [string] , return_value = True ) : [EOL] assert email . send_confirmation_email ( [string] , [string] ) [EOL] with patch ( [string] , return_value = False ) : [EOL] assert not email . send_confirmation_email ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import os [EOL] [EOL] from passzero import email as pz_email [EOL] from passzero . config import BUILD_ID [EOL] from passzero . my_env import REAL_EMAIL , SENDGRID_API_KEY [EOL] [EOL] [EOL] def test_send_email ( ) : [EOL] os . environ [ [string] ] = SENDGRID_API_KEY [EOL] [comment] [EOL] [comment] [EOL] success = pz_email . send_email ( REAL_EMAIL , [string] % BUILD_ID , [string] % BUILD_ID ) [EOL] assert success [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0