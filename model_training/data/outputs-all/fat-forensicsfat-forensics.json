[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict , Union , List [EOL] import typing [EOL] import re [EOL] from setuptools import find_packages , setup [EOL] [EOL] import fatf [EOL] [EOL] def dependencies_from_file ( file_path ) : [EOL] required = [ ] [EOL] with open ( file_path ) as f : [EOL] for l in f . readlines ( ) : [EOL] l_c = l . strip ( ) [EOL] [comment] [EOL] [comment] [EOL] if l_c and not l_c . startswith ( [string] ) : [EOL] required . append ( l_c ) [EOL] return required [EOL] [EOL] def get_dependency_version ( dependency , list_of_dependencies ) : [EOL] matched_dependencies = [ ] [EOL] [EOL] reformatted_dependency = dependency . lower ( ) . strip ( ) [EOL] for dep in list_of_dependencies : [EOL] dependency_version = re . split ( [string] , dep ) [EOL] if dependency_version [ [number] ] . lower ( ) . strip ( ) == reformatted_dependency : [EOL] matched_dependencies . append ( dep ) [EOL] [EOL] if not matched_dependencies : [EOL] raise NameError ( ( [string] [string] ) . format ( dependency ) ) [EOL] [EOL] return matched_dependencies [EOL] [EOL] DISTNAME = [string] [EOL] PACKAGE_NAME = [string] [EOL] VERSION = fatf . __version__ [EOL] DESCRIPTION = ( [string] [string] ) [EOL] with open ( [string] ) as f : [EOL] LONG_DESCRIPTION = f . read ( ) [EOL] MAINTAINER = [string] [EOL] MAINTAINER_EMAIL = [string] [EOL] URL = [string] . format ( DISTNAME ) [EOL] DOWNLOAD_URL = [string] . format ( DISTNAME ) [EOL] LICENSE = [string] [EOL] PACKAGES = find_packages ( exclude = [ [string] , [string] , [string] , [string] ] ) [EOL] INSTALL_REQUIRES = dependencies_from_file ( [string] ) [EOL] EXTRAS_REQUIRES_AUX = dependencies_from_file ( [string] ) [EOL] EXTRAS_REQUIRES_DEV = dependencies_from_file ( [string] ) [EOL] EXTRAS_REQUIRES_VIS = [ get_dependency_version ( [string] , EXTRAS_REQUIRES_AUX ) ] [EOL] EXTRAS_REQUIRES_ML = [ get_dependency_version ( [string] , EXTRAS_REQUIRES_AUX ) ] [EOL] EXTRAS_REQUIRE = { [string] : EXTRAS_REQUIRES_AUX , [string] : EXTRAS_REQUIRES_DEV , [string] : EXTRAS_REQUIRES_ML , [string] : EXTRAS_REQUIRES_VIS , } [EOL] [comment] [EOL] PYTHON_REQUIRES = [string] [EOL] INCLUDE_PACKAGE_DATA = True [EOL] [comment] [EOL] [EOL] def setup_package ( ) : [EOL] metadata = dict ( name = DISTNAME , maintainer = MAINTAINER , maintainer_email = MAINTAINER_EMAIL , description = DESCRIPTION , license = LICENSE , url = URL , download_url = DOWNLOAD_URL , version = VERSION , install_requires = INSTALL_REQUIRES , extras_require = EXTRAS_REQUIRE , long_description = LONG_DESCRIPTION , include_package_data = INCLUDE_PACKAGE_DATA , python_requires = PYTHON_REQUIRES , packages = PACKAGES ) [EOL] [EOL] setup ( ** metadata ) [EOL] [EOL] if __name__ == [string] : [EOL] setup_package ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] [EOL] class FATFException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class IncorrectShapeError ( FATFException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class IncompatibleExplainerError ( FATFException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class IncompatibleModelError ( FATFException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class UnfittedModelError ( FATFException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PrefittedModelError ( FATFException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional [EOL] [EOL] import logging [EOL] import os [EOL] import re [EOL] import sys [EOL] import warnings [EOL] [EOL] [comment] [EOL] __author__ = [string] [EOL] __email__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] __version__ = [string] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] logger = logging . getLogger ( __name__ ) [comment] [EOL] _logger_handler = logging . StreamHandler ( ) [comment] [EOL] _logger_formatter = logging . Formatter ( [string] , datefmt = [string] ) [EOL] _logger_handler . setFormatter ( _logger_formatter ) [EOL] logger . addHandler ( _logger_handler ) [EOL] if os . environ . get ( [string] , None ) is None : [EOL] logger . setLevel ( logging . INFO ) [comment] [EOL] else : [EOL] logger . setLevel ( logging . NOTSET ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def setup_warning_filters ( ) : [EOL] [docstring] [EOL] if not sys . warnoptions : [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] . format ( re . escape ( __name__ ) ) ) [EOL] warnings . filterwarnings ( [string] , category = ImportWarning , module = [string] . format ( re . escape ( __name__ ) ) ) [EOL] else : [EOL] logger . info ( [string] ) [EOL] [EOL] [EOL] if [string] not in os . environ : [EOL] setup_warning_filters ( ) [comment] [EOL] [EOL] [EOL] [comment] [EOL] def setup_random_seed ( seed = None ) : [EOL] [docstring] [EOL] import numpy as np [EOL] import random [EOL] [EOL] lower_bound = [number] [EOL] upper_bound = [number] [EOL] [EOL] if seed is None : [EOL] [comment] [EOL] _random_seed_os = os . environ . get ( [string] , None ) [EOL] if _random_seed_os is not None : [EOL] [comment] [EOL] _random_seed_os = _random_seed_os . strip ( ) [EOL] if _random_seed_os . isdigit ( ) : [EOL] _random_seed = int ( _random_seed_os ) [EOL] if _random_seed < lower_bound or _random_seed > upper_bound : [EOL] raise ValueError ( [string] [string] [string] [string] . format ( _random_seed ) ) [EOL] logger . info ( [string] ) [EOL] else : [EOL] raise ValueError ( [string] [string] [string] [string] . format ( _random_seed_os ) ) [EOL] else : [EOL] [comment] [EOL] _random_seed = int ( np . random . uniform ( ) * ( [number] ** [number] - [number] ) ) [EOL] logger . info ( [string] ) [EOL] else : [EOL] if isinstance ( seed , int ) : [EOL] if seed < lower_bound or seed > upper_bound : [EOL] raise ValueError ( [string] [string] ) [EOL] _random_seed = seed [EOL] logger . info ( [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] logger . info ( [string] , _random_seed ) [EOL] np . random . seed ( _random_seed ) [EOL] random . seed ( _random_seed ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 $logging.Formatter$ 0 0 $logging.Logger$ 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Callable [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from numbers import Number [EOL] from typing import Callable [EOL] [EOL] import warnings [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . validation as fuv [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def _input_is_valid ( distances ) : [EOL] [docstring] [EOL] is_input_ok = False [EOL] [EOL] if fuav . is_structured_array ( distances ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if not fuav . is_1d_array ( distances ) : [EOL] raise IncorrectShapeError ( [string] [string] ) [EOL] [EOL] if not fuav . is_numerical_array ( distances ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] is_input_ok = True [EOL] return is_input_ok [EOL] [EOL] [EOL] def exponential_kernel ( distances , width = [number] ) : [EOL] [docstring] [EOL] assert _input_is_valid ( distances ) , [string] [EOL] [EOL] if not isinstance ( width , Number ) : [EOL] raise TypeError ( [string] ) [EOL] if width <= [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] kernelised_distances = np . sqrt ( np . exp ( - ( distances ** [number] ) / width ** [number] ) ) [EOL] [EOL] return kernelised_distances [EOL] [EOL] [EOL] def check_kernel_functionality ( kernel_function , suppress_warning = False ) : [EOL] [docstring] [EOL] if not callable ( kernel_function ) : [EOL] raise TypeError ( [string] [string] ) [EOL] if not isinstance ( suppress_warning , bool ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] required_param_n = fuv . get_required_parameters_number ( kernel_function ) [EOL] is_functional = required_param_n == [number] [EOL] [EOL] if not is_functional and not suppress_warning : [EOL] message = ( [string] [string] [string] [string] ) . format ( kernel_function . __name__ , required_param_n ) [EOL] warnings . warn ( message , category = UserWarning ) [EOL] [EOL] return is_functional [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Mapping , Optional , Tuple , Any , List , Callable , Union [EOL] import typing [EOL] import inspect [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Callable , Dict , Optional , Tuple , Union [EOL] [EOL] import inspect [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def get_required_parameters_number ( callable_object ) : [EOL] [docstring] [EOL] if not callable ( callable_object ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] required_param_n = [number] [EOL] params = inspect . signature ( callable_object ) . parameters [EOL] for param in params : [EOL] if param != [string] : [EOL] if params [ param ] . default is params [ param ] . empty : [EOL] required_param_n += [number] [EOL] [EOL] return required_param_n [EOL] [EOL] [EOL] def check_object_functionality ( an_object , methods , object_reference_name = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( methods , dict ) : [EOL] if methods : [EOL] [comment] [EOL] [comment] [EOL] key_str = sorted ( [ i for i in methods . keys ( ) if isinstance ( i , str ) ] ) [EOL] key_otr = [ i for i in methods . keys ( ) if i not in key_str ] [EOL] [EOL] for key in key_str + key_otr : [EOL] value = methods [ key ] [EOL] if not isinstance ( key , str ) : [EOL] raise TypeError ( [string] [string] [string] . format ( key ) ) [EOL] if not isinstance ( value , int ) : [EOL] raise TypeError ( [string] [string] [string] [string] . format ( value , key ) ) [EOL] if value < [number] : [EOL] raise ValueError ( [string] [string] [string] [string] . format ( value , key ) ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if object_reference_name is not None : [EOL] if not isinstance ( object_reference_name , str ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] is_instantiated = not isinstance ( an_object , type ) [EOL] [EOL] if is_instantiated : [EOL] object_name = an_object . __class__ . __name__ [EOL] param_correction = [number] [EOL] else : [EOL] object_name = an_object . __name__ [comment] [EOL] [comment] [EOL] param_correction = [number] [EOL] [EOL] if object_reference_name is None : [EOL] object_reference = [string] . format ( object_name ) [EOL] else : [EOL] object_reference = [string] . format ( object_name , object_reference_name ) [EOL] [EOL] is_functional = True [EOL] message_strings = [ ] [EOL] [EOL] for method in methods : [EOL] if not hasattr ( an_object , method ) : [EOL] is_functional = False [EOL] message_strings . append ( [string] . format ( object_reference , method ) ) [EOL] else : [EOL] method_object = getattr ( an_object , method ) [EOL] required_param_n = get_required_parameters_number ( method_object ) [EOL] required_param_n -= param_correction [EOL] [EOL] if not required_param_n == methods [ method ] : [EOL] is_functional = False [EOL] message_strings . append ( ( [string] [string] [string] [string] ) . format ( method , object_reference , required_param_n , methods [ method ] ) ) [EOL] [EOL] message = [string] . join ( message_strings ) [EOL] [EOL] return is_functional , message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] def at_least_verion ( minimum_requirement , package_version ) : [EOL] [docstring] [EOL] [comment] [EOL] if not isinstance ( minimum_requirement , list ) : [EOL] raise TypeError ( [string] ) [EOL] for i , val in enumerate ( minimum_requirement ) : [EOL] if not isinstance ( val , int ) : [EOL] raise TypeError ( ( [string] [string] ) . format ( i , val ) ) [EOL] [EOL] if not isinstance ( package_version , list ) : [EOL] raise TypeError ( [string] ) [EOL] for i , val in enumerate ( package_version ) : [EOL] if not isinstance ( val , int ) : [EOL] raise TypeError ( ( [string] [string] ) . format ( i , val ) ) [EOL] [EOL] [comment] [EOL] if not minimum_requirement : [EOL] raise ValueError ( [string] ) [EOL] if not package_version : [EOL] raise ValueError ( [string] ) [EOL] [EOL] minimum_requirement_len = len ( minimum_requirement ) [EOL] package_version_len = len ( package_version ) [EOL] if minimum_requirement_len > package_version_len : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] is_compatible = True [EOL] for i in range ( minimum_requirement_len ) : [EOL] if package_version [ i ] < minimum_requirement [ i ] : [EOL] is_compatible = False [EOL] break [EOL] elif package_version [ i ] > minimum_requirement [ i ] : [EOL] assert is_compatible , [string] [EOL] is_compatible = True [EOL] break [EOL] [EOL] return is_compatible [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , List [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union [EOL] [EOL] import abc [EOL] import warnings [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . validation as fuv [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] class Explainer ( abc . ABC ) : [EOL] [docstring] [EOL] [EOL] def feature_importance ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [EOL] def explain_model ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] [string] ) [EOL] [EOL] def explain_instance ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError ( [string] [string] ) [EOL] [EOL] [EOL] def check_instance_explainer_functionality ( explainer_object , suppress_warning = False ) : [EOL] [docstring] [EOL] if not isinstance ( suppress_warning , bool ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] methods = { [string] : [number] } [EOL] [EOL] is_functional , message = fuv . check_object_functionality ( explainer_object , methods , object_reference_name = [string] ) [EOL] [EOL] if not is_functional and not suppress_warning : [EOL] warnings . warn ( message , category = UserWarning ) [EOL] [EOL] if isinstance ( explainer_object , type ) : [EOL] inherits_correctly = issubclass ( explainer_object , Explainer ) [EOL] else : [EOL] inherits_correctly = isinstance ( explainer_object , Explainer ) [EOL] if not inherits_correctly : [EOL] warnings . warn ( [string] [string] , category = UserWarning ) [EOL] [EOL] return is_functional [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . transparency . explainers as fute [EOL] [EOL] [EOL] class TestExplainer ( object ) : [EOL] [docstring] [EOL] explainer = fute . Explainer ( ) [EOL] [EOL] def test_explainer_class ( self ) : [EOL] [docstring] [EOL] assert self . explainer . __class__ . __bases__ [ [number] ] . __name__ == [string] [EOL] assert self . explainer . __class__ . __name__ == [string] [EOL] [EOL] def test_explainer_class_errors ( self ) : [EOL] [docstring] [EOL] feature_importance = [string] [EOL] model_explanation = [string] [EOL] instance_explanation = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( NotImplementedError ) as exinf : [EOL] self . explainer . feature_importance ( ) [EOL] assert str ( exinf . value ) == feature_importance [EOL] with pytest . raises ( NotImplementedError ) as exinf : [EOL] self . explainer . explain_model ( ) [EOL] assert str ( exinf . value ) == model_explanation [EOL] with pytest . raises ( NotImplementedError ) as exinf : [EOL] self . explainer . explain_instance ( ) [EOL] assert str ( exinf . value ) == instance_explanation [EOL] [EOL] [EOL] def test_check_instance_explainer_functionality ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] inheritance_warning = ( [string] [string] ) [EOL] [EOL] class ClassPlain ( object ) : [EOL] pass [EOL] [EOL] class_plain = ClassPlain ( ) [EOL] [EOL] class ClassInit ( fute . Explainer ) : [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] class_init = ClassInit ( ) [EOL] [EOL] class ClassExplainer1 ( object ) : [EOL] def explain_instance ( self ) : [EOL] pass [comment] [EOL] [EOL] class_explainer_1 = ClassExplainer1 ( ) [EOL] [EOL] class ClassExplainer2 ( fute . Explainer ) : [EOL] def explain_instance ( self , x , y ) : [EOL] pass [comment] [EOL] [EOL] class_explainer_2 = ClassExplainer2 ( ) [EOL] [EOL] class ClassExplainer3 ( object ) : [EOL] def explain_instance ( self , x ) : [EOL] pass [comment] [EOL] [EOL] class_explainer_3 = ClassExplainer3 ( ) [EOL] [EOL] class ClassExplainer4 ( fute . Explainer ) : [EOL] def explain_instance ( self , x , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] class_explainer_4 = ClassExplainer4 ( ) [EOL] [EOL] class ClassExplainer5 ( object ) : [EOL] def explain_instance ( self , x , y = [number] , z = [number] ) : [EOL] pass [comment] [EOL] [EOL] class_explainer_5 = ClassExplainer5 ( ) [EOL] [EOL] with pytest . raises ( TypeError ) as exinf : [EOL] fute . check_instance_explainer_functionality ( class_plain , [string] ) [EOL] assert str ( exinf . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exinf : [EOL] fute . check_instance_explainer_functionality ( ClassPlain , [string] ) [EOL] assert str ( exinf . value ) == type_error [EOL] [EOL] msg = [string] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_plain , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] ) == str ( warning [ [number] ] . message ) [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( ClassPlain ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] ) == str ( warning [ [number] ] . message ) [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_plain , True ) is False [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] msg = ( [string] [string] [string] [string] ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_init , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( ClassInit ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] [EOL] assert fute . check_instance_explainer_functionality ( class_init , True ) is False [EOL] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_1 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( ClassExplainer1 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_1 , True ) is False [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_2 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_2 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert msg . format ( [string] , [number] ) == str ( warning [ [number] ] . message ) [EOL] [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_2 , True ) is False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_3 , False ) is True [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( ClassExplainer3 , True ) is True [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] [comment] [EOL] [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_4 , False ) is True [EOL] assert fute . check_instance_explainer_functionality ( ClassExplainer4 , True ) is True [EOL] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( class_explainer_5 , False ) is True [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fute . check_instance_explainer_functionality ( ClassExplainer5 , True ) is True [EOL] assert len ( warning ) == [number] [EOL] assert inheritance_warning == str ( warning [ [number] ] . message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.transparency.explainers.Explainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] from fatf . exceptions import IncompatibleModelError , IncorrectShapeError [EOL] [EOL] import fatf [EOL] import fatf . utils . metrics . metrics as fummet [EOL] import fatf . utils . metrics . tools as fumt [EOL] import fatf . utils . models . models as fumm [EOL] import fatf . utils . transparency . surrogate_evaluation as futs [EOL] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] NUMERICAL_NP_ARRAY_LOCAL = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY_LOCAL = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] NUMERICAL_NP_ARRAY_TARGET = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] NUMERICAL_NP_ARRAY_LOCAL_TARGET = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_validate_input_local_fidelity ( ) : [EOL] [docstring] [EOL] incorrect_shape_dataset = ( [string] [string] ) [EOL] type_error_dataset = ( [string] [string] ) [EOL] incorrect_shape_datarow = ( [string] [string] [string] ) [EOL] incorrect_dtype_data = ( [string] [string] ) [EOL] datarow_features_error = ( [string] [string] ) [EOL] [EOL] global_model_incompatible = ( [string] [string] [string] ) [EOL] global_model_type = ( [string] [string] ) [EOL] local_model_incompatible = ( [string] [string] [string] ) [EOL] local_model_type = ( [string] [string] ) [EOL] [EOL] metric_param_error = ( [string] [string] ) [EOL] metric_type_error = ( [string] [string] ) [EOL] [EOL] explained_class_value_error = ( [string] [string] [string] [string] ) [EOL] explained_class_type_error = ( [string] [string] [string] [string] ) [EOL] explained_class_warning = ( [string] [string] [string] ) [EOL] [EOL] features_index_error = ( [string] [string] ) [EOL] features_type_error = ( [string] [string] ) [EOL] [EOL] fidelity_radius_type_error = ( [string] [string] ) [EOL] fidelity_radius_value_error = ( [string] [string] ) [EOL] [EOL] samples_number_value_error = ( [string] [string] ) [EOL] samples_number_type_error = [string] [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY [ [number] ] , None , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == incorrect_shape_dataset [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( np . array ( [ [ None ] ] ) , None , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == type_error_dataset [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == incorrect_shape_datarow [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , np . array ( [ [string] ] ) , None , None , None , None , None , None , None ) [comment] [EOL] assert str ( exin . value ) == incorrect_dtype_data [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] [ [number] : [number] ] , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == datarow_features_error [EOL] [EOL] def predict ( x ) : [EOL] return np . ones ( x . shape [ [number] ] ) [EOL] [EOL] def predict_invalid ( x_1 , x_2 ) : [EOL] pass [comment] [EOL] [EOL] def predict_proba ( x ) : [EOL] return np . ones ( ( x . shape [ [number] ] , [number] ) ) [EOL] [EOL] def predict_proba_invalid ( ) : [EOL] pass [comment] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == global_model_type [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_invalid , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == global_model_incompatible [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == local_model_type [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict_proba_invalid , None , None , None , None , None ) [EOL] assert str ( exin . value ) == local_model_incompatible [EOL] [EOL] def invalid_metric ( x ) : [EOL] pass [comment] [EOL] [EOL] def metric ( x_1 , x_2 ) : [EOL] pass [comment] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , None , None , None , None , None ) [EOL] assert str ( exin . value ) == metric_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , invalid_metric , None , None , None , None ) [EOL] assert str ( exin . value ) == metric_param_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , [string] , None , None , None ) [EOL] assert str ( exin . value ) == explained_class_type_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , - [number] , None , None , None ) [EOL] assert str ( exin . value ) == explained_class_value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , [number] , None , None , None ) [EOL] assert str ( exin . value ) == explained_class_value_error [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , [number] , None , [number] , [number] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == explained_class_warning [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , None , np . array ( [ [number] , [number] ] ) , None , None ) [EOL] assert str ( exin . value ) == features_type_error [EOL] with pytest . raises ( IndexError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , [ [number] , [number] ] , None , None ) [EOL] assert str ( exin . value ) == features_index_error . format ( np . array ( [ [number] , [number] ] ) ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , [number] , [ [number] , [number] ] , [string] , None ) [EOL] assert str ( exin . value ) == fidelity_radius_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , [number] , [ [number] , [number] ] , None , None ) [EOL] assert str ( exin . value ) == fidelity_radius_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict_proba , predict , metric , [number] , [ [number] , [number] ] , [number] , None ) [EOL] assert str ( exin . value ) == fidelity_radius_type_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , [ [number] , [number] ] , [number] , None ) [EOL] assert str ( exin . value ) == fidelity_radius_value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , [ [number] , [number] ] , [number] , None ) [EOL] assert str ( exin . value ) == fidelity_radius_value_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , None , [number] , None ) [EOL] assert str ( exin . value ) == samples_number_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , None , [number] , [number] ) [EOL] assert str ( exin . value ) == samples_number_type_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , None , [number] , [number] ) [EOL] assert str ( exin . value ) == samples_number_value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predict , predict , metric , None , None , [number] , - [number] ) [EOL] assert str ( exin . value ) == samples_number_value_error [EOL] [EOL] clf = fumm . KNN ( k = [number] ) [EOL] clf . fit ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , clf . predict_proba , predict , metric , [number] , None , [number] , [number] ) [EOL] assert str ( exin . value ) == explained_class_value_error [EOL] [EOL] [comment] [EOL] assert futs . _validate_input_local_fidelity ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , clf . predict_proba , predict , metric , [number] , [ [number] , [number] ] , [number] , [number] ) [EOL] [EOL] [EOL] def test_local_fidelity_score ( ) : [EOL] [docstring] [EOL] accuracy_warning = ( [string] [string] ) [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] def accuracy ( global_predictions , local_predictions ) : [EOL] global_predictions [ global_predictions >= [number] ] = [number] [EOL] global_predictions [ global_predictions < [number] ] = [number] [EOL] [EOL] local_predictions [ local_predictions >= [number] ] = [number] [EOL] local_predictions [ local_predictions < [number] ] = [number] [EOL] [EOL] confusion_matrix = fumt . get_confusion_matrix ( global_predictions , local_predictions , labels = [ [number] , [number] ] ) [EOL] accuracy = fummet . accuracy ( confusion_matrix ) [EOL] [EOL] return accuracy [EOL] [EOL] def accuracy_prob ( global_predictions , local_predictions , global_proba = True , local_proba = True ) : [EOL] if global_proba : [EOL] global_predictions = np . argmax ( global_predictions , axis = [number] ) [EOL] if local_proba : [EOL] local_predictions = np . argmax ( local_predictions , axis = [number] ) [EOL] [EOL] confusion_matrix = fumt . get_confusion_matrix ( global_predictions , local_predictions , labels = [ [number] , [number] , [number] ] ) [EOL] accuracy = fummet . accuracy ( confusion_matrix ) [EOL] [EOL] return accuracy [EOL] [EOL] def accuracy_proba_np ( global_predictions , local_predictions ) : [EOL] return accuracy_prob ( global_predictions , local_predictions , global_proba = False , local_proba = True ) [EOL] [EOL] def accuracy_proba_nn ( global_predictions , local_predictions ) : [EOL] return accuracy_prob ( global_predictions , local_predictions , global_proba = False , local_proba = False ) [EOL] [EOL] def reg_dist ( global_predictions , local_predictions ) : [EOL] return ( global_predictions - local_predictions ) . sum ( ) [EOL] [EOL] predictor = fumm . KNN ( k = [number] ) [EOL] predictor . fit ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] [EOL] regressor = fumm . KNN ( k = [number] , mode = [string] ) [EOL] regressor . fit ( NUMERICAL_NP_ARRAY_LOCAL , NUMERICAL_NP_ARRAY_LOCAL_TARGET ) [EOL] [EOL] regressor_23 = fumm . KNN ( k = [number] , mode = [string] ) [EOL] regressor_23 . fit ( NUMERICAL_NP_ARRAY_LOCAL [ : , [ [number] , [number] ] ] , NUMERICAL_NP_ARRAY_LOCAL_TARGET ) [EOL] [EOL] [comment] [EOL] predictor_struct = fumm . KNN ( k = [number] ) [EOL] predictor_struct . fit ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] [comment] [EOL] regressor_struct_cd = fumm . KNN ( k = [number] , mode = [string] ) [EOL] regressor_struct_cd . fit ( NUMERICAL_STRUCT_ARRAY_LOCAL [ [ [string] , [string] ] ] , NUMERICAL_NP_ARRAY_LOCAL_TARGET ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predictor . predict_proba , regressor . predict , accuracy , [number] ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [comment] [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predictor . predict_proba , predictor . predict , accuracy , [number] ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predictor . predict_proba , predictor . predict_proba , accuracy_prob ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == accuracy_warning . format ( set ( [ [number] ] ) ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predictor . predict , predictor . predict_proba , accuracy_proba_np ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == accuracy_warning . format ( set ( [ [number] ] ) ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , predictor . predict , predictor . predict , accuracy_proba_nn ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == accuracy_warning . format ( set ( [ [number] ] ) ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] , regressor . predict , regressor_23 . predict , reg_dist , explained_feature_indices = [ [number] , [number] ] ) [EOL] assert np . isclose ( comparison , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] comparison = futs . local_fidelity_score ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_STRUCT_ARRAY [ [number] ] , predictor_struct . predict_proba , regressor_struct_cd . predict , accuracy , [number] , explained_feature_indices = [ [string] , [string] ] ) [EOL] assert np . isclose ( comparison , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Type [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] import fatf . utils . models . models as fumm [EOL] from fatf . exceptions import ( IncorrectShapeError , PrefittedModelError , UnfittedModelError ) [EOL] [EOL] [EOL] class TestModel ( object ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def test__init__ ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] error_message = ( [string] [string] ) [EOL] with pytest . raises ( TypeError ) as exception_info : [EOL] fumm . Model ( ) [comment] [EOL] assert str ( exception_info . value ) == error_message [EOL] [EOL] def test_fit ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] assert fumm . Model . fit ( object ( ) , np . ndarray ( ( [number] , [number] ) ) , np . ndarray ( ( [number] , ) ) ) is None [comment] [EOL] [EOL] def test_predict ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] assert fumm . Model . predict ( object ( ) , np . ndarray ( ( [number] , ) ) ) is None [EOL] [EOL] def test_predict_proba ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] error_message = [string] [EOL] with pytest . raises ( NotImplementedError ) as exception_info : [EOL] fumm . Model . predict_proba ( object ( ) , np . ndarray ( ( [number] , ) ) ) [EOL] assert str ( exception_info . value ) == error_message [EOL] [EOL] [EOL] class TestKNN ( object ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error_k = [string] [EOL] value_error_k = [string] [EOL] value_error_mode = ( [string] [string] ) . format ( fumm . KNN . _MODES ) [EOL] prefitted_model_error = [string] [EOL] incorrect_shape_error_rows = [string] [EOL] incorrect_shape_error_2d = ( [string] [string] ) [EOL] incorrect_shape_error_1d = ( [string] [string] ) [EOL] incorrect_shape_error_X0 = ( [string] [string] ) [EOL] incorrect_shape_error_X1 = ( [string] [string] ) [EOL] incorrect_shape_error_Xy = ( [string] [string] ) [EOL] type_error_regressor = ( [string] [string] ) [EOL] unfitted_model_error = [string] [EOL] incorrect_shape_error_singular = ( [string] [string] [string] [string] ) [EOL] value_error_dtype = [string] [EOL] incorrect_shape_error_columns = ( [string] [string] ) [EOL] runtime_error = [string] [EOL] [EOL] k = [number] [EOL] [EOL] X_short = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] X_short_categorical_indices = np . array ( [ ] ) [EOL] X_short_numerical_indices = np . array ( [ [number] , [number] , [number] ] ) [EOL] X_short_n = [number] [EOL] [EOL] y_short = np . array ( [ [string] , [string] ] ) [EOL] [comment] [EOL] short_majority_label = [string] [EOL] short_unique_y = np . array ( [ [string] , [string] ] ) [EOL] short_unique_y_counts = np . array ( [ [number] , [number] ] ) [EOL] short_unique_y_probabilities = np . array ( [ [number] , [number] ] ) [EOL] [EOL] y_short_numerical = np . array ( [ [number] , [number] ] ) [EOL] [comment] [EOL] short_numerical_majority_label_classifier = [number] [EOL] short_numerical_majority_label_regressor = ( [number] + [number] ) / [number] [EOL] [comment] [EOL] short_numerical_unique_y = np . array ( [ [number] , [number] ] ) [EOL] short_numerical_unique_y_counts = np . array ( [ [number] , [number] ] ) [EOL] short_numerical_unique_y_probabilities = np . array ( [ [number] , [number] ] ) [EOL] [EOL] X_cat = np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) [EOL] X_cat_test = np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) [EOL] X_cat_categorical_indices = np . array ( [ [number] , [number] ] ) [EOL] X_cat_numerical_indices = np . array ( [ ] ) [EOL] X_cat_struct = np . array ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] X_cat_struct_test = np . array ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] X_cat_struct_categorical_indices = np . array ( [ [string] , [string] ] ) [EOL] X_cat_struct_numerical_indices = np . array ( [ ] ) [EOL] X_cat_distances = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] [EOL] X = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ - [number] , [number] ] , [ - [number] , - [number] ] , [ [number] , - [number] ] , [ [number] , [number] ] , ] ) [comment] [EOL] X_numerical_indices = np . array ( [ [number] , [number] ] ) [EOL] X_categorical_indices = np . array ( [ ] ) [EOL] [EOL] X_struct = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , [number] ) , ( - [number] , - [number] ) , ( [number] , - [number] ) , ( [number] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , [string] ) ] ) [EOL] X_struct_numerical_indices = np . array ( [ [string] , [string] ] ) [EOL] X_struct_categorical_indices = np . array ( [ ] ) [EOL] [EOL] X_mix = np . array ( [ ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) , ( [string] , - [number] , [number] ) , ( [string] , - [number] , - [number] ) , ( [string] , [number] , - [number] ) , ( [string] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] X_mix_numerical_indices = np . array ( [ [string] , [string] ] ) [EOL] X_mix_categorical_indices = np . array ( [ [string] ] ) [EOL] [EOL] X_n = [number] [EOL] y = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] y_categorical = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] unique_y = np . array ( [ [number] , [number] ] ) [EOL] unique_y_categorical = np . array ( [ [string] , [string] ] ) [EOL] unique_y_counts = np . array ( [ [number] , [number] ] ) [EOL] unique_y_probabilities = np . array ( [ [number] , [number] ] ) [EOL] [EOL] majority_label = [number] [EOL] majority_label_categorical = [string] [EOL] majority_label_regressor = ( [number] + [number] ) / [number] [EOL] [EOL] X_test = np . array ( [ [ - [number] , - [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] X_test_struct = np . array ( [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , float ) ] ) [EOL] X_distances = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] y_test_3_classification = np . array ( [ [number] , [number] , [number] ] ) [EOL] y_test_3_classification_categorical = np . array ( [ [string] , [string] , [string] ] ) [EOL] y_test_3_regression = np . array ( [ [number] , [number] , [number] ] ) [EOL] [EOL] y_test_3_proba = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] y_test_3_trainig_proba = np . array ( [ [number] , [number] ] ) [EOL] [EOL] X_test_mix = np . array ( [ ( [string] , - [number] , - [number] ) , ( [string] , [number] , [number] ) , ( [string] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] X_mix_distances = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] [EOL] X_3D = np . ones ( ( [number] , [number] , [number] ) ) [EOL] [EOL] def _test_unfitted_internals ( self , knn_clf , init_k = [number] , init_is_classifier = True ) : [EOL] [docstring] [EOL] [comment] [EOL] assert knn_clf . _k == init_k [EOL] assert knn_clf . _is_classifier is init_is_classifier [EOL] [EOL] assert knn_clf . _is_fitted is False [EOL] assert np . equal ( knn_clf . _X , np . ndarray ( ( [number] , [number] ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _y , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert knn_clf . _X_n == int ( ) [EOL] assert np . equal ( knn_clf . _unique_y , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _unique_y_counts , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _unique_y_probabilities , np . ndarray ( ( [number] , ) ) ) . all ( ) [comment] [EOL] assert knn_clf . _majority_label is None [EOL] assert knn_clf . _is_structured is False [EOL] assert np . equal ( knn_clf . _categorical_indices , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _numerical_indices , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] [EOL] def _test_fitted_internals ( self , knn_clf , is_structured , X , y , X_n , majority_label , categorical_indices , numerical_indices , unique_y = None , unique_y_counts = None , unique_y_probabilities = None ) : [EOL] [docstring] [EOL] [comment] [EOL] assert knn_clf . _is_fitted [EOL] assert np . array_equal ( knn_clf . _X , X ) [EOL] assert np . array_equal ( knn_clf . _y , y ) [EOL] assert knn_clf . _X_n == X_n [EOL] assert knn_clf . _is_structured is is_structured [EOL] assert np . array_equal ( knn_clf . _categorical_indices , categorical_indices ) [EOL] assert np . array_equal ( knn_clf . _numerical_indices , numerical_indices ) [EOL] [EOL] if knn_clf . _is_classifier : [EOL] assert np . array_equal ( knn_clf . _unique_y , unique_y ) [EOL] assert np . equal ( knn_clf . _unique_y_counts , unique_y_counts ) . all ( ) [EOL] assert np . isclose ( knn_clf . _unique_y_probabilities , unique_y_probabilities , atol = [number] ) . all ( ) [EOL] assert knn_clf . _majority_label == majority_label [EOL] else : [EOL] assert unique_y is None [EOL] assert unique_y_counts is None [EOL] assert unique_y_probabilities is None [EOL] assert np . equal ( knn_clf . _unique_y , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _unique_y_counts , np . ndarray ( ( [number] , ) ) ) . all ( ) [EOL] assert np . equal ( knn_clf . _unique_y_probabilities , np . ndarray ( ( [number] , ) ) ) . all ( ) [comment] [EOL] assert knn_clf . _majority_label == majority_label [EOL] [EOL] def test_knn ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exception_info : [EOL] clf = fumm . KNN ( k = None ) [EOL] assert str ( exception_info . value ) == self . type_error_k [EOL] with pytest . raises ( TypeError ) as exception_info : [EOL] clf = fumm . KNN ( k = [string] ) [EOL] assert str ( exception_info . value ) == self . type_error_k [EOL] with pytest . raises ( TypeError ) as exception_info : [EOL] clf = fumm . KNN ( k = - [number] ) [EOL] assert str ( exception_info . value ) == self . type_error_k [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf = fumm . KNN ( k = - [number] ) [EOL] assert str ( exception_info . value ) == self . value_error_k [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf = fumm . KNN ( k = [number] , mode = object ( ) ) [EOL] assert str ( exception_info . value ) == self . value_error_mode [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf = fumm . KNN ( k = [number] , mode = [number] ) [EOL] assert str ( exception_info . value ) == self . value_error_mode [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf = fumm . KNN ( k = [number] , mode = [string] ) [EOL] assert str ( exception_info . value ) == self . value_error_mode [EOL] [EOL] clf = fumm . KNN ( ) [EOL] self . _test_unfitted_internals ( clf , init_k = self . k , init_is_classifier = True ) [EOL] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] clf = fumm . KNN ( k = k , mode = None ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] [EOL] def test_fit ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( PrefittedModelError ) as exception_info : [EOL] clf . fit ( self . X , self . y ) [EOL] assert self . prefitted_model_error == str ( exception_info . value ) [EOL] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k ) [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( self . X_3D , self . y ) [EOL] assert self . incorrect_shape_error_2d == str ( exception_info . value ) [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( self . X_3D , self . X ) [EOL] assert self . incorrect_shape_error_2d == str ( exception_info . value ) [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( self . X , self . X_3D ) [EOL] assert self . incorrect_shape_error_1d == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( np . ndarray ( ( [number] , [number] ) ) , self . y ) [EOL] assert self . incorrect_shape_error_X0 == str ( exception_info . value ) [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( np . ndarray ( ( [number] , ) , dtype = [ ( [string] , str ) , ( [string] , int ) ] ) , self . y ) [EOL] assert self . incorrect_shape_error_X0 == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( np . ndarray ( ( [number] , [number] ) ) , self . y ) [EOL] assert self . incorrect_shape_error_X1 == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . fit ( self . X , self . X_numerical_indices ) [EOL] assert self . incorrect_shape_error_Xy == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] with pytest . raises ( TypeError ) as exception_info : [EOL] y_pred = np . array ( self . X . shape [ [number] ] * [ [string] ] ) [EOL] clf . fit ( self . X , y_pred ) [EOL] assert self . type_error_regressor == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_mix , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_mix , self . y , self . X_n , self . majority_label , self . X_mix_categorical_indices , self . X_mix_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X_short , self . y_short_numerical ) [EOL] self . _test_fitted_internals ( clf , False , self . X_short , self . y_short_numerical , self . X_short_n , self . short_numerical_majority_label_regressor , self . X_short_categorical_indices , self . X_short_numerical_indices ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_short , self . y_short_numerical ) [EOL] self . _test_fitted_internals ( clf , False , self . X_short , self . y_short_numerical , self . X_short_n , self . short_numerical_majority_label_classifier , self . X_short_categorical_indices , self . X_short_numerical_indices , self . short_numerical_unique_y , self . short_numerical_unique_y_counts , self . short_numerical_unique_y_probabilities ) [EOL] [EOL] [comment] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_short , self . y_short ) [EOL] self . _test_fitted_internals ( clf , False , self . X_short , self . y_short , self . X_short_n , self . short_majority_label , self . X_short_categorical_indices , self . X_short_numerical_indices , self . short_unique_y , self . short_unique_y_counts , self . short_unique_y_probabilities ) [EOL] [EOL] def test_clear ( self ) : [EOL] [docstring] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( UnfittedModelError ) as exception_info : [EOL] clf . clear ( ) [EOL] assert self . unfitted_model_error == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] clf . clear ( ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] def test_get_distances ( self ) : [EOL] [docstring] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] [EOL] def is_unfitted ( ) : [EOL] return self . _test_unfitted_internals ( clf , init_k = [number] , init_is_classifier = True ) [EOL] [EOL] is_unfitted ( ) [EOL] [EOL] [comment] [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] dist = clf . _get_distances ( self . X_test ) [EOL] assert np . isclose ( dist , self . X_distances , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] clf . clear ( ) [EOL] is_unfitted ( ) [EOL] clf . fit ( self . X_cat , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X_cat , self . y , self . X_n , self . majority_label , self . X_cat_categorical_indices , self . X_cat_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] dist = clf . _get_distances ( self . X_cat_test ) [EOL] assert np . isclose ( dist , self . X_cat_distances , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] clf . clear ( ) [EOL] is_unfitted ( ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] dist = clf . _get_distances ( self . X_test_struct ) [EOL] assert np . isclose ( dist , self . X_distances , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] clf . clear ( ) [EOL] is_unfitted ( ) [EOL] clf . fit ( self . X_cat_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_cat_struct , self . y , self . X_n , self . majority_label , self . X_cat_struct_categorical_indices , self . X_cat_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] dist = clf . _get_distances ( self . X_cat_struct_test ) [EOL] assert np . isclose ( dist , self . X_cat_distances , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] clf . clear ( ) [EOL] is_unfitted ( ) [EOL] clf . fit ( self . X_mix , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_mix , self . y , self . X_n , self . majority_label , self . X_mix_categorical_indices , self . X_mix_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] dist = clf . _get_distances ( self . X_test_mix ) [EOL] assert np . isclose ( dist , self . X_mix_distances , atol = [number] ) . all ( ) [EOL] [EOL] def test_predict ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( UnfittedModelError ) as exception_info : [EOL] clf . predict ( self . X_test ) [EOL] assert self . unfitted_model_error == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] clf . fit ( self . X , self . y ) [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict ( self . X_3D ) [EOL] assert self . incorrect_shape_error_singular == str ( exception_info . value ) [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict ( self . y ) [EOL] assert self . incorrect_shape_error_singular == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict ( self . X_cat ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict ( self . X_cat_struct ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict ( self . X_struct ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict ( np . ones ( ( [number] , [number] ) , dtype = int ) ) [EOL] assert self . incorrect_shape_error_rows == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict ( self . X_distances ) [EOL] assert str ( exception_info . value ) . startswith ( self . incorrect_shape_error_columns ) [EOL] [comment] [EOL] clf . clear ( ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict ( self . X_test_struct [ [ [string] ] ] ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label_regressor , self . X_categorical_indices , self . X_numerical_indices ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] assert np . isclose ( y_hat , self . y_test_3_regression , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label_regressor , self . X_categorical_indices , self . X_numerical_indices ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label_regressor ] ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label_regressor , self . X_struct_categorical_indices , self . X_struct_numerical_indices ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] assert np . isclose ( y_hat , self . y_test_3_regression , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label_regressor , self . X_struct_categorical_indices , self . X_struct_numerical_indices ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label_regressor ] ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] assert np . isclose ( y_hat , self . y_test_3_classification , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label ] ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] assert np . isclose ( y_hat , self . y_test_3_classification , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label ] ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_categorical_indices , self . X_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] assert np . array_equal ( y_hat , self . y_test_3_classification_categorical ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_categorical_indices , self . X_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label_categorical ] ) [EOL] assert np . array_equal ( y_hat , y_true ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] assert np . array_equal ( y_hat , self . y_test_3_classification_categorical ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict ( self . X_test_struct ) [EOL] y_true = np . array ( y_hat . shape [ [number] ] * [ self . majority_label_categorical ] ) [EOL] assert np . array_equal ( y_hat , y_true ) [EOL] [EOL] [comment] [EOL] y = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [comment] [EOL] majority_label = [number] [EOL] unique_y = np . array ( [ [number] , [number] ] ) [EOL] unique_y_counts = np . array ( [ [number] , [number] ] ) [EOL] unique_y_probabilities = np . array ( [ [number] , [number] ] ) [EOL] X_test = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [comment] [EOL] y_test = np . array ( [ [number] , [number] ] ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , y , self . X_n , majority_label , self . X_categorical_indices , self . X_numerical_indices , unique_y , unique_y_counts , unique_y_probabilities ) [EOL] y_hat = clf . predict ( X_test ) [EOL] assert np . array_equal ( y_hat , y_test ) [EOL] [EOL] def test_predict_proba ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k , mode = [string] ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = False ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label_regressor , self . X_categorical_indices , self . X_numerical_indices ) [EOL] with pytest . raises ( RuntimeError ) as exception_info : [EOL] clf . predict_proba ( self . X_test ) [EOL] assert str ( exception_info . value ) == self . runtime_error [EOL] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( UnfittedModelError ) as exception_info : [EOL] clf . predict_proba ( self . X_test ) [EOL] assert self . unfitted_model_error == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict_proba ( self . X_3D ) [EOL] assert self . incorrect_shape_error_singular == str ( exception_info . value ) [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict_proba ( self . y ) [EOL] assert self . incorrect_shape_error_singular == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict_proba ( self . X_cat ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict_proba ( self . X_cat_struct ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict_proba ( self . X_struct ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict_proba ( np . ones ( ( [number] , [number] ) , dtype = int ) ) [EOL] assert self . incorrect_shape_error_rows == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exception_info : [EOL] clf . predict_proba ( self . X_distances ) [EOL] assert str ( exception_info . value ) . startswith ( self . incorrect_shape_error_columns ) [EOL] [comment] [EOL] clf . clear ( ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] with pytest . raises ( ValueError ) as exception_info : [EOL] clf . predict_proba ( self . X_test_struct [ [ [string] ] ] ) [EOL] assert self . value_error_dtype == str ( exception_info . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test ) [EOL] assert np . isclose ( y_hat , self . y_test_3_proba , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y , self . X_n , self . majority_label , self . X_categorical_indices , self . X_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test ) [EOL] y_true = np . full ( ( y_hat . shape [ [number] ] , self . y_test_3_trainig_proba . shape [ [number] ] ) , fill_value = self . y_test_3_trainig_proba ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test_struct ) [EOL] assert np . isclose ( y_hat , self . y_test_3_proba , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y , self . X_n , self . majority_label , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test_struct ) [EOL] y_true = np . full ( ( y_hat . shape [ [number] ] , self . y_test_3_trainig_proba . shape [ [number] ] ) , fill_value = self . y_test_3_trainig_proba ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_categorical_indices , self . X_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test ) [EOL] assert np . isclose ( y_hat , self . y_test_3_proba , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , False , self . X , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_categorical_indices , self . X_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test ) [EOL] y_true = np . full ( ( y_hat . shape [ [number] ] , self . y_test_3_trainig_proba . shape [ [number] ] ) , fill_value = self . y_test_3_trainig_proba ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test_struct ) [EOL] assert np . isclose ( y_hat , self . y_test_3_proba , atol = [number] ) . all ( ) [EOL] [comment] [EOL] k = [number] [EOL] clf = fumm . KNN ( k = k ) [EOL] self . _test_unfitted_internals ( clf , init_k = k , init_is_classifier = True ) [EOL] clf . fit ( self . X_struct , self . y_categorical ) [EOL] self . _test_fitted_internals ( clf , True , self . X_struct , self . y_categorical , self . X_n , self . majority_label_categorical , self . X_struct_categorical_indices , self . X_struct_numerical_indices , self . unique_y_categorical , self . unique_y_counts , self . unique_y_probabilities ) [EOL] y_hat = clf . predict_proba ( self . X_test_struct ) [EOL] y_true = np . full ( ( y_hat . shape [ [number] ] , self . y_test_3_trainig_proba . shape [ [number] ] ) , fill_value = self . y_test_3_trainig_proba ) [EOL] assert np . isclose ( y_hat , y_true , atol = [number] ) . all ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . models . validation as fumv [EOL] [EOL] [EOL] def test_check_model_functionality ( ) : [EOL] [docstring] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class ClassPlain ( object ) : pass [EOL] class_plain = ClassPlain ( ) [EOL] class ClassObject ( object ) : pass [EOL] class_object = ClassObject ( ) [EOL] class ClassInit0 ( object ) : [EOL] def __init__ ( self ) : pass [EOL] class_init_0 = ClassInit0 ( ) [EOL] class ClassInit1 ( object ) : [EOL] def __init__ ( self , one ) : pass [EOL] class_init_1 = ClassInit1 ( [number] ) [EOL] class ClassFit0 ( object ) : [EOL] def fit ( self ) : pass [EOL] class_fit_0 = ClassFit0 ( ) [EOL] class ClassFit1 ( object ) : [EOL] def fit ( self , one ) : pass [EOL] class_fit_1 = ClassFit1 ( ) [EOL] class ClassFit11 ( object ) : [EOL] def fit ( self , one , two = [number] ) : pass [EOL] class_fit_11 = ClassFit11 ( ) [EOL] class ClassFit2 ( object ) : [EOL] def fit ( self , one , two ) : pass [EOL] class_fit_2 = ClassFit2 ( ) [EOL] class ClassFit21 ( object ) : [EOL] def fit ( self , one , two , three = [number] ) : pass [EOL] class_fit_21 = ClassFit21 ( ) [EOL] class ClassFit3 ( object ) : [EOL] def fit ( self , one , two , three ) : pass [EOL] class_fit_3 = ClassFit3 ( ) [EOL] class ClassPredict0 ( object ) : [EOL] def predict ( self ) : pass [EOL] class_predict_0 = ClassPredict0 ( ) [EOL] class ClassPredict1 ( object ) : [EOL] def predict ( self , one ) : pass [EOL] class_predict_1 = ClassPredict1 ( ) [EOL] class ClassPredict2 ( object ) : [EOL] def predict ( self , one , two ) : pass [EOL] class_predict_2 = ClassPredict2 ( ) [EOL] class ClassPredictProba0 ( object ) : [EOL] def predict_proba ( self ) : pass [EOL] class_predict_proba_0 = ClassPredictProba0 ( ) [EOL] class ClassPredictProba1 ( object ) : [EOL] def predict_proba ( self , one ) : pass [EOL] class_predict_proba_1 = ClassPredictProba1 ( ) [EOL] class ClassPredictProba2 ( object ) : [EOL] def predict_proba ( self , one , two ) : pass [EOL] class_predict_proba_2 = ClassPredictProba2 ( ) [EOL] [EOL] class ClassFit11Predict1 ( ClassFit11 , ClassPredict1 ) : pass [EOL] class_fit_11_predict_1 = ClassFit11Predict1 ( ) [EOL] class ClassFit21Predict1 ( ClassFit21 , ClassPredict1 ) : pass [EOL] class_fit_21_predict_1 = ClassFit21Predict1 ( ) [EOL] [EOL] class ClassFit1Predict2 ( ClassFit1 , ClassPredict2 ) : pass [EOL] class_fit_1_predict_2 = ClassFit1Predict2 ( ) [EOL] class ClassFit3Predict0 ( ClassFit3 , ClassPredict0 ) : pass [EOL] class_fit_3_predict_0 = ClassFit3Predict0 ( ) [EOL] class ClassFit3Predict1PredictProba0 ( ClassFit3 , ClassPredict1 , ClassPredictProba0 ) : [EOL] pass [EOL] class_fit_3_predict_1_predict_proba_0 = ClassFit3Predict1PredictProba0 ( ) [EOL] [EOL] class ClassFit2Predict1 ( ClassFit2 , ClassPredict1 ) : pass [EOL] class_fit_2_predict_1 = ClassFit2Predict1 ( ) [EOL] class ClassFit2Predict1PredictProba1 ( ClassFit2 , ClassPredict1 , ClassPredictProba1 ) : [EOL] pass [EOL] class_fit_2_predict_1_predict_proba_1 = ClassFit2Predict1PredictProba1 ( ) [EOL] class ClassFit2Predict1PredictProba0 ( ClassFit2 , ClassPredict1 , ClassPredictProba0 ) : [EOL] pass [EOL] class_fit_2_predict_1_predict_proba_0 = ClassFit2Predict1PredictProba0 ( ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] require_probabilities_error = ( [string] [string] ) [EOL] suppress_warning_error = [string] [EOL] with pytest . raises ( TypeError ) as error : [EOL] fumv . check_model_functionality ( class_plain , require_probabilities = [string] ) [EOL] assert str ( error . value ) == require_probabilities_error [EOL] with pytest . raises ( TypeError ) as error : [EOL] fumv . check_model_functionality ( class_plain , require_probabilities = [string] , suppress_warning = [string] ) [EOL] assert str ( error . value ) == require_probabilities_error [EOL] with pytest . raises ( TypeError ) as error : [EOL] fumv . check_model_functionality ( class_plain , require_probabilities = True , suppress_warning = [string] ) [EOL] assert str ( error . value ) == suppress_warning_error [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( class_plain , True , False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] assert ( [string] in w_message and [string] in w_message [EOL] and [string] in w_message ) [EOL] [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_plain , True , True ) is False [EOL] [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_11_predict_1 , suppress_warning = True ) is False [EOL] assert fumv . check_model_functionality ( class_fit_21_predict_1 ) is True [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( class_fit_1_predict_2 , suppress_warning = False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] m_message_1 = ( [string] [string] [string] [string] ) [EOL] m_message_2 = ( [string] [string] [string] [string] [string] ) [EOL] assert m_message_1 in w_message and m_message_2 in w_message [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( ClassFit1Predict2 , suppress_warning = False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] assert m_message_1 in w_message and m_message_2 in w_message [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( class_fit_3_predict_0 , suppress_warning = False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] m_message_1 = ( [string] [string] [string] [string] ) [EOL] m_message_2 = ( [string] [string] [string] [string] [string] ) [EOL] assert m_message_1 in w_message and m_message_2 in w_message [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( ClassFit3Predict0 , suppress_warning = False ) is False [EOL] assert m_message_1 in w_message and m_message_2 in w_message [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( class_fit_3_predict_0 , True , False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] m_message_1 = ( [string] [string] [string] [string] ) [EOL] m_message_2 = ( [string] [string] [string] [string] [string] ) [EOL] assert ( m_message_1 in w_message and m_message_2 in w_message [EOL] and [string] in w_message ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fumv . check_model_functionality ( ClassFit3Predict0 , True , False ) is False [EOL] w_message = str ( warning [ [number] ] . message ) [EOL] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1_predict_proba_0 ) is True [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1PredictProba0 ) is True [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1_predict_proba_0 , True , suppress_warning = True ) is False [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1PredictProba0 , True , suppress_warning = True ) is False [EOL] [comment] [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_3_predict_1_predict_proba_0 , suppress_warning = True ) is False [EOL] assert fumv . check_model_functionality ( ClassFit3Predict1PredictProba0 , suppress_warning = True ) is False [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_3_predict_1_predict_proba_0 , True , suppress_warning = True ) is False [EOL] assert fumv . check_model_functionality ( ClassFit3Predict1PredictProba0 , True , suppress_warning = True ) is False [EOL] [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1 ) is True [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1 ) is True [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1 , True , suppress_warning = True ) is False [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1 , True , suppress_warning = True ) is False [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1_predict_proba_1 , False ) is True [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1PredictProba1 , False ) is True [EOL] [comment] [EOL] assert fumv . check_model_functionality ( class_fit_2_predict_1_predict_proba_1 , True ) is True [EOL] assert fumv . check_model_functionality ( ClassFit2Predict1PredictProba1 , True ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . validation as fuv [EOL] [EOL] [EOL] def test_get_required_parameters_number ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as error : [EOL] fuv . get_required_parameters_number ( [string] ) [EOL] assert str ( error . value ) == type_error [EOL] [EOL] def function1 ( ) : [EOL] pass [comment] [EOL] [EOL] def function2 ( x ) : [EOL] pass [comment] [EOL] [EOL] def function3 ( x , y ) : [EOL] pass [comment] [EOL] [EOL] def function4 ( x , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function5 ( x = [number] , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function6 ( x , ** kwargs ) : [EOL] pass [comment] [EOL] [EOL] assert fuv . get_required_parameters_number ( function1 ) == [number] [EOL] assert fuv . get_required_parameters_number ( function2 ) == [number] [EOL] assert fuv . get_required_parameters_number ( function3 ) == [number] [EOL] assert fuv . get_required_parameters_number ( function4 ) == [number] [EOL] assert fuv . get_required_parameters_number ( function5 ) == [number] [EOL] assert fuv . get_required_parameters_number ( function6 ) == [number] [EOL] [EOL] [EOL] def test_check_object_functionality ( ) : [EOL] [docstring] [EOL] methods_key_type_error = ( [string] [string] ) [EOL] methods_value_type_error = ( [string] [string] [string] ) [EOL] methods_value_value_error = ( [string] [string] [string] ) [EOL] methods_empty_value_error = [string] [EOL] methods_type_error = [string] [EOL] [comment] [EOL] reference_type_error = ( [string] [string] ) [EOL] [EOL] missing_callable = [string] [EOL] missing_param = ( [string] [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuv . check_object_functionality ( [string] , [string] , [number] ) [EOL] assert str ( exin . value ) == methods_type_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuv . check_object_functionality ( [string] , { } , [number] ) [EOL] assert str ( exin . value ) == methods_empty_value_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuv . check_object_functionality ( [string] , { [string] : [number] , [number] : [string] , [string] : [number] } , [number] ) [EOL] assert str ( exin . value ) == methods_key_type_error . format ( [number] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuv . check_object_functionality ( [string] , { [string] : [string] , [number] : [string] , [string] : [number] } , [number] ) [comment] [EOL] assert str ( exin . value ) == methods_value_type_error . format ( [number] , [number] ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuv . check_object_functionality ( [string] , { [string] : [number] , [string] : - [number] , [string] : [number] } , [number] ) [comment] [EOL] assert str ( exin . value ) == methods_value_value_error . format ( - [number] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuv . check_object_functionality ( [string] , { [string] : [number] , [string] : [number] , [string] : [number] } , [number] ) [EOL] assert str ( exin . value ) == reference_type_error [EOL] [EOL] class A ( object ) : [EOL] pass [EOL] [EOL] class B ( A ) : [EOL] def zero ( self ) : [EOL] pass [comment] [EOL] [EOL] def one ( self , a , b = [number] ) : [EOL] pass [comment] [EOL] [EOL] class C ( B ) : [EOL] def zero ( self , a = [number] , b = [number] ) : [EOL] pass [comment] [EOL] [EOL] b = B ( ) [EOL] c = C ( ) [EOL] [EOL] is_functional , msg = fuv . check_object_functionality ( b , { [string] : [number] } ) [EOL] assert is_functional [EOL] assert msg == [string] [EOL] [EOL] is_functional , msg = fuv . check_object_functionality ( B , { [string] : [number] , [string] : [number] } , None ) [comment] [EOL] assert is_functional [EOL] assert msg == [string] [EOL] [EOL] is_functional , msg = fuv . check_object_functionality ( c , { [string] : [number] , [string] : [number] , [string] : [number] } , [string] ) [comment] [EOL] assert not is_functional [EOL] assert msg == missing_callable . format ( [string] , [string] ) [EOL] [EOL] is_functional , msg = fuv . check_object_functionality ( C , { [string] : [number] , [string] : [number] , [string] : [number] } , None ) [comment] [EOL] assert not is_functional [EOL] assert missing_callable . format ( [string] , [string] ) in msg [EOL] assert missing_param . format ( [string] , [string] , [number] , [number] ) in msg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . tools as fut [EOL] [EOL] [EOL] def test_at_least_verion ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] min_type_error = [string] [EOL] min_element_type_error = ( [string] [string] ) [EOL] curr_element_type_error = ( [string] [string] ) [EOL] current_type_error = [string] [EOL] min_value_error = [string] [EOL] current_value_error = [string] [EOL] length_value_error = ( [string] [string] ) [EOL] wrong_outer_types = [ None , [number] , [string] , { } , range ( [number] ) ] [EOL] wrong_inner_types = [ [ None , None ] , [ [string] , [string] ] , [ [number] , [string] ] , [ [number] , [number] ] , [ [number] + [number] , [number] + [number] , [number] ] ] [EOL] partially_wrong_inner_type_1 = [ [ None , [number] ] , [ [string] , [number] ] ] [EOL] partially_wrong_inner_type_2 = [ [ [number] , [string] ] , [ [number] , None ] ] [EOL] correct_inner_types = [ [ [number] ] , [ [number] , [number] ] ] [EOL] empty_inner_type = [ [ ] ] [EOL] [EOL] for i in wrong_outer_types : [EOL] for j in wrong_outer_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] [EOL] for j in wrong_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in partially_wrong_inner_type_1 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in partially_wrong_inner_type_2 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in correct_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == current_type_error [EOL] [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == current_type_error [EOL] [EOL] for i in wrong_inner_types : [EOL] for j in wrong_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in partially_wrong_inner_type_1 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in partially_wrong_inner_type_2 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in correct_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for i in partially_wrong_inner_type_1 : [EOL] for j in partially_wrong_inner_type_1 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in partially_wrong_inner_type_2 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , j [ [number] ] ) [EOL] [EOL] for j in correct_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for i in partially_wrong_inner_type_2 : [EOL] for j in partially_wrong_inner_type_2 : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in correct_inner_types : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_element_type_error . format ( [number] , i [ [number] ] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == curr_element_type_error . format ( [number] , i [ [number] ] ) [EOL] [EOL] assert len ( correct_inner_types ) == [number] , [string] [EOL] assert fut . at_least_verion ( correct_inner_types [ [number] ] , correct_inner_types [ [number] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( correct_inner_types [ [number] ] , correct_inner_types [ [number] ] ) [EOL] assert str ( exin . value ) == length_value_error [EOL] for i in correct_inner_types : [EOL] assert fut . at_least_verion ( i , i ) [EOL] [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == current_value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( j , i ) [EOL] assert str ( exin . value ) == min_value_error [EOL] [EOL] for i in empty_inner_type : [EOL] for j in empty_inner_type : [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( i , j ) [EOL] assert str ( exin . value ) == min_value_error [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert fut . at_least_verion ( [ [number] ] , [ [number] , [number] , [number] ] ) [EOL] assert fut . at_least_verion ( [ [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] assert not fut . at_least_verion ( [ [number] ] , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] ] ) [EOL] assert str ( exin . value ) == length_value_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] assert fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] ] ) [EOL] assert str ( exin . value ) == length_value_error [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] assert fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] assert fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] assert not fut . at_least_verion ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . kernels as fatf_kernels [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [string] , [string] , [string] ] ) [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] [EOL] [EOL] def test_input_is_valid ( ) : [EOL] [docstring] [EOL] structured_error = [string] [EOL] shape_error = [string] [EOL] type_error = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . _input_is_valid ( MIXED_ARRAY ) [EOL] assert str ( exin . value ) == structured_error [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fatf_kernels . _input_is_valid ( np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == shape_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . _input_is_valid ( CATEGORICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] assert fatf_kernels . _input_is_valid ( NUMERICAL_NP_ARRAY ) [EOL] assert fatf_kernels . _input_is_valid ( np . ones ( ( [number] , ) , dtype = np . int64 ) ) [EOL] [EOL] [EOL] def test_exponential_kernel ( ) : [EOL] [docstring] [EOL] width_type_err = [string] [EOL] width_value_err = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . exponential_kernel ( NUMERICAL_NP_ARRAY , [string] ) [EOL] assert str ( exin . value ) == width_type_err [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fatf_kernels . exponential_kernel ( NUMERICAL_NP_ARRAY , - [number] ) [EOL] assert str ( exin . value ) == width_value_err [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fatf_kernels . exponential_kernel ( NUMERICAL_NP_ARRAY , [number] ) [EOL] assert str ( exin . value ) == width_value_err [EOL] [EOL] results = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] kernelised = fatf_kernels . exponential_kernel ( NUMERICAL_NP_ARRAY , [number] ) [EOL] assert np . allclose ( kernelised , results , atol = [number] ) [EOL] [EOL] results = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] kernelised = fatf_kernels . exponential_kernel ( NUMERICAL_NP_ARRAY , [number] ) [EOL] assert np . allclose ( kernelised , results , atol = [number] ) [EOL] [EOL] results = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] kernelised = fatf_kernels . exponential_kernel ( np . ones ( [number] , ) , [number] ) [EOL] assert np . allclose ( kernelised , results , atol = [number] ) [EOL] [EOL] results = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] kernelised = fatf_kernels . exponential_kernel ( np . zeros ( [number] ) , [number] ) [EOL] assert np . allclose ( kernelised , results , atol = [number] ) [EOL] [EOL] [EOL] def test_check_kernel_functionality ( ) : [EOL] [docstring] [EOL] kernel_type_error = ( [string] [string] ) [EOL] suppress_type_error = [string] [EOL] [EOL] error_msg = ( [string] [string] [string] [string] ) [EOL] [EOL] def function1 ( ) : [EOL] pass [comment] [EOL] [EOL] def function2 ( x ) : [EOL] pass [comment] [EOL] [EOL] def function3 ( x , y ) : [EOL] pass [comment] [EOL] [EOL] def function4 ( x , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function5 ( x = [number] , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function6 ( x , ** kwargs ) : [EOL] pass [comment] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . check_kernel_functionality ( [string] ) [EOL] assert str ( exin . value ) == kernel_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . check_kernel_functionality ( [string] , [string] ) [EOL] assert str ( exin . value ) == kernel_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf_kernels . check_kernel_functionality ( function1 , [string] ) [EOL] assert str ( exin . value ) == suppress_type_error [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function1 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function1 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fatf_kernels . check_kernel_functionality ( function1 , True ) is False [EOL] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function5 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function5 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fatf_kernels . check_kernel_functionality ( function5 , True ) is False [EOL] [EOL] [comment] [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function3 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fatf_kernels . check_kernel_functionality ( function3 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fatf_kernels . check_kernel_functionality ( function3 , True ) is False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert fatf_kernels . check_kernel_functionality ( function2 ) is True [EOL] assert fatf_kernels . check_kernel_functionality ( function4 , False ) is True [EOL] assert fatf_kernels . check_kernel_functionality ( function6 , True ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . distances as fud [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] VECTOR_0D = np . array ( [number] , dtype = int ) [EOL] [EOL] VECTOR_1D_UNBASE_A1 = np . array ( [ None , object ( ) , None ] ) [EOL] [EOL] VECTOR_1D_NUMERICAL_A1 = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] VECTOR_1D_NUMERICAL_A2 = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCE_1D_NUMERICAL_A = [number] [EOL] DISTANCE_1D_A_BINARY = [number] [EOL] DISTANCE_1D_A_BINARY_NORMALISED = [number] [EOL] [EOL] VECTOR_1D_NUMERICAL_B1 = np . array ( [ [number] , [number] ] ) [EOL] VECTOR_1D_NUMERICAL_B2 = np . array ( [ [number] , [number] ] ) [EOL] DISTANCE_1D_NUMERICAL_B = [number] [EOL] [EOL] VECTOR_1D_CATEGORICAL_A1 = np . array ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] VECTOR_1D_CATEGORICAL_A2 = np . array ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] DISTANCE_1D_CATEGORICAL_A_BINARY = [number] [EOL] DISTANCE_1D_CATEGORICAL_A_BINARY_NORMALISED = [number] [EOL] DISTANCE_1D_CATEGORICAL_A_HAMMING = [number] [EOL] DISTANCES_1D_CATEGORICAL_A_HAMMING = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCE_1D_CATEGORICAL_A_HAMMING_NORMALISED = [number] [EOL] DISTANCES_1D_CATEGORICAL_A_HAMMING_NORMALISED = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] VECTORS_1D_A1 = np . array ( [ [ - [number] ] , [ - [number] ] , [ [number] ] , [ [number] ] , [ [number] ] ] ) [EOL] VECTORS_1D_A2 = np . array ( [ [ [number] ] , [ [number] ] , [ [number] ] , [ - [number] ] , [ - [number] ] ] ) [EOL] DISTANCES_1D_A = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCES_1D_A_BINARY = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCES_1D_A_BINARY_NORMALISED = DISTANCES_1D_A_BINARY [EOL] [EOL] VECTORS_1D_CATEGORICAL_A1 = np . array ( [ [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] ] ) [EOL] VECTORS_1D_CATEGORICAL_A2 = np . array ( [ [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] , [ [string] ] ] ) [EOL] DISTANCES_1D_CATEGORICAL_A = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCES_1D_CATEGORICAL_A_NORMALISED = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCES_1D_CATEGORICAL_A_BINARY = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] DISTANCES_1D_CATEGORICAL_A_BINARY_NORMALISED = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] VECTOR_2D_NUMERICAL_A1 = np . array ( [ [ - [number] , - [number] ] , [ [number] , [number] ] , [ [number] , - [number] ] ] ) [EOL] VECTOR_2D_NUMERICAL_A2 = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ - [number] , - [number] ] ] ) [EOL] VECTOR_2D_NUMERICAL_STRUCT_A1 = np . array ( [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] VECTOR_2D_NUMERICAL_STRUCT_A2 = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , - [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] DISTANCES_2D_NUMERICAL_A = np . array ( [ [ [number] , np . sqrt ( [number] ) , np . sqrt ( [number] ) ] , [ np . sqrt ( [number] ) , [number] , np . sqrt ( [number] ) ] , [ np . sqrt ( [number] ) , np . sqrt ( [number] ) , [number] ] ] ) [comment] [EOL] DISTANCES_2D_NUMERICAL_A_BINARY = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] [EOL] VECTOR_2D_CATEGORICAL_A1 = np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) [comment] [EOL] VECTOR_2D_CATEGORICAL_A2 = np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) [comment] [EOL] VECTOR_2D_CATEGORICAL_STRUCT_A1 = np . array ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] VECTOR_2D_CATEGORICAL_STRUCT_A2 = np . array ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] DISTANCES_2D_CATEGORICAL_A = np . array ( [ [ [number] + [number] , [number] + [number] , [number] + [number] ] , [ [number] + [number] , [number] + [number] , [number] + [number] ] , [ [number] + [number] , [number] + [number] , [number] + [number] ] ] ) [EOL] DISTANCES_2D_CATEGORICAL_A_NORMALISED = np . array ( [ [ [number] + [number] , [number] + [number] , [number] + [number] ] , [ [number] + [number] , [number] + [number] , [number] + [number] ] , [ [number] + [number] , [number] + [number] , [number] + [number] ] ] ) [EOL] DISTANCES_2D_CATEGORICAL_A_BINARY = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] [EOL] def test_euclidean_distance ( ) : [EOL] [docstring] [EOL] shape_error_x = [string] [EOL] shape_error_y = [string] [EOL] value_error_x = [string] [EOL] value_error_y = [string] [EOL] shape_error_xy = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_x [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_NUMERICAL_B1 ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_STRUCT_A1 [ [number] ] ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] [EOL] [comment] [EOL] assert ( ( VECTORS_1D_A1 . shape [ [number] ] == VECTORS_1D_A2 . shape [ [number] ] ) [EOL] and ( VECTORS_1D_A2 . shape [ [number] ] == DISTANCES_1D_A . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_1D_A . shape [ [number] ] ) : [EOL] dist = fud . euclidean_distance ( VECTORS_1D_A1 [ i ] , VECTORS_1D_A2 [ i ] ) [EOL] assert dist == DISTANCES_1D_A [ i ] [EOL] [EOL] dist = fud . euclidean_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_NUMERICAL_A2 ) [EOL] assert dist == pytest . approx ( DISTANCE_1D_NUMERICAL_A , rel = [number] ) [EOL] [EOL] dist = fud . euclidean_distance ( VECTOR_1D_NUMERICAL_B1 , VECTOR_1D_NUMERICAL_B2 ) [EOL] assert dist == pytest . approx ( DISTANCE_1D_NUMERICAL_B , rel = [number] ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) : [EOL] dist = fud . euclidean_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A [ i , i ] == pytest . approx ( dist ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) : [EOL] dist = fud . euclidean_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A [ i , i ] == pytest . approx ( dist ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [comment] [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) : [EOL] dist = fud . euclidean_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A [ i , i ] == pytest . approx ( dist ) [EOL] dist = fud . euclidean_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A [ i , i ] == pytest . approx ( dist ) [EOL] [EOL] [comment] [EOL] dist = fud . euclidean_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ [ [string] ] ] [ [number] ] ) [EOL] assert dist == [number] [EOL] [EOL] [EOL] def test_euclidean_point_distance ( ) : [EOL] [docstring] [EOL] shape_error_y = [string] [EOL] shape_error_X = [string] [EOL] value_error_y = [string] [EOL] value_error_X = [string] [EOL] shape_error_yX = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_y [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert str ( exin . value ) == value_error_X [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ [number] ] , DISTANCES_2D_NUMERICAL_A ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ i , : ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ : , i ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ i , : ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ : , i ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ i , : ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A [ : , i ] , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] dist = fud . euclidean_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ [ [string] ] ] ) [EOL] assert np . array_equal ( dist , [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_euclidean_array_distance ( ) : [EOL] [docstring] [EOL] shape_error_X = [string] [EOL] shape_error_Y = [string] [EOL] value_error_X = [string] [EOL] value_error_Y = [string] [EOL] shape_error_XY = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_X [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert str ( exin . value ) == value_error_Y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( DISTANCES_2D_NUMERICAL_A , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , DISTANCES_2D_NUMERICAL_A ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A , dist , rtol = [number] ) . all ( ) [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A . T , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A , dist , rtol = [number] ) . all ( ) [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A . T , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [comment] [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A , dist , rtol = [number] ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A . shape [ [number] ] ) ) [comment] [EOL] dist = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A . T , dist , rtol = [number] ) . all ( ) [EOL] [EOL] [EOL] def test_hamming_distance_base ( ) : [EOL] [docstring] [EOL] type_error_x = [string] [EOL] type_error_y = [string] [EOL] value_error = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . hamming_distance_base ( None , [string] ) [EOL] assert str ( exin . value ) == type_error_x [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . hamming_distance_base ( [string] , None ) [EOL] assert str ( exin . value ) == type_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance_base ( [string] , [string] , equal_length = True ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] dist = fud . hamming_distance_base ( [string] , [string] , equal_length = False ) [EOL] assert dist == [number] [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_1D_CATEGORICAL_A1 . shape [ [number] ] == VECTOR_1D_CATEGORICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_1D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A_HAMMING . shape [ [number] ] ) [EOL] and ( DISTANCES_1D_CATEGORICAL_A_HAMMING . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A_HAMMING_NORMALISED . shape [ [number] ] ) ) [comment] [EOL] [EOL] [comment] [EOL] for i in range ( VECTOR_1D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] ) [EOL] assert DISTANCES_1D_CATEGORICAL_A_HAMMING [ i ] == dist [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = False , equal_length = False ) [EOL] assert DISTANCES_1D_CATEGORICAL_A_HAMMING [ i ] == dist [EOL] [EOL] [comment] [EOL] for i in range ( VECTOR_1D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = True ) [EOL] assert ( DISTANCES_1D_CATEGORICAL_A_HAMMING_NORMALISED [ i ] == pytest . approx ( dist , rel = [number] ) ) [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = True , equal_length = False ) [EOL] assert ( DISTANCES_1D_CATEGORICAL_A_HAMMING_NORMALISED [ i ] == pytest . approx ( dist , rel = [number] ) ) [EOL] [EOL] [comment] [EOL] for i in range ( VECTOR_1D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] if ( len ( VECTOR_1D_CATEGORICAL_A1 [ i ] ) == len ( VECTOR_1D_CATEGORICAL_A2 [ i ] ) ) : [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , equal_length = True ) [EOL] assert DISTANCES_1D_CATEGORICAL_A_HAMMING [ i ] == dist [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = False , equal_length = True ) [EOL] assert DISTANCES_1D_CATEGORICAL_A_HAMMING [ i ] == dist [EOL] else : [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , equal_length = True ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = False , equal_length = True ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] for i in range ( VECTOR_1D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] if ( len ( VECTOR_1D_CATEGORICAL_A1 [ i ] ) == len ( VECTOR_1D_CATEGORICAL_A2 [ i ] ) ) : [EOL] dist = fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = True , equal_length = True ) [EOL] assert ( DISTANCES_1D_CATEGORICAL_A_HAMMING_NORMALISED [ i ] == pytest . approx ( dist , rel = [number] ) ) [EOL] else : [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance_base ( VECTOR_1D_CATEGORICAL_A1 [ i ] , VECTOR_1D_CATEGORICAL_A2 [ i ] , normalise = True , equal_length = True ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [EOL] def test_hamming_distance ( ) : [EOL] [docstring] [EOL] shape_error_x = [string] [EOL] shape_error_y = [string] [EOL] value_error_x = [string] [EOL] value_error_y = [string] [EOL] shape_error_xy = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_x [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTORS_1D_CATEGORICAL_A1 [ [number] ] ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_distance ( VECTORS_1D_CATEGORICAL_A1 [ [number] ] , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] [EOL] [comment] [EOL] dist = fud . hamming_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A2 ) [EOL] assert dist == DISTANCE_1D_CATEGORICAL_A_HAMMING [EOL] dist = fud . hamming_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A2 , normalise = True ) [EOL] assert dist == pytest . approx ( DISTANCE_1D_CATEGORICAL_A_HAMMING_NORMALISED , rel = [number] ) [EOL] [EOL] assert ( ( VECTORS_1D_CATEGORICAL_A1 . shape [ [number] ] == VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_1D_CATEGORICAL_A . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance ( VECTORS_1D_CATEGORICAL_A1 [ i ] , VECTORS_1D_CATEGORICAL_A2 [ i ] ) [EOL] assert dist == DISTANCES_1D_CATEGORICAL_A [ i ] [EOL] [EOL] assert ( ( VECTORS_1D_CATEGORICAL_A1 . shape [ [number] ] == VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_1D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance ( VECTORS_1D_CATEGORICAL_A1 [ i ] , VECTORS_1D_CATEGORICAL_A2 [ i ] , normalise = True ) [EOL] assert dist == DISTANCES_1D_CATEGORICAL_A_NORMALISED [ i ] [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_CATEGORICAL_A [ i , i ] == dist [EOL] dist = fud . hamming_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , i ] == dist [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) : [EOL] dist = fud . hamming_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_CATEGORICAL_A [ i , i ] == dist [EOL] dist = fud . hamming_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , i ] == dist [EOL] [EOL] [comment] [EOL] dist = fud . hamming_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ [ [string] ] ] [ [number] ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] ) [EOL] assert dist == [number] [EOL] [EOL] [EOL] def test_hamming_point_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] shape_error_y = [string] [EOL] shape_error_X = [string] [EOL] value_error_y = [string] [EOL] value_error_X = [string] [EOL] shape_error_yX = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert str ( exin . value ) == value_error_y [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_X [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [number] ] , VECTORS_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ i , : ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ : , i ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ i , : ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ : , i ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ i , : ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ : , i ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ i , : ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A [ : , i ] , dist ) . all ( ) [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] dist = fud . hamming_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ [ [string] ] ] [ [number] ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [ [string] ] ] ) [EOL] assert np . array_equal ( dist , [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_hamming_array_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] shape_error_X = [string] [EOL] shape_error_Y = [string] [EOL] value_error_X = [string] [EOL] value_error_Y = [string] [EOL] shape_error_XY = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == value_error_X [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert str ( exin . value ) == value_error_Y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTORS_1D_CATEGORICAL_A2 ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . hamming_array_distance ( VECTORS_1D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A . T , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A . T , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A . T , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A . T , dist ) . all ( ) [EOL] dist = fud . hamming_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [EOL] def test_binary_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] shape_error_x = [string] [EOL] shape_error_y = [string] [EOL] shape_error_xy = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_0D , VECTOR_1D_UNBASE_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_x [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTORS_1D_CATEGORICAL_A1 [ [number] ] ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTORS_1D_CATEGORICAL_A1 [ [number] ] , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_NUMERICAL_B1 ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_STRUCT_A1 [ [number] ] ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTORS_1D_CATEGORICAL_A1 [ [number] ] ) [EOL] assert str ( exin . value ) == shape_error_xy [EOL] [EOL] [comment] [EOL] dist = fud . binary_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A2 ) [EOL] assert dist == DISTANCE_1D_CATEGORICAL_A_BINARY [EOL] dist = fud . binary_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A2 , normalise = True ) [EOL] assert dist == DISTANCE_1D_CATEGORICAL_A_BINARY_NORMALISED [EOL] [EOL] dist = fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_NUMERICAL_A2 ) [EOL] assert dist == DISTANCE_1D_A_BINARY [EOL] dist = fud . binary_distance ( VECTOR_1D_NUMERICAL_A1 , VECTOR_1D_NUMERICAL_A2 , normalise = True ) [EOL] assert dist == DISTANCE_1D_A_BINARY_NORMALISED [EOL] [EOL] assert ( ( VECTORS_1D_CATEGORICAL_A1 . shape [ [number] ] == VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTORS_1D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_1D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_1D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_1D_CATEGORICAL_A . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTORS_1D_CATEGORICAL_A1 [ i ] , VECTORS_1D_CATEGORICAL_A2 [ i ] ) [EOL] assert dist == DISTANCES_1D_CATEGORICAL_A_BINARY [ i ] [EOL] dist = fud . binary_distance ( VECTORS_1D_CATEGORICAL_A1 [ i ] , VECTORS_1D_CATEGORICAL_A2 [ i ] , normalise = True ) [EOL] assert dist == DISTANCES_1D_CATEGORICAL_A_BINARY_NORMALISED [ i ] [EOL] [EOL] assert ( ( VECTORS_1D_A1 . shape [ [number] ] == VECTORS_1D_A2 . shape [ [number] ] ) [EOL] and ( VECTORS_1D_A2 . shape [ [number] ] == DISTANCES_1D_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_1D_A_BINARY . shape [ [number] ] == DISTANCES_1D_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_1D_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTORS_1D_A1 [ i ] , VECTORS_1D_A2 [ i ] ) [EOL] assert dist == DISTANCES_1D_A_BINARY [ i ] [EOL] dist = fud . binary_distance ( VECTORS_1D_A1 [ i ] , VECTORS_1D_A2 [ i ] , normalise = True ) [EOL] assert dist == DISTANCES_1D_A_BINARY_NORMALISED [ i ] [EOL] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [comment] [EOL] for i in range ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 [ i ] ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) : [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY [ i , i ] == dist [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 [ i ] , normalise = True ) [EOL] assert DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , i ] == dist [EOL] [EOL] [comment] [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ [ [string] ] ] [ [number] ] ) [EOL] assert dist == [number] [EOL] dist = fud . binary_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] , VECTOR_2D_NUMERICAL_STRUCT_A2 [ [ [string] ] ] [ [number] ] ) [EOL] assert dist == [number] [EOL] [EOL] [EOL] def test_binary_point_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] shape_error_y = [string] [EOL] shape_error_X = [string] [EOL] shape_error_yX = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [number] ] , VECTORS_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [number] ] , VECTORS_1D_A1 ) [EOL] assert str ( exin . value ) == shape_error_yX [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A2 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ i ] , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 [ i ] , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A2 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ i , : ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 [ i ] , VECTOR_2D_NUMERICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ i , : ] , dist ) . all ( ) [EOL] for i in range ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] ) : [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY [ : , i ] , dist ) . all ( ) [EOL] dist = fud . binary_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 [ i ] , VECTOR_2D_NUMERICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED [ : , i ] , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] dist = fud . binary_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [ [string] ] ] [ [number] ] , VECTOR_2D_CATEGORICAL_STRUCT_A1 [ [ [string] ] ] ) [EOL] assert np . array_equal ( dist , [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_binary_array_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] shape_error_X = [string] [EOL] shape_error_Y = [string] [EOL] shape_error_XY = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTOR_1D_CATEGORICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTOR_0D , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_X [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_0D ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_1D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_Y [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTORS_1D_CATEGORICAL_A2 ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . binary_array_distance ( VECTORS_1D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert str ( exin . value ) == shape_error_XY [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [comment] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A2 , VECTOR_2D_CATEGORICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_CATEGORICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_CATEGORICAL_A2 . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_CATEGORICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A2 , VECTOR_2D_CATEGORICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_CATEGORICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_STRUCT_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A2 , VECTOR_2D_NUMERICAL_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] assert ( ( VECTOR_2D_NUMERICAL_STRUCT_A1 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) [EOL] and ( VECTOR_2D_NUMERICAL_A2 . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] ) [EOL] and ( DISTANCES_2D_NUMERICAL_A_BINARY . shape [ [number] ] == DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . shape [ [number] ] ) ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_A2 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_A2 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY . T , dist ) . all ( ) [EOL] dist = fud . binary_array_distance ( VECTOR_2D_NUMERICAL_A2 , VECTOR_2D_NUMERICAL_STRUCT_A1 , normalise = True ) [EOL] assert np . isclose ( DISTANCES_2D_NUMERICAL_A_BINARY_NORMALISED . T , dist ) . all ( ) [EOL] [EOL] [EOL] def test_get_distance_matrix ( ) : [EOL] [docstring] [EOL] shape_error_data = ( [string] [string] ) [EOL] type_error_data = ( [string] [string] ) [EOL] type_error_func = ( [string] [string] ) [EOL] attribute_error_func = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . get_distance_matrix ( VECTOR_0D , None ) [EOL] assert str ( exin . value ) == shape_error_data [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_distance_matrix ( np . array ( [ [ None ] ] ) , None ) [EOL] assert str ( exin . value ) == type_error_data [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_distance_matrix ( VECTOR_2D_CATEGORICAL_A1 , None ) [EOL] assert str ( exin . value ) == type_error_func [EOL] [EOL] def bad_distance ( x ) : [EOL] return x + [number] [comment] [EOL] [EOL] with pytest . raises ( AttributeError ) as exin : [EOL] fud . get_distance_matrix ( VECTOR_2D_CATEGORICAL_A1 , bad_distance ) [EOL] assert str ( exin . value ) == attribute_error_func . format ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] true_distances = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A1 ) [EOL] [comment] [EOL] distances = fud . get_distance_matrix ( VECTOR_2D_NUMERICAL_A1 , fud . euclidean_distance ) [EOL] assert np . allclose ( distances , true_distances , atol = [number] ) [EOL] [EOL] [comment] [EOL] def struct_dist ( x , y ) : [EOL] return fud . euclidean_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] [EOL] distances = fud . get_distance_matrix ( VECTOR_2D_NUMERICAL_STRUCT_A1 , struct_dist ) [EOL] assert np . allclose ( distances , true_distances , atol = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] true_distances = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A1 ) [EOL] [comment] [EOL] distances = fud . get_distance_matrix ( VECTOR_2D_CATEGORICAL_A1 , fud . binary_distance ) [EOL] assert np . allclose ( distances , true_distances , atol = [number] ) [EOL] [EOL] [comment] [EOL] def struct_dist ( x , y ) : [EOL] return fud . binary_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] [EOL] distances = fud . get_distance_matrix ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , struct_dist ) [EOL] assert np . allclose ( distances , true_distances , atol = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] mixed_array = np . array ( [ ( [string] , [number] , [string] , [number] ) , ( [string] , [number] , [string] , [number] ) , ( [string] , [number] , [string] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , int ) , ( [string] , [string] ) , ( [string] , int ) ] ) [comment] [EOL] true_distances = np . array ( [ [ [number] , [number] + [number] + np . sqrt ( [number] ) , [number] + [number] + np . sqrt ( [number] ) ] , [ [number] + [number] + np . sqrt ( [number] ) , [number] , [number] + [number] + np . sqrt ( [number] ) ] , [ [number] + [number] + np . sqrt ( [number] ) , [number] + [number] + np . sqrt ( [number] ) , [number] ] ] ) [EOL] [EOL] def mix_dist ( x , y ) : [EOL] num = fud . euclidean_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] cat = fud . binary_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] return num + cat [EOL] [EOL] distances = fud . get_distance_matrix ( mixed_array , mix_dist ) [EOL] assert np . allclose ( distances , true_distances , atol = [number] ) [EOL] [EOL] [EOL] def test_get_point_distance ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] shape_error_data_point = ( [string] [string] ) [EOL] shape_error_columns = ( [string] [string] ) [EOL] type_error_base = ( [string] [string] ) [EOL] type_error_dtype = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A1 , fud . binary_distance ) [EOL] assert str ( exin . value ) == shape_error_data_point [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_NUMERICAL_A1 , np . array ( [ [number] , [number] , [number] ] ) , fud . binary_distance ) [EOL] assert str ( exin . value ) == shape_error_columns [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_NUMERICAL_A1 , np . array ( [ [number] , None , [number] ] ) , fud . binary_distance ) [EOL] assert str ( exin . value ) == type_error_base [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_NUMERICAL_A1 , np . array ( [ [number] , [string] , [number] ] ) , fud . binary_distance ) [EOL] assert str ( exin . value ) == type_error_dtype [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , np . array ( [ [number] , [string] , [number] ] ) , fud . binary_distance ) [EOL] assert str ( exin . value ) == type_error_dtype [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . get_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_STRUCT_A1 [ [number] ] , fud . binary_distance ) [EOL] assert str ( exin . value ) == type_error_dtype [EOL] [EOL] [comment] [EOL] [EOL] true_distances = fud . euclidean_array_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A2 ) [EOL] [comment] [EOL] distance = fud . get_point_distance ( VECTOR_2D_NUMERICAL_A1 , VECTOR_2D_NUMERICAL_A2 [ [number] ] , fud . euclidean_distance ) [EOL] assert np . allclose ( distance , true_distances [ : , [number] ] , atol = [number] ) [EOL] [EOL] [comment] [EOL] def struct_dist ( x , y ) : [EOL] return fud . euclidean_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] [EOL] distance = fud . get_point_distance ( VECTOR_2D_NUMERICAL_STRUCT_A1 , VECTOR_2D_NUMERICAL_STRUCT_A2 [ [number] ] , struct_dist ) [EOL] assert np . allclose ( distance , true_distances [ : , [number] ] , atol = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] true_distances = fud . binary_array_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 ) [EOL] [comment] [EOL] distance = fud . get_point_distance ( VECTOR_2D_CATEGORICAL_A1 , VECTOR_2D_CATEGORICAL_A2 [ [number] ] , fud . binary_distance ) [EOL] assert np . allclose ( distance , true_distances [ : , [number] ] , atol = [number] ) [EOL] [EOL] [comment] [EOL] def struct_dist ( x , y ) : [EOL] return fud . binary_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] [EOL] distance = fud . get_point_distance ( VECTOR_2D_CATEGORICAL_STRUCT_A1 , VECTOR_2D_CATEGORICAL_STRUCT_A2 [ [number] ] , struct_dist ) [EOL] assert np . allclose ( distance , true_distances [ : , [number] ] , atol = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] mixed_array = np . array ( [ ( [string] , [number] , [string] , [number] ) , ( [string] , [number] , [string] , [number] ) , ( [string] , [number] , [string] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , int ) , ( [string] , [string] ) , ( [string] , int ) ] ) [comment] [EOL] true_distances = np . array ( [ [ [number] , [number] + [number] + np . sqrt ( [number] ) , [number] + [number] + np . sqrt ( [number] ) ] , [ [number] + [number] + np . sqrt ( [number] ) , [number] , [number] + [number] + np . sqrt ( [number] ) ] , [ [number] + [number] + np . sqrt ( [number] ) , [number] + [number] + np . sqrt ( [number] ) , [number] ] ] ) [EOL] [EOL] def mix_dist ( x , y ) : [EOL] num = fud . euclidean_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] cat = fud . binary_distance ( np . array ( [ x [ [string] ] , x [ [string] ] ] ) , np . array ( [ y [ [string] ] , y [ [string] ] ] ) ) [EOL] return num + cat [EOL] [EOL] distance = fud . get_point_distance ( mixed_array , mixed_array [ [number] ] , mix_dist ) [EOL] assert np . allclose ( distance , true_distances [ [number] ] , atol = [number] ) [EOL] [EOL] [EOL] def test_check_distance_functionality ( ) : [EOL] [docstring] [EOL] distance_type_error = ( [string] [string] ) [EOL] suppress_type_error = [string] [EOL] [EOL] error_msg = ( [string] [string] [string] [string] ) [EOL] [EOL] def function1 ( ) : [EOL] pass [comment] [EOL] [EOL] def function2 ( x ) : [EOL] pass [comment] [EOL] [EOL] def function3 ( x , y ) : [EOL] pass [comment] [EOL] [EOL] def function4 ( x , y , z = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function5 ( x = [number] , y = [number] ) : [EOL] pass [comment] [EOL] [EOL] def function6 ( x , y , ** kwargs ) : [EOL] pass [comment] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . check_distance_functionality ( [string] ) [EOL] assert str ( exin . value ) == distance_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . check_distance_functionality ( [string] , [string] ) [EOL] assert str ( exin . value ) == distance_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fud . check_distance_functionality ( function1 , [string] ) [EOL] assert str ( exin . value ) == suppress_type_error [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function1 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function1 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fud . check_distance_functionality ( function1 , True ) is False [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function5 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function5 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fud . check_distance_functionality ( function5 , True ) is False [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function2 ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fud . check_distance_functionality ( function2 , False ) is False [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == error_msg . format ( [string] , [number] ) [EOL] [comment] [EOL] assert fud . check_distance_functionality ( function2 , True ) is False [EOL] [EOL] assert fud . check_distance_functionality ( function3 ) is True [EOL] assert fud . check_distance_functionality ( function4 , True ) is True [EOL] assert fud . check_distance_functionality ( function6 , False ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Iterator [EOL] import _importlib_modulespec [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import contextlib [EOL] import sys [EOL] [EOL] from typing import Iterator [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] @ contextlib . contextmanager def module_import_tester ( module_name , when_missing = True ) : [EOL] [docstring] [EOL] action = [number] [EOL] [EOL] [comment] [EOL] if when_missing : [EOL] sys_path_backup = sys . path [EOL] sys . path = [ ] [EOL] action = [number] [EOL] if module_name in sys . modules : [EOL] module_backup = sys . modules [ module_name ] [EOL] del sys . modules [ module_name ] [EOL] action = [number] [EOL] [comment] [EOL] elif not when_missing and module_name not in sys . modules : [EOL] sys . modules [ module_name ] = sys . modules [ [string] ] [EOL] action = [number] [EOL] [EOL] [comment] [EOL] yield [EOL] [EOL] [comment] [EOL] if action in ( [number] , [number] ) : [EOL] sys . path = sys_path_backup [EOL] if action == [number] : [EOL] sys . modules [ module_name ] = module_backup [EOL] elif action == [number] : [EOL] del sys . modules [ module_name ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Tuple , Any , List , Iterable , Union [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , Iterable , List , Tuple , Union [EOL] [EOL] import numpy as np [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] ExplanationList = Dict [ str , List [ Tuple [ str , Union [ Iterable [ float ] , float ] ] ] ] [EOL] ExplanationDict = Dict [ str , Dict [ Union [ str , int ] , Union [ Iterable [ float ] , float ] ] ] [EOL] [EOL] [comment] [EOL] LABELS = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , int ) , ( [string] , float ) , ( [string] , float ) ] ) [EOL] [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [comment] [EOL] [EOL] [EOL] class InvalidModel ( object ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] [EOL] def fit ( self , data , targets ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NonProbabilisticModel ( InvalidModel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , prediction_function ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . prediction_function = prediction_function [EOL] [EOL] def predict ( self , data ) : [EOL] [docstring] [EOL] return self . prediction_function ( data ) [EOL] [EOL] [EOL] def is_explanation_equal_list ( dict1 , dict2 , atol = [number] ) : [EOL] [docstring] [EOL] if set ( dict1 . keys ( ) ) == set ( dict2 . keys ( ) ) : [EOL] equal = True [EOL] for key in dict1 : [EOL] val1 = sorted ( dict1 [ key ] ) [EOL] val2 = sorted ( dict2 [ key ] ) [EOL] [EOL] if len ( val1 ) != len ( val2 ) : [EOL] equal = False [EOL] break [EOL] [EOL] for i , val1_i in enumerate ( val1 ) : [EOL] if val1_i [ [number] ] != val2 [ i ] [ [number] ] : [EOL] equal = False [EOL] break [EOL] is_close = np . allclose ( val1_i [ [number] ] , val2 [ i ] [ [number] ] , atol = atol , equal_nan = True ) [EOL] if not is_close : [EOL] equal = False [EOL] break [EOL] [EOL] if not equal : [EOL] break [EOL] else : [EOL] equal = False [EOL] return equal [EOL] [EOL] [EOL] def is_explanation_equal_dict ( dict1 , dict2 , atol = [number] ) : [EOL] [docstring] [EOL] if set ( dict1 . keys ( ) ) == set ( dict2 . keys ( ) ) : [EOL] equal = True [EOL] for outer_key in dict1 : [EOL] inner_dict1 = dict1 [ outer_key ] [EOL] inner_dict2 = dict2 [ outer_key ] [EOL] [EOL] if set ( inner_dict1 . keys ( ) ) == set ( inner_dict2 . keys ( ) ) : [EOL] for inner_key in inner_dict1 . keys ( ) : [EOL] val1 = inner_dict1 [ inner_key ] [EOL] val2 = inner_dict2 [ inner_key ] [EOL] [EOL] if not np . allclose ( val1 , val2 , atol = atol , equal_nan = True ) : [EOL] equal = False [EOL] break [EOL] else : [EOL] equal = False [EOL] break [EOL] [EOL] if not equal : [EOL] break [EOL] else : [EOL] equal = False [EOL] return equal [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Tuple [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import matplotlib [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Union [EOL] [EOL] import numpy as np [EOL] [EOL] try : [EOL] import matplotlib . lines [EOL] import matplotlib . pyplot as plt [EOL] except ImportError : [EOL] raise ImportError ( [string] [string] [string] ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def get_plot_data ( plot_axis ) : [EOL] [docstring] [EOL] assert isinstance ( plot_axis , plt . Axes ) , [string] [EOL] [EOL] plot_title = plot_axis . get_title ( ) [EOL] plot_x_label = plot_axis . xaxis . get_label_text ( ) [EOL] plot_x_range = plot_axis . xaxis . get_view_interval ( ) [EOL] plot_y_label = plot_axis . yaxis . get_label_text ( ) [EOL] plot_y_range = plot_axis . yaxis . get_view_interval ( ) [EOL] [EOL] return plot_title , plot_x_label , plot_x_range , plot_y_label , plot_y_range [EOL] [EOL] [EOL] def get_line_data ( line_plot , is_collection = False ) : [EOL] [docstring] [EOL] assert isinstance ( line_plot , ( matplotlib . lines . Line2D , matplotlib . collections . LineCollection ) ) , [string] [EOL] [EOL] if is_collection : [EOL] line_data = line_plot . get_segments ( ) [EOL] else : [EOL] line_data = line_plot . get_xydata ( ) [EOL] line_colour = line_plot . get_color ( ) [EOL] line_alpha = line_plot . get_alpha ( ) [EOL] line_label = line_plot . get_label ( ) [EOL] line_width = line_plot . get_linewidth ( ) [EOL] [EOL] return line_data , line_colour , line_alpha , line_label , line_width [EOL] [EOL] [EOL] def get_bar_data ( plot_axis ) : [EOL] [docstring] [EOL] assert isinstance ( plot_axis , plt . Axes ) , [string] [EOL] [EOL] plot_title = plot_axis . get_title ( ) [EOL] plot_x_tick_names = [ x . get_text ( ) for x in plot_axis . xaxis . get_ticklabels ( ) ] [EOL] plot_x_range = plot_axis . xaxis . get_view_interval ( ) [EOL] plot_y_tick_names = [ y . get_text ( ) for y in plot_axis . yaxis . get_ticklabels ( ) ] [EOL] plot_y_range = plot_axis . yaxis . get_view_interval ( ) [EOL] plot_bar_width = [ ybar . get_width ( ) for ybar in plot_axis . patches ] [EOL] plot_bar_colours = [ ybar . get_facecolor ( ) for ybar in plot_axis . patches ] [EOL] [EOL] return ( plot_title , plot_x_tick_names , plot_x_range , plot_y_tick_names , plot_y_range , plot_bar_width , plot_bar_colours ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,typing.List[builtins.float],builtins.str,typing.List[builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[numpy.ndarray,typing.List[numpy.ndarray]],builtins.str,builtins.float,builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,typing.List[builtins.str],typing.List[builtins.float],typing.List[builtins.str],typing.List[builtins.float],typing.List[builtins.float],typing.List[typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ True , [number] ] , [ - [number] , [number] ] , [ [number] + [number] , False ] , [ [number] + [number] , np . nan ] , [ np . inf , - np . inf ] ] ) [comment] [EOL] NOT_NUMERICAL_NP_ARRAY = np . array ( [ [ True , [number] ] , [ - [number] , [number] ] , [ [number] + [number] , False ] , [ [number] + [number] , np . nan ] , [ np . inf , - np . inf ] , [ object ( ) , [number] ] , [ [number] , None ] , [ [string] , [string] ] ] ) [comment] [EOL] WIDE_NP_ARRAY = np . array ( [ [ True , [number] , [number] ] , [ - [number] , [number] , [number] ] , [ np . nan , np . inf , - np . inf ] , [ [number] + [number] , False , [number] ] ] ) [comment] [EOL] NUMERICAL_STRUCTURED_ARRAY = np . array ( [ ( [number] , [number] + [number] ) , ( [number] , [number] + [number] ) , ( np . nan , - [number] + [number] ) , ( np . inf , - [number] + [number] ) , ( - np . inf , - [number] + [number] ) , ( - [number] , - [number] + [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] NOT_NUMERICAL_STRUCTURED_ARRAY = np . array ( [ ( True , [string] ) , ( [number] , [string] ) , ( - [number] , [string] ) , ( [number] , [string] ) , ( [number] + [number] , [string] ) , ( False , [string] ) , ( np . nan , [string] ) , ( np . inf , [string] ) , ( - np . inf , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] WIDE_STRUCTURED_ARRAY = np . array ( [ ( [number] , [number] + [number] , np . nan ) , ( np . inf , [number] + [number] , [number] ) , ( - [number] , - [number] + [number] , - np . inf ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] BASE_NP_ARRAY = np . array ( [ [ True , [number] ] , [ - [number] , [number] ] , [ [number] + [number] , False ] , [ [number] + [number] , np . nan ] , [ np . inf , - np . inf ] , [ [string] , [string] ] ] ) [comment] [EOL] NOT_BASE_NP_ARRAY = np . array ( [ [ True , np . timedelta64 ( [number] , [string] ) ] , [ - [number] , [number] ] , [ [number] + [number] , np . datetime64 ( [string] ) ] , [ [number] + [number] , np . nan ] , [ np . inf , - np . inf ] , [ [string] , [string] ] , [ object ( ) , [number] ] , [ [number] , None ] ] ) [comment] [EOL] BASE_STRUCTURED_ARRAY = np . array ( [ ( True , [string] ) , ( [number] , [string] ) , ( - [number] , [string] ) , ( [number] , [string] ) , ( [number] + [number] , [string] ) , ( False , [string] ) , ( np . nan , [string] ) , ( np . inf , [string] ) , ( - np . inf , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] NOT_BASE_STRUCTURED_ARRAY = np . array ( [ ( True , object ( ) , [string] ) , ( [number] , None , [string] ) , ( - [number] , None , [string] ) , ( [number] , None , [string] ) , ( [number] + [number] , None , [string] ) , ( False , None , [string] ) , ( np . nan , None , [string] ) , ( np . inf , None , [string] ) , ( - np . inf , object ( ) , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional , Tuple , Pattern , Any , List , Union [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import re [EOL] import warnings [EOL] [EOL] from typing import Optional , Pattern , Union [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] DEFAULT_WARNINGS = [ ( [string] , None , ResourceWarning , [string] , [number] ) , ( [string] , None , ImportWarning , [string] , [number] ) , ( [string] , [string] , PendingDeprecationWarning , [string] , [number] ) , ( [string] , None , DeprecationWarning , [string] , [number] ) , ( [string] , None , DeprecationWarning , [string] , [number] ) ] [EOL] [EOL] EMPTY_RE = re . compile ( [string] ) [EOL] EMPTY_RE_I = re . compile ( [string] , re . IGNORECASE ) [EOL] [EOL] [EOL] def handle_warnings_filter_pattern ( warning_filter_pattern , ignore_case = False ) : [EOL] [docstring] [EOL] filter_module_regex = None [EOL] if warning_filter_pattern is None : [EOL] if ignore_case : [EOL] filter_module_regex = EMPTY_RE_I [EOL] else : [EOL] filter_module_regex = EMPTY_RE [EOL] elif isinstance ( warning_filter_pattern , str ) : [EOL] if ignore_case : [EOL] filter_module_regex = re . compile ( warning_filter_pattern , re . IGNORECASE ) [EOL] else : [EOL] filter_module_regex = re . compile ( warning_filter_pattern ) [EOL] elif isinstance ( warning_filter_pattern , Pattern ) : [EOL] ignore_case_error_message = ( [string] [string] [string] ) [EOL] ignore_case_compiled = warning_filter_pattern . flags & [number] [EOL] if ignore_case_compiled and ignore_case : [EOL] filter_module_regex = warning_filter_pattern [EOL] elif not ignore_case_compiled and not ignore_case : [EOL] filter_module_regex = warning_filter_pattern [EOL] elif ignore_case_compiled : [EOL] raise ValueError ( ignore_case_error_message . format ( neg = [string] ) ) [EOL] else : [EOL] raise ValueError ( ignore_case_error_message . format ( neg = [string] ) ) [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] return filter_module_regex [EOL] [EOL] [EOL] def set_default_warning_filters ( ) : [EOL] [docstring] [EOL] warnings . resetwarnings ( ) [EOL] for warning in DEFAULT_WARNINGS : [EOL] warnings . filterwarnings ( warning [ [number] ] , category = warning [ [number] ] , module = warning [ [number] ] ) [EOL] [EOL] [EOL] def is_warning_class_displayed ( warning_class , warning_module = None ) : [EOL] [docstring] [EOL] if warning_module is None : [EOL] warning_module = [string] [EOL] is_displayed = True [EOL] [EOL] [comment] [EOL] allowed_warning_filters = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for fltr in warnings . filters : [comment] [EOL] active_warning_filter = fltr [ [number] ] [EOL] active_warning_class = fltr [ [number] ] [EOL] active_warning_module = handle_warnings_filter_pattern ( fltr [ [number] ] , ignore_case = False ) [EOL] if ( issubclass ( warning_class , active_warning_class ) [comment] [EOL] and active_warning_module . match ( warning_module ) ) : [EOL] if active_warning_filter in allowed_warning_filters : [EOL] is_displayed = True [EOL] break [EOL] else : [EOL] is_displayed = False [EOL] break [EOL] return is_displayed [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Pattern [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import re [EOL] import warnings [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . testing . warnings as testing_w [EOL] [EOL] [EOL] def test_handle_warnings_filter_pattern ( ) : [EOL] [docstring] [EOL] [EOL] def assert_correct_pattern ( error , error_message , pattern , ignore_case ) : [EOL] with pytest . raises ( error ) as value_error : [EOL] testing_w . handle_warnings_filter_pattern ( pattern , ignore_case = ignore_case ) [EOL] assert str ( value_error . value ) == error_message [EOL] [EOL] [comment] [EOL] assert testing_w . EMPTY_RE == testing_w . handle_warnings_filter_pattern ( None , ignore_case = False ) [EOL] assert testing_w . EMPTY_RE_I == testing_w . handle_warnings_filter_pattern ( None , ignore_case = True ) [EOL] [EOL] [comment] [EOL] my_str_pattern = [string] [EOL] my_re_pattern = re . compile ( my_str_pattern ) [EOL] my_re_pattern_i = re . compile ( my_str_pattern , re . IGNORECASE ) [EOL] assert my_re_pattern == testing_w . handle_warnings_filter_pattern ( my_str_pattern , ignore_case = False ) [EOL] assert my_re_pattern_i == testing_w . handle_warnings_filter_pattern ( my_str_pattern , ignore_case = True ) [EOL] [EOL] [comment] [EOL] assert my_re_pattern == testing_w . handle_warnings_filter_pattern ( my_re_pattern , ignore_case = False ) [EOL] [EOL] assert my_re_pattern_i == testing_w . handle_warnings_filter_pattern ( my_re_pattern_i , ignore_case = True ) [EOL] value_error_message = ( [string] [string] [string] ) [EOL] value_error_message_yes = value_error_message . format ( neg = [string] ) [EOL] value_error_message_no = value_error_message . format ( neg = [string] ) [EOL] [comment] [EOL] assert_correct_pattern ( ValueError , value_error_message_yes , my_re_pattern , True ) [EOL] assert_correct_pattern ( ValueError , value_error_message_no , my_re_pattern_i , False ) [EOL] [EOL] [comment] [EOL] type_error_message = ( [string] [string] ) [EOL] assert_correct_pattern ( TypeError , type_error_message , [number] , False ) [EOL] assert_correct_pattern ( TypeError , type_error_message , [number] , True ) [EOL] assert_correct_pattern ( TypeError , type_error_message , [ [number] , [number] ] , False ) [EOL] assert_correct_pattern ( TypeError , type_error_message , [ [number] , [number] ] , True ) [EOL] dict_example = { [number] : [string] , [number] : [string] } [EOL] assert_correct_pattern ( TypeError , type_error_message , dict_example , False ) [EOL] assert_correct_pattern ( TypeError , type_error_message , dict_example , True ) [EOL] [EOL] [comment] [EOL] flag_m = re . compile ( [string] , re . MULTILINE ) [EOL] assert flag_m == testing_w . handle_warnings_filter_pattern ( flag_m , ignore_case = False ) [EOL] assert_correct_pattern ( ValueError , value_error_message_yes , flag_m , True ) [EOL] [comment] [EOL] flag_i = re . compile ( [string] , re . IGNORECASE ) [EOL] assert flag_i == testing_w . handle_warnings_filter_pattern ( flag_i , ignore_case = True ) [EOL] assert_correct_pattern ( ValueError , value_error_message_no , flag_i , False ) [EOL] [comment] [EOL] flag_a = re . compile ( [string] , re . ASCII ) [EOL] assert flag_a == testing_w . handle_warnings_filter_pattern ( flag_a , ignore_case = False ) [EOL] assert_correct_pattern ( ValueError , value_error_message_yes , flag_m , True ) [EOL] [comment] [EOL] flag_mi = re . compile ( [string] , re . MULTILINE | re . IGNORECASE ) [EOL] assert flag_mi == testing_w . handle_warnings_filter_pattern ( flag_mi , ignore_case = True ) [EOL] assert_correct_pattern ( ValueError , value_error_message_no , flag_mi , False ) [EOL] [comment] [EOL] flag_ma = re . compile ( [string] , re . MULTILINE | re . ASCII ) [EOL] assert flag_ma == testing_w . handle_warnings_filter_pattern ( flag_ma , ignore_case = False ) [EOL] assert_correct_pattern ( ValueError , value_error_message_yes , flag_ma , True ) [EOL] [comment] [EOL] flag_ai = re . compile ( [string] , re . ASCII | re . IGNORECASE ) [EOL] assert flag_ai == testing_w . handle_warnings_filter_pattern ( flag_ai , ignore_case = True ) [EOL] assert_correct_pattern ( ValueError , value_error_message_no , flag_ai , False ) [EOL] [EOL] [EOL] def test_set_default_warning_filters ( ) : [EOL] [docstring] [EOL] testing_w . set_default_warning_filters ( ) [EOL] [EOL] filters_number = len ( testing_w . DEFAULT_WARNINGS ) [EOL] assert len ( warnings . filters ) == filters_number [EOL] [EOL] for i in range ( filters_number ) : [EOL] builtin_filter = warnings . filters [ i ] [EOL] default_filter = testing_w . DEFAULT_WARNINGS [ filters_number - [number] - i ] [EOL] [EOL] [comment] [EOL] assert builtin_filter [ [number] ] == default_filter [ [number] ] [EOL] [comment] [EOL] assert ( testing_w . handle_warnings_filter_pattern ( builtin_filter [ [number] ] , ignore_case = True ) == testing_w . handle_warnings_filter_pattern ( default_filter [ [number] ] , ignore_case = True ) ) [EOL] [comment] [EOL] assert builtin_filter [ [number] ] == default_filter [ [number] ] [EOL] [comment] [EOL] assert ( testing_w . handle_warnings_filter_pattern ( builtin_filter [ [number] ] , ignore_case = False ) == testing_w . handle_warnings_filter_pattern ( default_filter [ [number] ] , ignore_case = False ) ) [EOL] [comment] [EOL] assert builtin_filter [ [number] ] == default_filter [ [number] ] [EOL] [EOL] [EOL] def test_is_warning_class_displayed ( ) : [EOL] [docstring] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . filterwarnings ( [string] , category = ImportWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert not testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert not testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning ) [EOL] [EOL] [comment] [EOL] warnings . resetwarnings ( ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning , [string] ) [EOL] assert not testing_w . is_warning_class_displayed ( DeprecationWarning , [string] ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert not testing_w . is_warning_class_displayed ( DeprecationWarning , [string] ) [EOL] warnings . filterwarnings ( [string] , category = DeprecationWarning , module = [string] ) [EOL] assert not testing_w . is_warning_class_displayed ( DeprecationWarning , [string] ) [EOL] assert testing_w . is_warning_class_displayed ( DeprecationWarning , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import importlib [EOL] import sys [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . testing . imports as futi [EOL] [EOL] [EOL] def test_module_import_tester ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] import pytest [EOL] importlib . reload ( pytest ) [EOL] with futi . module_import_tester ( [string] , when_missing = True ) : [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . reload ( pytest ) [EOL] assert [string] in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import pytest [EOL] assert [string] in str ( excinfo . value ) [EOL] [comment] [EOL] import pytest [EOL] importlib . reload ( pytest ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] import pytest [EOL] importlib . reload ( pytest ) [EOL] with futi . module_import_tester ( [string] , when_missing = False ) : [EOL] [comment] [EOL] importlib . reload ( sys ) [EOL] import pytest [EOL] [comment] [EOL] import pytest [EOL] importlib . reload ( pytest ) [EOL] [EOL] missing_mod = [string] [EOL] missing_mod_exception = [string] . format ( missing_mod ) [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import gibberish_module_42 [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . import_module ( missing_mod ) [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with futi . module_import_tester ( missing_mod , when_missing = True ) : [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import gibberish_module_42 [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . import_module ( missing_mod ) [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import gibberish_module_42 [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . import_module ( missing_mod ) [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import gibberish_module_42 [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . import_module ( missing_mod ) [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with futi . module_import_tester ( missing_mod , when_missing = False ) : [EOL] [comment] [EOL] import gibberish_module_42 [EOL] with futi . module_import_tester ( missing_mod , when_missing = False ) : [EOL] [comment] [EOL] importlib . import_module ( missing_mod ) [EOL] [comment] [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] import gibberish_module_42 [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . import_module ( missing_mod ) [EOL] assert missing_mod_exception in str ( excinfo . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import matplotlib . collections [EOL] import matplotlib . pyplot as plt [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] , allow_module_level = True ) [EOL] [EOL] import importlib [EOL] import sys [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . testing . imports as futi [EOL] import fatf . utils . testing . vis as futv [EOL] [EOL] [EOL] def test_import_when_missing ( ) : [EOL] [docstring] [EOL] assert [string] in sys . modules [EOL] exception_msg = ( [string] [string] [string] ) [EOL] with futi . module_import_tester ( [string] , when_missing = True ) : [EOL] with pytest . raises ( ImportError ) as excinfo : [EOL] importlib . reload ( futv ) [EOL] assert str ( excinfo . value ) == exception_msg [EOL] assert [string] in sys . modules [EOL] [EOL] [EOL] def test_get_plot_data ( ) : [EOL] [docstring] [EOL] true_title = [string] [EOL] true_x_label = [string] [EOL] true_x_range = [ - [number] , [number] ] [EOL] true_y_label = [string] [EOL] true_y_range = [ - [number] , [number] ] [EOL] [EOL] plot_figure , plot_axis = plt . subplots ( [number] , [number] ) [EOL] plot_axis . set_title ( true_title ) [EOL] plot_axis . set_xlim ( true_x_range ) [EOL] plot_axis . set_xlabel ( true_x_label ) [EOL] plot_axis . set_ylim ( true_y_range ) [EOL] plot_axis . set_ylabel ( true_y_label ) [EOL] [EOL] title , x_label , x_range , y_label , y_range = futv . get_plot_data ( plot_axis ) [EOL] [EOL] assert true_title == title [EOL] assert true_x_label == x_label [EOL] assert true_y_label == y_label [EOL] assert np . array_equal ( true_y_range , y_range ) [EOL] assert np . array_equal ( true_x_range , x_range ) [EOL] [EOL] [EOL] def test_get_line_data ( ) : [EOL] [docstring] [EOL] [comment] [EOL] true_data = [ [ [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] ] ] [EOL] true_label = [string] [EOL] true_colour = [string] [EOL] true_alpha = [number] [EOL] true_width = [number] [EOL] [EOL] plot_figure , plot_axis = plt . subplots ( [number] , [number] ) [EOL] line_collection = matplotlib . collections . LineCollection ( true_data , label = true_label , color = true_colour , alpha = true_alpha , linewidth = true_width ) [EOL] plot_axis . add_collection ( line_collection ) [EOL] [EOL] assert len ( plot_axis . collections ) == [number] [EOL] data , colour , alpha , label , width = futv . get_line_data ( plot_axis . collections [ [number] ] , is_collection = True ) [EOL] [EOL] assert np . array_equal ( true_data , data ) [EOL] assert np . allclose ( [ [ [number] , [number] , [number] , [number] ] ] , colour , atol = [number] ) [EOL] assert true_alpha == alpha [EOL] assert true_label == label [EOL] assert true_width == width [EOL] [EOL] [comment] [EOL] true_data_x = [ [number] , [number] , [number] , [number] , [number] ] [EOL] true_data_y = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] plot_figure , plot_axis = plt . subplots ( [number] , [number] ) [EOL] plot_axis . plot ( true_data_x , true_data_y , color = true_colour , linewidth = true_width , alpha = true_alpha , label = true_label ) [EOL] [EOL] assert len ( plot_axis . lines ) == [number] [EOL] data , colour , alpha , label , width = futv . get_line_data ( plot_axis . lines [ [number] ] , is_collection = False ) [EOL] [EOL] assert data . shape == ( [number] , [number] ) [EOL] assert np . array_equal ( true_data_x , data [ : , [number] ] ) [EOL] assert np . array_equal ( true_data_y , data [ : , [number] ] ) [EOL] assert true_colour == colour [EOL] assert true_alpha == alpha [EOL] assert true_label == label [EOL] assert true_width == width [EOL] [EOL] data , colour , alpha , label , width = futv . get_line_data ( plot_axis . lines [ [number] ] ) [EOL] [EOL] assert data . shape == ( [number] , [number] ) [EOL] assert np . array_equal ( true_data_x , data [ : , [number] ] ) [EOL] assert np . array_equal ( true_data_y , data [ : , [number] ] ) [EOL] assert true_colour == colour [EOL] assert true_alpha == alpha [EOL] assert true_label == label [EOL] assert true_width == width [EOL] [EOL] [EOL] def test_get_bar_data ( ) : [EOL] [docstring] [EOL] true_title = [string] [EOL] true_y_tick_names = [ [string] , [string] , [string] ] [EOL] true_y_range = [ [number] , [number] , [number] ] [EOL] true_bar_widths = [ [number] , [number] , [number] ] [EOL] true_colours = [ [string] , [string] , [string] ] [EOL] true_colours_rgb = [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] [EOL] plot_figure , plot_axes = plt . subplots ( [number] , [number] , sharey = True , sharex = True ) [EOL] for axis in plot_axes : [EOL] axis . barh ( true_y_range , true_bar_widths , align = [string] , color = true_colours ) [EOL] axis . set_yticks ( true_y_range ) [EOL] axis . set_yticklabels ( true_y_tick_names ) [EOL] axis . set_title ( true_title ) [EOL] [EOL] for i in range ( [number] ) : [EOL] axis = plot_axes [ i ] [EOL] tpl = futv . get_bar_data ( axis ) [EOL] title , x_names , x_range , y_names , y_range , widths , colours = tpl [EOL] [EOL] assert true_title == title [EOL] [comment] [EOL] for j in x_names : [EOL] assert j == [string] [EOL] assert len ( x_range ) == [number] [EOL] assert abs ( max ( true_bar_widths ) - ( x_range [ [number] ] - x_range [ [number] ] ) ) < [number] [EOL] [comment] [EOL] if i == [number] : [EOL] assert np . array_equal ( true_y_tick_names , y_names ) [EOL] assert len ( y_range ) == [number] [EOL] assert abs ( len ( true_y_range ) - ( y_range [ [number] ] - y_range [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert np . array_equal ( true_bar_widths , widths ) [EOL] [comment] [EOL] assert len ( true_colours_rgb ) == len ( colours ) [EOL] for j in range ( len ( true_colours_rgb ) ) : [EOL] assert len ( true_colours_rgb [ j ] ) == len ( colours [ j ] ) [EOL] for k in range ( len ( true_colours_rgb [ j ] ) ) : [EOL] assert abs ( true_colours_rgb [ j ] [ k ] - colours [ j ] [ k ] ) < [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . metrics . subgroup_metrics as fums [EOL] [EOL] MISSING_LABEL_WARNING = ( [string] [string] ) [EOL] [EOL] DATASET = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] _INDICES_PER_BIN = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] GROUND_TRUTH = np . zeros ( ( [number] , ) , dtype = int ) [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] ] [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] PREDICTIONS = np . zeros ( ( [number] , ) , dtype = int ) [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] ] [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_apply_metric_function ( ) : [EOL] [docstring] [EOL] type_error_cmxs = ( [string] [string] ) [EOL] value_error_cmxs = ( [string] [string] ) [EOL] [comment] [EOL] type_error_fn = ( [string] [string] ) [EOL] attribute_error_fn = ( [string] [string] [string] ) [EOL] [comment] [EOL] type_error_metric = ( [string] [string] ) [EOL] [EOL] def zero ( ) : [EOL] return [string] [comment] [EOL] [EOL] def one ( one ) : [EOL] return [number] [EOL] [EOL] def one_array ( one ) : [EOL] return one . sum ( ) [EOL] [EOL] def two ( one , two ) : [EOL] return [string] + [string] + [string] + [string] + two [EOL] [EOL] cfmx = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fums . apply_metric_function ( [string] , None ) [EOL] assert str ( exin . value ) == type_error_cmxs [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fums . apply_metric_function ( [ ] , None ) [EOL] assert str ( exin . value ) == value_error_cmxs [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fums . apply_metric_function ( [ cfmx ] , None ) [EOL] assert str ( exin . value ) == type_error_fn [EOL] [EOL] with pytest . raises ( AttributeError ) as exin : [EOL] fums . apply_metric_function ( [ cfmx ] , zero ) [EOL] assert str ( exin . value ) == attribute_error_fn [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fums . apply_metric_function ( [ cfmx ] , two , [string] ) [EOL] assert str ( exin . value ) == type_error_metric . format ( [string] ) [EOL] [EOL] measures = fums . apply_metric_function ( [ cfmx ] , one ) [EOL] assert measures == [ [number] ] [EOL] [EOL] measures = fums . apply_metric_function ( [ cfmx ] , one_array ) [EOL] assert measures == [ [number] ] [EOL] [EOL] [EOL] def test_apply_metric ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] [EOL] available_metrics = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] cfmx = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fums . apply_metric ( [ cfmx ] , [number] ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fums . apply_metric ( [ cfmx ] , [string] ) [EOL] assert str ( exin . value ) == value_error . format ( [string] , sorted ( available_metrics ) ) [EOL] [EOL] measures = fums . apply_metric ( [ cfmx ] ) [EOL] assert len ( measures ) == [number] [EOL] assert measures [ [number] ] == [number] [EOL] [EOL] measures = fums . apply_metric ( [ cfmx ] , [string] ) [EOL] assert len ( measures ) == [number] [EOL] assert measures [ [number] ] == [number] [EOL] [EOL] measures = fums . apply_metric ( [ cfmx ] , [string] , label_index = [number] ) [EOL] assert len ( measures ) == [number] [EOL] assert measures [ [number] ] == pytest . approx ( [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_performance_per_subgroup ( ) : [EOL] [docstring] [EOL] true_bin_names = [ [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] / [number] , [number] / [number] , [number] / [number] ] , abs = [number] ) [EOL] assert bin_names == true_bin_names [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] , metric = [string] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] , [number] , [number] / [number] ] , abs = [number] ) [EOL] assert bin_names == true_bin_names [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] , metric = [string] , strict = True ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] , [number] / [number] , [number] / [number] ] , abs = [number] ) [EOL] assert bin_names == true_bin_names [EOL] [EOL] def one ( one ) : [EOL] return one . sum ( ) [EOL] [EOL] def two ( one , two , three = [number] ) : [EOL] return one . sum ( ) + two + three [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] , metric = [string] , metric_function = one ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL] assert bin_names == true_bin_names [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] , [number] , metric = [string] , metric_function = two ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL] assert bin_names == true_bin_names [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics , bin_names = fums . performance_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] , [number] , metric = [string] , metric_function = two , three = - [number] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL] assert bin_names == true_bin_names [EOL] [EOL] [EOL] def test_performance_per_subgroup_indexed ( ) : [EOL] [docstring] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , labels = [ [number] , [number] , [number] ] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] / [number] , [number] / [number] , [number] / [number] ] , abs = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , labels = [ [number] , [number] , [number] ] , metric = [string] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] , [number] , [number] / [number] ] , abs = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , labels = [ [number] , [number] , [number] ] , metric = [string] , strict = True ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == pytest . approx ( [ [number] , [number] / [number] , [number] / [number] ] , abs = [number] ) [EOL] [EOL] def one ( one ) : [EOL] return one . sum ( ) [EOL] [EOL] def two ( one , two , three = [number] ) : [EOL] return one . sum ( ) + two + three [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , labels = [ [number] , [number] , [number] ] , metric = [string] , metric_function = one ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , [number] , labels = [ [number] , [number] , [number] ] , metric = [string] , metric_function = two ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] bin_metrics = fums . performance_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , [number] , labels = [ [number] , [number] , [number] ] , metric = [string] , metric_function = two , three = - [number] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [comment] [EOL] assert bin_metrics == [ [number] , [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] import fatf . utils . metrics . tools as fumt [EOL] [EOL] USER_WARNING = ( [string] [string] ) [EOL] MISSING_LABEL_WARNING = ( [string] [string] ) [EOL] [EOL] DATASET = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] _INDICES_PER_BIN = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] GROUND_TRUTH = np . zeros ( ( [number] , ) , dtype = int ) [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] ] [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] GROUND_TRUTH [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] PREDICTIONS = np . zeros ( ( [number] , ) , dtype = int ) [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] ] [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] ] [EOL] PREDICTIONS [ _INDICES_PER_BIN [ [number] ] ] = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] [EOL] def test_validate_confusion_matrix ( ) : [EOL] [docstring] [EOL] incorrect_shape_error_2d = ( [string] [string] ) [EOL] incorrect_shape_error_square = ( [string] [string] ) [EOL] incorrect_shape_error_2 = [string] [EOL] value_error = [string] [EOL] type_error_cm = [string] [EOL] type_error_index = [string] [EOL] index_error = ( [string] [string] ) [EOL] [EOL] three_d_array = np . array ( [ [ [ [number] ] , [ [number] ] ] , [ [ [number] ] ] ] ) [EOL] two_d_array_rect = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] two_d_array_one = np . array ( [ [ [number] ] ] ) [EOL] struct_array = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] non_int_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] two_d_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . validate_confusion_matrix ( three_d_array ) [EOL] assert str ( exi . value ) == incorrect_shape_error_2d [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . validate_confusion_matrix ( two_d_array_rect ) [EOL] assert str ( exi . value ) == incorrect_shape_error_square [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . validate_confusion_matrix ( two_d_array_one ) [EOL] assert str ( exi . value ) == incorrect_shape_error_2 [EOL] [EOL] with pytest . raises ( ValueError ) as exi : [EOL] fumt . validate_confusion_matrix ( struct_array ) [EOL] assert str ( exi . value ) == value_error [EOL] [EOL] with pytest . raises ( TypeError ) as exi : [EOL] fumt . validate_confusion_matrix ( non_int_array ) [EOL] assert str ( exi . value ) == type_error_cm [EOL] [EOL] with pytest . raises ( TypeError ) as exi : [EOL] fumt . validate_confusion_matrix ( two_d_array , [string] ) [EOL] assert str ( exi . value ) == type_error_index [EOL] [EOL] with pytest . raises ( IndexError ) as exi : [EOL] fumt . validate_confusion_matrix ( two_d_array , - [number] ) [EOL] assert str ( exi . value ) == index_error . format ( - [number] , [number] , [number] ) [EOL] [EOL] with pytest . raises ( IndexError ) as exi : [EOL] fumt . validate_confusion_matrix ( two_d_array , [number] ) [EOL] assert str ( exi . value ) == index_error . format ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_validate_confusion_matrix_size ( ) : [EOL] [docstring] [EOL] incorrect_shape_error = ( [string] [string] ) [EOL] [EOL] two_d = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] three_d = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . validate_confusion_matrix_size ( two_d , [number] ) [EOL] assert str ( exi . value ) == incorrect_shape_error . format ( [number] , [number] , [number] , [number] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . validate_confusion_matrix_size ( three_d , [number] ) [EOL] assert str ( exi . value ) == incorrect_shape_error . format ( [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_get_confusion_matrix_errors ( ) : [EOL] [docstring] [EOL] incorrect_shape_error_gt = ( [string] [string] ) [EOL] incorrect_shape_error_pred = ( [string] [string] ) [EOL] incorrect_shape_error_gtp = ( [string] [string] ) [EOL] value_error_labels_empty = [string] [EOL] value_error_labels_duplicates = [string] [EOL] value_error_labels_missing = ( [string] [string] [string] ) [EOL] type_error_labels = [string] [EOL] [EOL] two_d_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] one_d_array_4 = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] one_d_array_5 = np . array ( [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] cma_true = np . array ( [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . get_confusion_matrix ( two_d_array , two_d_array ) [EOL] assert str ( exi . value ) == incorrect_shape_error_gt [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , two_d_array ) [EOL] assert str ( exi . value ) == incorrect_shape_error_pred [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_5 ) [EOL] assert str ( exi . value ) == incorrect_shape_error_gtp [EOL] [EOL] with pytest . raises ( TypeError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_4 , [string] ) [EOL] assert str ( exi . value ) == type_error_labels [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_4 , [ ] ) [EOL] assert str ( exi . value ) == value_error_labels_empty [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_4 , [ [number] , [number] , [number] ] ) [EOL] assert str ( exi . value ) == value_error_labels_duplicates [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exi : [EOL] fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_4 , [ [number] , [number] , [number] ] ) [EOL] assert str ( exi . value ) == value_error_labels_missing . format ( [string] ) [EOL] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] cma = fumt . get_confusion_matrix ( one_d_array_4 , one_d_array_4 , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == USER_WARNING . format ( [string] ) [EOL] assert np . array_equal ( cma , cma_true ) [EOL] [EOL] [EOL] def test_get_confusion_matrix ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ground_truth = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] predictions = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [comment] [EOL] [comment] [EOL] ground_truth_bin = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] predictions_bin = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] cmx = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] cmx_bin = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] cmx_bb = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] [EOL] [comment] [EOL] cma = fumt . get_confusion_matrix ( ground_truth , predictions ) [EOL] assert np . array_equal ( cmx , cma ) [EOL] cma = fumt . get_confusion_matrix ( ground_truth_bin , predictions_bin ) [EOL] assert np . array_equal ( cmx_bin , cma ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] cma = fumt . get_confusion_matrix ( ground_truth , predictions , [ [string] , [string] , [string] , [string] ] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == USER_WARNING . format ( [string] ) [EOL] assert np . array_equal ( cmx_bb , cma ) [EOL] [EOL] [EOL] def test_confusion_matrix_per_subgroup ( ) : [EOL] [docstring] [EOL] [EOL] mx1 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] mx2 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] mx3 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] pcmxs , bin_names = fumt . confusion_matrix_per_subgroup ( DATASET , GROUND_TRUTH , PREDICTIONS , [number] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == MISSING_LABEL_WARNING [EOL] [EOL] assert len ( pcmxs ) == [number] [EOL] assert np . array_equal ( pcmxs [ [number] ] , mx1 ) [EOL] assert np . array_equal ( pcmxs [ [number] ] , mx2 ) [EOL] assert np . array_equal ( pcmxs [ [number] ] , mx3 ) [EOL] assert bin_names == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_confusion_matrix_per_subgroup_indexed ( ) : [EOL] [docstring] [EOL] incorrect_shape_error_gt = ( [string] [string] ) [EOL] incorrect_shape_error_p = ( [string] [string] ) [EOL] [EOL] flat = np . array ( [ [number] , [number] ] ) [EOL] square = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fumt . confusion_matrix_per_subgroup_indexed ( [ [ [number] ] ] , square , square ) [EOL] assert str ( exin . value ) == incorrect_shape_error_gt [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fumt . confusion_matrix_per_subgroup_indexed ( [ [ [number] ] ] , flat , square ) [EOL] assert str ( exin . value ) == incorrect_shape_error_p [EOL] [EOL] mx1 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] mx2 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] mx3 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] pcmxs_1 = fumt . confusion_matrix_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS , labels = [ [number] , [number] , [number] ] ) [EOL] pcmxs_2 = fumt . confusion_matrix_per_subgroup_indexed ( _INDICES_PER_BIN , GROUND_TRUTH , PREDICTIONS ) [EOL] assert len ( w ) == [number] [EOL] wmsg = ( [string] [string] ) [EOL] assert str ( w [ [number] ] . message ) == wmsg [EOL] assert str ( w [ [number] ] . message ) == wmsg [EOL] assert len ( pcmxs_1 ) == [number] [EOL] assert len ( pcmxs_2 ) == [number] [EOL] assert np . array_equal ( pcmxs_1 [ [number] ] , mx1 ) [EOL] assert np . array_equal ( pcmxs_2 [ [number] ] , mx1 ) [EOL] assert np . array_equal ( pcmxs_1 [ [number] ] , mx2 ) [EOL] assert np . array_equal ( pcmxs_2 [ [number] ] , mx2 ) [EOL] assert np . array_equal ( pcmxs_1 [ [number] ] , mx3 ) [EOL] assert np . array_equal ( pcmxs_2 [ [number] ] , mx3 ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] import fatf . utils . metrics . metrics as fumm [EOL] [EOL] CMA = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] CMA_BIN = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] [EOL] def test_multiclass_true_positive_rate ( ) : [EOL] [docstring] [EOL] mtpr_0 = fumm . multiclass_true_positive_rate ( CMA , [number] ) [EOL] assert mtpr_0 == pytest . approx ( [number] , abs = [number] ) [EOL] mtpr_1 = fumm . multiclass_true_positive_rate ( CMA , [number] ) [EOL] assert mtpr_1 == [number] [EOL] mtpr_2 = fumm . multiclass_true_positive_rate ( CMA , [number] ) [EOL] assert mtpr_2 == pytest . approx ( [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_multiclass_true_negative_rate ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] with pytest . raises ( TypeError ) as exi : [EOL] fumm . multiclass_true_negative_rate ( CMA , [number] , [string] ) [EOL] assert str ( exi . value ) == type_error [EOL] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_0_n = fumm . multiclass_true_negative_rate ( CMA , [number] ) [EOL] assert mtpr_0_n == metric [EOL] mtpr_0_n = fumm . multiclass_true_negative_rate ( CMA , [number] , False ) [EOL] assert mtpr_0_n == metric [EOL] [comment] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_1_n = fumm . multiclass_true_negative_rate ( CMA , [number] ) [EOL] assert mtpr_1_n == metric [EOL] mtpr_1_n = fumm . multiclass_true_negative_rate ( CMA , [number] , False ) [EOL] assert mtpr_1_n == metric [EOL] [comment] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_2_n = fumm . multiclass_true_negative_rate ( CMA , [number] ) [EOL] assert mtpr_2_n == metric [EOL] mtpr_2_n = fumm . multiclass_true_negative_rate ( CMA , [number] , False ) [EOL] assert mtpr_2_n == metric [EOL] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_0_p = fumm . multiclass_true_negative_rate ( CMA , [number] , True ) [EOL] assert mtpr_0_p == metric [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_1_p = fumm . multiclass_true_negative_rate ( CMA , [number] , True ) [EOL] assert mtpr_1_p == metric [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_2_p = fumm . multiclass_true_negative_rate ( CMA , [number] , True ) [EOL] assert mtpr_2_p == metric [EOL] [EOL] [EOL] def test_multiclass_false_positive_rate ( ) : [EOL] [docstring] [EOL] mtpr_0 = fumm . multiclass_false_positive_rate ( CMA , [number] ) [EOL] assert mtpr_0 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_1 = fumm . multiclass_false_positive_rate ( CMA , [number] ) [EOL] assert mtpr_1 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_2 = fumm . multiclass_false_positive_rate ( CMA , [number] ) [EOL] assert mtpr_2 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_multiclass_false_negative_rate ( ) : [EOL] [docstring] [EOL] mtpr_0 = fumm . multiclass_false_negative_rate ( CMA , [number] ) [EOL] assert mtpr_0 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_1 = fumm . multiclass_false_negative_rate ( CMA , [number] ) [EOL] assert mtpr_1 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_2 = fumm . multiclass_false_negative_rate ( CMA , [number] ) [EOL] assert mtpr_2 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_true_positive_rate ( ) : [EOL] [docstring] [EOL] mtpr = fumm . true_positive_rate ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_true_negative_rate ( ) : [EOL] [docstring] [EOL] mtpr = fumm . true_negative_rate ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_false_negative_rate ( ) : [EOL] [docstring] [EOL] mtpr = fumm . false_negative_rate ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_false_positive_rate ( ) : [EOL] [docstring] [EOL] mtpr = fumm . false_positive_rate ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_multiclass_positive_predictive_value ( ) : [EOL] [docstring] [EOL] mtpr_0 = fumm . multiclass_positive_predictive_value ( CMA , [number] ) [EOL] assert mtpr_0 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_1 = fumm . multiclass_positive_predictive_value ( CMA , [number] ) [EOL] assert mtpr_1 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_2 = fumm . multiclass_positive_predictive_value ( CMA , [number] ) [EOL] assert mtpr_2 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_multiclass_negative_predictive_value ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] with pytest . raises ( TypeError ) as exi : [EOL] fumm . multiclass_negative_predictive_value ( CMA , [number] , [string] ) [EOL] assert str ( exi . value ) == type_error [EOL] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_0_n = fumm . multiclass_negative_predictive_value ( CMA , [number] ) [EOL] assert mtpr_0_n == metric [EOL] mtpr_0_n = fumm . multiclass_negative_predictive_value ( CMA , [number] , False ) [EOL] assert mtpr_0_n == metric [EOL] [comment] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_1_n = fumm . multiclass_negative_predictive_value ( CMA , [number] ) [EOL] assert mtpr_1_n == metric [EOL] mtpr_1_n = fumm . multiclass_negative_predictive_value ( CMA , [number] , False ) [EOL] assert mtpr_1_n == metric [EOL] [comment] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_2_n = fumm . multiclass_negative_predictive_value ( CMA , [number] ) [EOL] assert mtpr_2_n == metric [EOL] mtpr_2_n = fumm . multiclass_negative_predictive_value ( CMA , [number] , False ) [EOL] assert mtpr_2_n == metric [EOL] [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_0_p = fumm . multiclass_negative_predictive_value ( CMA , [number] , True ) [EOL] assert mtpr_0_p == metric [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_1_p = fumm . multiclass_negative_predictive_value ( CMA , [number] , True ) [EOL] assert mtpr_1_p == metric [EOL] metric = pytest . approx ( [number] / [number] ) [EOL] mtpr_2_p = fumm . multiclass_negative_predictive_value ( CMA , [number] , True ) [EOL] assert mtpr_2_p == metric [EOL] [EOL] [EOL] def test_positive_predictive_value ( ) : [EOL] [docstring] [EOL] mtpr = fumm . positive_predictive_value ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_negative_predictive_value ( ) : [EOL] [docstring] [EOL] mtpr = fumm . negative_predictive_value ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_accuracy ( ) : [EOL] [docstring] [EOL] acc = fumm . accuracy ( CMA ) [EOL] assert acc == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] acc = fumm . accuracy ( CMA_BIN ) [EOL] assert acc == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_multiclass_treatment ( ) : [EOL] [docstring] [EOL] mtpr_0 = fumm . multiclass_treatment ( CMA , [number] ) [EOL] assert mtpr_0 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_1 = fumm . multiclass_treatment ( CMA , [number] ) [EOL] assert mtpr_1 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] mtpr_2 = fumm . multiclass_treatment ( CMA , [number] ) [EOL] assert mtpr_2 == pytest . approx ( [number] / [number] , abs = [number] ) [EOL] [EOL] [EOL] def test_treatment ( ) : [EOL] [docstring] [EOL] mtpr = fumm . treatment ( CMA_BIN ) [EOL] assert mtpr == pytest . approx ( [number] / [number] , abs = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List , Union , Set [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple [comment] [EOL] from typing import Union [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] def _validate_input ( data_row , samples_number ) : [EOL] [docstring] [EOL] is_valid = False [EOL] [EOL] if not fuav . is_1d_like ( data_row ) : [EOL] raise IncorrectShapeError ( [string] [string] [string] ) [EOL] [EOL] if isinstance ( samples_number , int ) : [EOL] if samples_number < [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] is_valid = True [EOL] return is_valid [EOL] [EOL] [EOL] def binary_sampler ( data_row , samples_number = [number] ) : [EOL] [docstring] [EOL] assert _validate_input ( data_row , samples_number ) , [string] [EOL] [EOL] [comment] [EOL] unique_elements = set ( np . unique ( data_row . tolist ( ) ) ) [EOL] if not unique_elements . issubset ( [ [number] , [number] , [number] , [number] , False , True ] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] is_structured = fuav . is_structured_array ( np . asarray ( data_row ) ) [EOL] [EOL] if is_structured : [EOL] column_indices = data_row . dtype . names [EOL] output_shape = ( samples_number , ) [comment] [EOL] else : [EOL] column_indices = range ( data_row . shape [ [number] ] ) [EOL] output_shape = ( samples_number , data_row . shape [ [number] ] ) [EOL] [EOL] binary_samples = np . zeros ( output_shape , dtype = data_row . dtype ) [EOL] [EOL] for column_index in column_indices : [EOL] column_mask = np . random . choice ( [ [number] , [number] ] , size = ( samples_number , ) ) [EOL] column_values = data_row [ column_index ] * column_mask [EOL] if is_structured : [EOL] binary_samples [ column_index ] = column_values [EOL] else : [EOL] binary_samples [ : , column_index ] = column_values [EOL] [EOL] return binary_samples [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Tuple [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] [EOL] def _validate_input_drm ( dataset , data_row ) : [EOL] [docstring] [EOL] is_valid = False [EOL] [EOL] if not fuav . is_2d_array ( dataset ) : [EOL] raise IncorrectShapeError ( [string] [string] ) [EOL] if not fuav . is_base_array ( dataset ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] if not fuav . is_1d_like ( data_row ) : [EOL] raise IncorrectShapeError ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] are_similar = fuav . are_similar_dtype_arrays ( dataset , np . array ( [ data_row ] ) , strict_comparison = False ) [EOL] if not are_similar : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not fuav . is_structured_array ( dataset ) : [EOL] if dataset . shape [ [number] ] != data_row . shape [ [number] ] : [EOL] raise IncorrectShapeError ( [string] [string] [string] ) [EOL] [EOL] is_valid = True [EOL] return is_valid [EOL] [EOL] [EOL] def dataset_row_masking ( dataset , data_row ) : [EOL] [docstring] [EOL] assert _validate_input_drm ( dataset , data_row ) , [string] [EOL] [EOL] if fuav . is_structured_array ( dataset ) : [EOL] dtypes = [ ( name , np . int8 ) for name in dataset . dtype . names ] [EOL] binary_representation = np . zeros_like ( dataset , dtype = dtypes ) [EOL] for index in dataset . dtype . names : [EOL] [comment] [EOL] binary_representation [ index ] = ( dataset [ index ] == data_row [ index ] ) [EOL] else : [EOL] binary_representation = ( dataset == data_row ) . astype ( np . int8 ) [EOL] [EOL] return binary_representation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import sklearn [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] [string] , allow_module_level = True ) [EOL] else : [EOL] del sklearn [EOL] [EOL] import importlib [EOL] import sys [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . data . feature_selection . sklearn as fudfs [EOL] import fatf . utils . testing . imports as futi [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [comment] [EOL] ONE_D_ARRAY = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] NUMERICAL_NP_ARRAY_TARGET = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] [comment] [EOL] [EOL] FEATURE_INDICES_WARNING = ( [string] [string] [string] [string] ) [EOL] FEATURE_PERCENTAGE_LOG = ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] [EOL] def test_sklearn_import ( ) : [EOL] [docstring] [EOL] [comment] [EOL] assert [string] in sys . modules [EOL] with futi . module_import_tester ( [string] , when_missing = False ) : [EOL] importlib . reload ( fatf . utils . data . feature_selection . sklearn ) [EOL] assert [string] in sys . modules [EOL] [EOL] [comment] [EOL] assert [string] in sys . modules [EOL] exception_msg = ( [string] [string] [string] [string] [string] [string] ) [EOL] with futi . module_import_tester ( [string] , when_missing = True ) : [EOL] with pytest . raises ( ImportError ) as exin : [EOL] importlib . reload ( fatf . utils . data . feature_selection . sklearn ) [EOL] assert str ( exin . value ) == exception_msg [EOL] assert [string] in sys . modules [EOL] [EOL] [EOL] def test_validate_input_lasso_path ( ) : [EOL] [docstring] [EOL] dataset_shape_msg = [string] [EOL] dataset_type_msg = ( [string] [string] [string] ) [EOL] [comment] [EOL] target_shape_msg = [string] [EOL] target_shape_2_msg = ( [string] [string] ) [EOL] target_type_msg = ( [string] [string] ) [EOL] [comment] [EOL] weights_shape_msg = [string] [EOL] weights_shape_2_msg = ( [string] [string] [string] ) [EOL] weights_type_msg = [string] [EOL] [comment] [EOL] features_number_type_msg = ( [string] [string] ) [EOL] features_number_value_msg = ( [string] [string] ) [EOL] [comment] [EOL] features_percentage_type_msg = ( [string] [string] ) [EOL] features_percentage_value_msg = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( ONE_D_ARRAY , None , None , None , None ) [EOL] assert str ( exin . value ) == dataset_shape_msg [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( np . array ( [ [ None , [number] ] , [ [number] , [number] ] ] ) , None , None , None , None ) [EOL] assert str ( exin . value ) == dataset_type_msg [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( CATEGORICAL_NP_ARRAY , None , None , None , None ) [EOL] assert str ( exin . value ) == dataset_type_msg [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY , None , None , None ) [EOL] assert str ( exin . value ) == target_shape_msg [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , np . array ( [ [string] , [number] , [number] , [number] ] ) , None , None , None ) [EOL] assert str ( exin . value ) == target_type_msg [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET [ [number] : [number] ] , None , None , [number] ) [EOL] assert str ( exin . value ) == target_shape_2_msg [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY , None , None ) [EOL] assert str ( exin . value ) == weights_shape_msg [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , np . array ( [ None , [string] , [number] , [string] ] ) , None , None ) [EOL] assert str ( exin . value ) == weights_type_msg [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET [ [number] : [number] ] , None , None ) [EOL] assert str ( exin . value ) == weights_shape_2_msg [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [string] , None ) [EOL] assert str ( exin . value ) == features_number_type_msg [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , None ) [EOL] assert str ( exin . value ) == features_number_value_msg [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , None ) [EOL] assert str ( exin . value ) == features_percentage_type_msg [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , [number] ) [EOL] assert str ( exin . value ) == features_percentage_type_msg [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , - [number] ) [EOL] assert str ( exin . value ) == features_percentage_value_msg [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , [number] ) [EOL] assert str ( exin . value ) == features_percentage_value_msg [EOL] [EOL] [comment] [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , [number] ) [EOL] fudfs . _validate_input_lasso_path ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , NUMERICAL_NP_ARRAY_TARGET , [number] , [number] ) [EOL] [EOL] [EOL] def test_lasso_path ( caplog ) : [EOL] [docstring] [EOL] no_lasso_log = ( [string] [string] ) [EOL] less_lasso_log = ( [string] [string] ) [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] fatf . setup_random_seed ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) . startswith ( [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] [comment] [EOL] weights = np . ones ( ( NUMERICAL_NP_ARRAY . shape [ [number] ] , ) ) [EOL] [comment] [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] features = fudfs . lasso_path ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] features = fudfs . lasso_path ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == FEATURE_INDICES_WARNING [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == FEATURE_PERCENTAGE_LOG [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) * [number] [EOL] assert len ( caplog . records ) == [number] [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == no_lasso_log [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] features = fudfs . lasso_path ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] features = fudfs . lasso_path ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] features = fudfs . lasso_path ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == less_lasso_log . format ( [number] , [number] ) [EOL] [EOL] [EOL] def test_forward_selection ( caplog ) : [EOL] [docstring] [EOL] assert len ( caplog . records ) == [number] [EOL] fatf . setup_random_seed ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) . startswith ( [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] [comment] [EOL] weights = np . ones ( ( NUMERICAL_NP_ARRAY . shape [ [number] ] , ) ) [EOL] [comment] [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] features = fudfs . forward_selection ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] features = fudfs . forward_selection ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == FEATURE_INDICES_WARNING [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == FEATURE_PERCENTAGE_LOG [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) * [number] [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] features = fudfs . forward_selection ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] features = fudfs . forward_selection ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [EOL] [comment] [EOL] features = fudfs . forward_selection ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [EOL] def test_highest_weights ( caplog ) : [EOL] [docstring] [EOL] assert len ( caplog . records ) == [number] [EOL] fatf . setup_random_seed ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) . startswith ( [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] [comment] [EOL] weights = np . ones ( ( NUMERICAL_NP_ARRAY . shape [ [number] ] , ) ) [EOL] [comment] [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] features = fudfs . highest_weights ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] features = fudfs . highest_weights ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == FEATURE_INDICES_WARNING [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] [comment] [EOL] [comment] [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , features_percentage = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == FEATURE_PERCENTAGE_LOG [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) * [number] [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] [EOL] [comment] [EOL] weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] features = fudfs . highest_weights ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] features = fudfs . highest_weights ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET , weights , [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [string] , [string] ] ) ) [EOL] [EOL] [comment] [EOL] features = fudfs . highest_weights ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , features_number = [number] ) [EOL] assert fuav . is_1d_array ( features ) [EOL] assert np . array_equal ( features , np . array ( [ [number] , [number] ] ) ) [EOL] assert len ( caplog . records ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Type , Tuple , Any , List , Union [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . data . datasets as fudd [EOL] import fatf . utils . tools as fut [EOL] [EOL] _NUMPY_VERSION = [ int ( i ) for i in np . version . version . split ( [string] ) ] [EOL] _NUMPY_1_14 = fut . at_least_verion ( [ [number] , [number] ] , _NUMPY_VERSION ) [EOL] [EOL] [EOL] def test_validate_data_header ( ) : [EOL] [docstring] [EOL] assertion_2d = [string] [EOL] assertion_1d_y = [string] [EOL] assertion_1d_names = [string] [EOL] [EOL] value_error_samples = ( [string] [string] ) [EOL] value_error_features = ( [string] [string] ) [EOL] value_error_labels = ( [string] [string] ) [EOL] value_error_classes = ( [string] [string] ) [EOL] [EOL] one_d = np . array ( [ [number] , [number] , [number] ] ) [EOL] two_d = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] fudd . _validate_data_header ( one_d , two_d , [number] , [number] , two_d ) [EOL] assert str ( exin . value ) . startswith ( assertion_2d ) [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] fudd . _validate_data_header ( two_d , two_d , [number] , [number] , two_d ) [EOL] assert str ( exin . value ) . startswith ( assertion_1d_y ) [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] fudd . _validate_data_header ( two_d , one_d , [number] , [number] , two_d ) [EOL] assert str ( exin . value ) . startswith ( assertion_1d_names ) [EOL] [EOL] X = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] y = np . array ( [ [number] , [number] ] ) [EOL] y_too_long = np . array ( [ [number] , [number] , [number] ] ) [EOL] n_samples = [number] [EOL] n_features = [number] [EOL] y_names = np . array ( [ [string] , [string] ] ) [EOL] y_names_too_many = np . array ( [ [string] , [string] , [string] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _validate_data_header ( X , y , n_samples - [number] , n_features , y_names ) [EOL] assert str ( exin . value ) == value_error_samples [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _validate_data_header ( X , y , n_samples , n_features - [number] , y_names ) [EOL] assert str ( exin . value ) == value_error_features [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _validate_data_header ( X , y_too_long , n_samples , n_features , y_names ) [EOL] assert str ( exin . value ) == value_error_labels [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _validate_data_header ( X , y , n_samples , n_features , y_names_too_many ) [EOL] assert str ( exin . value ) == value_error_classes [EOL] [EOL] [comment] [EOL] assert fudd . _validate_data_header ( X , y , n_samples , n_features , y_names ) [EOL] [EOL] [comment] [EOL] assert fudd . _validate_data_header ( X , y , n_samples , n_features , np . array ( [ ] ) ) [EOL] [EOL] [EOL] def test_get_data_header ( tmpdir ) : [EOL] [docstring] [EOL] value_error = ( [string] [string] ) [EOL] type_error_samples = ( [string] [string] ) [EOL] type_error_features = ( [string] [string] [string] ) [EOL] [EOL] temp_dir = tmpdir . mkdir ( [string] ) [EOL] temp_file = temp_dir . join ( [string] ) [EOL] temp_file_path = temp_file . strpath [EOL] [EOL] def write_to_temp ( text ) : [EOL] return temp_file . write ( text , mode = [string] ) [EOL] [EOL] def is_empty_array ( array ) : [EOL] return np . array_equal ( np . array ( [ ] ) , array ) [EOL] [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_samples ) [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_samples ) [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_samples ) [EOL] [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_features ) [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_features ) [EOL] write_to_temp ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _get_data_header ( temp_file_path ) [EOL] assert str ( exin . value ) . endswith ( type_error_features ) [EOL] [EOL] write_to_temp ( [string] ) [EOL] n_samples , n_features , targ_names = fudd . _get_data_header ( temp_file_path ) [EOL] assert n_samples == [number] and n_features == [number] and is_empty_array ( targ_names ) [EOL] [EOL] write_to_temp ( [string] ) [EOL] n_samples , n_features , targ_names = fudd . _get_data_header ( temp_file_path ) [EOL] assert ( n_samples == [number] and n_features == [number] [EOL] and np . array_equal ( np . array ( [ [string] ] ) , targ_names ) ) [EOL] [EOL] write_to_temp ( [string] ) [EOL] n_samples , n_features , targ_names = fudd . _get_data_header ( temp_file_path ) [EOL] assert ( n_samples == [number] and n_features == [number] [EOL] and np . array_equal ( np . array ( [ [string] , [string] ] ) , targ_names ) ) [EOL] [EOL] [EOL] def test_load_data ( tmpdir ) : [EOL] [docstring] [EOL] value_error_feature_number = ( [string] [string] [string] ) [EOL] type_error_feature_string = ( [string] [string] ) [EOL] value_error_dual_names = ( [string] [string] [string] [string] ) [EOL] type_error_feature_names = ( [string] [string] [string] [string] ) [EOL] [EOL] value_error_dtype_tuple = ( [string] [string] [string] [string] ) [EOL] type_error_dtype_str = ( [string] [string] [string] ) [EOL] value_error_dtype_number = ( [string] [string] [string] [string] [string] ) [EOL] type_error_dtype = ( [string] [string] [string] ) [EOL] [EOL] temp_dir = tmpdir . mkdir ( [string] ) [EOL] temp_file = temp_dir . join ( [string] ) [EOL] temp_file_path = temp_file . strpath [EOL] [EOL] def write_to_temp ( text ) : [EOL] return temp_file . write ( text , mode = [string] ) [EOL] [EOL] simple_data = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] simple_target = np . array ( [ [number] , [number] ] ) [EOL] simple_target_names = np . array ( [ [string] , [string] ] ) [EOL] simple_feature_names_a = np . array ( [ [string] , [string] ] ) [EOL] write_to_temp ( [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , dtype = [number] ) [EOL] assert str ( exin . value ) == type_error_dtype [EOL] [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . int [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . int [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_feature_names_a ) [EOL] [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path , dtype = np . float32 ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_feature_names_a ) [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path , dtype = [string] ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_feature_names_a ) [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path , dtype = float ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float64 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float64 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_feature_names_a ) [EOL] [EOL] [comment] [EOL] my_dtype = [ ( [string] , np . float64 ) , ( [string] , [string] ) ] [EOL] my_names = np . array ( [ [string] , [string] ] ) [EOL] my_data = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) ] , dtype = my_dtype ) [EOL] loaded_data = fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] assert fuav . is_structured_array ( loaded_data [ [string] ] ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_data ) [EOL] for i in range ( len ( my_dtype ) ) : [EOL] assert loaded_data [ [string] ] . dtype . names [ i ] == my_dtype [ i ] [ [number] ] [EOL] assert loaded_data [ [string] ] . dtype [ i ] == my_dtype [ i ] [ [number] ] [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . int [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names ) [EOL] [comment] [EOL] my_dtype = [ ( [string] , np . float64 ) , [string] ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] assert str ( exin . value ) == value_error_dtype_tuple . format ( [string] ) [EOL] my_dtype = [ ( [string] , np . float64 ) , ( [string] , ) ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] assert str ( exin . value ) == value_error_dtype_tuple . format ( [string] ) [EOL] my_dtype = [ ( [string] , np . float64 ) , ( np . float64 , [string] ) ] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] e_format = [string] [EOL] assert str ( exin . value ) == type_error_dtype_str . format ( e_format ) [EOL] my_dtype = [ ( [string] , np . float64 ) ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] assert str ( exin . value ) == value_error_dtype_number [EOL] [EOL] [comment] [EOL] my_dtype = [ ( [string] , np . float64 ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] my_names = np . array ( [ [string] , [string] ] ) [EOL] my_target = np . array ( [ [string] , [string] ] ) [EOL] my_data = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) ] , dtype = my_dtype [ : - [number] ] ) [EOL] loaded_data = fudd . load_data ( temp_file_path , dtype = my_dtype ) [EOL] assert fuav . is_structured_array ( loaded_data [ [string] ] ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_data ) [EOL] for i in range ( len ( my_dtype [ : - [number] ] ) ) : [EOL] assert loaded_data [ [string] ] . dtype . names [ i ] == my_dtype [ i ] [ [number] ] [EOL] assert loaded_data [ [string] ] . dtype [ i ] == my_dtype [ i ] [ [number] ] [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . dtype ( [string] ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = [ [string] , [string] ] , dtype = [number] ) [EOL] assert str ( exin . value ) == type_error_dtype [EOL] [EOL] [comment] [EOL] my_names = [ [string] , [string] ] [EOL] my_names_np = np . array ( my_names ) [EOL] loaded_data = fudd . load_data ( temp_file_path , feature_names = my_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . int [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . int [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names_np ) [EOL] [comment] [EOL] wrong_type = [ [string] , [number] ] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = wrong_type ) [EOL] assert str ( exin . value ) == type_error_feature_string [EOL] [comment] [EOL] wrong_type = [ [string] , [string] , [string] ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = wrong_type ) [EOL] assert str ( exin . value ) == value_error_feature_number [EOL] [EOL] [comment] [EOL] my_names = [ [string] , [string] ] [EOL] my_names_np = np . array ( my_names ) [EOL] loaded_data = fudd . load_data ( temp_file_path , feature_names = my_names , dtype = np . float32 ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names_np ) [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path , feature_names = my_names , dtype = [string] ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float32 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names_np ) [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path , feature_names = my_names , dtype = float ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_data ) [EOL] assert loaded_data [ [string] ] . dtype == np . float64 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . float64 [EOL] assert np . array_equal ( loaded_data [ [string] ] , simple_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_names_np ) [EOL] [EOL] [comment] [EOL] my_names = [ [string] , [string] ] [EOL] my_types = [ ( [string] , int ) , ( [string] , int ) ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = my_names , dtype = my_types ) [EOL] assert str ( exin . value ) == value_error_dual_names [EOL] [EOL] [comment] [EOL] my_names = [ [string] , [string] ] [EOL] my_types = [ ( [string] , int ) , ( [string] , float ) , ( [string] , int ) ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = my_names , dtype = my_types ) [EOL] assert str ( exin . value ) == value_error_dual_names [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = [number] , dtype = [number] ) [EOL] assert str ( exin . value ) == type_error_feature_names [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = [number] ) [EOL] assert str ( exin . value ) == type_error_feature_names [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = [number] , dtype = np . int ) [EOL] assert str ( exin . value ) == type_error_feature_names [EOL] [EOL] [comment] [EOL] my_names = [ [string] , [string] ] [EOL] my_types = [ ( [string] , int ) , ( [string] , float ) , ( [string] , int ) ] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . load_data ( temp_file_path , feature_names = [number] , dtype = my_types ) [EOL] assert str ( exin . value ) == type_error_feature_names [EOL] [EOL] [comment] [EOL] string_type = [string] if _NUMPY_1_14 else [string] [EOL] write_to_temp ( [string] ) [EOL] my_feature_names = [ [string] , [string] ] [EOL] my_feature_names_np = np . array ( my_feature_names ) [EOL] my_feature_dtype = [ ( [string] , np . int ) , ( [string] , np . dtype ( string_type . format ( [string] ) ) ) ] [EOL] my_data = np . array ( [ ( [number] , [string] ) , ( [number] , [string] ) ] , dtype = my_feature_dtype ) [EOL] my_target = np . array ( [ [string] , [string] ] , dtype = string_type . format ( [string] ) ) [EOL] my_target_names = np . array ( [ [string] , [string] ] ) [EOL] [comment] [EOL] loaded_data = fudd . load_data ( temp_file_path ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_data ) [EOL] for i in range ( len ( my_feature_names ) ) : [EOL] assert loaded_data [ [string] ] . dtype . names [ i ] == my_feature_names [ i ] [EOL] assert loaded_data [ [string] ] . dtype [ i ] == my_feature_dtype [ i ] [ [number] ] [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . dtype ( string_type . format ( [string] ) ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_feature_names_np ) [EOL] [comment] [EOL] my_feature_names = [ [string] , [string] ] [EOL] my_feature_names_np = np . array ( my_feature_names ) [EOL] my_feature_dtype = [ ( [string] , np . int ) , ( [string] , np . dtype ( string_type . format ( [string] ) ) ) ] [EOL] my_data = np . array ( [ ( [number] , [string] ) , ( [number] , [string] ) ] , dtype = my_feature_dtype ) [EOL] loaded_data = fudd . load_data ( temp_file_path , feature_names = my_feature_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_data ) [EOL] for i in range ( len ( my_feature_names ) ) : [EOL] assert loaded_data [ [string] ] . dtype . names [ i ] == my_feature_names [ i ] [EOL] assert loaded_data [ [string] ] . dtype [ i ] == my_feature_dtype [ i ] [ [number] ] [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_target ) [EOL] assert loaded_data [ [string] ] . dtype == np . dtype ( string_type . format ( [string] ) ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_target_names ) [EOL] assert np . array_equal ( loaded_data [ [string] ] , my_feature_names_np ) [EOL] [EOL] [EOL] def test_load_iris ( ) : [EOL] [docstring] [EOL] [comment] [EOL] n_samples = [number] [EOL] n_features = [number] [EOL] check_ind = np . array ( [ [number] , [number] , [number] ] ) [EOL] true_data = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [comment] [EOL] true_target = np . array ( [ [number] , [number] , [number] ] ) [EOL] target_names = np . array ( [ [string] , [string] , [string] ] ) [EOL] feature_names = np . array ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] iris_data = fudd . load_iris ( ) [EOL] assert not fuav . is_structured_array ( iris_data [ [string] ] ) [EOL] assert iris_data [ [string] ] . shape == ( n_samples , n_features ) [EOL] assert iris_data [ [string] ] . shape == ( n_samples , ) [EOL] assert np . array_equal ( iris_data [ [string] ] , target_names ) [EOL] assert np . array_equal ( iris_data [ [string] ] , feature_names ) [EOL] [EOL] assert np . isclose ( iris_data [ [string] ] [ check_ind , : ] , true_data ) . all ( ) [EOL] assert np . isclose ( iris_data [ [string] ] [ check_ind ] , true_target ) . all ( ) [EOL] [EOL] [EOL] def test_load_health_records ( ) : [EOL] [docstring] [EOL] [comment] [EOL] n_samples = [number] [EOL] n_features = [number] [EOL] check_ind = np . array ( [ [number] , [number] , [number] ] ) [EOL] dtypes = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] [EOL] true_data = np . array ( [ ( [string] , [string] , [number] , [number] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [number] , [number] , [string] , [string] , [string] , [string] ) , ( [string] , [string] , [number] , [number] , [string] , [string] , [string] , [string] ) ] , dtype = dtypes ) [EOL] true_target = np . array ( [ [number] , [number] , [number] ] ) [EOL] target_names = np . array ( [ [string] , [string] ] ) [EOL] feature_names = np . array ( [ x for ( x , y ) in dtypes ] ) [EOL] [EOL] cat_data = fudd . load_health_records ( ) [EOL] assert fuav . is_structured_array ( cat_data [ [string] ] ) [EOL] assert cat_data [ [string] ] . shape == ( n_samples , ) [EOL] assert len ( cat_data [ [string] ] . dtype . names ) == n_features [EOL] assert cat_data [ [string] ] . shape == ( n_samples , ) [EOL] assert np . array_equal ( cat_data [ [string] ] , target_names ) [EOL] assert np . array_equal ( cat_data [ [string] ] , feature_names ) [EOL] [EOL] assert np . array_equal ( cat_data [ [string] ] [ check_ind ] , true_data ) [EOL] assert np . array_equal ( cat_data [ [string] ] [ check_ind ] , true_target ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . transformation as fudt [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [comment] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] NUMERICAL_NP_BINARY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_BINARY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , np . int8 ) , ( [string] , np . int8 ) , ( [string] , np . int8 ) , ( [string] , np . int8 ) ] ) [EOL] CATEGORICAL_NP_BINARY = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] CATEGORICAL_STRUCT_BINARY = np . array ( [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] , dtype = [ ( [string] , np . int8 ) , ( [string] , np . int8 ) , ( [string] , np . int8 ) ] ) [EOL] MIXED_BINARY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , np . int8 ) , ( [string] , np . int8 ) , ( [string] , np . int8 ) , ( [string] , np . int8 ) ] ) [EOL] [comment] [EOL] [EOL] [EOL] def test_validate_input_drm ( ) : [EOL] [docstring] [EOL] incorrect_shape_dataset = ( [string] [string] ) [EOL] type_error_data = ( [string] [string] ) [EOL] [comment] [EOL] incorrect_shape_data_row = ( [string] [string] [string] ) [EOL] [comment] [EOL] type_error_data_row = ( [string] [string] ) [EOL] incorrect_shape_features = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . _validate_input_drm ( NUMERICAL_NP_ARRAY [ [number] ] , None ) [EOL] assert str ( exin . value ) == incorrect_shape_dataset [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . _validate_input_drm ( np . array ( [ [ None , [number] ] , [ [number] , [number] ] ] ) , np . array ( [ ] ) ) [EOL] assert str ( exin . value ) == type_error_data [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . _validate_input_drm ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == incorrect_shape_data_row [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . _validate_input_drm ( NUMERICAL_NP_ARRAY , CATEGORICAL_NP_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . _validate_input_drm ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] [ : [number] ] ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [EOL] [EOL] def test_dataset_row_masking ( ) : [EOL] [docstring] [EOL] binary = fudt . dataset_row_masking ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( binary , NUMERICAL_NP_BINARY ) [EOL] [EOL] binary = fudt . dataset_row_masking ( NUMERICAL_NP_ARRAY , np . array ( [ [number] ] * [number] ) ) [EOL] assert np . array_equal ( binary , np . zeros_like ( NUMERICAL_NP_BINARY ) ) [EOL] [EOL] binary = fudt . dataset_row_masking ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( binary , NUMERICAL_STRUCT_BINARY ) [EOL] [EOL] array = np . array ( [ ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [ [number] ] [EOL] binary = fudt . dataset_row_masking ( NUMERICAL_STRUCT_ARRAY , array ) [EOL] assert np . array_equal ( binary , np . zeros_like ( NUMERICAL_STRUCT_BINARY ) ) [EOL] [EOL] binary = fudt . dataset_row_masking ( CATEGORICAL_NP_ARRAY , CATEGORICAL_NP_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( binary , CATEGORICAL_NP_BINARY ) [EOL] [EOL] array = np . array ( [ [string] ] * [number] ) [EOL] binary = fudt . dataset_row_masking ( CATEGORICAL_NP_ARRAY , array ) [EOL] assert np . array_equal ( binary , np . zeros_like ( CATEGORICAL_NP_BINARY ) ) [EOL] [EOL] binary = fudt . dataset_row_masking ( CATEGORICAL_STRUCT_ARRAY , CATEGORICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( binary , CATEGORICAL_STRUCT_BINARY ) [EOL] [EOL] array = np . array ( [ ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [ [number] ] [EOL] binary = fudt . dataset_row_masking ( CATEGORICAL_STRUCT_ARRAY , array ) [EOL] assert np . array_equal ( binary , np . zeros_like ( CATEGORICAL_STRUCT_BINARY ) ) [EOL] [EOL] binary = fudt . dataset_row_masking ( MIXED_ARRAY , MIXED_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( binary , MIXED_BINARY ) [EOL] [EOL] array = np . array ( [ ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [ [number] ] [comment] [EOL] binary = fudt . dataset_row_masking ( MIXED_ARRAY , array ) [EOL] assert np . array_equal ( binary , np . zeros_like ( MIXED_BINARY ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any , Dict , List [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . discretisation as fudd [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [comment] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_3D_ARRAY = np . ones ( ( [number] , [number] , [number] ) ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] NUMERICAL_NP_CAT_DISCRETISED = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_CAT_DISCRETISED = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_DISCRETISED = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [comment] [EOL] [EOL] [EOL] def test_validate_input_discretiser ( ) : [EOL] [docstring] [EOL] data_incorrect_shape = ( [string] [string] ) [EOL] data_type_error = [string] [EOL] [comment] [EOL] cidx_index_error = ( [string] [string] ) [EOL] cidx_type_error = ( [string] [string] ) [EOL] [comment] [EOL] feature_names_type_error = ( [string] [string] ) [EOL] feature_name_type_error = ( [string] [string] ) [EOL] feature_names_incorrect_shape = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudd . _validate_input_discretiser ( np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == data_incorrect_shape [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _validate_input_discretiser ( np . array ( [ [ [number] , [number] ] , [ None , [number] ] ] ) ) [EOL] assert str ( exin . value ) == data_type_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _validate_input_discretiser ( NUMERICAL_NP_ARRAY , categorical_indices = [number] ) [EOL] assert str ( exin . value ) == cidx_type_error [EOL] [comment] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] fudd . _validate_input_discretiser ( MIXED_ARRAY , categorical_indices = [ [string] ] ) [EOL] assert str ( exin . value ) == cidx_index_error . format ( [ [string] ] ) [EOL] with pytest . raises ( IndexError ) as exin : [EOL] fudd . _validate_input_discretiser ( MIXED_ARRAY , categorical_indices = [ [number] ] ) [EOL] assert str ( exin . value ) == cidx_index_error . format ( [ [number] ] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _validate_input_discretiser ( NUMERICAL_NP_ARRAY , feature_names = [string] ) [EOL] assert str ( exin . value ) == feature_names_type_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudd . _validate_input_discretiser ( NUMERICAL_NP_ARRAY , feature_names = [ [number] ] ) [EOL] assert str ( exin . value ) == feature_names_incorrect_shape [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _validate_input_discretiser ( NUMERICAL_NP_ARRAY , feature_names = [ [number] , [number] , [number] , [string] ] ) [EOL] assert str ( exin . value ) == feature_name_type_error . format ( [number] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . _validate_input_discretiser ( MIXED_ARRAY , feature_names = [ [string] , [string] , [number] , [string] ] ) [EOL] assert str ( exin . value ) == feature_name_type_error . format ( [number] ) [EOL] [EOL] assert fudd . _validate_input_discretiser ( MIXED_ARRAY , categorical_indices = [ [string] , [string] ] ) [EOL] [EOL] [EOL] class TestDiscretiser ( ) : [EOL] [docstring] [EOL] [EOL] class BrokenDiscretiser ( fudd . Discretiser ) : [EOL] [docstring] [EOL] [EOL] class BaseDiscretiser ( fudd . Discretiser ) : [EOL] [docstring] [EOL] [EOL] def discretise ( self , data ) : [EOL] [docstring] [EOL] self . _validate_input_discretise ( data ) [EOL] return np . ones ( data . shape ) [EOL] [EOL] def test_discretiser_class_init ( self ) : [EOL] [docstring] [EOL] abstract_method_error = ( [string] [string] ) [EOL] user_warning = ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudd . Discretiser ( NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == abstract_method_error . format ( [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . BrokenDiscretiser ( NUMERICAL_NP_ARRAY ) [EOL] msg = abstract_method_error . format ( [string] ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] discretiser = self . BaseDiscretiser ( CATEGORICAL_NP_ARRAY , [ [number] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] assert np . array_equal ( discretiser . categorical_indices , [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] discretiser = self . BaseDiscretiser ( CATEGORICAL_STRUCT_ARRAY , [ [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] assert np . array_equal ( discretiser . categorical_indices , np . array ( [ [string] , [string] , [string] ] ) ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] discretiser = self . BaseDiscretiser ( MIXED_ARRAY , [ [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] assert np . array_equal ( discretiser . categorical_indices , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] categorical_np_discretiser = self . BaseDiscretiser ( CATEGORICAL_NP_ARRAY , feature_names = [ [string] , [string] , [string] ] ) [EOL] assert categorical_np_discretiser . dataset_dtype == np . dtype ( [string] ) [EOL] assert not categorical_np_discretiser . is_structured [EOL] assert categorical_np_discretiser . features_number == [number] [EOL] assert categorical_np_discretiser . categorical_indices == [ [number] , [number] , [number] ] [EOL] assert categorical_np_discretiser . numerical_indices == [ ] [EOL] assert ( categorical_np_discretiser . feature_names_map == dict ( zip ( [ [number] , [number] , [number] ] , [ [string] , [string] , [string] ] ) ) ) [comment] [EOL] assert categorical_np_discretiser . feature_value_names == { } [EOL] assert categorical_np_discretiser . feature_bin_boundaries == { } [EOL] [EOL] categorical_struct_discretiser = self . BaseDiscretiser ( CATEGORICAL_STRUCT_ARRAY ) [EOL] assert ( categorical_struct_discretiser . dataset_dtype == np . dtype ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [comment] [EOL] assert categorical_struct_discretiser . is_structured [EOL] assert categorical_struct_discretiser . features_number == [number] [EOL] assert ( categorical_struct_discretiser . categorical_indices == [ [string] , [string] , [string] ] ) [comment] [EOL] assert categorical_struct_discretiser . numerical_indices == [ ] [EOL] assert ( categorical_struct_discretiser . feature_names_map == dict ( zip ( [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ) ) ) [comment] [EOL] assert categorical_struct_discretiser . feature_value_names == { } [EOL] assert categorical_struct_discretiser . feature_bin_boundaries == { } [EOL] [EOL] mixed_discretiser = self . BaseDiscretiser ( MIXED_ARRAY ) [EOL] assert ( mixed_discretiser . dataset_dtype == np . dtype ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [comment] [EOL] assert mixed_discretiser . is_structured [EOL] assert mixed_discretiser . features_number == [number] [EOL] assert mixed_discretiser . categorical_indices == [ [string] , [string] ] [EOL] assert mixed_discretiser . numerical_indices == [ [string] , [string] ] [EOL] assert ( mixed_discretiser . feature_names_map == dict ( zip ( [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ) ) ) [comment] [EOL] assert mixed_discretiser . feature_value_names == { } [EOL] assert mixed_discretiser . feature_bin_boundaries == { } [EOL] [EOL] numerical_np_discretiser = self . BaseDiscretiser ( NUMERICAL_NP_ARRAY , [ [number] , [number] ] , feature_names = [ [string] , [string] , [string] , [string] ] ) [EOL] assert numerical_np_discretiser . dataset_dtype == np . dtype ( [string] ) [EOL] assert not numerical_np_discretiser . is_structured [EOL] assert numerical_np_discretiser . features_number == [number] [EOL] assert numerical_np_discretiser . categorical_indices == [ [number] , [number] ] [EOL] assert numerical_np_discretiser . numerical_indices == [ [number] , [number] ] [EOL] assert ( numerical_np_discretiser . feature_names_map == dict ( zip ( [ [number] , [number] , [number] , [number] ] , [ [string] , [string] , [string] , [string] ] ) ) ) [comment] [EOL] assert numerical_np_discretiser . feature_value_names == { } [EOL] assert numerical_np_discretiser . feature_bin_boundaries == { } [EOL] [EOL] def test_validate_input_discretise ( self ) : [EOL] [docstring] [EOL] incorrect_shape_data_row = ( [string] [string] [string] [string] ) [EOL] type_error_data_row = ( [string] [string] [string] ) [EOL] incorrect_shape_features = ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] numerical_np_discretiser = self . BaseDiscretiser ( NUMERICAL_NP_ARRAY ) [EOL] categorical_np_discretiser = self . BaseDiscretiser ( CATEGORICAL_NP_ARRAY ) [EOL] numerical_struct_discretiser = self . BaseDiscretiser ( NUMERICAL_STRUCT_ARRAY ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] numerical_np_discretiser . discretise ( NUMERICAL_3D_ARRAY ) [EOL] assert str ( exin . value ) == incorrect_shape_data_row [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] numerical_np_discretiser . discretise ( np . array ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] numerical_struct_discretiser . discretise ( MIXED_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] categorical_np_discretiser . discretise ( np . array ( [ [number] ] ) ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] numerical_struct_discretiser . discretise ( MIXED_ARRAY [ [ [string] , [string] ] ] [ [number] ] ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] numerical_np_discretiser . discretise ( np . array ( [ [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] categorical_np_discretiser . discretise ( np . array ( [ [string] , [string] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] numerical_np_discretiser . discretise ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] categorical_np_discretiser . discretise ( np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [EOL] [comment] [EOL] assert np . array_equal ( numerical_np_discretiser . discretise ( NUMERICAL_NP_ARRAY [ [number] , : ] ) , np . ones ( NUMERICAL_NP_ARRAY [ [number] , : ] . shape ) ) [EOL] assert np . array_equal ( numerical_np_discretiser . discretise ( NUMERICAL_NP_ARRAY ) , np . ones ( NUMERICAL_NP_ARRAY . shape ) ) [EOL] assert np . array_equal ( categorical_np_discretiser . discretise ( CATEGORICAL_NP_ARRAY [ [number] , : ] ) , np . ones ( CATEGORICAL_NP_ARRAY [ [number] , : ] . shape ) ) [EOL] assert np . array_equal ( categorical_np_discretiser . discretise ( CATEGORICAL_NP_ARRAY ) , np . ones ( CATEGORICAL_NP_ARRAY . shape ) ) [EOL] [EOL] [EOL] class TestQuartileDiscretiser ( object ) : [EOL] [docstring] [EOL] numerical_np_discretiser = fudd . QuartileDiscretiser ( NUMERICAL_NP_ARRAY , [ [number] ] ) [EOL] numerical_np_discretiser_full = fudd . QuartileDiscretiser ( NUMERICAL_NP_ARRAY [ : , [number] : ] , [ ] ) [EOL] numerical_struct_discretiser = fudd . QuartileDiscretiser ( NUMERICAL_STRUCT_ARRAY , [ [string] ] ) [EOL] [EOL] categorical_np_discretiser = fudd . QuartileDiscretiser ( CATEGORICAL_NP_ARRAY , [ [number] , [number] , [number] ] ) [EOL] categorical_struct_discretiser = fudd . QuartileDiscretiser ( CATEGORICAL_STRUCT_ARRAY , [ [string] , [string] , [string] ] ) [EOL] [EOL] mixed_struct_discretiser = fudd . QuartileDiscretiser ( MIXED_ARRAY , [ [string] , [string] ] ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] correct_feature_names = { [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } } [EOL] correct_feature_names_full = { [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [number] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } } [EOL] correct_feature_names_struct = { [string] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [string] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [string] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } } [EOL] correct_feature_names_mixed = { [string] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } , [string] : { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } } [EOL] bins = [ np . array ( [ [number] , [number] , [number] ] ) , np . array ( [ [number] , [number] , [number] ] ) , np . array ( [ [number] , [number] , [number] ] ) ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert self . numerical_np_discretiser . categorical_indices == [ [number] ] [EOL] assert self . numerical_np_discretiser . numerical_indices == [ [number] , [number] , [number] ] [EOL] assert ( self . numerical_np_discretiser . feature_value_names == correct_feature_names ) [comment] [EOL] keys = sorted ( correct_feature_names . keys ( ) ) [EOL] for i , key in enumerate ( keys ) : [EOL] assert np . allclose ( self . numerical_np_discretiser . feature_bin_boundaries [ key ] , bins [ i ] , atol = [number] ) [EOL] assert ( self . numerical_np_discretiser . discretised_dtype == np . dtype ( [string] ) ) [comment] [EOL] [EOL] assert self . numerical_struct_discretiser . categorical_indices == [ [string] ] [EOL] assert ( self . numerical_struct_discretiser . numerical_indices == [ [string] , [string] , [string] ] ) [comment] [EOL] assert ( self . numerical_struct_discretiser . feature_value_names == correct_feature_names_struct ) [comment] [EOL] keys = sorted ( correct_feature_names_struct . keys ( ) ) [EOL] for i , key in enumerate ( keys ) : [EOL] assert np . allclose ( self . numerical_struct_discretiser . feature_bin_boundaries [ key ] , bins [ i ] , atol = [number] ) [EOL] assert ( self . numerical_struct_discretiser . discretised_dtype == np . dtype ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [comment] [EOL] [EOL] assert ( self . categorical_np_discretiser . categorical_indices == [ [number] , [number] , [number] ] ) [comment] [EOL] assert self . categorical_np_discretiser . numerical_indices == [ ] [EOL] assert self . categorical_np_discretiser . feature_value_names == { } [EOL] assert self . categorical_np_discretiser . feature_bin_boundaries == { } [EOL] assert ( self . categorical_np_discretiser . discretised_dtype == np . dtype ( [string] ) ) [comment] [EOL] [EOL] assert self . numerical_np_discretiser_full . categorical_indices == [ ] [EOL] assert ( self . numerical_np_discretiser_full . numerical_indices == [ [number] , [number] , [number] ] ) [comment] [EOL] assert ( self . numerical_np_discretiser_full . feature_value_names == correct_feature_names_full ) [comment] [EOL] keys = sorted ( correct_feature_names . keys ( ) ) [EOL] for i , key in enumerate ( keys ) : [EOL] fky = key - [number] [EOL] assert np . allclose ( self . numerical_np_discretiser_full . feature_bin_boundaries [ fky ] , bins [ i ] , atol = [number] ) [EOL] assert ( self . numerical_np_discretiser_full . discretised_dtype == np . dtype ( [string] ) ) [comment] [EOL] [EOL] assert ( self . categorical_struct_discretiser . categorical_indices == [ [string] , [string] , [string] ] ) [comment] [EOL] assert self . categorical_struct_discretiser . numerical_indices == [ ] [EOL] assert self . categorical_struct_discretiser . feature_value_names == { } [EOL] assert self . categorical_struct_discretiser . feature_bin_boundaries == { } [EOL] assert ( self . categorical_struct_discretiser . discretised_dtype == np . dtype ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [comment] [EOL] [EOL] assert self . mixed_struct_discretiser . categorical_indices == [ [string] , [string] ] [EOL] assert self . mixed_struct_discretiser . numerical_indices == [ [string] , [string] ] [EOL] assert ( self . mixed_struct_discretiser . feature_value_names == correct_feature_names_mixed ) [comment] [EOL] keys = sorted ( correct_feature_names_mixed . keys ( ) ) [EOL] for i , key in enumerate ( keys ) : [EOL] assert np . allclose ( self . mixed_struct_discretiser . feature_bin_boundaries [ key ] , bins [ i ] , atol = [number] ) [EOL] assert ( self . mixed_struct_discretiser . discretised_dtype == np . dtype ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [EOL] [EOL] def test_discretise ( self ) : [EOL] [docstring] [EOL] discretised = self . numerical_np_discretiser . discretise ( NUMERICAL_NP_ARRAY ) [EOL] assert np . array_equal ( discretised , NUMERICAL_NP_CAT_DISCRETISED ) [EOL] discretised = self . numerical_np_discretiser . discretise ( NUMERICAL_NP_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( discretised , NUMERICAL_NP_CAT_DISCRETISED [ [number] ] ) [EOL] [EOL] discretised = self . numerical_struct_discretiser . discretise ( NUMERICAL_STRUCT_ARRAY ) [EOL] assert np . array_equal ( discretised , NUMERICAL_STRUCT_CAT_DISCRETISED ) [EOL] discretised = self . numerical_struct_discretiser . discretise ( NUMERICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( discretised , NUMERICAL_STRUCT_CAT_DISCRETISED [ [number] ] ) [EOL] assert isinstance ( discretised , np . void ) [EOL] [EOL] discretised = self . categorical_np_discretiser . discretise ( CATEGORICAL_NP_ARRAY ) [EOL] assert np . array_equal ( discretised , CATEGORICAL_NP_ARRAY ) [EOL] discretised = self . categorical_np_discretiser . discretise ( CATEGORICAL_NP_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( discretised , CATEGORICAL_NP_ARRAY [ [number] ] ) [EOL] [EOL] discretised = self . numerical_np_discretiser_full . discretise ( NUMERICAL_NP_ARRAY [ : , [number] : ] ) [EOL] assert np . array_equal ( discretised , NUMERICAL_NP_CAT_DISCRETISED [ : , [number] : ] ) [EOL] discretised = self . numerical_np_discretiser_full . discretise ( NUMERICAL_NP_ARRAY [ [number] , [number] : ] ) [EOL] assert np . array_equal ( discretised , NUMERICAL_NP_CAT_DISCRETISED [ [number] , [number] : ] ) [EOL] [EOL] discretised = self . categorical_struct_discretiser . discretise ( CATEGORICAL_STRUCT_ARRAY ) [EOL] assert np . array_equal ( discretised , CATEGORICAL_STRUCT_ARRAY ) [EOL] discretised = self . categorical_struct_discretiser . discretise ( CATEGORICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( discretised , CATEGORICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert isinstance ( discretised , np . void ) [EOL] [EOL] discretised = self . mixed_struct_discretiser . discretise ( MIXED_ARRAY ) [EOL] assert np . array_equal ( discretised , MIXED_DISCRETISED ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.tests.test_discretisation.TestDiscretiser.BaseDiscretiser$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.data.discretisation.QuartileDiscretiser$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,builtins.str]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Type , Tuple , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] import pytest [EOL] [EOL] import fatf [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . data . instance_augmentation as fudi [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [comment] [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [comment] [EOL] [EOL] [EOL] def test_validate_input ( ) : [EOL] [docstring] [EOL] shape_msg = ( [string] [string] ) [EOL] samples_msg = [string] [EOL] samples_type_msg = [string] [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_NP_ARRAY , None ) [EOL] assert str ( exin . value ) == shape_msg [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_STRUCT_ARRAY , None ) [EOL] assert str ( exin . value ) == shape_msg [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_NP_ARRAY [ [number] ] , - [number] ) [EOL] assert str ( exin . value ) == samples_msg [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_STRUCT_ARRAY [ [number] ] , [number] ) [EOL] assert str ( exin . value ) == samples_msg [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_NP_ARRAY [ [number] ] , [string] ) [EOL] assert str ( exin . value ) == samples_type_msg [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudi . _validate_input ( NUMERICAL_STRUCT_ARRAY [ [number] ] , [number] ) [EOL] assert str ( exin . value ) == samples_type_msg [EOL] [EOL] [comment] [EOL] assert fudi . _validate_input ( NUMERICAL_NP_ARRAY [ [number] ] , [number] ) [EOL] assert fudi . _validate_input ( NUMERICAL_STRUCT_ARRAY [ [number] ] , [number] ) [EOL] assert fudi . _validate_input ( CATEGORICAL_NP_ARRAY [ [number] ] , [number] ) [EOL] assert fudi . _validate_input ( CATEGORICAL_STRUCT_ARRAY [ [number] ] , [number] ) [EOL] assert fudi . _validate_input ( MIXED_ARRAY [ [number] ] , [number] ) [EOL] [EOL] [EOL] def test_binary_sampler ( ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] binary_msg = [string] [EOL] proportions = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] numerical_binary_array = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] numerical_binary_array_sampled = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [comment] [EOL] [EOL] struct_dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , bool ) ] [EOL] numerical_binary_struct_array = np . array ( [ ( [number] , [number] , [number] , True ) ] , dtype = struct_dtype ) [EOL] numerical_binary_struct_array = numerical_binary_struct_array [ [number] ] [EOL] numerical_binary_struct_array_sampled = np . array ( [ ( [number] , [number] , [number] , False ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , True ) , ( [number] , [number] , [number] , False ) ] , dtype = struct_dtype ) [comment] [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . binary_sampler ( np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == binary_msg [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . binary_sampler ( np . array ( [ [number] , [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == binary_msg [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . binary_sampler ( CATEGORICAL_STRUCT_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == binary_msg [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudi . binary_sampler ( MIXED_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == binary_msg [EOL] [EOL] [comment] [EOL] [EOL] samples = fudi . binary_sampler ( numerical_binary_array , samples_number = [number] ) [EOL] assert np . array_equal ( samples , numerical_binary_array_sampled ) [EOL] [EOL] samples = fudi . binary_sampler ( numerical_binary_array , samples_number = [number] ) [EOL] assert np . allclose ( samples . sum ( axis = [number] ) / samples . shape [ [number] ] , proportions , atol = [number] ) [EOL] [EOL] samples = fudi . binary_sampler ( numerical_binary_struct_array , samples_number = [number] ) [EOL] assert np . array_equal ( samples , numerical_binary_struct_array_sampled ) [EOL] assert fuav . are_similar_dtype_arrays ( np . asarray ( numerical_binary_struct_array ) , samples , True ) [EOL] [EOL] samples = fudi . binary_sampler ( numerical_binary_struct_array , samples_number = [number] ) [EOL] for i , name in enumerate ( numerical_binary_struct_array . dtype . names ) : [EOL] assert np . allclose ( samples [ name ] . sum ( ) / samples [ name ] . shape [ [number] ] , proportions [ i ] , atol = [number] ) [EOL] assert fuav . are_similar_dtype_arrays ( np . asarray ( numerical_binary_struct_array ) , samples , True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . tools as fudt [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [EOL] def test_group_by_column_errors ( ) : [EOL] [docstring] [EOL] incorrect_shape_error_data = [string] [EOL] value_error_data = ( [string] [string] ) [EOL] [comment] [EOL] index_error_index = ( [string] [string] ) [EOL] type_error_index = [string] [EOL] [comment] [EOL] value_error_bins = [string] [EOL] type_error_bins = ( [string] [string] ) [EOL] [comment] [EOL] value_error_grouping_num_empty = ( [string] [string] ) [EOL] type_error_grouping_num_inner = ( [string] [string] [string] ) [EOL] value_error_grouping_num_monotonicity = ( [string] [string] [string] ) [EOL] type_error_grouping_num_general = ( [string] [string] [string] ) [EOL] [comment] [EOL] type_error_grouping_cat_general = ( [string] [string] [string] [string] [string] ) [EOL] type_error_grouping_cat_tuple = ( [string] [string] [string] ) [EOL] value_error_grouping_cat_empty = ( [string] [string] ) [EOL] value_error_grouping_cat_extra = ( [string] [string] ) [EOL] value_error_grouping_cat_unique = ( [string] [string] ) [EOL] [comment] [EOL] type_error_tac = [string] [EOL] [comment] [EOL] user_warning_val = ( [string] [string] ) [EOL] user_warning_ind = ( [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] num_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] cat_array = np . array ( [ [ [string] , [string] ] , [ [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . group_by_column ( np . ones ( ( [number] , [number] , [number] ) ) , [number] ) [EOL] assert str ( exin . value ) == incorrect_shape_error_data [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( np . array ( [ [ [number] , [number] ] , [ [number] , None ] ] ) , None ) [EOL] assert str ( exin . value ) == value_error_data [EOL] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] ) [EOL] assert str ( exin . value ) == index_error_index . format ( [number] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( num_array , None ) [EOL] assert str ( exin . value ) == type_error_index [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , numerical_bins_number = [number] ) [EOL] assert str ( exin . value ) == value_error_bins [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , numerical_bins_number = [string] ) [EOL] assert str ( exin . value ) == type_error_bins [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , groupings = [string] ) [EOL] assert str ( exin . value ) == type_error_grouping_num_general [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , groupings = [ ] ) [EOL] assert str ( exin . value ) == value_error_grouping_num_empty [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , groupings = [ [number] , [number] , [number] , [string] ] ) [EOL] assert str ( exin . value ) == type_error_grouping_num_inner . format ( [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( num_array , [number] , groupings = [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert str ( exin . value ) == value_error_grouping_num_monotonicity [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , groupings = [string] ) [EOL] assert str ( exin . value ) == type_error_grouping_cat_general [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , groupings = [ ( [string] , ) , [ [string] ] , ( [string] , ) ] ) [EOL] assert str ( exin . value ) == type_error_grouping_cat_tuple . format ( [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , groupings = [ ] ) [EOL] assert str ( exin . value ) == value_error_grouping_cat_empty [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , groupings = [ ( [string] , [string] ) , ( [string] , ) ] ) [EOL] assert str ( exin . value ) == value_error_grouping_cat_extra . format ( [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , groupings = [ ( [string] , [string] ) , ( [string] , ) ] ) [EOL] assert str ( exin . value ) == value_error_grouping_cat_unique [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . group_by_column ( cat_array , [number] , treat_as_categorical = [string] ) [EOL] assert str ( exin . value ) == type_error_tac [EOL] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] grp , grpn = fudt . group_by_column ( cat_array , [number] , groupings = [ ( [string] , ) ] ) [EOL] assert len ( warning ) == [number] [EOL] assert user_warning_val . format ( [string] ) == str ( warning [ [number] ] . message ) [EOL] assert user_warning_ind . format ( [string] ) == str ( warning [ [number] ] . message ) [EOL] assert grp == [ [ [number] ] ] [EOL] assert grpn == [ [string] ] [EOL] [comment] [EOL] nan_array = np . array ( [ [ [number] , np . inf ] , [ [number] , [number] ] , [ [number] , - np . inf ] , [ [number] , np . nan ] ] ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] grp , grpn = fudt . group_by_column ( nan_array , [number] , groupings = [ [number] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert user_warning_ind . format ( [string] ) == str ( warning [ [number] ] . message ) [EOL] assert grp == [ [ [number] ] , [ [number] , [number] ] ] [EOL] assert grpn == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_group_by_column ( ) : [EOL] [docstring] [EOL] user_warning_tac = ( [string] [string] [string] [string] ) [EOL] [EOL] n_1_grp = [ [ [number] , [number] , [number] , [number] ] , [ [number] ] , [ ] , [ ] , [ [number] ] ] [EOL] n_1_grps = [ [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] n_0_grp = [ [ [number] , [number] ] , [ [number] ] , [ [number] , [number] , [number] ] ] [EOL] n_0_grps = [ [string] , [string] , [string] ] [EOL] n_2_grp = [ [ [number] ] , [ [number] , [number] , [number] , [number] , [number] ] ] [EOL] n_2_grps = [ [string] , [string] ] [EOL] [EOL] c_1_grp_d = [ [ [number] , [number] ] , [ [number] ] , [ [number] , [number] ] , [ [number] ] ] [EOL] c_1_grps_d = [ [string] , [string] , [string] , [string] ] [EOL] c_1_grp_c = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] c_1_grps_c = [ [string] , [string] ] [EOL] [EOL] num_array = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , - [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , - [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] struct_array = np . array ( [ ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , - [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) ] , dtype = [ ( [string] , np . float32 ) , ( [string] , [string] ) , ( [string] , np . int32 ) ] ) [comment] [EOL] cat_array = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [comment] [EOL] [EOL] [comment] [EOL] grp , grpn = fudt . group_by_column ( num_array , [number] ) [EOL] assert grp == n_1_grp [EOL] assert grpn == n_1_grps [EOL] grp , grpn = fudt . group_by_column ( num_array , [number] , treat_as_categorical = False ) [EOL] assert grp == n_1_grp [EOL] assert grpn == n_1_grps [EOL] grp , grpn = fudt . group_by_column ( num_array , [number] , treat_as_categorical = True ) [EOL] assert grp == [ [ [number] ] , [ [number] ] , [ [number] , [number] ] , [ [number] ] , [ [number] ] ] [EOL] assert grpn == [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] grp , grpn = fudt . group_by_column ( struct_array , [string] , numerical_bins_number = [number] ) [EOL] assert grp == n_2_grp [EOL] assert grpn == n_2_grps [EOL] [EOL] [comment] [EOL] grp , grpn = fudt . group_by_column ( struct_array , [string] , groupings = [ [number] , [number] ] ) [EOL] assert grp == n_0_grp [EOL] assert grpn == n_0_grps [EOL] [EOL] [comment] [EOL] grp , grpn = fudt . group_by_column ( cat_array , [number] ) [EOL] assert grp == c_1_grp_d [EOL] assert grpn == c_1_grps_d [EOL] grp , grpn = fudt . group_by_column ( cat_array , [number] , treat_as_categorical = True ) [EOL] assert grp == c_1_grp_d [EOL] assert grpn == c_1_grps_d [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] grp , grpn = fudt . group_by_column ( cat_array , [number] , treat_as_categorical = False ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_tac [EOL] assert grp == c_1_grp_d [EOL] assert grpn == c_1_grps_d [EOL] grp , grpn = fudt . group_by_column ( cat_array , [number] , groupings = [ ( [string] , ) , ( [string] , ) , ( [string] , ) , ( [string] , ) ] ) [EOL] assert grp == c_1_grp_d [EOL] assert grpn == c_1_grps_d [EOL] [EOL] [comment] [EOL] grp , grpn = fudt . group_by_column ( struct_array , [string] , groupings = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] assert grp == c_1_grp_c [EOL] assert grpn == c_1_grps_c [EOL] [EOL] [EOL] def test_apply_to_column_grouping_errors ( ) : [EOL] [docstring] [EOL] shape_error_labels = [string] [EOL] shape_error_gt = [string] [EOL] shape_error_dim = ( [string] [string] ) [EOL] [comment] [EOL] type_error_rg = [string] [EOL] type_error_rg_inner = ( [string] [string] ) [EOL] type_error_rg_in_inner = ( [string] [string] ) [EOL] value_error_rg_empty = ( [string] [string] ) [EOL] value_error_rg_inner_empty = ( [string] [string] ) [EOL] value_error_rg_dup = ( [string] [string] ) [EOL] [comment] [EOL] type_error_fnc = [string] [EOL] attribute_error_fnc = ( [string] [string] [string] [string] ) [EOL] [EOL] labels = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] ground_truth = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] two_d_ones = np . ones ( ( [number] , [number] ) ) [EOL] [EOL] def fnc ( x , y , z ) : [EOL] return x + y + z [comment] [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . apply_to_column_grouping ( two_d_ones , two_d_ones , [ ] , fnc ) [EOL] assert str ( exin . value ) == shape_error_labels [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , two_d_ones , [ ] , fnc ) [EOL] assert str ( exin . value ) == shape_error_gt [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth [ : - [number] ] , [ ] , fnc ) [EOL] assert str ( exin . value ) == shape_error_dim [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , None , fnc ) [EOL] assert str ( exin . value ) == type_error_rg [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ ] , fnc ) [EOL] assert str ( exin . value ) == value_error_rg_empty [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [string] ] , fnc ) [EOL] assert str ( exin . value ) == type_error_rg_inner [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [ ] ] , fnc ) [EOL] assert str ( exin . value ) == value_error_rg_inner_empty [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [ [string] ] ] , fnc ) [EOL] assert str ( exin . value ) == type_error_rg_in_inner [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [ [number] , [number] ] ] , fnc ) [EOL] assert str ( exin . value ) == value_error_rg_dup [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [ [number] ] ] , None ) [EOL] assert str ( exin . value ) == type_error_fnc [EOL] with pytest . raises ( AttributeError ) as exin : [EOL] fudt . apply_to_column_grouping ( labels , ground_truth , [ [ [number] ] , [ [number] ] ] , fnc ) [EOL] assert str ( exin . value ) == attribute_error_fnc [EOL] [EOL] [EOL] def test_apply_to_column_grouping ( ) : [EOL] [docstring] [EOL] labels = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] ground_truth = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] groupings = [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] [EOL] def fnc ( x , y ) : [EOL] return ( x != y ) . sum ( ) / x . shape [ [number] ] [EOL] [EOL] vls = fudt . apply_to_column_grouping ( labels , ground_truth , groupings , fnc ) [EOL] assert vls == [ [number] / [number] , [number] / [number] ] [EOL] [EOL] [EOL] def test_validate_indices_per_bin ( ) : [EOL] [docstring] [EOL] type_error_out = [string] [EOL] value_error_empty = [string] [EOL] value_error_negative_index = ( [string] [string] ) [EOL] type_error_nonnumber_index = ( [string] [string] ) [EOL] type_error_in = ( [string] [string] ) [EOL] value_error_duplicates = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . validate_indices_per_bin ( [string] ) [EOL] assert str ( exin . value ) == type_error_out [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . validate_indices_per_bin ( [ [ [number] ] , [ [number] ] , [string] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == type_error_in [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . validate_indices_per_bin ( [ [ [number] ] , [ [number] ] , [ [number] , [string] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == type_error_nonnumber_index . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_indices_per_bin ( [ ] ) [EOL] assert str ( exin . value ) == value_error_empty [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_indices_per_bin ( [ [ [number] ] , [ [number] ] , [ - [number] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == value_error_negative_index [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_indices_per_bin ( [ [ [number] , [number] ] , [ [number] ] , [ [number] , [number] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == value_error_duplicates [EOL] [EOL] user_warning = ( [string] [string] [string] ) [EOL] with pytest . warns ( UserWarning ) as w : [EOL] assert fudt . validate_indices_per_bin ( [ [ [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] ] ] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning . format ( [string] ) [EOL] [EOL] [EOL] def test_validate_binary_matrix ( ) : [EOL] [docstring] [EOL] incorrect_shape_2d = [string] [EOL] incorrect_shape_square = [string] [EOL] type_error = [string] [EOL] value_error_diagonal = [string] [EOL] value_error_structured = [string] [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ [number] , [number] , [number] ] ) , [string] ) [EOL] assert str ( exin . value ) == incorrect_shape_2d . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , int ) ] ) ) [EOL] assert str ( exin . value ) == value_error_structured . format ( [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ [ [number] , [number] , [number] ] ] ) , [string] ) [EOL] assert str ( exin . value ) == type_error . format ( [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ [ True , False , False ] ] ) , [string] ) [EOL] assert str ( exin . value ) == incorrect_shape_square . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ [ False , True ] , [ False , False ] ] ) ) [EOL] assert str ( exin . value ) == value_error_diagonal . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fudt . validate_binary_matrix ( np . array ( [ [ True , True ] , [ True , True ] ] ) ) [EOL] assert str ( exin . value ) == value_error_diagonal . format ( [string] ) [EOL] [EOL] assert fudt . validate_binary_matrix ( np . array ( [ [ False , False ] , [ False , False ] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional , Tuple , Any , List , Union , Set [EOL] import numpy [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] [EOL] from typing import Optional , Tuple , Union [EOL] [EOL] import numpy as np [EOL] import numpy . lib . recfunctions as recfn [EOL] [EOL] import fatf . utils . tools as fut [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _LOCAL_STRUCTURED_TO_UNSTRUCTURED = None [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [comment] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [comment] [EOL] [EOL] [EOL] def indices_by_type ( array ) : [EOL] [docstring] [EOL] if not isinstance ( array , np . ndarray ) : [EOL] raise TypeError ( [string] ) [EOL] if not fuav . is_2d_array ( array ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] if not fuav . is_base_array ( array ) : [EOL] raise ValueError ( [string] [string] [string] [string] ) [EOL] [EOL] if fuav . is_structured_array ( array ) : [EOL] assert len ( array . dtype ) > [number] , [string] [EOL] numerical_indices_list = [ ] [EOL] non_numerical_indices_list = [ ] [EOL] [EOL] for column_name in array . dtype . names : [EOL] column_dtype = array . dtype [ column_name ] [EOL] if fuav . is_numerical_dtype ( column_dtype ) : [EOL] numerical_indices_list . append ( column_name ) [EOL] else : [EOL] non_numerical_indices_list . append ( column_name ) [EOL] [EOL] numerical_indices = np . array ( numerical_indices_list ) [EOL] non_numerical_indices = np . array ( non_numerical_indices_list ) [EOL] else : [EOL] if fuav . is_numerical_array ( array ) : [EOL] numerical_indices = np . array ( range ( array . shape [ [number] ] ) ) [EOL] non_numerical_indices = np . empty ( ( [number] , ) , dtype = [string] ) [EOL] else : [EOL] numerical_indices = np . empty ( ( [number] , ) , dtype = [string] ) [EOL] non_numerical_indices = np . array ( range ( array . shape [ [number] ] ) ) [EOL] [EOL] return numerical_indices , non_numerical_indices [EOL] [EOL] [EOL] def get_invalid_indices ( array , indices ) : [EOL] [docstring] [EOL] if not ( isinstance ( array , np . ndarray ) and isinstance ( indices , np . ndarray ) ) : [EOL] raise TypeError ( [string] ) [EOL] if not fuav . is_2d_array ( array ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] if not fuav . is_1d_array ( indices ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] [EOL] if fuav . is_structured_array ( array ) : [EOL] array_indices = set ( array . dtype . names ) [EOL] else : [EOL] array_indices = set ( range ( array . shape [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] invalid_indices = set ( indices . tolist ( ) ) - array_indices [EOL] return np . sort ( list ( invalid_indices ) ) [EOL] [EOL] [EOL] def are_indices_valid ( array , indices ) : [EOL] [docstring] [EOL] if not ( isinstance ( array , np . ndarray ) and isinstance ( indices , np . ndarray ) ) : [EOL] raise TypeError ( [string] ) [EOL] if not fuav . is_2d_array ( array ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] if not fuav . is_1d_array ( indices ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] [EOL] invalid_indices = get_invalid_indices ( array , indices ) [EOL] assert fuav . is_1d_array ( invalid_indices ) , [string] [EOL] [EOL] is_valid = not bool ( invalid_indices . shape [ [number] ] ) [EOL] return is_valid [EOL] [EOL] [EOL] def generalise_dtype ( dtype_one , dtype_two ) : [EOL] [docstring] [EOL] error_msg = [string] [EOL] if not fuav . is_base_dtype ( dtype_one ) : [EOL] raise ValueError ( error_msg . format ( [string] ) ) [EOL] if not fuav . is_base_dtype ( dtype_two ) : [EOL] raise ValueError ( error_msg . format ( [string] ) ) [EOL] [EOL] type_one_array = np . ones ( ( [number] , ) , dtype = dtype_one ) [EOL] type_two_array = np . ones ( ( [number] , ) , dtype = dtype_two ) [EOL] common_array = np . concatenate ( [ type_one_array , type_two_array ] ) [EOL] common_dtype = common_array . dtype [EOL] [EOL] return common_dtype [EOL] [EOL] [EOL] def _choose_structured_to_unstructured ( ) : [EOL] [docstring] [EOL] use_local_implementation = True [EOL] np_ver = [ int ( i ) for i in np . version . version . split ( [string] ) ] [EOL] [comment] [EOL] if fut . at_least_verion ( [ [number] , [number] ] , np_ver ) : [EOL] logger . info ( [string] [string] [string] [string] ) [EOL] use_local_implementation = False [EOL] else : [EOL] logger . info ( [string] [string] [string] [string] [string] ) [EOL] use_local_implementation = True [EOL] return use_local_implementation [EOL] [EOL] [EOL] def fatf_structured_to_unstructured_row ( structured_row ) : [EOL] [docstring] [EOL] if not fuav . is_structured_row ( structured_row ) : [EOL] raise TypeError ( [string] ) [EOL] for dname in structured_row . dtype . names : [EOL] if not fuav . is_base_dtype ( structured_row . dtype [ dname ] ) : [EOL] raise ValueError ( [string] [string] [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] assert len ( structured_row . dtype . names ) , [string] [EOL] classic_array = np . array ( [ i for i in structured_row ] ) [EOL] if classic_array . shape [ [number] ] == [number] : [EOL] unstructured_row = classic_array [ [number] ] [EOL] else : [EOL] unstructured_row = classic_array [EOL] return unstructured_row [EOL] [EOL] [EOL] def structured_to_unstructured_row ( structured_row , ** kwargs ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] if _LOCAL_STRUCTURED_TO_UNSTRUCTURED : [EOL] classic_row = fatf_structured_to_unstructured_row ( structured_row ) [EOL] else : [EOL] classic_row = recfn . structured_to_unstructured ( structured_row , ** kwargs ) [EOL] return classic_row [EOL] [EOL] [EOL] def fatf_structured_to_unstructured ( structured_array ) : [EOL] [docstring] [EOL] if not fuav . is_structured_array ( structured_array ) : [EOL] raise TypeError ( [string] ) [EOL] if not fuav . is_base_array ( structured_array ) : [EOL] raise ValueError ( [string] [string] [string] [string] ) [EOL] [EOL] if fuav . is_numerical_array ( structured_array ) : [EOL] dtype = np . array ( [ i for i in structured_array [ [number] ] ] ) . dtype [EOL] else : [EOL] dtype = str [EOL] dtyped_columns = [ ] [EOL] [comment] [EOL] assert len ( structured_array . dtype . names ) != [number] , [string] [EOL] for i in structured_array . dtype . names : [EOL] dtyped_columns . append ( structured_array [ i ] . astype ( dtype ) ) [EOL] classic_array = np . column_stack ( dtyped_columns ) [EOL] return classic_array [EOL] [EOL] [EOL] def structured_to_unstructured ( structured_array , ** kwargs ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] if _LOCAL_STRUCTURED_TO_UNSTRUCTURED : [EOL] classic_array = fatf_structured_to_unstructured ( structured_array ) [EOL] else : [EOL] classic_array = recfn . structured_to_unstructured ( structured_array , ** kwargs ) [EOL] if ( fuav . is_2d_array ( structured_array ) [EOL] and fuav . is_1d_array ( classic_array ) ) : [EOL] classic_array = classic_array . reshape ( ( structured_array . shape [ [number] ] , [number] ) ) [EOL] return classic_array [EOL] [EOL] [EOL] def as_unstructured ( array_like , ** kwargs ) : [EOL] [docstring] [EOL] if isinstance ( array_like , np . void ) : [EOL] assert fuav . is_structured_row ( array_like ) , [string] [EOL] classic_array = structured_to_unstructured_row ( array_like , ** kwargs ) [EOL] elif isinstance ( array_like , np . ndarray ) : [EOL] if fuav . is_structured_array ( array_like ) : [EOL] classic_array = structured_to_unstructured ( array_like , ** kwargs ) [EOL] else : [EOL] if fuav . is_base_array ( array_like ) : [EOL] classic_array = array_like [EOL] else : [EOL] raise ValueError ( [string] [string] [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] [string] [string] ) [EOL] return classic_array [EOL] [EOL] [EOL] [comment] [EOL] _LOCAL_STRUCTURED_TO_UNSTRUCTURED = _choose_structured_to_unstructured ( ) [EOL] assert isinstance ( _LOCAL_STRUCTURED_TO_UNSTRUCTURED , bool ) , [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[numpy.dtype,numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Tuple , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . tools as fut [EOL] [EOL] from fatf . utils . testing . arrays import ( NUMERICAL_NP_ARRAY , NOT_NUMERICAL_NP_ARRAY , WIDE_NP_ARRAY , NUMERICAL_STRUCTURED_ARRAY , NOT_NUMERICAL_STRUCTURED_ARRAY , WIDE_STRUCTURED_ARRAY , BASE_NP_ARRAY , NOT_BASE_NP_ARRAY , BASE_STRUCTURED_ARRAY , NOT_BASE_STRUCTURED_ARRAY ) [EOL] [EOL] NUMERICAL_KINDS = [ True , [number] , - [number] , [number] , [number] + [number] , np . nan , np . inf , - np . inf ] [EOL] NOT_NUMERICAL_KINDS = [ object ( ) , [string] , [string] , None ] [EOL] TEXTUAL_KINDS = [ [string] , [string] ] [EOL] UNSUPPORTED_TEXTUAL_KINDS = [ [string] ] [EOL] UNSUPPORTED_TEXTUAL_DTYPES = [ np . dtype ( [string] ) , np . dtype ( [string] ) ] [EOL] BASE_KINDS = [ True , [number] , - [number] , [number] , [number] + [number] , [string] , [string] , [string] , np . nan , np . inf , - np . inf ] [comment] [EOL] NOT_BASE_KINDS = [ None , object ( ) ] [EOL] [EOL] NP_VER = [ int ( i ) for i in np . version . version . split ( [string] ) ] [EOL] NP_VER_TYPEERROR_MSG_14 = [string] [EOL] NP_VER_TYPEERROR_MSG_12 = [string] [EOL] [EOL] [EOL] def test_is_numerical_dtype ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_dtype ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_numerical_dtype ( array_dtype ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_numerical_dtype ( array_dtype ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_numerical_dtype ( NUMERICAL_NP_ARRAY . dtype ) is True [EOL] [comment] [EOL] assert fuav . is_numerical_dtype ( NOT_NUMERICAL_NP_ARRAY . dtype ) is False [EOL] assert fuav . is_numerical_dtype ( BASE_NP_ARRAY . dtype ) is False [EOL] assert fuav . is_numerical_dtype ( NOT_BASE_NP_ARRAY . dtype ) is False [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_numerical_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_numerical_dtype ( NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_numerical_dtype ( BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_numerical_dtype ( NOT_BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is bool : [EOL] assert fuav . is_numerical_dtype ( np . dtype ( dtype ) ) is True [EOL] else : [EOL] assert fuav . is_numerical_dtype ( np . dtype ( dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_numerical_dtype ( np . dtype ( dtype ) ) is True [EOL] [EOL] [EOL] def test_is_textual_dtype ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] warning_message = ( [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_dtype ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_textual_dtype ( array_dtype ) is False [EOL] [EOL] [comment] [EOL] for i in TEXTUAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_textual_dtype ( array_dtype ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_textual_dtype ( array_dtype ) is False [EOL] [EOL] for i in UNSUPPORTED_TEXTUAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_dtype ( array_dtype ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] [EOL] for dtype in UNSUPPORTED_TEXTUAL_DTYPES : [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_dtype ( dtype ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] [EOL] [comment] [EOL] assert fuav . is_textual_dtype ( NUMERICAL_NP_ARRAY . dtype ) is False [EOL] [comment] [EOL] assert fuav . is_textual_dtype ( NOT_NUMERICAL_NP_ARRAY . dtype ) is False [EOL] assert fuav . is_textual_dtype ( BASE_NP_ARRAY . dtype ) is True [EOL] assert fuav . is_textual_dtype ( NOT_BASE_NP_ARRAY . dtype ) is False [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_textual_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_textual_dtype ( NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_textual_dtype ( BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_textual_dtype ( NOT_BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is str : [EOL] assert fuav . is_textual_dtype ( np . dtype ( dtype ) ) is True [EOL] elif dtype is bytes : [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_dtype ( np . dtype ( dtype ) ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] else : [EOL] assert fuav . is_textual_dtype ( np . dtype ( dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_textual_dtype ( np . dtype ( dtype ) ) is False [EOL] [EOL] [EOL] def test_is_base_dtype ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_dtype ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_base_dtype ( array_dtype ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] array_dtype = array . dtype [EOL] assert fuav . is_base_dtype ( array_dtype ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_base_dtype ( NUMERICAL_NP_ARRAY . dtype ) is True [EOL] assert fuav . is_base_dtype ( NOT_NUMERICAL_NP_ARRAY . dtype ) is False [EOL] assert fuav . is_base_dtype ( BASE_NP_ARRAY . dtype ) is True [EOL] assert fuav . is_base_dtype ( NOT_BASE_NP_ARRAY . dtype ) is False [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_base_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_base_dtype ( NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_base_dtype ( BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_base_dtype ( NOT_BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is bool or dtype is str or dtype is bytes : [EOL] assert fuav . is_base_dtype ( np . dtype ( dtype ) ) is True [EOL] else : [EOL] assert fuav . is_base_dtype ( np . dtype ( dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_base_dtype ( np . dtype ( dtype ) ) is True [EOL] [EOL] [EOL] def test_is_flat_dtype ( ) : [EOL] [docstring] [EOL] [EOL] def numpy_low ( ) : [EOL] assert fuav . is_flat_dtype ( NUMERICAL_NP_ARRAY . dtype ) [EOL] assert fuav . is_flat_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert not fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_2 . dtype ) [EOL] [EOL] def numpy_high ( ) : [comment] [EOL] assert fuav . is_flat_dtype ( NUMERICAL_NP_ARRAY . dtype ) [EOL] assert fuav . is_flat_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert not fuav . is_flat_dtype ( weird_array_1 . dtype [ [number] ] ) [EOL] assert fuav . is_flat_dtype ( weird_array_2 . dtype ) [EOL] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_flat_dtype ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_flat_dtype ( NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_flat_dtype ( NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_flat_dtype ( BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . is_flat_dtype ( NOT_BASE_STRUCTURED_ARRAY . dtype ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] weird_array_1 = np . zeros ( [number] , dtype = [ ( [string] , [string] ) , ( [string] , np . float32 ) , ( [string] , [string] , ( [number] , [number] ) ) ] ) [EOL] weird_array_2 = np . ones ( ( [number] , [number] ) , dtype = weird_array_1 . dtype [ [number] ] ) [EOL] [EOL] if fuav . _NUMPY_1_13 : [comment] [EOL] numpy_low ( ) [EOL] numpy_high ( ) [EOL] else : [comment] [EOL] numpy_low ( ) [EOL] [EOL] [EOL] def test_are_similar_dtypes ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error_a = [string] [EOL] type_error_b = [string] [EOL] value_error_a = ( [string] [string] ) [EOL] value_error_b = ( [string] [string] ) [EOL] [EOL] simple_dtype = NUMERICAL_NP_ARRAY . dtype [EOL] structured_dtype = NUMERICAL_STRUCTURED_ARRAY . dtype [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtypes ( None , None , False ) [EOL] assert str ( exin . value ) == type_error_a [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtypes ( None , simple_dtype , True ) [EOL] assert str ( exin . value ) == type_error_a [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtypes ( simple_dtype , None , False ) [EOL] assert str ( exin . value ) == type_error_b [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtypes ( structured_dtype , None , True ) [EOL] assert str ( exin . value ) == type_error_b [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . are_similar_dtypes ( structured_dtype , structured_dtype , True ) [EOL] assert str ( exin . value ) == value_error_a [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . are_similar_dtypes ( structured_dtype , simple_dtype , False ) [EOL] assert str ( exin . value ) == value_error_a [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuav . are_similar_dtypes ( simple_dtype , structured_dtype , True ) [EOL] assert str ( exin . value ) == value_error_b [EOL] [EOL] f1_dtype = np . array ( [ [number] , [number] ] ) . dtype [EOL] f2_dtype = np . array ( [ [number] , [number] ] , dtype = float ) . dtype [EOL] f3_dtype = np . array ( [ [number] , [number] ] ) . dtype [EOL] c1_dtype = np . array ( [ [string] , [string] ] ) . dtype [EOL] c2_dtype = np . array ( [ [string] ] ) . dtype [EOL] c3_dtype = np . array ( [ [string] ] ) . dtype [EOL] c4_dtype = np . array ( [ [string] ] , dtype = str ) . dtype [EOL] c5_dtype = np . array ( [ [string] ] ) . dtype [EOL] [EOL] [comment] [EOL] assert fuav . are_similar_dtypes ( f1_dtype , f2_dtype , True ) is True [EOL] assert fuav . are_similar_dtypes ( f2_dtype , f3_dtype , True ) is False [EOL] assert fuav . are_similar_dtypes ( f3_dtype , c1_dtype , True ) is False [EOL] assert fuav . are_similar_dtypes ( c1_dtype , c2_dtype , True ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c4_dtype , True ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c3_dtype , True ) is False [EOL] assert fuav . are_similar_dtypes ( c3_dtype , c4_dtype , True ) is False [EOL] assert fuav . are_similar_dtypes ( c1_dtype , c5_dtype , True ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c5_dtype , True ) is True [EOL] [EOL] [comment] [EOL] assert fuav . are_similar_dtypes ( f1_dtype , f2_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( f2_dtype , f3_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( f3_dtype , c1_dtype , False ) is False [EOL] assert fuav . are_similar_dtypes ( c1_dtype , c2_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c4_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c3_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( c3_dtype , c4_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( c1_dtype , c5_dtype , False ) is True [EOL] assert fuav . are_similar_dtypes ( c2_dtype , c5_dtype , False ) is True [EOL] [EOL] [EOL] def test_are_similar_dtype_arrays ( ) : [EOL] [docstring] [EOL] type_error_a = [string] [EOL] type_error_b = [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtype_arrays ( None , None , False ) [EOL] assert str ( exin . value ) == type_error_a [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtype_arrays ( None , NUMERICAL_NP_ARRAY , True ) [EOL] assert str ( exin . value ) == type_error_a [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . are_similar_dtype_arrays ( NUMERICAL_NP_ARRAY , None , False ) [EOL] assert str ( exin . value ) == type_error_b [EOL] [EOL] [comment] [EOL] assert fuav . are_similar_dtype_arrays ( NUMERICAL_NP_ARRAY , NUMERICAL_STRUCTURED_ARRAY , False ) is False [EOL] assert fuav . are_similar_dtype_arrays ( NUMERICAL_STRUCTURED_ARRAY , NUMERICAL_NP_ARRAY , True ) is False [EOL] [EOL] f1_array = np . array ( [ [number] , [number] ] ) [EOL] f2_array = np . array ( [ [number] , [number] ] , dtype = float ) [EOL] f3_array = np . array ( [ [number] , [number] ] ) [EOL] c1_array = np . array ( [ [string] , [string] ] ) [EOL] c2_array = np . array ( [ [string] ] ) [EOL] c3_array = np . array ( [ [string] ] ) [EOL] c4_array = np . array ( [ [string] ] , dtype = str ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert fuav . are_similar_dtype_arrays ( f1_array , f2_array , True ) is True [EOL] assert fuav . are_similar_dtype_arrays ( f2_array , f3_array , True ) is False [EOL] assert fuav . are_similar_dtype_arrays ( f3_array , c1_array , True ) is False [EOL] assert fuav . are_similar_dtype_arrays ( c1_array , c2_array , True ) is True [EOL] assert fuav . are_similar_dtype_arrays ( c2_array , c4_array , True ) is True [EOL] assert fuav . are_similar_dtype_arrays ( c2_array , c3_array , True ) is False [EOL] assert fuav . are_similar_dtype_arrays ( c3_array , c4_array , True ) is False [EOL] [comment] [EOL] assert fuav . are_similar_dtype_arrays ( f1_array , f2_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( f2_array , f3_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( f3_array , c1_array , False ) is False [EOL] assert fuav . are_similar_dtype_arrays ( c1_array , c2_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( c2_array , c4_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( c2_array , c3_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( c3_array , c4_array , False ) is True [EOL] [EOL] s1_array = np . array ( [ ( [number] , [string] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , str ) , ( [string] , float ) ] ) [EOL] s2_array = np . array ( [ ( [number] , [string] ) ] , dtype = [ ( [string] , int ) , ( [string] , str ) ] ) [EOL] s3_array = np . array ( [ ( [number] , [string] ) ] , dtype = [ ( [string] , int ) , ( [string] , str ) ] ) [EOL] s4_array = np . array ( [ ( [number] , [string] ) ] , dtype = [ ( [string] , int ) , ( [string] , str ) ] ) [EOL] s5_array = np . array ( [ ( [number] , [string] ) ] , dtype = [ ( [string] , float ) , ( [string] , str ) ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert fuav . are_similar_dtype_arrays ( s1_array , s2_array , True ) is False [EOL] assert fuav . are_similar_dtype_arrays ( s2_array , s3_array , True ) is False [EOL] assert fuav . are_similar_dtype_arrays ( s2_array , s4_array , True ) is True [EOL] assert fuav . are_similar_dtype_arrays ( s4_array , s5_array , True ) is False [EOL] [comment] [EOL] assert fuav . are_similar_dtype_arrays ( s1_array , s3_array , False ) is False [EOL] assert fuav . are_similar_dtype_arrays ( s2_array , s3_array , False ) is False [EOL] assert fuav . are_similar_dtype_arrays ( s2_array , s4_array , False ) is True [EOL] assert fuav . are_similar_dtype_arrays ( s4_array , s5_array , False ) is False [EOL] [EOL] [EOL] def test_is_numerical_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error = [string] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_numerical_array ( array ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_numerical_array ( array ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_numerical_array ( NUMERICAL_NP_ARRAY ) is True [EOL] [comment] [EOL] assert fuav . is_numerical_array ( NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] [comment] [EOL] assert fuav . is_numerical_array ( WIDE_NP_ARRAY ) is True [EOL] assert fuav . is_numerical_array ( WIDE_STRUCTURED_ARRAY ) is True [EOL] [EOL] [comment] [EOL] assert fuav . is_numerical_array ( NOT_NUMERICAL_NP_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_numerical_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_numerical_array ( BASE_NP_ARRAY ) is False [EOL] assert fuav . is_numerical_array ( NOT_BASE_NP_ARRAY ) is False [EOL] assert fuav . is_numerical_array ( BASE_STRUCTURED_ARRAY ) is False [EOL] assert fuav . is_numerical_array ( NOT_BASE_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] [comment] [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is bool : [EOL] assert fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is True [EOL] elif dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] assert fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_numerical_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_numerical_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_numerical_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is True [EOL] [comment] [EOL] [EOL] [EOL] def test_is_textual_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error = [string] [EOL] warning_message = ( [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_textual_array ( array ) is False [EOL] [EOL] [comment] [EOL] for i in TEXTUAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_textual_array ( array ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_textual_array ( array ) is False [EOL] [EOL] for i in UNSUPPORTED_TEXTUAL_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_array ( array ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] [EOL] [comment] [EOL] assert fuav . is_textual_array ( NUMERICAL_NP_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_textual_array ( NUMERICAL_STRUCTURED_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_textual_array ( WIDE_NP_ARRAY ) is False [EOL] assert fuav . is_textual_array ( WIDE_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_textual_array ( NOT_NUMERICAL_NP_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_textual_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_textual_array ( BASE_NP_ARRAY ) is True [EOL] assert fuav . is_textual_array ( NOT_BASE_NP_ARRAY ) is False [EOL] assert fuav . is_textual_array ( BASE_STRUCTURED_ARRAY ) is False [EOL] assert fuav . is_textual_array ( NOT_BASE_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] [comment] [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is str : [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is True [EOL] elif dtype is bytes : [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] elif dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_textual_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_textual_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] [comment] [EOL] [EOL] [EOL] def test_is_base_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error = [string] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_base_array ( array ) is True [EOL] [EOL] [comment] [EOL] for i in NOT_BASE_KINDS : [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ i ] * [number] ] * [number] ] : [EOL] array = np . array ( j ) [EOL] assert fuav . is_base_array ( array ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_base_array ( NUMERICAL_NP_ARRAY ) is True [EOL] assert fuav . is_base_array ( WIDE_NP_ARRAY ) is True [EOL] assert fuav . is_base_array ( NOT_NUMERICAL_NP_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_base_array ( WIDE_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_base_array ( NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_base_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] [comment] [EOL] assert fuav . is_base_array ( BASE_NP_ARRAY ) is True [EOL] assert fuav . is_base_array ( NOT_BASE_NP_ARRAY ) is False [EOL] assert fuav . is_base_array ( BASE_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_base_array ( NOT_BASE_STRUCTURED_ARRAY ) is False [EOL] [EOL] [comment] [EOL] for kind , dtypes in np . sctypes . items ( ) : [EOL] [comment] [EOL] if kind == [string] : [EOL] for dtype in dtypes : [EOL] if dtype is bool or dtype is str or dtype is bytes : [EOL] assert fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is True [EOL] elif dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] assert fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] assert fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is False [EOL] assert fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is False [EOL] else : [EOL] for dtype in dtypes : [EOL] assert fuav . is_base_array ( np . empty ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_base_array ( np . ones ( ( [number] , ) , dtype = dtype ) ) is True [EOL] assert fuav . is_base_array ( np . zeros ( ( [number] , ) , dtype = dtype ) ) is True [EOL] [comment] [EOL] [EOL] [EOL] def test_is_2d_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] type_error = [string] [EOL] warning_message = ( [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS + NOT_NUMERICAL_KINDS : [EOL] for j in [ [ [ i ] * [number] ] * [number] ] : [EOL] assert fuav . is_2d_array ( np . array ( j ) ) is True [EOL] for j in [ i , [ i ] , [ i ] * [number] , [ [ [ i ] * [number] ] * [number] ] * [number] ] : [EOL] assert fuav . is_2d_array ( np . array ( j ) ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_2d_array ( NUMERICAL_NP_ARRAY ) is True [EOL] assert fuav . is_2d_array ( NOT_NUMERICAL_NP_ARRAY ) is True [EOL] assert fuav . is_2d_array ( NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_2d_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_2d_array ( WIDE_NP_ARRAY ) is True [EOL] assert fuav . is_2d_array ( WIDE_STRUCTURED_ARRAY ) is True [EOL] [EOL] [comment] [EOL] square_shapes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] not_square_shapes = [ ( [number] , ) , ( [number] , ) , ( [number] , ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] [EOL] for _ , dtypes in np . sctypes . items ( ) : [EOL] for dtype in dtypes : [EOL] for shape in square_shapes : [EOL] if dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . zeros ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . empty ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] if [number] not in shape : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is True [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is True [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is True [EOL] for shape in not_square_shapes : [EOL] if dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . zeros ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . empty ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] if [number] not in shape : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_2d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] [EOL] [comment] [EOL] arr = np . zeros ( [number] , dtype = [ ( [string] , [string] ) , ( [string] , np . float32 ) , ( [string] , [string] , ( [number] , [number] ) ) ] ) [EOL] assert fuav . is_2d_array ( arr ) is False [EOL] arr = np . ones ( ( [number] , [number] ) , dtype = arr . dtype [ [number] ] ) [EOL] assert fuav . is_2d_array ( arr ) is False [EOL] [comment] [EOL] not_flat_dtype = [ NUMERICAL_STRUCTURED_ARRAY . dtype , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ] [EOL] flat_dtype = [ NUMERICAL_NP_ARRAY . dtype , NOT_NUMERICAL_NP_ARRAY . dtype ] [EOL] flat_struct = [ np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) ] [EOL] [comment] [EOL] complex_flat_shapes = [ ( [number] , ) , ( [number] , ) , ( [number] , ) ] [EOL] complex_square_shapes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] complex_not_square_shapes = [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] [comment] [EOL] [comment] [EOL] for shape in complex_not_square_shapes : [EOL] for dtype in not_flat_dtype + flat_dtype + flat_struct : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] for shape in complex_square_shapes : [EOL] for dtype in flat_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is True [EOL] for shape in complex_square_shapes : [EOL] for dtype in flat_struct : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] for shape in complex_square_shapes : [EOL] for dtype in not_flat_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] for shape in complex_flat_shapes : [EOL] for dtype in flat_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is False [EOL] for shape in complex_flat_shapes : [EOL] for dtype in not_flat_dtype + flat_struct : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_2d_array ( empty ) is True [EOL] [EOL] [EOL] def test_is_1d_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] type_error = [string] [EOL] warning_message = ( [string] [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] for i in NUMERICAL_KINDS + NOT_NUMERICAL_KINDS : [EOL] for j in [ [ i ] , [ i ] * [number] ] : [EOL] assert fuav . is_1d_array ( np . array ( j ) ) is True [EOL] for j in [ i , [ [ i ] * [number] ] * [number] , [ [ [ i ] * [number] ] * [number] ] * [number] ] : [EOL] assert fuav . is_1d_array ( np . array ( j ) ) is False [EOL] [EOL] [comment] [EOL] assert fuav . is_1d_array ( NUMERICAL_NP_ARRAY ) is False [EOL] assert fuav . is_1d_array ( NOT_NUMERICAL_NP_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_1d_array ( NUMERICAL_STRUCTURED_ARRAY ) is False [EOL] assert fuav . is_1d_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is False [EOL] [comment] [EOL] assert fuav . is_1d_array ( WIDE_NP_ARRAY ) is False [EOL] assert fuav . is_1d_array ( WIDE_STRUCTURED_ARRAY ) is False [EOL] [EOL] flat_shapes = [ ( [number] , ) , ( [number] , ) , ( [number] , ) ] [EOL] not_flat_shapes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] [comment] [EOL] for _ , dtypes in np . sctypes . items ( ) : [EOL] for dtype in dtypes : [EOL] for shape in flat_shapes : [EOL] if dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . zeros ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . empty ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] if [number] not in shape : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is True [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is True [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is True [EOL] for shape in not_flat_shapes : [EOL] if dtype is np . void : [comment] [EOL] if not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . zeros ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . empty ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_12 [EOL] elif not fut . at_least_verion ( [ [number] , [number] ] , NP_VER ) : [EOL] if [number] not in shape : [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_array ( np . ones ( shape = shape , dtype = dtype ) ) [EOL] assert str ( exin . value ) == NP_VER_TYPEERROR_MSG_14 [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] else : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] [EOL] [comment] [EOL] not_flat_dtype = [ NUMERICAL_STRUCTURED_ARRAY . dtype , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype ] [EOL] flat_dtype = [ NUMERICAL_NP_ARRAY . dtype , NOT_NUMERICAL_NP_ARRAY . dtype ] [EOL] flat_struct = [ np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) ] [EOL] [comment] [EOL] for shape in flat_shapes : [EOL] for dtype in flat_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is True [EOL] for shape in flat_shapes : [EOL] for dtype in flat_struct : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] [comment] [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] [comment] [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] assert warning_message == str ( warning [ [number] ] . message ) [EOL] for shape in flat_shapes : [EOL] for dtype in not_flat_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] for shape in not_flat_shapes : [EOL] for dtype in not_flat_dtype + flat_dtype + flat_struct : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_1d_array ( empty ) is False [EOL] [EOL] [EOL] def test_is_structured_row ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( np . ones ( ( [number] , [number] ) , dtype = float ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( np . ones ( ( [number] , ) , dtype = float ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( np . array ( ( [number] , ( [number] + [number] ) ) , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( np . array ( [ ( [number] , ( [number] + [number] ) ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( np . array ( [ ( [number] , ) , ( [number] , ) , ( [number] , ) ] , dtype = [ ( [string] , [string] ) ] ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] void_array = np . array ( [ [string] ] , np . void ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( void_array ) [EOL] assert str ( exin . value ) == type_error [EOL] assert not fuav . is_structured_row ( void_array [ [number] ] ) [EOL] void_array = np . array ( [ [string] , [string] ] , np . void ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_row ( void_array ) [EOL] assert str ( exin . value ) == type_error [EOL] assert not fuav . is_structured_row ( void_array [ [number] ] ) [EOL] [comment] [EOL] assert fuav . is_structured_row ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_structured_row ( NOT_NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_structured_row ( BASE_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_structured_row ( NOT_BASE_STRUCTURED_ARRAY [ [number] ] ) [EOL] [EOL] [EOL] def test_is_1d_like ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_1d_like ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] assert not fuav . is_1d_like ( np . ones ( ( [number] , [number] ) , dtype = float ) ) [EOL] [comment] [EOL] assert fuav . is_1d_like ( np . ones ( ( [number] , ) , dtype = float ) ) [EOL] [comment] [EOL] assert not fuav . is_1d_like ( NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert not fuav . is_1d_like ( NOT_NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert not fuav . is_1d_like ( BASE_STRUCTURED_ARRAY ) [EOL] assert not fuav . is_1d_like ( NOT_BASE_STRUCTURED_ARRAY ) [EOL] [comment] [EOL] assert not fuav . is_1d_like ( np . array ( [ ( [number] , ( [number] + [number] ) ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) ) [EOL] user_warning = ( [string] [string] [string] [string] ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] assert not fuav . is_1d_like ( np . array ( [ ( [number] , ) , ( [number] , ) , ( [number] , ) ] , dtype = [ ( [string] , [string] ) ] ) ) [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] [comment] [EOL] assert fuav . is_1d_like ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_1d_like ( NOT_NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_1d_like ( BASE_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuav . is_1d_like ( NOT_BASE_STRUCTURED_ARRAY [ [number] ] ) [EOL] [comment] [EOL] void_array = np . array ( [ [string] ] , np . void ) [EOL] assert fuav . is_1d_like ( void_array ) [EOL] assert not fuav . is_1d_like ( void_array [ [number] ] ) [EOL] void_array = np . array ( [ [string] , [string] ] , np . void ) [EOL] assert fuav . is_1d_like ( void_array ) [EOL] assert not fuav . is_1d_like ( void_array [ [number] ] ) [EOL] [EOL] [EOL] def test_is_structured_array ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuav . is_structured_array ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] assert fuav . is_structured_array ( NUMERICAL_NP_ARRAY ) is False [EOL] assert fuav . is_structured_array ( NOT_NUMERICAL_NP_ARRAY ) is False [EOL] assert fuav . is_structured_array ( WIDE_NP_ARRAY ) is False [EOL] assert fuav . is_structured_array ( NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_structured_array ( NOT_NUMERICAL_STRUCTURED_ARRAY ) is True [EOL] assert fuav . is_structured_array ( WIDE_STRUCTURED_ARRAY ) is True [EOL] [EOL] shapes = [ ( [number] , ) , ( [number] , ) , ( [number] , ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] [EOL] [comment] [EOL] basic_dtype = [ NUMERICAL_NP_ARRAY . dtype , NOT_NUMERICAL_NP_ARRAY . dtype , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ] [EOL] struct_dtype = [ NUMERICAL_STRUCTURED_ARRAY . dtype , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype , np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) , np . dtype ( [ ( [string] , NOT_NUMERICAL_STRUCTURED_ARRAY . dtype [ [number] ] ) ] ) ] [EOL] [comment] [EOL] for shape in shapes : [EOL] for dtype in basic_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( ones ) is False [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( zeros ) is False [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( empty ) is False [EOL] for dtype in struct_dtype : [EOL] ones = np . ones ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( ones ) is True [EOL] zeros = np . zeros ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( zeros ) is True [EOL] empty = np . empty ( shape = shape , dtype = dtype ) [EOL] assert fuav . is_structured_array ( empty ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] import pytest [EOL] [EOL] import fatf . utils . array . tools as fuat [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] from fatf . utils . testing . arrays import ( BASE_NP_ARRAY , NOT_BASE_NP_ARRAY , NOT_BASE_STRUCTURED_ARRAY , NOT_NUMERICAL_NP_ARRAY , NOT_NUMERICAL_STRUCTURED_ARRAY , NUMERICAL_NP_ARRAY , NUMERICAL_STRUCTURED_ARRAY , WIDE_NP_ARRAY , WIDE_STRUCTURED_ARRAY ) [EOL] [EOL] NUMERICAL_UNSTRUCTURED_ARRAY = np . array ( [ [ [number] , [number] + [number] ] , [ [number] , [number] + [number] ] , [ np . nan , - [number] + [number] ] , [ np . inf , - [number] + [number] ] , [ - np . inf , - [number] + [number] ] , [ - [number] , - [number] + [number] ] ] ) [comment] [EOL] NOT_NUMERICAL_UNSTRUCTURED_ARRAY = np . array ( [ [ [number] + [number] , [string] ] , [ [number] + [number] , [string] ] , [ - [number] + [number] , [string] ] , [ [number] + [number] , [string] ] , [ [number] + [number] , [string] ] , [ [number] , [string] ] , [ np . nan + [number] , [string] ] , [ np . inf + [number] , [string] ] , [ - np . inf + [number] , [string] ] ] ) [comment] [EOL] WIDE_UNSTRUCTURED_ARRAY = np . array ( [ [ [number] , [number] + [number] , np . nan ] , [ np . inf , [number] + [number] , [number] ] , [ - [number] , - [number] + [number] , - np . inf ] ] ) [comment] [EOL] [EOL] NP_VER = [ int ( i ) for i in np . version . version . split ( [string] ) ] [EOL] [EOL] [EOL] def _compare_nan_arrays ( array1 , array2 ) : [EOL] [docstring] [EOL] assert not fuav . is_structured_array ( array1 ) , [string] [EOL] assert not fuav . is_structured_array ( array2 ) , [string] [EOL] assert array1 . shape == array2 . shape , [string] [EOL] [comment] [EOL] assert len ( array1 . shape ) > [number] and len ( array1 . shape ) < [number] , [string] [EOL] are_equal = True [EOL] if len ( array1 . shape ) == [number] : [EOL] for i in range ( array1 . shape [ [number] ] ) : [EOL] if np . isnan ( array1 [ i ] ) and np . isnan ( array2 [ i ] ) : [EOL] continue [EOL] elif array1 [ i ] != array2 [ i ] : [EOL] are_equal = False [EOL] break [EOL] elif len ( array1 . shape ) == [number] : [EOL] for i in range ( array1 . shape [ [number] ] ) : [EOL] for j in range ( array1 . shape [ [number] ] ) : [EOL] if np . isnan ( array1 [ i , j ] ) and np . isnan ( array2 [ i , j ] ) : [EOL] continue [EOL] elif array1 [ i , j ] != array2 [ i , j ] : [EOL] are_equal = False [EOL] break [EOL] if not are_equal : [EOL] break [EOL] return are_equal [EOL] [EOL] [EOL] def test_compare_nan_arrays ( ) : [EOL] [docstring] [EOL] assertion_error_1 = [string] [EOL] assertion_error_2 = [string] [EOL] assertion_error_3 = [string] [EOL] assertion_error_4 = [string] [EOL] [EOL] array_3d_a = np . ones ( ( [number] , [number] , [number] ) , dtype = float ) [EOL] array_struct = np . array ( [ ( [number] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , float ) ] ) [EOL] array_1d_a = np . array ( [ [number] , np . nan , [number] ] ) [EOL] array_1d_b = np . array ( [ - np . inf , [number] , np . inf ] ) [EOL] array_2d_a = np . array ( [ [ [number] , np . nan , [number] ] , [ - np . inf , [number] , np . inf ] ] ) [EOL] array_2d_b = np . array ( [ [ - np . inf , [number] , np . inf ] , [ [number] , np . nan , [number] ] ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] _compare_nan_arrays ( array_struct , array_struct ) [EOL] assert str ( exin . value ) . startswith ( assertion_error_1 ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] _compare_nan_arrays ( array_1d_a , array_struct ) [EOL] assert str ( exin . value ) . startswith ( assertion_error_2 ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] _compare_nan_arrays ( array_1d_a , array_2d_a ) [EOL] assert str ( exin . value ) . startswith ( assertion_error_3 ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] _compare_nan_arrays ( array_3d_a , array_3d_a ) [EOL] assert str ( exin . value ) . startswith ( assertion_error_4 ) [EOL] [EOL] [comment] [EOL] assert not _compare_nan_arrays ( array_1d_a , array_1d_b ) [EOL] assert _compare_nan_arrays ( array_1d_a , array_2d_a [ [number] , : ] ) [EOL] assert not _compare_nan_arrays ( array_1d_a , array_2d_a [ [number] , : ] ) [EOL] assert not _compare_nan_arrays ( array_1d_b , array_2d_a [ [number] , : ] ) [EOL] assert _compare_nan_arrays ( array_1d_b , array_2d_a [ [number] , : ] ) [EOL] [EOL] [comment] [EOL] assert not _compare_nan_arrays ( array_2d_a , array_2d_b ) [EOL] assert not _compare_nan_arrays ( array_2d_a [ [ [number] ] , : ] , array_2d_b [ [ [number] ] , : ] ) [EOL] assert _compare_nan_arrays ( array_2d_a , array_2d_b [ [ [number] , [number] ] , : ] ) [EOL] assert _compare_nan_arrays ( array_2d_a [ [ [number] ] , : ] , array_2d_b [ [ [number] ] , : ] ) [EOL] assert _compare_nan_arrays ( array_2d_a [ [ [number] ] , : ] , array_2d_b [ [ [number] ] , : ] ) [EOL] [EOL] [EOL] def test_indices_by_type ( ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] type_error = [string] [EOL] incorrect_shape_error = [string] [EOL] value_error = ( [string] [string] [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . indices_by_type ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . indices_by_type ( np . empty ( ( [number] , ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . indices_by_type ( NOT_NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] i_n , i_c = fuat . indices_by_type ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert np . array_equal ( [ ] , i_n ) [EOL] assert np . array_equal ( [ ] , i_c ) [EOL] [EOL] [comment] [EOL] array_all_numerical = np . ones ( ( [number] , [number] ) ) [EOL] array_all_numerical_indices_numerical = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] array_all_numerical_indices_categorical = np . array ( [ ] , dtype = int ) [EOL] i_n , i_c = fuat . indices_by_type ( array_all_numerical ) [EOL] assert np . array_equal ( array_all_numerical_indices_numerical , i_n ) [EOL] assert np . array_equal ( array_all_numerical_indices_categorical , i_c ) [EOL] [EOL] [comment] [EOL] array_all_categorical = np . ones ( ( [number] , [number] ) , dtype = [string] ) [EOL] array_all_categorical_indices_numerical = np . array ( [ ] ) [EOL] array_all_categorical_indices_categorical = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] i_n , i_c = fuat . indices_by_type ( array_all_categorical ) [EOL] assert np . array_equal ( array_all_categorical_indices_numerical , i_n ) [EOL] assert np . array_equal ( array_all_categorical_indices_categorical , i_c ) [EOL] [EOL] [comment] [EOL] array_mixture_1 = np . ones ( ( [number] , ) , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [comment] [EOL] array_mixture_1_indices_numerical = np . array ( [ ] ) [EOL] array_mixture_1_indices_categorical = np . array ( [ [string] , [string] , [string] , [string] ] , dtype = [string] ) [EOL] [comment] [EOL] i_n , i_c = fuat . indices_by_type ( array_mixture_1 ) [EOL] assert np . array_equal ( array_mixture_1_indices_numerical , i_n ) [EOL] assert np . array_equal ( array_mixture_1_indices_categorical , i_c ) [EOL] [EOL] array_mixture_2 = np . ones ( ( [number] , ) , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , int ) ] ) [comment] [EOL] array_mixture_2_indices_numerical = np . array ( [ [string] , [string] ] , dtype = [string] ) [EOL] array_mixture_2_indices_categorical = np . array ( [ [string] , [string] ] , dtype = [string] ) [EOL] i_n , i_c = fuat . indices_by_type ( array_mixture_2 ) [EOL] assert np . array_equal ( array_mixture_2_indices_numerical , i_n ) [EOL] assert np . array_equal ( array_mixture_2_indices_categorical , i_c ) [EOL] [EOL] glob_indices_numerical = np . array ( [ [number] , [number] ] ) [EOL] glob_indices_categorical = np . array ( [ ] ) [EOL] i_n , i_c = fuat . indices_by_type ( NUMERICAL_NP_ARRAY ) [EOL] assert np . array_equal ( glob_indices_numerical , i_n ) [EOL] assert np . array_equal ( glob_indices_categorical , i_c ) [EOL] [comment] [EOL] glob_indices_numerical = np . array ( [ [number] , [number] , [number] ] ) [EOL] glob_indices_categorical = np . array ( [ ] ) [EOL] i_n , i_c = fuat . indices_by_type ( WIDE_NP_ARRAY ) [EOL] assert np . array_equal ( glob_indices_numerical , i_n ) [EOL] assert np . array_equal ( glob_indices_categorical , i_c ) [EOL] [comment] [EOL] glob_indices_numerical = np . array ( [ [string] , [string] ] ) [EOL] glob_indices_categorical = np . array ( [ ] ) [EOL] i_n , i_c = fuat . indices_by_type ( NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( glob_indices_numerical , i_n ) [EOL] assert np . array_equal ( glob_indices_categorical , i_c ) [EOL] [comment] [EOL] glob_indices_numerical = np . array ( [ [string] ] ) [EOL] glob_indices_categorical = np . array ( [ [string] ] ) [EOL] i_n , i_c = fuat . indices_by_type ( NOT_NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( glob_indices_numerical , i_n ) [EOL] assert np . array_equal ( glob_indices_categorical , i_c ) [EOL] [comment] [EOL] glob_indices_numerical = np . array ( [ [string] , [string] , [string] ] ) [EOL] glob_indices_categorical = np . array ( [ ] ) [EOL] i_n , i_c = fuat . indices_by_type ( WIDE_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( glob_indices_numerical , i_n ) [EOL] assert np . array_equal ( glob_indices_categorical , i_c ) [EOL] [EOL] [EOL] def test_get_invalid_indices ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] incorrect_shape_array = [string] [EOL] incorrect_shape_indices = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . get_invalid_indices ( None , np . ones ( ( [number] , ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . get_invalid_indices ( None , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . get_invalid_indices ( np . ones ( ( [number] , ) ) , None ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . get_invalid_indices ( None , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . get_invalid_indices ( np . ones ( ( [number] , ) ) , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_array [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . get_invalid_indices ( np . ones ( ( [number] , ) ) , np . ones ( ( [number] , ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_array [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . get_invalid_indices ( np . ones ( ( [number] , [number] ) ) , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_indices [EOL] [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [number] ] ) ) [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_NP_ARRAY , np . array ( [ [string] , [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [string] , [string] ] ) ) [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ ] ) ) [EOL] assert np . array_equal ( gind , np . empty ( ( [number] , ) ) ) [EOL] [comment] [EOL] gind = fuat . get_invalid_indices ( NOT_NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [number] ] ) ) [EOL] gind = fuat . get_invalid_indices ( NOT_NUMERICAL_NP_ARRAY , np . array ( [ [string] , [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [string] , [string] ] ) ) [EOL] [comment] [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [number] , [string] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [string] ] ) ) [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [number] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ [number] ] ) ) [EOL] gind = fuat . get_invalid_indices ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [string] , [string] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ ] ) ) [EOL] [comment] [EOL] gind = fuat . get_invalid_indices ( WIDE_STRUCTURED_ARRAY , np . array ( [ [string] , [string] ] ) ) [EOL] assert np . array_equal ( gind , np . array ( [ ] ) ) [EOL] [EOL] [EOL] def test_are_indices_valid ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] incorrect_shape_array = [string] [EOL] incorrect_shape_indices = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . are_indices_valid ( None , np . ones ( ( [number] , ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . are_indices_valid ( None , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . are_indices_valid ( np . ones ( ( [number] , ) ) , None ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . are_indices_valid ( None , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . are_indices_valid ( np . ones ( ( [number] , ) ) , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_array [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . are_indices_valid ( np . ones ( ( [number] , ) ) , np . ones ( ( [number] , ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_array [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fuat . are_indices_valid ( np . ones ( ( [number] , [number] ) ) , np . ones ( ( [number] , [number] ) ) ) [EOL] assert str ( exin . value ) == incorrect_shape_indices [EOL] [EOL] assert not fuat . are_indices_valid ( NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] assert not fuat . are_indices_valid ( NUMERICAL_NP_ARRAY , np . array ( [ [string] , [number] ] ) ) [EOL] assert fuat . are_indices_valid ( NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] assert not fuat . are_indices_valid ( NOT_NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] assert not fuat . are_indices_valid ( NOT_NUMERICAL_NP_ARRAY , np . array ( [ [string] , [number] ] ) ) [comment] [EOL] assert fuat . are_indices_valid ( NOT_NUMERICAL_NP_ARRAY , np . array ( [ [number] , [number] ] ) ) [EOL] [comment] [EOL] assert not fuat . are_indices_valid ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [number] , [string] ] ) ) [EOL] assert not fuat . are_indices_valid ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [number] ] ) ) [comment] [EOL] assert fuat . are_indices_valid ( NUMERICAL_STRUCTURED_ARRAY , np . array ( [ [string] , [string] ] ) ) [EOL] [comment] [EOL] assert fuat . are_indices_valid ( WIDE_STRUCTURED_ARRAY , np . array ( [ [string] , [string] ] ) ) [EOL] [EOL] [EOL] def test_generalise_dtype ( ) : [EOL] [docstring] [EOL] error_msg = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . generalise_dtype ( np . dtype ( np . datetime64 ) , np . dtype ( np . datetime64 ) ) [EOL] assert str ( exin . value ) == error_msg . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . generalise_dtype ( np . dtype ( np . float64 ) , np . dtype ( np . datetime64 ) ) [EOL] assert str ( exin . value ) == error_msg . format ( [string] ) [EOL] [EOL] dtype_int = np . dtype ( int ) [EOL] dtype_int32 = np . dtype ( np . int32 ) [EOL] dtype_int64 = np . dtype ( np . int64 ) [EOL] dtype_float = np . dtype ( float ) [EOL] dtype_float16 = np . dtype ( np . float16 ) [EOL] dtype_float32 = np . dtype ( np . float32 ) [EOL] dtype_float64 = np . dtype ( np . float64 ) [EOL] dtype_str = np . dtype ( str ) [EOL] dtype_str4 = np . dtype ( [string] ) [EOL] dtype_str11 = np . dtype ( [string] ) [EOL] dtype_str16 = np . dtype ( [string] ) [EOL] dtype_str21 = np . dtype ( [string] ) [EOL] dtype_str32 = np . dtype ( [string] ) [EOL] [EOL] assert dtype_int64 is fuat . generalise_dtype ( dtype_int , dtype_int32 ) [EOL] assert dtype_int64 is fuat . generalise_dtype ( dtype_int , dtype_int64 ) [EOL] assert dtype_int64 is fuat . generalise_dtype ( dtype_int32 , dtype_int64 ) [EOL] assert dtype_int64 is fuat . generalise_dtype ( dtype_int , dtype_int ) [EOL] [EOL] assert dtype_float64 is fuat . generalise_dtype ( dtype_float , dtype_float ) [EOL] assert dtype_float64 is fuat . generalise_dtype ( dtype_float64 , dtype_float ) [EOL] assert dtype_float64 is fuat . generalise_dtype ( dtype_int , dtype_float32 ) [EOL] assert dtype_float64 is fuat . generalise_dtype ( dtype_int32 , dtype_float32 ) [EOL] assert dtype_float32 is fuat . generalise_dtype ( dtype_float32 , dtype_float16 ) [EOL] [EOL] assert dtype_str4 is fuat . generalise_dtype ( dtype_str , dtype_str4 ) [EOL] assert dtype_str21 is fuat . generalise_dtype ( dtype_str21 , dtype_str4 ) [EOL] [EOL] assert dtype_str16 == fuat . generalise_dtype ( dtype_str11 , dtype_str16 ) [EOL] assert dtype_str11 == fuat . generalise_dtype ( dtype_int32 , dtype_str4 ) [EOL] assert dtype_str21 == fuat . generalise_dtype ( dtype_int64 , dtype_str4 ) [EOL] assert dtype_str32 == fuat . generalise_dtype ( dtype_float32 , dtype_str4 ) [EOL] assert dtype_str32 == fuat . generalise_dtype ( dtype_float64 , dtype_str16 ) [EOL] [EOL] [EOL] def test_fatf_structured_to_unstructured_row ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . fatf_structured_to_unstructured_row ( np . array ( [ [string] ] , np . void ) [ [number] ] ) [EOL] assert str ( exin . value ) == type_error [EOL] value_arror = ( [string] [string] [string] [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . fatf_structured_to_unstructured_row ( NOT_BASE_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == value_arror [EOL] [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] [comment] [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NOT_NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NOT_NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NOT_NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] [comment] [EOL] simple = fuat . fatf_structured_to_unstructured_row ( WIDE_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , WIDE_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] simple = fuat . fatf_structured_to_unstructured_row ( WIDE_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , WIDE_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] [EOL] assert fuat . fatf_structured_to_unstructured_row ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , float ) ] ) [ [number] ] ) == [number] [EOL] [EOL] [EOL] def test_structured_to_unstructured_row ( ) : [EOL] [docstring] [EOL] simple = fuat . fatf_structured_to_unstructured_row ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] assert fuat . fatf_structured_to_unstructured_row ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , float ) ] ) [ [number] ] ) == [number] [EOL] assert ( [string] [string] [string] [string] ) [EOL] [EOL] [EOL] def test_choose_structured_to_unstructured ( caplog ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] installed_numpy_version = np . version . version [EOL] [comment] [EOL] np . version . version = [string] [EOL] log_message = ( [string] [string] [string] [string] [string] ) [EOL] assert fuat . _choose_structured_to_unstructured ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == log_message [EOL] [comment] [EOL] np . version . version = [string] [EOL] log_message = ( [string] [string] [string] [string] ) [EOL] assert not fuat . _choose_structured_to_unstructured ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == log_message [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] np . version . version = installed_numpy_version [EOL] [EOL] [EOL] def test_fatf_structured_to_unstructured ( ) : [EOL] [docstring] [EOL] [comment] [EOL] type_error = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . fatf_structured_to_unstructured ( NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . fatf_structured_to_unstructured ( NOT_NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . fatf_structured_to_unstructured ( WIDE_NP_ARRAY ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] value_error = ( [string] [string] [string] [string] ) [EOL] complex_array = np . array ( [ ( None , object ( ) ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . fatf_structured_to_unstructured ( complex_array ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [comment] [EOL] simple = fuat . fatf_structured_to_unstructured ( NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY ) [EOL] simple = fuat . fatf_structured_to_unstructured ( NOT_NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY ) [EOL] simple = fuat . fatf_structured_to_unstructured ( WIDE_STRUCTURED_ARRAY ) [EOL] assert _compare_nan_arrays ( simple , WIDE_UNSTRUCTURED_ARRAY ) [EOL] [EOL] simple = fuat . fatf_structured_to_unstructured ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , float ) ] ) ) [EOL] assert np . array_equal ( simple , np . array ( [ [ [number] ] ] ) ) [EOL] simple = fuat . fatf_structured_to_unstructured ( np . array ( [ ( [number] , ) , ( [number] , ) ] , dtype = [ ( [string] , float ) ] ) ) [EOL] assert np . array_equal ( simple , np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] [EOL] def test_structured_to_unstructured ( ) : [EOL] [docstring] [EOL] simple = fuat . structured_to_unstructured ( NOT_NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY ) [EOL] simple = fuat . structured_to_unstructured ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , float ) ] ) ) [EOL] assert _compare_nan_arrays ( simple , np . array ( [ [ [number] ] ] ) ) [EOL] assert ( [string] [string] [string] ) [EOL] [EOL] [EOL] def test_as_unstructured ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] [string] ) [EOL] value_error = ( [string] [string] [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fuat . as_unstructured ( None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] [comment] [EOL] simple = fuat . as_unstructured ( NUMERICAL_STRUCTURED_ARRAY [ [number] ] ) [EOL] assert _compare_nan_arrays ( simple , NUMERICAL_UNSTRUCTURED_ARRAY [ [number] ] ) [EOL] [EOL] [comment] [EOL] simple = fuat . as_unstructured ( NOT_NUMERICAL_STRUCTURED_ARRAY ) [EOL] assert np . array_equal ( simple , NOT_NUMERICAL_UNSTRUCTURED_ARRAY ) [EOL] [comment] [EOL] simple = fuat . as_unstructured ( BASE_NP_ARRAY ) [EOL] assert np . array_equal ( simple , BASE_NP_ARRAY ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fuat . as_unstructured ( NOT_BASE_NP_ARRAY ) [EOL] assert str ( exin . value ) == value_error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from numbers import Number [EOL] from typing import List [EOL] [EOL] import numpy as np [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] [EOL] def systematic_performance_bias ( metrics_list , threshold = [number] ) : [EOL] [docstring] [EOL] grid_check = systematic_performance_bias_grid ( metrics_list , threshold ) [EOL] is_biased = grid_check . any ( ) [EOL] return is_biased [EOL] [EOL] [EOL] def systematic_performance_bias_grid ( metrics_list , threshold = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] if isinstance ( metrics_list , list ) : [EOL] if not metrics_list : [EOL] raise ValueError ( [string] ) [EOL] for metric_value in metrics_list : [EOL] if not isinstance ( metric_value , Number ) : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [comment] [EOL] if isinstance ( threshold , Number ) : [EOL] if threshold < [number] or threshold > [number] : [EOL] raise ValueError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] metrics_array = np . asarray ( metrics_list ) [EOL] inv_threshold = [number] - threshold [EOL] [comment] [EOL] proportions = metrics_array [ np . newaxis , : ] / metrics_array [ : , np . newaxis ] [EOL] proportions = np . abs ( proportions - [number] ) [EOL] [EOL] [comment] [EOL] grid_check = proportions > inv_threshold [EOL] np . logical_or ( grid_check , grid_check . T , out = grid_check ) [EOL] [EOL] return grid_check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . accountability . models . measures as famm [EOL] [EOL] [EOL] def test_systematic_performance_bias_grid ( ) : [EOL] [docstring] [EOL] type_error_metric_out = [string] [EOL] type_error_metric_in = ( [string] [string] ) [EOL] value_error_metric = [string] [EOL] [comment] [EOL] type_error_threshold = [string] [EOL] value_error_threshold = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] famm . systematic_performance_bias_grid ( [string] ) [EOL] assert str ( exin . value ) == type_error_metric_out [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] famm . systematic_performance_bias_grid ( [ [number] , [number] , [number] , [string] , [number] ] ) [EOL] assert str ( exin . value ) == type_error_metric_in [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] famm . systematic_performance_bias_grid ( [ ] ) [EOL] assert str ( exin . value ) == value_error_metric [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] famm . systematic_performance_bias_grid ( [ [number] , [number] , [number] , [number] ] , [string] ) [EOL] assert str ( exin . value ) == type_error_threshold [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] famm . systematic_performance_bias_grid ( [ [number] , [number] , [number] , [number] ] , - [number] ) [EOL] assert str ( exin . value ) == value_error_threshold [EOL] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , False , False ] , [ False , False , False ] , [ False , False , False ] ] ) [comment] [EOL] grid_check = famm . systematic_performance_bias_grid ( performances ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , False , True ] , [ False , False , False ] , [ True , False , False ] ] ) [comment] [EOL] grid_check = famm . systematic_performance_bias_grid ( performances ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , True , True ] , [ True , False , True ] , [ True , True , False ] ] ) [comment] [EOL] grid_check = famm . systematic_performance_bias_grid ( performances ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] [EOL] def test_systematic_performance_bias ( ) : [EOL] [docstring] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check = famm . systematic_performance_bias ( performances ) [EOL] assert not grid_check [EOL] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check = famm . systematic_performance_bias ( performances ) [EOL] assert grid_check [EOL] [EOL] performances = [ [number] , [number] , [number] ] [EOL] grid_check = famm . systematic_performance_bias ( performances ) [EOL] assert grid_check [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . accountability . data . measures as fadm [EOL] [EOL] [EOL] def test_get_weights ( ) : [EOL] [docstring] [EOL] weights = fadm . _get_weights ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ] ) [EOL] true_weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert np . allclose ( weights , true_weights , atol = [number] ) [EOL] [EOL] [EOL] def test_validate_threshold ( ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] value_error = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . _validate_threshold ( [string] ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . _validate_threshold ( - [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . _validate_threshold ( [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [EOL] def test_validate_counts ( ) : [EOL] [docstring] [EOL] type_error_out = [string] [EOL] type_error_in = [string] [EOL] value_error = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . _validate_counts ( [string] ) [EOL] assert str ( exin . value ) == type_error_out [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . _validate_counts ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert str ( exin . value ) == type_error_in [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . _validate_counts ( [ [number] , [number] , [number] , [number] , - [number] , [number] , [number] ] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] [EOL] def test_sampling_bias_grid_check ( ) : [EOL] [docstring] [EOL] counts = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , False , False ] , [ False , False , False ] , [ False , False , False ] ] ) [comment] [EOL] grid_check = fadm . sampling_bias_grid_check ( counts ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] counts = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , False , True ] , [ False , False , False ] , [ True , False , False ] ] ) [comment] [EOL] grid_check = fadm . sampling_bias_grid_check ( counts ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] counts = [ [number] , [number] , [number] ] [EOL] grid_check_true = np . array ( [ [ False , True , True ] , [ True , False , True ] , [ True , True , False ] ] ) [comment] [EOL] grid_check = fadm . sampling_bias_grid_check ( counts ) [EOL] assert np . array_equal ( grid_check , grid_check_true ) [EOL] [EOL] [EOL] def test_sampling_bias_check ( ) : [EOL] [docstring] [EOL] counts = [ [number] , [number] , [number] ] [EOL] assert not fadm . sampling_bias_check ( counts ) [EOL] [EOL] counts = [ [number] , [number] , [number] ] [EOL] assert fadm . sampling_bias_check ( counts ) [EOL] [EOL] [EOL] def test_sampling_bias_indexed ( ) : [EOL] [docstring] [EOL] type_error_out = [string] [EOL] value_error_empty = [string] [EOL] value_error_negative_index = ( [string] [string] ) [EOL] type_error_nonnumber_index = ( [string] [string] ) [EOL] type_error_in = ( [string] [string] ) [EOL] value_error_duplicates = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . sampling_bias_indexed ( [string] ) [EOL] assert str ( exin . value ) == type_error_out [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . sampling_bias_indexed ( [ [ [number] ] , [ [number] ] , [string] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == type_error_in [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fadm . sampling_bias_indexed ( [ [ [number] ] , [ [number] ] , [ [number] , [string] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == type_error_nonnumber_index . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . sampling_bias_indexed ( [ ] ) [EOL] assert str ( exin . value ) == value_error_empty [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . sampling_bias_indexed ( [ [ [number] ] , [ [number] ] , [ - [number] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == value_error_negative_index [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fadm . sampling_bias_indexed ( [ [ [number] , [number] ] , [ [number] ] , [ [number] , [number] ] , [ [number] ] ] ) [EOL] assert str ( exin . value ) == value_error_duplicates [EOL] [EOL] user_warning = ( [string] [string] [string] ) [EOL] with pytest . warns ( UserWarning ) as w : [EOL] counts , weights = fadm . sampling_bias_indexed ( [ [ [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] ] ] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning . format ( [string] ) [EOL] assert counts == [ [number] , [number] , [number] ] [EOL] true_weights = np . array ( [ [number] , np . nan , [number] , [number] , [number] , [number] , [number] ] ) [EOL] assert np . allclose ( weights , true_weights , atol = [number] , equal_nan = True ) [EOL] [EOL] binning = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] true_counts = [ [number] , [number] , [number] ] [EOL] true_weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] counts , weights = fadm . sampling_bias_indexed ( binning ) [EOL] assert counts == true_counts [EOL] assert np . allclose ( weights , true_weights , atol = [number] ) [EOL] [EOL] [EOL] def test_sampling_bias ( ) : [EOL] [docstring] [EOL] dataset = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [comment] [EOL] true_counts = [ [number] , [number] , [number] ] [EOL] true_weights = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] true_bin_names = [ [string] , [string] , [string] ] [EOL] [EOL] counts , weights , bin_names = fadm . sampling_bias ( dataset , [number] ) [EOL] assert counts == true_counts [EOL] assert np . allclose ( weights , true_weights , atol = [number] ) [EOL] assert bin_names == true_bin_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Literal , Type , Tuple , Any , List , Union , Set [EOL] import typing [EOL] import typing_extensions [EOL] import logging [EOL] import builtins [EOL] import matplotlib [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import logging [EOL] [EOL] from numbers import Number [EOL] from typing import Any , Dict , Set , Union [EOL] [EOL] import matplotlib . pyplot as plt [EOL] [EOL] __all__ = [ [string] ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [comment] [EOL] [EOL] BlimeyExplanation = Dict [ str , float ] [EOL] [EOL] [EOL] def plot_lime ( surrogate_explanation ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def validate ( explanation ) : [EOL] is_valid = False [EOL] if isinstance ( explanation , dict ) : [EOL] if not explanation : [EOL] raise ValueError ( [string] [string] ) [EOL] for key , value in explanation . items ( ) : [EOL] if not isinstance ( key , str ) : [EOL] raise TypeError ( [string] [string] ) [EOL] if not isinstance ( value , Number ) : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] is_valid = True [EOL] return is_valid [EOL] [EOL] if isinstance ( surrogate_explanation , dict ) : [EOL] if not surrogate_explanation : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] example_key = sorted ( surrogate_explanation . keys ( ) ) [ [number] ] [EOL] example_explanation = surrogate_explanation [ example_key ] [EOL] [comment] [EOL] if isinstance ( example_explanation , dict ) : [EOL] for class_name , explanation in surrogate_explanation . items ( ) : [EOL] if not isinstance ( class_name , str ) : [EOL] raise TypeError ( [string] ) [EOL] assert validate ( explanation ) , [string] [EOL] plot_explanation = surrogate_explanation [comment] [EOL] [comment] [EOL] elif isinstance ( example_explanation , Number ) : [EOL] assert validate ( surrogate_explanation ) , [string] [EOL] plot_explanation = { [string] : surrogate_explanation } [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [comment] [EOL] class_names = sorted ( plot_explanation . keys ( ) ) [EOL] class_n = len ( class_names ) [EOL] [EOL] [comment] [EOL] share_y = True [EOL] fig_shape = ( [number] , class_n ) [EOL] [comment] [EOL] explanation_label_set_old = set ( ) [comment] [EOL] for class_explanation in plot_explanation . values ( ) : [EOL] if not explanation_label_set_old : [EOL] explanation_label_set_old = set ( class_explanation . keys ( ) ) [EOL] else : [EOL] explanation_labels_set = set ( class_explanation . keys ( ) ) [EOL] if explanation_label_set_old != explanation_labels_set : [EOL] share_y = False [EOL] fig_shape = ( class_n , [number] ) [EOL] logger . info ( [string] [string] ) [EOL] break [EOL] [EOL] [comment] [EOL] if share_y : [EOL] name_ordering = sorted ( plot_explanation [ class_names [ [number] ] ] . keys ( ) ) [EOL] [EOL] figure , axes = plt . subplots ( * fig_shape , sharey = share_y , sharex = True ) [EOL] figure . suptitle ( [string] ) [EOL] [EOL] [comment] [EOL] for i in range ( class_n ) : [EOL] class_name = class_names [ i ] [EOL] class_explanation = plot_explanation [ class_name ] [EOL] [EOL] [comment] [EOL] if share_y : [EOL] exp_names = name_ordering [EOL] else : [EOL] exp_names = sorted ( class_explanation . keys ( ) ) [EOL] exp_values = [ class_explanation [ name ] for name in exp_names ] [EOL] [EOL] positions = [ i + [number] for i in range ( len ( class_explanation ) ) ] [EOL] colours = [ [string] if val > [number] else [string] for val in exp_values ] [EOL] [EOL] if class_n == [number] : [EOL] [comment] [EOL] axis = axes [EOL] else : [EOL] axis = axes [ i ] [EOL] axis . barh ( positions , exp_values , align = [string] , color = colours ) [EOL] axis . set_yticks ( positions ) [EOL] axis . set_yticklabels ( exp_names ) [EOL] [EOL] axis . set_title ( [string] . format ( class_name ) ) [EOL] [EOL] return figure [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $matplotlib.pyplot.Figure$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] try : [EOL] import matplotlib [EOL] import matplotlib . pyplot as plt [EOL] except ImportError : [EOL] raise ImportError ( [string] [string] [string] [string] ) [EOL] else : [EOL] [comment] [EOL] plt . style . use ( [string] ) [EOL] [comment] [EOL] del plt [EOL] del matplotlib [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , Any , List , Union [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import matplotlib [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from numbers import Number [EOL] from typing import List , Optional , Tuple , Union [EOL] [EOL] import matplotlib . collections [EOL] [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] __all__ = [ [string] , [string] ] [comment] [EOL] [EOL] [EOL] def _validate_input ( ice_pdp_array , feature_linespace , class_index , feature_name , class_name , plot_axis , test_partial_dependence = False ) : [EOL] [docstring] [EOL] [comment] [EOL] input_is_valid = False [EOL] [EOL] assert isinstance ( test_partial_dependence , bool ) , [string] [EOL] [EOL] if fuav . is_structured_array ( ice_pdp_array ) : [EOL] raise ValueError ( [string] ) [EOL] if not fuav . is_numerical_array ( ice_pdp_array ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if test_partial_dependence : [EOL] if len ( ice_pdp_array . shape ) != [number] : [EOL] raise IncorrectShapeError ( [string] [string] [string] ) [EOL] else : [EOL] if len ( ice_pdp_array . shape ) != [number] : [EOL] raise IncorrectShapeError ( [string] [string] [string] ) [EOL] [EOL] if fuav . is_structured_array ( feature_linespace ) : [EOL] raise ValueError ( [string] ) [EOL] if not fuav . is_1d_array ( feature_linespace ) : [EOL] raise IncorrectShapeError ( [string] [string] ) [EOL] if not fuav . is_numerical_array ( feature_linespace ) : [EOL] raise ValueError ( [string] ) [EOL] if feature_linespace . shape [ [number] ] != ice_pdp_array . shape [ - [number] ] : [EOL] raise ValueError ( [string] [string] [string] . format ( feature_linespace . shape [ [number] ] , ice_pdp_array . shape [ - [number] ] ) ) [EOL] [EOL] [comment] [EOL] if not isinstance ( class_index , int ) : [EOL] raise TypeError ( [string] ) [EOL] if class_index < [number] or class_index >= ice_pdp_array . shape [ - [number] ] : [EOL] raise IndexError ( [string] [string] [string] . format ( class_index , ice_pdp_array . shape [ - [number] ] ) ) [EOL] [EOL] if feature_name is not None and not isinstance ( feature_name , str ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if class_name is not None and not isinstance ( class_name , str ) : [EOL] raise TypeError ( [string] ) [EOL] [EOL] if plot_axis is not None and not isinstance ( plot_axis , plt . Axes ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] input_is_valid = True [EOL] return input_is_valid [EOL] [EOL] [EOL] def _prepare_a_canvas ( plot_title , plot_axis , class_index , class_name , feature_name , x_range ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] assert isinstance ( plot_title , str ) , [string] [EOL] assert plot_axis is None or isinstance ( plot_axis , plt . Axes ) , [string] [EOL] assert isinstance ( class_index , int ) , [string] [EOL] assert class_name is None or isinstance ( class_name , str ) , [string] [EOL] assert feature_name is None or isinstance ( feature_name , str ) , [string] [EOL] assert isinstance ( x_range , list ) , [string] [EOL] assert len ( x_range ) == [number] , [string] [EOL] assert isinstance ( x_range [ [number] ] , Number ) and isinstance ( x_range [ [number] ] , Number ) , [string] [EOL] assert x_range [ [number] ] < x_range [ [number] ] , [string] [EOL] [EOL] if plot_axis is None : [EOL] if class_name is None : [EOL] class_name = [string] . format ( class_index ) [EOL] if feature_name is None : [EOL] feature_name = [string] [EOL] [EOL] plot_figure , plot_axis = plt . subplots ( [number] , [number] ) [EOL] plot_axis . set_title ( plot_title ) [EOL] plot_axis . set_xlim ( x_range ) [EOL] plot_axis . set_xlabel ( feature_name ) [EOL] plot_axis . set_ylim ( np . array ( [ - [number] , [number] ] ) ) [EOL] plot_axis . set_ylabel ( [string] . format ( class_name ) ) [EOL] else : [EOL] plot_figure = None [EOL] [comment] [EOL] current_x_range = plot_axis . xaxis . get_view_interval ( ) [EOL] if not np . array_equal ( current_x_range , x_range ) : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] current_y_range = plot_axis . yaxis . get_view_interval ( ) [EOL] if not np . array_equal ( current_y_range , [ - [number] , [number] ] ) : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] if plot_title : [EOL] current_title = plot_axis . get_title ( ) [EOL] plot_axis . set_title ( [string] . format ( current_title , plot_title ) ) [EOL] [EOL] [comment] [EOL] if feature_name is None : [EOL] [comment] [EOL] current_x_label = plot_axis . xaxis . get_label_text ( ) [EOL] if not current_x_label : [EOL] plot_axis . set_xlabel ( [string] ) [EOL] else : [EOL] [comment] [EOL] plot_axis . set_xlabel ( feature_name ) [EOL] [EOL] if class_name is None : [EOL] [comment] [EOL] current_y_label = plot_axis . yaxis . get_label_text ( ) [EOL] if not current_y_label : [EOL] plot_axis . set_ylabel ( [string] . format ( class_index ) ) [EOL] else : [EOL] [comment] [EOL] plot_axis . set_ylabel ( [string] . format ( class_name ) ) [EOL] [EOL] return plot_figure , plot_axis [EOL] [EOL] [EOL] def plot_individual_conditional_expectation ( ice_array , feature_linespace , class_index , feature_name = None , class_name = None , plot_axis = None ) : [EOL] [docstring] [EOL] [comment] [EOL] assert _validate_input ( ice_array , feature_linespace , class_index , feature_name , class_name , plot_axis , False ) , [string] [EOL] [EOL] plot_title = [string] [EOL] x_range = [ feature_linespace [ [number] ] , feature_linespace [ - [number] ] ] [EOL] plot_figure , plot_axis = _prepare_a_canvas ( plot_title , plot_axis , class_index , class_name , feature_name , x_range ) [EOL] [EOL] lines = np . zeros ( ( ice_array . shape [ [number] ] , ice_array . shape [ [number] ] , [number] ) , dtype = ice_array . dtype ) [EOL] lines [ : , : , [number] ] = ice_array [ : , : , class_index ] [EOL] lines [ : , : , [number] ] = feature_linespace [EOL] [EOL] line_collection = matplotlib . collections . LineCollection ( lines , label = [string] , color = [string] , alpha = [number] ) [EOL] plot_axis . add_collection ( line_collection ) [EOL] plot_axis . legend ( ) [EOL] [EOL] return plot_figure , plot_axis [EOL] [EOL] [EOL] def plot_partial_dependence ( pd_array , feature_linespace , class_index , feature_name = None , class_name = None , plot_axis = None ) : [EOL] [docstring] [EOL] [comment] [EOL] assert _validate_input ( pd_array , feature_linespace , class_index , feature_name , class_name , plot_axis , True ) , [string] [EOL] [EOL] plot_title = [string] [EOL] x_range = [ feature_linespace [ [number] ] , feature_linespace [ - [number] ] ] [EOL] plot_figure , plot_axis = _prepare_a_canvas ( plot_title , plot_axis , class_index , class_name , feature_name , x_range ) [EOL] [EOL] plot_axis . plot ( feature_linespace , pd_array [ : , class_index ] , color = [string] , linewidth = [number] , alpha = [number] , label = [string] ) [EOL] plot_axis . legend ( ) [EOL] [EOL] return plot_figure , plot_axis [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[matplotlib.pyplot.Figure,None],matplotlib.pyplot.Axes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[matplotlib.pyplot.Figure,None],matplotlib.pyplot.Axes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Union[matplotlib.pyplot.Figure,None],matplotlib.pyplot.Axes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import matplotlib [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] , allow_module_level = True ) [EOL] else : [EOL] del matplotlib [EOL] [EOL] import importlib [EOL] import sys [EOL] [EOL] import fatf . utils . testing . imports as futi [EOL] import fatf . vis [EOL] [EOL] [EOL] def test_import_when_installed ( ) : [EOL] [docstring] [EOL] assert [string] in sys . modules [EOL] with futi . module_import_tester ( [string] , when_missing = False ) : [EOL] importlib . reload ( fatf . vis ) [EOL] assert [string] in sys . modules [EOL] [EOL] [EOL] def test_import_when_missing ( ) : [EOL] [docstring] [EOL] assert [string] in sys . modules [EOL] exception_msg = ( [string] [string] [string] [string] ) [EOL] with futi . module_import_tester ( [string] , when_missing = True ) : [EOL] with pytest . raises ( ImportError ) as exin : [EOL] importlib . reload ( fatf . vis ) [EOL] assert str ( exin . value ) == exception_msg [EOL] assert [string] in sys . modules [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Tuple , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import matplotlib [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] , allow_module_level = True ) [EOL] else : [EOL] del matplotlib [EOL] [EOL] import fatf . utils . testing . vis as futv [EOL] import fatf . vis . lime as fvl [EOL] [EOL] RED = ( [number] , [number] , [number] , [number] ) [EOL] GREEN = ( [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_plot_lime_validation ( caplog ) : [EOL] [docstring] [EOL] type_error_global = [string] [EOL] type_error_key_type = ( [string] [string] ) [EOL] type_error_key = [string] [EOL] type_error_val = [string] [EOL] type_error_tup1 = [string] [EOL] type_error_tup2 = [string] [EOL] [EOL] value_error_global = [string] [EOL] value_error = [string] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( [string] ) [EOL] assert str ( exin . value ) == type_error_global [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvl . plot_lime ( { } ) [EOL] assert str ( exin . value ) == value_error_global [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( { [string] : None } ) [EOL] assert str ( exin . value ) == type_error_key_type [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( { None : { } } ) [EOL] assert str ( exin . value ) == type_error_key [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvl . plot_lime ( { [string] : { } } ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( { [string] : { None : [string] } } ) [EOL] assert str ( exin . value ) == type_error_tup1 [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( { [string] : { [string] : [string] } } ) [EOL] assert str ( exin . value ) == type_error_tup2 [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvl . plot_lime ( { [string] : { [string] : [number] } , [string] : None } ) [EOL] assert str ( exin . value ) == type_error_val [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [EOL] def test_plot_lime_classification ( caplog ) : [EOL] [docstring] [EOL] assert len ( caplog . records ) == [number] [EOL] logger_info = ( [string] [string] ) [EOL] data_dict = { [string] : { [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : - [number] } , [string] : { [string] : [number] , [string] : - [number] , [string] : [number] , [string] : - [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [comment] [EOL] classes = sorted ( data_dict . keys ( ) ) [EOL] x_range = [ - [number] , [number] ] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] y_labels = sorted ( data_dict [ [string] ] . keys ( ) ) [EOL] widths = [ [ [number] , - [number] , - [number] , - [number] ] , [ - [number] , - [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] colours = [ [ GREEN , RED , RED , RED ] , [ RED , RED , GREEN , GREEN ] , [ GREEN , GREEN , GREEN , GREEN ] ] [EOL] widths_dict = [ ] [EOL] colours_dict = [ ] [EOL] for i , _ in enumerate ( classes ) : [EOL] widths_dict_ = [ ] [EOL] colours_dict_ = [ ] [EOL] for label in y_labels : [EOL] y_labels_index = y_labels . index ( label ) [EOL] widths_dict_ . append ( widths [ i ] [ y_labels_index ] ) [EOL] colours_dict_ . append ( colours [ i ] [ y_labels_index ] ) [EOL] widths_dict . append ( widths_dict_ ) [EOL] colours_dict . append ( colours_dict_ ) [EOL] [EOL] [comment] [EOL] fig = fvl . plot_lime ( data_dict ) [EOL] assert len ( fig . axes ) == len ( classes ) [EOL] [EOL] for axis_index in range ( len ( fig . axes ) ) : [EOL] bar_data = futv . get_bar_data ( fig . axes [ axis_index ] ) [EOL] title , x_ticks , x_rng , y_ticks , y_rng , width , colour = bar_data [EOL] [EOL] [comment] [EOL] [comment] [EOL] i = classes . index ( title ) [EOL] [comment] [EOL] assert title == classes [ i ] [EOL] [comment] [EOL] for j in x_ticks : [EOL] assert j == [string] [EOL] assert len ( x_range ) == [number] [EOL] assert len ( x_rng ) == [number] [EOL] assert abs ( ( x_range [ [number] ] - x_range [ [number] ] ) - ( x_rng [ [number] ] - x_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] if axis_index == [number] : [EOL] assert len ( y_labels ) == len ( y_ticks ) [EOL] for j in range ( len ( y_ticks ) ) : [EOL] assert y_labels [ j ] == y_ticks [ j ] [EOL] else : [EOL] assert not y_ticks [EOL] assert len ( y_rng ) == [number] [EOL] assert abs ( len ( data_dict [ classes [ i ] ] ) - ( y_rng [ [number] ] - y_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert len ( width ) == len ( widths [ i ] ) [EOL] for j in range ( len ( width ) ) : [EOL] assert widths [ i ] [ j ] == width [ j ] [EOL] [comment] [EOL] assert len ( colour ) == len ( colours [ i ] ) [EOL] for j in range ( len ( colour ) ) : [EOL] assert len ( colour [ j ] ) == len ( colours [ i ] [ j ] ) [EOL] for k in range ( len ( colour [ j ] ) ) : [EOL] assert abs ( colours [ i ] [ j ] [ k ] - colour [ j ] [ k ] ) < [number] [EOL] [EOL] [comment] [EOL] del data_dict [ [string] ] [ [string] ] [EOL] y_labels = [ sorted ( data_dict [ i ] . keys ( ) ) for i in classes ] [EOL] widths = [ [ data_dict [ c ] [ j ] for j in y_labels [ i ] ] for i , c in enumerate ( classes ) ] [EOL] colours = [ [ GREEN , RED , RED , RED ] , [ RED , RED , GREEN ] , [ GREEN , GREEN , GREEN , GREEN ] ] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] fig = fvl . plot_lime ( data_dict ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == logger_info [EOL] [EOL] assert len ( fig . axes ) == len ( classes ) [EOL] [EOL] for axis_index in range ( len ( fig . axes ) ) : [EOL] bar_data = futv . get_bar_data ( fig . axes [ axis_index ] ) [EOL] title , x_ticks , x_rng , y_ticks , y_rng , width , colour = bar_data [EOL] [EOL] [comment] [EOL] [comment] [EOL] i = classes . index ( title ) [EOL] [comment] [EOL] assert title == classes [ i ] [EOL] [comment] [EOL] for j in x_ticks : [EOL] assert j == [string] [EOL] assert len ( x_range ) == [number] [EOL] assert len ( x_rng ) == [number] [EOL] assert abs ( ( x_range [ [number] ] - x_range [ [number] ] ) - ( x_rng [ [number] ] - x_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert len ( y_labels [ i ] ) == len ( y_ticks ) [EOL] for j in range ( len ( y_ticks ) ) : [EOL] assert y_labels [ i ] [ j ] == y_ticks [ j ] [EOL] assert len ( y_rng ) == [number] [EOL] assert abs ( len ( data_dict [ classes [ i ] ] ) - ( y_rng [ [number] ] - y_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert len ( width ) == len ( widths [ i ] ) [EOL] for j in range ( len ( width ) ) : [EOL] assert widths [ i ] [ j ] == width [ j ] [EOL] [comment] [EOL] [comment] [EOL] assert len ( colour ) == len ( colours [ i ] ) [EOL] for j in range ( len ( colour ) ) : [EOL] assert len ( colour [ j ] ) == len ( colours [ i ] [ j ] ) [EOL] for k in range ( len ( colour [ j ] ) ) : [EOL] assert abs ( colours [ i ] [ j ] [ k ] - colour [ j ] [ k ] ) < [number] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [EOL] def test_plot_lime_regression ( caplog ) : [EOL] [docstring] [EOL] assert len ( caplog . records ) == [number] [EOL] data = { [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : - [number] } [comment] [EOL] x_range = [ - [number] , [number] ] [comment] [EOL] y_labels = sorted ( data . keys ( ) ) [EOL] true_width = [ [number] , - [number] , - [number] , - [number] ] [EOL] true_colour = [ GREEN , RED , RED , RED ] [EOL] true_title = [string] [EOL] [EOL] fig = fvl . plot_lime ( data ) [EOL] assert len ( fig . axes ) == [number] [EOL] [EOL] bar_data = futv . get_bar_data ( fig . axes [ [number] ] ) [EOL] title , x_ticks , x_rng , y_ticks , y_rng , width , colour = bar_data [EOL] assert true_title == title [EOL] [comment] [EOL] for j in x_ticks : [EOL] assert j == [string] [EOL] assert len ( x_range ) == [number] [EOL] assert len ( x_rng ) == [number] [EOL] assert abs ( ( x_range [ [number] ] - x_range [ [number] ] ) - ( x_rng [ [number] ] - x_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert len ( y_labels ) == len ( y_ticks ) [EOL] for j in range ( len ( y_ticks ) ) : [EOL] assert y_labels [ j ] == y_ticks [ j ] [EOL] assert len ( y_rng ) == [number] [EOL] assert abs ( len ( data ) - ( y_rng [ [number] ] - y_rng [ [number] ] ) ) < [number] [EOL] [comment] [EOL] assert len ( width ) == len ( true_width ) [EOL] for j in range ( len ( width ) ) : [EOL] assert true_width [ j ] == width [ j ] [EOL] [comment] [EOL] [comment] [EOL] assert len ( colour ) == len ( true_colour ) [EOL] for j in range ( len ( colour ) ) : [EOL] assert len ( colour [ j ] ) == len ( true_colour [ j ] ) [EOL] for k in range ( len ( colour [ j ] ) ) : [EOL] assert abs ( true_colour [ j ] [ k ] - colour [ j ] [ k ] ) < [number] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import matplotlib . legend [EOL] import matplotlib . pyplot as plt [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] , allow_module_level = True ) [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . testing . vis as futv [EOL] import fatf . vis . feature_influence as fvfi [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] FAKE_ICE_ARRAY = np . array ( [ [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ] ) [comment] [EOL] FAKE_PD_ARRAY = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] FAKE_LINESPACE = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_validate_input ( ) : [EOL] [docstring] [EOL] msg = [string] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] fvfi . _validate_input ( None , None , None , None , None , None , [number] ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] msg = [string] [EOL] struct_array = np . array ( [ ( [number] , [number] ) , ( [number] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , int ) ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( struct_array , None , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] msg = [string] [EOL] non_numerical_array = np . array ( [ [ [number] , [string] ] , [ [number] , [string] ] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( non_numerical_array , None , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] numerical_2d_array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] numerical_3d_array = np . array ( [ [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ] ) [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , None , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , None , None , None , None , None , True ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , struct_array , None , None , None , None , True ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , numerical_2d_array , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , non_numerical_array [ [number] ] , None , None , None , None , True ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , numerical_2d_array [ [number] , : ] , None , None , None , None , True ) [EOL] assert str ( exin . value ) == msg . format ( [number] , [number] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , numerical_2d_array [ [number] , : ] , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg . format ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , numerical_2d_array [ : , [number] ] , None , None , None , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( IndexError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , numerical_2d_array [ : , [number] ] , - [number] , None , None , None , False ) [EOL] assert str ( exin . value ) == msg . format ( - [number] , [number] ) [EOL] with pytest . raises ( IndexError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , numerical_2d_array [ : , [number] ] , [number] , None , None , None , True ) [EOL] assert str ( exin . value ) == msg . format ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , numerical_2d_array [ : , [number] ] , [number] , [number] , None , None , True ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvfi . _validate_input ( numerical_3d_array , numerical_2d_array [ : , [number] ] , [number] , None , [number] , None , False ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fvfi . _validate_input ( numerical_2d_array , numerical_2d_array [ : , [number] ] , [number] , [string] , None , [number] , True ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] assert fvfi . _validate_input ( numerical_2d_array , numerical_2d_array [ : , [number] ] , [number] , [string] , [string] , None , True ) [EOL] fig , my_plot = plt . subplots ( [number] , [number] ) [EOL] assert fvfi . _validate_input ( numerical_3d_array , numerical_2d_array [ : , [number] ] , [number] , [string] , [string] , my_plot , False ) [EOL] [EOL] [EOL] def test_prepare_a_canvas ( ) : [EOL] [docstring] [EOL] title = [string] [EOL] title_custom = [string] [EOL] class_index = [number] [EOL] x_range = [ - [number] , [number] ] [EOL] y_range = [ - [number] , [number] ] [EOL] class_name_n = None [EOL] class_name_s = [string] [EOL] feature_name_n = None [EOL] feature_name_s = [string] [EOL] [EOL] [comment] [EOL] axis = None [EOL] [comment] [EOL] figure , plot = fvfi . _prepare_a_canvas ( title , axis , class_index , class_name_s , feature_name_n , x_range ) [EOL] assert isinstance ( figure , plt . Figure ) [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( plot ) [EOL] [comment] [EOL] assert p_title == title [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , x_range ) [EOL] [comment] [EOL] assert p_x_label == [string] [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , y_range ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_name_s ) [EOL] [comment] [EOL] figure , plot = fvfi . _prepare_a_canvas ( title , axis , class_index , class_name_n , feature_name_s , x_range ) [EOL] assert isinstance ( figure , plt . Figure ) [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( plot ) [EOL] [comment] [EOL] assert p_title == title [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , x_range ) [EOL] [comment] [EOL] assert p_x_label == feature_name_s [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , y_range ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_index ) [EOL] [EOL] [comment] [EOL] fig , axis = plt . subplots ( [number] , [number] ) [EOL] [comment] [EOL] axis . set_xlim ( np . array ( [ - [number] , [number] ] ) ) [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _prepare_a_canvas ( title , axis , class_index , class_name_n , feature_name_n , x_range ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] axis . set_xlim ( np . array ( x_range ) ) [EOL] axis . set_ylim ( np . array ( [ [number] , [number] ] ) ) [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fvfi . _prepare_a_canvas ( title , axis , class_index , class_name_n , feature_name_n , x_range ) [EOL] assert str ( exin . value ) == msg [EOL] [comment] [EOL] axis . set_ylim ( np . array ( y_range ) ) [EOL] axis . set_title ( title_custom ) [EOL] [comment] [EOL] [comment] [EOL] figure , plot = fvfi . _prepare_a_canvas ( [string] , axis , class_index , class_name_s , feature_name_s , x_range ) [EOL] assert figure is None [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( plot ) [EOL] [comment] [EOL] assert p_title == title_custom [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , x_range ) [EOL] [comment] [EOL] assert p_x_label == feature_name_s [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , y_range ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_name_s ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] figure , plot = fvfi . _prepare_a_canvas ( [string] , plot , class_index , class_name_n , feature_name_n , x_range ) [EOL] assert figure is None [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( plot ) [EOL] [comment] [EOL] assert p_title == title_custom [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , x_range ) [EOL] [comment] [EOL] assert p_x_label == feature_name_s [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , y_range ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_name_s ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] axis . set_ylabel ( None ) [EOL] axis . set_xlabel ( None ) [EOL] figure , plot = fvfi . _prepare_a_canvas ( [string] , axis , class_index , class_name_n , feature_name_n , x_range ) [EOL] assert figure is None [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( plot ) [EOL] [comment] [EOL] assert p_title == [string] . format ( title_custom ) [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , x_range ) [EOL] [comment] [EOL] assert p_x_label == [string] [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , y_range ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_index ) [EOL] [EOL] [EOL] def test_plot_individual_conditional_expectation ( ) : [EOL] [docstring] [EOL] feature_name = [string] [EOL] class_index = [number] [EOL] class_name = [string] [EOL] [EOL] figure , axis = fvfi . plot_individual_conditional_expectation ( FAKE_ICE_ARRAY , FAKE_LINESPACE , class_index , feature_name , class_name ) [EOL] [EOL] assert isinstance ( figure , plt . Figure ) [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( axis ) [EOL] [comment] [EOL] assert p_title == [string] [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , [ FAKE_LINESPACE [ [number] ] , FAKE_LINESPACE [ - [number] ] ] ) [EOL] [comment] [EOL] assert p_x_label == feature_name [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , [ - [number] , [number] ] ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_name ) [EOL] [EOL] [comment] [EOL] assert len ( axis . collections ) == [number] [EOL] l_data , l_colour , l_alpha , l_label , l_width = futv . get_line_data ( axis . collections [ [number] ] , is_collection = True ) [EOL] assert len ( l_data ) == FAKE_ICE_ARRAY . shape [ [number] ] [EOL] for i , line_array in enumerate ( l_data ) : [EOL] line_data = np . stack ( [ FAKE_LINESPACE , FAKE_ICE_ARRAY [ i , : , class_index ] ] , axis = [number] ) [EOL] assert np . array_equal ( line_array , line_data ) [EOL] assert np . isclose ( l_colour , np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) , atol = [number] ) . all ( ) [comment] [EOL] assert l_alpha == [number] [EOL] assert l_label == [string] [EOL] assert l_width == [number] [EOL] [EOL] [comment] [EOL] legend = [ i for i in axis . get_children ( ) if isinstance ( i , matplotlib . legend . Legend ) ] [EOL] assert len ( legend ) == [number] [EOL] legend_texts = legend [ [number] ] . get_texts ( ) [EOL] assert len ( legend_texts ) == [number] [EOL] assert legend_texts [ [number] ] . get_text ( ) == [string] [EOL] [EOL] [EOL] def test_plot_partial_dependence ( ) : [EOL] [docstring] [EOL] feature_name = [string] [EOL] class_index = [number] [EOL] class_name = [string] [EOL] [EOL] figure , axis = fvfi . plot_partial_dependence ( FAKE_PD_ARRAY , FAKE_LINESPACE , class_index , feature_name , class_name ) [EOL] [EOL] assert isinstance ( figure , plt . Figure ) [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( axis ) [EOL] [comment] [EOL] assert p_title == [string] [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , [ FAKE_LINESPACE [ [number] ] , FAKE_LINESPACE [ - [number] ] ] ) [EOL] [comment] [EOL] assert p_x_label == feature_name [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , [ - [number] , [number] ] ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( class_name ) [EOL] [EOL] [comment] [EOL] assert len ( axis . lines ) == [number] [EOL] l_data , l_colour , l_alpha , l_label , l_width = futv . get_line_data ( axis . lines [ [number] ] ) [EOL] line_data = np . stack ( [ FAKE_LINESPACE , FAKE_PD_ARRAY [ : , class_index ] ] , axis = [number] ) [EOL] assert np . array_equal ( l_data , line_data ) [EOL] assert l_colour == [string] [EOL] assert l_alpha == [number] [EOL] assert l_label == [string] [EOL] assert l_width == [number] [EOL] [EOL] [comment] [EOL] legend = [ i for i in axis . get_children ( ) if isinstance ( i , matplotlib . legend . Legend ) ] [EOL] assert len ( legend ) == [number] [EOL] legend_texts = legend [ [number] ] . get_texts ( ) [EOL] assert len ( legend_texts ) == [number] [EOL] assert legend_texts [ [number] ] . get_text ( ) == [string] [EOL] [EOL] [EOL] def test_ice_pd_overlay ( ) : [EOL] [docstring] [EOL] f_name = [string] [EOL] c_index = [number] [EOL] c_name = [string] [EOL] [EOL] figure , axis = fvfi . plot_individual_conditional_expectation ( FAKE_ICE_ARRAY , FAKE_LINESPACE , c_index , f_name , c_name ) [EOL] assert isinstance ( figure , plt . Figure ) [EOL] assert isinstance ( axis , plt . Axes ) [EOL] [EOL] none , axis = fvfi . plot_partial_dependence ( FAKE_PD_ARRAY , FAKE_LINESPACE , c_index , f_name , c_name , axis ) [EOL] assert none is None [EOL] assert isinstance ( axis , plt . Axes ) [EOL] [EOL] [comment] [EOL] p_title , p_x_label , p_x_range , p_y_label , p_y_range = futv . get_plot_data ( axis ) [EOL] [comment] [EOL] assert p_title == ( [string] [string] ) [EOL] [comment] [EOL] assert np . array_equal ( p_x_range , [ FAKE_LINESPACE [ [number] ] , FAKE_LINESPACE [ - [number] ] ] ) [EOL] [comment] [EOL] assert p_x_label == f_name [EOL] [comment] [EOL] assert np . array_equal ( p_y_range , [ - [number] , [number] ] ) [EOL] [comment] [EOL] assert p_y_label == [string] . format ( c_name ) [EOL] [EOL] [comment] [EOL] assert len ( axis . collections ) == [number] [EOL] l_data , l_colour , l_alpha , l_label , l_width = futv . get_line_data ( axis . collections [ [number] ] , is_collection = True ) [EOL] assert len ( l_data ) == FAKE_ICE_ARRAY . shape [ [number] ] [EOL] for i , line_array in enumerate ( l_data ) : [EOL] line_data = np . stack ( [ FAKE_LINESPACE , FAKE_ICE_ARRAY [ i , : , c_index ] ] , axis = [number] ) [EOL] assert np . array_equal ( line_array , line_data ) [EOL] assert np . isclose ( l_colour , np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) , atol = [number] ) . all ( ) [comment] [EOL] assert l_alpha == [number] [EOL] assert l_label == [string] [EOL] assert l_width == [number] [EOL] [EOL] [comment] [EOL] assert len ( axis . lines ) == [number] [EOL] l_data , l_colour , l_alpha , l_label , l_width = futv . get_line_data ( axis . lines [ [number] ] ) [EOL] line_data = np . stack ( [ FAKE_LINESPACE , FAKE_PD_ARRAY [ : , c_index ] ] , axis = [number] ) [EOL] assert np . array_equal ( l_data , line_data ) [EOL] assert l_colour == [string] [EOL] assert l_alpha == [number] [EOL] assert l_label == [string] [EOL] assert l_width == [number] [EOL] [EOL] [comment] [EOL] legend = [ i for i in axis . get_children ( ) if isinstance ( i , matplotlib . legend . Legend ) ] [EOL] assert len ( legend ) == [number] [EOL] legend_texts = legend [ [number] ] . get_texts ( ) [EOL] assert len ( legend_texts ) == [number] [EOL] assert legend_texts [ [number] ] . get_text ( ) == [string] [EOL] assert legend_texts [ [number] ] . get_text ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List , Tuple [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . transparency . models . feature_influence as ftmfi [EOL] import fatf . utils . models as fum [EOL] [EOL] from fatf . exceptions import IncompatibleModelError , IncorrectShapeError [EOL] from fatf . utils . testing . arrays import ( BASE_NP_ARRAY , BASE_STRUCTURED_ARRAY , NOT_BASE_NP_ARRAY ) [EOL] [EOL] [comment] [EOL] ONE_D_ARRAY = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] NUMERICAL_NP_ARRAY_TARGET = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] NUMERICAL_NP_ARRAY = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_ARRAY = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] [EOL] NUMERICAL_NP_ARRAY_TEST_INT = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_NP_ARRAY_TEST = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_STRUCT_ARRAY_TEST = np . array ( [ ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] NUMERICAL_NP_ICE = np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) [EOL] NUMERICAL_NP_PD = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_NP_ICE_CAT = np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) [EOL] NUMERICAL_NP_PD_CAT = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_NP_ICE_100 = np . array ( [ [number] * [ [ [number] , [number] , [number] ] ] , [number] * [ [ [number] , [number] , [number] ] ] + [number] * [ [ [number] , [number] , [number] ] ] ] ) [EOL] NUMERICAL_NP_PD_100 = np . array ( [number] * [ [ [number] , [number] , [number] ] ] + [number] * [ [ [number] , [number] , [number] ] ] ) [EOL] NUMERICAL_NP_LINESPACE = np . array ( [ [number] , [number] , [number] ] ) [EOL] NUMERICAL_NP_LINESPACE_CAT = np . array ( [ [number] , [number] ] ) [EOL] NUMERICAL_NP_LINESPACE_100 = np . linspace ( [number] , [number] , [number] ) [EOL] [EOL] CATEGORICAL_NP_ARRAY_TEST = np . array ( [ [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ] ) [EOL] CATEGORICAL_STRUCT_ARRAY_TEST = np . array ( [ ( [string] , [string] , [string] ) , ( [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] CATEGORICAL_NP_ARRAY_TARGET = np . array ( [ [number] , [number] , [number] ] ) [EOL] CATEGORICAL_NP_ICE = np . array ( [ [ [ [number] , [number] ] , [ [number] , [number] ] ] , [ [ [number] , [number] ] , [ [number] , [number] ] ] ] ) [EOL] CATEGORICAL_NP_PD = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] CATEGORICAL_NP_LINESPACE = np . array ( [ [string] , [string] ] ) [EOL] [EOL] MIXED_ARRAY_TEST = np . array ( [ ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) , ( [number] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] MIXED_ARRAY_TARGET = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] MIXED_ICE_NUMERICAL = np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) [EOL] MIXED_PD_NUMERICAL = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] MIXED_LINESPACE_NUMERICAL = np . array ( [ [number] , [number] , [number] ] ) [EOL] MIXED_ICE_CATEGORICAL = np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) [EOL] MIXED_PD_CATEGORICAL = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] MIXED_LINESPACE_CATEGORICAL = np . array ( [ [string] , [string] ] ) [EOL] [comment] [EOL] [EOL] [EOL] class InvalidModel ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def fit ( self , X , y ) : [EOL] [docstring] [EOL] return X , y [comment] [EOL] [EOL] def predict ( self , X ) : [EOL] [docstring] [EOL] return X [comment] [EOL] [EOL] [EOL] def test_is_valid_input ( ) : [EOL] [docstring] [EOL] knn_model = fum . KNN ( ) [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftmfi . _input_is_valid ( ONE_D_ARRAY , None , None , None , None ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] msg = ( [string] [string] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _input_is_valid ( NOT_BASE_NP_ARRAY , None , None , None , None ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = ( [string] [string] ) [EOL] model = InvalidModel ( ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_STRUCTURED_ARRAY , model , None , None , None ) [EOL] assert str ( exin . value ) == msg [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == ( [string] [string] ) [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_STRUCTURED_ARRAY , knn_model , [number] , None , None ) [EOL] assert str ( exin . value ) == msg [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [string] , None , None ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , None , [string] ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] msg = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , None , [number] ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] msg = [string] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , [string] , None ) [EOL] assert str ( exin . value ) == msg [EOL] [EOL] [comment] [EOL] assert ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , None , [number] ) [EOL] assert ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , False , [number] ) [EOL] [comment] [EOL] assert ftmfi . _input_is_valid ( BASE_NP_ARRAY , knn_model , [number] , True , [number] ) [EOL] [EOL] [EOL] def test_interpolate_array ( ) : [EOL] [docstring] [EOL] [comment] [EOL] feature_index_num = [number] [EOL] feature_index_cat = [string] [EOL] [comment] [EOL] num_1_min = [number] [EOL] num_1_max = [number] [EOL] num_1_unique = np . array ( [ num_1_min , num_1_max ] ) [EOL] cat_1_unique = np . array ( [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] sar1 = NUMERICAL_NP_ARRAY . copy ( ) [EOL] sar1 [ : , feature_index_num ] = num_1_min [EOL] sar2 = NUMERICAL_NP_ARRAY . copy ( ) [EOL] sar2 [ : , feature_index_num ] = num_1_max [EOL] num_1_data_unique = np . stack ( [ sar1 , sar2 ] , axis = [number] ) [EOL] [comment] [EOL] num_1_interpolate_3 = np . array ( [ num_1_min , [number] , num_1_max ] ) [EOL] [comment] [EOL] sar = [ ] [EOL] for i in num_1_interpolate_3 : [EOL] sar_i = NUMERICAL_NP_ARRAY . copy ( ) [EOL] sar_i [ : , feature_index_num ] = i [EOL] sar . append ( sar_i ) [EOL] num_1_data_interpolate_3 = np . stack ( sar , axis = [number] ) [EOL] [comment] [EOL] sar = [ ] [EOL] for i in cat_1_unique : [EOL] sar_i = CATEGORICAL_NP_ARRAY . copy ( ) [EOL] sar_i [ : , feature_index_num ] = i [EOL] sar . append ( sar_i ) [EOL] cat_1_interpolate = np . stack ( sar , axis = [number] ) [EOL] [comment] [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( NUMERICAL_NP_ARRAY , feature_index_num , True , None ) [EOL] assert np . array_equal ( interpolated_data , num_1_data_unique ) [EOL] assert np . array_equal ( interpolated_values , num_1_unique ) [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( NUMERICAL_NP_ARRAY , feature_index_num , True , [number] ) [EOL] assert np . array_equal ( interpolated_data , num_1_data_unique ) [EOL] assert np . array_equal ( interpolated_values , num_1_unique ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( NUMERICAL_STRUCT_ARRAY , feature_index_cat , False , [number] ) [EOL] for index , column in enumerate ( NUMERICAL_STRUCT_ARRAY . dtype . names ) : [EOL] assert np . allclose ( interpolated_data [ : , : ] [ column ] , num_1_data_interpolate_3 [ : , : , index ] ) [EOL] assert np . array_equal ( interpolated_values , num_1_interpolate_3 ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( CATEGORICAL_NP_ARRAY , feature_index_num , True , None ) [EOL] assert np . array_equal ( interpolated_data , cat_1_interpolate ) [EOL] assert np . array_equal ( interpolated_values , cat_1_unique ) [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( CATEGORICAL_STRUCT_ARRAY , feature_index_cat , True , [number] ) [EOL] for index , column in enumerate ( CATEGORICAL_STRUCT_ARRAY . dtype . names ) : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , cat_1_interpolate [ : , : , index ] ) [EOL] assert np . array_equal ( interpolated_values , cat_1_unique ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL] [comment] [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] numerical_column = [string] [EOL] numreical_linespace_cat = np . array ( [ [number] , [number] ] ) [EOL] sar = [ ] [EOL] for i in numreical_linespace_cat : [EOL] sar_i = MIXED_ARRAY . copy ( ) [EOL] sar_i [ numerical_column ] = i [EOL] sar . append ( sar_i ) [EOL] numerical_interpolation_cat = np . stack ( sar , axis = [number] ) [EOL] [comment] [EOL] numreical_linespace_num = np . array ( [ [number] , [number] , [number] ] ) [EOL] sar = [ ] [EOL] for i in numreical_linespace_num : [EOL] [comment] [EOL] dtype = [ ( name , numreical_linespace_num . dtype ) [EOL] if name == numerical_column [EOL] else ( name , MIXED_ARRAY . dtype [ name ] ) for name in MIXED_ARRAY . dtype . names ] [comment] [EOL] sar_i = MIXED_ARRAY . astype ( dtype ) [EOL] [EOL] sar_i [ numerical_column ] = i [EOL] sar . append ( sar_i ) [EOL] numerical_interpolation_num = np . stack ( sar , axis = [number] ) [EOL] [EOL] categorical_column = [string] [EOL] categorical_linespace = np . array ( [ [string] , [string] , [string] ] ) [EOL] sar = [ ] [EOL] for i in categorical_linespace : [EOL] sar_i = MIXED_ARRAY . copy ( ) [EOL] sar_i [ categorical_column ] = i [EOL] sar . append ( sar_i ) [EOL] categorical_interpolation = np . stack ( sar , axis = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( MIXED_ARRAY , categorical_column , True , None ) [EOL] assert np . array_equal ( interpolated_values , categorical_linespace ) [EOL] for column in MIXED_ARRAY . dtype . names : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , categorical_interpolation [ : , : ] [ column ] ) [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( MIXED_ARRAY , categorical_column , True , [number] ) [EOL] assert np . array_equal ( interpolated_values , categorical_linespace ) [EOL] for column in MIXED_ARRAY . dtype . names : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , categorical_interpolation [ : , : ] [ column ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( MIXED_ARRAY , numerical_column , True , None ) [EOL] assert np . array_equal ( interpolated_values , numreical_linespace_cat ) [EOL] for column in MIXED_ARRAY . dtype . names : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , numerical_interpolation_cat [ : , : ] [ column ] ) [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( MIXED_ARRAY , numerical_column , True , [number] ) [EOL] assert np . array_equal ( interpolated_values , numreical_linespace_cat ) [EOL] for column in MIXED_ARRAY . dtype . names : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , numerical_interpolation_cat [ : , : ] [ column ] ) [EOL] [comment] [EOL] [comment] [EOL] interpolated_data , interpolated_values = ftmfi . _interpolate_array ( MIXED_ARRAY , numerical_column , False , [number] ) [EOL] assert np . array_equal ( interpolated_values , numreical_linespace_num ) [EOL] for column in MIXED_ARRAY . dtype . names : [EOL] assert np . array_equal ( interpolated_data [ : , : ] [ column ] , numerical_interpolation_num [ : , : ] [ column ] ) [EOL] [EOL] [EOL] def test_filter_rows ( ) : [EOL] [docstring] [EOL] value_error = ( [string] [string] ) [EOL] type_error_include = ( [string] [string] [string] ) [EOL] type_error_include_list = [string] [EOL] type_error_exclude = ( [string] [string] [string] ) [EOL] type_error_exclude_list = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _filter_rows ( [string] , None , [number] ) [EOL] assert str ( exin . value ) == type_error_include [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _filter_rows ( [ [number] , [number] , [string] , [number] , [number] ] , None , [number] ) [EOL] assert str ( exin . value ) == type_error_include_list . format ( [string] ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _filter_rows ( None , [string] , [number] ) [EOL] assert str ( exin . value ) == type_error_exclude [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . _filter_rows ( None , [ [number] , [number] , [string] , [number] , [number] ] , [number] ) [EOL] assert str ( exin . value ) == type_error_exclude_list . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _filter_rows ( None , [ [number] , [number] , [number] , [number] ] , [number] ) [EOL] assert str ( exin . value ) == value_error . format ( [string] , [number] , [number] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _filter_rows ( None , [number] , [number] ) [EOL] assert str ( exin . value ) == value_error . format ( [string] , [number] , [number] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _filter_rows ( [ [number] , [number] , [number] , [number] ] , None , [number] ) [EOL] assert str ( exin . value ) == value_error . format ( [string] , [number] , [number] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . _filter_rows ( [number] , None , [number] ) [EOL] assert str ( exin . value ) == value_error . format ( [string] , [number] , [number] ) [EOL] [EOL] row_number = [number] [EOL] row_none = None [EOL] row_digit = [number] [EOL] row_list = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] all_rows = list ( range ( [number] ) ) [EOL] all_but_one = [ [number] , [number] , [number] ] + list ( range ( [number] , [number] ) ) [EOL] all_but_list = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] row_but_one = [ [number] , [number] , [number] ] [EOL] three = [ [number] ] [EOL] empty = [ ] [EOL] [EOL] rows = ftmfi . _filter_rows ( row_none , row_none , row_number ) [EOL] assert np . array_equal ( rows , all_rows ) [EOL] rows = ftmfi . _filter_rows ( row_none , row_digit , row_number ) [EOL] assert np . array_equal ( rows , all_but_one ) [EOL] rows = ftmfi . _filter_rows ( row_none , row_list , row_number ) [EOL] assert np . array_equal ( rows , all_but_list ) [EOL] rows = ftmfi . _filter_rows ( row_none , empty , row_number ) [EOL] assert np . array_equal ( rows , all_rows ) [EOL] rows = ftmfi . _filter_rows ( empty , row_none , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] [EOL] rows = ftmfi . _filter_rows ( row_digit , row_none , row_number ) [EOL] assert np . array_equal ( rows , three ) [EOL] rows = ftmfi . _filter_rows ( row_digit , row_digit , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] rows = ftmfi . _filter_rows ( row_digit , row_list , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] rows = ftmfi . _filter_rows ( row_digit , empty , row_number ) [EOL] assert np . array_equal ( rows , three ) [EOL] rows = ftmfi . _filter_rows ( empty , row_digit , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] [EOL] rows = ftmfi . _filter_rows ( row_list , row_none , row_number ) [EOL] assert np . array_equal ( rows , row_list ) [EOL] rows = ftmfi . _filter_rows ( row_list , row_digit , row_number ) [EOL] assert np . array_equal ( rows , row_but_one ) [EOL] rows = ftmfi . _filter_rows ( row_list , row_list , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] rows = ftmfi . _filter_rows ( row_list , empty , row_number ) [EOL] assert np . array_equal ( rows , row_list ) [EOL] rows = ftmfi . _filter_rows ( empty , row_list , row_number ) [EOL] assert np . array_equal ( rows , empty ) [EOL] [EOL] [EOL] def test_merge_ice_arrays ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] ) [EOL] value_error_empty = [string] [EOL] value_error_numerical = ( [string] [string] ) [EOL] value_error_struct = ( [string] [string] ) [EOL] incorrect_shape_3d = [string] [EOL] value_error_shape = ( [string] [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [string] ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ ] ) [EOL] assert str ( exin . value ) == value_error_empty [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ np . array ( [ [number] , [number] , [string] , [number] , [number] ] ) ] ) [EOL] assert str ( exin . value ) == value_error_numerical [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ np . array ( [ [ [ [number] ] ] ] ) , np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , int ) ] ) ] ) [EOL] assert str ( exin . value ) == value_error_struct [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ np . array ( [ [ [ [number] ] ] ] ) , np . array ( [ [number] ] ) ] ) [EOL] assert str ( exin . value ) == incorrect_shape_3d [EOL] [EOL] arr_1 = np . array ( [ [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ] ) [EOL] arr_2 = np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) [EOL] arr_3 = np . array ( [ [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ] ) [EOL] arr_4 = np . array ( [ [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ] , dtype = float ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ arr_1 , arr_1 , arr_2 ] ) [EOL] assert str ( exin . value ) == value_error_shape [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ arr_1 , arr_3 , arr_2 ] ) [EOL] assert str ( exin . value ) == value_error_shape [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . merge_ice_arrays ( [ arr_3 , arr_3 , arr_4 ] ) [EOL] assert str ( exin . value ) == value_error_shape [EOL] [EOL] [comment] [EOL] selected_column_index = [number] [EOL] smaller_numerical_array = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [comment] [EOL] concat = np . concatenate ( [ NUMERICAL_NP_ARRAY , smaller_numerical_array ] ) [EOL] arr_a = [ ] [EOL] arr_b = [ ] [EOL] arr_c = [ ] [EOL] for i in range ( [number] ) : [EOL] arr_i = NUMERICAL_NP_ARRAY . copy ( ) [EOL] arr_i [ : , selected_column_index ] = i [EOL] arr_a . append ( arr_i ) [EOL] [EOL] arr_i = smaller_numerical_array . copy ( ) [EOL] arr_i [ : , selected_column_index ] = i [EOL] arr_b . append ( arr_i ) [EOL] [EOL] arr_i = concat . copy ( ) [EOL] arr_i [ : , selected_column_index ] = i [EOL] arr_c . append ( arr_i ) [EOL] unstructured_array_a = np . stack ( arr_a , axis = [number] ) [EOL] unstructured_array_b = np . stack ( arr_b , axis = [number] ) [EOL] unstructured_array_c = np . stack ( arr_c , axis = [number] ) [EOL] [EOL] comp = ftmfi . merge_ice_arrays ( [ unstructured_array_a , unstructured_array_b ] ) [EOL] assert np . array_equal ( comp , unstructured_array_c ) [EOL] [EOL] [EOL] def test_individual_conditional_expectation ( ) : [EOL] [docstring] [EOL] user_warning = ( [string] [string] [string] [string] ) [EOL] steps_n_warning = ( [string] [string] ) [EOL] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] clf_struct = fum . KNN ( k = [number] ) [EOL] clf_struct . fit ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_NP_ARRAY_TEST_INT , clf , [number] , treat_as_categorical = False , steps_number = [number] ) [EOL] assert np . allclose ( ice , np . array ( [ [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ] ) ) [EOL] assert np . allclose ( linespace , np . array ( [ [number] , [number] , [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = False , steps_number = [number] ) [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE ) [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = False ) [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE_100 ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_100 ) [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = True , steps_number = [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == steps_n_warning [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE_CAT ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_CAT ) [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = True ) [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE_CAT ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_CAT ) [EOL] [comment] [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_NP_ARRAY_TEST , clf , [number] , steps_number = [number] ) [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE ) [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( NUMERICAL_NP_ARRAY_TEST , clf , [number] ) [EOL] assert np . allclose ( ice , NUMERICAL_NP_ICE_100 ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_100 ) [EOL] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( CATEGORICAL_NP_ARRAY , CATEGORICAL_NP_ARRAY_TARGET ) [EOL] clf_struct = fum . KNN ( k = [number] ) [EOL] clf_struct . fit ( CATEGORICAL_STRUCT_ARRAY , CATEGORICAL_NP_ARRAY_TARGET ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = False , steps_number = [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = False ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = True , steps_number = [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == steps_n_warning [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = True ) [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_NP_ARRAY_TEST , clf , [number] , steps_number = [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == steps_n_warning [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [comment] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( CATEGORICAL_STRUCT_ARRAY_TEST , clf_struct , [string] ) [EOL] assert np . allclose ( ice , CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [EOL] [comment] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( MIXED_ARRAY , MIXED_ARRAY_TARGET ) [EOL] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( MIXED_ARRAY_TEST , clf , [string] , steps_number = [number] , exclude_rows = [number] ) [EOL] assert np . allclose ( ice , MIXED_ICE_NUMERICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_NUMERICAL ) [EOL] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( MIXED_ARRAY_TEST , clf , [string] , steps_number = [number] , include_rows = [ [number] , [number] ] , exclude_rows = [ [number] ] ) [EOL] assert np . allclose ( ice , MIXED_ICE_NUMERICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_NUMERICAL ) [EOL] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( MIXED_ARRAY_TEST , clf , [string] , steps_number = [number] , include_rows = [ [number] , [number] ] , exclude_rows = [number] ) [EOL] assert np . allclose ( ice , MIXED_ICE_NUMERICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_NUMERICAL ) [EOL] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( MIXED_ARRAY_TEST , clf , [string] , exclude_rows = [number] ) [EOL] assert np . allclose ( ice , MIXED_ICE_CATEGORICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_CATEGORICAL ) [EOL] [EOL] ice , linespace = ftmfi . individual_conditional_expectation ( MIXED_ARRAY_TEST , clf , [string] , include_rows = [ [number] , [number] ] , exclude_rows = [number] ) [EOL] assert np . allclose ( ice , MIXED_ICE_CATEGORICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_CATEGORICAL ) [EOL] [EOL] [EOL] def test_partial_dependence_ice ( ) : [EOL] [docstring] [EOL] value_error_structured = [string] [EOL] value_error_not_numerical = [string] [EOL] incorrect_shape_error = [string] [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . partial_dependence_ice ( np . array ( [ ( [number] , ) ] , dtype = [ ( [string] , int ) ] ) ) [EOL] assert str ( exin . value ) == value_error_structured [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftmfi . partial_dependence_ice ( np . array ( [ [ [number] , [string] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == value_error_not_numerical [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftmfi . partial_dependence_ice ( ONE_D_ARRAY ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] [EOL] [comment] [EOL] pd = ftmfi . partial_dependence_ice ( NUMERICAL_NP_ICE ) [EOL] assert np . array_equal ( pd , NUMERICAL_NP_PD ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( NUMERICAL_NP_ICE_CAT ) [EOL] assert np . array_equal ( pd , NUMERICAL_NP_PD_CAT ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( NUMERICAL_NP_ICE_100 ) [EOL] assert np . array_equal ( pd , NUMERICAL_NP_PD_100 ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( CATEGORICAL_NP_ICE ) [EOL] assert np . array_equal ( pd , CATEGORICAL_NP_PD ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_NUMERICAL ) [EOL] assert np . array_equal ( pd , MIXED_PD_NUMERICAL ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL ) [EOL] assert np . array_equal ( pd , MIXED_PD_CATEGORICAL ) [EOL] [EOL] [comment] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL , include_rows = [number] ) [EOL] assert np . array_equal ( pd , MIXED_ICE_CATEGORICAL [ [number] ] ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL , include_rows = [ [number] ] ) [EOL] assert np . array_equal ( pd , MIXED_ICE_CATEGORICAL [ [number] ] ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL , exclude_rows = [number] ) [EOL] assert np . array_equal ( pd , MIXED_ICE_CATEGORICAL [ [number] ] ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL , exclude_rows = [ [number] ] ) [EOL] assert np . array_equal ( pd , MIXED_ICE_CATEGORICAL [ [number] ] ) [EOL] [EOL] pd = ftmfi . partial_dependence_ice ( MIXED_ICE_CATEGORICAL , include_rows = [ [number] , [number] ] , exclude_rows = [ [number] ] ) [EOL] assert np . array_equal ( pd , MIXED_ICE_CATEGORICAL [ [number] ] ) [EOL] [EOL] [EOL] def test_partial_dependence ( ) : [EOL] [docstring] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( NUMERICAL_NP_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] clf_struct = fum . KNN ( k = [number] ) [EOL] clf_struct . fit ( NUMERICAL_STRUCT_ARRAY , NUMERICAL_NP_ARRAY_TARGET ) [EOL] [EOL] [comment] [EOL] pd , linespace = ftmfi . partial_dependence ( NUMERICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = False , steps_number = [number] ) [EOL] assert np . allclose ( pd , NUMERICAL_NP_PD ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( NUMERICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = False ) [EOL] assert np . allclose ( pd , NUMERICAL_NP_PD_100 ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_100 ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( NUMERICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = True ) [EOL] assert np . allclose ( pd , NUMERICAL_NP_PD_CAT ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_CAT ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( NUMERICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = True ) [EOL] assert np . allclose ( pd , NUMERICAL_NP_PD_CAT ) [EOL] assert np . allclose ( linespace , NUMERICAL_NP_LINESPACE_CAT ) [EOL] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( CATEGORICAL_NP_ARRAY , CATEGORICAL_NP_ARRAY_TARGET ) [EOL] clf_struct = fum . KNN ( k = [number] ) [EOL] clf_struct . fit ( CATEGORICAL_STRUCT_ARRAY , CATEGORICAL_NP_ARRAY_TARGET ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( CATEGORICAL_NP_ARRAY_TEST , clf , [number] , treat_as_categorical = True ) [EOL] assert np . allclose ( pd , CATEGORICAL_NP_PD ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( CATEGORICAL_STRUCT_ARRAY_TEST , clf_struct , [string] , treat_as_categorical = True ) [EOL] assert np . allclose ( pd , CATEGORICAL_NP_PD ) [EOL] assert np . array_equal ( linespace , CATEGORICAL_NP_LINESPACE ) [EOL] [EOL] [comment] [EOL] clf = fum . KNN ( k = [number] ) [EOL] clf . fit ( MIXED_ARRAY , MIXED_ARRAY_TARGET ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( MIXED_ARRAY_TEST , clf , [string] , steps_number = [number] , include_rows = [ [number] , [number] ] , exclude_rows = [number] ) [EOL] assert np . allclose ( pd , MIXED_PD_NUMERICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_NUMERICAL ) [EOL] [EOL] pd , linespace = ftmfi . partial_dependence ( MIXED_ARRAY_TEST , clf , [string] , exclude_rows = [number] ) [EOL] assert np . allclose ( pd , MIXED_PD_CATEGORICAL ) [EOL] assert np . array_equal ( linespace , MIXED_LINESPACE_CATEGORICAL ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List , Optional , Union [EOL] import typing [EOL] import numpy [EOL] import sklearn [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import abc [EOL] import logging [EOL] import warnings [EOL] [EOL] from typing import List , Optional , Union [EOL] [EOL] import sklearn [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . validation as fuav [EOL] import fatf . utils . transparency . explainers as fute [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [comment] [EOL] [EOL] [EOL] def is_sklearn_model ( clf ) : [EOL] [docstring] [EOL] if isinstance ( clf , type ) : [comment] [EOL] is_valid_model = issubclass ( clf , sklearn . base . BaseEstimator ) [EOL] else : [comment] [EOL] is_valid_model = isinstance ( clf , sklearn . base . BaseEstimator ) [EOL] return is_valid_model [EOL] [EOL] [EOL] def is_sklearn_model_instance ( clf ) : [EOL] [docstring] [EOL] is_valid_model_instance = ( not isinstance ( clf , type ) [EOL] and is_sklearn_model ( clf ) ) [EOL] return is_valid_model_instance [EOL] [EOL] [EOL] def _validate_input ( clf , feature_names , class_names ) : [EOL] [docstring] [EOL] [comment] [EOL] is_valid = False [EOL] [EOL] if not is_sklearn_model_instance ( clf ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] if feature_names is not None : [EOL] if isinstance ( feature_names , list ) : [EOL] if not feature_names : [EOL] raise ValueError ( [string] ) [EOL] for feature_name in feature_names : [EOL] if not isinstance ( feature_name , str ) : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] if class_names is not None : [EOL] if isinstance ( class_names , list ) : [EOL] if not class_names : [EOL] raise ValueError ( [string] ) [EOL] for class_name in class_names : [EOL] if not isinstance ( class_name , str ) : [EOL] raise TypeError ( [string] [string] ) [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] is_valid = True [EOL] return is_valid [EOL] [EOL] [EOL] class SKLearnExplainer ( fute . Explainer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , clf , feature_names = None , class_names = None ) : [EOL] [docstring] [EOL] [comment] [EOL] assert _validate_input ( clf , feature_names , class_names ) , [string] [EOL] self . clf = clf [EOL] self . feature_names = feature_names [EOL] self . class_names = class_names [EOL] [EOL] [comment] [EOL] assert self . _validate_kind_fitted ( ) , [string] [EOL] [EOL] [comment] [EOL] self . is_classifier = self . _is_classifier ( ) [EOL] assert isinstance ( self . is_classifier , bool ) , [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . features_number = self . _get_features_number ( ) [EOL] if self . features_number is not None : [EOL] assert isinstance ( self . features_number , int ) , [string] [EOL] [EOL] [comment] [EOL] self . classes_array = self . _get_classes_array ( ) [EOL] if self . classes_array is not None : [EOL] assert isinstance ( self . classes_array , np . ndarray ) , [string] [EOL] if self . classes_array is not None : [EOL] assert fuav . is_1d_array ( self . classes_array ) , [string] [EOL] assert ( fuav . is_numerical_array ( self . classes_array ) or fuav . is_textual_array ( self . classes_array ) ) , [string] [EOL] [EOL] [comment] [EOL] if not self . is_classifier : [EOL] assert self . classes_array is None and self . class_names is None , [string] [EOL] [EOL] [comment] [EOL] if self . feature_names is None : [EOL] if self . features_number is not None : [EOL] logger . info ( [string] [string] ) [EOL] self . feature_names = [ [string] . format ( i ) for i in range ( self . features_number ) ] [EOL] else : [EOL] if self . features_number is None : [EOL] warnings . warn ( [string] [string] [string] , UserWarning ) [EOL] else : [EOL] if len ( self . feature_names ) != self . features_number : [EOL] raise ValueError ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] if self . class_names is None : [EOL] if self . classes_array is not None : [EOL] logger . info ( [string] [string] [string] ) [EOL] self . class_names = [ [string] . format ( i ) for i in self . classes_array ] [EOL] else : [EOL] if self . classes_array is None : [EOL] warnings . warn ( [string] [string] , UserWarning ) [EOL] else : [EOL] if self . classes_array . shape [ [number] ] != len ( self . class_names ) : [EOL] raise ValueError ( [string] [string] [string] [string] ) [EOL] [EOL] def map_class ( self , clf_class ) : [EOL] [docstring] [EOL] if not self . is_classifier : [EOL] raise RuntimeError ( [string] [string] ) [EOL] [EOL] if not isinstance ( clf_class , ( str , int ) ) : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] if self . class_names is None or self . classes_array is None : [EOL] raise RuntimeError ( [string] [string] ) [EOL] if clf_class not in self . classes_array : [EOL] possible_classes = self . classes_array . tolist ( ) [EOL] raise ValueError ( [string] [string] [string] . format ( possible_classes ) ) [EOL] [EOL] class_index = np . where ( self . classes_array == clf_class ) [ [number] ] [EOL] assert len ( class_index . shape ) == [number] , [string] [EOL] assert class_index . shape [ [number] ] == [number] , [string] [EOL] [EOL] mapped_class = self . class_names [ class_index [ [number] ] ] [EOL] return mapped_class [EOL] [EOL] @ abc . abstractmethod def _validate_kind_fitted ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [comment] [EOL] is_valid = False [EOL] return is_valid [EOL] [EOL] @ abc . abstractmethod def _is_classifier ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [comment] [EOL] is_classifier = False [EOL] return is_classifier [EOL] [EOL] @ abc . abstractmethod def _get_features_number ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [comment] [EOL] features_number = None [EOL] return features_number [EOL] [EOL] @ abc . abstractmethod def _get_classes_array ( self ) : [comment] [EOL] [docstring] [EOL] raise NotImplementedError ( [string] ) [EOL] [comment] [EOL] classes_array = None [EOL] return classes_array [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[numpy.ndarray,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union , Tuple [EOL] import sklearn [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union [EOL] [EOL] import sklearn . linear_model [EOL] import sklearn . utils . validation [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . transparency . sklearn . tools as ftst [EOL] import fatf . utils . tools as fut [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL] [EOL] _SKLEARN_VERSION = [ int ( i ) for i in sklearn . __version__ . split ( [string] ) [ : [number] ] ] [EOL] _SKLEARN_0_22 = fut . at_least_verion ( [ [number] , [number] ] , _SKLEARN_VERSION ) [EOL] [EOL] if _SKLEARN_0_22 : [comment] [EOL] [comment] [EOL] _linear_base = sklearn . linear_model . _base [EOL] _linear_coordinate_descent = sklearn . linear_model . _coordinate_descent [EOL] _lienar_stochastic_gradient = sklearn . linear_model . _stochastic_gradient [EOL] _linear_bayes = sklearn . linear_model . _bayes [EOL] _linear_theil = sklearn . linear_model . _theil_sen [EOL] _linear_omp = sklearn . linear_model . _omp [EOL] _linear_ridge = sklearn . linear_model . _ridge [EOL] _linear_angles = sklearn . linear_model . _least_angle [EOL] else : [comment] [EOL] _linear_base = sklearn . linear_model . base [comment] [EOL] [comment] [EOL] _linear_coordinate_descent = sklearn . linear_model . coordinate_descent [EOL] _lienar_stochastic_gradient = sklearn . linear_model . stochastic_gradient [EOL] _linear_bayes = sklearn . linear_model . bayes [EOL] _linear_theil = sklearn . linear_model . theil_sen [EOL] _linear_omp = sklearn . linear_model . omp [EOL] _linear_ridge = sklearn . linear_model . ridge [EOL] _linear_angles = sklearn . linear_model . least_angle [EOL] [EOL] _LINEAR = ( _linear_base . LinearModel , _linear_coordinate_descent . LinearModelCV ) [EOL] _LINEAR_CLASSIFIER = ( _linear_base . LinearClassifierMixin , ) [EOL] _LINEAR_REGRESSOR = ( _linear_base . LinearRegression , _lienar_stochastic_gradient . BaseSGDRegressor , _linear_bayes . BayesianRidge , _linear_bayes . ARDRegression , _linear_coordinate_descent . ElasticNet , _linear_coordinate_descent . ElasticNetCV , _linear_coordinate_descent . LassoCV , _linear_theil . TheilSenRegressor , _linear_omp . OrthogonalMatchingPursuit , _linear_omp . OrthogonalMatchingPursuitCV , _linear_ridge . Ridge , _linear_ridge . RidgeCV , sklearn . linear_model . HuberRegressor , _linear_angles . Lars , sklearn . svm . LinearSVR , _linear_coordinate_descent . MultiTaskLassoCV , _linear_coordinate_descent . MultiTaskElasticNetCV ) [EOL] [EOL] [EOL] def _is_scikit_linear ( clf ) : [EOL] [docstring] [EOL] [EOL] assert ftst . is_sklearn_model_instance ( clf ) , [string] [EOL] is_scikit_linear = isinstance ( clf , ( _LINEAR_REGRESSOR , _LINEAR_CLASSIFIER ) ) [EOL] return is_scikit_linear [EOL] [EOL] [EOL] def _is_fitted_linear ( clf ) : [EOL] [docstring] [EOL] assert _is_scikit_linear ( clf ) , [string] [EOL] [EOL] is_fitted_linear = False [EOL] [EOL] [comment] [EOL] if _SKLEARN_0_22 : [comment] [EOL] [comment] [EOL] sklearn . utils . validation . check_is_fitted ( clf ) [EOL] else : [comment] [EOL] sklearn . utils . validation . check_is_fitted ( clf , [string] , all_or_any = all ) [EOL] [EOL] is_fitted_linear = True [EOL] return is_fitted_linear [EOL] [EOL] [EOL] def linear_classifier_coefficients ( clf ) : [EOL] [docstring] [EOL] [comment] [EOL] if not _is_scikit_linear ( clf ) : [EOL] raise TypeError ( [string] [string] [string] . format ( clf . __module__ , clf . __class__ . __name__ ) ) [EOL] assert _is_fitted_linear ( clf ) , [string] [EOL] [EOL] assert hasattr ( clf , [string] ) , [string] [EOL] coefficients = clf . coef_ [EOL] [comment] [EOL] [comment] [EOL] [EOL] return coefficients [EOL] [EOL] [EOL] class SKLearnLinearModelExplainer ( ftst . SKLearnExplainer ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] def feature_importance ( self ) : [EOL] [docstring] [EOL] feature_importance_array = linear_classifier_coefficients ( self . clf ) [EOL] return feature_importance_array [EOL] [EOL] def _is_classifier ( self ) : [EOL] [docstring] [EOL] if isinstance ( self . clf , _LINEAR_CLASSIFIER ) : [EOL] is_classifier = True [EOL] elif isinstance ( self . clf , _LINEAR_REGRESSOR ) : [EOL] is_classifier = False [EOL] else : [EOL] assert False , [string] [comment] [EOL] return is_classifier [EOL] [EOL] def _validate_kind_fitted ( self ) : [EOL] [docstring] [EOL] is_linear_fitted = False [EOL] [EOL] if not _is_scikit_linear ( self . clf ) : [EOL] raise TypeError ( [string] [string] [string] . format ( self . clf . __module__ , self . clf . __class__ . __name__ ) ) [EOL] [EOL] assert _is_fitted_linear ( self . clf ) , [string] [EOL] [EOL] is_linear_fitted = True [EOL] return is_linear_fitted [EOL] [EOL] def _get_features_number ( self ) : [EOL] [docstring] [EOL] if self . is_classifier : [EOL] features_number = self . clf . coef_ . shape [ [number] ] [EOL] else : [EOL] coef_shape_dim = len ( self . clf . coef_ . shape ) [EOL] if coef_shape_dim == [number] : [comment] [EOL] features_number = self . clf . coef_ . shape [ [number] ] [EOL] elif coef_shape_dim == [number] : [comment] [EOL] features_number = self . clf . coef_ . shape [ [number] ] [EOL] else : [EOL] assert False , [string] [comment] [EOL] return features_number [EOL] [EOL] def _get_classes_array ( self ) : [EOL] [docstring] [EOL] if self . is_classifier : [EOL] classes_array = self . clf . classes_ [EOL] else : [EOL] classes_array = None [EOL] return classes_array [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[numpy.ndarray,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] try : [EOL] import sklearn [EOL] except ImportError : [EOL] raise ImportError ( [string] [string] [string] [string] [string] [string] ) [EOL] else : [EOL] del sklearn [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict , Type , List [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import sklearn [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] [string] , allow_module_level = True ) [EOL] [EOL] import sklearn . cluster [EOL] import sklearn . discriminant_analysis [EOL] import sklearn . dummy [EOL] import sklearn . exceptions [EOL] import sklearn . linear_model [EOL] import sklearn . naive_bayes [EOL] import sklearn . neighbors [EOL] import sklearn . svm [EOL] import sklearn . tree [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf [EOL] [EOL] import fatf . transparency . sklearn . linear_model as ftsl [EOL] import fatf . utils . tools as fut [EOL] [EOL] _SKLEARN_VERSION = [ int ( i ) for i in sklearn . __version__ . split ( [string] ) [ : [number] ] ] [EOL] _SKLEARN_0_20 = fut . at_least_verion ( [ [number] , [number] ] , _SKLEARN_VERSION ) [EOL] _SKLEARN_0_22 = fut . at_least_verion ( [ [number] , [number] ] , _SKLEARN_VERSION ) [EOL] _SKLEARN_0_23 = fut . at_least_verion ( [ [number] , [number] ] , _SKLEARN_VERSION ) [EOL] [EOL] [comment] [EOL] LINEAR_CLASSIFIERS = [ sklearn . svm . LinearSVC , sklearn . linear_model . RidgeClassifier , sklearn . linear_model . RidgeClassifierCV , sklearn . discriminant_analysis . LinearDiscriminantAnalysis , sklearn . linear_model . LogisticRegression , sklearn . linear_model . LogisticRegressionCV ] [EOL] [comment] [EOL] [comment] [EOL] LINEAR_CLASSIFIERS_ = [ sklearn . linear_model . SGDClassifier , sklearn . linear_model . PassiveAggressiveClassifier , sklearn . linear_model . Perceptron ] [EOL] LINEAR_REGRESSORS = [ sklearn . linear_model . BayesianRidge , sklearn . linear_model . ElasticNet , sklearn . linear_model . ElasticNetCV , sklearn . linear_model . Lasso , sklearn . linear_model . LassoCV , sklearn . linear_model . Lars , sklearn . linear_model . LarsCV , sklearn . linear_model . LassoLars , sklearn . linear_model . LassoLarsCV , sklearn . linear_model . LassoLarsIC , sklearn . linear_model . ARDRegression , sklearn . linear_model . HuberRegressor , sklearn . linear_model . TheilSenRegressor , sklearn . linear_model . OrthogonalMatchingPursuit , sklearn . linear_model . OrthogonalMatchingPursuitCV , sklearn . linear_model . Ridge , sklearn . linear_model . RidgeCV , sklearn . linear_model . PassiveAggressiveRegressor , sklearn . linear_model . SGDRegressor ] [EOL] LINEAR_REGRESSORS_ = [ sklearn . linear_model . LinearRegression , sklearn . svm . LinearSVR ] [EOL] LINEAR_MULTITASK_REGRESSORS = [ sklearn . linear_model . MultiTaskLasso , sklearn . linear_model . MultiTaskLassoCV , sklearn . linear_model . MultiTaskElasticNet , sklearn . linear_model . MultiTaskElasticNetCV ] [EOL] NON_LINEAR_MODELS = [ sklearn . cluster . KMeans , sklearn . dummy . DummyRegressor , sklearn . naive_bayes . BernoulliNB , sklearn . neighbors . KNeighborsClassifier , sklearn . neighbors . KNeighborsRegressor , sklearn . tree . DecisionTreeClassifier , sklearn . tree . DecisionTreeRegressor ] [EOL] NON_LINEAR_MODELS_ = [ sklearn . dummy . DummyClassifier , sklearn . linear_model . RANSACRegressor ] [EOL] [EOL] LINEAR_REG_COEF = [ np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ - [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , - [number] , - [number] ] ) ] [EOL] if not _SKLEARN_0_20 : [comment] [EOL] LINEAR_REG_COEF [ [number] ] = np . array ( [ [number] , [number] , [number] , - [number] ] ) [EOL] LINEAR_REG_COEF [ [number] ] = np . array ( [ - [number] , - [number] , - [number] , [number] ] ) [EOL] LINEAR_REG_COEF_ = [ np . array ( [ [number] , - [number] , [number] , - [number] ] ) , np . array ( [ [number] , [number] , [number] , - [number] ] ) ] [EOL] LINEAR_CLF_COEF_36 = [ np . array ( [ [ - [number] , - [number] , - [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ - [number] , - [number] , - [number] , - [number] ] ] ) , ] [EOL] LINEAR_CLF_COEF_37 = [ np . array ( [ [ [number] , [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , [number] , [number] , - [number] ] ] ) ] [EOL] LINEAR_CLF_COEF = [ np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] ] ) ] [EOL] if _SKLEARN_0_23 : [comment] [EOL] LINEAR_CLF_COEF [ [number] ] = np . array ( [ [number] , - [number] , [number] , - [number] ] ) [EOL] LINEAR_MUL_REG_COEF = [ np . array ( [ [ [number] , - [number] , [number] , - [number] ] , [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] , [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] , [ [number] , - [number] , [number] , - [number] ] ] ) , np . array ( [ [ [number] , - [number] , [number] , - [number] ] , [ [number] , - [number] , [number] , - [number] ] ] ) ] [EOL] [comment] [EOL] [EOL] DATA = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , - [number] , [number] ] , [ [number] , [number] , [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] , [ [number] , [number] , [number] , - [number] ] ] [EOL] LABELS = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] LABELS_MULTITASK = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] [EOL] [EOL] def get_kwargs ( clf_name ) : [EOL] [docstring] [EOL] assert isinstance ( clf_name , str ) , [string] [EOL] [EOL] if clf_name . endswith ( [string] ) : [EOL] kwargs = dict ( cv = [number] ) [EOL] elif clf_name == [string] : [EOL] kwargs = dict ( solver = [string] ) [EOL] elif ( clf_name . startswith ( [string] ) or clf_name in ( [string] , [string] , [string] ) ) : [EOL] kwargs = dict ( max_iter = [number] , tol = [number] , random_state = [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] else : [EOL] kwargs = dict ( ) [EOL] return kwargs [EOL] [EOL] [EOL] def test_validate_classifier_list ( ) : [EOL] [docstring] [EOL] for clf in LINEAR_CLASSIFIERS + LINEAR_CLASSIFIERS_ : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] assert hasattr ( clf_instance , [string] ) [EOL] [EOL] for clf in LINEAR_REGRESSORS : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] assert not hasattr ( clf_instance , [string] ) [EOL] [EOL] for clf in LINEAR_MULTITASK_REGRESSORS : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS_MULTITASK ) [EOL] [EOL] assert not hasattr ( clf_instance , [string] ) [EOL] [EOL] [EOL] def test_is_scikit_linear ( ) : [EOL] [docstring] [EOL] assertion_error_clf = [string] [EOL] [EOL] clf_instance = object ( ) [EOL] with pytest . raises ( AssertionError ) as excinfo : [EOL] ftsl . _is_scikit_linear ( clf_instance ) [EOL] assert str ( excinfo . value ) == assertion_error_clf [EOL] clf_instance = [string] [EOL] with pytest . raises ( AssertionError ) as excinfo : [EOL] ftsl . _is_scikit_linear ( clf_instance ) [EOL] assert str ( excinfo . value ) == assertion_error_clf [EOL] clf_instance = object [EOL] with pytest . raises ( AssertionError ) as excinfo : [EOL] ftsl . _is_scikit_linear ( clf_instance ) [EOL] assert str ( excinfo . value ) == assertion_error_clf [EOL] [EOL] for clf in NON_LINEAR_MODELS + NON_LINEAR_MODELS_ : [EOL] clf_instance = clf ( ) [EOL] assert ftsl . _is_scikit_linear ( clf_instance ) is False [EOL] [EOL] mdl = ( LINEAR_CLASSIFIERS + LINEAR_CLASSIFIERS_ + LINEAR_REGRESSORS + LINEAR_REGRESSORS_ + LINEAR_MULTITASK_REGRESSORS ) [comment] [EOL] for clf in mdl : [EOL] clf_instance = clf ( ) [EOL] assert ftsl . _is_scikit_linear ( clf_instance ) is True [EOL] [EOL] [EOL] def test_is_fitted_linear ( ) : [EOL] [docstring] [EOL] unfit_error = ( [string] [string] . format ( [string] if _SKLEARN_0_22 else [string] ) ) [EOL] [EOL] for clf in LINEAR_CLASSIFIERS + LINEAR_CLASSIFIERS_ + LINEAR_REGRESSORS : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] [EOL] with pytest . raises ( sklearn . exceptions . NotFittedError ) as excinfo : [EOL] ftsl . _is_fitted_linear ( clf_instance ) [EOL] msg = unfit_error . format ( clf_instance . __class__ . __name__ ) [EOL] assert str ( excinfo . value ) == msg [EOL] [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] assert ftsl . _is_fitted_linear ( clf_instance ) [EOL] [EOL] for clf in LINEAR_MULTITASK_REGRESSORS : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] [EOL] with pytest . raises ( sklearn . exceptions . NotFittedError ) as excinfo : [EOL] ftsl . _is_fitted_linear ( clf_instance ) [EOL] msg = unfit_error . format ( clf_instance . __class__ . __name__ ) [EOL] assert str ( excinfo . value ) == msg [EOL] [EOL] clf_instance . fit ( DATA , LABELS_MULTITASK ) [EOL] assert ftsl . _is_fitted_linear ( clf_instance ) [EOL] [EOL] [EOL] def test_linear_classifier_coefficients ( ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] type_error = ( [string] [string] ) [EOL] unfit_error = ( [string] [string] . format ( [string] if _SKLEARN_0_22 else [string] ) ) [EOL] [EOL] for clf in NON_LINEAR_MODELS : [EOL] clf_instance = clf ( ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] with pytest . raises ( TypeError ) as excinfo : [EOL] ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] name = str ( clf ) . strip ( [string] ) [ [number] : ] [EOL] assert str ( excinfo . value ) == type_error . format ( name ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_REGRESSORS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] [EOL] with pytest . raises ( sklearn . exceptions . NotFittedError ) as excinfo : [EOL] ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] msg = unfit_error . format ( clf_instance . __class__ . __name__ ) [EOL] assert str ( excinfo . value ) == msg [EOL] [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] coef = ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] if name == [string] : [EOL] assert np . allclose ( coef / [number] , LINEAR_REG_COEF [ i ] , atol = [number] ) [EOL] else : [EOL] assert np . allclose ( coef , LINEAR_REG_COEF [ i ] , atol = [number] ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_CLASSIFIERS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] [EOL] with pytest . raises ( sklearn . exceptions . NotFittedError ) as excinfo : [EOL] ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] msg = unfit_error . format ( clf_instance . __class__ . __name__ ) [EOL] assert str ( excinfo . value ) == msg [EOL] [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] coef = ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] assert np . allclose ( coef , LINEAR_CLF_COEF [ i ] , atol = [number] ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_MULTITASK_REGRESSORS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] [EOL] with pytest . raises ( sklearn . exceptions . NotFittedError ) as excinfo : [EOL] ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] msg = unfit_error . format ( clf_instance . __class__ . __name__ ) [EOL] assert str ( excinfo . value ) == msg [EOL] [EOL] clf_instance . fit ( DATA , LABELS_MULTITASK ) [EOL] [EOL] coef = ftsl . linear_classifier_coefficients ( clf_instance ) [EOL] assert np . allclose ( coef , LINEAR_MUL_REG_COEF [ i ] , atol = [number] ) [EOL] [EOL] [EOL] class TestSKLearnLinearModelExplainer ( object ) : [EOL] [docstring] [EOL] [EOL] feature_names = [ [string] . format ( i ) for i in range ( [number] ) ] [EOL] class_names = [ [string] . format ( i ) for i in range ( [number] ) ] [EOL] [EOL] def test_linear_classifiers ( self ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_CLASSIFIERS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] ske = ftsl . SKLearnLinearModelExplainer ( clf_instance , self . feature_names , self . class_names ) [EOL] [comment] [EOL] assert ske . clf == clf_instance [EOL] assert ske . is_classifier is True [EOL] assert ske . feature_names == self . feature_names [EOL] assert ske . class_names == self . class_names [EOL] assert ske . features_number == [number] [EOL] assert np . array_equal ( ske . classes_array , [ [number] , [number] ] ) [EOL] [EOL] coef = ske . feature_importance ( ) [EOL] assert np . allclose ( coef , LINEAR_CLF_COEF [ i ] , atol = [number] ) [EOL] [EOL] def test_linear_regressors ( self ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_REGRESSORS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] ske = ftsl . SKLearnLinearModelExplainer ( clf_instance , feature_names = self . feature_names ) [EOL] [comment] [EOL] assert ske . clf == clf_instance [EOL] assert ske . is_classifier is False [EOL] assert ske . feature_names == self . feature_names [EOL] assert ske . class_names is None [EOL] assert ske . features_number == [number] [EOL] assert ske . classes_array is None [EOL] [EOL] coef = ske . feature_importance ( ) [EOL] if name == [string] : [EOL] assert np . allclose ( coef / [number] , LINEAR_REG_COEF [ i ] , atol = [number] ) [EOL] else : [EOL] assert np . allclose ( coef , LINEAR_REG_COEF [ i ] , atol = [number] ) [EOL] [EOL] def test_linear_multitask_regressors ( self ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] for i , clf in enumerate ( LINEAR_MULTITASK_REGRESSORS ) : [EOL] name = clf . __name__ [EOL] kwargs = get_kwargs ( name ) [EOL] clf_instance = clf ( ** kwargs ) [EOL] clf_instance . fit ( DATA , LABELS_MULTITASK ) [EOL] [EOL] ske = ftsl . SKLearnLinearModelExplainer ( clf_instance , feature_names = self . feature_names ) [EOL] [comment] [EOL] assert ske . clf == clf_instance [EOL] assert ske . is_classifier is False [EOL] assert ske . feature_names == self . feature_names [EOL] assert ske . class_names is None [EOL] assert ske . features_number == [number] [EOL] assert ske . classes_array is None [EOL] [EOL] coef = ske . feature_importance ( ) [EOL] assert np . allclose ( coef , LINEAR_MUL_REG_COEF [ i ] , atol = [number] ) [EOL] [EOL] def test_non_linear_models ( self ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] [string] ) [EOL] [EOL] for clf in NON_LINEAR_MODELS : [EOL] clf_instance = clf ( ) [EOL] clf_instance . fit ( DATA , LABELS ) [EOL] [EOL] with pytest . raises ( TypeError ) as excinfo : [EOL] ftsl . SKLearnLinearModelExplainer ( clf_instance ) [EOL] name = str ( clf ) . strip ( [string] ) [ [number] : ] [EOL] assert str ( excinfo . value ) == type_error . format ( name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.linear_model.SKLearnLinearModelExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0
from typing import Any , List [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import sklearn [EOL] import sklearn . tree [EOL] except ImportError : [comment] [EOL] pytest . skip ( [string] [string] , allow_module_level = True ) [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . transparency . sklearn . tools as ftst [EOL] [EOL] IOBJ = object ( ) [EOL] BOBJ = sklearn . base . BaseEstimator ( ) [EOL] TOBJ = sklearn . tree . DecisionTreeClassifier ( ) [EOL] [EOL] [EOL] def test_is_sklearn_model ( ) : [EOL] [docstring] [EOL] assert not ftst . is_sklearn_model ( IOBJ ) [EOL] assert not ftst . is_sklearn_model ( object ) [EOL] assert ftst . is_sklearn_model ( BOBJ ) [EOL] assert ftst . is_sklearn_model ( sklearn . base . BaseEstimator ) [EOL] assert ftst . is_sklearn_model ( TOBJ ) [EOL] assert ftst . is_sklearn_model ( sklearn . tree . DecisionTreeClassifier ) [EOL] [EOL] [EOL] def test_is_sklearn_model_instance ( ) : [EOL] [docstring] [EOL] assert not ftst . is_sklearn_model_instance ( IOBJ ) [EOL] assert not ftst . is_sklearn_model_instance ( object ) [EOL] assert ftst . is_sklearn_model_instance ( BOBJ ) [EOL] assert not ftst . is_sklearn_model_instance ( sklearn . base . BaseEstimator ) [EOL] assert ftst . is_sklearn_model_instance ( TOBJ ) [EOL] assert not ftst . is_sklearn_model_instance ( sklearn . tree . DecisionTreeClassifier ) [EOL] [EOL] [EOL] def test_validate_input ( ) : [EOL] [docstring] [EOL] type_error_clf = ( [string] [string] ) [EOL] type_error_fno = ( [string] [string] ) [EOL] type_error_fni = ( [string] [string] ) [EOL] value_error_fn = [string] [EOL] type_error_cno = ( [string] [string] ) [EOL] type_error_cni = [string] [EOL] value_error_cn = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( IOBJ , None , None ) [EOL] assert str ( exin . value ) == type_error_clf [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( sklearn . tree . DecisionTreeClassifier , None , None ) [EOL] assert str ( exin . value ) == type_error_clf [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( TOBJ , [string] , None ) [EOL] assert str ( exin . value ) == type_error_fno [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftst . _validate_input ( TOBJ , [ ] , None ) [EOL] assert str ( exin . value ) == value_error_fn [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( TOBJ , [ [string] , [string] , [number] , [string] ] , None ) [EOL] assert str ( exin . value ) == type_error_fni [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( BOBJ , [ [string] , [string] , [string] , [string] ] , [string] ) [EOL] assert str ( exin . value ) == type_error_cno [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftst . _validate_input ( BOBJ , None , [ ] ) [EOL] assert str ( exin . value ) == value_error_cn [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . _validate_input ( BOBJ , [ [string] , [string] , [string] , [string] ] , [ [string] , [number] , [string] ] ) [EOL] assert str ( exin . value ) == type_error_cni [EOL] [EOL] assert ftst . _validate_input ( BOBJ , None , None ) [EOL] assert ftst . _validate_input ( BOBJ , [ [string] , [string] ] , None ) [EOL] assert ftst . _validate_input ( TOBJ , None , [ [string] , [string] ] ) [EOL] assert ftst . _validate_input ( TOBJ , [ [string] , [string] ] , [ [string] , [string] ] ) [EOL] [EOL] [EOL] class TestSKLearnExplainer ( object ) : [EOL] [docstring] [EOL] [EOL] class SKLearnExplainer_validate_e ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return None [EOL] [EOL] def _is_classifier ( self ) : [EOL] [comment] [EOL] return True [comment] [EOL] [EOL] def _get_features_number ( self ) : [EOL] [comment] [EOL] return None [comment] [EOL] [EOL] def _get_classes_array ( self ) : [EOL] [comment] [EOL] return None [comment] [EOL] [EOL] class SKLearnExplainer_classifier_e ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return True [EOL] [EOL] def _is_classifier ( self ) : [EOL] return None [EOL] [EOL] def _get_features_number ( self ) : [EOL] [comment] [EOL] return None [comment] [EOL] [EOL] def _get_classes_array ( self ) : [EOL] [comment] [EOL] return None [comment] [EOL] [EOL] class SKLearnExplainer_valid ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return True [EOL] [EOL] def _is_classifier ( self ) : [EOL] return True [EOL] [EOL] def _get_features_number ( self ) : [EOL] return None [EOL] [EOL] def _get_classes_array ( self ) : [EOL] return None [EOL] [EOL] class SKLearnExplainer_full ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return True [EOL] [EOL] def _is_classifier ( self ) : [EOL] return True [EOL] [EOL] def _get_features_number ( self ) : [EOL] return [number] [EOL] [EOL] def _get_classes_array ( self ) : [EOL] return np . array ( [ [string] , [string] ] ) [EOL] [EOL] class SKLearnExplainer_invalid_reg ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return True [EOL] [EOL] def _is_classifier ( self ) : [EOL] return False [EOL] [EOL] def _get_features_number ( self ) : [EOL] return None [EOL] [EOL] def _get_classes_array ( self ) : [EOL] return np . array ( [ [string] , [string] ] ) [EOL] [EOL] class SKLearnExplainer_valid_reg ( ftst . SKLearnExplainer ) : [EOL] def _validate_kind_fitted ( self ) : [EOL] return True [EOL] [EOL] def _is_classifier ( self ) : [EOL] return False [EOL] [EOL] def _get_features_number ( self ) : [EOL] return None [EOL] [EOL] def _get_classes_array ( self ) : [EOL] return None [EOL] [EOL] def test_class_init ( self , caplog ) : [EOL] [docstring] [EOL] type_error_abstract = ( [string] [string] [string] [string] ) [EOL] assertion_kind_fit = [string] [EOL] assertion_classifier = [string] [EOL] assertion_reg = ( [string] [string] ) [EOL] [EOL] value_error_fn = ( [string] [string] [string] ) [EOL] value_error_cn = ( [string] [string] [string] ) [EOL] [EOL] log_info_fn = ( [string] [string] ) [EOL] log_info_cn = ( [string] [string] [string] ) [EOL] [EOL] user_warning_fn = ( [string] [string] [string] ) [EOL] user_warning_cn = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftst . SKLearnExplainer ( ) [EOL] assert str ( exin . value ) == type_error_abstract [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] ske = self . SKLearnExplainer_validate_e ( TOBJ ) [EOL] assert str ( exin . value ) == assertion_kind_fit [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] ske = self . SKLearnExplainer_classifier_e ( TOBJ ) [EOL] assert str ( exin . value ) == assertion_classifier [EOL] [EOL] [comment] [EOL] ske = self . SKLearnExplainer_valid ( TOBJ ) [EOL] assert ske . clf == TOBJ [EOL] assert ske . feature_names is None [EOL] assert ske . class_names is None [EOL] assert ske . is_classifier is True [EOL] assert ske . features_number is None [EOL] assert ske . classes_array is None [EOL] [EOL] [comment] [EOL] f_names = [ [string] , [string] ] [EOL] c_names = [ [string] , [string] ] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] ske = self . SKLearnExplainer_valid ( TOBJ , f_names , c_names ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning_fn [EOL] assert str ( w [ [number] ] . message ) == user_warning_cn [EOL] [comment] [EOL] assert ske . clf == TOBJ [EOL] assert ske . feature_names == f_names [EOL] assert ske . class_names == c_names [EOL] assert ske . is_classifier is True [EOL] assert ske . features_number is None [EOL] assert ske . classes_array is None [EOL] [EOL] [comment] [EOL] f_names = [ [string] , [string] , [string] ] [EOL] c_names = [ [string] , [string] ] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . SKLearnExplainer_full ( TOBJ , [ [string] ] , [ [string] ] ) [EOL] assert str ( exin . value ) == value_error_fn [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . SKLearnExplainer_full ( TOBJ , f_names , [ [string] ] ) [EOL] assert str ( exin . value ) == value_error_cn [EOL] [EOL] ske = self . SKLearnExplainer_full ( TOBJ , f_names , c_names ) [EOL] assert ske . clf == TOBJ [EOL] assert ske . feature_names == f_names [EOL] assert ske . class_names == c_names [EOL] assert ske . is_classifier is True [EOL] assert ske . features_number == [number] [EOL] assert np . array_equal ( ske . classes_array , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] ske = self . SKLearnExplainer_full ( TOBJ ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == log_info_fn [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == log_info_cn [EOL] [comment] [EOL] assert ske . clf == TOBJ [EOL] assert ske . feature_names == [ [string] , [string] , [string] ] [EOL] assert ske . class_names == [ [string] , [string] ] [EOL] assert ske . is_classifier is True [EOL] assert ske . features_number == [number] [EOL] assert np . array_equal ( ske . classes_array , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . SKLearnExplainer_invalid_reg ( TOBJ ) [EOL] assert str ( exin . value ) == assertion_reg [EOL] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] ske = self . SKLearnExplainer_valid_reg ( TOBJ , feature_names = f_names ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning_fn [EOL] assert ske . feature_names == f_names [EOL] assert ske . class_names is None [EOL] assert ske . is_classifier is False [EOL] assert ske . features_number is None [EOL] assert ske . classes_array is None [EOL] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . SKLearnExplainer_valid_reg ( TOBJ , class_names = [ [string] , [string] ] ) [EOL] assert str ( exin . value ) == assertion_reg [EOL] [EOL] def test_map_class ( self ) : [EOL] [docstring] [EOL] runtime_error_reg = ( [string] [string] ) [EOL] type_error_cls = ( [string] [string] ) [EOL] runtime_error_none = ( [string] [string] ) [EOL] value_error_cls = ( [string] [string] ) [EOL] [EOL] ske = self . SKLearnExplainer_valid_reg ( TOBJ ) [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ske . map_class ( [string] ) [EOL] assert str ( exin . value ) == runtime_error_reg [EOL] [EOL] ske = self . SKLearnExplainer_valid ( TOBJ ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ske . map_class ( None ) [EOL] assert str ( exin . value ) == type_error_cls [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ske . map_class ( [string] ) [EOL] assert str ( exin . value ) == runtime_error_none [EOL] [EOL] ske = self . SKLearnExplainer_full ( TOBJ , class_names = [ [string] , [string] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ske . map_class ( [string] ) [EOL] assert str ( exin . value ) == value_error_cls . format ( [ [string] , [string] ] ) [EOL] [EOL] assert ske . map_class ( [string] ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.List[builtins.str]$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.List[builtins.str]$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.List[builtins.str]$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.List[builtins.str]$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.Any$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 $typing.List[builtins.str]$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_valid_reg$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.sklearn.tests.test_tools_sklearn.TestSKLearnExplainer.SKLearnExplainer_full$ 0 0 0 0 0 0 0 0
from typing import Dict , Type , Optional , Tuple , List , Union , Set [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import warnings [EOL] [EOL] from typing import Dict , List , Optional , Set , Tuple , Union [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . array . tools as fuat [EOL] import fatf . utils . array . validation as fuav [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [comment] [EOL] [EOL] IndicesType = Set [ Union [ str , int ] ] [EOL] [EOL] NUMERICAL_KEYS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] CATEGORICAL_KEYS = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def describe_array ( array , include = None , exclude = None , ** kwargs ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] is_1d = fuav . is_1d_like ( array ) [EOL] if is_1d : [EOL] array = fuat . as_unstructured ( array ) [EOL] is_2d = False [EOL] else : [EOL] is_2d = fuav . is_2d_array ( array ) [EOL] [EOL] if not is_1d and not is_2d : [EOL] raise IncorrectShapeError ( [string] [string] ) [EOL] [EOL] if not fuav . is_base_array ( array ) : [EOL] raise ValueError ( [string] [string] ) [EOL] [EOL] if is_1d : [EOL] if include is not None or exclude is not None : [EOL] warnings . warn ( [string] [string] , category = UserWarning ) [EOL] [EOL] if fuav . is_numerical_array ( array ) : [EOL] description = describe_numerical_array ( array , ** kwargs ) [EOL] elif fuav . is_textual_array ( array ) : [EOL] description = describe_categorical_array ( array ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] elif is_2d : [EOL] numerical_indices , categorical_indices = fuat . indices_by_type ( array ) [EOL] is_structured_array = fuav . is_structured_array ( array ) [EOL] [EOL] if ( numerical_indices . shape [ [number] ] + categorical_indices . shape [ [number] ] ) == [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] numerical_indices_set = set ( numerical_indices ) [EOL] categorical_indices_set = set ( categorical_indices ) [EOL] all_indices = categorical_indices_set . union ( numerical_indices_set ) [EOL] [comment] [EOL] include_indices = _filter_include_indices ( categorical_indices_set , numerical_indices_set , include , all_indices ) [EOL] categorical_indices_set , numerical_indices_set = include_indices [EOL] [EOL] [comment] [EOL] exclude_indices = _filter_exclude_indices ( categorical_indices_set , numerical_indices_set , exclude , all_indices ) [EOL] categorical_indices_set , numerical_indices_set = exclude_indices [EOL] [EOL] all_indices = numerical_indices_set . union ( categorical_indices_set ) [EOL] if len ( all_indices ) == [number] : [comment] [EOL] raise RuntimeError ( [string] [string] ) [EOL] [EOL] description = dict ( ) [EOL] for idx in numerical_indices_set : [EOL] if is_structured_array : [EOL] description [ idx ] = describe_numerical_array ( array [ idx ] , ** kwargs ) [EOL] else : [EOL] description [ idx ] = describe_numerical_array ( array [ : , idx ] , ** kwargs ) [EOL] for idx in categorical_indices_set : [EOL] if is_structured_array : [EOL] description [ idx ] = describe_categorical_array ( array [ idx ] ) [EOL] else : [EOL] description [ idx ] = describe_categorical_array ( array [ : , idx ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] return description [comment] [EOL] [EOL] [EOL] def describe_numerical_array ( array , skip_nans = True ) : [EOL] [docstring] [EOL] if not fuav . is_1d_like ( array ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] [EOL] classic_array = fuat . as_unstructured ( array ) [EOL] assert len ( classic_array . shape ) == [number] , [string] [EOL] [EOL] if not classic_array . shape [ [number] ] : [EOL] raise ValueError ( [string] ) [EOL] if not fuav . is_numerical_array ( classic_array ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] nan_indices = np . isnan ( classic_array ) [EOL] n_elements = classic_array . shape [ [number] ] [EOL] [EOL] if skip_nans : [EOL] classic_array = classic_array [ ~ nan_indices ] [EOL] [EOL] numerical_description = { [string] : n_elements , [string] : np . mean ( classic_array ) , [string] : np . std ( classic_array ) , [string] : np . min ( classic_array ) , [string] : np . percentile ( classic_array , [number] ) , [string] : np . percentile ( classic_array , [number] ) , [string] : np . percentile ( classic_array , [number] ) , [string] : np . max ( classic_array ) , [string] : nan_indices . sum ( ) } [EOL] [EOL] return numerical_description [EOL] [EOL] [EOL] def describe_categorical_array ( array ) : [EOL] [docstring] [EOL] if not fuav . is_1d_like ( array ) : [EOL] raise IncorrectShapeError ( [string] ) [EOL] [EOL] classic_array = fuat . as_unstructured ( array ) [EOL] assert len ( classic_array . shape ) == [number] , [string] [EOL] [EOL] if not classic_array . shape [ [number] ] : [EOL] raise ValueError ( [string] ) [EOL] if not fuav . is_textual_array ( classic_array ) : [EOL] warnings . warn ( [string] [string] [string] , category = UserWarning ) [EOL] classic_array = classic_array . astype ( str ) [EOL] [EOL] unique , unique_counts = np . unique ( classic_array , return_counts = True ) [EOL] [EOL] unique_sort_index = np . argsort ( unique ) [EOL] unique = unique [ unique_sort_index ] [EOL] unique_counts = unique_counts [ unique_sort_index ] [EOL] [EOL] top_index = np . argmax ( unique_counts ) [EOL] [EOL] top = unique [ top_index ] [EOL] freq = unique_counts [ top_index ] [EOL] [EOL] is_top_unique = ( unique_counts == freq ) . sum ( ) < [number] [EOL] [EOL] categorical_description = { [string] : classic_array . shape [ [number] ] , [string] : unique , [string] : unique_counts , [string] : top , [string] : freq , [string] : is_top_unique } [EOL] [EOL] return categorical_description [EOL] [EOL] [EOL] def _filter_include_indices ( categorical_indices_set , numerical_indices_set , include , all_indices ) : [EOL] [docstring] [EOL] assert isinstance ( categorical_indices_set , set ) , [string] [EOL] assert isinstance ( numerical_indices_set , set ) , [string] [EOL] [EOL] if include is None : [EOL] pass [EOL] elif isinstance ( include , ( str , int ) ) : [EOL] if include == [string] : [EOL] categorical_indices_set = set ( ) [EOL] elif include == [string] : [EOL] numerical_indices_set = set ( ) [EOL] else : [EOL] if include not in all_indices : [EOL] raise IndexError ( [string] [string] . format ( include ) ) [EOL] [EOL] numerical_indices_set = numerical_indices_set . intersection ( [ include ] ) [EOL] categorical_indices_set = categorical_indices_set . intersection ( [ include ] ) [EOL] elif isinstance ( include , list ) : [EOL] invalid_indices = set ( include ) . difference ( all_indices ) [EOL] if invalid_indices : [EOL] raise IndexError ( [string] [string] . format ( invalid_indices ) ) [EOL] [EOL] numerical_indices_set = numerical_indices_set . intersection ( include ) [EOL] categorical_indices_set = categorical_indices_set . intersection ( include ) [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] return categorical_indices_set , numerical_indices_set [EOL] [EOL] [EOL] def _filter_exclude_indices ( categorical_indices_set , numerical_indices_set , exclude , all_indices ) : [EOL] [docstring] [EOL] assert isinstance ( categorical_indices_set , set ) , [string] [EOL] assert isinstance ( numerical_indices_set , set ) , [string] [EOL] [EOL] if exclude is None : [EOL] pass [EOL] elif isinstance ( exclude , ( str , int ) ) : [EOL] if exclude == [string] : [EOL] numerical_indices_set = set ( ) [EOL] elif exclude == [string] : [EOL] categorical_indices_set = set ( ) [EOL] else : [EOL] if exclude not in all_indices : [EOL] raise IndexError ( [string] [string] . format ( exclude ) ) [EOL] [EOL] numerical_indices_set = numerical_indices_set . difference ( [ exclude ] ) [EOL] categorical_indices_set = categorical_indices_set . difference ( [ exclude ] ) [EOL] elif isinstance ( exclude , list ) : [EOL] invalid_indices = set ( exclude ) . difference ( all_indices ) [EOL] if invalid_indices : [EOL] raise IndexError ( [string] [string] . format ( invalid_indices ) ) [EOL] [EOL] numerical_indices_set = numerical_indices_set . difference ( exclude ) [EOL] categorical_indices_set = categorical_indices_set . difference ( exclude ) [EOL] else : [EOL] raise TypeError ( [string] [string] ) [EOL] [EOL] return categorical_indices_set , numerical_indices_set [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[IndicesType,IndicesType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[IndicesType,IndicesType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Literal , Any , List , Union , Set [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . transparency . data . describe_functions as ftddf [EOL] import fatf . utils . tools as fut [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] _NUMPY_VERSION = [ int ( i ) for i in np . version . version . split ( [string] ) ] [EOL] _NUMPY_1_17 = fut . at_least_verion ( [ [number] , [number] ] , _NUMPY_VERSION ) [EOL] _NUMPY_1_16 = fut . at_least_verion ( [ [number] , [number] ] , _NUMPY_VERSION ) [EOL] _NUMPY_1_14_4 = fut . at_least_verion ( [ [number] , [number] , [number] ] , _NUMPY_VERSION ) [EOL] _NUMPY_1_11 = fut . at_least_verion ( [ [number] , [number] ] , _NUMPY_VERSION ) [EOL] _NUMPY_1_10 = fut . at_least_verion ( [ [number] , [number] ] , _NUMPY_VERSION ) [EOL] [EOL] [EOL] def test_describe_numerical_array ( ) : [EOL] [docstring] [EOL] rwpf = [string] if _NUMPY_1_11 else [string] [EOL] runtime_warning_percentile = [string] . format ( rwpf ) [EOL] [comment] [EOL] runtime_warning_minmax = [string] [EOL] [comment] [EOL] incorrect_shape_error = [string] [EOL] value_error_non_numerical = [string] [EOL] value_error_empty = [string] [EOL] [EOL] [comment] [EOL] array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftddf . describe_numerical_array ( array ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] [EOL] [comment] [EOL] array = np . array ( [ [string] , [number] , [number] , [number] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftddf . describe_numerical_array ( array ) [EOL] assert str ( exin . value ) == value_error_non_numerical [EOL] [EOL] [comment] [EOL] array = np . array ( [ ] , dtype = np . int32 ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftddf . describe_numerical_array ( array ) [EOL] assert str ( exin . value ) == value_error_empty [EOL] [EOL] [comment] [EOL] array = np . array ( [ ( [number] , [number] , np . nan , [number] , np . nan , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , int ) , ( [string] , np . float ) , ( [string] , np . int32 ) , ( [string] , np . float ) , ( [string] , int ) ] ) [EOL] description = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [comment] [EOL] array_description = ftddf . describe_numerical_array ( array [ [number] ] ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] assert pytest . approx ( array_description [ i ] , abs = [number] ) == description [ i ] [EOL] [comment] [EOL] array_description = ftddf . describe_numerical_array ( array [ [number] ] , skip_nans = True ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] assert pytest . approx ( array_description [ i ] , abs = [number] ) == description [ i ] [EOL] [EOL] [comment] [EOL] array = np . array ( [ [number] , [number] , np . nan , [number] , np . nan , [number] ] ) [EOL] if _NUMPY_1_10 : [comment] [EOL] description = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] } [comment] [EOL] if _NUMPY_1_17 : [EOL] array_description = ftddf . describe_numerical_array ( array , skip_nans = False ) [EOL] else : [EOL] with pytest . warns ( RuntimeWarning ) as w : [EOL] array_description = ftddf . describe_numerical_array ( array , skip_nans = False ) [EOL] if _NUMPY_1_16 : [EOL] assert len ( w ) == [number] [EOL] for i in range ( len ( w ) ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] elif _NUMPY_1_14_4 : [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] for i in range ( [number] , len ( w ) - [number] ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] assert str ( w [ - [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] else : [EOL] assert len ( w ) == [number] [EOL] for i in range ( len ( w ) ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] else : [comment] [EOL] description = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] , [string] : [number] , [string] : np . nan , [string] : [number] } [comment] [EOL] array_description = ftddf . describe_numerical_array ( array , skip_nans = False ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] true = description [ i ] [EOL] computed = array_description [ i ] [EOL] if np . isnan ( true ) and np . isnan ( computed ) : [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( computed , abs = [number] ) == true [EOL] [EOL] [comment] [EOL] array = np . array ( [ [number] , [number] , [number] , [number] ] ) [EOL] description = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [comment] [EOL] array_description = ftddf . describe_numerical_array ( array , skip_nans = True ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] assert pytest . approx ( array_description [ i ] , abs = [number] ) == description [ i ] [EOL] [EOL] [comment] [EOL] array_description = ftddf . describe_numerical_array ( array , skip_nans = False ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] assert pytest . approx ( array_description [ i ] , abs = [number] ) == description [ i ] [EOL] [EOL] [EOL] def test_describe_categorical_array ( ) : [EOL] [docstring] [EOL] incorrect_shape_error = [string] [EOL] value_error_empty = [string] [EOL] user_warning_non_numerical = ( [string] [string] [string] [string] ) [EOL] [comment] [EOL] array = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftddf . describe_categorical_array ( array ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] [EOL] [comment] [EOL] array = np . array ( [ ] , dtype = np . int32 ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftddf . describe_categorical_array ( array ) [EOL] assert str ( exin . value ) == value_error_empty [EOL] [EOL] [comment] [EOL] array = np . array ( [ [number] , [number] , [number] ] ) [EOL] description = { [string] : [number] , [string] : np . array ( [ [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : True } [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] array_description = ftddf . describe_categorical_array ( array ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning_non_numerical [EOL] [comment] [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] array = np . array ( [ ( [string] , [string] , [string] , [string] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] description = { [string] : [number] , [string] : np . array ( [ [string] , [string] , [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] , [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : True } [comment] [EOL] array_description = ftddf . describe_categorical_array ( array [ [number] ] ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] array = np . array ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] description = { [string] : [number] , [string] : np . array ( [ [string] , [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : False } [comment] [EOL] array_description = ftddf . describe_categorical_array ( array ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [EOL] def test_describe_array ( ) : [EOL] [docstring] [EOL] incorrect_shape_error = [string] [EOL] value_error_non_base = ( [string] [string] ) [EOL] user_warning = ( [string] [string] ) [EOL] value_error_0_columns = [string] [EOL] value_error_include_index = ( [string] [string] ) [EOL] value_error_include_indices = ( [string] [string] ) [EOL] type_error_include = ( [string] [string] ) [EOL] value_error_exclude_index = ( [string] [string] ) [EOL] value_error_exclude_indices = ( [string] [string] ) [EOL] type_error_exclude = ( [string] [string] ) [EOL] runtime_error = [string] [EOL] rwpf = [string] if _NUMPY_1_11 else [string] [EOL] runtime_warning_percentile = [string] . format ( rwpf ) [EOL] [comment] [EOL] runtime_warning_minmax = [string] [EOL] [EOL] [comment] [EOL] array = np . ones ( ( [number] , [number] , [number] ) , dtype = np . int32 ) [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftddf . describe_array ( array ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] [EOL] [comment] [EOL] array = np . array ( [ [ [number] , None , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftddf . describe_array ( array ) [EOL] assert str ( exin . value ) == value_error_non_base [EOL] [EOL] [comment] [EOL] array = np . array ( [ [number] , [string] , [number] , [number] ] ) [EOL] description = { [string] : [number] , [string] : np . array ( [ [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : False } [comment] [EOL] array_description = ftddf . describe_array ( array ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [comment] [EOL] array_description = ftddf . describe_array ( array , skip_nans = False ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] array = np . array ( [ [number] , [string] , [number] , [number] ] ) [EOL] description = { [string] : [number] , [string] : np . array ( [ [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : False } [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] array_description = ftddf . describe_array ( array , exclude = [string] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning [EOL] [comment] [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] if isinstance ( description [ i ] , ( str , bool , int ) ) : [EOL] assert array_description [ i ] == description [ i ] [EOL] elif isinstance ( description [ i ] , np . ndarray ) : [EOL] assert np . array_equal ( array_description [ i ] , description [ i ] ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] array = np . array ( [ ( [number] , [number] , np . nan , [number] , np . nan , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , int ) , ( [string] , np . float ) , ( [string] , np . int32 ) , ( [string] , np . float ) , ( [string] , int ) ] ) [EOL] description = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] array_description = ftddf . describe_array ( array [ [number] ] , exclude = [string] , include = [string] ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning [EOL] [comment] [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] assert pytest . approx ( array_description [ i ] , abs = [number] ) == description [ i ] [EOL] [EOL] [comment] [EOL] if _NUMPY_1_10 : [comment] [EOL] description = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] } [comment] [EOL] with pytest . warns ( None ) as w : [EOL] array_description = ftddf . describe_array ( array [ [number] ] , include = [string] , skip_nans = False ) [EOL] assert issubclass ( w [ [number] ] . category , UserWarning ) [EOL] assert str ( w [ [number] ] . message ) == user_warning [EOL] if _NUMPY_1_17 : [EOL] pass [EOL] elif _NUMPY_1_16 : [EOL] assert len ( w ) == [number] [EOL] for i in range ( [number] , len ( w ) ) : [EOL] assert issubclass ( w [ i ] . category , RuntimeWarning ) [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] elif _NUMPY_1_14_4 : [EOL] assert len ( w ) == [number] [EOL] assert issubclass ( w [ [number] ] . category , RuntimeWarning ) [EOL] assert str ( w [ [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] for i in range ( [number] , len ( w ) - [number] ) : [EOL] assert issubclass ( w [ i ] . category , RuntimeWarning ) [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] assert issubclass ( w [ - [number] ] . category , RuntimeWarning ) [EOL] assert str ( w [ - [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] else : [EOL] assert len ( w ) == [number] [EOL] for i in range ( [number] , len ( w ) ) : [EOL] assert issubclass ( w [ i ] . category , RuntimeWarning ) [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] else : [comment] [EOL] description = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] , [string] : [number] , [string] : np . nan , [string] : [number] } [comment] [EOL] with pytest . warns ( UserWarning ) as w : [EOL] array_description = ftddf . describe_array ( array [ [number] ] , include = [string] , skip_nans = False ) [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) == user_warning [EOL] [comment] [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( array_description . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] true = description [ i ] [EOL] computed = array_description [ i ] [EOL] if np . isnan ( true ) and np . isnan ( computed ) : [EOL] assert True [EOL] else : [EOL] assert true == computed [EOL] [EOL] [comment] [EOL] array = np . ndarray ( ( [number] , [number] ) , dtype = np . int32 ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftddf . describe_array ( array ) [EOL] assert str ( exin . value ) == value_error_0_columns [EOL] [EOL] [comment] [EOL] numerical_indices_struct = [ [string] , [string] , [string] ] [EOL] array_num = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , - [number] ] , [ [number] , np . nan , [number] ] ] ) [EOL] array_cat = np . array ( [ [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] , [ [string] , [string] ] ] ) [EOL] array_struct = np . array ( [ ( [number] , [number] , [string] , [number] , [string] ) , ( [number] , [number] , [string] , [number] , [string] ) , ( [number] , [number] , [string] , - [number] , [string] ) , ( [number] , np . nan , [string] , [number] , [string] ) ] , dtype = [ ( [string] , int ) , ( [string] , float ) , ( [string] , [string] ) , ( [string] , np . int32 ) , ( [string] , [string] ) ] ) [EOL] [comment] [EOL] num_c0 = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] num_c1 = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] num_c1_nan = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] } [EOL] num_c1_nann = { [string] : [number] , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : np . nan , [string] : [number] , [string] : [number] , [string] : np . nan , [string] : [number] } [EOL] num_c2 = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] description_num = { [string] : num_c0 , [string] : num_c1 , [string] : num_c2 , [number] : num_c0 , [number] : num_c1 , [number] : num_c2 , [number] : num_c2 } [EOL] description_num_nan = { [string] : num_c0 , [string] : num_c1_nan , [string] : num_c2 , [number] : num_c0 , [number] : num_c1_nan , [number] : num_c2 , [number] : num_c2 } [EOL] description_num_nann = { [string] : num_c0 , [string] : num_c1_nann , [string] : num_c2 , [number] : num_c0 , [number] : num_c1_nann , [number] : num_c2 , [number] : num_c2 } [EOL] cat_c0 = { [string] : [number] , [string] : np . array ( [ [string] , [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : True } [comment] [EOL] cat_c1 = { [string] : [number] , [string] : np . array ( [ [string] , [string] ] ) , [string] : np . array ( [ [number] , [number] ] ) , [string] : [string] , [string] : [number] , [string] : False } [comment] [EOL] description_cat = { [string] : cat_c0 , [string] : cat_c1 , [number] : cat_c0 , [number] : cat_c1 } [EOL] [comment] [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct ) [EOL] assert set ( description ) == set ( array_struct . dtype . names ) [EOL] for col_id , column_description in description . items ( ) : [EOL] if col_id in numerical_indices_struct : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] else : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] if _NUMPY_1_10 : [comment] [EOL] description_num_test = description_num_nan [EOL] if _NUMPY_1_17 : [EOL] description = ftddf . describe_array ( array_struct , skip_nans = False ) [EOL] else : [EOL] with pytest . warns ( RuntimeWarning ) as w : [EOL] description = ftddf . describe_array ( array_struct , skip_nans = False ) [EOL] if _NUMPY_1_16 : [EOL] assert len ( w ) == [number] [EOL] for i in range ( len ( w ) ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] elif _NUMPY_1_14_4 : [EOL] assert len ( w ) == [number] [EOL] assert str ( w [ [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] for i in range ( [number] , len ( w ) - [number] ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] assert str ( w [ - [number] ] . message ) . startswith ( runtime_warning_minmax ) [EOL] else : [EOL] assert len ( w ) == [number] [EOL] for i in range ( len ( w ) ) : [EOL] assert str ( w [ i ] . message ) . startswith ( runtime_warning_percentile ) [EOL] else : [comment] [EOL] description_num_test = description_num_nann [EOL] description = ftddf . describe_array ( array_struct , skip_nans = False ) [EOL] [comment] [EOL] assert set ( description ) == set ( array_struct . dtype . names ) [EOL] for col_id , column_description in description . items ( ) : [EOL] if col_id in numerical_indices_struct : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num_test [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num_test [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] else : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [string] , exclude = [string] ) [EOL] assert set ( description ) == set ( [ [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [string] , exclude = [ [string] , [string] , [string] , [string] ] ) [EOL] assert set ( description ) == set ( [string] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num_nan [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num_nan [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [string] , exclude = [string] ) [EOL] assert str ( exin . value ) == runtime_error [EOL] [EOL] [comment] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [string] , exclude = [string] ) [EOL] assert str ( exin . value ) == value_error_include_index . format ( [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [number] , exclude = [string] ) [EOL] assert str ( exin . value ) == type_error_include [EOL] [EOL] [comment] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [ [string] , [number] , [string] , [string] ] , exclude = [string] ) [EOL] exin_message = str ( exin . value ) [EOL] assert ( exin_message . startswith ( value_error_include_indices ) [EOL] and [string] in exin_message and [string] in exin_message [EOL] and [string] in exin_message and [string] in exin_message ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [string] , exclude = [string] ) [EOL] assert str ( exin . value ) == value_error_exclude_index . format ( [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [string] , exclude = [ [string] , [number] , [string] , [string] ] ) [EOL] exin_message = str ( exin . value ) [EOL] assert ( exin_message . startswith ( value_error_exclude_indices ) [EOL] and [string] in exin_message and [string] in exin_message [EOL] and [string] in exin_message and [string] in exin_message ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftddf . describe_array ( array_struct , include = [string] , exclude = [number] ) [EOL] assert str ( exin . value ) == type_error_exclude [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [ [string] , [string] ] , exclude = [string] ) [EOL] assert set ( description ) == set ( [ [string] , [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num_nan [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num_nan [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [string] ) [EOL] assert set ( description ) == set ( [ [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num_nan [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num_nan [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [string] ) [EOL] assert set ( description ) == set ( [ [string] , [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , include = [string] ) [EOL] assert set ( description ) == set ( [ [string] , [string] , [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , exclude = [string] ) [EOL] assert set ( description ) == set ( [ [string] , [string] , [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_struct , exclude = [string] ) [EOL] assert set ( description ) == set ( [ [string] , [string] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ftddf . describe_array ( array_num , exclude = [string] ) [EOL] assert str ( exin . value ) == runtime_error [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_num , exclude = [number] ) [EOL] assert set ( description ) == set ( [ [number] , [number] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_num , include = [ [number] , [number] ] ) [EOL] assert set ( description ) == set ( [ [number] , [number] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . NUMERICAL_KEYS ) == set ( description_num [ col_id ] . keys ( ) ) [EOL] for i in ftddf . NUMERICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_num [ col_id ] [ i ] [EOL] if np . isnan ( col_d ) and np . isnan ( gt_d ) : [comment] [EOL] assert True [EOL] else : [EOL] assert pytest . approx ( col_d , abs = [number] ) == gt_d [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ftddf . describe_array ( array_cat , exclude = [string] ) [EOL] assert str ( exin . value ) == runtime_error [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_cat , exclude = [number] ) [EOL] assert set ( description ) == set ( [ [number] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [comment] [EOL] description = ftddf . describe_array ( array_cat , include = [number] , exclude = [string] ) [EOL] assert set ( description ) == set ( [ [number] ] ) [EOL] for col_id , column_description in description . items ( ) : [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( column_description . keys ( ) ) [EOL] assert set ( ftddf . CATEGORICAL_KEYS ) == set ( description_cat [ col_id ] . keys ( ) ) [EOL] for i in ftddf . CATEGORICAL_KEYS : [EOL] col_d = column_description [ i ] [EOL] gt_d = description_cat [ col_id ] [ i ] [EOL] if isinstance ( col_d , ( str , bool , int , np . int64 , np . bool_ ) ) : [EOL] assert col_d == gt_d [EOL] elif isinstance ( col_d , np . ndarray ) : [EOL] assert np . array_equal ( col_d , gt_d ) [EOL] else : [comment] [EOL] assert False , [string] [EOL] [EOL] [EOL] def test_filter_include_indices ( ) : [EOL] [docstring] [EOL] index_error_a = [string] [EOL] index_error_b = [string] [EOL] type_error = ( [string] [string] ) [EOL] n_set = set ( [ [string] , [string] , [string] ] ) [EOL] c_set = set ( [ [string] , [string] , [string] ] ) [EOL] nc_set = n_set . union ( c_set ) [EOL] n_set_num = set ( [ [number] , [number] , [number] ] ) [EOL] c_set_num = set ( [ [number] , [number] ] ) [EOL] nc_set_num = n_set_num . union ( c_set_num ) [EOL] [EOL] [comment] [EOL] include = None [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert c_ind == c_set and n_ind == n_set [EOL] [EOL] [comment] [EOL] include = [string] [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert c_ind == set ( ) and n_ind == n_set [EOL] [EOL] [comment] [EOL] include = [string] [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert c_ind == c_set and n_ind == set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] include = [number] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert str ( exin . value ) == index_error_a . format ( include ) [EOL] [comment] [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( c_set_num , n_set_num , include , nc_set_num ) [EOL] assert c_ind == set ( [ [number] ] ) and n_ind == set ( ) [EOL] [comment] [EOL] include = [number] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert str ( exin . value ) == type_error . format ( include ) [EOL] [EOL] [comment] [EOL] include = [string] [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] assert c_ind == set ( [ [string] ] ) and n_ind == set ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] include = [ [string] , [string] , [number] , [number] , [string] ] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . _filter_include_indices ( c_set , n_set , include , nc_set ) [EOL] exin_msg = str ( exin . value ) [EOL] assert ( exin_msg . startswith ( index_error_b ) and [string] in exin_msg [EOL] and [string] in exin_msg and [string] in exin_msg ) [EOL] [comment] [EOL] include = [ [string] , [string] , [string] ] [EOL] c_ind , n_ind = ftddf . _filter_include_indices ( set ( [ [string] , [string] ] ) , n_set , include , nc_set ) [EOL] assert c_ind == set ( [ [string] ] ) and n_ind == set ( [ [string] ] ) [EOL] [EOL] [EOL] def test_filter_exclude_indices ( ) : [EOL] [docstring] [EOL] index_error_a = [string] [EOL] index_error_b = [string] [EOL] type_error = ( [string] [string] ) [EOL] n_set = set ( [ [string] , [string] , [string] ] ) [EOL] c_set = set ( [ [string] , [string] , [string] ] ) [EOL] nc_set = n_set . union ( c_set ) [EOL] n_set_num = set ( [ [number] , [number] , [number] ] ) [EOL] c_set_num = set ( [ [number] , [number] ] ) [EOL] nc_set_num = n_set_num . union ( c_set_num ) [EOL] [EOL] [comment] [EOL] exclude = None [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert c_ind == c_set and n_ind == n_set [EOL] [EOL] [comment] [EOL] exclude = [string] [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert c_ind == c_set and n_ind == set ( ) [EOL] [EOL] [comment] [EOL] exclude = [string] [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert c_ind == set ( ) and n_ind == n_set [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude = [number] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert str ( exin . value ) == index_error_a . format ( exclude ) [EOL] [comment] [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( c_set_num , n_set_num , exclude , nc_set_num ) [EOL] assert c_ind == set ( [ [number] ] ) and n_ind == set ( [ [number] , [number] , [number] ] ) [EOL] [comment] [EOL] exclude = [number] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert str ( exin . value ) == type_error . format ( exclude ) [EOL] [EOL] [comment] [EOL] exclude = [string] [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] assert c_ind == set ( [ [string] , [string] ] ) and n_ind == set ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] exclude = [ [string] , [string] , [number] , [number] , [string] ] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftddf . _filter_exclude_indices ( c_set , n_set , exclude , nc_set ) [EOL] exin_msg = str ( exin . value ) [EOL] assert ( exin_msg . startswith ( index_error_b ) and [string] in exin_msg [EOL] and [string] in exin_msg and [string] in exin_msg ) [EOL] [comment] [EOL] exclude = [ [string] , [string] , [string] ] [EOL] c_ind , n_ind = ftddf . _filter_exclude_indices ( set ( [ [string] , [string] ] ) , n_set , exclude , nc_set ) [EOL] assert c_ind == set ( [ [string] ] ) and n_ind == set ( [ [string] , [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Dict , Tuple , Any , List , Union [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] try : [EOL] import sklearn [EOL] except ImportError : [comment] [EOL] _missing_sklearn_msg = ( [string] [string] [string] ) [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] import fatf . transparency . predictions . surrogate_explainers as ftps [EOL] assert len ( warning ) > [number] [EOL] assert str ( warning [ - [number] ] . message ) == _missing_sklearn_msg [EOL] [EOL] SKLEARN_MISSING = True [EOL] else : [EOL] del sklearn [EOL] import fatf . transparency . predictions . surrogate_explainers as ftps [EOL] SKLEARN_MISSING = False [EOL] [EOL] import importlib [EOL] import sys [EOL] [EOL] import numpy as np [EOL] [EOL] from fatf . exceptions import IncompatibleModelError , IncorrectShapeError [EOL] [EOL] import fatf [EOL] [EOL] import fatf . utils . array . tools as fuat [EOL] import fatf . utils . data . augmentation as fuda [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . data . discretisation as fudd [EOL] import fatf . utils . models as fum [EOL] import fatf . utils . testing . transparency as futt [EOL] import fatf . utils . testing . imports as futi [EOL] [EOL] IRIS_DATASET = fatf_datasets . load_iris ( ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( SKLEARN_MISSING , reason = [string] ) def test_sklearn_imports ( caplog ) : [EOL] [docstring] [EOL] missing_sklearn = ( [string] [string] [string] [string] ) [EOL] import_error_lime = ( [string] [string] ) [EOL] import_error_tree = ( [string] [string] ) [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] assert [string] in sys . modules [EOL] [EOL] with futi . module_import_tester ( [string] , when_missing = True ) : [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] importlib . reload ( ftps ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == missing_sklearn [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] with pytest . raises ( ImportError ) as exin : [EOL] ftps . TabularBlimeyLime ( None , None ) [EOL] assert str ( exin . value ) == import_error_lime [EOL] [EOL] with pytest . raises ( ImportError ) as exin : [EOL] ftps . TabularBlimeyTree ( None , None ) [EOL] assert str ( exin . value ) == import_error_tree [EOL] [EOL] importlib . reload ( ftps ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert [string] in sys . modules [EOL] [EOL] [EOL] def test_input_is_valid ( ) : [EOL] [docstring] [EOL] dataset_incorrect_shape = ( [string] [string] ) [EOL] dataset_type_error = ( [string] [string] ) [EOL] as_probabilistic_type_error = ( [string] [string] ) [EOL] as_regressor_type_error = [string] [EOL] model_incompatible_reg = ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] model_incompatible_model_np = ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] model_incompatible_model_p = ( [string] [string] [string] [string] [string] [string] [string] ) [EOL] categorical_indices_index_error = ( [string] [string] ) [EOL] categorical_indices_type_error = ( [string] [string] ) [EOL] categorical_indices_value_error = ( [string] [string] ) [EOL] class_names_type_error_out = ( [string] [string] ) [EOL] class_names_value_error_empty = [string] [EOL] class_names_value_error_dup = ( [string] [string] ) [EOL] class_names_type_error_in = ( [string] [string] ) [EOL] class_number_type_error = ( [string] [string] ) [EOL] class_number_value_error = ( [string] [string] ) [EOL] feature_names_type_error_out = ( [string] [string] ) [EOL] feature_names_value_error_count = ( [string] [string] [string] ) [EOL] feature_names_value_error_dup = ( [string] [string] ) [EOL] feature_names_type_error_in = ( [string] [string] ) [EOL] unique_predictions_type_error_out = ( [string] [string] ) [EOL] unique_predictions_value_error_empty = ( [string] [string] ) [EOL] unique_predictions_value_error_dup = ( [string] [string] ) [EOL] unique_predictions_type_error_in = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ftps . _input_is_valid ( futt . LABELS , None , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == dataset_incorrect_shape [EOL] with pytest . raises ( TypeError ) as exin : [EOL] array = np . array ( [ [ [number] , None ] , [ [number] , [number] ] ] ) [EOL] ftps . _input_is_valid ( array , None , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == dataset_type_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , None , None , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == as_probabilistic_type_error [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , None , True , None , None , None , None , None , None ) [EOL] assert str ( exin . value ) == as_regressor_type_error [EOL] [EOL] model = futt . InvalidModel ( ) [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , True , True , None , None , None , None , None ) [EOL] assert str ( exin . value ) == model_incompatible_reg [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , True , None , None , None , None , None ) [EOL] assert str ( exin . value ) == model_incompatible_reg [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , None ) [EOL] assert str ( exin . value ) == model_incompatible_model_np [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , True , False , None , None , None , None , None ) [EOL] assert str ( exin . value ) == model_incompatible_model_p [EOL] [EOL] model = futt . NonProbabilisticModel ( None ) [EOL] with pytest . raises ( IncompatibleModelError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , True , False , None , None , None , None , None ) [EOL] assert str ( exin . value ) == model_incompatible_model_p [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , [string] , None , None , None , None ) [EOL] assert str ( exin . value ) == categorical_indices_type_error [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , [ [string] ] , None , None , None , None ) [EOL] assert str ( exin . value ) == categorical_indices_index_error . format ( np . array ( [ [string] ] ) ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , [ [string] , [string] , [string] , [string] ] , None , None , None , None ) [EOL] assert str ( exin . value ) == categorical_indices_value_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , [string] , None , None , None ) [EOL] assert str ( exin . value ) == class_names_type_error_out [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , [ ] , None , None , None ) [EOL] assert str ( exin . value ) == class_names_value_error_empty [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , [ [string] , [string] , [string] , [string] ] , None , None , None ) [EOL] assert str ( exin . value ) == class_names_value_error_dup [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , [ [string] , [number] , [string] ] , None , None , None ) [EOL] assert str ( exin . value ) == class_names_type_error_in . format ( [number] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , [string] , None , None ) [EOL] assert str ( exin . value ) == class_number_type_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , [number] , None , None ) [EOL] assert str ( exin . value ) == class_number_value_error [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , [string] , None ) [EOL] assert str ( exin . value ) == feature_names_type_error_out [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , [ [string] ] , None ) [EOL] assert str ( exin . value ) == feature_names_value_error_count . format ( [number] ) [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , [ [string] , [string] , [string] , [string] ] , None ) [EOL] assert str ( exin . value ) == feature_names_value_error_dup [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , [ [string] , [string] , [number] , [string] ] , None ) [EOL] assert str ( exin . value ) == feature_names_type_error_in . format ( [number] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , [string] ) [EOL] assert str ( exin . value ) == unique_predictions_type_error_out [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , [ None , [string] , [string] ] ) [EOL] assert str ( exin . value ) == unique_predictions_type_error_in [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , [ [string] , [string] , [string] , [number] , [string] , [string] ] ) [EOL] assert str ( exin . value ) == unique_predictions_type_error_in [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , [ ] ) [EOL] assert str ( exin . value ) == unique_predictions_value_error_empty [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , [ [string] , [string] , [string] , [string] ] ) [EOL] assert str ( exin . value ) == unique_predictions_value_error_dup [EOL] [EOL] assert ftps . _input_is_valid ( futt . NUMERICAL_NP_ARRAY , model , False , False , None , None , None , None , None ) [EOL] [EOL] [EOL] class TestSurrogateTabularExplainer ( object ) : [EOL] [docstring] [EOL] [EOL] class BrokenSurrogateTabularExplainer ( ftps . SurrogateTabularExplainer ) : [EOL] [docstring] [EOL] [EOL] class BaseSurrogateTabularExplainer ( ftps . SurrogateTabularExplainer ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dataset , predictive_model , as_probabilistic = True , as_regressor = False , categorical_indices = None , class_names = None , classes_number = None , feature_names = None , unique_predictions = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( dataset , predictive_model , as_probabilistic , as_regressor , categorical_indices , class_names , classes_number , feature_names , unique_predictions ) [EOL] [EOL] def explain_instance ( self , data_row ) : [EOL] [docstring] [EOL] self . _explain_instance_input_is_valid ( data_row ) [EOL] [EOL] numerical_np_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_np_array_classifier . fit ( futt . NUMERICAL_NP_ARRAY , futt . LABELS ) [EOL] numerical_dummy_surrogate = BaseSurrogateTabularExplainer ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier , as_probabilistic = True , categorical_indices = [ [number] ] , class_names = None , feature_names = [ [string] , [string] , [string] , [string] ] ) [EOL] numerical_dummy_surrogate_reg = BaseSurrogateTabularExplainer ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier , as_probabilistic = True , as_regressor = True , categorical_indices = [ [number] ] , class_names = [ [string] , [string] , [string] ] , feature_names = [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] numerical_struct_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_struct_array_classifier . fit ( futt . NUMERICAL_STRUCT_ARRAY , futt . LABELS ) [EOL] numerical_struct_dummy_surrogate = BaseSurrogateTabularExplainer ( futt . NUMERICAL_STRUCT_ARRAY , numerical_struct_array_classifier , as_probabilistic = False , categorical_indices = [ [string] , [string] ] , class_names = [ [string] , [string] , [string] ] , feature_names = None , classes_number = [number] , unique_predictions = [ [number] , [number] , [number] ] ) [EOL] [EOL] categorical_np_array_classifier = fum . KNN ( k = [number] ) [EOL] categorical_np_array_classifier . fit ( futt . CATEGORICAL_NP_ARRAY , futt . LABELS ) [EOL] categorical_np_dummy_surrogate = BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , categorical_np_array_classifier , categorical_indices = [ [number] , [number] , [number] ] ) [EOL] [EOL] categorical_struct_array_classifier = fum . KNN ( k = [number] ) [EOL] categorical_struct_array_classifier . fit ( futt . CATEGORICAL_STRUCT_ARRAY , futt . LABELS ) [EOL] categorical_struct_dummy_surrogate = BaseSurrogateTabularExplainer ( futt . CATEGORICAL_STRUCT_ARRAY , categorical_struct_array_classifier , categorical_indices = [ [string] , [string] , [string] ] , class_names = [ [string] , [string] , [string] ] , feature_names = [ [string] , [string] , [string] ] ) [EOL] [EOL] mixed_classifier = fum . KNN ( k = [number] ) [EOL] mixed_classifier . fit ( futt . MIXED_ARRAY , futt . LABELS ) [EOL] mixed_dummy_surrogate = BaseSurrogateTabularExplainer ( futt . MIXED_ARRAY , mixed_classifier , categorical_indices = [ [string] , [string] ] , feature_names = [ [string] , [string] , [string] , [string] ] ) [EOL] mixed_dummy_surrogate_reg = BaseSurrogateTabularExplainer ( futt . MIXED_ARRAY , mixed_classifier , as_probabilistic = False , as_regressor = True , categorical_indices = [ [string] , [string] ] , class_names = [ [string] , [string] , [string] ] , classes_number = [number] , unique_predictions = [ [string] , [string] ] , feature_names = [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_surrogate_explainer_init ( self , caplog ) : [EOL] [docstring] [EOL] abstract_method_error = ( [string] [string] ) [EOL] user_warning_features = ( [string] [string] [string] [string] [string] [string] ) [EOL] user_warning_predictions_missing = ( [string] [string] [string] [string] [string] ) [EOL] user_warning_predictions_surplus = ( [string] [string] [string] ) [EOL] user_warning_classes = ( [string] [string] [string] [string] [string] ) [EOL] [EOL] debug_log_class_names = ( [string] [string] ) [EOL] debug_log_unique_predictions = ( [string] [string] [string] ) [EOL] [EOL] classes_number_runtime_error = ( [string] [string] [string] [string] [string] ) [EOL] unique_predictions_runtime_error_different = ( [string] [string] ) [EOL] unique_predictions_runtime_error_number_i = ( [string] [string] [string] ) [EOL] unique_predictions_runtime_error_number_u = ( [string] [string] [string] [string] ) [EOL] class_names_value_error = ( [string] [string] [string] ) [EOL] [EOL] unique_predictions = [ [number] , [number] , [number] ] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . SurrogateTabularExplainer ( futt . NUMERICAL_NP_ARRAY , self . numerical_np_array_classifier ) [EOL] assert str ( exin . value ) == abstract_method_error . format ( [string] ) [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . BrokenSurrogateTabularExplainer ( futt . NUMERICAL_NP_ARRAY , self . numerical_np_array_classifier ) [EOL] assert str ( exin . value ) == abstract_method_error . format ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . BaseSurrogateTabularExplainer ( futt . NUMERICAL_NP_ARRAY , self . numerical_np_array_classifier , as_probabilistic = True , classes_number = [number] ) [EOL] assert str ( exin . value ) == classes_number_runtime_error . format ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . NUMERICAL_STRUCT_ARRAY , self . numerical_struct_array_classifier , as_probabilistic = True , unique_predictions = [ [string] , [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_predictions_surplus [EOL] assert ( surrogate_explainer . predictive_function == self . numerical_struct_array_classifier . predict_proba ) [EOL] assert surrogate_explainer . unique_predictions is None [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False ) [EOL] assert ( surrogate_explainer . predictive_function == self . categorical_np_array_classifier . predict ) [EOL] assert len ( warning ) == [number] [EOL] [comment] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_classes . format ( [number] ) [EOL] assert surrogate_explainer . classes_number == [number] [EOL] [comment] [EOL] assert ( str ( warning [ [number] ] . message ) == user_warning_predictions_missing . format ( unique_predictions ) ) [EOL] assert np . array_equal ( surrogate_explainer . unique_predictions , unique_predictions ) [EOL] assert ( surrogate_explainer . class_names == [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , classes_number = [number] ) [EOL] assert ( str ( exin . value ) == unique_predictions_runtime_error_number_i . format ( [number] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , classes_number = [number] , unique_predictions = [ [number] , [number] ] ) [EOL] assert ( str ( exin . value ) == unique_predictions_runtime_error_number_u . format ( [number] ) ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , classes_number = [number] , unique_predictions = [ [number] , [number] , [number] ] ) [EOL] assert ( str ( exin . value ) == unique_predictions_runtime_error_different . format ( [ [number] ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , unique_predictions = [ [number] , [number] , [number] ] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == debug_log_unique_predictions [EOL] assert surrogate_explainer . classes_number == [number] [EOL] assert ( surrogate_explainer . class_names == [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , class_names = [ [string] , [string] , [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert ( str ( warning [ [number] ] . message ) == user_warning_predictions_missing . format ( unique_predictions ) ) [EOL] assert np . array_equal ( surrogate_explainer . unique_predictions , unique_predictions ) [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == debug_log_class_names [EOL] assert surrogate_explainer . classes_number == [number] [EOL] [comment] [EOL] assert np . array_equal ( surrogate_explainer . feature_names , [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = False , unique_predictions = [ [number] , [number] , [number] ] , classes_number = [number] , class_names = [ [string] , [string] , [string] , [string] ] ) [EOL] assert str ( exin . value ) == class_names_value_error . format ( [number] ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_NP_ARRAY , self . categorical_np_array_classifier , as_probabilistic = True , categorical_indices = [ [number] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_features [EOL] assert np . array_equal ( surrogate_explainer . categorical_indices , [ [number] , [number] , [number] ] ) [EOL] assert np . array_equal ( surrogate_explainer . numerical_indices , [ ] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . CATEGORICAL_STRUCT_ARRAY , self . categorical_struct_array_classifier , as_probabilistic = True , categorical_indices = [ [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_features [EOL] assert np . array_equal ( surrogate_explainer . categorical_indices , [ [string] , [string] , [string] ] ) [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] surrogate_explainer = self . BaseSurrogateTabularExplainer ( futt . MIXED_ARRAY , self . mixed_classifier , as_probabilistic = True , categorical_indices = [ [string] ] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == user_warning_features [EOL] assert np . array_equal ( surrogate_explainer . categorical_indices , [ [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] assert np . array_equal ( self . numerical_dummy_surrogate . dataset , futt . NUMERICAL_NP_ARRAY ) [EOL] assert not self . numerical_dummy_surrogate . is_structured [EOL] assert self . numerical_dummy_surrogate . column_indices == [ [number] , [number] , [number] , [number] ] [EOL] assert self . numerical_dummy_surrogate . categorical_indices == [ [number] ] [EOL] assert self . numerical_dummy_surrogate . numerical_indices == [ [number] , [number] , [number] ] [EOL] assert self . numerical_dummy_surrogate . as_probabilistic [EOL] assert not self . numerical_dummy_surrogate . as_regressor [EOL] [comment] [EOL] assert ( self . numerical_dummy_surrogate . predictive_model == self . numerical_np_array_classifier ) [EOL] assert ( self . numerical_dummy_surrogate . predictive_function == self . numerical_np_array_classifier . predict_proba ) [EOL] assert self . numerical_dummy_surrogate . classes_number == [number] [EOL] assert ( self . numerical_dummy_surrogate . class_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . numerical_dummy_surrogate . feature_names == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . numerical_dummy_surrogate . unique_predictions is None [EOL] [EOL] assert np . array_equal ( self . numerical_dummy_surrogate_reg . dataset , futt . NUMERICAL_NP_ARRAY ) [EOL] assert not self . numerical_dummy_surrogate_reg . is_structured [EOL] assert ( self . numerical_dummy_surrogate_reg . column_indices == [ [number] , [number] , [number] , [number] ] ) [EOL] assert self . numerical_dummy_surrogate_reg . categorical_indices == [ [number] ] [EOL] assert ( self . numerical_dummy_surrogate_reg . numerical_indices == [ [number] , [number] , [number] ] ) [EOL] assert self . numerical_dummy_surrogate_reg . as_probabilistic [EOL] assert self . numerical_dummy_surrogate_reg . as_regressor [EOL] assert ( self . numerical_dummy_surrogate_reg . predictive_model == self . numerical_np_array_classifier ) [EOL] assert ( self . numerical_dummy_surrogate_reg . predictive_function == self . numerical_np_array_classifier . predict ) [EOL] assert self . numerical_dummy_surrogate_reg . classes_number is None [EOL] assert self . numerical_dummy_surrogate_reg . class_names is None [EOL] assert ( self . numerical_dummy_surrogate_reg . feature_names == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . numerical_dummy_surrogate_reg . unique_predictions is None [EOL] [EOL] assert np . array_equal ( self . numerical_struct_dummy_surrogate . dataset , futt . NUMERICAL_STRUCT_ARRAY ) [EOL] assert self . numerical_struct_dummy_surrogate . is_structured [EOL] assert ( self . numerical_struct_dummy_surrogate . column_indices == [ [string] , [string] , [string] , [string] ] ) [EOL] assert ( self . numerical_struct_dummy_surrogate . categorical_indices == [ [string] , [string] ] ) [EOL] assert ( self . numerical_struct_dummy_surrogate . numerical_indices == [ [string] , [string] ] ) [EOL] assert not self . numerical_struct_dummy_surrogate . as_probabilistic [EOL] assert not self . numerical_struct_dummy_surrogate . as_regressor [EOL] assert ( self . numerical_struct_dummy_surrogate . predictive_model == self . numerical_struct_array_classifier ) [EOL] assert ( self . numerical_struct_dummy_surrogate . predictive_function == self . numerical_struct_array_classifier . predict ) [EOL] assert self . numerical_struct_dummy_surrogate . classes_number == [number] [EOL] assert ( self . numerical_struct_dummy_surrogate . class_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . numerical_struct_dummy_surrogate . feature_names == [ [string] , [string] , [string] , [string] ] ) [EOL] assert ( self . numerical_struct_dummy_surrogate . unique_predictions == [ [number] , [number] , [number] ] ) [EOL] [EOL] assert np . array_equal ( self . categorical_np_dummy_surrogate . dataset , futt . CATEGORICAL_NP_ARRAY ) [EOL] assert not self . categorical_np_dummy_surrogate . is_structured [EOL] assert self . categorical_np_dummy_surrogate . column_indices == [ [number] , [number] , [number] ] [EOL] assert ( self . categorical_np_dummy_surrogate . categorical_indices == [ [number] , [number] , [number] ] ) [EOL] assert self . categorical_np_dummy_surrogate . numerical_indices == [ ] [EOL] assert self . categorical_np_dummy_surrogate . as_probabilistic [EOL] assert not self . categorical_np_dummy_surrogate . as_regressor [EOL] assert ( self . categorical_np_dummy_surrogate . predictive_model == self . categorical_np_array_classifier ) [EOL] assert ( self . categorical_np_dummy_surrogate . predictive_function == self . categorical_np_array_classifier . predict_proba ) [EOL] assert self . categorical_np_dummy_surrogate . classes_number == [number] [EOL] assert ( self . categorical_np_dummy_surrogate . class_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . categorical_np_dummy_surrogate . feature_names == [ [string] , [string] , [string] ] ) [EOL] assert self . categorical_np_dummy_surrogate . unique_predictions is None [EOL] [EOL] assert np . array_equal ( self . categorical_struct_dummy_surrogate . dataset , futt . CATEGORICAL_STRUCT_ARRAY ) [EOL] assert self . categorical_struct_dummy_surrogate . is_structured [EOL] assert ( self . categorical_struct_dummy_surrogate . column_indices == [ [string] , [string] , [string] ] ) [EOL] assert ( self . categorical_struct_dummy_surrogate . categorical_indices == [ [string] , [string] , [string] ] ) [EOL] assert self . categorical_struct_dummy_surrogate . numerical_indices == [ ] [EOL] assert self . categorical_struct_dummy_surrogate . as_probabilistic [EOL] assert not self . categorical_struct_dummy_surrogate . as_regressor [EOL] assert ( self . categorical_struct_dummy_surrogate . predictive_model == self . categorical_struct_array_classifier ) [EOL] assert ( self . categorical_struct_dummy_surrogate . predictive_function == self . categorical_struct_array_classifier . predict_proba ) [EOL] assert self . categorical_struct_dummy_surrogate . classes_number == [number] [EOL] assert ( self . categorical_struct_dummy_surrogate . class_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . categorical_struct_dummy_surrogate . feature_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . categorical_struct_dummy_surrogate . unique_predictions is None ) [EOL] [EOL] assert np . array_equal ( self . mixed_dummy_surrogate . dataset , futt . MIXED_ARRAY ) [EOL] assert self . mixed_dummy_surrogate . is_structured [EOL] assert ( self . mixed_dummy_surrogate . column_indices == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . mixed_dummy_surrogate . categorical_indices == [ [string] , [string] ] [EOL] assert self . mixed_dummy_surrogate . numerical_indices == [ [string] , [string] ] [EOL] assert self . mixed_dummy_surrogate . as_probabilistic [EOL] assert not self . mixed_dummy_surrogate . as_regressor [EOL] assert ( self . mixed_dummy_surrogate . predictive_model == self . mixed_classifier ) [EOL] assert ( self . mixed_dummy_surrogate . predictive_function == self . mixed_classifier . predict_proba ) [EOL] assert self . mixed_dummy_surrogate . classes_number == [number] [EOL] assert ( self . mixed_dummy_surrogate . class_names == [ [string] , [string] , [string] ] ) [EOL] assert ( self . mixed_dummy_surrogate . feature_names == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . mixed_dummy_surrogate . unique_predictions is None [EOL] [EOL] assert np . array_equal ( self . mixed_dummy_surrogate_reg . dataset , futt . MIXED_ARRAY ) [EOL] assert self . mixed_dummy_surrogate_reg . is_structured [EOL] assert ( self . mixed_dummy_surrogate_reg . column_indices == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . mixed_dummy_surrogate_reg . categorical_indices == [ [string] , [string] ] [EOL] assert self . mixed_dummy_surrogate_reg . numerical_indices == [ [string] , [string] ] [EOL] assert not self . mixed_dummy_surrogate_reg . as_probabilistic [EOL] assert self . mixed_dummy_surrogate_reg . as_regressor [EOL] assert ( self . mixed_dummy_surrogate_reg . predictive_model == self . mixed_classifier ) [EOL] assert ( self . mixed_dummy_surrogate_reg . predictive_function == self . mixed_classifier . predict ) [EOL] assert self . mixed_dummy_surrogate_reg . classes_number is None [EOL] assert self . mixed_dummy_surrogate_reg . class_names is None [EOL] assert ( self . mixed_dummy_surrogate_reg . feature_names == [ [string] , [string] , [string] , [string] ] ) [EOL] assert self . mixed_dummy_surrogate_reg . unique_predictions is None [EOL] [comment] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] def test_explain_instance_validation ( self ) : [EOL] [docstring] [EOL] incorrect_shape_data_row = ( [string] [string] [string] ) [EOL] type_error_data_row = ( [string] [string] [string] ) [EOL] incorrect_shape_features = ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] self . numerical_dummy_surrogate . explain_instance ( futt . NUMERICAL_NP_ARRAY ) [EOL] assert str ( exin . value ) == incorrect_shape_data_row [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] self . numerical_struct_dummy_surrogate . explain_instance ( futt . NUMERICAL_STRUCT_ARRAY ) [EOL] assert str ( exin . value ) == incorrect_shape_data_row [EOL] [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_dummy_surrogate . explain_instance ( np . array ( [ [string] , [string] , [string] , [string] ] ) ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_struct_dummy_surrogate . explain_instance ( futt . MIXED_ARRAY [ [number] ] ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . categorical_np_dummy_surrogate . explain_instance ( np . array ( [ [number] ] ) ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [comment] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_struct_dummy_surrogate . explain_instance ( futt . MIXED_ARRAY [ [ [string] , [string] ] ] [ [number] ] ) [EOL] assert str ( exin . value ) == type_error_data_row [EOL] [EOL] [comment] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] self . numerical_dummy_surrogate . explain_instance ( np . array ( [ [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] self . categorical_np_dummy_surrogate . explain_instance ( np . array ( [ [string] , [string] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_features [EOL] [EOL] [EOL] @ pytest . mark . skipif ( SKLEARN_MISSING , reason = [string] ) class TestTabularBlimeyLime ( object ) : [EOL] [docstring] [EOL] if not SKLEARN_MISSING : [EOL] numerical_np_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_np_array_classifier . fit ( futt . NUMERICAL_NP_ARRAY , futt . LABELS ) [EOL] numerical_np_tabular_lime = ftps . TabularBlimeyLime ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier ) [EOL] numerical_np_tabular_lime_reg = ftps . TabularBlimeyLime ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier , as_regressor = True ) [EOL] [EOL] wide_data = np . concatenate ( [number] * [ futt . NUMERICAL_NP_ARRAY ] , axis = [number] ) [EOL] numerical_np_array_classifier_wide = fum . KNN ( k = [number] ) [EOL] numerical_np_array_classifier_wide . fit ( wide_data , futt . LABELS ) [EOL] numerical_np_tabular_lime_wide_reg = ftps . TabularBlimeyLime ( wide_data , numerical_np_array_classifier_wide , as_regressor = True ) [EOL] [EOL] numerical_struct_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_struct_array_classifier . fit ( futt . NUMERICAL_STRUCT_ARRAY , futt . LABELS ) [EOL] numerical_struct_cat_tabular_lime = ftps . TabularBlimeyLime ( futt . NUMERICAL_STRUCT_ARRAY , numerical_struct_array_classifier , categorical_indices = [ [string] , [string] ] ) [EOL] [EOL] categorical_array_classifier = fum . KNN ( k = [number] ) [EOL] categorical_array_classifier . fit ( futt . CATEGORICAL_NP_ARRAY , futt . LABELS ) [EOL] categorical_np_lime = ftps . TabularBlimeyLime ( futt . CATEGORICAL_NP_ARRAY , categorical_array_classifier , categorical_indices = [ [number] , [number] , [number] ] ) [EOL] [EOL] iris_classifier = fum . KNN ( k = [number] ) [EOL] iris_classifier . fit ( IRIS_DATASET [ [string] ] , IRIS_DATASET [ [string] ] ) [EOL] iris_lime = ftps . TabularBlimeyLime ( IRIS_DATASET [ [string] ] , iris_classifier , class_names = IRIS_DATASET [ [string] ] . tolist ( ) , feature_names = IRIS_DATASET [ [string] ] . tolist ( ) ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] assert ( self . numerical_np_tabular_lime . __class__ . __bases__ [ [number] ] . __name__ == [string] ) [EOL] [comment] [EOL] [EOL] numerical_bin_sampling_values = { [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , np . nan , np . nan ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , np . nan , np . nan ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , np . inf , np . nan , np . nan ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } } [EOL] numerical_struct_sampling_values = { [string] : numerical_bin_sampling_values [ [number] ] , [string] : numerical_bin_sampling_values [ [number] ] } [EOL] iris_lime_sampling_values = { [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } , [number] : { [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) , [number] : ( [number] , [number] , [number] , [number] ) } } [EOL] [EOL] [comment] [EOL] assert ( self . numerical_np_tabular_lime . numerical_indices == [ [number] , [number] , [number] , [number] ] ) [EOL] [comment] [EOL] assert self . numerical_np_tabular_lime . categorical_indices == [ ] [EOL] assert isinstance ( self . numerical_np_tabular_lime . discretiser , fudd . QuartileDiscretiser ) [EOL] assert isinstance ( self . numerical_np_tabular_lime . augmenter , fuda . NormalSampling ) [EOL] assert futt . is_explanation_equal_dict ( self . numerical_np_tabular_lime . bin_sampling_values , numerical_bin_sampling_values ) [EOL] [EOL] [comment] [EOL] assert ( self . numerical_struct_cat_tabular_lime . numerical_indices == [ [string] , [string] ] ) [EOL] assert ( self . numerical_struct_cat_tabular_lime . categorical_indices == [ [string] , [string] ] ) [EOL] [comment] [EOL] assert isinstance ( self . numerical_struct_cat_tabular_lime . augmenter , fuda . NormalSampling ) [EOL] assert isinstance ( self . numerical_struct_cat_tabular_lime . discretiser , fudd . QuartileDiscretiser ) [EOL] assert futt . is_explanation_equal_dict ( self . numerical_struct_cat_tabular_lime . bin_sampling_values , numerical_struct_sampling_values ) [EOL] [EOL] assert self . categorical_np_lime . numerical_indices == [ ] [EOL] assert self . categorical_np_lime . categorical_indices == [ [number] , [number] , [number] ] [EOL] assert isinstance ( self . categorical_np_lime . augmenter , fuda . NormalSampling ) [EOL] assert isinstance ( self . categorical_np_lime . discretiser , fudd . QuartileDiscretiser ) [EOL] assert self . categorical_np_lime . bin_sampling_values == { } [EOL] [EOL] assert self . iris_lime . numerical_indices == [ [number] , [number] , [number] , [number] ] [EOL] assert self . iris_lime . categorical_indices == [ ] [EOL] assert isinstance ( self . iris_lime . augmenter , fuda . NormalSampling ) [EOL] assert isinstance ( self . iris_lime . discretiser , fudd . QuartileDiscretiser ) [EOL] assert futt . is_explanation_equal_dict ( self . iris_lime . bin_sampling_values , iris_lime_sampling_values ) [EOL] [EOL] def test_explain_instance_input_is_valid ( self ) : [EOL] [docstring] [EOL] explained_class_type = ( [string] [string] ) [EOL] samples_number_type = ( [string] [string] ) [EOL] samples_number_value = ( [string] [string] ) [EOL] features_number_type = ( [string] [string] ) [EOL] features_number_value = ( [string] [string] ) [EOL] kernel_width_type = ( [string] [string] ) [EOL] kernel_width_value = ( [string] [string] ) [EOL] return_models_type = [string] [EOL] [EOL] instance = futt . NUMERICAL_NP_ARRAY [ [number] ] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , [number] , None , None , None , None ) [EOL] assert str ( exin . value ) == explained_class_type [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [string] , None , None , None ) [EOL] assert str ( exin . value ) == samples_number_type [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , - [number] , None , None , None ) [EOL] assert str ( exin . value ) == samples_number_value [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , [string] , None , None ) [EOL] assert str ( exin . value ) == features_number_type [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , - [number] , None , None ) [EOL] assert str ( exin . value ) == features_number_value [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , None , [string] , None ) [EOL] assert str ( exin . value ) == kernel_width_type [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , None , - [number] , None ) [EOL] assert str ( exin . value ) == kernel_width_value [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , None , None , None ) [EOL] assert str ( exin . value ) == return_models_type [EOL] [EOL] [comment] [EOL] assert self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , None , None , False ) [EOL] assert self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , None , [number] , False ) [EOL] assert self . numerical_np_tabular_lime . _explain_instance_input_is_valid ( instance , None , [number] , [number] , [number] , False ) [EOL] [EOL] def test_undiscretise_data ( self ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] [comment] [EOL] impossible_point = [string] [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . numerical_np_tabular_lime . _undiscretise_data ( np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == impossible_point [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . numerical_np_tabular_lime . _undiscretise_data ( np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == impossible_point [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . numerical_np_tabular_lime . _undiscretise_data ( np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == impossible_point [EOL] with pytest . raises ( AssertionError ) as exin : [EOL] self . numerical_np_tabular_lime . _undiscretise_data ( np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == impossible_point [EOL] [EOL] udata = self . numerical_np_tabular_lime . _undiscretise_data ( np . array ( [ [ [number] , [number] , [number] , [number] ] ] ) ) [EOL] assert np . allclose ( udata , [ [ [number] , [number] , [number] , [number] ] ] , atol = [number] ) [EOL] [EOL] dtype = futt . NUMERICAL_STRUCT_ARRAY . dtype [EOL] udata = self . numerical_struct_cat_tabular_lime . _undiscretise_data ( np . array ( [ ( [number] , [number] , [number] , [number] ) ] , dtype = dtype ) ) [EOL] assert np . allclose ( fuat . as_unstructured ( udata ) , [ [ [number] , [number] , [number] , [number] ] ] , atol = [number] ) [EOL] [EOL] def test_explain_instance_errors ( self ) : [EOL] [docstring] [EOL] explain_class_value_error1 = ( [string] [string] [string] ) [EOL] explain_class_value_error2 = ( [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_lime . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , explained_class = [string] ) [EOL] assert str ( exin . value ) == explain_class_value_error1 . format ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_lime . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , explained_class = [number] ) [EOL] assert str ( exin . value ) == explain_class_value_error2 . format ( [number] , [number] ) [EOL] [EOL] def test_explain_instance ( self , caplog ) : [EOL] [docstring] [EOL] assert len ( caplog . records ) == [number] [EOL] fatf . setup_random_seed ( ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == ( [string] [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] log_info_forward_selection = ( [string] [string] ) [EOL] log_info_highest_weights = ( [string] [string] ) [EOL] [EOL] numerical_np_explanation = { [string] : { [string] : - [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] } } [EOL] numerical_np_explanation_reg = { [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : - [number] } [EOL] numerical_np_explanation_wide_reg = { [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] , [string] : - [number] , [string] : [number] , [string] : [number] } [EOL] numerical_np_explanation_wide_reg_all = { [string] : [number] , [string] : - [number] , [string] : [number] , [string] : - [number] , [string] : [number] , [string] : - [number] , [string] : - [number] , [string] : [number] } [EOL] numerical_struct_explanation = { [string] : { [string] : - [number] , [string] : [number] } , [string] : { [string] : - [number] , [string] : - [number] } , [string] : { [string] : [number] , [string] : - [number] } } [EOL] categorical_np_explanation = { [string] : { [string] : [number] , [string] : - [number] } , [string] : { [string] : - [number] , [string] : - [number] } , [string] : { [string] : [number] , [string] : [number] } } [EOL] iris_explanation = { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : - [number] , [string] : [number] } , [string] : { [string] : - [number] , [string] : - [number] } } [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [comment] [EOL] explanation = self . numerical_np_tabular_lime . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = None ) [EOL] assert futt . is_explanation_equal_dict ( numerical_np_explanation , explanation , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] explanation = self . numerical_struct_cat_tabular_lime . explain_instance ( futt . NUMERICAL_STRUCT_ARRAY [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = None ) [EOL] assert futt . is_explanation_equal_dict ( numerical_struct_explanation , explanation , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] explanation = self . categorical_np_lime . explain_instance ( futt . CATEGORICAL_NP_ARRAY [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = None ) [EOL] assert futt . is_explanation_equal_dict ( categorical_np_explanation , explanation , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] explanation , models = self . iris_lime . explain_instance ( IRIS_DATASET [ [string] ] [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = None , return_models = True ) [EOL] assert futt . is_explanation_equal_dict ( iris_explanation , explanation , atol = [number] ) [EOL] for key , model in models . items ( ) : [EOL] assert np . allclose ( sorted ( list ( iris_explanation [ key ] . values ( ) ) ) , sorted ( model . coef_ . tolist ( ) ) , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] explanation = self . iris_lime . explain_instance ( IRIS_DATASET [ [string] ] [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = [number] , explained_class = [string] ) [EOL] explanation_ = { [string] : { [string] : [number] } } [EOL] assert futt . is_explanation_equal_dict ( explanation , explanation_ , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] explanation = self . iris_lime . explain_instance ( IRIS_DATASET [ [string] ] [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = [number] , explained_class = [number] ) [EOL] explanation_ = { [string] : { [string] : - [number] } } [EOL] assert futt . is_explanation_equal_dict ( explanation , explanation_ , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] [comment] [EOL] explanation = self . numerical_np_tabular_lime_reg . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , features_number = [number] , kernel_width = None ) [EOL] assert futt . is_explanation_equal_dict ( { [string] : numerical_np_explanation_reg } , { [string] : explanation } , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_forward_selection . format ( [number] ) ) [EOL] [EOL] [comment] [EOL] explanation = self . numerical_np_tabular_lime_wide_reg . explain_instance ( self . wide_data [ [number] ] , samples_number = [number] , features_number = [number] ) [EOL] assert futt . is_explanation_equal_dict ( { [string] : numerical_np_explanation_wide_reg } , { [string] : explanation } , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_highest_weights . format ( [number] ) ) [EOL] [comment] [EOL] explanation = self . numerical_np_tabular_lime_wide_reg . explain_instance ( self . wide_data [ [number] ] , samples_number = [number] ) [EOL] assert futt . is_explanation_equal_dict ( { [string] : numerical_np_explanation_wide_reg_all } , { [string] : explanation } , atol = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == log_info_highest_weights . format ( [number] ) ) [EOL] [EOL] [EOL] def map_target ( target ) : [EOL] [docstring] [EOL] categorical_target = [ ] [EOL] for i in target : [EOL] if i == [number] : [EOL] categorical_target . append ( [string] ) [EOL] elif i == [number] : [EOL] categorical_target . append ( [string] ) [EOL] elif i == [number] : [EOL] categorical_target . append ( [string] ) [EOL] else : [EOL] assert False , [string] [comment] [EOL] return np . array ( categorical_target ) [EOL] [EOL] [EOL] @ pytest . mark . skipif ( SKLEARN_MISSING , reason = [string] ) class TestTabularBlimeyTree ( object ) : [EOL] [docstring] [EOL] if not SKLEARN_MISSING : [EOL] numerical_np_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_np_array_classifier . fit ( futt . NUMERICAL_NP_ARRAY , futt . LABELS ) [EOL] numerical_np_tabular_blimey = ftps . TabularBlimeyTree ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier ) [EOL] numerical_np_tabular_blimey_reg = ftps . TabularBlimeyTree ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier , as_regressor = True ) [EOL] [EOL] numerical_np_array_classifier_noprob = fum . KNN ( k = [number] ) [EOL] numerical_np_array_classifier_noprob . fit ( futt . NUMERICAL_NP_ARRAY , map_target ( futt . LABELS ) ) [EOL] numerical_np_tabular_blimey_noprob = ftps . TabularBlimeyTree ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier_noprob , as_probabilistic = False , classes_number = [number] , unique_predictions = [ [string] , [string] , [string] ] , class_names = [ [string] , [string] , [string] ] ) [EOL] [EOL] numerical_struct_array_classifier = fum . KNN ( k = [number] ) [EOL] numerical_struct_array_classifier . fit ( futt . NUMERICAL_STRUCT_ARRAY , futt . LABELS ) [EOL] numerical_np_cat_tabular_blimey = ftps . TabularBlimeyTree ( futt . NUMERICAL_NP_ARRAY , numerical_np_array_classifier , categorical_indices = [ [number] , [number] ] ) [EOL] [EOL] iris_classifier = fum . KNN ( k = [number] ) [EOL] iris_classifier . fit ( IRIS_DATASET [ [string] ] , IRIS_DATASET [ [string] ] ) [EOL] iris_blimey = ftps . TabularBlimeyTree ( IRIS_DATASET [ [string] ] , iris_classifier , class_names = IRIS_DATASET [ [string] ] . tolist ( ) , feature_names = IRIS_DATASET [ [string] ] . tolist ( ) ) [EOL] [EOL] def test_init ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] assert ( self . numerical_np_tabular_blimey . __class__ . __bases__ [ [number] ] . __name__ == [string] ) [EOL] [comment] [EOL] [EOL] string_array_error = ( [string] [string] [string] [string] ) [EOL] structured_array_error = ( [string] [string] [string] [string] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . TabularBlimeyTree ( futt . NUMERICAL_STRUCT_ARRAY , self . numerical_struct_array_classifier ) [EOL] assert str ( exin . value ) == structured_array_error [EOL] [EOL] categorical_array_classifier = fum . KNN ( k = [number] ) [EOL] categorical_array_classifier . fit ( futt . CATEGORICAL_NP_ARRAY , futt . LABELS ) [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ftps . TabularBlimeyTree ( futt . CATEGORICAL_NP_ARRAY , categorical_array_classifier ) [EOL] assert str ( exin . value ) == string_array_error [EOL] [EOL] [comment] [EOL] assert ( self . numerical_np_tabular_blimey . numerical_indices == [ [number] , [number] , [number] , [number] ] ) [EOL] assert self . numerical_np_tabular_blimey . categorical_indices == [ ] [EOL] assert isinstance ( self . numerical_np_tabular_blimey . augmenter , fuda . Mixup ) [EOL] [EOL] assert ( self . numerical_np_cat_tabular_blimey . numerical_indices == [ [number] , [number] ] ) [EOL] assert ( self . numerical_np_cat_tabular_blimey . categorical_indices == [ [number] , [number] ] ) [EOL] assert isinstance ( self . numerical_np_tabular_blimey . augmenter , fuda . Mixup ) [EOL] [EOL] def test_explain_instance_input_is_valid ( self ) : [EOL] [docstring] [EOL] explained_class_type = ( [string] [string] ) [EOL] one_vs_rest_type = ( [string] [string] ) [EOL] samples_number_type = ( [string] [string] ) [EOL] samples_number_value = ( [string] [string] ) [EOL] maximum_depth_type = [string] [EOL] maximum_depth_value = ( [string] [string] ) [EOL] return_models_type = [string] [EOL] [EOL] array = futt . NUMERICAL_NP_ARRAY [ [number] ] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , None , None , None , None ) [EOL] assert str ( exin . value ) == explained_class_type [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , [string] , None , None , None ) [EOL] assert str ( exin . value ) == one_vs_rest_type [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , None , None , None , None ) [EOL] assert str ( exin . value ) == one_vs_rest_type [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , None , False , None , None , None ) [EOL] assert str ( exin . value ) == samples_number_type [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , None , False , [string] , None , None ) [EOL] assert str ( exin . value ) == samples_number_type [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [string] , True , [number] , None , None ) [EOL] assert str ( exin . value ) == samples_number_value [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , False , [number] , None , None ) [EOL] assert str ( exin . value ) == maximum_depth_type [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , False , [number] , [string] , None ) [EOL] assert str ( exin . value ) == maximum_depth_type [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , None , True , [number] , [number] , None ) [EOL] assert str ( exin . value ) == maximum_depth_value [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , False , [number] , [number] , None ) [EOL] assert str ( exin . value ) == return_models_type [EOL] [EOL] [comment] [EOL] assert self . numerical_np_tabular_blimey . _explain_instance_input_is_valid ( array , [string] , False , [number] , [number] , False ) [EOL] assert self . numerical_np_cat_tabular_blimey . _explain_instance_input_is_valid ( array , [number] , True , [number] , [number] , False ) [EOL] [EOL] def test_get_local_model ( self ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] one_runtime_error = ( [string] [string] [string] [string] ) [EOL] multi_runtime_error = ( [string] [string] [string] ) [EOL] [EOL] sampled_data = np . array ( [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] ) [EOL] sampled_data_predictions_prob = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] sampled_data_predictions_noprob_cat = np . array ( [ [string] , [string] , [string] ] ) [EOL] sampled_data_predictions_noprob_err_cat = np . array ( [ [string] , [string] , [string] ] ) [EOL] [EOL] tree_thresholds = np . array ( [ [number] , - [number] , - [number] ] ) [EOL] [EOL] [comment] [EOL] model = self . numerical_np_tabular_blimey . _get_local_model ( sampled_data , sampled_data_predictions_prob , [number] , True , [number] ) [EOL] assert np . array_equal ( model . tree_ . threshold , tree_thresholds ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . numerical_np_tabular_blimey_noprob . _get_local_model ( sampled_data , sampled_data_predictions_noprob_err_cat , [number] , True , [number] ) [EOL] assert str ( exin . value ) == one_runtime_error . format ( [string] , [number] , [string] ) [EOL] [EOL] model = self . numerical_np_tabular_blimey_noprob . _get_local_model ( sampled_data , sampled_data_predictions_noprob_cat , [number] , True , [number] ) [EOL] assert np . array_equal ( model . tree_ . threshold , tree_thresholds ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] self . numerical_np_tabular_blimey_noprob . _get_local_model ( sampled_data , sampled_data_predictions_noprob_err_cat , [number] , False , [number] ) [EOL] assert str ( exin . value ) == multi_runtime_error . format ( [string] ) [EOL] [EOL] model = self . numerical_np_tabular_blimey_noprob . _get_local_model ( sampled_data , sampled_data_predictions_noprob_cat , [number] , False , [number] ) [EOL] assert np . array_equal ( model . tree_ . threshold , tree_thresholds ) [EOL] [EOL] def test_explain_instance ( self , caplog ) : [EOL] [docstring] [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] probabilistic_user_warning = ( [string] [string] [string] [string] [string] [string] ) [EOL] nonprobabilistic_user_warning = ( [string] [string] [string] [string] [string] ) [EOL] [EOL] nonprobabilistic_debug_log_prediction = ( [string] [string] ) [EOL] nonprobabilistic_debug_log_class = ( [string] [string] ) [EOL] nonprobabilistic_debug_log_int = ( [string] [string] ) [EOL] [EOL] nonprobabilistic_info_log = ( [string] [string] [string] [string] [string] ) [EOL] [EOL] probabilistic_value_error_str = ( [string] [string] [string] ) [EOL] probabilistic_value_error_int = ( [string] [string] [string] ) [EOL] [EOL] nonprobabilistic_value_error_int = ( [string] [string] [string] [string] ) [EOL] nonprobabilistic_value_error = ( [string] [string] [string] [string] ) [EOL] [EOL] mixup_warning = ( [string] [string] [string] [string] [string] ) [EOL] [EOL] numerical_np_explanation = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] numerical_np_explanation_reg = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] numerical_np_cat_explanation = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] iris_explanation = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) . startswith ( [string] ) [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] explanation = self . numerical_np_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] ) [EOL] assert futt . is_explanation_equal_dict ( numerical_np_explanation , explanation , atol = [number] ) [EOL] [EOL] explanation = self . numerical_np_cat_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] ) [EOL] assert futt . is_explanation_equal_dict ( numerical_np_cat_explanation , explanation , atol = [number] ) [EOL] [EOL] explanation = self . iris_blimey . explain_instance ( IRIS_DATASET [ [string] ] [ [number] ] , samples_number = [number] , maximum_depth = [number] ) [EOL] assert futt . is_explanation_equal_dict ( iris_explanation , explanation , atol = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , explained_class = [string] ) [EOL] assert str ( exin . value ) == probabilistic_value_error_str . format ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , explained_class = [number] ) [EOL] assert str ( exin . value ) == probabilistic_value_error_int . format ( [number] , [number] ) [EOL] [EOL] explanation_ = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] keys_ = [ [string] ] [EOL] thresholds_ = np . array ( [ [number] , [number] , - [number] , - [number] , - [number] ] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] return_ = self . numerical_np_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , one_vs_rest = False , explained_class = [number] , return_models = True ) [EOL] explanation , models = return_ [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == probabilistic_user_warning [EOL] assert futt . is_explanation_equal_dict ( explanation_ , explanation , atol = [number] ) [EOL] assert list ( models . keys ( ) ) == keys_ [EOL] assert np . allclose ( models [ keys_ [ [number] ] ] . tree_ . threshold , thresholds_ , atol = [number] ) [EOL] [EOL] [comment] [EOL] explanation_ = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] explanation = self . numerical_np_tabular_blimey . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , explained_class = [string] ) [EOL] assert futt . is_explanation_equal_dict ( explanation_ , explanation , atol = [number] ) [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] exp = self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , one_vs_rest = False , explained_class = [string] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == nonprobabilistic_user_warning [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == nonprobabilistic_debug_log_prediction ) [EOL] [comment] [EOL] exp_ = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] assert futt . is_explanation_equal_dict ( exp_ , exp , atol = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] exp_ = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] exp = self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , one_vs_rest = True , explained_class = [string] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == nonprobabilistic_debug_log_class ) [EOL] assert futt . is_explanation_equal_dict ( exp_ , exp , atol = [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] exp_ = { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] exp = self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , one_vs_rest = True , explained_class = [number] ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert ( caplog . records [ [number] ] . getMessage ( ) == nonprobabilistic_debug_log_int ) [EOL] assert futt . is_explanation_equal_dict ( exp_ , exp , atol = [number] ) [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , one_vs_rest = True , explained_class = [number] ) [EOL] assert str ( exin . value ) == nonprobabilistic_value_error_int . format ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , one_vs_rest = True , explained_class = [string] ) [EOL] assert str ( exin . value ) == nonprobabilistic_value_error . format ( [ [string] , [string] , [string] ] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] exp = self . numerical_np_tabular_blimey_noprob . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] , one_vs_rest = False ) [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == nonprobabilistic_info_log [EOL] [comment] [EOL] [comment] [EOL] exp_uni = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] exp_ = { k : exp_uni for k in exp } [EOL] assert futt . is_explanation_equal_dict ( exp_ , exp , atol = [number] ) [EOL] [EOL] [comment] [EOL] with pytest . warns ( UserWarning ) as warning : [EOL] exp = self . numerical_np_tabular_blimey_reg . explain_instance ( futt . NUMERICAL_NP_ARRAY [ [number] ] , samples_number = [number] , maximum_depth = [number] ) [EOL] assert len ( warning ) == [number] [EOL] assert str ( warning [ [number] ] . message ) == mixup_warning [EOL] assert futt . is_explanation_equal_dict ( { [string] : numerical_np_explanation_reg } , { [string] : exp } , atol = [number] ) [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $fatf.transparency.predictions.tests.test_surrogate_explainers.TestSurrogateTabularExplainer.BaseSurrogateTabularExplainer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]],typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,unknown,unknown]],typing.Dict[builtins.int,typing.Tuple[builtins.float,unknown,unknown,unknown]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Dict[builtins.int,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List , Type , Tuple [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] import fatf . fairness . predictions . measures as ffpm [EOL] import fatf . utils . models as fum [EOL] [EOL] [EOL] def test_counterfactual_fairness ( ) : [EOL] [docstring] [EOL] dataset_struct = np . array ( [ ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) ] , dtype = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , float ) , ( [string] , [string] ) ] ) [EOL] target = np . array ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] knn_struct = fum . KNN ( k = [number] ) [EOL] knn_struct . fit ( dataset_struct , target ) [EOL] [EOL] cfs , cfs_dist , cfs_pred = ffpm . counterfactual_fairness ( dataset_struct [ [number] ] , [ [string] , [string] ] , model = knn_struct , dataset = dataset_struct ) [EOL] [EOL] t_cfs = np . array ( [ ( [string] , [string] , [number] , [string] ) , ( [string] , [string] , [number] , [string] ) ] , dtype = dataset_struct . dtype ) [EOL] t_dist = np . array ( [number] * [ [number] ] ) [EOL] t_pred = np . array ( [number] * [ [string] ] ) [EOL] assert np . array_equal ( cfs , t_cfs ) [EOL] assert np . allclose ( cfs_dist , t_dist ) [EOL] assert np . array_equal ( cfs_pred , t_pred ) [EOL] [EOL] [EOL] def test_counterfactual_fairness_check ( ) : [EOL] [docstring] [EOL] incorrect_shape_cf = ( [string] [string] ) [EOL] incorrect_shape_dist = ( [string] [string] ) [EOL] value_error_dist = [string] [EOL] type_error_threshold = [string] [EOL] runtime_error = ( [string] [string] [string] ) [EOL] [EOL] struct_dtype = [ ( [string] , int ) , ( [string] , int ) , ( [string] , int ) ] [EOL] [EOL] one_d_array = np . array ( [ [number] , [number] ] ) [EOL] one_d_array_str = np . array ( [ [string] , [string] ] ) [EOL] two_d_array = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] two_d_array_struct = np . array ( [ ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ] , dtype = struct_dtype ) [EOL] [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( ) [EOL] assert str ( exin . value ) == runtime_error [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( distances = [string] ) [EOL] assert str ( exin . value ) == runtime_error [EOL] with pytest . raises ( RuntimeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( threshold = [string] ) [EOL] assert str ( exin . value ) == runtime_error [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( unfair_counterfactuals = one_d_array ) [EOL] assert str ( exin . value ) == incorrect_shape_cf [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( distances = two_d_array , threshold = [number] ) [EOL] assert str ( exin . value ) == incorrect_shape_dist [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( distances = one_d_array_str , threshold = [number] ) [EOL] assert str ( exin . value ) == value_error_dist [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ffpm . counterfactual_fairness_check ( distances = one_d_array , threshold = [string] ) [EOL] assert str ( exin . value ) == type_error_threshold [EOL] [EOL] [comment] [EOL] assert ffpm . counterfactual_fairness_check ( unfair_counterfactuals = two_d_array ) [EOL] assert not ffpm . counterfactual_fairness_check ( unfair_counterfactuals = np . ndarray ( ( [number] , [number] ) ) ) [EOL] assert ffpm . counterfactual_fairness_check ( unfair_counterfactuals = two_d_array_struct ) [EOL] assert not ffpm . counterfactual_fairness_check ( unfair_counterfactuals = np . ndarray ( ( [number] , ) , dtype = struct_dtype ) ) [EOL] [EOL] assert not ffpm . counterfactual_fairness_check ( distances = one_d_array , threshold = [number] ) [EOL] assert ffpm . counterfactual_fairness_check ( distances = one_d_array , threshold = [number] ) [EOL] [EOL] [comment] [EOL] assert ffpm . counterfactual_fairness_check ( unfair_counterfactuals = two_d_array , distances = [string] ) [EOL] assert ffpm . counterfactual_fairness_check ( unfair_counterfactuals = two_d_array , threshold = [string] ) [EOL] [EOL] [comment] [EOL] assert not ffpm . counterfactual_fairness_check ( unfair_counterfactuals = two_d_array , distances = one_d_array , threshold = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . fairness . models . measures as ffmm [EOL] [EOL] [comment] [EOL] CM1 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [comment] [EOL] CM2 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [comment] [EOL] CM3 = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] CM_LIST = [ CM1 , CM2 , CM3 ] [EOL] [EOL] GROUND_TRUTH = np . array ( [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] ) [comment] [EOL] PREDICTIONS = np . array ( [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] + [number] * [ [string] ] ) [comment] [EOL] [EOL] [EOL] def test_validate_tolerance ( ) : [EOL] [docstring] [EOL] value_error = [string] [EOL] type_error = [string] [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ffmm . _validate_tolerance ( [string] ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffmm . _validate_tolerance ( - [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffmm . _validate_tolerance ( [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] assert ffmm . _validate_tolerance ( [number] ) [EOL] [EOL] [EOL] def test_equal_accuracy ( ) : [EOL] [docstring] [EOL] ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] not_ok_array = np . array ( [ [ False , False , False ] , [ False , False , False ] , [ False , False , False ] ] ) [EOL] [EOL] disparity = ffmm . equal_accuracy ( CM_LIST ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . equal_accuracy ( CM_LIST , tolerance = [number] ) [EOL] assert np . array_equal ( disparity , not_ok_array ) [EOL] [EOL] [EOL] def test_equal_opportunity ( ) : [EOL] [docstring] [EOL] ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] not_ok_array = np . array ( [ [ False , False , True ] , [ False , False , False ] , [ True , False , False ] ] ) [EOL] [EOL] disparity = ffmm . equal_opportunity ( CM_LIST ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . equal_opportunity ( CM_LIST , label_index = [number] ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . equal_opportunity ( CM_LIST , tolerance = [number] ) [EOL] assert np . array_equal ( disparity , not_ok_array ) [EOL] [EOL] [EOL] def test_demographic_parity ( ) : [EOL] [docstring] [EOL] ok_array = np . array ( [ [ False , True , True ] , [ True , False , False ] , [ True , False , False ] ] ) [EOL] not_ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] [EOL] disparity = ffmm . demographic_parity ( CM_LIST ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . demographic_parity ( CM_LIST , label_index = [number] ) [EOL] assert np . array_equal ( disparity , not_ok_array ) [EOL] [EOL] disparity = ffmm . demographic_parity ( CM_LIST , label_index = [number] , tolerance = [number] ) [EOL] assert not disparity . any ( ) [EOL] [EOL] [EOL] def test_disparate_impact_check ( ) : [EOL] [docstring] [EOL] ok_array = np . array ( [ [ False , False ] , [ False , False ] ] ) [EOL] not_ok_array = np . array ( [ [ False , True ] , [ True , False ] ] ) [EOL] [EOL] assert not ffmm . disparate_impact_check ( ok_array ) [EOL] assert ffmm . disparate_impact_check ( not_ok_array ) [EOL] [EOL] [EOL] def test_disparate_impact_grid ( ) : [EOL] [docstring] [EOL] type_error = ( [string] [string] [string] ) [EOL] value_error = ( [string] [string] [string] ) [EOL] [EOL] ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] not_ok_array = np . array ( [ [ False , True , True ] , [ True , False , False ] , [ True , False , False ] ] ) [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ffmm . _disparate_impact_grid ( [number] , [number] , [number] , [number] ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffmm . _disparate_impact_grid ( [number] , [string] , [number] , [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] disparity = ffmm . _disparate_impact_grid ( CM_LIST , None , [number] , [number] ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . _disparate_impact_grid ( CM_LIST , [string] , [number] , [number] ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . _disparate_impact_grid ( CM_LIST , [string] , [number] , [number] ) [comment] [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] disparity = ffmm . _disparate_impact_grid ( CM_LIST , [string] , [number] , [number] ) [comment] [EOL] assert np . array_equal ( disparity , not_ok_array ) [EOL] [EOL] [EOL] def test_disparate_impact_indexed ( ) : [EOL] [docstring] [EOL] grouping = [ [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] + list ( range ( [number] , [number] ) ) ] [comment] [EOL] [EOL] disparity = ffmm . disparate_impact_indexed ( grouping , GROUND_TRUTH , PREDICTIONS ) [EOL] ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL] [EOL] [EOL] def test_disparate_impact ( ) : [EOL] [docstring] [EOL] dataset = np . array ( [ * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) , * ( [number] * [ [ [string] , [string] ] ] ) ] ) [EOL] [EOL] disparity , bin_names = ffmm . disparate_impact ( dataset , GROUND_TRUTH , PREDICTIONS , [number] ) [EOL] [EOL] assert bin_names == [ [string] , [string] , [string] ] [EOL] ok_array = np . array ( [ [ False , False , True ] , [ False , False , True ] , [ True , True , False ] ] ) [EOL] assert np . array_equal ( disparity , ok_array ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] from fatf . exceptions import IncorrectShapeError [EOL] [EOL] import fatf . fairness . data . measures as ffdm [EOL] [EOL] [EOL] def test_systemic_bias ( ) : [EOL] [docstring] [EOL] incorrect_shape_data = [string] [EOL] incorrect_shape_gt = ( [string] [string] ) [EOL] incorrect_shape_length = ( [string] [string] ) [EOL] index_error = ( [string] [string] ) [EOL] type_error = [string] [EOL] value_error = [string] [EOL] [EOL] one_d_array = np . array ( [ [number] , [number] ] ) [EOL] two_d_array = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffdm . systemic_bias ( one_d_array , two_d_array , None ) [EOL] assert str ( exin . value ) == incorrect_shape_data [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffdm . systemic_bias ( two_d_array , two_d_array , None ) [EOL] assert str ( exin . value ) == incorrect_shape_gt [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffdm . systemic_bias ( two_d_array , np . array ( [ [number] , [number] , [number] ] ) , None ) [EOL] assert str ( exin . value ) == incorrect_shape_length [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ffdm . systemic_bias ( two_d_array , one_d_array , None ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( IndexError ) as exin : [EOL] ffdm . systemic_bias ( two_d_array , one_d_array , [ [string] , [string] ] ) [EOL] assert str ( exin . value ) == index_error . format ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffdm . systemic_bias ( two_d_array , one_d_array , [ [number] , [number] , [number] ] ) [EOL] assert str ( exin . value ) == value_error [EOL] [EOL] data = np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [comment] [EOL] data_struct = np . array ( [ ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) , ( [number] , [string] , [number] ) ] , dtype = [ ( [string] , int ) , ( [string] , [string] ) , ( [string] , float ) ] ) [comment] [EOL] ground_truth = np . array ( [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] zero_indices = [ ] [EOL] one_indices = [ [number] ] [EOL] two_indices = [ [number] , [number] ] [EOL] all_indices = [ [number] , [number] , [number] ] [EOL] [comment] [EOL] one_indices_struct = [ [string] ] [EOL] two_indices_struct = [ [string] , [string] ] [EOL] all_indices_struct = [ [string] , [string] , [string] ] [EOL] [EOL] zero_matrix = np . array ( [ [ False , False , False , False , False ] , [ False , False , False , False , False ] , [ False , False , False , False , True ] , [ False , False , False , False , False ] , [ False , False , True , False , False ] ] ) [EOL] one_matrix = np . array ( [ [ False , False , False , False , False ] , [ False , False , False , True , False ] , [ False , False , False , False , True ] , [ False , True , False , False , False ] , [ False , False , True , False , False ] ] ) [EOL] two_matrix = np . array ( [ [ False , False , False , True , False ] , [ False , False , False , True , False ] , [ False , False , False , False , True ] , [ True , True , False , False , False ] , [ False , False , True , False , False ] ] ) [EOL] all_matrix = np . array ( [ [ False , False , True , True , False ] , [ False , False , True , True , False ] , [ True , True , False , False , True ] , [ True , True , False , False , True ] , [ False , False , True , True , False ] ] ) [EOL] [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data , ground_truth , zero_indices ) [EOL] assert np . array_equal ( grid , zero_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data , ground_truth , one_indices ) [EOL] assert np . array_equal ( grid , one_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data , ground_truth , two_indices ) [EOL] assert np . array_equal ( grid , two_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data , ground_truth , all_indices ) [EOL] assert np . array_equal ( grid , all_matrix ) [EOL] [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data_struct , ground_truth , zero_indices ) [EOL] assert np . array_equal ( grid , zero_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data_struct , ground_truth , one_indices_struct ) [EOL] assert np . array_equal ( grid , one_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data_struct , ground_truth , two_indices_struct ) [EOL] assert np . array_equal ( grid , two_matrix ) [EOL] [comment] [EOL] grid = ffdm . systemic_bias ( data_struct , ground_truth , all_indices_struct ) [EOL] assert np . array_equal ( grid , all_matrix ) [EOL] [EOL] [EOL] def test_systemic_bias_check ( ) : [EOL] [docstring] [EOL] incorrect_shape_error = [string] [EOL] incorrect_shape_error_square = [string] [EOL] type_error = [string] [EOL] value_error_symmetric = ( [string] [string] ) [EOL] value_error_structured = ( [string] [string] ) [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ [number] , [number] , [number] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_error [EOL] [EOL] with pytest . raises ( IncorrectShapeError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ [ True ] , [ True ] ] ) ) [EOL] assert str ( exin . value ) == incorrect_shape_error_square [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ ( True , ) ] , dtype = [ ( [string] , bool ) ] ) ) [EOL] assert str ( exin . value ) == value_error_structured [EOL] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert str ( exin . value ) == type_error [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ [ True , False ] , [ False , False ] ] ) ) [EOL] assert str ( exin . value ) == value_error_symmetric [EOL] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] ffdm . systemic_bias_check ( np . array ( [ [ True , False ] , [ True , True ] ] ) ) [EOL] assert str ( exin . value ) == value_error_symmetric [EOL] [EOL] ok_array = np . array ( [ [ False , True , False ] , [ True , False , False ] , [ False , False , False ] ] ) [EOL] assert ffdm . systemic_bias_check ( ok_array ) [EOL] [EOL] not_ok_array = np . array ( [ [ False , False , False ] , [ False , False , False ] , [ False , False , False ] ] ) [EOL] assert not ffdm . systemic_bias_check ( not_ok_array ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import os [EOL] import random [EOL] [EOL] import pytest [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf [EOL] [EOL] [EOL] def test_random_seed ( caplog ) : [EOL] [docstring] [EOL] fatf_seed = os . environ . get ( [string] , None ) [EOL] if fatf_seed is not None : [EOL] del os . environ [ [string] ] [comment] [EOL] assert [string] not in os . environ [EOL] [EOL] fatf . setup_random_seed ( ) [EOL] seed = np . random . get_state ( ) [ [number] ] [ [number] ] [EOL] message_source = [string] [EOL] message_seed = [string] . format ( seed ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_source [EOL] [comment] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] [comment] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_seed [EOL] [EOL] [comment] [EOL] python_random_seed = random . getstate ( ) [EOL] random . seed ( seed ) [EOL] assert random . getstate ( ) == python_random_seed [EOL] assert id ( random . getstate ( ) ) != id ( python_random_seed ) [EOL] [EOL] if fatf_seed is not None : [EOL] os . environ [ [string] ] = fatf_seed [comment] [EOL] assert [string] in os . environ [comment] [EOL] [EOL] [EOL] def test_osvar_seed ( caplog ) : [EOL] [docstring] [EOL] value_error_range = ( [string] [string] [string] ) [EOL] value_error_type = ( [string] [string] [string] ) [EOL] [EOL] seed_int = [number] [EOL] seed_int_random = [number] [EOL] seed_str = [string] . format ( seed_int ) [EOL] message_source = [string] [EOL] message_seed = [string] . format ( seed_str ) [EOL] [EOL] [comment] [EOL] fatf_seed = os . environ . get ( [string] , None ) [EOL] [EOL] [comment] [EOL] os . environ [ [string] ] = seed_str [EOL] fatf . setup_random_seed ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_source [EOL] [comment] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] [comment] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_seed [EOL] [EOL] [comment] [EOL] assert random . getstate ( ) [ [number] ] [ [number] ] == seed_int_random [EOL] assert np . random . get_state ( ) [ [number] ] [ [number] ] == seed_int [EOL] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] [comment] [EOL] os . environ [ [string] ] = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fatf . setup_random_seed ( ) [EOL] assert str ( exin . value ) == value_error_type [EOL] [comment] [EOL] os . environ [ [string] ] = [string] [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fatf . setup_random_seed ( ) [EOL] assert str ( exin . value ) == value_error_range [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] [comment] [EOL] if fatf_seed is None : [EOL] del os . environ [ [string] ] [comment] [EOL] else : [EOL] os . environ [ [string] ] = fatf_seed [comment] [EOL] [EOL] [EOL] def test_seed_seed ( caplog ) : [EOL] [docstring] [EOL] type_error = [string] [EOL] value_error = ( [string] [string] ) [EOL] [EOL] message_source = [string] [EOL] message_seed = [string] [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] with pytest . raises ( TypeError ) as exin : [EOL] fatf . setup_random_seed ( [string] ) [EOL] assert str ( exin . value ) == type_error [EOL] with pytest . raises ( ValueError ) as exin : [EOL] fatf . setup_random_seed ( - [number] ) [EOL] assert str ( exin . value ) == value_error [EOL] assert len ( caplog . records ) == [number] [EOL] [EOL] fatf . setup_random_seed ( [number] ) [EOL] [EOL] assert len ( caplog . records ) == [number] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_source [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message_seed [EOL] assert len ( caplog . records ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Tuple , Pattern , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import sys [EOL] import warnings [EOL] [EOL] import pytest [EOL] [EOL] import fatf [EOL] import fatf . utils . testing . warnings as testing_w [EOL] [EOL] PYTEST_WARNING_FILTERS = [ ] [EOL] [EOL] [EOL] def test_logger_level ( ) : [EOL] [docstring] [EOL] [comment] [EOL] assert fatf . logger . level == [number] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , ImportWarning ) , ( [string] , DeprecationWarning ) , ( [string] , PendingDeprecationWarning ) ] ) def test_warnings_emission1 ( error_type , error_class ) : [EOL] [docstring] [EOL] message = [string] . format ( error_type ) [EOL] with pytest . warns ( error_class , match = message ) as record : [EOL] warnings . warn ( message , error_class ) [EOL] [EOL] [comment] [EOL] assert len ( record ) == [number] [EOL] [comment] [EOL] assert record [ [number] ] . message . args [ [number] ] == message [EOL] [comment] [EOL] assert testing_w . is_warning_class_displayed ( error_class ) [EOL] [EOL] for fltr in warnings . filters : [EOL] warning_matches_module = testing_w . handle_warnings_filter_pattern ( fltr [ [number] ] , ignore_case = False ) [EOL] if warning_matches_module is not None : [EOL] module_pattern = warning_matches_module . pattern [EOL] if module_pattern not in PYTEST_WARNING_FILTERS : [EOL] assert [string] not in module_pattern [EOL] [EOL] [EOL] def test_warnings_emission2 ( ) : [EOL] [docstring] [EOL] [EOL] def test_record ( error_type , error_class , displayed ) : [EOL] message = [string] . format ( error_type ) [EOL] with pytest . warns ( error_class , match = message ) as record : [EOL] warnings . warn ( message , error_class ) [EOL] [EOL] [comment] [EOL] assert len ( record ) == [number] [EOL] [comment] [EOL] assert record [ [number] ] . message . args [ [number] ] == message [EOL] [comment] [EOL] assert displayed == testing_w . is_warning_class_displayed ( error_class ) [EOL] [EOL] testing_w . set_default_warning_filters ( ) [EOL] fatf . setup_warning_filters ( ) [EOL] [EOL] assert len ( warnings . filters ) == len ( testing_w . DEFAULT_WARNINGS ) + [number] [EOL] for fltr in warnings . filters [ : [number] ] : [EOL] warning_matches_module = testing_w . handle_warnings_filter_pattern ( fltr [ [number] ] , ignore_case = False ) [EOL] if warning_matches_module is not None : [EOL] assert [string] in warning_matches_module . pattern [EOL] [EOL] test_warning = [ ( [string] , ImportWarning ) , ( [string] , DeprecationWarning ) ] [EOL] for twi , tww in test_warning : [EOL] test_record ( twi , tww , True ) [EOL] [EOL] test_record ( [string] , PendingDeprecationWarning , False ) [EOL] [EOL] [EOL] def test_warnings_emission3 ( caplog ) : [EOL] [docstring] [EOL] sys . warnoptions = [ [string] ] [EOL] testing_w . set_default_warning_filters ( ) [EOL] [EOL] fatf . setup_warning_filters ( ) [EOL] [EOL] [comment] [EOL] message = [string] [EOL] [comment] [EOL] assert len ( caplog . records ) == [number] [EOL] [comment] [EOL] assert caplog . records [ [number] ] . levelname == [string] [EOL] [comment] [EOL] assert caplog . records [ [number] ] . getMessage ( ) == message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import pytest [EOL] [EOL] import fatf . exceptions [EOL] [EOL] [EOL] def test_fatfexception ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . FATFException ) as exception_info : [EOL] raise fatf . exceptions . FATFException ( ) [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . FATFException ) as exception_info : [EOL] raise fatf . exceptions . FATFException [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . FATFException ) as exception_info : [EOL] raise fatf . exceptions . FATFException ( custom_message ) [EOL] assert str ( exception_info . value ) == custom_message [EOL] [EOL] [EOL] def test_incorrectshapeerror ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncorrectShapeError ) as exin : [EOL] raise fatf . exceptions . IncorrectShapeError ( ) [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncorrectShapeError ) as exin : [EOL] raise fatf . exceptions . IncorrectShapeError [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . IncorrectShapeError ) as exin : [EOL] raise fatf . exceptions . IncorrectShapeError ( custom_message ) [EOL] assert str ( exin . value ) == custom_message [EOL] [EOL] [EOL] def test_incompatibleexplainererror ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleExplainerError ) as exin : [EOL] raise fatf . exceptions . IncompatibleExplainerError ( ) [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleExplainerError ) as exin : [EOL] raise fatf . exceptions . IncompatibleExplainerError [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleExplainerError ) as exin : [EOL] raise fatf . exceptions . IncompatibleExplainerError ( custom_message ) [EOL] assert str ( exin . value ) == custom_message [EOL] [EOL] [EOL] def test_incompatiblemodelerror ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleModelError ) as exin : [EOL] raise fatf . exceptions . IncompatibleModelError ( ) [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleModelError ) as exin : [EOL] raise fatf . exceptions . IncompatibleModelError [EOL] assert str ( exin . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . IncompatibleModelError ) as exin : [EOL] raise fatf . exceptions . IncompatibleModelError ( custom_message ) [EOL] assert str ( exin . value ) == custom_message [EOL] [EOL] [EOL] def test_unfittedmodelerror ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . UnfittedModelError ) as exception_info : [EOL] raise fatf . exceptions . UnfittedModelError ( ) [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . UnfittedModelError ) as exception_info : [EOL] raise fatf . exceptions . UnfittedModelError [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . UnfittedModelError ) as exception_info : [EOL] raise fatf . exceptions . UnfittedModelError ( custom_message ) [EOL] assert str ( exception_info . value ) == custom_message [EOL] [EOL] [EOL] def test_prefittedmodelerror ( ) : [EOL] [docstring] [EOL] default_message = [string] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . PrefittedModelError ) as exception_info : [EOL] raise fatf . exceptions . PrefittedModelError ( ) [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] with pytest . raises ( fatf . exceptions . PrefittedModelError ) as exception_info : [EOL] raise fatf . exceptions . PrefittedModelError [EOL] assert str ( exception_info . value ) == default_message [EOL] [EOL] [comment] [EOL] custom_message = [string] [EOL] with pytest . raises ( fatf . exceptions . PrefittedModelError ) as exception_info : [EOL] raise fatf . exceptions . PrefittedModelError ( custom_message ) [EOL] assert str ( exception_info . value ) == custom_message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . transparency . models . feature_influence as fatf_fi [EOL] [EOL] import fatf . vis . feature_influence as fatf_vis_fi [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] selected_feature_index = [number] [EOL] selected_feature_name = iris_feature_names [ selected_feature_index ] [EOL] print ( [string] . format ( selected_feature_index , selected_feature_name ) ) [EOL] [EOL] [comment] [EOL] explanation_class = [number] [EOL] explanation_class_name = iris_class_names [ explanation_class ] [EOL] print ( [string] . format ( explanation_class , explanation_class_name ) ) [EOL] [EOL] [comment] [EOL] linspace_samples = [number] [EOL] [EOL] [comment] [EOL] pd_array , pd_linspace = fatf_fi . partial_dependence ( iris_X , clf , selected_feature_index , steps_number = linspace_samples ) [EOL] [EOL] [comment] [EOL] pd_plot_clean = fatf_vis_fi . plot_partial_dependence ( pd_array , pd_linspace , explanation_class , class_name = explanation_class_name , feature_name = selected_feature_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict , Union , Tuple [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pprint import pprint [EOL] [EOL] import fatf [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . transparency . predictions . surrogate_explainers as fatf_surrogates [EOL] [EOL] import fatf . vis . lime as fatf_vis_lime [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] fatf . setup_random_seed ( [number] ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] [EOL] iris_feature_names = iris_data_dict [ [string] ] . tolist ( ) [EOL] iris_class_names = iris_data_dict [ [string] ] . tolist ( ) [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] lime = fatf_surrogates . TabularBlimeyLime ( iris_X , clf , feature_names = iris_feature_names , class_names = iris_class_names ) [EOL] [EOL] [comment] [EOL] index_to_explain = [number] [EOL] [EOL] [comment] [EOL] lime_explanation = lime . explain_instance ( iris_X [ index_to_explain , : ] , samples_number = [number] ) [EOL] [EOL] [comment] [EOL] pprint ( lime_explanation ) [EOL] [EOL] [comment] [EOL] fatf_vis_lime . plot_lime ( lime_explanation ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyLime$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 0
from typing import Any [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pprint import pprint [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . transparency . predictions . counterfactuals as fatf_cf [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] cf_explainer = fatf_cf . CounterfactualExplainer ( model = clf , dataset = iris_X , categorical_indices = [ ] , default_numerical_step_size = [number] ) [EOL] [EOL] [EOL] def describe_data_point ( data_point_index ) : [EOL] [docstring] [EOL] dp_to_explain = iris_X [ data_point_index , : ] [EOL] dp_to_explain_class_index = int ( iris_y [ data_point_index ] ) [EOL] dp_to_explain_class = iris_class_names [ dp_to_explain_class_index ] [EOL] [EOL] feature_description_template = [string] [EOL] features_description = [ ] [EOL] for i , name in enumerate ( iris_feature_names ) : [EOL] dsc = feature_description_template . format ( name , i , dp_to_explain [ i ] ) [EOL] features_description . append ( dsc ) [EOL] features_description = [string] . join ( features_description ) [EOL] [EOL] data_point_description = ( [string] [string] . format ( data_point_index , dp_to_explain_class , dp_to_explain_class_index , features_description ) ) [EOL] [EOL] print ( data_point_description ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] dp_1_index = [number] [EOL] dp_1_X = iris_X [ dp_1_index , : ] [EOL] dp_1_y = iris_y [ dp_1_index ] [EOL] describe_data_point ( dp_1_index ) [EOL] [EOL] [comment] [EOL] dp_1_cf_tuple = cf_explainer . explain_instance ( dp_1_X ) [EOL] dp_1_cfs , dp_1_cfs_distances , dp_1_cfs_predictions = dp_1_cf_tuple [EOL] dp_1_cfs_predictions_names = np . array ( [ iris_class_names [ i ] for i in dp_1_cfs_predictions ] ) [EOL] [EOL] print ( [string] ) [EOL] pprint ( dp_1_cfs ) [EOL] print ( [string] ) [EOL] pprint ( dp_1_cfs_distances ) [EOL] print ( [string] ) [EOL] pprint ( dp_1_cfs_predictions ) [EOL] pprint ( dp_1_cfs_predictions_names ) [EOL] [EOL] [comment] [EOL] dp_1_cfs_text = fatf_cf . textualise_counterfactuals ( dp_1_X , dp_1_cfs , instance_class = dp_1_y , counterfactuals_distances = dp_1_cfs_distances , counterfactuals_predictions = dp_1_cfs_predictions ) [EOL] print ( dp_1_cfs_text ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] dp_2_index = [number] [EOL] dp_2_X = iris_X [ dp_2_index , : ] [EOL] dp_2_y = iris_y [ dp_2_index ] [EOL] describe_data_point ( dp_2_index ) [EOL] [EOL] [comment] [EOL] dp_2_cf_tuple = cf_explainer . explain_instance ( dp_2_X ) [EOL] dp_2_cfs , dp_2_cfs_distances , dp_2_cfs_predictions = dp_2_cf_tuple [EOL] dp_2_cfs_predictions_names = np . array ( [ iris_class_names [ i ] for i in dp_2_cfs_predictions ] ) [EOL] [EOL] print ( [string] ) [EOL] pprint ( dp_2_cfs ) [EOL] print ( [string] ) [EOL] pprint ( dp_2_cfs_distances ) [EOL] print ( [string] ) [EOL] pprint ( dp_2_cfs_predictions ) [EOL] pprint ( dp_2_cfs_predictions_names ) [EOL] [EOL] [comment] [EOL] dp_2_cfs_text = fatf_cf . textualise_counterfactuals ( dp_2_X , dp_2_cfs , instance_class = dp_2_y , counterfactuals_distances = dp_2_cfs_distances , counterfactuals_predictions = dp_2_cfs_predictions ) [EOL] print ( dp_2_cfs_text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $fatf.transparency.predictions.counterfactuals.CounterfactualExplainer$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fatf.transparency.predictions.counterfactuals.CounterfactualExplainer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $fatf.transparency.predictions.counterfactuals.CounterfactualExplainer$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . transparency . models . feature_influence as fatf_fi [EOL] [EOL] import fatf . vis . feature_influence as fatf_vis_fi [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] selected_feature_index = [number] [EOL] selected_feature_name = iris_feature_names [ selected_feature_index ] [EOL] print ( [string] . format ( selected_feature_index , selected_feature_name ) ) [EOL] [EOL] [comment] [EOL] linspace_samples = [number] [EOL] [EOL] [comment] [EOL] ice_array , ice_linspace = fatf_fi . individual_conditional_expectation ( iris_X , clf , selected_feature_index , steps_number = linspace_samples ) [EOL] [EOL] [comment] [EOL] explanation_class = [number] [EOL] explanation_class_name = iris_class_names [ explanation_class ] [EOL] print ( [string] . format ( explanation_class , explanation_class_name ) ) [EOL] [EOL] [comment] [EOL] ice_plot = fatf_vis_fi . plot_individual_conditional_expectation ( ice_array , ice_linspace , explanation_class , class_name = explanation_class_name , feature_name = selected_feature_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] index_to_explain = [number] [EOL] dp_to_explain = iris_X [ index_to_explain , : ] [EOL] dp_to_explain_class_index = int ( iris_y [ index_to_explain ] ) [EOL] dp_to_explain_class = iris_class_names [ dp_to_explain_class_index ] [EOL] [EOL] feature_description_template = [string] [EOL] data_point_description = [ ] [EOL] for i , name in enumerate ( iris_feature_names ) : [EOL] dsc = feature_description_template . format ( name , i , dp_to_explain [ i ] ) [EOL] data_point_description . append ( dsc ) [EOL] data_point_description = [string] . join ( data_point_description ) [EOL] [EOL] print ( [string] [string] . format ( index_to_explain , dp_to_explain_class , dp_to_explain_class_index , data_point_description ) ) [EOL] [EOL] [comment] [EOL] ice_array_dp = ice_array [ [ index_to_explain ] , : , : ] [EOL] [EOL] [comment] [EOL] ice_dp_plot = fatf_vis_fi . plot_individual_conditional_expectation ( ice_array_dp , ice_linspace , dp_to_explain_class_index , class_name = dp_to_explain_class , feature_name = selected_feature_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] pd_array = fatf_fi . partial_dependence_ice ( ice_array ) [EOL] [EOL] [comment] [EOL] pd_plot_clean = fatf_vis_fi . plot_partial_dependence ( pd_array , ice_linspace , explanation_class , class_name = explanation_class_name , feature_name = selected_feature_name ) [EOL] [EOL] [comment] [EOL] ice_plot_2 = fatf_vis_fi . plot_individual_conditional_expectation ( ice_array , ice_linspace , explanation_class , class_name = explanation_class_name , feature_name = selected_feature_name ) [EOL] ice_plot_2_figure , ice_plot_2_axis = ice_plot_2 [EOL] pd_plot_overlay = fatf_vis_fi . plot_partial_dependence ( pd_array , ice_linspace , explanation_class , class_name = explanation_class_name , feature_name = selected_feature_name , plot_axis = ice_plot_2_axis ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any , Dict , Union , Tuple [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pprint import pprint [EOL] [EOL] import fatf [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . transparency . predictions . surrogate_explainers as fatf_surrogates [EOL] [EOL] import fatf . vis . lime as fatf_vis_lime [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] fatf . setup_random_seed ( [number] ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] [EOL] iris_feature_names = iris_data_dict [ [string] ] . tolist ( ) [EOL] iris_class_names = iris_data_dict [ [string] ] . tolist ( ) [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] tree = fatf_surrogates . TabularBlimeyTree ( iris_X , clf , feature_names = iris_feature_names , class_names = iris_class_names ) [EOL] [EOL] [comment] [EOL] index_to_explain = [number] [EOL] [EOL] [comment] [EOL] tree_explanation = tree . explain_instance ( iris_X [ index_to_explain , : ] , samples_number = [number] ) [EOL] [EOL] [comment] [EOL] pprint ( tree_explanation ) [EOL] [EOL] [comment] [EOL] fatf_vis_lime . plot_lime ( tree_explanation ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 $fatf.transparency.predictions.surrogate_explainers.TabularBlimeyTree$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Tuple[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.float]],typing.Union[typing.Dict[builtins.str,fatf.utils.models.models.Model],fatf.utils.models.models.Model]]]$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pprint import pprint [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] [EOL] import fatf . transparency . data . describe_functions as fatf_dd [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] features_description = fatf_dd . describe_array ( iris_X ) [EOL] [EOL] [comment] [EOL] named_features_description = dict ( ) [EOL] for fdi in features_description . items ( ) : [EOL] feature_id , feature_description = fdi [EOL] feature_name = iris_feature_names [ feature_id ] [EOL] [EOL] named_features_description [ feature_name ] = feature_description [EOL] [EOL] print ( [string] ) [EOL] pprint ( named_features_description ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] selected_feature_id = [number] [EOL] selected_feature_name = iris_feature_names [ selected_feature_id ] [EOL] [EOL] [comment] [EOL] per_class_row_mask = dict ( ) [EOL] for class_index , class_name in enumerate ( iris_class_names ) : [EOL] per_class_row_mask [ class_name ] = iris_y == class_index [EOL] [EOL] [comment] [EOL] per_class_explanation = dict ( ) [EOL] for class_name , class_mask in per_class_row_mask . items ( ) : [EOL] class_array = iris_X [ class_mask , selected_feature_id ] [EOL] per_class_explanation [ class_name ] = fatf_dd . describe_array ( class_array ) [EOL] [EOL] print ( [string] [string] . format ( selected_feature_name , selected_feature_id ) ) [EOL] pprint ( per_class_explanation ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] target_explanation = fatf_dd . describe_categorical_array ( iris_y ) [EOL] [EOL] print ( [string] ) [EOL] pprint ( target_explanation ) [EOL] [EOL] [comment] [EOL] iris_y_named = np . array ( [ iris_class_names [ i ] for i in iris_y ] ) [EOL] target_explanation_named = fatf_dd . describe_categorical_array ( iris_y_named ) [EOL] [EOL] print ( [string] ) [EOL] pprint ( target_explanation_named ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . accountability . models . measures as fatf_mam [EOL] [EOL] import fatf . utils . metrics . subgroup_metrics as fatf_smt [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X , iris_y ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] iris_pred = clf . predict ( iris_X ) [EOL] [EOL] [comment] [EOL] predictive_performance_metric = [string] [EOL] [EOL] [comment] [EOL] selected_feature_index = [number] [EOL] selected_feature_name = iris_feature_names [ selected_feature_index ] [EOL] [EOL] [comment] [EOL] selected_feature_grouping = [ [number] ] [EOL] [EOL] [comment] [EOL] population_metrics , population_names = fatf_smt . performance_per_subgroup ( iris_X , iris_y , iris_pred , selected_feature_index , groupings = selected_feature_grouping , metric = predictive_performance_metric ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( predictive_performance_metric , selected_feature_name , selected_feature_index ) ) [EOL] for p_name , p_metric in zip ( population_names , population_metrics ) : [EOL] print ( [string] [string] . format ( p_name , predictive_performance_metric , p_metric ) ) [EOL] [EOL] [comment] [EOL] bias_grid = fatf_mam . systematic_performance_bias_grid ( population_metrics ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( predictive_performance_metric , selected_feature_name , selected_feature_index ) ) [EOL] for grouping_i , grouping_name_i in enumerate ( population_names ) : [EOL] j_offset = grouping_i + [number] [EOL] for grouping_j , grouping_name_j in enumerate ( population_names [ j_offset : ] ) : [EOL] grouping_j += j_offset [EOL] is_not = [string] if bias_grid [ grouping_i , grouping_j ] else [string] [EOL] [EOL] print ( [string] [string] . format ( grouping_name_i , grouping_name_j , is_not ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . utils . data . density as fatf_density [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] cmap = np . array ( [ plt . get_cmap ( [string] ) . colors [ [number] ] , plt . get_cmap ( [string] ) . colors [ [number] ] , plt . get_cmap ( [string] ) . colors [ [number] ] ] ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] chosen_features_index = [ [number] , [number] ] [EOL] chosen_features_name = iris_feature_names [ chosen_features_index ] [EOL] [EOL] [comment] [EOL] iris_X_chosen_features = iris_X [ : , chosen_features_index ] [EOL] [EOL] [comment] [EOL] plt . scatter ( iris_X_chosen_features [ : , [number] ] , iris_X_chosen_features [ : , [number] ] , c = cmap [ iris_y ] ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( chosen_features_name [ [number] ] ) [EOL] plt . ylabel ( chosen_features_name [ [number] ] ) [EOL] plt . show ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( iris_X_chosen_features , iris_y ) [EOL] [EOL] [comment] [EOL] point_dense = np . array ( [ [ [number] , [number] ] ] ) [EOL] point_sparse = np . array ( [ [ [number] , [number] ] ] ) [EOL] [EOL] [comment] [EOL] plt . scatter ( iris_X_chosen_features [ : , [number] ] , iris_X_chosen_features [ : , [number] ] , c = cmap [ iris_y ] ) [EOL] plt . scatter ( point_dense [ : , [number] ] , point_dense [ : , [number] ] , c = [string] , s = [number] , marker = [string] , label = [string] ) [EOL] plt . scatter ( point_sparse [ : , [number] ] , point_sparse [ : , [number] ] , c = [string] , s = [number] , marker = [string] , label = [string] ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( chosen_features_name [ [number] ] ) [EOL] plt . ylabel ( chosen_features_name [ [number] ] ) [EOL] plt . legend ( loc = [string] ) [EOL] plt . show ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] point_dense_prediction = clf . predict ( point_dense ) [ [number] ] [EOL] point_sparse_prediction = clf . predict ( point_sparse ) [ [number] ] [EOL] [EOL] [comment] [EOL] print ( [string] . format ( iris_class_names [ point_dense_prediction ] , point_dense_prediction ) ) [EOL] print ( [string] . format ( iris_class_names [ point_sparse_prediction ] , point_sparse_prediction ) ) [EOL] [EOL] [comment] [EOL] plt . scatter ( iris_X_chosen_features [ : , [number] ] , iris_X_chosen_features [ : , [number] ] , c = cmap [ iris_y ] ) [EOL] plt . scatter ( point_dense [ : , [number] ] , point_dense [ : , [number] ] , c = cmap [ [ int ( point_dense_prediction ) ] ] , s = [number] , marker = [string] , label = [string] . format ( iris_class_names [ point_dense_prediction ] ) ) [EOL] plt . scatter ( point_sparse [ : , [number] ] , point_sparse [ : , [number] ] , c = cmap [ [ int ( point_sparse_prediction ) ] ] , s = [number] , marker = [string] , label = [string] . format ( iris_class_names [ point_sparse_prediction ] ) ) [EOL] plt . title ( [string] ) [EOL] plt . xlabel ( chosen_features_name [ [number] ] ) [EOL] plt . ylabel ( chosen_features_name [ [number] ] ) [EOL] plt . legend ( loc = [string] ) [EOL] plt . show ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( iris_class_names ) ) [EOL] [EOL] [comment] [EOL] iris_density = fatf_density . DensityCheck ( iris_X_chosen_features ) [EOL] [EOL] [comment] [EOL] density_score_dense = iris_density . score_data_point ( point_dense [ [number] , : ] ) [EOL] [comment] [EOL] probabilities_dense = clf . predict_proba ( point_dense ) [ [number] ] [EOL] [EOL] [comment] [EOL] density_score_sparse = iris_density . score_data_point ( point_sparse [ [number] , : ] ) [EOL] [comment] [EOL] probabilities_sparse = clf . predict_proba ( point_sparse ) [ [number] ] [EOL] [EOL] print ( [string] [string] . format ( probabilities_sparse , density_score_sparse ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] [string] . format ( probabilities_dense , density_score_dense ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $fatf.utils.data.density.DensityCheck$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 $fatf.utils.data.density.DensityCheck$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $fatf.utils.data.density.DensityCheck$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] [EOL] import fatf . accountability . data . measures as fatf_dam [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] iris_data_dict = fatf_datasets . load_iris ( ) [EOL] iris_X = iris_data_dict [ [string] ] [EOL] iris_y = iris_data_dict [ [string] ] . astype ( int ) [EOL] iris_feature_names = iris_data_dict [ [string] ] [EOL] iris_class_names = iris_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] selected_feature_index = [number] [EOL] selected_feature_name = iris_feature_names [ selected_feature_index ] [EOL] [EOL] [comment] [EOL] selected_feature_grouping = [ [number] , [number] ] [EOL] [EOL] [comment] [EOL] grp_counts , grp_weights , grp_names = fatf_dam . sampling_bias ( iris_X , selected_feature_index , selected_feature_grouping ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( selected_feature_name , selected_feature_index ) ) [EOL] for g_name , g_count in zip ( grp_names , grp_counts ) : [EOL] is_are = [string] if g_count == [number] else [string] [EOL] print ( [string] [string] . format ( g_name , is_are , g_count ) ) [EOL] [EOL] [comment] [EOL] bias_grid = fatf_dam . sampling_bias_grid_check ( grp_counts ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( selected_feature_name , selected_feature_index ) ) [EOL] for grouping_i , grouping_name_i in enumerate ( grp_names ) : [EOL] j_offset = grouping_i + [number] [EOL] for grouping_j , grouping_name_j in enumerate ( grp_names [ j_offset : ] ) : [EOL] grouping_j += j_offset [EOL] is_not = [string] if bias_grid [ grouping_i , grouping_j ] else [string] [EOL] [EOL] print ( [string] [string] . format ( grouping_name_i , grouping_name_j , is_not ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . fairness . predictions . measures as fatf_pfm [EOL] [EOL] import fatf . transparency . predictions . counterfactuals as fatf_cf [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] hr_data_dict = fatf_datasets . load_health_records ( ) [EOL] hr_X = hr_data_dict [ [string] ] [EOL] hr_y = hr_data_dict [ [string] ] [EOL] hr_feature_names = hr_data_dict [ [string] ] [EOL] hr_class_names = hr_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] hr_y = np . array ( [ hr_class_names [ i ] for i in hr_y ] ) [EOL] [EOL] [comment] [EOL] unique_identifiers = [ [string] , [string] , [string] , [string] ] [EOL] columns_to_keep = [ i for i in hr_X . dtype . names if i not in unique_identifiers ] [EOL] [comment] [EOL] hr_X = hr_X [ columns_to_keep ] [EOL] hr_feature_names = [ i for i in hr_feature_names if i not in unique_identifiers ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( hr_X , hr_y ) [EOL] [EOL] [comment] [EOL] data_point_index = [number] + [number] [EOL] data_point = hr_X [ data_point_index ] [EOL] data_point_y = hr_y [ data_point_index ] [EOL] [EOL] [comment] [EOL] protected_features = [ [string] , [string] ] [EOL] [EOL] [comment] [EOL] assert protected_features , [string] [EOL] person = [string] if len ( protected_features ) == [number] else [string] [EOL] print ( [string] . format ( person ) ) [EOL] for feature_name in protected_features : [EOL] print ( [string] . format ( feature_name ) ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( data_point_index , data_point_y ) ) [EOL] for feature_name in data_point . dtype . names : [EOL] print ( [string] . format ( feature_name , data_point [ feature_name ] ) ) [EOL] [EOL] [comment] [EOL] cfs , cfs_distances , cfs_classes = fatf_pfm . counterfactual_fairness ( instance = data_point , protected_feature_indices = protected_features , model = clf , default_numerical_step_size = [number] , dataset = hr_X ) [EOL] [EOL] [comment] [EOL] cfs_text = fatf_cf . textualise_counterfactuals ( data_point , cfs , instance_class = data_point_y , counterfactuals_distances = cfs_distances , counterfactuals_predictions = cfs_classes ) [EOL] print ( [string] . format ( cfs_text ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Dict , Tuple , List [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from pprint import pprint [EOL] import numpy as np [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] [EOL] import fatf . fairness . data . measures as fatf_dfm [EOL] [EOL] import fatf . utils . data . tools as fatf_data_tools [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] hr_data_dict = fatf_datasets . load_health_records ( ) [EOL] hr_X = hr_data_dict [ [string] ] [EOL] hr_y = hr_data_dict [ [string] ] [EOL] hr_feature_names = hr_data_dict [ [string] ] [EOL] hr_class_names = hr_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] protected_features = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [comment] [EOL] data_fairness_matrix = fatf_dfm . systemic_bias ( hr_X , hr_y , protected_features ) [EOL] [EOL] [comment] [EOL] is_data_unfair = fatf_dfm . systemic_bias_check ( data_fairness_matrix ) [EOL] [EOL] [comment] [EOL] unfair_pairs_tuple = np . where ( data_fairness_matrix ) [EOL] unfair_pairs = [ ] [EOL] for i , j in zip ( * unfair_pairs_tuple ) : [EOL] pair_a , pair_b = ( i , j ) , ( j , i ) [EOL] if pair_a not in unfair_pairs and pair_b not in unfair_pairs : [EOL] unfair_pairs . append ( pair_a ) [EOL] [EOL] [comment] [EOL] if is_data_unfair : [EOL] unfair_n = len ( unfair_pairs ) [EOL] unfair_fill = ( [string] , [string] ) if unfair_n == [number] else ( [string] , [string] ) [EOL] print ( [string] [string] . format ( unfair_fill [ [number] ] , unfair_n , unfair_fill [ [number] ] ) ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] pprint ( hr_X [ [ unfair_pairs [ [number] ] [ [number] ] , unfair_pairs [ [number] ] [ [number] ] ] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] grouping_column = [string] [EOL] grouping_indices , grouping_names = fatf_data_tools . group_by_column ( hr_X , grouping_column , treat_as_categorical = True ) [EOL] [EOL] [comment] [EOL] print ( [string] [string] . format ( grouping_column ) ) [EOL] for grouping_name , grouping_idx in zip ( grouping_names , grouping_indices ) : [EOL] print ( [string] . format ( grouping_name , len ( grouping_idx ) ) ) [EOL] [EOL] [comment] [EOL] grouping_class_distribution = dict ( ) [EOL] for grouping_name , grouping_idx in zip ( grouping_names , grouping_indices ) : [EOL] sg_y = hr_y [ grouping_idx ] [EOL] sg_classes , sg_counts = np . unique ( sg_y , return_counts = True ) [EOL] [EOL] grouping_class_distribution [ grouping_name ] = dict ( ) [EOL] for sg_class , sg_count in zip ( sg_classes , sg_counts ) : [EOL] sg_class_name = hr_class_names [ sg_class ] [EOL] [EOL] grouping_class_distribution [ grouping_name ] [ sg_class_name ] = sg_count [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] for grouping_name , class_distribution in grouping_class_distribution . items ( ) : [EOL] print ( [string] [string] . format ( grouping_name ) ) [EOL] for class_name , class_count in class_distribution . items ( ) : [EOL] print ( [string] . format ( class_name , class_count ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 $builtins.int$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Literal , Union [EOL] import typing_extensions [EOL] import typing [EOL] import fatf [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import fatf . utils . data . datasets as fatf_datasets [EOL] import fatf . utils . models as fatf_models [EOL] [EOL] import fatf . fairness . models . measures as fatf_mfm [EOL] [EOL] import fatf . utils . metrics . tools as fatf_mt [EOL] [EOL] print ( __doc__ ) [EOL] [EOL] [comment] [EOL] hr_data_dict = fatf_datasets . load_health_records ( ) [EOL] hr_X = hr_data_dict [ [string] ] [EOL] hr_y = hr_data_dict [ [string] ] [EOL] hr_feature_names = hr_data_dict [ [string] ] [EOL] hr_class_names = hr_data_dict [ [string] ] [EOL] [EOL] [comment] [EOL] clf = fatf_models . KNN ( ) [EOL] clf . fit ( hr_X , hr_y ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] hr_pred = clf . predict ( hr_X ) [EOL] [EOL] [comment] [EOL] protected_feature = [string] [EOL] [EOL] [comment] [EOL] confusion_matrix_per_bin , bin_names = fatf_mt . confusion_matrix_per_subgroup ( hr_X , hr_y , hr_pred , protected_feature , treat_as_categorical = True ) [EOL] [EOL] [EOL] def print_fairness ( metric_name , metric_matrix ) : [EOL] [docstring] [EOL] print ( [string] [string] . format ( metric_name , protected_feature ) ) [EOL] for grouping_i , grouping_name_i in enumerate ( bin_names ) : [EOL] j_offset = grouping_i + [number] [EOL] for grouping_j , grouping_name_j in enumerate ( bin_names [ j_offset : ] ) : [EOL] grouping_j += j_offset [EOL] is_not = [string] if metric_matrix [ grouping_i , grouping_j ] else [string] [EOL] [EOL] print ( [string] [string] . format ( is_not , grouping_name_i , grouping_name_j ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] equal_accuracy_matrix = fatf_mfm . equal_accuracy ( confusion_matrix_per_bin ) [EOL] [EOL] [comment] [EOL] print_fairness ( [string] , equal_accuracy_matrix ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] equal_opportunity_matrix = fatf_mfm . equal_opportunity ( confusion_matrix_per_bin ) [EOL] [EOL] [comment] [EOL] print_fairness ( [string] , equal_opportunity_matrix ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] demographic_parity_matrix = fatf_mfm . demographic_parity ( confusion_matrix_per_bin ) [EOL] [EOL] [comment] [EOL] print_fairness ( [string] , demographic_parity_matrix ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $fatf.utils.models.models.KNN$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import inspect [EOL] import os [EOL] import subprocess [EOL] import sys [EOL] [EOL] from functools import partial [EOL] from operator import attrgetter [EOL] [EOL] REVISION_CMD = [string] [EOL] [EOL] [EOL] def _get_git_revision ( ) : [EOL] [docstring] [EOL] try : [EOL] revision = subprocess . check_output ( REVISION_CMD . split ( ) ) . strip ( ) [EOL] except ( subprocess . CalledProcessError , OSError ) : [EOL] print ( [string] ) [EOL] return None [EOL] return revision . decode ( [string] ) [EOL] [EOL] [EOL] def _linkcode_resolve ( domain , info , package , url_fmt , revision ) : [EOL] [docstring] [EOL] [comment] [EOL] if revision is None : [EOL] return None [EOL] if domain != [string] : [EOL] return None [EOL] if not info . get ( [string] ) or not info . get ( [string] ) : [EOL] return None [EOL] [EOL] class_name = info [ [string] ] . split ( [string] ) [ [number] ] [EOL] module = __import__ ( info [ [string] ] , fromlist = [ class_name ] ) [EOL] obj = attrgetter ( info [ [string] ] ) ( module ) [EOL] [EOL] try : [EOL] function = inspect . getsourcefile ( obj ) [EOL] except Exception : [EOL] function = None [EOL] if not function : [EOL] try : [EOL] function = inspect . getsourcefile ( sys . modules [ obj . __module__ ] ) [EOL] except Exception : [EOL] function = None [EOL] if not function : [EOL] return None [EOL] [EOL] function = os . path . relpath ( function , start = os . path . dirname ( __import__ ( package ) . __file__ ) ) [EOL] try : [EOL] lineno = inspect . getsourcelines ( obj ) [ [number] ] [EOL] except Exception : [EOL] lineno = [string] [EOL] return url_fmt . format ( revision = revision , package = package , path = function , lineno = lineno ) [EOL] [EOL] [EOL] def make_linkcode_resolve ( package , url_fmt ) : [EOL] [docstring] [EOL] revision = _get_git_revision ( ) [EOL] return partial ( _linkcode_resolve , revision = revision , package = package , url_fmt = url_fmt ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0