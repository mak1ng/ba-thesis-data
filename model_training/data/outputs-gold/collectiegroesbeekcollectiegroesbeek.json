from collectiegroesbeek import app [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Optional [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Optional , List , Type [EOL] [EOL] from elasticsearch_dsl import Document , Index , Text , Keyword , Short [EOL] [EOL] [EOL] class BaseDocument ( Document ) : [EOL] [EOL] class Index : [EOL] name = [string] [EOL] [EOL] @ classmethod def _matches ( cls , hit ) : [EOL] [comment] [EOL] [comment] [EOL] return bool ( re . search ( cls . Index . name + [string] , hit [ [string] ] ) ) [EOL] [EOL] @ classmethod def from_csv_line ( cls , line ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ staticmethod def get_multimatch_fields ( ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ staticmethod def get_index_name_pretty ( ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_title ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_subtitle ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def get_body_lines ( self ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class CardNameDoc ( BaseDocument ) : [EOL] datum = Text ( norms = False ) [EOL] naam = Text ( norms = False ) [EOL] inhoud = Text ( norms = False ) [EOL] bron = Text ( norms = False ) [EOL] getuigen = Text ( norms = False ) [EOL] bijzonderheden = Text ( norms = False ) [EOL] [EOL] naam_keyword = Keyword ( ) [EOL] jaar = Short ( ) [EOL] [EOL] class Index : [EOL] name = [string] [EOL] [EOL] def __new__ ( cls ) : [EOL] return Index ( name = cls . name ) [EOL] [EOL] @ classmethod def from_csv_line ( cls , line ) : [EOL] doc = cls ( ) [EOL] if len ( line [ [number] ] ) == [number] : [EOL] return None [EOL] doc . meta . id = int ( line [ [number] ] ) [EOL] doc . datum = parse_entry ( line [ [number] ] ) [EOL] doc . naam = parse_entry ( line [ [number] ] ) [EOL] doc . inhoud = parse_entry ( line [ [number] ] ) [EOL] doc . bron = parse_entry ( line [ [number] ] ) [EOL] doc . getuigen = parse_entry ( line [ [number] ] ) [EOL] doc . bijzonderheden = parse_entry ( line [ [number] ] ) [EOL] if not doc . is_valid ( ) : [EOL] return None [EOL] if doc . naam is not None : [EOL] doc . naam_keyword = create_name_keyword ( str ( doc . naam ) ) [EOL] if doc . datum is not None : [EOL] doc . jaar = create_year ( str ( doc . datum ) ) [EOL] return doc [EOL] [EOL] def is_valid ( self ) : [EOL] [comment] [EOL] if getattr ( self . meta , [string] , None ) is None : [EOL] return False [EOL] [comment] [EOL] if self . naam is None and self . datum is None : [EOL] return False [EOL] return True [EOL] [EOL] @ staticmethod def get_multimatch_fields ( ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ staticmethod def get_index_name_pretty ( ) : [EOL] return [string] [EOL] [EOL] def get_title ( self ) : [EOL] return [string] . format ( self . naam or [string] , self . datum or [string] ) [EOL] [EOL] def get_subtitle ( self ) : [EOL] return self . bron or [string] [EOL] [EOL] def get_body_lines ( self ) : [EOL] out = [ self . inhoud , self . getuigen , self . bijzonderheden ] [EOL] return [ value for value in out if value ] [EOL] [EOL] [EOL] def create_name_keyword ( naam ) : [EOL] [docstring] [EOL] [comment] [EOL] if len ( naam . split ( [string] ) ) >= [number] : [EOL] return naam . split ( [string] ) [ [number] ] [EOL] elif len ( naam . split ( [string] ) ) >= [number] : [EOL] return naam . split ( [string] ) [ [number] ] [EOL] elif len ( naam . split ( [string] ) ) >= [number] : [EOL] return naam . split ( [string] ) [ [number] ] [EOL] else : [EOL] return naam [EOL] [EOL] [EOL] def create_year ( datum ) : [EOL] [docstring] [EOL] if datum is None or len ( datum ) < [number] or not datum [ : [number] ] . isdigit ( ) : [EOL] return None [EOL] jaar = int ( datum [ : [number] ] ) [EOL] if [number] < jaar < [number] : [EOL] return jaar [EOL] return None [EOL] [EOL] [EOL] class VoornamenDoc ( BaseDocument ) : [EOL] datum = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] voornaam = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] patroniem = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] inhoud = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] bron = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] getuigen = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] bijzonderheden = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] [EOL] jaar = Short ( ) [EOL] [EOL] class Index : [EOL] name = [string] [EOL] [EOL] def __new__ ( cls ) : [EOL] return Index ( name = cls . name ) [EOL] [EOL] @ classmethod def from_csv_line ( cls , line ) : [EOL] doc = cls ( ) [EOL] if len ( line [ [number] ] ) == [number] : [EOL] return None [EOL] doc . meta . id = int ( line [ [number] ] ) [EOL] doc . datum = parse_entry ( line [ [number] ] ) [EOL] doc . voornaam = parse_entry ( line [ [number] ] ) [EOL] doc . patroniem = parse_entry ( line [ [number] ] ) [EOL] doc . inhoud = parse_entry ( line [ [number] ] ) [EOL] doc . bron = parse_entry ( line [ [number] ] ) [EOL] doc . getuigen = parse_entry ( line [ [number] ] ) [EOL] doc . bijzonderheden = parse_entry ( line [ [number] ] ) [EOL] if not doc . is_valid ( ) : [EOL] return None [EOL] if doc . datum is not None : [EOL] doc . jaar = create_year ( str ( doc . datum ) ) [EOL] return doc [EOL] [EOL] def is_valid ( self ) : [EOL] [comment] [EOL] if getattr ( self . meta , [string] , None ) is None : [EOL] return False [EOL] [comment] [EOL] if self . voornaam is None and self . datum is None : [EOL] return False [EOL] return True [EOL] [EOL] @ staticmethod def get_multimatch_fields ( ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ staticmethod def get_index_name_pretty ( ) : [EOL] return [string] [EOL] [EOL] def get_title ( self ) : [EOL] return [string] . format ( self . voornaam or [string] , self . patroniem or [string] , self . datum or [string] ) [EOL] [EOL] def get_subtitle ( self ) : [EOL] return self . bron or [string] [EOL] [EOL] def get_body_lines ( self ) : [EOL] out = [ self . inhoud , self . getuigen , self . bijzonderheden ] [EOL] return [ value for value in out if value ] [EOL] [EOL] [EOL] class HeemskerkMaatboekDoc ( BaseDocument ) : [EOL] locatie = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] sector = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] [EOL] eigenaar = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] huurder = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] [EOL] oppervlakte = Keyword ( ) [EOL] prijs = Keyword ( ) [EOL] [EOL] datum = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] jaar = Short ( ) [EOL] [EOL] bron = Text ( fields = { [string] : Keyword ( ) } , norms = False ) [EOL] opmerkingen = Text ( norms = False ) [EOL] [EOL] class Index : [EOL] name = [string] [EOL] [EOL] def __new__ ( cls ) : [EOL] return Index ( name = cls . name ) [EOL] [EOL] @ classmethod def from_csv_line ( cls , line ) : [EOL] [comment] [EOL] if not parse_entry ( line [ [number] ] ) or not any ( parse_entry ( value ) for value in line [ [number] : ] ) : [EOL] return None [EOL] doc = cls ( ) [EOL] doc . meta . id = line [ [number] ] [EOL] doc . locatie = parse_entry ( line [ [number] ] ) [EOL] doc . sector = parse_entry ( line [ [number] ] ) [EOL] doc . oppervlakte = parse_entry ( line [ [number] ] ) [EOL] doc . eigenaar = parse_entry ( line [ [number] ] ) [EOL] doc . huurder = parse_entry ( line [ [number] ] ) [EOL] doc . prijs = parse_entry ( line [ [number] ] ) [EOL] doc . datum = parse_entry ( line [ [number] ] ) [EOL] doc . bron = parse_entry ( line [ [number] ] ) [EOL] doc . opmerkingen = parse_entry ( line [ [number] ] ) [EOL] doc . jaar = cls . parse_year ( doc . datum ) [EOL] return doc [EOL] [EOL] @ staticmethod def parse_year ( datum ) : [EOL] res = re . search ( [string] , datum or [string] ) [EOL] return int ( res [ [number] ] ) if res else None [EOL] [EOL] @ staticmethod def get_multimatch_fields ( ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] @ staticmethod def get_index_name_pretty ( ) : [EOL] return [string] [EOL] [EOL] def get_title ( self ) : [EOL] title = self . sector or self . locatie or self . eigenaar or self . huurder or [string] [EOL] if len ( title ) > [number] : [EOL] title = title [ : [number] ] + [string] [EOL] if self . datum : [EOL] title += [string] + self . datum [EOL] return title [EOL] [EOL] def get_subtitle ( self ) : [EOL] return self . bron or [string] [EOL] [EOL] def get_body_lines ( self ) : [EOL] out = [ self . locatie , self . sector , [string] + self . eigenaar if self . eigenaar else None , [string] + self . huurder if self . huurder else None , self . oppervlakte , self . prijs , self . opmerkingen , ] [EOL] return [ value for value in out if value ] [EOL] [EOL] [EOL] class HeemskerkAktenDoc ( BaseDocument ) : [EOL] [EOL] class Index : [EOL] name = [string] [EOL] [EOL] def __new__ ( cls ) : [EOL] return Index ( name = cls . name ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def parse_entry ( entry ) : [EOL] return entry . strip ( ) or None [EOL] [EOL] [EOL] def list_doctypes ( ) : [EOL] return [ CardNameDoc , VoornamenDoc , HeemskerkMaatboekDoc ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['BaseDocument']$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['CardNameDoc']$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['VoornamenDoc']$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional['HeemskerkMaatboekDoc']$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Type[BaseDocument]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] [EOL] import flask [EOL] [EOL] app = flask . Flask ( __name__ ) [EOL] app . config [ [string] ] = os . environ . get ( [string] , [string] ) [EOL] [EOL] from . import view [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import model [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from urllib . parse import quote [EOL] from typing import List , Tuple , Type [EOL] [EOL] import flask [EOL] [EOL] from . import app [EOL] from . import controller [EOL] from . model import BaseDocument , list_doctypes [EOL] [EOL] [EOL] @ app . route ( [string] ) def home ( ) : [EOL] q = flask . request . args . get ( [string] ) [EOL] return index ( ) if not q else search ( ) [EOL] [EOL] [EOL] def index ( ) : [EOL] return flask . render_template ( [string] , show_search = controller . is_elasticsearch_reachable ( ) , ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def search ( ) : [EOL] q = flask . request . args . get ( [string] ) [EOL] doctypes_selection = [ doctype for doctype in list_doctypes ( ) if flask . request . args . get ( doctype . __name__ ) == [string] ] [EOL] if not doctypes_selection : [EOL] doctypes_selection = list_doctypes ( ) [EOL] doctypes = [ ( doctype . get_index_name_pretty ( ) , doctype . __name__ , doctype in doctypes_selection ) for doctype in list_doctypes ( ) ] [EOL] if not q : [EOL] return flask . render_template ( [string] , show_search = controller . is_elasticsearch_reachable ( ) , doctypes = doctypes , ) [EOL] elif len ( q ) <= [number] : [EOL] return show_names_list ( q ) [EOL] cards_per_page = [number] [EOL] page = flask . request . args . get ( [string] , default = [number] , type = int ) [EOL] searcher = controller . Searcher ( q . lower ( ) , start = ( page - [number] ) * cards_per_page , size = cards_per_page , doctypes = doctypes_selection ) [EOL] hits = searcher . get_results ( ) [EOL] hits_formatted = [ format_hit ( hit ) for hit in hits ] [EOL] hits_total = searcher . count ( ) [EOL] page_range = controller . get_page_range ( hits_total , page , cards_per_page ) [EOL] query_string = f' [string] { quote ( q ) } [string] ' [EOL] [EOL] if page == [number] : [EOL] suggestions = controller . get_suggestions ( searcher . keywords ) [EOL] else : [EOL] suggestions = { } [EOL] suggestion_urls = { } [EOL] for token , _suggs in suggestions . items ( ) : [EOL] for suggestion in _suggs : [EOL] q_new = re . sub ( [string] . format ( token ) , f'{ token } [string] { suggestion }' , q ) [EOL] url = f' [string] { quote ( q_new ) }' [EOL] suggestion_urls [ suggestion ] = url [EOL] [EOL] return flask . render_template ( [string] , hits = hits_formatted , hits_total = hits_total , q = q , query_string = query_string , page_range = page_range , page = page , suggestions = suggestion_urls , doctypes = doctypes , ) [EOL] [EOL] [EOL] @ app . route ( [string] ) def show_names_list ( q ) : [EOL] for letter in q . lower ( ) : [EOL] if not letter . isalpha ( ) : [EOL] return index ( ) [EOL] names_list = controller . get_names_list ( q ) [EOL] hits_total = len ( names_list ) [EOL] return flask . render_template ( [string] , namen = names_list , hits_total = hits_total ) [EOL] [EOL] [EOL] def format_hit ( doc ) : [EOL] return { [string] : doc . meta . id , [string] : doc . meta . score , [string] : doc . get_index_name_pretty ( ) , [string] : doc . get_title ( ) , [string] : doc . get_subtitle ( ) , [string] : doc . get_body_lines ( ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , Iterable , Set , List , Type [EOL] import model [EOL] import typing [EOL] import elasticsearch_dsl [EOL] import builtins [EOL] import re [EOL] from typing import Dict , List , Tuple , Iterable , Optional , Set , Type [EOL] [EOL] import elasticsearch_dsl [EOL] from elasticsearch_dsl import connections , Q , Search [EOL] from elasticsearch_dsl . query import MultiMatch , Query [EOL] from elasticsearch_dsl . response import Hit [EOL] [EOL] from . import app [EOL] from . model import CardNameDoc , BaseDocument , list_doctypes [EOL] [EOL] [EOL] connections . create_connection ( [string] , hosts = [ app . config [ [string] ] ] ) [EOL] [EOL] [EOL] class Searcher : [EOL] [EOL] def __init__ ( self , q , start , size , doctypes , ) : [EOL] self . q = q [EOL] self . start = start [EOL] self . size = size [EOL] if doctypes is None : [EOL] doctypes = list_doctypes ( ) [EOL] self . multimatch_fields = [ field for doctype in doctypes for field in doctype . get_multimatch_fields ( ) ] [EOL] year_range = self . parse_year_range ( ) [EOL] queries_must = [ ] [EOL] self . keywords = set ( ) [EOL] for part in self . q . split ( [string] ) : [EOL] part = part . strip ( ) [EOL] if part : [EOL] queries_must . append ( self . get_query ( part ) ) [EOL] query = Q ( [string] , must = queries_must ) [EOL] indices = [ doctype . Index . name for doctype in doctypes ] [EOL] s = Search ( index = indices , doc_type = doctypes ) . query ( query ) [EOL] s = s [ self . start : self . start + self . size ] [EOL] if year_range : [EOL] s = s . filter ( [string] , ** { [string] : { [string] : year_range [ [number] ] , [string] : year_range [ [number] ] } } ) [EOL] s = s . highlight ( [string] , number_of_fragments = [number] ) [EOL] self . s = s [EOL] [EOL] def get_query ( self , q ) : [EOL] [docstring] [EOL] queries = [ ] [EOL] if [string] in q : [EOL] query_list , keywords = self . handle_specific_field_request ( q ) [EOL] queries . extend ( query_list ) [EOL] else : [EOL] queries . append ( self . get_regular_query ( q ) ) [EOL] keywords = q . split ( ) [EOL] self . keywords . update ( keywords ) [EOL] if len ( queries ) == [number] : [EOL] raise RuntimeError ( [string] ) [EOL] elif len ( queries ) == [number] : [EOL] return queries [ [number] ] [EOL] else : [EOL] return Q ( [string] , should = queries ) [EOL] [EOL] def handle_specific_field_request ( self , q ) : [EOL] [docstring] [EOL] parts = q . split ( [string] ) [EOL] fields = [ ] [EOL] keywords_sets = [ ] [EOL] for part in parts [ : - [number] ] : [EOL] words = part . split ( [string] ) [EOL] fields . append ( words [ - [number] ] . strip ( [string] ) ) [EOL] if len ( words [ : - [number] ] ) > [number] : [EOL] keywords_sets . append ( [string] . join ( words [ : - [number] ] ) . strip ( [string] ) ) [EOL] keywords_sets . append ( parts [ - [number] ] . strip ( [string] ) ) [EOL] [comment] [EOL] if len ( keywords_sets ) > len ( fields ) : [EOL] fields = [ [string] ] + fields [EOL] queries = [ ] [EOL] keywords = [ ] [EOL] for i in range ( len ( fields ) ) : [EOL] if fields [ i ] == [string] : [EOL] queries . append ( self . get_regular_query ( keywords_sets [ i ] ) ) [EOL] else : [EOL] queries . append ( self . get_specific_field_query ( fields [ i ] , keywords_sets [ i ] ) ) [EOL] for keyword in keywords_sets [ i ] . split ( [string] ) : [EOL] keywords . append ( keyword ) [EOL] return queries , keywords [EOL] [EOL] @ staticmethod def get_specific_field_query ( field , keywords ) : [EOL] [docstring] [EOL] return Q ( [string] , ** { field : keywords } ) [EOL] [EOL] def get_regular_query ( self , keywords ) : [EOL] [docstring] [EOL] return MultiMatch ( [string] , query = keywords , fields = self . multimatch_fields ) [EOL] [EOL] def parse_year_range ( self ) : [EOL] pattern = re . compile ( [string] ) [EOL] match = pattern . search ( self . q ) [EOL] if match is None : [EOL] return None [EOL] year_start = int ( match . group ( [number] ) ) [EOL] year_end = int ( match . group ( [number] ) ) [EOL] self . q = pattern . sub ( repl = [string] , string = self . q ) . strip ( ) [EOL] return year_start , year_end [EOL] [EOL] def count ( self ) : [EOL] return self . s . count ( ) [EOL] [EOL] def get_results ( self ) : [EOL] res = list ( self . s ) [EOL] for hit in res : [EOL] for key , values in hit . meta . highlight . to_dict ( ) . items ( ) : [EOL] setattr ( hit , key , [string] . join ( values ) ) [EOL] return res [EOL] [EOL] [EOL] def get_page_range ( hits_total , page , cards_per_page ) : [EOL] page_total = hits_total // cards_per_page + [number] * ( hits_total % cards_per_page != [number] ) [EOL] ext = [number] [EOL] first_item = max ( ( page - ext , [number] ) ) [EOL] last_item = min ( ( page + ext , page_total ) ) [EOL] if page < ext + [number] : [EOL] last_item = min ( ( last_item + ext + [number] - page , page_total ) ) [EOL] if page_total - page < ext + [number] : [EOL] first_item = max ( ( first_item - ext + ( page_total - page ) , [number] ) ) [EOL] return list ( range ( first_item , last_item + [number] ) ) [EOL] [EOL] [EOL] def get_names_list ( q ) : [EOL] s = elasticsearch_dsl . Search ( index = CardNameDoc . Index . name ) [EOL] s . aggs . bucket ( name = [string] , agg_type = [string] , field = [string] , order = { [string] : [string] } , include = f'{ q . title ( ) } [string] ' , size = [number] ) [EOL] res = s . execute ( ) [EOL] names_list = res . aggregations [ [string] ] . buckets [EOL] [comment] [EOL] return names_list [EOL] [EOL] [EOL] def is_elasticsearch_reachable ( ) : [EOL] [docstring] [EOL] return connections . get_connection ( ) . ping ( ) [EOL] [EOL] [EOL] def get_suggestions ( keywords ) : [EOL] tokens = [ token for token in keywords if not token . isdigit ( ) ] [EOL] s = CardNameDoc . search ( ) [EOL] for field in [ [string] , [string] , [string] , [string] ] : [EOL] s = s . suggest ( name = field , text = [string] . join ( tokens ) , term = { [string] : field , [string] : [number] , [string] : [string] } ) [EOL] s = s . extra ( size = [number] ) [EOL] resp = s . execute ( ) [EOL] suggestions = { } [EOL] tokens_set = set ( tokens ) [EOL] for res_per_token in resp . suggest . to_dict ( ) . values ( ) : [EOL] for token_res in res_per_token : [EOL] token = token_res [ [string] ] [EOL] for option in token_res [ [string] ] : [EOL] suggestion = option [ [string] ] [EOL] if suggestion not in tokens_set : [EOL] suggestions . setdefault ( token , set ( ) ) . add ( suggestion ) [EOL] return { k : sorted ( v ) for k , v in suggestions . items ( ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elasticsearch_dsl.query.Query$ 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 $typing.Tuple[typing.List[elasticsearch_dsl.query.Query],typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[elasticsearch_dsl.query.Query]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $elasticsearch_dsl.query.Query$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $elasticsearch_dsl.query.MultiMatch$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[model.BaseDocument]$ 0 0 0 0 0 $typing.List[model.BaseDocument]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[model.BaseDocument]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[model.BaseDocument]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from collectiegroesbeek . model import CardNameDoc [EOL] [EOL] [EOL] class TestCardNameIndex : [EOL] [EOL] @ staticmethod def test_create_year ( ) : [EOL] assert CardNameDoc . create_year ( [string] ) == [number] [EOL] assert CardNameDoc . create_year ( [string] ) is None [EOL] assert CardNameDoc . create_year ( [string] ) == [number] [EOL] assert CardNameDoc . create_year ( [string] ) == [number] [EOL] assert CardNameDoc . create_year ( [string] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type [EOL] import collectiegroesbeek [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import logging [EOL] import sys [EOL] import csv [EOL] import argparse [EOL] import time [EOL] from typing import Type , Dict , Optional [EOL] [EOL] from elasticsearch . helpers import bulk [EOL] from elasticsearch_dsl import connections , Index [EOL] import tqdm [EOL] [EOL] from collectiegroesbeek . model import HeemskerkMaatboekDoc , BaseDocument , CardNameDoc , HeemskerkAktenDoc , VoornamenDoc [EOL] [EOL] if sys . version_info [ [number] ] < [number] : [EOL] raise ImportError ( [string] ) [EOL] [EOL] [EOL] connections . create_connection ( hosts = [ [string] ] ) [EOL] [EOL] [EOL] def logging_setup ( ) : [EOL] log_format = [string] [EOL] logging . basicConfig ( format = log_format , level = logging . DEBUG ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] logging . getLogger ( [string] ) . setLevel ( logging . WARNING ) [EOL] [EOL] [EOL] class CardProcessor : [EOL] [EOL] def __init__ ( self , batch_size = [number] ) : [EOL] self . batch_size = batch_size [EOL] self . client = connections . get_connection ( ) [EOL] self . _movers = { } [EOL] self . _items = [ ] [EOL] [EOL] def register_index ( self , doctype ) : [EOL] [docstring] [EOL] key = doctype . Index . name [EOL] if key in self . _movers : [EOL] return [EOL] self . _movers [ key ] = IndexMover ( doctype ) [EOL] [EOL] def add ( self , card ) : [EOL] d = card . to_dict ( include_meta = True ) [EOL] d [ [string] ] = self . _movers [ d [ [string] ] ] . new_name [EOL] self . _items . append ( d ) [EOL] if len ( self . _items ) > self . batch_size : [EOL] self . flush ( ) [EOL] [EOL] def flush ( self ) : [EOL] if len ( self . _items ) > [number] : [EOL] bulk ( self . client , self . _items ) [EOL] self . _items = [ ] [EOL] [EOL] def finalize ( self ) : [EOL] self . flush ( ) [EOL] for mover in self . _movers . values ( ) : [EOL] mover . move_alias_to_new ( ) [EOL] [EOL] [EOL] class IndexMover : [EOL] [EOL] def __init__ ( self , doctype ) : [EOL] self . alias = doctype . Index . name [EOL] if doctype . Index ( ) . exists ( ) : [EOL] self . old_name = next ( iter ( doctype . Index ( ) . get_alias ( ) . keys ( ) ) ) [EOL] self . old_es_index = Index ( name = self . old_name ) [EOL] else : [EOL] self . old_es_index = None [EOL] self . old_name = None [EOL] self . new_name = [string] . format ( self . alias , time . time ( ) ) [EOL] self . new_es_index = Index ( name = self . new_name ) [EOL] doctype . init ( index = self . new_name ) [EOL] [EOL] def move_alias_to_new ( self ) : [EOL] if self . old_es_index : [EOL] self . old_es_index . delete_alias ( name = self . alias ) [EOL] self . new_es_index . put_alias ( name = self . alias ) [EOL] if self . old_es_index : [EOL] self . old_es_index . delete ( ) [EOL] [EOL] [EOL] def filename_to_doctype ( filename ) : [EOL] filename = filename . lower ( ) [EOL] if filename . startswith ( [string] ) : [EOL] if [string] in filename : [EOL] return VoornamenDoc [EOL] return CardNameDoc [EOL] if [string] in filename : [EOL] if [string] in filename : [EOL] return HeemskerkMaatboekDoc [EOL] if [string] in filename : [EOL] return HeemskerkAktenDoc [EOL] else : [EOL] raise ValueError ( [string] . format ( filename ) ) [EOL] [EOL] [EOL] def run ( path , doctype_name ) : [EOL] processor = CardProcessor ( ) [EOL] filenames = sorted ( filename for filename in os . listdir ( path ) if filename . endswith ( [string] ) ) [EOL] pbar = tqdm . tqdm ( filenames ) [EOL] for filename in pbar : [EOL] pbar . set_postfix ( filename = filename ) [EOL] doctype = filename_to_doctype ( filename ) [EOL] if doctype_name and doctype . __name__ != doctype_name : [EOL] continue [EOL] processor . register_index ( doctype ) [EOL] filepath = os . path . join ( path , filename ) [EOL] with open ( filepath ) as f : [EOL] csvreader = csv . reader ( f ) [EOL] next ( csvreader ) [comment] [EOL] for line in csvreader : [EOL] if not line : [EOL] continue [EOL] card = doctype . from_csv_line ( line ) [EOL] if card is None : [EOL] continue [EOL] processor . add ( card ) [EOL] processor . finalize ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] logging_setup ( ) [EOL] assert connections . get_connection ( ) . ping ( ) [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , required = False , help = [string] ) [EOL] options = parser . parse_args ( ) [EOL] run ( path = options . path , doctype_name = options . doctype ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,IndexMover]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collectiegroesbeek.model.BaseDocument$ 0 0 0 0 0 $collectiegroesbeek.model.BaseDocument$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[collectiegroesbeek.model.BaseDocument]$ 0 0 0 0 0 0 0 $typing.Type[collectiegroesbeek.model.BaseDocument]$ 0 0 0 0 0 0 $typing.Type[collectiegroesbeek.model.BaseDocument]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[collectiegroesbeek.model.BaseDocument]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[collectiegroesbeek.model.BaseDocument]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0