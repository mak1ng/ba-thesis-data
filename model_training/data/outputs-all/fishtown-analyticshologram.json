from typing import List [EOL] import typing [EOL] from setuptools import setup [EOL] [EOL] requires = [ [string] , [string] , [string] , ] [EOL] [EOL] package_version = [string] [EOL] [EOL] [EOL] def read ( f ) : [EOL] return open ( f , encoding = [string] ) . read ( ) [EOL] [EOL] [EOL] setup ( name = [string] , description = [string] , long_description = read ( [string] ) , long_description_content_type = [string] , packages = [ [string] ] , package_data = { [string] : [ [string] ] } , version = package_version , author = [string] , author_email = [string] , url = [string] , install_requires = requires , setup_requires = [ [string] , [string] ] , tests_require = [ [string] , [string] , [string] ] , license = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Type , Any [EOL] import builtins [EOL] import typing [EOL] from dataclasses import fields [EOL] from enum import Enum [EOL] from typing import Type [EOL] [EOL] from hologram import JsonSchemaMixin , FieldEncoder [EOL] [EOL] [EOL] class StrEnum ( str , Enum ) : [EOL] def __str__ ( self ) : [EOL] return self . value [EOL] [EOL] [comment] [EOL] def _generate_next_value_ ( name , start , count , last_values ) : [EOL] return name [EOL] [EOL] [EOL] def StrLiteral ( value ) : [EOL] [comment] [EOL] return StrEnum ( value , value ) [comment] [EOL] [EOL] [EOL] def register_pattern ( base_type , pattern ) : [EOL] [docstring] [EOL] [EOL] class PatternEncoder ( FieldEncoder ) : [EOL] @ property def json_schema ( self ) : [EOL] return { [string] : [string] , [string] : pattern } [EOL] [EOL] JsonSchemaMixin . register_field_encoders ( { base_type : PatternEncoder ( ) } ) [EOL] [EOL] [EOL] class HyphenatedJsonSchemaMixin ( JsonSchemaMixin ) : [EOL] @ classmethod def field_mapping ( cls ) : [EOL] result = { } [EOL] for field in fields ( cls ) : [EOL] skip = field . metadata . get ( [string] ) [EOL] if skip : [EOL] continue [EOL] [EOL] if [string] in field . name : [EOL] result [ field . name ] = field . name . replace ( [string] , [string] ) [EOL] return result [EOL] [EOL] [EOL] class ExtensibleJsonSchemaMixin ( JsonSchemaMixin ) : [EOL] ADDITIONAL_PROPERTIES = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[StrEnum]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] from hologram import ValidationError , JsonSchemaMixin [EOL] from hologram . helpers import ExtensibleJsonSchemaMixin [EOL] [EOL] [EOL] @ dataclass class Extensible ( ExtensibleJsonSchemaMixin ) : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] @ dataclass class Inextensible ( JsonSchemaMixin ) : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] @ dataclass class ContainsExtended ( JsonSchemaMixin ) : [EOL] ext = ... [EOL] [EOL] [EOL] @ pytest . fixture def extensible_dict ( ) : [EOL] return { [string] : [string] , [string] : [number] } [EOL] [EOL] [EOL] @ pytest . fixture def extra_data ( extensible_dict ) : [EOL] extra = dict ( extensible_dict ) [EOL] extra [ [string] ] = [ ] [EOL] return extra [EOL] [EOL] [EOL] @ pytest . fixture def extensible ( ) : [EOL] return Extensible ( a = [string] , b = [number] ) [EOL] [EOL] [EOL] @ pytest . fixture def inextensible ( ) : [EOL] return Inextensible ( a = [string] , b = [number] ) [EOL] [EOL] [EOL] @ pytest . fixture def contains_extra_data ( extra_data ) : [EOL] return { [string] : dict ( extra_data ) } [EOL] [EOL] [EOL] @ pytest . fixture def contains ( ) : [EOL] return ContainsExtended ( ext = Extensible ( a = [string] , b = [number] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def contains_dict ( extensible_dict ) : [EOL] return { [string] : dict ( extensible_dict ) } [EOL] [EOL] [EOL] def test_extensible ( extra_data , extensible_dict , extensible ) : [EOL] assert Extensible . from_dict ( extra_data ) == extensible [EOL] assert Extensible . from_dict ( extensible_dict ) == extensible [EOL] assert extensible . to_dict ( ) == extensible_dict [EOL] assert Extensible . from_dict ( extra_data ) . to_dict ( ) == extensible_dict [EOL] [EOL] [EOL] def test_inextensible ( extra_data , extensible_dict , inextensible ) : [EOL] assert Inextensible . from_dict ( extensible_dict ) == inextensible [EOL] assert inextensible . to_dict ( ) == extensible_dict [EOL] with pytest . raises ( ValidationError ) : [EOL] Inextensible . from_dict ( extra_data ) [EOL] [EOL] [EOL] def test_contains ( contains_extra_data , contains_dict , contains ) : [EOL] assert ContainsExtended . from_dict ( contains_dict ) == contains [EOL] assert ( ContainsExtended . from_dict ( contains_extra_data ) . to_dict ( ) == contains_dict ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Extensible$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass , field [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] from hologram . helpers import HyphenatedJsonSchemaMixin [EOL] [EOL] [EOL] @ dataclass class HasUnderscoreConverts ( HyphenatedJsonSchemaMixin ) : [EOL] a_thing = field ( metadata = { [string] : True } ) [EOL] other_thing = ... [EOL] [EOL] [EOL] @ dataclass class ContainsHasUnderscoreConverts ( JsonSchemaMixin ) : [EOL] things = ... [EOL] [EOL] [EOL] @ pytest . fixture def underscore ( ) : [EOL] return HasUnderscoreConverts ( a_thing = [string] , other_thing = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def underscore_dict ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . fixture def contains ( underscore ) : [EOL] return ContainsHasUnderscoreConverts ( things = underscore ) [EOL] [EOL] [EOL] @ pytest . fixture def contains_dict ( underscore_dict ) : [EOL] return { [string] : underscore_dict } [EOL] [EOL] [EOL] @ pytest . fixture def bad_dict ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_base ( underscore , underscore_dict , bad_dict ) : [EOL] assert HasUnderscoreConverts . from_dict ( underscore_dict ) == underscore [EOL] assert underscore . to_dict ( ) == underscore_dict [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] HasUnderscoreConverts . from_dict ( bad_dict ) [EOL] [EOL] [EOL] def test_nested ( contains , contains_dict , bad_dict ) : [EOL] assert ContainsHasUnderscoreConverts . from_dict ( contains_dict ) == contains [EOL] assert contains . to_dict ( ) == contains_dict [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] ContainsHasUnderscoreConverts . from_dict ( { [string] : bad_dict } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $HasUnderscoreConverts$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import NewType [EOL] [EOL] from hologram import ValidationError , JsonSchemaMixin [EOL] from hologram . helpers import register_pattern [EOL] [EOL] [EOL] Uppercase = NewType ( [string] , str ) [EOL] register_pattern ( Uppercase , [string] ) [EOL] [EOL] [EOL] @ dataclass class Loud ( JsonSchemaMixin ) : [EOL] shouting = ... [EOL] normal = ... [EOL] [EOL] [EOL] @ pytest . fixture def loud ( ) : [EOL] return Loud ( shouting = [string] , normal = [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def loud_dict ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ pytest . fixture def too_quiet ( ) : [EOL] return { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def test_loud ( loud , loud_dict , too_quiet ) : [EOL] assert loud . to_dict ( ) == loud_dict [EOL] assert Loud . from_dict ( loud_dict ) == loud [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] Loud . from_dict ( too_quiet ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Uppercase$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import builtins [EOL] import typing [EOL] from dataclasses import dataclass , field [EOL] from typing import List , Optional , Union [EOL] from uuid import UUID [EOL] [EOL] from . conftest import ( Foo , Point , Recursive , OpaqueData , ShoppingCart , Product , ProductList , SubSchemas , Bar , Weekday , JsonSchemaMixin , Zoo , Baz , ) [EOL] import pytest [EOL] [EOL] from hologram import ValidationError [EOL] [EOL] [EOL] FOO_SCHEMA = { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [ { [string] : { [string] : [string] } , [string] : [string] } , { [string] : [string] } , ] } , [string] : { [string] : { [string] : [string] } , [string] : [string] } , [string] : { [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] ] , } , [string] : { [string] : [string] , [string] : [number] , [string] : [number] , [string] : [ { [string] : [string] } , { [string] : [string] } ] , } , [string] : { [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [ { [string] : [string] , [string] : [number] , [string] : [number] } , { [string] : [string] } , ] } , [string] : { [string] : [ { [string] : [string] } , { [string] : [string] } ] } , } , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] ] , [string] : False , } [EOL] [EOL] [comment] [EOL] POINT_SCHEMA = { [string] : Point . __doc__ , [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } , [string] : [ [string] , [string] ] , [string] : False , } [EOL] [EOL] RECURSIVE_SCHEMA = { [string] : Recursive . __doc__ , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [string] , [string] : [ [string] ] , [string] : False , } [EOL] [EOL] OPAQUE_DATA_SCHEMA = { [string] : OpaqueData . __doc__ , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } , [string] : [string] , [string] : [ [string] , [string] ] , [string] : False , } [EOL] [EOL] PRODUCT_SCHEMA = { [string] : Product . __doc__ , [string] : { [string] : { [string] : [string] , [string] : [number] } , [string] : { [string] : [string] } , } , [string] : [ [string] ] , [string] : [string] , [string] : False , } [EOL] [EOL] SHOPPING_CART_SCHEMA = { [string] : ShoppingCart . __doc__ , [string] : { [string] : { [string] : { [string] : [string] } , [string] : [string] } } , [string] : [ [string] ] , [string] : [string] , [string] : False , } [EOL] PRODUCT_LIST_SCHEMA = { [string] : ProductList . __doc__ , [string] : { [string] : { [string] : { [string] : [string] } , [string] : [string] , } } , [string] : [string] , [string] : [ [string] ] , [string] : False , } [EOL] BAR_SCHEMA = { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : [ { [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] , ] , } , { [string] : [string] } , ] } } , [string] : [ [string] ] , [string] : False , } [EOL] ZOO_SCHEMA = { [string] : [string] , [string] : [string] , [string] : { [string] : { [string] : { [string] : [string] } , [string] : [string] , [string] : { } , } } , [string] : False , } [EOL] BAZ_SCHEMA = { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [number] , [string] : [number] } } } , [string] : [string] , [string] : False , } [EOL] [EOL] [EOL] def test_field_with_default_factory ( ) : [EOL] assert Zoo ( animal_types = { } ) == Zoo . from_dict ( { } ) [EOL] assert Zoo ( animal_types = { [string] : [string] , [string] : [string] } ) == Zoo . from_dict ( { [string] : { [string] : [string] , [string] : [string] } } ) [EOL] [EOL] [EOL] def test_field_with_default_dataclass ( ) : [EOL] assert Baz ( a = Point ( [number] , [number] ) ) == Baz . from_dict ( { } ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_json_schema ( ) : [EOL] definitions = { [string] : POINT_SCHEMA } [EOL] schema = { ** FOO_SCHEMA , ** { [string] : definitions , [string] : [string] , } , } [EOL] assert schema == Foo . json_schema ( ) [EOL] [EOL] [EOL] def test_serialise_deserialise ( ) : [EOL] data = { [string] : [string] , [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] , [string] : [string] , [string] : [ [string] , [number] ] , [string] : [ [string] ] , [string] : { [string] : [number] , [string] : [number] } , } [EOL] f = Foo . from_dict ( data ) [EOL] assert f . f == ( [string] , [number] ) [EOL] assert f . g == ( [string] , ) [EOL] assert data == f . to_dict ( ) [EOL] [EOL] [EOL] def test_invalid_data ( ) : [EOL] with pytest . raises ( ValidationError ) : [EOL] Point . from_dict ( { [string] : [number] , [string] : [string] } ) [EOL] [EOL] [EOL] def test_newtype_field_validation ( ) : [EOL] with pytest . raises ( ValidationError ) : [EOL] Foo . from_dict ( { [string] : [string] , [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : { [string] : [number] , [string] : [number] } , [string] : [string] , [string] : [string] , [string] : [ [string] , [number] ] , [string] : [ [string] ] , } ) [EOL] [EOL] [EOL] def test_recursive_data ( ) : [EOL] data = { [string] : [string] , [string] : { [string] : [string] } } [EOL] r = Recursive . from_dict ( data ) [EOL] assert r . a == [string] [EOL] assert r . to_dict ( ) == data [EOL] [EOL] [EOL] def test_recursive_validation ( ) : [EOL] [comment] [EOL] data = { [string] : [ { [string] : [string] , [string] : [number] } , { [string] : [string] , [string] : [number] } , ] } [EOL] cart = ShoppingCart . from_dict ( data , validate = True ) [EOL] assert len ( cart . items ) == [number] [EOL] assert { item . name for item in cart . items } == { [string] , [string] } [EOL] assert cart . cost == [number] + [number] [EOL] [EOL] [comment] [EOL] data = { [string] : [ { [string] : [number] } ] } [EOL] with pytest . raises ( ValidationError ) : [EOL] ShoppingCart . from_dict ( data , validate = True ) [EOL] [EOL] [EOL] def test_non_string_keys ( ) : [EOL] p = ProductList ( products = { UUID ( [string] ) : Product ( name = [string] , cost = [number] ) } ) [EOL] expected_data = { [string] : { [string] : { [string] : [string] , [string] : [number] , } } } [EOL] assert p . to_dict ( ) == expected_data [EOL] assert ProductList . from_dict ( expected_data ) == p [EOL] [EOL] [EOL] def test_type_union_schema ( ) : [EOL] expected_schema = { ** BAR_SCHEMA , [string] : { [string] : POINT_SCHEMA } , [string] : [string] , } [EOL] assert expected_schema == Bar . json_schema ( ) [EOL] [EOL] [EOL] def test_type_union_serialise ( ) : [EOL] assert Bar ( a = Weekday . MON ) . to_dict ( ) == { [string] : [string] } [EOL] assert Bar ( a = Point ( x = [number] , y = [number] ) ) . to_dict ( ) == { [string] : { [string] : [number] , [string] : [number] } } [EOL] [EOL] [EOL] def test_type_union_deserialise ( ) : [EOL] assert Bar . from_dict ( { [string] : [string] } ) == Bar ( a = Weekday . FRI ) [EOL] assert Bar . from_dict ( { [string] : { [string] : [number] , [string] : [number] } } ) == Bar ( a = Point ( x = [number] , y = [number] ) ) [EOL] [EOL] [EOL] def test_default_values ( ) : [EOL] assert Product ( name = [string] , cost = [number] ) == Product . from_dict ( { [string] : [string] } ) [EOL] [EOL] [EOL] def test_default_factory ( ) : [EOL] @ dataclass class ClassTest ( JsonSchemaMixin ) : [EOL] attri = field ( default_factory = lambda : [ [string] ] ) [EOL] [EOL] assert ClassTest ( ) . attri == [ [string] ] [EOL] assert ClassTest ( ) . to_dict ( ) == { [string] : [ [string] ] } [EOL] assert ClassTest . from_dict ( { } ) . attri == [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_optional_field_no_default ( ) : [EOL] @ dataclass class FooBar ( JsonSchemaMixin ) : [EOL] id = ... [EOL] [EOL] schema = FooBar . json_schema ( embeddable = True ) [EOL] [EOL] assert not hasattr ( schema [ [string] ] , [string] ) [EOL] [EOL] [EOL] def test_required_union_field_no_default ( ) : [EOL] @ dataclass class FooBar ( JsonSchemaMixin ) : [EOL] id = ... [EOL] [EOL] schema = FooBar . json_schema ( embeddable = True ) [EOL] [EOL] assert [string] in schema [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.str],builtins.str]]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.float],builtins.str]]],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] from hologram import JsonSchemaMixin [EOL] from typing import Dict , Union [EOL] [EOL] [EOL] @ dataclass class DictFieldValue ( JsonSchemaMixin ) : [EOL] z = ... [EOL] [EOL] [EOL] @ dataclass class SecondDictFieldValue ( JsonSchemaMixin ) : [EOL] z = ... [EOL] [EOL] [EOL] @ dataclass class HasDictFields ( JsonSchemaMixin ) : [EOL] a = ... [EOL] x = ... [EOL] z = ... [EOL] [EOL] [EOL] def test_schema ( ) : [EOL] schema = HasDictFields . json_schema ( ) [EOL] [EOL] assert schema [ [string] ] == [string] [EOL] assert schema [ [string] ] == [ [string] , [string] , [string] ] [EOL] assert schema [ [string] ] == { [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : { [string] : [string] } } , [string] : { [string] : [string] , [string] : { [string] : [ { [string] : [string] } , { [string] : [string] } , ] } , } , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.Union[DictFieldValue,SecondDictFieldValue]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Any [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Union [EOL] [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] from hologram . helpers import StrEnum [EOL] [EOL] [EOL] class MySelector ( StrEnum ) : [EOL] A = [string] [EOL] B = [string] [EOL] C = [string] [EOL] [EOL] [EOL] @ dataclass class RestrictAB ( JsonSchemaMixin ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A , MySelector . B ] } ) [EOL] bar = ... [EOL] [EOL] [EOL] @ dataclass class RestrictC ( JsonSchemaMixin ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . C ] } ) [EOL] baz = ... [EOL] [EOL] [EOL] @ dataclass class HasRestricted ( JsonSchemaMixin ) : [EOL] thing = ... [EOL] [EOL] [EOL] def test_encode ( ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . A , bar = [number] ) ) [EOL] assert x . to_dict ( ) == { [string] : { [string] : [string] , [string] : [number] } } [EOL] [EOL] y = HasRestricted ( thing = [number] ) [EOL] assert y . to_dict ( ) == { [string] : [number] } [EOL] [EOL] z = HasRestricted ( thing = RestrictC ( foo = MySelector . C , baz = [string] ) ) [EOL] assert z . to_dict ( ) == { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . C , bar = [number] ) ) [EOL] x . to_dict ( validate = True ) [EOL] [EOL] [EOL] def test_decode ( ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . A , bar = [number] ) ) [EOL] assert ( HasRestricted . from_dict ( { [string] : { [string] : [string] , [string] : [number] } } , validate = True ) == x ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] HasRestricted . from_dict ( { [string] : { [string] : [string] , [string] : [number] } } , validate = True ) [EOL] [EOL] [EOL] @ dataclass class FancyRestrictBase ( JsonSchemaMixin ) : [EOL] foo = ... [EOL] [EOL] [EOL] @ dataclass class FancyRestrictATrue ( FancyRestrictBase ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A ] } ) [EOL] is_something = field ( metadata = { [string] : [ True ] } ) [EOL] bar = ... [EOL] [EOL] [EOL] @ dataclass class FancyRestrictAFalse ( FancyRestrictBase ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A ] } ) [EOL] is_something = field ( metadata = { [string] : [ False ] } ) [EOL] bar = ... [EOL] [EOL] [EOL] @ dataclass class FancyRestrictBC ( FancyRestrictBase ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . B , MySelector . C ] } ) [EOL] bar = ... [EOL] [EOL] [EOL] @ dataclass class HasFancyRestricted ( JsonSchemaMixin ) : [EOL] thing = ... [EOL] [EOL] [EOL] def test_multi_symmetric ( ) : [EOL] x = HasFancyRestricted ( thing = FancyRestrictATrue ( foo = MySelector . A , is_something = True , bar = [string] ) ) [EOL] x_dict = { [string] : { [string] : [string] , [string] : True , [string] : [string] } } [EOL] assert x . to_dict ( validate = True ) == x_dict [EOL] assert HasFancyRestricted . from_dict ( x_dict , validate = True ) == x [EOL] [EOL] y = HasFancyRestricted ( thing = FancyRestrictAFalse ( foo = MySelector . A , is_something = False , bar = [string] ) ) [EOL] y_dict = { [string] : { [string] : [string] , [string] : False , [string] : [string] } } [EOL] assert y . to_dict ( ) == y_dict [EOL] assert HasFancyRestricted . from_dict ( y_dict ) == y [EOL] [EOL] z = HasFancyRestricted ( thing = FancyRestrictBC ( foo = MySelector . C , bar = [string] ) ) [EOL] z_dict = { [string] : { [string] : [string] , [string] : [string] } } [EOL] assert z . to_dict ( ) == z_dict [EOL] assert HasFancyRestricted . from_dict ( z_dict ) == z [EOL] [EOL] [comment] [EOL] assert x . thing . to_dict ( ) == x_dict [ [string] ] [EOL] assert FancyRestrictATrue . from_dict ( x_dict [ [string] ] ) == x . thing [EOL] [comment] [EOL] assert y . thing . to_dict ( ) == y_dict [ [string] ] [EOL] assert FancyRestrictAFalse . from_dict ( y_dict [ [string] ] ) == y . thing [EOL] [comment] [EOL] assert z . thing . to_dict ( ) == z_dict [ [string] ] [EOL] assert FancyRestrictBC . from_dict ( z_dict [ [string] ] ) == z . thing [EOL] [EOL] [EOL] def test_json_schema_ok ( ) : [EOL] schema = HasFancyRestricted . json_schema ( ) [EOL] assert schema [ [string] ] is False [EOL] assert schema [ [string] ] == { [string] : { [string] : [ { [string] : [string] } , { [string] : [string] } , { [string] : [string] } , ] } } [EOL] assert schema [ [string] ] == [ [string] ] [EOL] [EOL] for k in [string] , [string] , [string] : [EOL] assert k in schema [ [string] ] [EOL] assert schema [ [string] ] [ k ] [ [string] ] is False [EOL] assert schema [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] assert schema [ [string] ] [ [string] ] [ [string] ] == { [string] : { [string] : [ [string] ] , [string] : [string] } , [string] : { [string] : [ True ] , [string] : [string] } , [string] : { [string] : [string] } , } [EOL] assert sorted ( schema [ [string] ] [ [string] ] [ [string] ] ) == [ [string] , [string] , [string] , ] [EOL] assert schema [ [string] ] [ [string] ] [ [string] ] == { [string] : { [string] : [ [string] ] , [string] : [string] } , [string] : { [string] : [ False ] , [string] : [string] } , [string] : { [string] : [string] } , } [EOL] assert sorted ( schema [ [string] ] [ [string] ] [ [string] ] ) == [ [string] , [string] , [string] ] [EOL] [EOL] schema [ [string] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] . sort ( ) [EOL] assert schema [ [string] ] [ [string] ] [ [string] ] == { [string] : { [string] : [ [string] , [string] ] , [string] : [string] } , [string] : { [string] : [string] } , } [EOL] assert sorted ( schema [ [string] ] [ [string] ] [ [string] ] ) == [ [string] , [string] , ] [EOL] [EOL] [EOL] class OtherSelector ( StrEnum ) : [EOL] X = [string] [EOL] Y = [string] [EOL] Z = [string] [EOL] [EOL] [EOL] @ dataclass class InvalidRestrictedType ( JsonSchemaMixin ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A , int ] } ) [EOL] [EOL] [EOL] def test_bad_restrictions ( ) : [EOL] with pytest . raises ( ValidationError ) : [EOL] InvalidRestrictedType . json_schema ( ) [EOL] [EOL] [EOL] @ dataclass class FancyRestrictATrueExtras ( FancyRestrictBase ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A ] } ) [EOL] is_something = field ( metadata = { [string] : [ True ] } ) [EOL] bar = ... [EOL] baz = ... [EOL] [EOL] [EOL] @ dataclass class HasFancyRestrictedOverlapping ( JsonSchemaMixin ) : [EOL] thing = ... [EOL] [EOL] [EOL] @ dataclass class HasFancyRestrictedOverlappingReversed ( JsonSchemaMixin ) : [EOL] thing = ... [EOL] [EOL] [EOL] def test_multi_overlapping_restricted ( ) : [EOL] classes = [ HasFancyRestrictedOverlapping , HasFancyRestrictedOverlappingReversed , ] [EOL] for cls in classes : [EOL] fancy_a = FancyRestrictATrue ( foo = MySelector . A , is_something = True , bar = [string] ) [EOL] fancy_a_extra = FancyRestrictATrueExtras ( foo = MySelector . A , is_something = True , bar = [string] , baz = [string] ) [EOL] x = cls ( thing = fancy_a ) [EOL] y = cls ( thing = fancy_a_extra ) [EOL] [EOL] assert cls . from_dict ( x . to_dict ( ) ) == x [EOL] assert cls . from_dict ( y . to_dict ( ) ) == y [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[RestrictAB,builtins.int,RestrictC]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[FancyRestrictATrue,FancyRestrictAFalse,FancyRestrictBC]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[FancyRestrictATrue,FancyRestrictAFalse,FancyRestrictBC,FancyRestrictATrueExtras,]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[FancyRestrictATrueExtras,FancyRestrictBC,FancyRestrictAFalse,FancyRestrictATrue,]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List [EOL] import typing [EOL] import tests [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] from typing import Union , Optional , List [EOL] [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] [EOL] [EOL] @ dataclass class IHaveAnnoyingUnions ( JsonSchemaMixin ) : [EOL] my_field = ... [EOL] [EOL] [EOL] @ dataclass class IHaveAnnoyingUnionsReversed ( JsonSchemaMixin ) : [EOL] my_field = ... [EOL] [EOL] [EOL] def test_union_decoding ( ) : [EOL] for field_value in ( None , [ [string] ] , [string] ) : [EOL] obj = IHaveAnnoyingUnions ( my_field = field_value ) [EOL] dct = { [string] : field_value } [EOL] decoded = IHaveAnnoyingUnions . from_dict ( dct ) [EOL] assert decoded == obj [EOL] assert obj . to_dict ( omit_none = False ) == dct [EOL] [EOL] [comment] [EOL] IHaveAnnoyingUnions ( my_field = ( [string] , ) ) == { [string] : ( [string] , ) } [EOL] [EOL] [EOL] def test_union_decoding_ordering ( ) : [EOL] for field_value in ( None , [ [string] ] , [string] ) : [EOL] obj = IHaveAnnoyingUnionsReversed ( my_field = field_value ) [EOL] dct = { [string] : field_value } [EOL] decoded = IHaveAnnoyingUnionsReversed . from_dict ( dct ) [EOL] assert decoded == obj [EOL] assert obj . to_dict ( omit_none = False ) == dct [EOL] [EOL] [comment] [EOL] IHaveAnnoyingUnionsReversed ( my_field = ( [string] , ) ) == { [string] : ( [string] , ) } [EOL] [EOL] [EOL] def test_union_decode_error ( ) : [EOL] x = IHaveAnnoyingUnions ( my_field = { [string] } ) [EOL] with pytest . raises ( ValidationError ) : [EOL] x . to_dict ( validate = True ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] IHaveAnnoyingUnions . from_dict ( { [string] : { [string] } } ) [EOL] [EOL] [EOL] @ dataclass class UnionMember ( JsonSchemaMixin ) : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass class LongOptionalUnion ( JsonSchemaMixin ) : [EOL] [comment] [EOL] member = ... [EOL] [EOL] [EOL] def test_long_union_decoding ( ) : [EOL] x = LongOptionalUnion ( None ) [EOL] x . to_dict ( ) == { [string] : None } [EOL] LongOptionalUnion . from_dict ( { [string] : None } ) [EOL] [EOL] x = LongOptionalUnion ( UnionMember ( [number] ) ) [EOL] x . to_dict ( ) == { [string] : { [string] : [number] } } [EOL] LongOptionalUnion . from_dict ( { [string] : { [string] : [number] } } ) == x [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] try : [EOL] LongOptionalUnion . from_dict ( { [string] : { [string] : [number] } } , validate = False ) [EOL] except ValidationError as exc : [EOL] str ( exc ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[None,UnionMember]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , List , Dict [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import hologram [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] from hologram . helpers import StrEnum , StrLiteral [EOL] from typing import Optional , Union , List [EOL] [EOL] [EOL] class Stage ( StrEnum ) : [EOL] one = [string] [EOL] two = [string] [EOL] [EOL] [EOL] @ dataclass class StageOneFoo ( JsonSchemaMixin ) : [EOL] unique_id = None [EOL] stage = Stage . one [EOL] has_default = None [EOL] [EOL] [EOL] @ dataclass class StageTwoFoo ( StageOneFoo , JsonSchemaMixin ) : [EOL] additional_information = None [EOL] stage = Stage . two [EOL] additional_default = None [EOL] [EOL] [EOL] def test_symmetry_StageOneFoo ( ) : [EOL] def assert_symmetry_StageOne ( value ) : [EOL] assert StageOneFoo . from_dict ( value ) . to_dict ( ) == value [EOL] [EOL] assert_symmetry_StageOne ( { [string] : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] def test_symmetry_StageTwoFoo ( ) : [EOL] def assert_symmetry_StageTwo ( value ) : [EOL] assert StageTwoFoo . from_dict ( value ) . to_dict ( ) == value [EOL] [EOL] assert_symmetry_StageTwo ( { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] [EOL] def test_wrong_class ( ) : [EOL] with pytest . raises ( ValidationError ) : [EOL] StageOneFoo . from_dict ( { [string] : [string] , [string] : [string] , [string] : [string] , } ) [EOL] [EOL] [EOL] def test_inferred_class ( ) : [EOL] assert isinstance ( JsonSchemaMixin . from_dict ( { [string] : [string] , [string] : [string] , [string] : [string] , } ) , StageTwoFoo , ) [EOL] [EOL] [EOL] @ dataclass class Thing ( JsonSchemaMixin ) : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass class OtherThing ( JsonSchemaMixin ) : [EOL] b = ... [EOL] c = ... [EOL] [EOL] [EOL] @ dataclass class MoreThings ( JsonSchemaMixin ) : [EOL] d = ... [EOL] e = ... [EOL] [EOL] [EOL] @ dataclass class Unioned ( JsonSchemaMixin ) : [EOL] unioned = ... [EOL] [EOL] [EOL] @ dataclass class Nested ( JsonSchemaMixin ) : [EOL] first = ... [EOL] top = ... [EOL] [EOL] [EOL] def test_tricky_unions ( ) : [EOL] dcts = { [string] : [ { [string] : [string] } , { [string] : [string] , [string] : [string] } , { [string] : [string] } , ] } [EOL] expected = [ Thing ( a = [string] ) , OtherThing ( b = [string] , c = [string] ) , Thing ( a = [string] ) , ] [EOL] assert Unioned . from_dict ( dcts ) . unioned == expected [EOL] assert Unioned . from_dict ( dcts ) . to_dict ( ) == dcts [EOL] [EOL] [EOL] def test_nested_ok ( ) : [EOL] nested = { [string] : { [string] : [string] } , [string] : [ [ { [string] : [string] } ] , { [string] : [string] } , { [string] : [string] , [string] : [string] } , [ { [string] : [string] , [string] : [string] } ] , ] , } [EOL] expected = [ [ Thing ( a = [string] ) ] , Thing ( a = [string] ) , OtherThing ( b = [string] , c = [string] ) , [ MoreThings ( d = [string] , e = [string] ) ] , ] [EOL] result = Nested . from_dict ( nested ) [EOL] assert result . top == expected [EOL] assert result . first == Thing ( a = [string] ) [EOL] [EOL] assert Nested . from_dict ( nested ) . to_dict ( ) == nested [EOL] [EOL] [EOL] def test_bad_nested ( ) : [EOL] bad_nested = { [string] : { [string] : [string] } , [string] : [ [ { [string] : [number] } ] , { [string] : [string] } , { [string] : [string] , [string] : [string] } , [ { [string] : [string] , [string] : [string] } ] , ] , } [EOL] with pytest . raises ( ValidationError ) : [EOL] Nested . from_dict ( bad_nested ) [EOL] [EOL] bad_nested_2 = { [string] : { [string] : [number] } , [string] : [ [ { [string] : [string] } ] , { [string] : [string] } , { [string] : [string] , [string] : [string] } , [ { [string] : [string] , [string] : [string] } ] , ] , } [EOL] with pytest . raises ( ValidationError ) : [EOL] Nested . from_dict ( bad_nested ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[Thing,OtherThing,MoreThings]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Thing$ 0 0 0 $typing.List[typing.Union[typing.List[Thing],Thing,OtherThing,typing.List[MoreThings]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Optional , List , Union , Dict , Any [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] import pytest [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import Union , NewType , Optional [EOL] [EOL] from hologram import JsonSchemaMixin , ValidationError [EOL] from hologram . helpers import StrEnum [EOL] [EOL] [EOL] class MySelector ( StrEnum ) : [EOL] A = [string] [EOL] B = [string] [EOL] C = [string] [EOL] [EOL] [EOL] @ dataclass class RestrictAB ( JsonSchemaMixin ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . A , MySelector . B ] } ) [EOL] bar = ... [EOL] [EOL] [EOL] @ dataclass class RestrictC ( JsonSchemaMixin ) : [EOL] foo = field ( metadata = { [string] : [ MySelector . C ] } ) [EOL] baz = ... [EOL] [EOL] [EOL] @ dataclass class A ( JsonSchemaMixin ) : [EOL] baz = ... [EOL] [EOL] [EOL] @ dataclass class B ( JsonSchemaMixin ) : [EOL] baz = ... [EOL] [EOL] [EOL] @ dataclass class HasRestricted ( JsonSchemaMixin ) : [EOL] thing = ... [EOL] [EOL] [EOL] def test_encode ( ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . A , bar = [number] ) ) [EOL] assert x . to_dict ( ) == { [string] : { [string] : [string] , [string] : [number] } } [EOL] [EOL] y = HasRestricted ( thing = [number] ) [EOL] assert y . to_dict ( ) == { [string] : [number] } [EOL] [EOL] z = HasRestricted ( thing = RestrictC ( foo = MySelector . C , baz = [string] ) ) [EOL] assert z . to_dict ( ) == { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . C , bar = [number] ) ) [EOL] x . to_dict ( validate = True ) [EOL] [EOL] [EOL] def test_decode ( ) : [EOL] x = HasRestricted ( thing = RestrictAB ( foo = MySelector . A , bar = [number] ) ) [EOL] assert ( HasRestricted . from_dict ( { [string] : { [string] : [string] , [string] : [number] } } , validate = True ) == x ) [EOL] [EOL] with pytest . raises ( ValidationError ) : [EOL] HasRestricted . from_dict ( { [string] : { [string] : [string] , [string] : [number] } } , validate = True ) [EOL] [EOL] [EOL] @ dataclass class IHaveExtremelyAnnoyingUnions ( JsonSchemaMixin ) : [EOL] my_field = None [EOL] [EOL] [EOL] def test_evil_union ( ) : [EOL] pairs = [ ( IHaveExtremelyAnnoyingUnions ( my_field = True ) . to_dict ( ) , { [string] : True } , ) , ( IHaveExtremelyAnnoyingUnions ( my_field = [string] ) . to_dict ( ) , { [string] : [string] } , ) , ( IHaveExtremelyAnnoyingUnions ( my_field = [number] ) . to_dict ( ) , { [string] : [number] } , ) , ( IHaveExtremelyAnnoyingUnions ( ) . to_dict ( ) , { } ) , ] [EOL] for a , b in pairs : [EOL] assert a == b [EOL] assert IHaveExtremelyAnnoyingUnions . from_dict ( b ) . to_dict ( ) == a [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $MySelector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[A,typing.Optional[typing.Union[RestrictAB,RestrictC]],B]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Optional[builtins.str],builtins.bool,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Union , Dict , List , Any [EOL] import builtins [EOL] import typing [EOL] import tests [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] from dataclasses import dataclass , field [EOL] from typing import List , Dict , Any [EOL] [EOL] [EOL] @ dataclass class Foo ( JsonSchemaMixin ) : [EOL] x = [number] [EOL] y = field ( default_factory = list ) [EOL] z = field ( default_factory = dict ) [EOL] [EOL] [EOL] def test_basic ( ) : [EOL] foo = Foo ( ) [EOL] assert foo . to_dict ( ) == { [string] : [number] , [string] : [ ] , [string] : { } } [EOL] assert Foo . from_dict ( { } ) == foo [EOL] [EOL] [EOL] def test_complex ( ) : [EOL] json_obj = { [string] : [number] , [string] : [ [string] , [string] ] , [string] : { [string] : [ [string] , [string] ] , [string] : [string] } , } [EOL] full_dict = { [string] : [number] , [string] : [ [string] , [string] ] , [string] : json_obj } [EOL] foo = Foo ( [number] , [ [string] , [string] ] , json_obj ) [EOL] assert foo . to_dict ( ) == full_dict [EOL] assert Foo . from_dict ( full_dict ) == foo [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List [EOL] import typing [EOL] import tests [EOL] from dataclasses import dataclass [EOL] from typing import Tuple [EOL] [EOL] from hologram import JsonSchemaMixin [EOL] [EOL] [EOL] @ dataclass class TupleMember ( JsonSchemaMixin ) : [EOL] a = ... [EOL] [EOL] [EOL] @ dataclass class TupleEllipsisHolder ( JsonSchemaMixin ) : [EOL] member = ... [EOL] [EOL] [EOL] @ dataclass class TupleMemberFirstHolder ( JsonSchemaMixin ) : [EOL] member = ... [EOL] [EOL] [EOL] @ dataclass class TupleMemberSecondHolder ( JsonSchemaMixin ) : [EOL] member = ... [EOL] [EOL] [EOL] def test_ellipsis_tuples ( ) : [EOL] dct = { [string] : [ { [string] : [number] } , { [string] : [number] } , { [string] : [number] } ] } [EOL] value = TupleEllipsisHolder ( member = ( TupleMember ( [number] ) , TupleMember ( [number] ) , TupleMember ( [number] ) ) ) [EOL] assert value . to_dict ( ) == dct [EOL] assert TupleEllipsisHolder . from_dict ( dct ) == value [EOL] [EOL] [EOL] def test_member_first_tuple ( ) : [EOL] dct = { [string] : [ { [string] : [number] } , [string] ] } [EOL] value = TupleMemberFirstHolder ( member = ( TupleMember ( [number] ) , [string] ) ) [EOL] TupleMemberFirstHolder . from_dict ( dct ) == value [EOL] value . to_dict ( ) == dct [EOL] [EOL] [EOL] def test_member_second_tuple ( ) : [EOL] dct = { [string] : [ [string] , { [string] : [number] } ] } [EOL] value = TupleMemberSecondHolder ( member = ( [string] , TupleMember ( [number] ) ) ) [EOL] TupleMemberSecondHolder . from_dict ( dct ) == value [EOL] value . to_dict ( ) == dct [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[TupleMember,...]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[TupleMember,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,TupleMember]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0