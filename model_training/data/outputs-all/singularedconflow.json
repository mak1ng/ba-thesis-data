from typing import TypeVar [EOL] import typing [EOL] import conflow [EOL] [docstring] [EOL] from typing import overload , cast , TypeVar [EOL] [EOL] from conflow . manager import Config [EOL] from conflow . node import Node , NodeList , NodeMap , TU , AbstractNode [EOL] [EOL] NB = TypeVar ( [string] , str , int , float , bool , None ) [EOL] NO = TypeVar ( [string] , str , int , float , bool , None ) [EOL] TB = TypeVar ( [string] ) [EOL] TO = TypeVar ( [string] ) [EOL] TR = TypeVar ( [string] ) [EOL] [EOL] [comment] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] [comment] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] [comment] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] @ overload def merge_factory ( base , other , config , ) : [EOL] [docstring] [EOL] ... [EOL] [EOL] [EOL] [comment] [EOL] def merge_factory ( base , other , config ) : [EOL] if isinstance ( base , Node ) and isinstance ( other , Node ) : [EOL] return other [EOL] [EOL] if isinstance ( base , Node ) and isinstance ( other , NodeList ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , Node ) and isinstance ( other , NodeMap ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , NodeList ) and isinstance ( other , Node ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , NodeList ) and isinstance ( other , NodeList ) : [EOL] return config . merge_list ( base , other ) [EOL] [EOL] if isinstance ( base , NodeList ) and isinstance ( other , NodeMap ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , NodeMap ) and isinstance ( other , Node ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , NodeMap ) and isinstance ( other , NodeList ) : [EOL] return config . merge_different ( base , other ) [EOL] [EOL] if isinstance ( base , NodeMap ) and isinstance ( other , NodeMap ) : [EOL] for key , value in other . items ( ) : [EOL] if key in base : [EOL] base [ key ] = merge_factory ( cast ( TU , base [ key ] ) , cast ( TU , value ) , config ) [EOL] else : [EOL] base [ key ] = value [EOL] return base [EOL] [EOL] return other [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.node.AbstractNode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from conflow . froms import from_env , from_yaml [EOL] from conflow . layer import Layer , LayerProtocol [EOL] from conflow . manager import Config [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , TypeVar , Any [EOL] import typing [EOL] import builtins [EOL] from typing import TypeVar , Dict , Any [EOL] [EOL] import yaml [EOL] [EOL] T = TypeVar ( [string] ) [EOL] [EOL] [EOL] def from_yaml ( file_name , required = False ) : [EOL] [docstring] [EOL] try : [EOL] with open ( file_name , [string] ) as file_handler : [EOL] yaml_str = file_handler . read ( ) [EOL] return yaml . safe_load ( yaml_str ) [EOL] except FileNotFoundError as error : [EOL] if required : [EOL] raise FileNotFoundError ( error ) [EOL] else : [EOL] return { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from conflow . froms . environment import from_env [EOL] from conflow . froms . yml import from_yaml [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] import conflow [EOL] import pytest [EOL] [EOL] from conflow . manager import Config [EOL] from conflow . policy import MergeListPolicy , MergeDifferentTypesPolicy [EOL] [EOL] [EOL] @ pytest . fixture def config_node_data ( ) : [EOL] return { [string] : { [string] : [number] , [string] : [string] , [string] : [number] , [string] : [ [number] , [number] , [string] ] , [string] : [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] , [string] : { [string] : [ [number] , [number] , [number] ] , [string] : { [string] : [string] , [string] : [number] } } , [string] : { [number] , [number] , [string] } , [string] : { [string] : [number] , [string] : [string] } , [string] : None } } [EOL] [EOL] [EOL] @ pytest . fixture def default_config ( ) : [EOL] return Config ( ) [EOL] [EOL] [EOL] @ pytest . fixture def strict_config ( ) : [EOL] return Config ( merge_different = MergeDifferentTypesPolicy . strict ) [EOL] [EOL] [EOL] @ pytest . fixture def extend_list_config ( ) : [EOL] config = Config ( ) [EOL] config . merge_list = MergeListPolicy . extend [EOL] return config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import conflow [EOL] import pytest [EOL] from conflow . node import node_factory , AbstractNode , Node , NodeList , NodeMap [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , Node ) , ( [number] , Node ) , ( [number] , Node ) , ( True , Node ) , ( None , Node ) , ( [ ] , NodeList ) , ( { } , NodeMap ) , ] ) def test_node_value ( value , type ) : [EOL] node = node_factory ( [string] , value ) [EOL] assert isinstance ( node , AbstractNode ) [EOL] assert isinstance ( node , type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Union , Dict , Any [EOL] import typing [EOL] import conflow [EOL] import pytest [comment] [EOL] from typing import Dict [EOL] from conflow . node import NodeMap , Node , AbstractNode [comment] [EOL] [EOL] [EOL] FLAT_VALUES = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [number] , [string] : [number] , [string] : None } , ] [EOL] [EOL] NESTED_VALUES = [ { [string] : { [string] : [ [number] , [number] , [number] ] , [string] : { [string] : [string] } } } ] [EOL] [EOL] ATTRIBUTE_ERROR_VALUES = [ { [number] : [number] } , { None : [number] } , { [number] : [number] } , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FLAT_VALUES + ATTRIBUTE_ERROR_VALUES ) def test_node_map ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] assert node == value [EOL] assert node != { [string] : None } [EOL] assert len ( node ) == len ( value ) [EOL] assert [string] not in node [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , NESTED_VALUES ) def test_node_map_nested ( value ) : [EOL] representation = ( [string] ) [EOL] node = NodeMap ( [string] , value ) [EOL] [EOL] assert repr ( node ) == representation [EOL] assert node == value [EOL] [EOL] assert node [ [string] ] == value [ [string] ] [EOL] assert node [ [string] ] [ [string] ] == value [ [string] ] [ [string] ] [EOL] assert node [ [string] ] [ [string] ] == value [ [string] ] [ [string] ] [EOL] [EOL] assert node . nested ( ) == value [ [string] ] [EOL] assert node . nested . list ( ) == value [ [string] ] [ [string] ] [EOL] assert node . nested . map ( ) == value [ [string] ] [ [string] ] [EOL] assert node . nested . map . a ( ) == value [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , NESTED_VALUES ) def test_node_map_nested_missed_chain ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] assert node . missing . missing ( ) is None [EOL] assert node . nested . map . missing ( ) is None [EOL] with pytest . raises ( KeyError ) : [EOL] node . nested . map [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FLAT_VALUES + ATTRIBUTE_ERROR_VALUES ) def test_map_getitem ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] for k in value : [EOL] assert k in node [EOL] assert node [ k ] == value [ k ] [EOL] assert isinstance ( node [ k ] , Node ) [EOL] assert isinstance ( node [ k ] , AbstractNode ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FLAT_VALUES ) def test_map_getattribute ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] for k in value : [EOL] assert k in node [EOL] assert getattr ( node , k ) == value [ k ] [EOL] assert isinstance ( getattr ( node , k ) , Node ) [EOL] assert isinstance ( getattr ( node , k ) , AbstractNode ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ATTRIBUTE_ERROR_VALUES ) def test_map_getattribute_error ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] for k in value : [EOL] assert k in node [EOL] with pytest . raises ( TypeError ) : [EOL] assert getattr ( node , k ) == value [ k ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FLAT_VALUES + ATTRIBUTE_ERROR_VALUES ) def test_map_repr ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] assert repr ( node ) , repr ( value ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , FLAT_VALUES + ATTRIBUTE_ERROR_VALUES ) def test_map_value ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] assert node ( ) , value [EOL] for k in value : [EOL] assert node [ k ] ( ) == value [ k ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , NESTED_VALUES ) def test_map_delete ( value ) : [EOL] node = NodeMap ( [string] , value ) [EOL] del ( node [ [string] ] [ [string] ] ) [EOL] assert len ( node . nested ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import conflow [EOL] import pytest [EOL] from conflow . node import Node , AbstractNode [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] , [string] ) , ( [number] , [number] , [string] ) , ( [number] , [number] , [string] ) , ( True , False , [string] ) , ( None , [number] , [string] ) , ] ) def test_node_value ( value , other , representation ) : [EOL] node = Node ( [string] , value ) [EOL] assert isinstance ( node , AbstractNode ) [EOL] assert isinstance ( node , Node ) [EOL] assert node ( ) == value [EOL] assert node ( ) != other [EOL] assert node == value [EOL] assert node != other [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [number] , [number] , True , None , ] ) def test_node_missing_getattr ( value ) : [EOL] assert Node ( [string] , value ) . missing . missingtoo == Node ( [string] , None ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [number] , [string] ) , ( [number] , [string] ) , ( True , [string] ) , ( None , [string] ) , ] ) def test_node_repr ( value , representation ) : [EOL] assert repr ( Node ( [string] , value ) ) == representation [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import pytest [EOL] import os [EOL] [EOL] from conflow import from_env [EOL] from conflow . manager import Config [EOL] [EOL] DEFAULT_SETTINGS = { [string] : { [string] : { [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , } } } [EOL] [EOL] ENV_SETTINGS = { [string] : { [string] : { [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , } } } [EOL] [EOL] [EOL] @ pytest . fixture def config ( ) : [EOL] return Config ( ) [EOL] [EOL] [EOL] def test_config_first_merge ( config ) : [EOL] config . merge ( DEFAULT_SETTINGS ) [EOL] assert config . layer is not None [EOL] [EOL] [EOL] def test_config_merge ( config ) : [EOL] config = config . merge ( DEFAULT_SETTINGS ) [EOL] assert config . layer . tree ( ) . db . master . host == [string] [EOL] config = config . merge ( ENV_SETTINGS ) [EOL] assert config . layer . tree ( ) . db . master . host == [string] [EOL] [EOL] [EOL] def test_config_get_attr ( config ) : [EOL] config = config . merge ( DEFAULT_SETTINGS ) [EOL] assert config . db . master . host == [string] [EOL] [EOL] [EOL] def test_config_get_item ( config ) : [EOL] config = config . merge ( DEFAULT_SETTINGS ) [EOL] assert config [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] def test_config_with_froms ( config ) : [EOL] os . environ [ [string] ] = [string] [EOL] os . environ [ [string] ] = [string] [EOL] config = config . merge ( DEFAULT_SETTINGS ) . merge ( from_env ( [string] ) ) [EOL] assert config . db . master . host ( ) == [string] [EOL] assert config . db . slave . host ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import conflow [EOL] import pytest [EOL] [EOL] from conflow . merge import merge_factory [EOL] from conflow . node import Node , NodeList , NodeMap [EOL] [EOL] [EOL] def test_merge_node_node ( default_config ) : [EOL] base = Node ( [string] , [string] ) [EOL] other = Node ( [string] , [string] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_node_nodelist ( default_config ) : [EOL] base = Node ( [string] , [string] ) [EOL] other = NodeList ( [string] , [ [number] ] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_node_nodemap ( default_config ) : [EOL] base = Node ( [string] , [string] ) [EOL] other = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodelist_node ( default_config ) : [EOL] base = NodeList ( [string] , [ [number] ] ) [EOL] other = Node ( [string] , [string] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodelist_nodelist_override ( default_config ) : [EOL] base = NodeList ( [string] , [ [number] ] ) [EOL] other = NodeList ( [string] , [ [number] ] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodelist_nodelist_extend ( extend_list_config ) : [EOL] base = NodeList ( [string] , [ [number] ] ) [EOL] other = NodeList ( [string] , [ [number] ] ) [EOL] expected = NodeList ( [string] , [ [number] , [number] ] ) [EOL] assert merge_factory ( base , other , extend_list_config ) == expected [EOL] [EOL] [EOL] def test_merge_nodelist_nodemap ( default_config ) : [EOL] base = NodeList ( [string] , [ [number] ] ) [EOL] other = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodemap_node ( default_config ) : [EOL] base = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] other = Node ( [string] , [string] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodemap_nodelist ( default_config ) : [EOL] base = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] other = NodeList ( [string] , [ [number] ] ) [EOL] assert merge_factory ( base , other , default_config ) == other [EOL] [EOL] [EOL] def test_merge_nodemap_nodemap_override ( default_config ) : [EOL] base = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] other = NodeMap ( [string] , { [string] : { [string] : { [string] : [string] } } } ) [EOL] result = merge_factory ( base , other , default_config ) [EOL] assert result . db . master . host == [string] [EOL] [EOL] [EOL] def test_merge_nodemap_nodemap_extend ( default_config ) : [EOL] base = NodeMap ( [string] , { [string] : { [string] : [string] } } ) [EOL] other = NodeMap ( [string] , { [string] : { [string] : [string] } } ) [EOL] result = merge_factory ( base , other , default_config ) [EOL] assert [string] in result [EOL] assert [string] in result [EOL] [EOL] [EOL] def test_merge_nodemap_nodemap_empty ( default_config ) : [EOL] base = NodeMap ( [string] , { } ) [EOL] other = NodeMap ( [string] , { } ) [EOL] expected = NodeMap ( [string] , { } ) [EOL] assert merge_factory ( base , other , default_config ) == expected [EOL] [EOL] [EOL] def test_merge_different_types_strict ( strict_config ) : [EOL] base = NodeMap ( [string] , { [string] : { [string] : [string] } } ) [EOL] other = NodeMap ( [string] , { [string] : [number] } ) [EOL] with pytest . raises ( RuntimeError ) as error : [EOL] merge_factory ( base , other , strict_config ) [EOL] error_message = ( [string] ) [EOL] assert str ( error . value ) == error_message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import conflow [EOL] from conflow . layer import Layer [EOL] from conflow . node import node_factory [EOL] [EOL] [EOL] def test_layer_tree ( default_config ) : [EOL] node_data = { [string] : [number] } [EOL] layer = Layer ( default_config , node_data , [string] ) [EOL] node = node_factory ( [string] , node_data ) [EOL] assert layer . tree ( ) == node [EOL] [EOL] [EOL] def test_layer_merge ( default_config ) : [EOL] base_layer = Layer ( default_config , { [string] : [number] } , [string] ) [EOL] other_layer = Layer ( default_config , { [string] : [number] } , [string] ) [EOL] base_layer . merge ( other_layer ) [EOL] assert base_layer . tree ( ) . a == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import conflow [EOL] import pytest [EOL] import os [EOL] [EOL] from conflow import from_env [EOL] from conflow . froms . environment import try_str_int , load_by_prefix , add_pair [EOL] [EOL] ENV_SETTINGS = { [string] : [string] , [string] : [string] , } [EOL] [EOL] DICT_REPRESENTATION = { [string] : { [string] : { [string] : [string] , [string] : [number] } } } [EOL] [EOL] [EOL] @ pytest . fixture def env_fixture ( ) : [EOL] for key , value in ENV_SETTINGS . items ( ) : [EOL] os . environ [ key ] = value [EOL] [EOL] [EOL] def test_from_environment_exists ( ) : [EOL] assert hasattr ( conflow , [string] ) [EOL] [EOL] [EOL] def test_from_environment_correct_loads ( env_fixture ) : [EOL] selected = load_by_prefix ( [string] ) [EOL] assert len ( selected ) == [number] [EOL] assert [string] in selected [EOL] assert [string] in selected [EOL] [EOL] [EOL] def test_from_environment_correct_adds_pairs ( ) : [EOL] env_map = { } [EOL] add_pair ( env_map , [string] , [string] ) [EOL] add_pair ( env_map , [string] , [string] ) [EOL] assert env_map == DICT_REPRESENTATION [EOL] [EOL] [EOL] def test_from_environment_correct_parses ( env_fixture ) : [EOL] env = from_env ( [string] ) [EOL] assert env == DICT_REPRESENTATION [EOL] [EOL] [EOL] def test_from_environment_try_str_int ( ) : [EOL] assert try_str_int ( [string] ) == [number] [EOL] assert try_str_int ( [number] ) == [number] [EOL] assert try_str_int ( [string] ) == [string] [EOL] assert try_str_int ( [string] ) == [string] [EOL] [EOL] [EOL] def test_from_environment_get_item ( env_fixture ) : [EOL] env = from_env ( [string] ) [EOL] assert env [ [string] ] == DICT_REPRESENTATION [ [string] ] [EOL] assert env [ [string] ] [ [string] ] == DICT_REPRESENTATION [ [string] ] [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import pytest [EOL] import mock [EOL] [EOL] import conflow [EOL] from conflow import from_yaml [EOL] [EOL] [EOL] @ pytest . fixture def yaml_fixture ( ) : [EOL] yaml = [string] [EOL] return yaml [EOL] [EOL] [EOL] def test_from_yaml_exists ( ) : [EOL] assert hasattr ( conflow , [string] ) [EOL] [EOL] [EOL] def test_from_yaml_correct_parses ( yaml_fixture ) : [EOL] mocked_open = mock . mock_open ( read_data = yaml_fixture ) [EOL] with mock . patch ( [string] , mocked_open ) : [EOL] yml = from_yaml ( [string] ) [EOL] assert yml [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] assert yml [ [string] ] [ [string] ] [ [string] ] == [number] [EOL] [EOL] [EOL] def test_from_yaml_correct_work_non_exists_file ( ) : [EOL] yml = from_yaml ( [string] , required = False ) [EOL] assert len ( yml ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any [EOL] import typing [EOL] import conflow [EOL] import os [EOL] from conflow import Config , from_env , from_yaml [EOL] from typing import Dict [EOL] [EOL] PATH = os . path . dirname ( __file__ ) [EOL] [EOL] DEFAULT_SETTINGS = { [string] : { [string] : { [string] : [string] , [string] : [number] , } , [string] : { [string] : [string] , [string] : [number] , } } } [EOL] [EOL] config = Config ( ) . merge ( DEFAULT_SETTINGS ) [EOL] assert config . db . master . host ( ) == [string] [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] env_settings = from_env ( [string] ) [EOL] [EOL] config = Config ( ) . merge ( DEFAULT_SETTINGS ) . merge ( env_settings ) [EOL] assert config . db . master . host ( ) == [string] [EOL] [EOL] develop_settings = from_yaml ( os . path . join ( PATH , [string] , [string] ) , required = True ) [EOL] [EOL] config = Config ( ) . merge ( DEFAULT_SETTINGS ) . merge ( env_settings ) . merge ( develop_settings ) [EOL] assert config . db . master . host ( ) == [string] [EOL] [EOL] print ( repr ( config . db ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 $typing.Dict$ 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 $typing.Dict$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $conflow.manager.Config$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $conflow.manager.Config$ 0 0 0 0 0