	0
[comment] [EOL] [EOL] import json [EOL] from shapely . geometry import Point [EOL] from mobility_pipeline . lib . voronoi import load_cell [EOL] [EOL] [EOL] def test_load_cell_polygon ( ) : [EOL] voronoi_json = [string] [EOL] polygon = load_cell ( json . loads ( voronoi_json ) ) [EOL] assert polygon . bounds == ( - [number] , - [number] , [number] , [number] ) [comment] [EOL] assert polygon . area == [number] [EOL] [EOL] [EOL] def test_load_cell_multipolygon ( ) : [EOL] voronoi_json = [string] [EOL] polygon = load_cell ( json . loads ( voronoi_json ) ) [EOL] assert polygon . bounds == ( - [number] , - [number] , [number] , [number] ) [comment] [EOL] assert polygon . area == [number] + [number] [EOL] assert polygon . contains ( Point ( [number] , - [number] ) ) [EOL] assert polygon . contains ( Point ( [number] , [number] ) ) [EOL] assert not polygon . contains ( Point ( [number] , [number] ) ) [comment] [EOL] assert not polygon . contains ( Point ( [number] , [number] ) ) [EOL] assert not polygon . contains ( Point ( [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from mobility_pipeline . lib . validate import validate_mobility , validate_mobility_full [EOL] [EOL] [EOL] def test_validate_mobility_simple_full_valid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is None [EOL] [EOL] [EOL] def test_validate_mobility_simple_missing_row_valid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_ori_1_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_ori_2_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_dst_1_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_dst_2_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_count_1_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_count_2_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_malformed_count_3_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_negative_count_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_unordered_1_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_unordered_2_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_simple_unordered_3_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility ( csv ) is not None [EOL] [EOL] [EOL] def test_validate_mobility_full_simple_missing_row_invalid ( ) : [EOL] csv = [ [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] , [ [string] , [string] , [string] , [string] ] ] [EOL] assert validate_mobility_full ( csv ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from shapely . geometry . polygon import Polygon [comment] [EOL] from lib . overlap import compute_overlap [EOL] [EOL] [EOL] def test_compute_overlap_simple ( ) : [EOL] polygon1 = Polygon ( [ ( - [number] , - [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ] ) [EOL] polygon2 = Polygon ( [ ( - [number] , - [number] ) , ( - [number] , - [number] ) , ( - [number] , - [number] ) , ( - [number] , - [number] ) ] ) [EOL] polygon3 = Polygon ( [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] enclosing = Polygon ( [ ( - [number] , - [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ] ) [EOL] [EOL] assert compute_overlap ( polygon1 , enclosing ) == [number] [EOL] assert compute_overlap ( polygon2 , enclosing ) == [number] [EOL] assert compute_overlap ( polygon3 , enclosing ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import List , Any , Union [EOL] import typing [EOL] from math import sqrt [EOL] from hypothesis import given [EOL] from hypothesis . strategies import lists , integers [EOL] import numpy as np [EOL] import pandas as pd [EOL] from shapely . geometry import MultiPolygon , Polygon [EOL] from mobility_pipeline . lib . make_matrix import make_tower_tower_matrix , make_admin_admin_matrix , make_admin_to_tower_matrix , make_tower_to_admin_matrix [EOL] [EOL] [EOL] PANDAS_COLUMNS = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_make_tower_tower_matrix_simple_full ( ) : [EOL] raw_mat = [ PANDAS_COLUMNS , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] mobility = pd . DataFrame ( raw_mat [ [number] : ] , columns = raw_mat [ [number] ] ) [EOL] mat = make_tower_tower_matrix ( mobility , [number] ) [EOL] expected_mat = [ [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] assert np . all ( mat == expected_mat ) [EOL] [EOL] [EOL] def test_make_tower_tower_matrix_simple_missing_rows ( ) : [EOL] raw_mat = [ PANDAS_COLUMNS , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] mobility = pd . DataFrame ( raw_mat [ [number] : ] , columns = raw_mat [ [number] ] ) [EOL] mat = make_tower_tower_matrix ( mobility , [number] ) [EOL] expected_mat = [ [ [number] , [number] ] , [ [number] , [number] ] ] [EOL] assert np . all ( mat == expected_mat ) [EOL] [EOL] [EOL] @ given ( lists ( integers ( min_value = [number] ) , min_size = [number] ) , integers ( min_value = [number] ) ) def test_make_tower_tower_matrix_hypothesis ( nums , num ) : [EOL] nums . append ( num ) [EOL] n_towers = int ( sqrt ( len ( nums ) ) ) [EOL] nums = nums [ : n_towers ** [number] ] [EOL] raw_mat = [ ] [EOL] nums_i = [number] [EOL] for i in range ( n_towers ) : [EOL] for j in range ( n_towers ) : [EOL] if nums [ nums_i ] != [number] : [EOL] raw_mat . append ( [ i , j , nums [ nums_i ] ] ) [EOL] nums_i += [number] [EOL] mobility = pd . DataFrame ( raw_mat , columns = PANDAS_COLUMNS ) [EOL] mat = make_tower_tower_matrix ( mobility , n_towers ) [EOL] expected_mat = np . reshape ( np . array ( nums ) , ( n_towers , n_towers ) ) [EOL] [EOL] assert np . all ( mat == expected_mat ) [EOL] [EOL] [EOL] def test_make_matrix_simple ( ) : [EOL] a = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] b = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] c = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] e = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] assert np . all ( make_admin_admin_matrix ( b , a , c ) == ( a @ b ) @ c ) [EOL] assert np . all ( ( a @ b ) @ c == e ) [EOL] [EOL] [EOL] [comment] [EOL] A = MultiPolygon ( [ Polygon ( [ ( - [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( - [number] , - [number] ) ] ) ] ) [EOL] B = MultiPolygon ( [ Polygon ( [ ( - [number] , - [number] ) , ( - [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ] ) ] ) [EOL] C = MultiPolygon ( [ Polygon ( [ ( [number] , - [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , - [number] ) ] ) ] ) [EOL] D = MultiPolygon ( [ Polygon ( [ ( [number] , - [number] ) , ( [number] , - [number] ) , ( [number] , - [number] ) , ( [number] , - [number] ) ] ) ] ) [EOL] [EOL] [EOL] def test_make_tower_to_admin ( ) : [EOL] expected = [ [ [number] / [number] , [number] / [number] ] , [ [number] , [number] / [number] ] ] [EOL] expected = np . array ( expected ) [EOL] [EOL] towers = [ A , C ] [EOL] admins = [ B , D ] [EOL] actual = make_tower_to_admin_matrix ( towers , admins ) [EOL] [EOL] assert np . all ( actual == expected ) [EOL] [EOL] [EOL] def test_make_admin_to_tower ( ) : [EOL] expected = [ [ [number] / [number] , [number] ] , [ [number] / [number] , [number] / [number] ] ] [EOL] expected = np . array ( expected ) [EOL] [EOL] towers = [ A , C ] [EOL] admins = [ B , D ] [EOL] actual = make_admin_to_tower_matrix ( admins , towers ) [EOL] [EOL] assert np . all ( actual == expected ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] from argparse import ArgumentParser [EOL] from os import path [EOL] [EOL] from data_interface import ( load_voronoi_cells , convert_shape_to_json , load_admin_cells , save_admin_tower , save_tower_admin , DATA_PATH , ) [EOL] from lib . make_matrix import ( make_tower_to_admin_matrix , make_admin_to_tower_matrix , ) [EOL] [EOL] [EOL] DESC = f""" [string] { path . abspath ( DATA_PATH ) } [string] """ [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( description = DESC , epilog = [string] , ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . shapefile_path_prefix : [EOL] print ( [string] ) [EOL] convert_shape_to_json ( args . shapefile_path_prefix , args . country_id ) [EOL] else : [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] tower_cells = load_voronoi_cells ( args . voronoi_path ) [EOL] admin_cells = load_admin_cells ( args . country_id ) [EOL] [EOL] print ( [string] ) [EOL] tower_admin_mat = make_tower_to_admin_matrix ( tower_cells , admin_cells ) [EOL] print ( [string] ) [EOL] admin_tower_mat = make_admin_to_tower_matrix ( admin_cells , tower_cells ) [EOL] [EOL] print ( [string] ) [EOL] save_tower_admin ( args . country_id , tower_admin_mat ) [EOL] save_admin_tower ( args . country_id , admin_tower_mat ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] from argparse import ArgumentParser [EOL] from os import path [EOL] [EOL] from data_interface import ( load_mobility , load_admin_tower , load_tower_admin , save_admin_admin , DATA_PATH , ) [EOL] from lib . make_matrix import ( make_tower_tower_matrix , make_admin_admin_matrix , ) [EOL] [EOL] [EOL] DESCRIPTION = f""" [string] { path . abspath ( DATA_PATH ) } [string] """ [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] parser = ArgumentParser ( description = DESCRIPTION , epilog = [string] , ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] print ( [string] ) [EOL] mobility_df = load_mobility ( args . mobility_path ) [EOL] [EOL] print ( [string] ) [EOL] tower_admin_mat = load_tower_admin ( args . country_id ) [EOL] admin_tower_mat = load_admin_tower ( args . country_id ) [EOL] [EOL] print ( [string] ) [EOL] tower_tower_mat = make_tower_tower_matrix ( mobility_df , len ( admin_tower_mat ) ) [EOL] [EOL] admin_admin_mat = make_admin_admin_matrix ( tower_tower_mat , tower_admin_mat , admin_tower_mat ) [EOL] print ( [string] ) [EOL] mat_path = save_admin_admin ( args . country_id , args . day_id , admin_admin_mat ) [EOL] print ( f" [string] { mat_path }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Any [EOL] import shapely [EOL] import typing [EOL] import matplotlib [EOL] [docstring] [EOL] [EOL] from matplotlib import pyplot as plt [comment] [EOL] from shapely . geometry import MultiPolygon [comment] [EOL] from descartes import PolygonPatch [comment] [EOL] from data_interface import ( load_voronoi_cells , load_towers , VORONOI_PATH , TOWERS_PATH , ) [EOL] [EOL] [EOL] def plot_polygon ( axes , polygon ) : [EOL] [docstring] [EOL] patch = PolygonPatch ( polygon , facecolor = [ [number] , [number] , [number] ] , edgecolor = [ [number] , [number] , [number] ] , alpha = [number] ) [EOL] axes . add_patch ( patch ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] cells = load_voronoi_cells ( VORONOI_PATH ) [EOL] towers = load_towers ( TOWERS_PATH ) [EOL] print ( [string] , len ( cells ) , [string] , len ( towers ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] plt . ioff ( ) [EOL] [EOL] fig = plt . figure ( ) [EOL] [comment] [EOL] ax = fig . add_axes ( ( [number] , [number] , [number] , [number] ) ) [EOL] ax . set_aspect ( [number] ) [EOL] [EOL] no_coor_indices = [ ] [EOL] for i , cell in enumerate ( cells ) : [EOL] plot_polygon ( ax , cell ) [EOL] if cell . area == [number] : [EOL] no_coor_indices . append ( i ) [EOL] for i , ( lat , lng ) in enumerate ( towers ) : [EOL] color = [string] [EOL] if i in no_coor_indices : [EOL] color = [string] [EOL] ax . plot ( lat , lng , color = color , marker = [string] , markersize = [number] , alpha = [number] ) [EOL] [EOL] [comment] [EOL] ax . relim ( ) [EOL] ax . autoscale_view ( ) [EOL] [EOL] plt . show ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any [EOL] import shapely [EOL] import typing [EOL] import matplotlib [EOL] [docstring] [EOL] [EOL] from random import uniform as rand [EOL] from matplotlib import pyplot as plt [comment] [EOL] from shapely . geometry import MultiPolygon [comment] [EOL] from descartes import PolygonPatch [comment] [EOL] from lib . make_matrix import make_a_to_b_matrix [EOL] from data_interface import ( load_admin_cells , load_voronoi_cells , VORONOI_PATH , COUNTRY_ID , ) [EOL] [EOL] [EOL] I_TOWER_TO_COLOR = [number] [EOL] [docstring] [EOL] [EOL] [EOL] def plot_polygon ( axes , polygon , color , _label = [string] ) : [EOL] [docstring] [EOL] patch = PolygonPatch ( polygon , facecolor = color , edgecolor = [ [number] , [number] , [number] ] , alpha = [number] , label = _label ) [EOL] axes . add_patch ( patch ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] admin_cells = load_admin_cells ( COUNTRY_ID ) [EOL] tower_cells = load_voronoi_cells ( VORONOI_PATH ) [EOL] mat = make_a_to_b_matrix ( tower_cells , admin_cells ) [EOL] for i in range ( len ( mat [ : , I_TOWER_TO_COLOR ] ) ) : [EOL] if mat [ i , I_TOWER_TO_COLOR ] != [number] : [EOL] print ( str ( i ) , mat [ i , I_TOWER_TO_COLOR ] ) [EOL] plt . ioff ( ) [EOL] fig = plt . figure ( ) [EOL] [comment] [EOL] axes = fig . add_axes ( ( [number] , [number] , [number] , [number] ) ) [EOL] axes . set_aspect ( [number] ) [EOL] [EOL] for i , admin in enumerate ( admin_cells ) : [EOL] if mat [ i , I_TOWER_TO_COLOR ] != [number] : [EOL] plot_polygon ( axes , admin , [ rand ( [number] , [number] ) , rand ( [number] , [number] ) , rand ( [number] , [number] ) ] , str ( i ) ) [EOL] else : [EOL] plot_polygon ( axes , admin , [ [number] , [number] , [number] ] ) [EOL] plot_polygon ( axes , tower_cells [ I_TOWER_TO_COLOR ] , [ [number] , [number] , [number] ] ) [EOL] [EOL] axes . relim ( ) [EOL] axes . autoscale_view ( ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import io [EOL] import _csv [EOL] import typing [EOL] [docstring] [EOL] [EOL] import csv [EOL] from mobility_pipeline . data_interface import TOWERS_PATH , MOBILITY_PATH , load_voronoi_cells , load_towers , VORONOI_PATH , COUNTRY_ID [EOL] from mobility_pipeline . lib . validate import validate_mobility , validate_admins , validate_voronoi , validate_tower_cells_aligned , validate_tower_index_name_aligned [EOL] [EOL] [EOL] def validate_data_files ( ) : [EOL] [comment] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] f = None [EOL] try : [EOL] f = open ( TOWERS_PATH , [string] ) [EOL] towers_csv = csv . reader ( f ) [EOL] except ( FileNotFoundError , IOError ) as e : [EOL] msg = repr ( e ) [EOL] print ( f' [string] { TOWERS_PATH } [string] { msg }' ) [EOL] return False [EOL] else : [EOL] print ( [string] ) [EOL] align_error = validate_tower_index_name_aligned ( towers_csv ) [EOL] if align_error : [EOL] print ( f' [string] { align_error }' ) [EOL] return False [EOL] print ( [string] ) [EOL] towers = load_towers ( TOWERS_PATH ) [EOL] finally : [EOL] if f : [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] voronoi_errs = validate_voronoi ( VORONOI_PATH ) [EOL] if voronoi_errs : [EOL] print ( f' [string] { voronoi_errs }' ) [EOL] return False [EOL] print ( [string] ) [EOL] voronoi = load_voronoi_cells ( VORONOI_PATH ) [EOL] [EOL] [comment] [EOL] tower_voronoi_align_err = validate_tower_cells_aligned ( voronoi , towers ) [EOL] if tower_voronoi_align_err : [EOL] print ( f' [string] { tower_voronoi_align_err }' ) [EOL] return False [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] f = open ( MOBILITY_PATH , [string] ) [EOL] mobility_csv = csv . reader ( f ) [EOL] except ( FileNotFoundError , IOError ) as e : [EOL] msg = repr ( e ) [EOL] print ( f' [string] { MOBILITY_PATH } [string] { msg }' ) [EOL] return False [EOL] else : [EOL] print ( [string] ) [EOL] mobility_err = validate_mobility ( list ( mobility_csv ) [ [number] : ] ) [EOL] if mobility_err : [EOL] print ( f' [string] { mobility_err }' ) [EOL] return False [EOL] print ( [string] ) [EOL] finally : [EOL] if f : [EOL] f . close ( ) [EOL] [EOL] [comment] [EOL] admin_errs = validate_admins ( COUNTRY_ID ) [EOL] if admin_errs : [EOL] print ( f' [string] { admin_errs }' ) [EOL] return False [EOL] print ( [string] ) [EOL] return True [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] if validate_data_files ( ) : [EOL] exit ( [number] ) [EOL] else : [EOL] exit ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import builtins [EOL] import shapely [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , Union , cast [EOL] from mypy_extensions import TypedDict [EOL] import numpy as np [comment] [EOL] from shapely . geometry import Polygon , MultiPolygon [comment] [EOL] [EOL] [EOL] def json_to_polygon ( points_json ) : [EOL] [docstring] [EOL] pts = np . array ( points_json ) [EOL] return Polygon ( pts ) [EOL] [EOL] [EOL] class VoronoiCell ( TypedDict ) : [EOL] [docstring] [EOL] type = ... [EOL] [comment] [EOL] coordinates = ... [EOL] [EOL] [EOL] def load_cell ( cell_json ) : [EOL] [docstring] [EOL] [comment] [EOL] if [string] not in cell_json : [EOL] return MultiPolygon ( [ Polygon ( [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] ) ] ) [EOL] [comment] [EOL] if cell_json [ [string] ] == [string] : [EOL] coors = cast ( List [ List [ List [ float ] ] ] , cell_json [ [string] ] ) [EOL] pol = json_to_polygon ( coors [ [number] ] ) [EOL] return MultiPolygon ( [ pol ] ) [EOL] pols = [ json_to_polygon ( pol_json [ [number] ] ) for pol_json in cast ( List [ List [ List [ List [ float ] ] ] ] , cell_json [ [string] ] ) ] [EOL] return MultiPolygon ( pols ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Union[typing.List[typing.List[typing.List[builtins.float]]],typing.List[typing.List[typing.List[typing.List[builtins.float]]]]]$ 0 0 0 0 0 0 $shapely.geometry.MultiPolygon$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Dict , Any , Sequence [EOL] import shapely [EOL] import typing [EOL] import numpy [EOL] import builtins [EOL] import collections [EOL] import pandas [EOL] [docstring] [EOL] [EOL] from collections . abc import Sequence [EOL] from typing import Tuple , Dict , List [EOL] import numpy as np [comment] [EOL] import pandas as pd [comment] [EOL] from shapely . strtree import STRtree [comment] [EOL] from shapely . geometry import MultiPolygon [comment] [EOL] from lib . overlap import compute_overlap [EOL] [EOL] [EOL] def make_tower_tower_matrix ( mobility , n_towers ) : [EOL] [docstring] [EOL] ori_indices = np . array ( [ np . repeat ( i , n_towers ) for i in np . arange ( [number] , n_towers ) ] ) . flatten ( ) [EOL] dst_indices = np . tile ( np . arange ( [number] , n_towers ) , n_towers ) [EOL] df = pd . DataFrame ( { [string] : ori_indices , [string] : dst_indices } ) [EOL] mobility = df . merge ( mobility , how = [string] , on = [ [string] , [string] ] ) [EOL] mobility = mobility . fillna ( [number] ) [EOL] np_array = mobility [ [string] ] . values [EOL] return np . reshape ( np_array , ( n_towers , n_towers ) ) [EOL] [EOL] [EOL] def generate_rtree ( polygons ) : [EOL] [docstring] [EOL] tree = STRtree ( polygons ) [EOL] index_mapping = { } [EOL] for i , mpoly in enumerate ( polygons ) : [EOL] index_mapping [ tuple ( [ tuple ( p . exterior . coords ) for p in mpoly ] ) ] = i [EOL] return tree , index_mapping [EOL] [EOL] [EOL] def make_a_to_b_matrix ( a_cells , b_cells ) : [EOL] [docstring] [EOL] mat = np . zeros ( ( len ( b_cells ) , len ( a_cells ) ) ) [EOL] a_rtree , tree_index_mapping = generate_rtree ( a_cells ) [EOL] for i , bcell in enumerate ( b_cells ) : [EOL] overlapping_cells = a_rtree . query ( bcell ) [EOL] for acell in overlapping_cells : [EOL] [comment] [EOL] coords = tuple ( [ tuple ( pol . exterior . coords ) for pol in acell ] ) [EOL] mat [ i ] [ tree_index_mapping [ coords ] ] = compute_overlap ( bcell , acell ) [EOL] return mat [EOL] [EOL] [EOL] def make_tower_to_admin_matrix ( tower_cells , admin_cells ) : [EOL] [docstring] [EOL] return make_a_to_b_matrix ( tower_cells , admin_cells ) [EOL] [EOL] [EOL] def make_admin_to_tower_matrix ( admin_cells , tower_cells ) : [EOL] [docstring] [EOL] return make_a_to_b_matrix ( admin_cells , tower_cells ) [EOL] [EOL] [EOL] def make_admin_admin_matrix ( tower_tower , tower_admin , admin_tower ) : [EOL] [docstring] [EOL] return ( tower_admin @ tower_tower ) @ admin_tower [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[shapely.strtree.STRtree,typing.Dict[typing.Tuple[builtins.tuple,...],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Union , Iterator , Optional [EOL] import builtins [EOL] import shapely [EOL] import typing [EOL] import numpy [EOL] [docstring] [EOL] [EOL] from typing import List , Optional , cast , Union , Iterator [EOL] from shapely . geometry import MultiPolygon , Polygon , Point [comment] [EOL] from shapely . ops import unary_union [comment] [EOL] import numpy as np [comment] [EOL] from data_interface import ( TOWER_PREFIX , load_admin_cells , load_voronoi_cells , ) [EOL] [EOL] [EOL] AREA_THRESHOLD = [number] [EOL] [docstring] [EOL] [EOL] [EOL] def all_numeric ( string ) : [EOL] [docstring] [EOL] for c in string : [EOL] if not c . isdigit ( ) : [EOL] return False [EOL] return True [EOL] [EOL] [EOL] def validate_mobility ( raw ) : [EOL] [comment] [EOL] [docstring] [EOL] prev_ori = - [number] [EOL] prev_dst = - [number] [EOL] for line in raw : [EOL] _ , ori_str , dst_str , count_str = line [EOL] ori_str = ori_str [ len ( TOWER_PREFIX ) : ] [EOL] dst_str = dst_str [ len ( TOWER_PREFIX ) : ] [EOL] if not all_numeric ( ori_str ) : [EOL] return [string] . format ( line , ori_str ) [EOL] if not all_numeric ( dst_str ) : [EOL] return [string] . format ( line , ori_str ) [EOL] if not all_numeric ( count_str ) : [EOL] return [string] . format ( line , count_str ) [EOL] ori = int ( ori_str ) [EOL] dst = int ( dst_str ) [EOL] count = int ( count_str ) [EOL] if ori < prev_ori : [EOL] return [string] . format ( line , prev_ori ) [EOL] if ori > prev_ori : [EOL] prev_ori = ori [EOL] prev_dst = - [number] [EOL] if dst <= prev_dst : [EOL] return [string] . format ( line , prev_dst ) [EOL] prev_dst = dst [EOL] [EOL] if count < [number] : [EOL] return [string] . format ( count ) [EOL] return None [EOL] [EOL] [EOL] def validate_mobility_full ( mobility ) : [EOL] [docstring] [EOL] n_towers = int ( mobility [ - [number] ] [ [number] ] [ [number] : ] ) + [number] [EOL] i_row = [number] [EOL] [EOL] for i_ori in range ( n_towers ) : [EOL] for i_dst in range ( n_towers ) : [EOL] _ , ori , dst , _ = mobility [ i_row ] [EOL] if ori != [string] . format ( i_ori ) or dst != [string] . format ( i_dst ) : [EOL] msg = [string] . format ( i_row , mobility [ i_row ] , [string] . format ( i_ori , i_dst ) ) [EOL] return msg [EOL] i_row += [number] [EOL] return None [EOL] [EOL] [EOL] def validate_tower_cells_aligned ( cells , towers ) : [EOL] [docstring] [EOL] for i , cell in enumerate ( cells ) : [EOL] tower = Point ( * towers [ i ] ) [EOL] if cell . area != [number] and not cell . contains ( tower ) : [EOL] return [string] . format ( i ) [EOL] return None [EOL] [EOL] [EOL] def validate_tower_index_name_aligned ( csv_reader ) : [EOL] [docstring] [EOL] next ( csv_reader ) [comment] [EOL] for i , row in enumerate ( csv_reader ) : [EOL] lst = cast ( List [ str ] , row ) [comment] [EOL] if lst [ [number] ] != TOWER_PREFIX + str ( i ) : [EOL] return [string] . format ( lst , TOWER_PREFIX , i ) [EOL] return None [EOL] [EOL] [EOL] def validate_contiguous_disjoint_cells ( cells ) : [EOL] [docstring] [EOL] [EOL] if not cells : [EOL] return [string] [EOL] [EOL] area_sum = [number] [EOL] for mpol in cells : [EOL] area_sum += mpol . area [EOL] cell_union = unary_union ( cells ) [EOL] union_area = cell_union . area [EOL] diff = union_area - area_sum [EOL] frac = diff / union_area [EOL] if frac > AREA_THRESHOLD : [EOL] return f' [string] ' f' [string] { area_sum } [string] { union_area }' [EOL] if frac < - AREA_THRESHOLD : [EOL] return f' [string] ' f' [string] { area_sum } [string] { union_area }' [EOL] return None [EOL] [EOL] [EOL] def validate_admins ( country_id ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] admins = load_admin_cells ( country_id ) [EOL] except ( FileNotFoundError , IOError ) as e : [EOL] msg = repr ( e ) [EOL] return f' [string] { msg }' [EOL] [EOL] error = validate_contiguous_disjoint_cells ( admins ) [EOL] if error : [EOL] return f' [string] { error }' [EOL] return None [EOL] [EOL] [EOL] def validate_voronoi ( voronoi_path ) : [EOL] [docstring] [EOL] try : [EOL] cells = load_voronoi_cells ( voronoi_path ) [EOL] except ( FileNotFoundError , IOError ) as e : [EOL] msg = repr ( e ) [EOL] return f' [string] { msg }' [EOL] error = validate_contiguous_disjoint_cells ( cells ) [EOL] if error : [EOL] return f' [string] { error }' [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Union [EOL] import shapely [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Union [EOL] from shapely . geometry import Polygon , MultiPolygon [comment] [EOL] [EOL] [EOL] def compute_overlap ( polygon_1 , polygon_2 ) : [EOL] [docstring] [EOL] [EOL] intersection = polygon_1 . intersection ( polygon_2 ) [EOL] return intersection . area / polygon_1 . area [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0