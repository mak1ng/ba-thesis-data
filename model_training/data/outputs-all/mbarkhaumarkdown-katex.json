[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Sequence , Type [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] import json [EOL] import typing as typ [EOL] import subprocess as sp [EOL] [EOL] import markdown_katex [EOL] from markdown_katex import html [EOL] [EOL] try : [EOL] import pretty_traceback [EOL] [EOL] pretty_traceback . install ( ) [EOL] except ImportError : [EOL] pass [comment] [EOL] [EOL] [EOL] ExitCode = int [EOL] [EOL] [EOL] def _selftest ( ) : [EOL] [comment] [EOL] from markdown_katex import wrapper [EOL] [EOL] print ( [string] ) [EOL] print ( json . dumps ( wrapper . parse_options ( ) , indent = [number] ) ) [EOL] print ( ) [EOL] [EOL] html_parts = [ ] [EOL] test_formulas = markdown_katex . TEST_FORMULAS [EOL] [EOL] for tex_formula in test_formulas : [EOL] html_part = wrapper . tex2html ( tex_formula ) [EOL] if not html_part : [EOL] return [number] [EOL] [EOL] html_parts . append ( html_part ) [EOL] [EOL] formula_html = [string] . join ( html_parts ) [EOL] html_text = html . HTML_TEMPLATE . replace ( [string] , formula_html ) [EOL] [EOL] with open ( [string] , mode = [string] ) as fobj : [EOL] fobj . write ( html_text . encode ( [string] ) ) [EOL] [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] [EOL] def main ( args = sys . argv [ [number] : ] ) : [EOL] [docstring] [EOL] [comment] [EOL] [EOL] if [string] in args : [EOL] return _selftest ( ) [EOL] [EOL] bin_cmd = markdown_katex . get_bin_cmd ( ) [EOL] [EOL] if [string] in args or [string] in args : [EOL] version = markdown_katex . __version__ [EOL] bin_str = [string] . join ( bin_cmd ) [EOL] print ( [string] , version , f" [string] { bin_str } [string] " ) [EOL] [EOL] return sp . check_call ( bin_cmd + list ( args ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ExitCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ExitCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import List , Callable [EOL] import typing [EOL] import markdown_katex [EOL] import src [EOL] [docstring] [EOL] [EOL] [EOL] __version__ = [string] [EOL] [EOL] from markdown_katex . wrapper import tex2html [EOL] from markdown_katex . wrapper import get_bin_cmd [EOL] from markdown_katex . extension import KatexExtension [EOL] [EOL] [EOL] def _make_extension ( ** kwargs ) : [EOL] return KatexExtension ( ** kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] makeExtension = _make_extension [EOL] [EOL] [EOL] TEST_FORMULAS = [string] . split ( [string] ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $markdown_katex.extension.KatexExtension$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _STYLESHEET_LINK = [string] [EOL] [EOL] _KATEX_IMAGE_STYLES = [string] [EOL] [EOL] KATEX_STYLES = _STYLESHEET_LINK + _KATEX_IMAGE_STYLES [EOL] [EOL] [EOL] HTML_TEMPLATE = [string] [EOL] [EOL] HTML_TEMPLATE = HTML_TEMPLATE . replace ( [string] , _STYLESHEET_LINK ) [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Set , Dict , Union [EOL] import io [EOL] import typing [EOL] import markdown [EOL] import pathlib2 [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] [EOL] import io [EOL] import re [EOL] import tempfile [EOL] import textwrap [EOL] from xml . etree . ElementTree import XML [EOL] [EOL] import bs4 [EOL] import pytest [EOL] import markdown as md [EOL] import pathlib2 as pl [EOL] [EOL] import markdown_katex [EOL] import markdown_katex . wrapper as wrp [EOL] import markdown_katex . extension as ext [EOL] [EOL] DATA_DIR = pl . Path ( __file__ ) . parent . parent / [string] [EOL] DATA_DIR . mkdir ( parents = True , exist_ok = True ) [EOL] [EOL] TMP_DIR = pl . Path ( tempfile . gettempdir ( ) ) / [string] [EOL] [EOL] BASIC_TEX_TXT = [string] [EOL] [EOL] TEX_WITH_SVG_OUTPUT = [string] [EOL] [EOL] [EOL] BASIC_BLOCK_TXT = [string] + BASIC_TEX_TXT + [string] [EOL] [EOL] [EOL] DEFAULT_MKDOCS_EXTENSIONS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] EXTENDED_BLOCK_TXT = [string] [EOL] [EOL] [EOL] EXTENDED_HTML_TEMPLATE = [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def katex_output ( ) : [EOL] path = DATA_DIR / [string] [EOL] with path . open ( mode = [string] ) as fobj : [EOL] return fobj . read ( ) [EOL] [EOL] [EOL] def test_svg2img ( katex_output ) : [EOL] assert [string] in katex_output [EOL] assert [string] in katex_output [EOL] [EOL] assert [string] not in katex_output [EOL] [EOL] result = ext . svg2img ( katex_output ) [EOL] [EOL] assert [string] in result [EOL] [EOL] out_path = DATA_DIR / [string] [EOL] with out_path . open ( mode = [string] ) as fobj : [EOL] fobj . write ( result ) [EOL] [EOL] [EOL] def test_regexp ( ) : [EOL] assert ext . MATH_FENCE_RE . match ( BASIC_BLOCK_TXT ) [EOL] alt_block_text = BASIC_BLOCK_TXT . replace ( [string] , [string] ) [EOL] assert ext . MATH_FENCE_RE . match ( alt_block_text ) [EOL] [EOL] [EOL] INLINE_TEST_CASES = { [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ ] , [string] : [ ] , [string] : [ ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , INLINE_TEST_CASES . items ( ) ) def test_inline_parsing ( line , expected ) : [EOL] result = [ code_item . inline_text for code_item in ext . iter_inline_katex ( line ) ] [EOL] assert result == expected [EOL] [EOL] [EOL] def test_inline_multiple ( ) : [EOL] md_text = textwrap . dedent ( [string] ) [EOL] result = md . markdown ( md_text , extensions = [ [string] ] ) [EOL] assert result . strip ( ) . startswith ( ext . KATEX_STYLES . strip ( ) ) [EOL] [comment] [EOL] assert result . count ( [string] ) == [number] [EOL] [comment] [EOL] assert [string] not in result [EOL] [EOL] [EOL] def test_determinism ( ) : [EOL] html_data1 = markdown_katex . tex2html ( BASIC_TEX_TXT ) [EOL] html_data2 = markdown_katex . tex2html ( BASIC_TEX_TXT ) [EOL] assert html_data1 == html_data2 [EOL] [EOL] [EOL] def test_tex2html ( ) : [EOL] assert len ( markdown_katex . TEST_FORMULAS ) > [number] [EOL] for formula in markdown_katex . TEST_FORMULAS : [EOL] md_text = [string] . format ( formula ) [EOL] html_text = ext . md_block2html ( md_text ) [EOL] assert html_text . startswith ( [string] ) [EOL] assert html_text . endswith ( [string] ) [EOL] [EOL] md_text = [string] . format ( formula ) [EOL] html_text = ext . md_inline2html ( md_text ) [EOL] assert html_text . startswith ( [string] ) [EOL] assert html_text . endswith ( [string] ) [EOL] [EOL] [EOL] def test_basic_block ( ) : [EOL] html_data = markdown_katex . tex2html ( BASIC_TEX_TXT ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert [string] in html_data [EOL] [EOL] no_inline_svg = ext . md_block2html ( BASIC_BLOCK_TXT , default_options = { [string] : False } ) [EOL] default_output = ext . md_block2html ( BASIC_BLOCK_TXT ) [EOL] assert no_inline_svg == default_output [EOL] assert default_output [EOL] assert default_output . startswith ( [string] ) [EOL] expected = [string] . format ( default_output ) [EOL] [EOL] result = md . markdown ( BASIC_BLOCK_TXT , extensions = [ [string] ] ) [EOL] [EOL] assert default_output in result [EOL] [EOL] assert result . strip ( ) . startswith ( ext . KATEX_STYLES . strip ( ) ) [EOL] assert result . endswith ( expected ) [EOL] [EOL] [EOL] BASIC_TEX = [string] [EOL] [EOL] INLINE_MD_TMPL = [string] [EOL] [EOL] [EOL] def test_inline_basic ( ) : [EOL] inline_txt = [string] + BASIC_TEX + [string] [EOL] inline_output = ext . md_inline2html ( inline_txt ) [EOL] assert [string] in inline_output [EOL] [EOL] inline_md_txt = INLINE_MD_TMPL . format ( inline_txt , inline_txt ) [EOL] result = md . markdown ( inline_md_txt , extensions = [ [string] ] ) [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert result . count ( inline_output ) == [number] [EOL] [EOL] assert result . strip ( ) . startswith ( ext . KATEX_STYLES . strip ( ) ) [EOL] [EOL] [EOL] def test_trailing_whitespace ( ) : [EOL] default_output = ext . md_block2html ( BASIC_BLOCK_TXT ) [EOL] [EOL] trailing_space_result = md . markdown ( BASIC_BLOCK_TXT + [string] , extensions = [ [string] ] ) [EOL] assert default_output in trailing_space_result [EOL] assert [string] not in trailing_space_result [EOL] [EOL] [EOL] def test_inline_quoted ( ) : [EOL] inline_txt = [string] + BASIC_TEX + [string] [EOL] quoted_inline_txt = [string] + BASIC_TEX + [string] [EOL] inline_output = ext . md_inline2html ( inline_txt ) [EOL] [EOL] inline_md_txt = INLINE_MD_TMPL . format ( inline_txt , quoted_inline_txt ) [EOL] result = md . markdown ( inline_md_txt , extensions = [ [string] ] ) [EOL] assert result . count ( inline_output ) == [number] [EOL] assert [string] not in result [EOL] [EOL] inline_md_txt = INLINE_MD_TMPL . format ( quoted_inline_txt , inline_txt ) [EOL] result = md . markdown ( inline_md_txt , extensions = [ [string] ] ) [EOL] assert result . count ( inline_output ) == [number] [EOL] assert [string] not in result [EOL] [EOL] [EOL] def test_marker_uniqueness ( ) : [EOL] inline_md_txt = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] md_ctx = md . Markdown ( extensions = [ [string] ] ) [EOL] preproc = next ( iter ( ( pp for pp in md_ctx . preprocessors if isinstance ( pp , ext . KatexPreprocessor ) ) ) ) [EOL] out_lines = preproc . run ( inline_md_txt . splitlines ( ) ) [EOL] md_output = [string] . join ( out_lines ) [EOL] [EOL] assert md_output . count ( [string] ) == [number] [EOL] marker_ids = [ match . group ( [number] ) for match in re . finditer ( [string] , md_output ) ] [EOL] assert len ( set ( marker_ids ) ) == [number] [EOL] [EOL] [EOL] def test_svg_uniqueness ( ) : [EOL] md_text = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] html_output = md . markdown ( md_text , extensions = [ [string] ] ) [EOL] [EOL] [comment] [EOL] assert [string] in html_output [EOL] assert [string] in html_output [EOL] [EOL] fobj = io . StringIO ( html_output ) [EOL] soup = bs4 . BeautifulSoup ( fobj , [string] ) [EOL] [EOL] results = set ( ) [EOL] for tag in soup . find_all ( [string] , attrs = { [string] : [string] } ) : [EOL] results . add ( str ( tag ) ) [EOL] [EOL] assert len ( results ) == [number] [EOL] [EOL] [EOL] def test_no_inline_svg ( ) : [EOL] inline_md_txt = [string] + TEX_WITH_SVG_OUTPUT + [string] [EOL] inline_output = ext . md_inline2html ( inline_md_txt ) [EOL] assert [string] in inline_output [EOL] assert [string] in inline_output [EOL] assert [string] not in inline_output [EOL] [EOL] inline_output = ext . md_inline2html ( inline_md_txt , default_options = { [string] : True } ) [EOL] assert [string] in inline_output [EOL] assert [string] not in inline_output [EOL] assert [string] in inline_output [EOL] [EOL] result = md . markdown ( INLINE_MD_TMPL . format ( inline_md_txt , inline_md_txt ) , extensions = [ [string] ] , extension_configs = { [string] : { [string] : True } } , ) [EOL] assert [string] in result [EOL] assert [string] not in result [EOL] assert [string] in result [EOL] [EOL] [EOL] def test_insert_fonts_css ( ) : [EOL] result = md . markdown ( BASIC_BLOCK_TXT , extensions = [ [string] ] , extension_configs = { [string] : { [string] : True } } , ) [EOL] assert result . startswith ( ext . KATEX_STYLES . strip ( ) ) [EOL] result = md . markdown ( BASIC_BLOCK_TXT , extensions = [ [string] ] , extension_configs = { [string] : { [string] : False } } , ) [EOL] assert not result . startswith ( ext . KATEX_STYLES . strip ( ) ) [EOL] [EOL] [EOL] def test_err_msg ( ) : [EOL] invalid_md_txt = [string] [EOL] md_txt = INLINE_MD_TMPL . format ( invalid_md_txt , invalid_md_txt ) [EOL] try : [EOL] md . markdown ( md_txt , extensions = [ [string] ] ) [EOL] assert False , [string] [EOL] except wrp . KatexError as err : [EOL] err_msg = err . args [ [number] ] [EOL] assert [string] in err_msg [EOL] assert [string] in err_msg [EOL] [EOL] [EOL] def test_bin_paths ( ) : [EOL] assert wrp . _get_pkg_bin_path ( ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_html_output ( ) : [EOL] [comment] [EOL] [comment] [EOL] assert len ( markdown_katex . TEST_FORMULAS ) > [number] [EOL] md_parts = [ ] [EOL] for formula in markdown_katex . TEST_FORMULAS : [EOL] inline_formula = formula . replace ( [string] , [string] ) . strip ( ) [EOL] md_parts . append ( [string] + inline_formula + [string] ) [EOL] md_parts . append ( [string] + formula + [string] ) [EOL] [EOL] md_text = [string] + [string] . join ( md_parts ) [EOL] result = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] , extension_configs = { [string] : { [string] : True } } , ) [EOL] html = [string] [EOL] html = textwrap . dedent ( html . lstrip ( [string] ) ) [EOL] html = html . replace ( [string] , result ) [EOL] [EOL] tmp_file = TMP_DIR / [string] [EOL] with tmp_file . open ( mode = [string] , encoding = [string] ) as fobj : [EOL] fobj . write ( html ) [EOL] [EOL] [EOL] def test_valid_xml ( ) : [EOL] md_text = textwrap . dedent ( [string] ) [EOL] [EOL] extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] [EOL] result = md . markdown ( md_text , extensions = extensions , extension_configs = { [string] : { [string] : True } } , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] result = [string] + result + [string] [EOL] [EOL] [comment] [EOL] XML ( result ) [EOL] [EOL] [EOL] def test_ignore_in_non_math_block ( ) : [EOL] md_text = textwrap . dedent ( [string] ) [EOL] result_a = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] , extension_configs = { [string] : { [string] : True } } , ) [EOL] result_b = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS , ) [EOL] assert [string] not in result_a [EOL] assert [string] not in result_b [EOL] [EOL] assert result_a == result_b [EOL] assert [string] in result_a [EOL] assert [string] in result_a [EOL] assert [string] in result_a [EOL] [EOL] [EOL] def test_macro_file ( ) : [EOL] md_text = textwrap . dedent ( [string] ) [EOL] macro_text = textwrap . dedent ( [string] ) [EOL] [EOL] with tempfile . NamedTemporaryFile ( suffix = [string] ) as fobj : [EOL] fobj . write ( macro_text . encode ( [string] ) ) [EOL] fobj . flush ( ) [EOL] [EOL] macro_file = fobj . name [EOL] [EOL] result = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] , extension_configs = { [string] : { [string] : True , [string] : macro_file } } , ) [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert [string] in result [EOL] assert result . index ( [string] ) < result . index ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[typing.Any],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] import sys [EOL] [EOL] data = open ( sys . argv [ [number] ] ) . read ( [number] ) [EOL] has_data = len ( data ) > [number] [EOL] [EOL] sys . exit ( has_data ) [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0