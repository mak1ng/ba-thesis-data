from typing import Dict , List [EOL] import typing [EOL] import os [EOL] from setuptools import setup , find_packages [EOL] [EOL] name = [string] [EOL] description = [string] [EOL] version = [string] [EOL] depends = [ [string] , [string] , ] [EOL] entry_points = { [string] : [ [string] ] , } [EOL] [EOL] setup ( name = name , version = version , description = description , author = [string] , author_email = [string] , packages = find_packages ( [string] , exclude = [ [string] ] ) , package_dir = { [string] : [string] } , package_data = { [string] : [ [string] ] } , install_requires = depends , entry_points = entry_points , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0
from typing import Any , Coroutine , Callable , Set , Union , Awaitable , Optional , Type , TypeVar [EOL] import builtins [EOL] import typing [EOL] import webswitch [EOL] import threading [EOL] import queue [EOL] import asyncio [EOL] import multiprocessing [EOL] import concurrent [EOL] import asyncio [EOL] import logging [EOL] import threading [EOL] import traceback [EOL] from typing import Any , Optional , Coroutine , Union , Type , Callable , TypeVar , Awaitable , cast [EOL] from queue import Queue as thread_Queue [EOL] from multiprocessing import Queue as mp_Queue [EOL] import concurrent . futures as futures [EOL] [EOL] from . logger import g_logger [EOL] [EOL] [EOL] InitReturn = TypeVar ( [string] ) [EOL] ShutdownReturn = TypeVar ( [string] ) [EOL] [EOL] [EOL] class EventLoopManager ( threading . Thread ) : [EOL] [docstring] [EOL] event_loop_manager_latest_id = [number] [EOL] [EOL] def __init__ ( self , init_async_func = None , shutdown_async_func = None , loop = None , executor = None , * , daemon = False ) : [EOL] [docstring] [EOL] EventLoopManager . event_loop_manager_latest_id += [number] [EOL] self . id = EventLoopManager . event_loop_manager_latest_id [EOL] [EOL] self . logger = g_logger . getChild ( f' [string] { self . id }' ) [EOL] self . logger . debug ( [string] ) [EOL] [EOL] super ( EventLoopManager , self ) . __init__ ( args = ( ) , kwargs = { } , daemon = daemon ) [EOL] [EOL] self . _queue_factory = ... [EOL] [EOL] if isinstance ( executor , futures . ProcessPoolExecutor ) : [EOL] self . _queue_factory = mp_Queue [EOL] else : [EOL] self . _queue_factory = thread_Queue [EOL] [EOL] self . event_loop = loop or asyncio . new_event_loop ( ) [EOL] [EOL] if executor : [EOL] self . event_loop . set_default_executor ( executor ) [EOL] [EOL] self . _init_event = threading . Event ( ) [EOL] [EOL] self . exception_traceback = None [EOL] self . exception = None [EOL] self . _result = None [EOL] [EOL] async def _noop_init ( ) : [EOL] return cast ( InitReturn , True ) [EOL] [EOL] async def _noop_shutdown ( ) : [EOL] return cast ( ShutdownReturn , True ) [EOL] [EOL] self . _init_async_func = init_async_func or _noop_init [EOL] self . _shutdown_async_func = shutdown_async_func or _noop_shutdown [EOL] [EOL] async def _run_init_async ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] return await asyncio . ensure_future ( self . _init_async_func ( ) , loop = self . event_loop ) [EOL] [EOL] async def _run_shutdown_async ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] return await asyncio . ensure_future ( cast ( Awaitable [ ShutdownReturn ] , self . _shutdown_async_func ( ) ) , loop = self . event_loop ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] self . logger . debug ( [string] ) [EOL] self . exception = None [EOL] self . _result = None [EOL] self . _init_event . clear ( ) [EOL] [EOL] try : [EOL] self . _result = self . event_loop . run_until_complete ( self . _run_init_async ( ) ) [EOL] except Exception as e : [EOL] self . logger . debug ( [string] ) [EOL] self . exception_traceback = traceback . format_exc ( ) [EOL] self . exception = e [EOL] [EOL] self . logger . debug ( [string] ) [EOL] self . _init_event . set ( ) [EOL] [EOL] self . logger . debug ( [string] ) [EOL] self . event_loop . run_forever ( ) [EOL] [EOL] self . logger . debug ( [string] ) [EOL] [EOL] self . event_loop . run_until_complete ( self . event_loop . shutdown_asyncgens ( ) ) [EOL] [EOL] if self . exception is None : [EOL] self . event_loop . run_until_complete ( self . _run_shutdown_async ( ) ) [EOL] self . event_loop . close ( ) [EOL] self . logger . debug ( [string] ) [EOL] [EOL] def join ( self , timeout = None ) : [EOL] [docstring] [EOL] self . logger . debug ( [string] ) [EOL] super ( EventLoopManager , self ) . join ( timeout = timeout ) [EOL] [EOL] def wait_result ( self ) : [EOL] [docstring] [EOL] self . logger . debug ( [string] ) [EOL] [EOL] self . _init_event . wait ( ) [EOL] [EOL] if self . exception : [EOL] self . logger . debug ( [string] ) [EOL] raise self . exception [EOL] [EOL] self . logger . debug ( f' [string] { self . _result !r}' ) [EOL] [EOL] assert self . _result is not None [EOL] [EOL] return self . _result [EOL] [EOL] def shutdown_loop ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pending = asyncio . all_tasks ( loop = self . event_loop ) [EOL] [EOL] self . logger . debug ( f' [string] { len ( pending ) } [string] ' ) [EOL] [EOL] async def wait_pending_callback ( ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] await asyncio . gather ( * pending , return_exceptions = True ) [EOL] [EOL] self . logger . info ( [string] ) [EOL] [EOL] asyncio . run_coroutine_threadsafe ( wait_pending_callback ( ) , loop = self . event_loop ) . result ( ) [EOL] [EOL] self . logger . info ( [string] ) [EOL] self . event_loop . call_soon_threadsafe ( self . event_loop . stop ) [EOL] [EOL] def run_coroutine_threadsafe ( self , coro ) : [EOL] return asyncio . run_coroutine_threadsafe ( coro , loop = self . event_loop ) [EOL] [EOL] def call_soon_threadsafe ( self , callback , * args ) : [EOL] return self . event_loop . call_soon_threadsafe ( callback , * args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 $InitReturn$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[asyncio.tasks.Task[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[asyncio.tasks.Task[typing.Any]]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.Future$ 0 0 0 $typing.Coroutine$ 0 0 0 0 0 0 0 0 $typing.Coroutine$ 0 0 0 0 0 0 0 0 0 0 $asyncio.Handle$ 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable$ 0 0 $typing.Any$ 0 0
from typing import Any , Generator , List , Match , Set , Union , Dict , Optional , Type , Tuple [EOL] import builtins [EOL] import dispatch [EOL] import message [EOL] import typing [EOL] import webswitch [EOL] import router [EOL] import argparse [EOL] import uuid [EOL] import logging [EOL] import re [EOL] from typing import Any , Optional , Union , Tuple , Dict , Type , Set , List [EOL] import traceback [EOL] import uuid [EOL] import argparse [EOL] import asyncio [EOL] [EOL] [EOL] from . logger import g_logger [EOL] from . dispatch import ResponseDispatcher , AwaitDispatch , AbstractAwaitDispatch , add_action , Action , ParameterSet [EOL] from . router . errors import RouterError , RouterResponseError , RouterConnectionError [EOL] from . router . connection import Connection [EOL] from . router . router import Router [EOL] from . message import Message [EOL] [EOL] import logging [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ChannelServerError ( RouterError ) : [EOL] def __init__ ( self , message , ** data ) : [EOL] super ( ChannelServerError , self ) . __init__ ( [string] , message = message , ** data ) [EOL] [EOL] [EOL] class ChannelServerActionError ( ChannelServerError ) : [EOL] def __init__ ( self , message , ** data ) : [EOL] super ( ChannelServerActionError , self ) . __init__ ( message , ** data ) [EOL] self . error_types . append ( [string] ) [EOL] [EOL] [EOL] RoomChannelKey = Tuple [ str , str ] [EOL] [EOL] [EOL] class ChannelServerResponseError ( RouterResponseError ) : [EOL] def __init__ ( self , message , response , orig_exc = None , ** data ) : [EOL] new_data = dict ( data ) [EOL] [EOL] if orig_exc : [EOL] new_data [ [string] ] = orig_exc . __class__ . __name__ [EOL] [EOL] super ( ChannelServerResponseError , self ) . __init__ ( message = message , ** new_data ) [EOL] self . error_types . append ( [string] ) [EOL] [EOL] if response : [EOL] self . set_guid ( self , response ) [EOL] [EOL] @ staticmethod def set_guid ( exception , response ) : [EOL] exception . error_data [ [string] ] = response [EOL] [EOL] [EOL] [comment] [EOL] class ChannelClient ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , channel_server , conn ) : [EOL] self . channel_server = channel_server [EOL] self . connections = [ conn ] [EOL] self . name = None [EOL] self . _room_key = None [EOL] [EOL] self . id = channel_server . get_next_client_id ( ) [EOL] [EOL] self . logger = channel_server . get_logger ( ) . getChild ( f' [string] { self . id }' ) [EOL] self . logger . debug ( f' [string] { self !r}' ) [EOL] [EOL] def get_room_key ( self ) : [EOL] if not self . _room_key : [EOL] raise ChannelServerError ( [string] ) [EOL] [EOL] return self . _room_key [EOL] [EOL] def set_room_key ( self , key ) : [EOL] self . _room_key = key [EOL] [EOL] async def send ( self , message , response_id ) : [EOL] [docstring] [EOL] if isinstance ( message , dict ) : [EOL] message = Message ( data = message ) [EOL] [EOL] if response_id is not None : [EOL] message = message . clone ( ) [EOL] message . data . update ( response_id = str ( response_id ) ) [EOL] [EOL] await self . channel_server . send_messages ( self . connections , message ) [EOL] [EOL] def try_send ( self , message , response_id ) : [EOL] [docstring] [EOL] if response_id is not None : [EOL] message = message . clone ( ) [EOL] message . data . update ( response_id = str ( response_id ) ) [EOL] [EOL] self . channel_server . try_send_messages ( self . connections , message ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return f' [string] { self . id } [string] { len ( self . connections ) } [string] ' [EOL] [EOL] def __str__ ( self ) : [EOL] return repr ( self ) [EOL] [EOL] [EOL] class Conversation ( AbstractAwaitDispatch ) : [EOL] [docstring] [EOL] def __init__ ( self , client , original ) : [EOL] self . await_dispatch = original [EOL] self . client = client [EOL] [EOL] def get_await_dispatch ( self ) : [EOL] return self . await_dispatch [EOL] [EOL] async def send ( self , data ) : [EOL] await self . client . send ( data , self . await_dispatch . guid ) [EOL] [EOL] async def send_and_recv ( self , data , expect_params = None , timeout = None ) : [EOL] await self . send ( data ) [EOL] return await self ( params = expect_params , timeout = timeout ) [EOL] [EOL] [EOL] class ChannelServer ( Router ) : [EOL] [docstring] [EOL] _common_intrinsic_params = { [string] : ChannelClient } [EOL] _common_exposed_params = { } [EOL] [EOL] non_async_params = ParameterSet ( exposed = _common_exposed_params , intrinsic = _common_intrinsic_params ) [EOL] async_params = ParameterSet ( exposed = _common_exposed_params , intrinsic = { ** _common_intrinsic_params , [string] : Conversation , } ) [EOL] [EOL] def __init__ ( self , host , port , max_queue_size = [number] ) : [EOL] super ( ChannelServer , self ) . __init__ ( host , port , max_queue_size ) [EOL] self . rooms = { } [EOL] self . conn_to_client = { } [EOL] [comment] [EOL] self . id_to_client = { } [EOL] [EOL] self . host , self . port = host , port [EOL] [EOL] self . dispatcher = ResponseDispatcher ( common_params = self . non_async_params , common_async_params = self . async_params , instance = self , exception_handler = self . action_exception_handler , complete_handler = self . action_complete_handler , argument_hook = self . argument_hook , ) [EOL] [EOL] self . stop_timeout = None [EOL] [EOL] self . logger = super ( ChannelServer , self ) . get_logger ( ) . getChild ( f' [string] { self . id }' ) [EOL] self . logger . info ( [string] ) [EOL] [EOL] self . last_client_id = [number] [EOL] [EOL] def get_logger ( self ) : [EOL] return self . logger [EOL] [EOL] def get_next_client_id ( self ) : [EOL] self . last_client_id += [number] [EOL] return self . last_client_id [EOL] [EOL] def _add_connection ( self , key , connection , room , other_data , ) : [EOL] [docstring] [EOL] if other_data : [EOL] client_id = int ( other_data ) [EOL] client = self . id_to_client [ client_id ] [EOL] client . connections . append ( connection ) [EOL] else : [EOL] client = ChannelClient ( self , connection ) [EOL] self . id_to_client [ client . id ] = client [EOL] room . add ( client ) [EOL] client . set_room_key ( key ) [EOL] [EOL] self . conn_to_client [ connection ] = client [EOL] [EOL] self . logger . info ( f' [string] { connection !r} [string] { client !r} [string] { key !r}' ) [EOL] [EOL] def _remove_connection ( self , connection ) : [EOL] [docstring] [EOL] client = self . conn_to_client [ connection ] [EOL] [EOL] del self . conn_to_client [ connection ] [EOL] [EOL] client . connections . remove ( connection ) [EOL] [EOL] self . logger . info ( f' [string] { connection !r} [string] { client !r}' ) [EOL] [EOL] if not client . connections : [EOL] room = self . rooms [ client . get_room_key ( ) ] [EOL] room . remove ( client ) [EOL] del self . id_to_client [ client . id ] [EOL] [EOL] self . logger . info ( f' [string] { client !r} [string] ' ) [EOL] self . dispatcher . cancel_action_by_source ( client ) [EOL] [EOL] def _get_client ( self , connection ) : [EOL] [docstring] [EOL] client = self . conn_to_client . get ( connection ) [EOL] [EOL] if not client : [EOL] self . logger . error ( f' [string] { connection !r}' ) [EOL] raise ChannelServerError ( f' [string] ' ) [EOL] [EOL] return client [EOL] [EOL] async def send_to ( self , data , targets , key , sender_id , ) : [EOL] [comment] [EOL] target_clients = [ ] [EOL] [EOL] if key not in self . rooms : [EOL] self . logger . warning ( f' [string] { key !r} [string] ' ) [EOL] return [EOL] [EOL] _targets = targets if targets is not None else ( c . id for c in self . rooms [ key ] ) [EOL] [EOL] [comment] [EOL] for target_id in _targets : [EOL] client_ = self . id_to_client . get ( target_id ) [EOL] [EOL] if not client_ : [EOL] raise ChannelServerActionError ( f' [string] { target_id } [string] ' ) [EOL] [EOL] if key and key != client_ . get_room_key ( ) : [EOL] raise ChannelServerActionError ( f' [string] { client_ !r} [string] { key !r}' ) [EOL] [EOL] target_clients . append ( client_ ) [EOL] [EOL] data_to_send = dict ( data ) [EOL] [EOL] if sender_id is not None : [EOL] data_to_send [ [string] ] = sender_id [EOL] [EOL] message = Message ( data_to_send ) [EOL] [EOL] for client_ in target_clients : [EOL] client_ . try_send ( message , response_id = None ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def argument_hook ( self , args , source , action ) : [EOL] [docstring] [EOL] assert isinstance ( source , ChannelClient ) [EOL] [EOL] await_dispatch = args . get ( [string] ) [EOL] [EOL] new_args = args . copy ( ) [EOL] [EOL] self . logger . debug ( f' [string] { action !r}' ) [EOL] [EOL] if await_dispatch : [EOL] assert isinstance ( await_dispatch , AwaitDispatch ) [EOL] new_conversation = Conversation ( client = source , original = await_dispatch ) [EOL] new_args . update ( convo = new_conversation ) [EOL] [EOL] new_args [ [string] ] = source [EOL] [EOL] return new_args [EOL] [EOL] [comment] [EOL] async def action_exception_handler ( self , source , action_name , e , response_id ) : [EOL] [docstring] [EOL] self . logger . warning ( f' [string] { action_name } [string] { source } [string] { e !r}' ) [EOL] [EOL] assert isinstance ( source , ChannelClient ) [EOL] [EOL] if not isinstance ( e , RouterError ) : [EOL] e = ChannelServerResponseError ( f' [string] { str ( e ) or repr ( e ) }' , orig_exc = e , response = response_id ) [EOL] [EOL] [comment] [EOL] if response_id : [EOL] ChannelServerResponseError . set_guid ( e , response_id ) [EOL] [EOL] source . try_send ( Message . error_from_exc ( e ) , response_id ) [EOL] [EOL] [comment] [EOL] def action_complete_handler ( self , source , action_name , result , response_id ) : [EOL] assert isinstance ( source , ChannelClient ) [EOL] [EOL] if isinstance ( result , Dict ) : [EOL] source . try_send ( Message ( data = result , is_final = True ) , response_id ) [EOL] else : [EOL] self . logger . warning ( f' [string] { action_name } [string] { result !r}' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def on_start ( self ) : [EOL] self . dispatcher . start ( ) [EOL] [EOL] def on_stop ( self ) : [EOL] self . dispatcher . stop ( self . stop_timeout ) [EOL] [EOL] def stop_serve ( self , timeout = None ) : [EOL] self . stop_timeout = timeout [EOL] super ( ChannelServer , self ) . stop_serve ( ) [EOL] [EOL] def on_new ( self , connection , path ) : [EOL] groups = { } [EOL] [EOL] try : [EOL] [comment] [EOL] matches = re . match ( [string] , path ) [EOL] [EOL] if matches : [EOL] groups . update ( matches . groupdict ( ) ) [EOL] [EOL] [comment] [EOL] if not groups . get ( [string] ) or not groups . get ( [string] ) : [EOL] raise RouterConnectionError ( [string] ) [EOL] [EOL] self . logger . debug ( f' [string] { connection } [string] { path !r}' ) [EOL] [EOL] key = ( groups [ [string] ] , groups [ [string] ] ) [EOL] [EOL] room = self . rooms . get ( key ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if room is None : [EOL] self . logger . info ( f' [string] { key !r} [string] ' ) [EOL] [EOL] self . rooms [ key ] = room = set ( ) [EOL] [EOL] self . _add_connection ( key , connection , room , groups . get ( [string] ) ) [EOL] [EOL] [comment] [EOL] except RouterConnectionError as e : [EOL] raise [EOL] [EOL] except Exception as e : [EOL] connection . close ( reason = str ( e ) ) [EOL] [EOL] def on_remove ( self , connection ) : [EOL] self . _remove_connection ( connection ) [EOL] [EOL] def on_message ( self , connection , message ) : [EOL] action_name = message . data . get ( [string] ) [EOL] client = self . _get_client ( connection ) [EOL] [EOL] response_id = message . data . get ( [string] ) [EOL] [EOL] try : [EOL] if action_name is None : [EOL] raise ChannelServerActionError ( [string] ) [EOL] [EOL] action = self . dispatcher . actions . get ( action_name ) [EOL] [EOL] if not action : [EOL] raise ChannelServerError ( f' [string] { action_name !r}' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . dispatcher . dispatch ( source = client , action_name = action_name , args = message . data , response_id = response_id ) [EOL] [EOL] except RouterError as e : [EOL] self . logger . warning ( f' [string] { e !r}' ) [EOL] if response_id : [EOL] ChannelServerResponseError . set_guid ( e , response_id ) [EOL] raise [EOL] [EOL] except Exception as e : [EOL] self . logger . error ( f' [string] { e !r} [string] { traceback . format_exc ( ) }' ) [EOL] raise ChannelServerError ( f' [string] { e !r}' ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ add_action ( ) def action_whoami ( self , client ) : [EOL] return { [string] : client . id } [EOL] [EOL] @ add_action ( params = { [string] : list , [string] : dict } ) async def action_send ( self , convo , targets , data , client ) : [EOL] key = client . get_room_key ( ) [EOL] [EOL] await self . send_to ( data , targets , key , client . id , ) [EOL] [EOL] @ add_action ( ) def action_enum_clients ( self , client ) : [EOL] clients = self . rooms [ client . get_room_key ( ) ] [EOL] return { [string] : list ( map ( lambda c : c . id , clients ) ) } [EOL] [EOL] [EOL] def cli_main ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] , formatter_class = argparse . ArgumentDefaultsHelpFormatter , ) [EOL] [EOL] parser . add_argument ( [string] , type = str , metavar = [string] , default = [string] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , type = int , metavar = [string] , default = [number] , help = [string] , ) [EOL] [EOL] parser . add_argument ( [string] , [string] , type = str , choices = ( [string] , [string] , [string] , [string] , [string] ) , default = [string] , ) [EOL] [EOL] args = parser . parse_args ( ) [EOL] [EOL] logging . basicConfig ( format = [string] ) [EOL] g_logger . setLevel ( args . log_level . upper ( ) ) [EOL] [EOL] router = ChannelServer ( args . host , args . port ) [EOL] router . serve ( daemon = False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] cli_main ( ) [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[typing.Union[uuid.UUID,'AwaitDispatch']]$ 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Optional[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[uuid.UUID,'AwaitDispatch']]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Union[uuid.UUID,'AwaitDispatch']]$ 0 0 0 0 0 0 $None$ 0 $router.errors.RouterError$ 0 $typing.Union[uuid.UUID,'AwaitDispatch']$ 0 0 0 $router.errors.RouterError$ 0 0 0 0 0 0 $typing.Union[uuid.UUID,'AwaitDispatch']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $webswitch.channel_server.ChannelServer$ 0 $router.connection.Connection$ 0 0 0 0 0 $webswitch.channel_server.ChannelServer$ 0 $webswitch.channel_server.ChannelServer$ 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[RoomChannelKey]$ 0 0 0 0 0 0 $builtins.int$ 0 $webswitch.channel_server.ChannelServer$ 0 0 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelServer$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RoomChannelKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $RoomChannelKey$ 0 0 0 0 0 $typing.Optional[typing.Tuple[builtins.str,builtins.str]]$ 0 $RoomChannelKey$ 0 0 0 0 $None$ 0 0 0 $webswitch.message.Message$ 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 $webswitch.message.Message$ 0 $webswitch.message.Message$ 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 $None$ 0 0 0 $webswitch.message.Message$ 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 $webswitch.message.Message$ 0 $webswitch.message.Message$ 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 $typing.Optional[uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 $dispatch.AwaitDispatch$ 0 0 0 0 0 $webswitch.dispatch.AwaitDispatch$ 0 $dispatch.AwaitDispatch$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 $webswitch.channel_server.ChannelClient$ 0 0 0 $dispatch.AwaitDispatch$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[message.Message,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[message.Message,typing.Dict]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Union[message.Message,typing.Dict]$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Type]]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[message.Message,typing.Dict]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Type]]$ 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 0 0 $webswitch.dispatch.ParameterSet$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 $webswitch.dispatch.ParameterSet$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[RoomChannelKey,typing.Set[ChannelClient]]$ 0 0 0 0 0 0 $typing.Dict[router.connection.Connection,ChannelClient]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,ChannelClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.dispatch.ResponseDispatcher$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $RoomChannelKey$ 0 $router.connection.Connection$ 0 $typing.Set[ChannelClient]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $builtins.int$ 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 $typing.Set[ChannelClient]$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 $RoomChannelKey$ 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 $RoomChannelKey$ 0 0 0 0 0 $None$ 0 0 0 $router.connection.Connection$ 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 $typing.Set[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 $typing.Set[webswitch.channel_server.ChannelClient]$ 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 $ChannelClient$ 0 0 0 $router.connection.Connection$ 0 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 $None$ 0 0 0 $builtins.dict$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 $RoomChannelKey$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 $typing.List[ChannelClient]$ 0 0 0 0 0 0 $RoomChannelKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RoomChannelKey$ 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.int],typing.Generator[builtins.int,None,None]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 $typing.Optional[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RoomChannelKey$ 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[builtins.int],typing.Generator[builtins.int,None,None]]$ 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RoomChannelKey$ 0 $RoomChannelKey$ 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 $RoomChannelKey$ 0 0 0 0 $typing.List[ChannelClient]$ 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.dict$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 $webswitch.message.Message$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 $typing.List[ChannelClient]$ 0 0 $typing.Optional[webswitch.channel_server.ChannelClient]$ 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $builtins.object$ 0 $dispatch.Action$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $typing.Optional[dispatch.AwaitDispatch]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dispatch.Action$ 0 0 0 0 0 $typing.Optional[dispatch.AwaitDispatch]$ 0 0 0 0 0 $typing.Optional[dispatch.AwaitDispatch]$ 0 0 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 $builtins.object$ 0 0 0 $typing.Optional[dispatch.AwaitDispatch]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $webswitch.channel_server.Conversation$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.object$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.object$ 0 $builtins.str$ 0 $webswitch.channel_server.ChannelServerResponseError$ 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.object$ 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 $uuid.UUID$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelServerResponseError$ 0 0 $uuid.UUID$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.object$ 0 $builtins.str$ 0 $typing.Any$ 0 $uuid.UUID$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $uuid.UUID$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $router.connection.Connection$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $router.connection.Connection$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $router.connection.Connection$ 0 0 0 0 0 0 0 $router.connection.Connection$ 0 0 0 0 $None$ 0 0 0 $router.connection.Connection$ 0 $message.Message$ 0 0 0 $typing.Any$ 0 $message.Message$ 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 0 0 0 0 $router.connection.Connection$ 0 0 0 $typing.Any$ 0 $message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[webswitch.dispatch.Action]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[webswitch.dispatch.Action]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.channel_server.ChannelClient$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $message.Message$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $ChannelClient$ 0 0 0 0 0 0 0 $ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Conversation$ 0 $typing.List[builtins.int]$ 0 $builtins.dict$ 0 $ChannelClient$ 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $typing.List[builtins.int]$ 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $ChannelClient$ 0 0 0 $typing.Set[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 $ChannelClient$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[webswitch.channel_server.ChannelClient]$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import logging [EOL] import logging [EOL] [EOL] g_logger = logging . getLogger ( [string] )	0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0
from typing import Union , Any , List [EOL] import builtins [EOL] import typing [EOL] from typing import List , Union , Any [EOL] [EOL] [EOL] class RouterError ( Exception ) : [EOL] def __init__ ( self , error_types , message , ** data ) : [EOL] super ( RouterError , self ) . __init__ ( ) [EOL] self . message = message [EOL] self . error_types = [ error_types ] if isinstance ( error_types , str ) else error_types [EOL] self . error_data = data [EOL] [EOL] def __repr__ ( self ) : [EOL] errors = [string] . join ( self . error_types ) [EOL] return ( f' [string] ' f' [string] { self . message !r} [string] ' f' [string] { errors } [string] ' f' [string] { self . error_data !r} [string] ' ) [EOL] [EOL] def __str__ ( self ) : [EOL] errors = [string] . join ( self . error_types ) [EOL] return f" [string] { errors } [string] { self . message }" [EOL] [EOL] [EOL] class RouterResponseError ( RouterError ) : [EOL] def __init__ ( self , message , ** data ) : [EOL] super ( RouterResponseError , self ) . __init__ ( message = message , ** { [string] : [string] , ** data } ) [EOL] [EOL] [EOL] class RouterConnectionError ( RouterError ) : [EOL] def __init__ ( self , message , ** data ) : [EOL] super ( RouterConnectionError , self ) . __init__ ( message = message , ** { [string] : [string] , ** data } ) [EOL] [EOL] [EOL] class RouterServerError ( RouterError ) : [EOL] def __init__ ( self , message , ** data ) : [EOL] super ( RouterServerError , self ) . __init__ ( message = message , ** { [string] : [string] , ** data } ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional [EOL] import websockets [EOL] import builtins [EOL] import typing [EOL] import threading [EOL] import webswitch [EOL] import asyncio [EOL] import asyncio [EOL] import logging [EOL] import threading [EOL] from typing import Optional , List , Any [EOL] [EOL] import websockets [EOL] from websockets import WebSocketServerProtocol [EOL] [EOL] from . . logger import g_logger [EOL] [EOL] [EOL] class ConnectionList : [EOL] def __init__ ( self ) : [EOL] self . connections = [ ] [EOL] self . _lock = threading . Lock ( ) [EOL] self . last_connection_id = [number] [EOL] [EOL] def generate_id ( self ) : [EOL] with self . _lock : [EOL] self . last_connection_id += [number] [EOL] return self . last_connection_id [EOL] [EOL] def add ( self , connection ) : [EOL] with self . _lock : [EOL] self . connections . append ( connection ) [EOL] connection . in_pool = True [EOL] [EOL] def remove ( self , connection ) : [EOL] with self . _lock : [EOL] self . connections . remove ( connection ) [EOL] [EOL] def __bool__ ( self ) : [EOL] with self . _lock : [EOL] return bool ( self . connections ) [EOL] [EOL] def __len__ ( self ) : [EOL] with self . _lock : [EOL] return len ( self . connections ) [EOL] [EOL] def copy ( self ) : [EOL] with self . _lock : [EOL] return self . connections [ : ] [EOL] [EOL] def close ( self , reason ) : [EOL] with self . _lock : [EOL] for conn in self . connections : [EOL] conn . close ( reason = reason ) [EOL] [EOL] [EOL] class Connection ( object ) : [EOL] def __init__ ( self , conn_list , event_loop , ws = None , ** extra_kwargs ) : [EOL] self . extra = extra_kwargs [EOL] self . ws = ws [EOL] self . event_loop = event_loop [EOL] self . conn_list = conn_list [EOL] [EOL] self . closed = False [EOL] self . _close_issued = False [EOL] self . _close_event = asyncio . Event ( loop = self . event_loop ) [EOL] [EOL] self . close_reason = None [EOL] self . close_code = None [EOL] self . in_pool = False [EOL] [EOL] self . conn_id = conn_list . generate_id ( ) [EOL] [EOL] self . _close_lock = threading . Lock ( ) [EOL] [EOL] self . logger = g_logger . getChild ( f' [string] { self . conn_id }' ) [EOL] self . logger . debug ( f' [string] { self !r}' ) [EOL] [EOL] @ property def close_issued ( self ) : [EOL] return self . _close_issued [EOL] [EOL] def copy_to_subclass ( self , subclassed_object ) : [EOL] [docstring] [EOL] if self . conn_list is not subclassed_object . conn_list : [EOL] raise Exception ( [string] ) [EOL] [EOL] for v in ( [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ) : [EOL] my_value = getattr ( self , v ) [EOL] setattr ( subclassed_object , v , my_value ) [EOL] [EOL] def __repr__ ( self ) : [EOL] if self . ws : [EOL] addr , port , * _ = self . ws . remote_address [EOL] [EOL] tags = [ f' [string] { self . conn_id }' , f' [string] { addr } [string] { port }' , ] [EOL] else : [EOL] tags = [ f' [string] { self . conn_id }' , [string] ] [EOL] [EOL] if self . _close_issued : [EOL] tags . append ( [string] ) [EOL] [EOL] return [string] . format ( [string] . join ( tags ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] if self . ws : [EOL] tags = [ f' [string] { self . conn_id }' , ] [EOL] else : [EOL] tags = [ f' [string] { self . conn_id }' , [string] ] [EOL] [EOL] if self . _close_issued : [EOL] tags . append ( [string] ) [EOL] [EOL] return [string] . format ( [string] . join ( tags ) ) [EOL] [EOL] def close ( self , code = [number] , reason = [string] ) : [EOL] with self . _close_lock : [EOL] if self . _close_issued : [EOL] self . logger . warning ( [string] ) [EOL] return [EOL] [EOL] self . _close_issued = True [EOL] self . logger . debug ( [string] ) [EOL] [EOL] self . close_code = code or [number] [EOL] self . close_reason = reason or [string] [EOL] [EOL] async def async_callback ( ) : [EOL] with self . _close_lock : [EOL] self . _close_issued = True [EOL] [EOL] if self . closed : [EOL] self . logger . warning ( [string] ) [EOL] return True [EOL] [EOL] if self . in_pool : [EOL] self . conn_list . remove ( self ) [EOL] [EOL] try : [EOL] await self . ws . close ( code = self . close_code , reason = self . close_reason ) [EOL] except websockets . InvalidState : [comment] [EOL] pass [EOL] except Exception as e : [EOL] self . logger . error ( f' [string] { e !r}' ) [EOL] [EOL] self . _close_event . set ( ) [EOL] [EOL] self . logger . debug ( f' [string] { self . close_code } [string] { self . close_reason }' ) [EOL] [EOL] self . closed = True [EOL] [EOL] return True [EOL] [EOL] def callback ( ) : [EOL] self . logger . debug ( [string] ) [EOL] self . close_future = asyncio . ensure_future ( async_callback ( ) , loop = self . event_loop ) [EOL] [EOL] self . event_loop . call_soon_threadsafe ( callback ) [EOL] [EOL] async def wait_closed ( self ) : [EOL] self . logger . debug ( [string] ) [EOL] await self . _close_event . wait ( ) [EOL] self . logger . debug ( [string] ) [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'Connection'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Connection'$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List['Connection']$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $webswitch.router.connection.ConnectionList$ 0 $asyncio.events.AbstractEventLoop$ 0 $websockets.WebSocketServerProtocol$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $websockets.WebSocketServerProtocol$ 0 $websockets.WebSocketServerProtocol$ 0 0 0 $asyncio.events.AbstractEventLoop$ 0 $asyncio.events.AbstractEventLoop$ 0 0 0 $webswitch.router.connection.ConnectionList$ 0 $webswitch.router.connection.ConnectionList$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $asyncio.locks.Event$ 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $webswitch.router.connection.ConnectionList$ 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'Connection'$ 0 0 0 0 0 0 0 0 0 0 0 $'Connection'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $'Connection'$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , Iterable , List , Callable [EOL] import websockets [EOL] import builtins [EOL] import connection [EOL] import message [EOL] import webswitch [EOL] import typing [EOL] import threading [EOL] import event_loop [EOL] import queue [EOL] import asyncio [EOL] import logging [EOL] import asyncio [EOL] import websockets [EOL] import json [EOL] from queue import Queue [EOL] import time [EOL] import logging [EOL] import threading [EOL] import traceback [EOL] from typing import * [EOL] [EOL] from websockets . server import WebSocketServerProtocol [EOL] from websockets . exceptions import ConnectionClosed [EOL] [EOL] from . connection import Connection , ConnectionList [EOL] from . errors import RouterError , RouterConnectionError , RouterServerError [EOL] from . . event_loop import EventLoopManager [EOL] from . . message import Message [EOL] from . . logger import g_logger [EOL] [EOL] [EOL] def _route_thread ( message_callback , conn_list , receive_queue , logger ) : [EOL] logger . info ( [string] ) [EOL] [EOL] while True : [EOL] conn , data = receive_queue . get ( ) [EOL] [EOL] if conn is None : [EOL] if conn_list : [EOL] logger . error ( [string] ) [EOL] break [EOL] [EOL] assert isinstance ( conn , Connection ) [EOL] [EOL] if conn . closed : [EOL] logger . warning ( f' [string] { conn !r} [string] { data !r}' ) [EOL] continue [EOL] [EOL] logger . debug ( f' [string] { conn !r} [string] { data !r}' ) [EOL] [EOL] message_callback ( conn , data ) [EOL] [EOL] [EOL] class Router ( object ) : [EOL] [docstring] [EOL] router_last_id = [number] [EOL] [EOL] def __init__ ( self , host , port , max_queue_size = [number] ) : [EOL] self . host , self . port = host , port [EOL] [EOL] self . connection_list = ConnectionList ( ) [EOL] [EOL] self . receive_queue = Queue ( max_queue_size ) [EOL] [EOL] self . closed = False [EOL] [EOL] self . event_loop = asyncio . new_event_loop ( ) [EOL] self . event_loop . set_debug ( True ) [EOL] [EOL] self . connection_index = [number] [EOL] [EOL] Router . router_last_id += [number] [EOL] self . id = Router . router_last_id [EOL] [EOL] self . last_connection_id = [number] [EOL] [EOL] self . __logger = g_logger . getChild ( f' [string] { self . id }' ) [EOL] self . __logger . debug ( [string] ) [EOL] [EOL] self . _server_thread = threading . Thread ( target = self . _serve_forever ) [EOL] self . _interrupt_event = threading . Event ( ) [EOL] self . _ready_event = threading . Event ( ) [EOL] [EOL] self . _close_lock = threading . Lock ( ) [EOL] [EOL] def get_logger ( self ) : [EOL] [docstring] [EOL] return self . __logger [EOL] [EOL] def serve ( self , * , daemon = False , block_until_ready = True ) : [EOL] [docstring] [EOL] self . __logger . info ( [string] ) [EOL] self . _ready_event . clear ( ) [EOL] self . _server_thread . start ( ) [EOL] [EOL] if block_until_ready : [EOL] self . _ready_event . wait ( ) [EOL] [EOL] if not daemon : [EOL] try : [EOL] while True : [EOL] time . sleep ( [number] ) [EOL] except KeyboardInterrupt : [EOL] self . __logger . warning ( [string] ) [EOL] [EOL] self . stop_serve ( ) [EOL] [EOL] self . __logger . info ( [string] ) [EOL] [EOL] def stop_serve ( self ) : [EOL] [docstring] [EOL] self . __logger . info ( [string] ) [EOL] self . _interrupt_event . set ( ) [EOL] self . _server_thread . join ( ) [EOL] self . __logger . info ( [string] ) [EOL] [EOL] def _serve_forever ( self ) : [EOL] self . _interrupt_event . clear ( ) [EOL] [EOL] asyncio . set_event_loop ( self . event_loop ) [EOL] serve_task = websockets . serve ( self . handle_connect , self . host , self . port ) [EOL] server = serve_task . ws_server [EOL] [EOL] async def async_init_callback ( ) : [EOL] await serve_task [EOL] return True [EOL] [EOL] async def async_shutdown_callback ( ) : [EOL] self . __logger . info ( [string] ) [EOL] server . close ( ) [EOL] self . __logger . info ( [string] ) [EOL] await server . wait_closed ( ) [EOL] [EOL] event_manager = EventLoopManager ( loop = self . event_loop , init_async_func = async_init_callback , shutdown_async_func = async_shutdown_callback , ) [EOL] event_manager . start ( ) [EOL] [EOL] main_thread = threading . Thread ( target = _route_thread , args = ( self . _handle_message , self . connection_list , self . receive_queue , self . __logger , ) , ) [EOL] main_thread . start ( ) [EOL] [EOL] success = False [EOL] [EOL] try : [EOL] success = event_manager . wait_result ( ) [EOL] except Exception as e : [EOL] self . __logger . error ( f'{ event_manager . exception_traceback } [string] { e !r}' ) [EOL] [EOL] if success : [EOL] self . on_start ( ) [EOL] self . _ready_event . set ( ) [comment] [EOL] [EOL] self . __logger . info ( f' [string] { self . host } [string] { self . port }' ) [EOL] self . _interrupt_event . wait ( ) [EOL] [EOL] self . on_stop ( ) [EOL] else : [EOL] self . __logger . error ( f'{ event_manager . exception_traceback } [string] ' ) [EOL] self . _ready_event . set ( ) [comment] [EOL] [EOL] [comment] [EOL] self . _set_closed ( ) [EOL] [EOL] self . __logger . info ( f' [string] { len ( self . connection_list ) } [string] ' ) [EOL] [EOL] [comment] [EOL] self . connection_list . close ( reason = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] wait_time = [number] [EOL] sleep_time = [number] [EOL] sleep_count = int ( wait_time / sleep_time ) [EOL] [EOL] self . __logger . info ( f' [string] { wait_time } [string] ' ) [EOL] for i in range ( sleep_count ) : [EOL] if self . connection_list : [EOL] time . sleep ( sleep_time ) [EOL] else : [EOL] break [EOL] [EOL] if self . connection_list : [EOL] self . __logger . warning ( f' [string] { len ( self . connection_list ) } [string] ' ) [EOL] [EOL] self . __logger . info ( [string] ) [EOL] self . receive_queue . put ( ( None , None ) ) [EOL] [EOL] main_thread . join ( ) [EOL] [EOL] event_manager . shutdown_loop ( ) [EOL] event_manager . join ( ) [EOL] [EOL] self . __logger . info ( [string] ) [EOL] [EOL] def _is_closed ( self ) : [EOL] with self . _close_lock : [EOL] return self . closed [EOL] [EOL] def _set_closed ( self ) : [EOL] with self . _close_lock : [EOL] self . closed = True [EOL] [EOL] async def handle_connect ( self , websocket , path ) : [EOL] if self . _is_closed ( ) : [EOL] self . __logger . warning ( [string] , websocket ) [EOL] return [EOL] [EOL] connection = Connection ( conn_list = self . connection_list , event_loop = self . event_loop , router = self , ws = websocket , path = path , ) [EOL] [EOL] self . __logger . debug ( f' [string] { path !r} [string] { connection }' ) [EOL] [EOL] try : [EOL] [comment] [EOL] self . on_new ( connection , path ) [EOL] [EOL] [comment] [EOL] if connection . close_issued : [EOL] raise RouterConnectionError ( connection . close_reason or [string] ) [EOL] [EOL] [comment] [EOL] self . connection_list . add ( connection ) [EOL] [EOL] [comment] [EOL] except RouterError as e : [EOL] self . __logger . warning ( f' [string] { connection } [string] { e !r}' ) [EOL] [EOL] [comment] [EOL] if not connection . close_issued : [EOL] await self . send_messages ( [ connection ] , Message . error_from_exc ( e ) ) [EOL] connection . close ( reason = str ( e ) ) [EOL] [EOL] await connection . wait_closed ( ) [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] except Exception as e : [EOL] self . __logger . error ( f'{ traceback . format_exc ( ) } [string] { connection } [string] { e !r}' ) [EOL] [EOL] if not connection . close_issued : [EOL] reason = connection . close_reason or [string] [EOL] await self . send_messages ( [ connection ] , Message . error_from_exc ( e ) ) [EOL] connection . close ( reason = reason ) [EOL] [EOL] await connection . wait_closed ( ) [EOL] raise [EOL] [EOL] [comment] [EOL] try : [EOL] async for message in websocket : [EOL] self . receive_queue . put ( ( connection , message ) ) [EOL] [EOL] self . __logger . info ( f' [string] { connection !r} [string] ' ) [EOL] [EOL] except ConnectionClosed as e : [EOL] self . __logger . warning ( f' [string] { connection !r} [string] { e . code !r} [string] { e . reason !r} [string] ' ) [EOL] [EOL] connection . close ( ) [EOL] await connection . wait_closed ( ) [EOL] [EOL] self . on_remove ( connection ) [EOL] [EOL] self . __logger . debug ( f' [string] { connection }' ) [EOL] [EOL] def _handle_message ( self , connection , data ) : [EOL] try : [EOL] json_obj = json . loads ( data ) [EOL] [EOL] if not isinstance ( json_obj , dict ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] except json . JSONDecodeError as e : [EOL] self . __logger . error ( f' [string] { data !r} [string] { connection !r} [string] { e !r}' ) [EOL] [EOL] self . try_send_messages ( [ connection ] , Message . error_from_exc ( RouterError ( [string] , str ( e ) ) ) ) [EOL] raise [EOL] [EOL] message = Message ( ) . load ( json_obj ) [EOL] [EOL] try : [EOL] self . on_message ( connection , message ) [EOL] [EOL] except RouterError as e : [EOL] self . __logger . warning ( f' [string] { e !r}' ) [EOL] self . try_send_messages ( [ connection ] , Message . error_from_exc ( e ) ) [EOL] [EOL] except Exception as e : [EOL] self . __logger . error ( f'{ traceback . format_exc ( ) } [string] { e }' ) [EOL] self . try_send_messages ( [ connection ] , Message . error_from_exc ( e ) ) [EOL] raise [EOL] [EOL] async def send_messages ( self , recipients , message ) : [EOL] [docstring] [EOL] payload = message . json ( ) [EOL] [EOL] gens = [ ] [EOL] [EOL] for conn in recipients : [EOL] self . __logger . debug ( f' [string] { message !r} [string] { conn !r}' ) [EOL] gens . append ( conn . ws . send ( payload ) ) [EOL] [EOL] return cast ( Iterable , await asyncio . gather ( * gens , return_exceptions = True , ) ) [EOL] [EOL] def try_send_messages ( self , recipients , message ) : [EOL] [docstring] [EOL] async def _async_call ( ) : [EOL] try : [EOL] results = await self . send_messages ( recipients , message ) [EOL] except Exception as e : [EOL] self . __logger . error ( f' [string] { e !r}' ) [EOL] [EOL] errors = [ ] [EOL] passive = [ ] [EOL] [EOL] for i , r in enumerate ( results ) : [EOL] conn = recipients [ i ] [EOL] [EOL] if not isinstance ( r , Exception ) : [EOL] continue [EOL] [EOL] if isinstance ( r , websockets . ConnectionClosed ) : [EOL] passive . append ( ( conn , r ) ) [EOL] else : [EOL] errors . append ( ( conn , r ) ) [EOL] [EOL] if errors : [EOL] self . __logger . error ( f' [string] { errors !r}' ) [EOL] [EOL] if passive : [EOL] self . __logger . warning ( f' [string] { passive !r}' ) [EOL] [EOL] asyncio . run_coroutine_threadsafe ( _async_call ( ) , self . event_loop ) [EOL] [EOL] def on_stop ( self ) : [EOL] pass [EOL] [EOL] def on_start ( self ) : [EOL] pass [EOL] [EOL] def on_new ( self , connection , path ) : [EOL] pass [EOL] [EOL] def on_message ( self , connection , message ) : [EOL] pass [EOL] [EOL] def on_remove ( self , connection ) : [EOL] pass [EOL] [EOL] [EOL] __all__ = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.ConnectionList$ 0 0 0 0 0 0 0 0 $queue.Queue$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $asyncio.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $asyncio.AbstractEventLoop$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 $threading.Event$ 0 0 0 0 0 0 0 0 0 0 $threading.Lock$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 $event_loop.EventLoopManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 $websockets.server.WebSocketServerProtocol$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $websockets.server.WebSocketServerProtocol$ 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $websockets.server.WebSocketServerProtocol$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 $builtins.str$ 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 $builtins.str$ 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $websockets.server.WebSocketServerProtocol$ 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 $None$ 0 0 0 $connection.Connection$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $webswitch.message.Message$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 $connection.Connection$ 0 $webswitch.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable$ 0 0 0 $typing.List[connection.Connection]$ 0 $message.Message$ 0 0 0 0 0 $builtins.str$ 0 $message.Message$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[connection.Connection]$ 0 0 0 0 0 0 0 0 0 0 0 $message.Message$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[connection.Connection]$ 0 $message.Message$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Iterable[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Any]$ 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $webswitch.router.connection.Connection$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $connection.Connection$ 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $connection.Connection$ 0 $message.Message$ 0 0 0 0 0 0 0 $None$ 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import Any , List , Iterator , Optional [EOL] import uuid [EOL] import webswitch [EOL] import typing [EOL] import itertools [EOL] import time [EOL] import uuid [EOL] from typing import NamedTuple , List [EOL] [EOL] from webswitch . client import MessageQueues [EOL] from webswitch . index_map import IndexMap [EOL] from webswitch . message import Message [EOL] [EOL] [EOL] def test_message_queue ( ) : [EOL] mq = MessageQueues ( [number] ) [EOL] [EOL] uuids = [ uuid . UUID ( [string] ) , uuid . UUID ( [string] ) , uuid . UUID ( [string] ) , ] [EOL] [EOL] messages = [ Message ( data = { [string] : _ } ) for _ in range ( [number] ) ] [EOL] [EOL] msg_iter = iter ( messages ) [EOL] [EOL] mq . add ( uuids [ [number] ] , next ( msg_iter ) ) [EOL] time . sleep ( [number] ) [comment] [EOL] [EOL] old_msg = next ( msg_iter ) [EOL] mq . add ( uuids [ [number] ] , old_msg ) [EOL] time . sleep ( [number] ) [EOL] mq . add ( uuids [ [number] ] , next ( msg_iter ) ) [EOL] time . sleep ( [number] ) [EOL] [EOL] for msg in itertools . islice ( msg_iter , [number] ) : [EOL] time . sleep ( [number] ) [EOL] mq . add ( uuids [ [number] ] , msg ) [EOL] [EOL] for msg in itertools . islice ( msg_iter , [number] ) : [EOL] time . sleep ( [number] ) [EOL] mq . add ( uuids [ [number] ] , msg ) [EOL] [EOL] assert set ( uuids ) == set ( mq . get_guids ( ) ) [EOL] assert mq . get_messages ( uuids [ [number] ] ) == messages [ : [number] ] [EOL] assert mq . get_messages ( uuids [ [number] ] ) == messages [ [number] : [number] ] [EOL] assert mq . get_messages ( uuids [ [number] ] ) == messages [ [number] : [number] ] [EOL] assert mq . count == [number] [EOL] [EOL] mq . add ( uuids [ [number] ] , next ( msg_iter ) ) [EOL] [EOL] assert mq . count == [number] [EOL] [EOL] assert mq . get_messages ( uuids [ [number] ] ) == messages [ [number] : [number] ] [EOL] assert mq . get_messages ( uuids [ [number] ] ) == messages [ [number] : [number] ] + [ messages [ [number] ] ] [EOL] [EOL] mq . remove_oldest ( [number] ) [EOL] [EOL] first = mq . get_messages ( uuids [ [number] ] ) [EOL] [EOL] assert first [EOL] assert set ( first ) == set ( messages [ [number] : [number] ] ) - { old_msg } [EOL] [EOL] [EOL] class Item ( NamedTuple ) : [EOL] a = ... [EOL] b = ... [EOL] [EOL] [EOL] def test_index_map ( ) : [EOL] im = IndexMap ( [string] , [string] , [string] ) [EOL] [EOL] items = [ Item ( a = [number] , b = [string] ) , Item ( a = [number] , b = [string] ) , Item ( a = [number] , b = [string] ) , Item ( a = [number] , b = [string] ) , Item ( a = [number] , b = [string] ) , ] [EOL] [EOL] for item in items : [EOL] im . add ( item , a = item . a , b = item . b , c = [string] ) [EOL] [EOL] assert set ( im . lookup ( a = [number] , b = [string] ) ) == { items [ [number] ] } [EOL] [EOL] im . remove ( items [ [number] ] ) [EOL] [EOL] assert not im . lookup ( a = [number] ) [EOL] assert not im . lookup ( b = [string] ) [EOL] assert not im . lookup ( a = [number] , b = [string] ) [EOL] [EOL] items . remove ( items [ [number] ] ) [EOL] [EOL] assert set ( im . lookup ( c = [string] ) ) == set ( items ) [EOL] assert set ( im . lookup ( b = [string] ) ) == set ( items [ [number] : [number] ] ) [EOL] assert set ( im . lookup ( a = [number] ) ) == set ( items [ [number] : [number] ] ) [EOL] assert set ( im . lookup ( a = [number] , b = [string] ) ) == { items [ [number] ] } [EOL] assert set ( im . _indexes . keys ( ) ) == { [string] , [string] , [string] } [EOL] [EOL] for item in im : [EOL] im . remove ( item ) [EOL] [EOL] assert not im . _items [EOL] assert not im . _indexes [ [string] ] [EOL] assert not im . _indexes [ [string] ] [EOL] assert not im . _indexes [ [string] ] [EOL] assert not im . _inverse_indexes [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , Callable [EOL] import tests [EOL] import builtins [EOL] import typing [EOL] import webswitch [EOL] import threading [EOL] import asyncio [EOL] import logging [EOL] import pytest [EOL] from threading import Thread , Event [EOL] from asyncio import sleep as async_sleep , new_event_loop [EOL] from typing import Iterable , Optional , List , Callable , Dict , Any [EOL] [EOL] from . common import * [EOL] from webswitch . channel_server import Conversation , add_action , ChannelClient [EOL] from webswitch . client import Client , ResponseException [EOL] from webswitch . message import Message [EOL] [EOL] [EOL] class UniqueError ( Exception ) : [EOL] def __init__ ( self ) : [EOL] super ( UniqueError , self ) . __init__ ( [string] , [string] ) [EOL] [EOL] [EOL] class ServerTestingServer ( ChannelServerBase ) : [EOL] @ add_action ( ) async def action_server_timeout_test ( self , client , convo ) : [EOL] await convo . send_and_recv ( { [string] : [string] } , timeout = [number] ) [EOL] [EOL] @ add_action ( params = { [string] : float } ) async def action_timeout ( self , timeout , client , convo ) : [EOL] await convo . send ( { [string] : True } ) [EOL] await async_sleep ( timeout ) [EOL] [EOL] @ add_action ( ) def action_raise_unique_error ( self , client ) : [EOL] raise UniqueError ( ) [EOL] [EOL] @ add_action ( ) async def action_raise_unique_error_async ( self , client , convo ) : [EOL] raise UniqueError ( ) [EOL] [EOL] @ add_action ( ) async def action_async_return ( self , convo , client ) : [EOL] return { [string] : [string] } [EOL] [EOL] @ add_action ( ) def action_nonasync_return ( self , client ) : [EOL] return { [string] : [string] } [EOL] [EOL] @ add_action ( ) async def action_send_error_and_continue ( self , convo , client ) : [EOL] response = await convo . send_and_recv ( Message ( { [string] : [string] } , error = [string] ) ) [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] , scope = [string] ) def get_server_fixture ( free_port ) : [EOL] def func ( ) : [EOL] return ServerTestingServer ( free_port ) [EOL] [EOL] return func [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_invalid_room ( get_server , free_port , ) : [EOL] server = get_server ( ) [EOL] server . serve ( daemon = True ) [EOL] [EOL] with pytest . raises ( Exception ) as excinfo : [EOL] client = Client ( f' [string] { HOSTNAME } [string] { free_port } [string] ' ) [EOL] [EOL] async with client : [EOL] convo = client . convo ( [string] ) [EOL] await convo . send_and_expect ( { } ) [comment] [EOL] [EOL] assert excinfo . value . data . get ( [string] ) == [string] , [string] [EOL] assert excinfo . value . message . startswith ( [string] ) [EOL] [EOL] server . stop_serve ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_response_dispatch_timeout ( get_server , get_client , caplog ) : [EOL] server = get_server ( ) [EOL] server . serve ( daemon = True ) [EOL] [EOL] async with get_client ( ) as client : [EOL] convo = client . convo ( [string] ) [EOL] response = await convo . send_and_expect ( data = { [string] : [number] } ) [EOL] assert [string] in response . data [EOL] [EOL] wait_time = [number] [EOL] [EOL] caplog . clear ( ) [EOL] [comment] [EOL] with caplog . at_level ( logging . DEBUG ) : [EOL] server . stop_serve ( wait_time ) [EOL] [EOL] name_pattern = [string] [EOL] [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = f' [string] { wait_time } [string] ' ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_response_dispatch_no_cancel ( get_server , get_client , caplog ) : [EOL] server = get_server ( ) [EOL] server . serve ( daemon = True ) [EOL] [EOL] async with get_client ( ) as client : [EOL] convo = client . convo ( [string] ) [EOL] response = await convo . send_and_expect ( data = { [string] : [number] } ) [EOL] assert [string] in response . data [EOL] [EOL] [comment] [EOL] wait_time = [number] [EOL] caplog . clear ( ) [EOL] with caplog . at_level ( logging . DEBUG ) : [EOL] server . stop_serve ( wait_time ) [EOL] [EOL] name_pattern = [string] [EOL] [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = f' [string] { wait_time } [string] ' ) [EOL] assert not filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert not filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_response_dispatch_do_cancel ( get_server , get_client , caplog ) : [EOL] server = get_server ( ) [EOL] server . serve ( daemon = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] client_send_event = Event ( ) [EOL] server_stop_event = Event ( ) [EOL] [EOL] def thread_main ( ) : [EOL] async def async_main ( ) : [EOL] async with get_client ( ) as client : [EOL] convo = client . convo ( [string] ) [EOL] [comment] [EOL] response = await convo . send_and_expect ( data = { [string] : [number] } ) [EOL] assert [string] in response . data [EOL] client_send_event . set ( ) [EOL] [EOL] while not server_stop_event . is_set ( ) : [EOL] await async_sleep ( [number] ) [EOL] [EOL] event_loop = new_event_loop ( ) [EOL] event_loop . run_until_complete ( async_main ( ) ) [EOL] [EOL] thread = Thread ( name = [string] , target = thread_main ) [EOL] thread . start ( ) [EOL] client_send_event . wait ( ) [EOL] [EOL] wait_time = [number] [EOL] [EOL] caplog . clear ( ) [EOL] with caplog . at_level ( logging . DEBUG ) : [EOL] server . stop_serve ( wait_time ) [EOL] [EOL] server_stop_event . set ( ) [EOL] thread . join ( ) [EOL] [EOL] name_pattern = [string] [EOL] [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = f' [string] { wait_time } [string] ' ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] assert filter_records ( caplog . record_tuples , name_pattern = name_pattern , msg_pattern = [string] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_unique_error_nonasync ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] await convo . send_and_expect ( { } ) [EOL] [EOL] assert excinfo . value . data . get ( [string] ) == [string] , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_unique_error_async ( get_server , get_client ) : [EOL] server = get_server ( ) [EOL] server . serve ( daemon = True ) [EOL] [EOL] async with get_client ( ) as client : [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] convo = client . convo ( [string] ) [EOL] await convo . send_and_expect ( { } ) [EOL] [EOL] assert excinfo . value . data . get ( [string] ) == [string] , [string] [EOL] assert len ( server . dispatcher . _actives ) == [number] [EOL] [EOL] server . stop_serve ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_server_timeout ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] [comment] [EOL] response = await convo . send_and_expect ( { } ) [EOL] [EOL] assert response . data . get ( [string] ) == [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] await convo . expect ( [number] ) [EOL] [EOL] assert excinfo . value . data . get ( [string] ) == [string] , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_return ( client_with_server ) : [EOL] message = await client_with_server . convo ( [string] ) . send_and_expect ( { } ) [EOL] assert [string] in message . data [EOL] assert [string] in message . data [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_nonasync_return ( client_with_server ) : [EOL] message = await client_with_server . convo ( [string] ) . send_and_expect ( { } ) [EOL] assert [string] in message . data [EOL] assert [string] in message . data [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_client_error ( get_server , get_client ) : [EOL] [comment] [EOL] [comment] [EOL] server = get_server ( ) [EOL] [EOL] server . serve ( daemon = True ) [EOL] [EOL] async with get_client ( ) as client : [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] convo = client . convo ( [string] ) [EOL] await convo . send_and_expect ( { } , [number] ) [EOL] assert excinfo . value . message == [string] , [string] [EOL] [EOL] with TimeBox ( [number] ) as window : [EOL] server . stop_serve ( window . timelimit ) [EOL] [EOL] assert len ( server . dispatcher . _actives ) == [number] , [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'ChannelClient'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $webswitch.channel_server.Conversation$ 0 $'ChannelClient'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict$ 0 0 0 $'ChannelClient'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $webswitch.channel_server.Conversation$ 0 $'ChannelClient'$ 0 0 0 $typing.Any$ 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],ServerTestingServer]$ 0 0 0 0 0 0 $ServerTestingServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , Callable , List , AsyncIterable , Optional , Tuple [EOL] import builtins [EOL] import typing [EOL] import webswitch [EOL] import types [EOL] import fnmatch [EOL] import socket [EOL] import time [EOL] from types import TracebackType [EOL] from contextlib import closing [EOL] from types import TracebackType [EOL] from typing import * [EOL] [EOL] import pytest [EOL] [EOL] from webswitch . client import Client [EOL] from webswitch . channel_server import ChannelServer [EOL] [EOL] HOSTNAME = [string] [EOL] PORT = None [comment] [EOL] [EOL] [EOL] class ChannelServerBase ( ChannelServer ) : [EOL] def __init__ ( self , port ) : [EOL] super ( ChannelServerBase , self ) . __init__ ( [string] , port ) [EOL] [EOL] def __enter__ ( self ) : [EOL] self . serve ( daemon = True ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] self . stop_serve ( ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] , scope = [string] ) def get_server_fixture ( free_port ) : [EOL] raise NotImplemented ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) async def client_with_server ( get_client , get_server ) : [EOL] with get_server ( ) : [EOL] async with get_client ( ) as client : [EOL] yield client [EOL] [EOL] [EOL] def filter_records ( records , name_pattern = None , msg_pattern = None , ) : [EOL] filtered = [ ] [EOL] for name , level , msg in records : [EOL] if name_pattern and not fnmatch . fnmatch ( name , name_pattern ) : [EOL] continue [EOL] [EOL] if msg_pattern and not fnmatch . fnmatch ( msg , msg_pattern ) : [EOL] continue [EOL] [EOL] filtered . append ( ( name , level , msg ) ) [EOL] [EOL] return filtered [EOL] [EOL] [EOL] def find_free_port ( ) : [EOL] global PORT [EOL] [EOL] if PORT : [EOL] return PORT [EOL] [EOL] with closing ( socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) ) as s : [EOL] s . bind ( ( [string] , [number] ) ) [EOL] return cast ( Tuple [ Any , int ] , s . getsockname ( ) ) [ [number] ] [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def free_port ( ) : [EOL] return find_free_port ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def get_client ( free_port ) : [EOL] def func ( ) : [EOL] return Client ( f' [string] { HOSTNAME } [string] { free_port } [string] ' ) [EOL] [EOL] return func [EOL] [EOL] [EOL] class TimeBox ( object ) : [EOL] def __init__ ( self , window , slack = [number] ) : [EOL] self . _timelimit = window [EOL] self . _slack = slack [EOL] self . _start = None [EOL] self . _elapsed = None [EOL] [EOL] @ property def timelimit ( self ) : [EOL] return self . _timelimit [EOL] [EOL] @ property def elapsed ( self ) : [EOL] return self . _elapsed [EOL] [EOL] @ property def within_timelimit ( self ) : [EOL] assert self . _elapsed is not None [EOL] return self . _elapsed < self . _timelimit - self . _slack [EOL] [EOL] def __enter__ ( self ) : [EOL] self . _start = time . monotonic ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_val , exc_tb ) : [EOL] assert self . _start is not None [EOL] self . _elapsed = time . monotonic ( ) - self . _start [EOL] [EOL] assert self . within_timelimit , f' [string] { self . _timelimit } [string] ' [EOL] [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $'ChannelServerBase'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 $types.TracebackType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterable[webswitch.client.Client]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],webswitch.client.Client]$ 0 0 0 0 0 0 $webswitch.client.Client$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'TimeBox'$ 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[builtins.BaseException]$ 0 $typing.Any$ 0 $types.TracebackType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import logging [EOL] from logging . handlers import SocketHandler [EOL] from webswitch . logger import g_logger [EOL] [EOL] logging . basicConfig ( format = [string] ) [EOL] g_logger . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , Callable [EOL] import builtins [EOL] import webswitch [EOL] import typing [EOL] from asyncio import sleep as async_sleep [EOL] import asyncio [EOL] import pytest [EOL] from typing import * [EOL] [EOL] from webswitch . router . errors import RouterError [EOL] from webswitch . client import Client , ResponseException , ResponseTimeoutException [EOL] from webswitch . channel_server import Conversation , add_action , ChannelClient [EOL] [EOL] from . common import * [EOL] [EOL] [EOL] class ClientTestingServer ( ChannelServerBase ) : [EOL] @ add_action ( params = { [string] : str } ) async def action_test_conversation ( self , arg , client , convo ) : [EOL] [EOL] response = await convo . send_and_recv ( { [string] : f' [string] { arg }' , [string] : f' [string] { arg }' } ) [EOL] [EOL] arg = response . get ( [string] ) [EOL] [EOL] assert arg , [string] [EOL] assert arg == [string] , [string] [EOL] [EOL] response = await convo . send_and_recv ( { [string] : [string] } , expect_params = { [string] : int } ) [EOL] [EOL] arg = response . get ( [string] ) [EOL] [EOL] assert arg == [number] , [string] [EOL] [EOL] @ add_action ( ) async def action_async_raise ( self , client , convo ) : [EOL] raise RouterError ( error_types = [string] , message = [string] ) [EOL] [EOL] @ add_action ( params = { [string] : float } ) async def action_client_timeout_test ( self , timeout , client , convo ) : [EOL] await async_sleep ( timeout ) [EOL] await convo . send ( { [string] : [string] } ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] , scope = [string] ) def get_server_fixture ( free_port ) : [EOL] def func ( ) : [EOL] return ClientTestingServer ( free_port ) [EOL] [EOL] return func [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_whoami ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] reply = await convo . send_and_expect ( { } ) [EOL] [EOL] my_id = reply . data . get ( [string] ) [EOL] [EOL] assert my_id , [string] [EOL] assert isinstance ( my_id , int ) , [string] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_async_raise ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] await convo . send_and_expect ( { } ) [EOL] [EOL] assert [string] in excinfo . value . error_types [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_convo ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] response = await convo . send_and_expect ( { [string] : [string] } ) [EOL] [EOL] assert response . data . get ( [string] ) == [string] [EOL] assert response . data . get ( [string] ) == [string] [EOL] [EOL] response = await convo . send_and_expect ( { [string] : [string] } ) [EOL] [EOL] assert response . data . get ( [string] ) == [string] [EOL] [EOL] await convo . send ( data = dict ( arg = [number] ) ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_client_timeout ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] with pytest . raises ( ResponseTimeoutException ) as excinfo : [EOL] await convo . send_and_expect ( { [string] : [number] } , timeout = [number] ) [EOL] [EOL] @ pytest . mark . asyncio async def test_unknown_action ( client_with_server ) : [EOL] convo = client_with_server . convo ( [string] ) [EOL] [EOL] with pytest . raises ( ResponseException ) as excinfo : [EOL] await convo . send_and_expect ( { } ) [EOL] [EOL] assert excinfo . match ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [number] ] ) @ pytest . mark . asyncio async def test_enum ( count , get_client , get_server ) : [EOL] with get_server ( ) as server : [EOL] clients = [ ] [EOL] [EOL] for i in range ( count ) : [EOL] clients . append ( get_client ( ) ) [EOL] [EOL] await asyncio . gather ( * ( c . __aenter__ ( ) for c in clients ) ) [EOL] [EOL] collected_ids = set ( ) [EOL] [EOL] for client in clients : [EOL] message = await client . convo ( [string] ) . send_and_expect ( { } ) [EOL] assert [string] in message . data [EOL] collected_ids . add ( message . data [ [string] ] ) [EOL] [EOL] client1 = clients [ [number] ] [EOL] [EOL] message = await client1 . convo ( [string] ) . send_and_expect ( { } ) [EOL] [EOL] await asyncio . gather ( * ( c . __aexit__ ( None , None , None ) for c in clients ) ) [EOL] [EOL] data = message . data [EOL] [EOL] assert isinstance ( data , dict ) [EOL] assert [string] in data [EOL] assert isinstance ( data [ [string] ] , list ) [EOL] [EOL] enum_ids = set ( data [ [string] ] ) [EOL] [EOL] assert enum_ids == collected_ids [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_send ( get_client , get_server ) : [EOL] with get_server ( ) : [EOL] async with get_client ( ) as client1 , get_client ( ) as client2 : [EOL] await client1 . convo ( [string] ) . send ( { [string] : [ client2 . client_id ] , [string] : { [string] : [string] } } ) [EOL] [EOL] response = await client2 . convo ( None ) . expect ( [number] ) [EOL] [EOL] assert response . data . get ( [string] ) == [string] [EOL] assert response . data . get ( [string] ) == client1 . client_id [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 $typing.Any$ 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 $'ChannelClient'$ 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $webswitch.channel_server.Conversation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[],ClientTestingServer]$ 0 0 0 0 0 0 $ClientTestingServer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0