import builtins [EOL] from talepy . functional import arity , is_arity_one_pair , partition [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( lambda : [number] , [number] ) , ( lambda x : x , [number] ) , ( lambda x , y : x + y , [number] ) ] , ) def test_we_can_get_arity_from_functions ( test_func , expected_arity ) : [EOL] assert arity ( test_func ) == expected_arity [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( ( lambda x : x , lambda y : y ) , True ) , ( lambda : [number] , False ) , ( ( [string] , [string] ) , False ) , ( ( lambda x : x , [string] ) , False ) , ( [string] , False ) , ( ( lambda x , z : x + z , lambda y : y ) , False ) , ( ( lambda x : x , lambda y , z : y + z ) , False ) , ( ( lambda : [number] , lambda y : y ) , False ) , ( ( lambda x : x , lambda : [number] ) , False ) , ( ( lambda x : x , lambda y : y , lambda z : z ) , False ) , ] , ) def test_we_can_tell_if_something_is_a_pair_of_functions ( thing , expected_result ) : [EOL] assert is_arity_one_pair ( thing ) == expected_result [EOL] [EOL] [EOL] def test_partition_splits_a_list ( ) : [EOL] even , odd = partition ( [ [number] , [number] , [number] , [number] ] , lambda x : ( x % [number] ) == [number] ) [EOL] assert odd == [ [number] , [number] ] [EOL] assert even == [ [number] , [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import talepy [EOL] import tests [EOL] import builtins [EOL] from talepy . steps import LambdaStep , Step [EOL] [EOL] [EOL] def test_execute_calls_the_first_lambda ( ) : [EOL] step = LambdaStep ( lambda x : f" [string] { x }" , lambda y : None ) [EOL] assert step . execute ( [string] ) == [string] [EOL] [EOL] [EOL] def test_compensate_calls_the_second_lambda_with_the_supplied_state ( ) : [EOL] class Reverter : [EOL] def lambda_func ( self , state_given ) : [EOL] self . reverted = state_given [EOL] [EOL] reverter = Reverter ( ) [EOL] step = LambdaStep ( lambda x : f" [string] { x }" , reverter . lambda_func ) [EOL] [EOL] step . compensate ( [string] ) [EOL] assert reverter . reverted == [string] [EOL] [EOL] [EOL] def test_compensate_step_is_optional ( ) : [EOL] step = LambdaStep ( lambda x : f" [string] { x }" ) [EOL] assert step . execute ( [string] ) == [string] [EOL] step . compensate ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Any [EOL] import tests [EOL] import typing [EOL] import pytest [EOL] [EOL] from talepy import run_transaction [EOL] from talepy . exceptions import CompensationFailure [EOL] from tests . mocks import MockCountingStep , AlwaysFailsStep , AlwaysFailException [EOL] [EOL] [EOL] def test_a_transaction_runs_a_step_it_wraps ( ) : [EOL] mock_step = MockCountingStep ( ) [EOL] run_transaction ( steps = [ mock_step ] , starting_state = [number] ) [EOL] [EOL] assert mock_step . actions_taken == [ [string] ] [EOL] [EOL] [EOL] def test_a_transaction_runs_many_steps_it_wraps_and_passes_state ( ) : [EOL] step_one = MockCountingStep ( ) [EOL] step_two = MockCountingStep ( ) [EOL] run_transaction ( steps = [ step_one , step_two ] , starting_state = [number] ) [EOL] [EOL] assert step_one . actions_taken == [ [string] ] [EOL] assert step_two . actions_taken == [ [string] ] [EOL] [EOL] [EOL] def test_final_state_is_returned ( ) : [EOL] step_one = MockCountingStep ( ) [EOL] step_two = MockCountingStep ( ) [EOL] [EOL] result = run_transaction ( steps = [ step_one , step_two ] , starting_state = [number] ) [EOL] [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_if_a_transaction_fails_all_compensations_are_applied ( ) : [EOL] step_one = MockCountingStep ( ) [EOL] step_two = MockCountingStep ( ) [EOL] failing_step = AlwaysFailsStep ( ) [EOL] [EOL] with pytest . raises ( AlwaysFailException ) : [EOL] run_transaction ( steps = [ step_one , step_two , failing_step ] , starting_state = [number] ) [EOL] [EOL] assert step_one . actions_taken == [ [string] , [string] ] [EOL] assert step_two . actions_taken == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_if_a_transaction_fails_later_steps_are_ignored ( ) : [EOL] step_one = MockCountingStep ( ) [EOL] step_two = MockCountingStep ( ) [EOL] failing_step = AlwaysFailsStep ( ) [EOL] never_executed_step = MockCountingStep ( ) [EOL] [EOL] with pytest . raises ( AlwaysFailException ) : [EOL] run_transaction ( steps = [ step_one , step_two , failing_step , never_executed_step ] , starting_state = [number] , ) [EOL] [EOL] assert never_executed_step . actions_taken == [ ] [EOL] [EOL] [EOL] def test_exceptions_are_raised_eventually ( ) : [EOL] with pytest . raises ( AlwaysFailException , match = [string] ) : [EOL] run_transaction ( steps = [ MockCountingStep ( ) , AlwaysFailsStep ( ) ] , starting_state = [number] ) [EOL] [EOL] [EOL] def test_single_lambdas_are_turned_into_steps ( ) : [EOL] result = run_transaction ( steps = [ lambda x : x + [number] , lambda x : x + [number] ] , starting_state = [number] ) [EOL] [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_pairs_of_lambdas_are_turned_into_a_step ( ) : [EOL] result = run_transaction ( steps = [ ( lambda x : x + [number] , lambda y : None ) , ( lambda x : x + [number] , lambda y : None ) ] , starting_state = [number] , ) [EOL] [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_failures_in_compensations_are_caught_and_bundled ( ) : [EOL] def create_failure ( message ) : [EOL] def fail ( s ) : [EOL] raise Exception ( message ) [EOL] [EOL] return fail [EOL] [EOL] with pytest . raises ( CompensationFailure ) as e_info : [EOL] run_transaction ( steps = [ ( lambda x : x + [number] , create_failure ( [string] ) ) , ( lambda x : x + [number] , create_failure ( [string] ) ) , ( create_failure ( [string] ) , lambda x : x - [number] ) , ] , starting_state = [number] , ) [EOL] [EOL] assert str ( e_info . value ) == f" [string] " [EOL] error_messages = map ( lambda e : str ( e ) , e_info . value . inner_exceptions ) [EOL] assert list ( error_messages ) == [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import tests [EOL] import pytest [EOL] [EOL] from talepy import run_transaction [EOL] from talepy . exceptions import FailuresAfterRetrying [EOL] from talepy . retries import attempt_retries [EOL] from tests . mocks import ( MockRetryStep , MockRetryStepThatRetriesTwice , MockRetryStepThatRetriesTwiceThenGivesUp , RegularMockStep , ) [EOL] [EOL] [EOL] def test_the_retry_is_run ( ) : [EOL] mock_step = MockRetryStep ( ) [EOL] run_transaction ( steps = [ mock_step ] , starting_state = [number] ) [EOL] [EOL] assert mock_step . actions_taken == [ [string] ] [EOL] [EOL] [EOL] def test_a_second_retry_can_be_run ( ) : [EOL] mock_step = MockRetryStepThatRetriesTwice ( ) [EOL] run_transaction ( steps = [ mock_step ] , starting_state = [number] ) [EOL] [EOL] assert mock_step . actions_taken == [ [string] , [string] , ] [EOL] [EOL] [EOL] def test_retries_can_be_stopped_by_raising_abort_retries ( ) : [EOL] mock_step = MockRetryStepThatRetriesTwiceThenGivesUp ( ) [EOL] [EOL] with pytest . raises ( FailuresAfterRetrying ) as e_info : [EOL] run_transaction ( steps = [ mock_step ] , starting_state = [number] ) [EOL] [EOL] assert mock_step . actions_taken == [ [string] , [string] , ] [EOL] [EOL] assert str ( e_info . value ) == [string] [EOL] [EOL] [EOL] def test_helper_method_runs_the_step_the_expected_number_of_times ( ) : [EOL] mock_step = RegularMockStep ( ) [EOL] [EOL] with pytest . raises ( FailuresAfterRetrying ) as e_info : [EOL] run_transaction ( steps = [ attempt_retries ( mock_step , times = [number] ) ] , starting_state = [number] ) [EOL] [EOL] assert mock_step . actions_taken == [ [string] , [string] , [string] ] [EOL] [EOL] assert str ( e_info . value ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import tests [EOL] import typing [EOL] import builtins [EOL] import asyncio [EOL] import typing [EOL] from typing import List [EOL] [EOL] from talepy import StepWithRetries , Step [EOL] from talepy . exceptions import AbortRetries [EOL] [EOL] [EOL] class MockCountingStep ( Step [ int , int ] ) : [EOL] [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] return counter_state + [number] [EOL] [EOL] [EOL] class MockAsyncExecuteStep ( Step [ int , int ] ) : [EOL] [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] async def execute ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] return counter_state + [number] [EOL] [EOL] [EOL] class MockAsyncExecuteAndCompensateStep ( Step [ int , int ] ) : [EOL] [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] async def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] async def execute ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] return counter_state + [number] [EOL] [EOL] [EOL] class MockAsyncCompensateStep ( Step [ int , int ] ) : [EOL] [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] async def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] return counter_state + [number] [EOL] [EOL] [EOL] class AlwaysFailException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class AlwaysFailsStep ( Step ) : [EOL] [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] self . exception = AlwaysFailException ( [string] ) [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] pass [EOL] [EOL] def execute ( self , counter_state ) : [EOL] raise self . exception [EOL] [EOL] [EOL] class MockRetryStep ( StepWithRetries ) : [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] raise FirstFail ( [string] ) [EOL] [EOL] def retry ( self , state , failures ) : [EOL] self . actions_taken . append ( f" [string] { state } [string] { len ( failures ) } [string] " ) [EOL] return state + [number] [EOL] [EOL] [EOL] class MockRetryStepThatRetriesTwice ( StepWithRetries ) : [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] raise FirstFail ( [string] ) [EOL] [EOL] def retry ( self , state , failures ) : [EOL] self . actions_taken . append ( f" [string] { state } [string] { len ( failures ) } [string] " ) [EOL] if len ( failures ) < [number] : [EOL] raise FirstFail ( [string] ) [EOL] return state + [number] [EOL] [EOL] [EOL] class MockRetryStepThatRetriesTwiceThenGivesUp ( StepWithRetries ) : [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] raise FirstFail ( [string] ) [EOL] [EOL] def retry ( self , state , failures ) : [EOL] self . actions_taken . append ( f" [string] { state } [string] { len ( failures ) } [string] " ) [EOL] if len ( failures ) < [number] : [EOL] raise FirstFail ( [string] ) [EOL] [EOL] raise AbortRetries ( [string] ) [EOL] [EOL] [EOL] class RegularMockStep ( Step ) : [EOL] actions_taken = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . actions_taken = [ ] [EOL] [EOL] def compensate ( self , counter_state ) : [EOL] self . actions_taken . append ( f" [string] { counter_state }" ) [EOL] [EOL] def execute ( self , counter_state ) : [EOL] self . actions_taken . append ( [string] ) [EOL] raise FirstFail ( [string] ) [EOL] [EOL] [EOL] class FirstFail ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SubsequentFailure ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SlowMoStep ( Step ) : [EOL] def compensate ( self , state ) : [EOL] pass [EOL] [EOL] async def execute ( self , state ) : [EOL] await asyncio . sleep ( [number] ) [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $tests.mocks.AlwaysFailException$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any , List [EOL] [EOL] [EOL] class TalepyException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class InvalidStepDefinition ( ValueError , TalepyException ) : [EOL] def __init__ ( self , invalid_definition ) : [EOL] super ( ) . __init__ ( f" [string] { invalid_definition } [string] " ) [EOL] [EOL] [EOL] class CompensationFailure ( RuntimeError , TalepyException ) : [EOL] inner_exceptions = ... [EOL] [EOL] def __init__ ( self , failures ) : [EOL] self . inner_exceptions = failures [EOL] super ( ) . __init__ ( f" [string] { len ( failures ) } [string] " ) [EOL] [EOL] [EOL] class AbortRetries ( RuntimeError , TalepyException ) : [EOL] pass [EOL] [EOL] [EOL] class FailuresAfterRetrying ( RuntimeError , TalepyException ) : [EOL] inner_exceptions = ... [EOL] [EOL] def __init__ ( self , failures ) : [EOL] self . inner_exceptions = failures [EOL] super ( ) . __init__ ( f" [string] { len ( failures ) } [string] " ) [EOL] [EOL] [EOL] class AsyncStepFailures ( RuntimeError , TalepyException ) : [EOL] inner_exceptions = ... [EOL] [EOL] def __init__ ( self , exceptions ) : [EOL] self . inner_exceptions = exceptions [EOL] [EOL] [EOL] class AsyncStepUsedInSyncTransaction ( ValueError , TalepyException ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( f" [string] " f" [string] " ) [EOL] [EOL] [EOL] class RetriesCannotBeUsedInConcurrent ( ValueError , TalepyException ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( f" [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 $typing.List[builtins.Exception]$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Union , Callable , Any , Iterable [EOL] import talepy [EOL] import typing [EOL] import steps [EOL] from typing import Tuple , Any , List , Iterable [EOL] [EOL] from . async_transactions import has_async_execute [EOL] from . exceptions import CompensationFailure , AsyncStepUsedInSyncTransaction [EOL] from . retries import StepWithRetries , execute_step_retry [EOL] from . steps import build_step_list , StepLike , Step [EOL] [EOL] [EOL] def _compensate_completed_steps ( completed_steps ) : [EOL] failures = [ ] [EOL] for ( step , state ) in reversed ( completed_steps ) : [EOL] try : [EOL] step . compensate ( state ) [EOL] except Exception as failure : [EOL] failures . append ( failure ) [EOL] if failures != [ ] : [EOL] raise CompensationFailure ( failures ) [EOL] [EOL] [EOL] def _execute_step ( state , step ) : [EOL] try : [EOL] return step . execute ( state ) [EOL] except Exception as e : [EOL] if isinstance ( step , StepWithRetries ) : [EOL] return execute_step_retry ( state , step , [ e ] ) [EOL] raise e [EOL] [EOL] [EOL] def run_transaction ( steps , starting_state = None ) : [EOL] steps = build_step_list ( steps ) [EOL] completed_steps = [ ] [EOL] state = starting_state [EOL] try : [EOL] for step in steps : [EOL] if has_async_execute ( step ) : [EOL] raise AsyncStepUsedInSyncTransaction [EOL] state = _execute_step ( state , step ) [EOL] completed_steps . append ( ( step , state ) ) [EOL] return state [EOL] [EOL] except Exception as error : [EOL] _compensate_completed_steps ( completed_steps ) [EOL] raise error [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , List [EOL] import typing [EOL] import steps [EOL] import builtins [EOL] from abc import ABC , abstractmethod [EOL] from typing import List , TypeVar [EOL] [EOL] from . exceptions import AbortRetries , FailuresAfterRetrying [EOL] from . steps import Step [EOL] [EOL] InputState = TypeVar ( [string] ) [EOL] OutputState = TypeVar ( [string] ) [EOL] [EOL] [EOL] class StepWithRetries ( Step [ InputState , OutputState ] , ABC ) : [EOL] @ abstractmethod def retry ( self , state , failures ) : [EOL] pass [EOL] [EOL] [EOL] def attempt_retries ( step , times ) : [EOL] class AutoRetryStep ( StepWithRetries ) : [EOL] def __init__ ( self , wrapped_step , max_tries ) : [EOL] self . wrapped_step = wrapped_step [EOL] self . attempts_made = [number] [EOL] self . max_tries = max_tries [EOL] [EOL] def compensate ( self , state ) : [EOL] self . wrapped_step . compensate ( state ) [EOL] [EOL] def execute ( self , state ) : [EOL] self . attempts_made += [number] [EOL] return self . wrapped_step . execute ( state ) [EOL] [EOL] def retry ( self , state , _failures ) : [EOL] if self . attempts_made > self . max_tries : [EOL] raise AbortRetries ( [string] ) [EOL] return self . execute ( state ) [EOL] [EOL] return AutoRetryStep ( step , times ) [EOL] [EOL] [EOL] def execute_step_retry ( state , step , previous_errors ) : [EOL] try : [EOL] return step . retry ( state , previous_errors ) [EOL] except AbortRetries as _give_up : [EOL] raise FailuresAfterRetrying ( previous_errors ) [EOL] except Exception as e : [EOL] return execute_step_retry ( state , step , previous_errors + [ e ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OutputState$ 0 0 0 $InputState$ 0 $typing.List[builtins.Exception]$ 0 0 0 0 0 0 0 0 $StepWithRetries$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0