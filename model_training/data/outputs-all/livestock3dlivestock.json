import datetime [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from setuptools import setup [EOL] from codecs import open [EOL] from os import path [EOL] import datetime [EOL] [EOL] [comment] [EOL] here = path . abspath ( path . dirname ( __file__ ) ) [EOL] [EOL] [comment] [EOL] with open ( path . join ( here , [string] ) , encoding = [string] ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] now = datetime . datetime . now ( ) [EOL] release_version = [string] [EOL] version = f'{ now . year } [string] { now . month } [string] { release_version }' [EOL] [EOL] setup ( name = [string] , version = version , description = [string] [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , author = [string] , author_email = [string] , license = [string] , keywords = [string] , packages = [ [string] , ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , python_requires = [string] , ) [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $datetime.datetime$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] import pytest [EOL] import platform [EOL] import os [EOL] [EOL] [comment] [EOL] from livestock import flow [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . skipif ( platform . system ( ) == [string] , reason = [string] ) def test_flow_from_centers ( drain_mesh ) : [EOL] [EOL] flow . flow_from_centers ( drain_mesh ) [EOL] [EOL] assert os . path . exists ( os . path . join ( drain_mesh , [string] ) ) [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import cmf [EOL] import pytest [EOL] import os [EOL] [EOL] [comment] [EOL] from livestock import hydrology [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_load_cmf_files ( input_files ) : [EOL] ( ground , mesh_paths , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = hydrology . load_cmf_files ( input_files ) [EOL] [EOL] assert ground [EOL] assert isinstance ( ground , list ) [EOL] for ground_ in ground : [EOL] assert isinstance ( ground_ , dict ) [EOL] [EOL] assert mesh_paths [EOL] assert isinstance ( mesh_paths , list ) [EOL] for mesh in mesh_paths : [EOL] assert isinstance ( mesh , str ) [EOL] assert os . path . split ( mesh ) [ [number] ] . startswith ( [string] ) [EOL] assert os . path . split ( mesh ) [ [number] ] . endswith ( [string] ) [EOL] [EOL] assert outputs [EOL] assert isinstance ( outputs , dict ) [EOL] [EOL] assert solver_settings [EOL] assert isinstance ( solver_settings , dict ) [EOL] [EOL] [EOL] def test_mesh_to_cells ( obj_file_paths ) : [EOL] project = cmf . project ( ) [EOL] [EOL] hydrology . mesh_to_cells ( project , [ obj_file_paths , ] , False ) [EOL] [EOL] assert project [EOL] assert project . cells [EOL] [EOL] [EOL] def test_create_retention_curve ( cmf_data ) : [EOL] ( ground_list , mesh_path , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = cmf_data [EOL] [EOL] for ground in ground_list : [EOL] curve_dict = ground [ [string] ] [ [string] ] [EOL] r_curve = hydrology . create_retention_curve ( curve_dict ) [EOL] [EOL] assert r_curve [EOL] assert isinstance ( r_curve , cmf . VanGenuchtenMualem ) [EOL] assert r_curve . Ksat == curve_dict [ [string] ] [EOL] assert r_curve . alpha == curve_dict [ [string] ] [EOL] assert r_curve . Phi == curve_dict [ [string] ] [EOL] assert r_curve . n == curve_dict [ [string] ] [EOL] assert r_curve . m == curve_dict [ [string] ] [EOL] assert r_curve . l == curve_dict [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_install_cell_connections ( cmf_data , project_with_cells ) : [EOL] ( ground_list , mesh_path , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = cmf_data [EOL] [EOL] for ground in ground_list : [EOL] for cell_index in ground [ [string] ] : [EOL] cell = project_with_cells . cells [ cell_index ] [EOL] hydrology . install_cell_connections ( cell , ground [ [string] ] ) [EOL] [EOL] [EOL] def test_build_cell ( cmf_data , project_with_cells , retention_curve ) : [EOL] ( ground_list , mesh_paths , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = cmf_data [EOL] [EOL] project , mesh_info = project_with_cells [EOL] for ground in ground_list : [EOL] for cell_index in mesh_info [ ground [ [string] ] ] : [EOL] hydrology . build_cell ( cell_index , project , ground , retention_curve ) [EOL] [EOL] cell = project . cells [ cell_index ] [EOL] [EOL] assert cell [EOL] if len ( cell . layers ) > [number] : [EOL] assert len ( cell . layers ) == len ( ground [ [string] ] [ [string] ] ) [EOL] assert cell . evaporation [EOL] assert cell . transpiration [EOL] assert cell . vegetation [EOL] assert pytest . approx ( cell . saturated_depth == ground [ [string] ] [ [string] ] ) [EOL] [EOL] assert True [EOL] [EOL] [EOL] def test_install_flux_connections ( cmf_data , project_with_cells ) : [EOL] ( ground_list , mesh_path , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = cmf_data [EOL] project , mesh_info = project_with_cells [EOL] [EOL] for ground in ground_list : [EOL] hydrology . install_flux_connections ( project , ground ) [EOL] [EOL] [comment] [EOL] assert project [EOL] [EOL] [EOL] def test_configure_cells ( cmf_data , project_with_cells ) : [EOL] ( ground_list , mesh_path , weather_dict , trees_dict , outputs , solver_settings , boundary_dict ) = cmf_data [EOL] project , mesh_info = project_with_cells [EOL] [EOL] for ground in ground_list : [EOL] hydrology . configure_cells ( project , ground , mesh_info [ ground [ [string] ] ] ) [EOL] [EOL] [comment] [EOL] assert project_with_cells [EOL] [EOL] [EOL] def test_add_tree_to_project ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_create_weather ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_create_boundary_conditions ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_config_outputs ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_gather_results ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_get_analysis_length ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_get_time_step ( ) : [EOL] assert True [EOL] [EOL] [EOL] def test_solve_project ( solve_ready_project , mock_solver , mock_gather_results ) : [EOL] results = hydrology . solve_project ( * solve_ready_project ) [EOL] [EOL] assert results [EOL] [EOL] [EOL] def test_save_project ( ) : [EOL] assert True [EOL] [EOL] [EOL] @ pytest . mark . skip ( [string] ) def test_run_off ( data_folder ) : [EOL] folder = os . path . join ( data_folder , [string] ) [EOL] hydrology . run_model ( folder ) [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import shutil [EOL] [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] def test_obj_to_shapefile ( ) : [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import lib_cmf as lc [EOL] import pytest [EOL] import shutil [EOL] [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder ) [EOL] [EOL] @ pytest . fixture def finished_project ( folder ) : [EOL] unpack ( folder ) [EOL] model = lc . CMFModel ( folder ) [EOL] [EOL] return model . run_model ( ) [EOL] [EOL] [EOL] def test_constant ( ) : [EOL] folder_path = [string] [EOL] p = finished_project ( folder_path ) [EOL] [EOL] [comment] [EOL] temp = [ t for t in p . meteo_stations [ [number] ] . T ] [EOL] relhum = [ rh for rh in p . meteo_stations [ [number] ] . rHmean ] [EOL] wind = [ ws for ws in p . meteo_stations [ [number] ] . Windspeed ] [EOL] sun = [ ss for ss in p . meteo_stations [ [number] ] . Sunshine ] [EOL] rad = [ gr for gr in p . meteo_stations [ [number] ] . Rs ] [EOL] rain = [ r for r in p . rainfall_stations [ [number] ] ] [EOL] ground = [ gt for gt in p . meteo_stations [ [number] ] . Tground ] [EOL] [EOL] [comment] [EOL] file_temp = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_relhum = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_wind = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_sun = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_rad = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_rain = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] file_ground = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] assert temp == file_temp [EOL] assert relhum == file_relhum [EOL] assert wind == file_wind [EOL] assert sun == file_sun [EOL] assert rad == file_rad [EOL] assert rain == file_rain [EOL] assert ground == file_ground	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import progressbar [EOL] import time [EOL] import datetime [EOL] [EOL] [EOL] def format_custom_text ( ) : [EOL] format_custom_text = progressbar . FormatCustomText ( [string] , dict ( spam = [number] , eggs = [number] , ) , ) [EOL] [EOL] bar = progressbar . ProgressBar ( widgets = [ format_custom_text , [string] , progressbar . Percentage ( ) , ] ) [EOL] for i in bar ( range ( [number] ) ) : [EOL] format_custom_text . update_mapping ( eggs = i * [number] ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def format_label ( ) : [EOL] widgets = [ progressbar . FormatLabel ( [string] ) ] [EOL] bar = progressbar . ProgressBar ( widgets = widgets ) [EOL] for i in bar ( ( i for i in range ( [number] ) ) ) : [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def print_output ( ) : [EOL] for i in progressbar . progressbar ( range ( [number] ) , redirect_stdout = True ) : [EOL] print ( [string] , i ) [EOL] time . sleep ( [number] ) [EOL] [EOL] def cmf_bar ( ) : [EOL] [EOL] widgets = [ [string] , progressbar . Timer ( ) , [string] , progressbar . Bar ( ) , [string] , progressbar . AdaptiveETA ( ) , [string] ] [EOL] bar = progressbar . ProgressBar ( max_value = [number] , widgets = widgets ) [EOL] for i in range ( [number] ) : [EOL] time . sleep ( [number] ) [EOL] bar . update ( ) [EOL] [EOL] [EOL] [comment] [EOL] cmf_bar ( ) [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import lib_cmf as lc [EOL] from matplotlib import pyplot as plt [EOL] import numpy as np [EOL] import shutil [EOL] [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder ) [EOL] [EOL] [EOL] def get_ylabel ( weather_type ) : [EOL] if str ( weather_type ) == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] elif weather_type == [string] : [EOL] return [string] [EOL] [EOL] [EOL] def plot_weather ( weather , weather_type , test_type ) : [EOL] x = np . linspace ( [number] , len ( weather ) , len ( weather ) ) [EOL] [EOL] unit = get_ylabel ( weather_type ) [EOL] plt . figure ( weather_type ) [EOL] plt . plot ( x , weather ) [EOL] plt . title ( test_type + [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( unit ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] def plot_weather_double ( weather_double , weather_type , test_type ) : [EOL] x = np . linspace ( [number] , len ( weather_double [ [number] ] ) , len ( weather_double [ [number] ] ) ) [EOL] [EOL] unit = get_ylabel ( weather_type ) [EOL] plt . figure ( weather_type ) [EOL] plt . plot ( x , weather_double [ [number] ] ) [EOL] plt . plot ( x , weather_double [ [number] ] ) [EOL] plt . title ( test_type + [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( unit ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] def test_constant ( ) : [EOL] folder_path = [string] [EOL] [EOL] unpack ( folder_path ) [EOL] model = lc . CMFModel ( folder_path ) [EOL] p = model . run_model ( ) [EOL] temp = [ t for t in p . meteo_stations [ [number] ] . T ] [EOL] relhum = [ rh for rh in p . meteo_stations [ [number] ] . rHmean ] [EOL] wind = [ ws for ws in p . meteo_stations [ [number] ] . Windspeed ] [EOL] sun = [ ss for ss in p . meteo_stations [ [number] ] . Sunshine ] [EOL] rad = [ gr for gr in p . meteo_stations [ [number] ] . Rs ] [EOL] rain = [ r for r in p . rainfall_stations [ [number] ] . data ] [EOL] ground = [ gt for gt in p . meteo_stations [ [number] ] . Tground ] [EOL] [EOL] plot_weather ( temp , [string] , [string] ) [EOL] plot_weather ( relhum , [string] , [string] ) [EOL] plot_weather ( wind , [string] , [string] ) [EOL] plot_weather ( sun , [string] , [string] ) [EOL] plot_weather ( rad , [string] , [string] ) [EOL] plot_weather ( rain , [string] , [string] ) [EOL] plot_weather ( ground , [string] , [string] ) [EOL] [EOL] [EOL] def test_sinus ( ) : [EOL] folder_path = [string] [EOL] [EOL] unpack ( folder_path ) [EOL] model = lc . CMFModel ( folder_path ) [EOL] p = model . run_model ( ) [EOL] temp = [ t for t in p . meteo_stations [ [number] ] . T ] [EOL] relhum = [ rh for rh in p . meteo_stations [ [number] ] . rHmean ] [EOL] wind = [ ws for ws in p . meteo_stations [ [number] ] . Windspeed ] [EOL] sun = [ ss for ss in p . meteo_stations [ [number] ] . Sunshine ] [EOL] rad = [ gr for gr in p . meteo_stations [ [number] ] . Rs ] [EOL] rain = [ r for r in p . rainfall_stations [ [number] ] . data ] [EOL] ground = [ gt for gt in p . meteo_stations [ [number] ] . Tground ] [EOL] [EOL] plot_weather ( temp , [string] , [string] ) [EOL] plot_weather ( relhum , [string] , [string] ) [EOL] plot_weather ( wind , [string] , [string] ) [EOL] plot_weather ( sun , [string] , [string] ) [EOL] plot_weather ( rad , [string] , [string] ) [EOL] plot_weather ( rain , [string] , [string] ) [EOL] plot_weather ( ground , [string] , [string] ) [EOL] [EOL] [EOL] def test_double ( ) : [EOL] folder_path = [string] [EOL] [EOL] unpack ( folder_path ) [EOL] model = lc . CMFModel ( folder_path ) [EOL] p = model . run_model ( ) [EOL] temp = [ [ t for t in p . meteo_stations [ [number] ] . T ] , [ t for t in p . meteo_stations [ [number] ] . T ] ] [EOL] relhum = [ [ rh for rh in p . meteo_stations [ [number] ] . rHmean ] , [ rh for rh in p . meteo_stations [ [number] ] . rHmean ] ] [EOL] wind = [ [ ws for ws in p . meteo_stations [ [number] ] . Windspeed ] , [ ws for ws in p . meteo_stations [ [number] ] . Windspeed ] ] [EOL] sun = [ [ ss for ss in p . meteo_stations [ [number] ] . Sunshine ] , [ ss for ss in p . meteo_stations [ [number] ] . Sunshine ] ] [EOL] rad = [ [ gr for gr in p . meteo_stations [ [number] ] . Rs ] , [ gr for gr in p . meteo_stations [ [number] ] . Rs ] ] [EOL] rain = [ [ r for r in ( p . rainfall_stations [ [number] ] . data ) ] , [ r for r in ( p . rainfall_stations [ [number] ] . data ) ] ] [EOL] ground = [ [ gt for gt in p . meteo_stations [ [number] ] . Tground ] , [ gt for gt in p . meteo_stations [ [number] ] . Tground ] ] [EOL] [EOL] plot_weather_double ( temp , [string] , [string] ) [EOL] plot_weather_double ( relhum , [string] , [string] ) [EOL] plot_weather_double ( wind , [string] , [string] ) [EOL] plot_weather_double ( sun , [string] , [string] ) [EOL] plot_weather_double ( rad , [string] , [string] ) [EOL] plot_weather_double ( rain , [string] , [string] ) [EOL] plot_weather_double ( ground , [string] , [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] test_double ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import air as air [EOL] import shutil [EOL] [EOL] [EOL] [EOL] folder_path = [string] [EOL] [EOL] if __name__ == [string] : [EOL] air . new_temperature_and_relative_humidity ( folder_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import typing [EOL] import shapely [EOL] import numpy as np [EOL] import livestock . geometry as geo [EOL] [EOL] path = [string] [EOL] [EOL] shape = geo . obj_to_polygons ( path ) [EOL] point = list ( shape [ [number] ] . exterior . coords ) [EOL] [EOL] [EOL] def centroid_z ( polygon ) : [EOL] z_values = [ ] [EOL] for pt in polygon . exterior . coords : [EOL] z_values . append ( pt [ [number] ] ) [EOL] [EOL] mean_z = sum ( z_values ) / len ( z_values ) [EOL] [EOL] return mean_z [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import geometry as geo [EOL] [EOL] obj = [string] [EOL] shp = [string] [EOL] [EOL] geo . obj_to_shp ( obj , shp ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import typing [EOL] import numpy as np [EOL] from functools import wraps [EOL] import os [EOL] [EOL] [EOL] def file_as_input ( function_ ) : [EOL] [EOL] @ wraps ( function_ ) def wrapper ( * args , ** kwargs ) : [EOL] [EOL] args_ = [ ] [EOL] for arg in args : [EOL] try : [EOL] os . path . isfile ( arg ) [EOL] args_ . append ( np . loadtxt ( arg ) ) [EOL] except ValueError : [EOL] args_ . append ( arg ) [EOL] [EOL] return function_ ( * args_ , ** kwargs ) [EOL] return wrapper [EOL] [EOL] [EOL] def poly_list ( x ) : [EOL] return x ** [number] + [number] * x - [number] [EOL] [EOL] [EOL] @ file_as_input def poly_file ( x ) : [EOL] return x ** [number] + [number] * x - [number] [EOL] [EOL] [EOL] [EOL] [EOL] data_file = [string] [EOL] data_list = np . array ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] print ( poly_file ( data_list ) ) [EOL] [EOL] print ( poly_file ( data_file ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Set [EOL] import typing [EOL] import bpy [EOL] import bmesh [EOL] import json [EOL] [EOL] def clean ( ) : [EOL] for o in bpy . data . objects : [EOL] if o . type == [string] : [EOL] o . select = True [EOL] else : [EOL] o . select = False [EOL] [EOL] [comment] [EOL] bpy . ops . object . delete ( ) [EOL] [EOL] [EOL] clean ( ) [EOL] [EOL] file_obj = [string] [EOL] [EOL] bpy . ops . import_scene . obj ( filepath = file_obj , axis_forward = [string] , axis_up = [string] , ) [EOL] imported_mesh = bpy . context . selected_objects [ - [number] ] [EOL] [EOL] me = imported_mesh . data [EOL] bm = bmesh . new ( ) [EOL] [EOL] [comment] [EOL] bm . from_mesh ( me ) [EOL] [EOL] lowest_neighbour = [ ] [EOL] for face in bm . faces : [EOL] linked_faces = set ( f for v in face . verts for f in v . link_faces ) [EOL] centers = [ [ linked_face . index , tuple ( linked_face . calc_center_median ( ) ) ] for linked_face in linked_faces ] [EOL] [EOL] sorted_centers = sorted ( centers , key = lambda v : v [ [number] ] [ [number] ] ) [EOL] [EOL] if face . calc_center_median ( ) . z <= sorted_centers [ [number] ] [ [number] ] [ [number] ] : [EOL] lowest_neighbour . append ( None ) [EOL] else : [EOL] lowest_neighbour . append ( sorted_centers [ [number] ] ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def get_curve_points ( start_index , point_list ) : [EOL] [EOL] curve_points = [ ] [EOL] next_index = start_index [EOL] while True : [EOL] pt = point_list [ next_index ] [EOL] [EOL] if pt : [EOL] next_index = pt [ [number] ] [EOL] curve_points . append ( pt [ [number] ] ) [EOL] else : [EOL] return curve_points [EOL] [EOL] [EOL] curves = [ ] [EOL] for face_index in range ( len ( bm . faces ) ) : [EOL] curves . append ( get_curve_points ( face_index , lowest_neighbour ) ) [EOL] [EOL] outfile = [string] [EOL] [EOL] with open ( outfile , [string] ) as file : [EOL] json . dump ( curves , file ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import cmf [EOL] import numpy as np [EOL] from matplotlib . animation import FuncAnimation [EOL] import datetime [EOL] [comment] [EOL] from cmf . draw import hill_plot [EOL] [comment] [EOL] from matplotlib . pylab import figure , show , cm [EOL] [EOL] [EOL] def z ( x ) : [EOL] return [number] / ( [number] + np . exp ( ( x - [number] ) / [number] ) ) [EOL] [comment] [EOL] p = cmf . project ( ) [EOL] [EOL] for i in range ( [number] ) : [EOL] x = i * [number] [EOL] [comment] [EOL] c = p . NewCell ( x , [number] , z ( x ) , [number] , True ) [EOL] [EOL] for c_upper , c_lower in zip ( p [ : - [number] ] , p [ [number] : ] ) : [EOL] c_upper . topology . AddNeighbor ( c_lower , [number] ) [EOL] [EOL] [comment] [EOL] for c in p : [EOL] [comment] [EOL] for d in [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] : [EOL] rc = cmf . VanGenuchtenMualem ( Ksat = [number] * np . exp ( - d ) , alpha = [number] , n = [number] , phi = [number] ) [EOL] rc . w0 = [number] [EOL] c . add_layer ( d , rc ) [EOL] [comment] [EOL] c . saturated_depth = [number] [EOL] [comment] [EOL] c . install_connection ( cmf . Richards ) [EOL] c . install_connection ( cmf . GreenAmptInfiltration ) [EOL] [comment] [EOL] [EOL] cmf . connect_cells_with_flux ( p , cmf . Darcy ) [EOL] cmf . connect_cells_with_flux ( p , cmf . KinematicSurfaceRunoff ) [EOL] [EOL] for c in p : [EOL] c . set_rainfall ( [number] ) [EOL] [EOL] outlet = p . NewOutlet ( [string] , [number] , [number] , [number] ) [EOL] for l in p [ - [number] ] . layers : [EOL] [comment] [EOL] [comment] [EOL] cmf . Darcy ( l , outlet , FlowWidth = [number] ) [EOL] cmf . KinematicSurfaceRunoff ( p [ - [number] ] . surfacewater , outlet , [number] ) [EOL] [EOL] solver = cmf . CVodeIntegrator ( p , [number] ) [EOL] solver . t = datetime . datetime ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] [EOL] [comment] [EOL] fig = figure ( figsize = ( [number] , [number] ) ) [EOL] [comment] [EOL] ax = fig . add_subplot ( [number] , axisbg = [string] ) [EOL] [comment] [EOL] image = hill_plot ( p , solver . t ) [EOL] [comment] [EOL] image . scale = [number] [EOL] [comment] [EOL] image . q_sub . set_facecolor ( [string] ) [EOL] [EOL] def run ( frame ) : [EOL] [comment] [EOL] t = solver ( cmf . day ) [EOL] [comment] [EOL] image ( t ) [EOL] [EOL] [EOL] animation = FuncAnimation ( fig , run , repeat = False , frames = [number] ) [EOL] show ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import cmf [EOL] from numpy import transpose [EOL] from matplotlib import pyplot as plt [EOL] [EOL] p = cmf . project ( ) [EOL] [comment] [EOL] c = p . NewCell ( [number] , [number] , [number] , [number] , True ) [EOL] [comment] [EOL] c . surfacewater . puddledepth = [number] [EOL] [comment] [EOL] c . add_layer ( [number] , cmf . VanGenuchtenMualem ( Ksat = [number] ) ) [EOL] c . install_connection ( cmf . GreenAmptInfiltration ) [EOL] [comment] [EOL] outlet = p . NewOutlet ( [string] , [number] , [number] , [number] ) [EOL] [comment] [EOL] con = cmf . KinematicSurfaceRunoff ( c . surfacewater , outlet , flowwidth = [number] ) [EOL] [comment] [EOL] c . set_rainfall ( [number] ) [EOL] [comment] [EOL] solver = cmf . CVodeIntegrator ( p , [number] ) [EOL] [EOL] [comment] [EOL] Vsoil , Vsurf , qsurf , qinf = transpose ( [ ( c . layers [ [number] ] . volume , c . surfacewater . volume , outlet ( t ) , c . layers [ [number] ] ( t ) ) for t in solver . run ( cmf . Time ( [number] , [number] , [number] ) , cmf . Time ( [number] , [number] , [number] ) , cmf . min ) ] ) [EOL] [comment] [EOL] ax1 = plt . subplot ( [number] ) [EOL] plt . plot ( Vsurf , label = [string] ) [EOL] plt . plot ( Vsoil , label = [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( loc = [number] ) [EOL] plt . subplot ( [number] , sharex = ax1 ) [EOL] plt . plot ( qsurf , label = [string] ) [EOL] plt . plot ( qinf , label = [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . legend ( loc = [number] ) [EOL] plt . show ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import cmf [EOL] from numpy import transpose [EOL] from matplotlib import pyplot as plt [EOL] import datetime [EOL] [EOL] p = cmf . project ( ) [EOL] [comment] [EOL] c = p . NewCell ( [number] , [number] , [number] , [number] , True ) [EOL] [comment] [EOL] c . surfacewater . puddledepth = [number] [EOL] [comment] [EOL] c . add_layer ( [number] , cmf . VanGenuchtenMualem ( Ksat = [number] ) ) [EOL] c . install_connection ( cmf . GreenAmptInfiltration ) [EOL] [EOL] [comment] [EOL] In = cmf . NeumannBoundary . create ( c . surfacewater ) [EOL] [comment] [EOL] In . flux = [number] [EOL] [EOL] [EOL] [comment] [EOL] solver = cmf . CVodeIntegrator ( p , [number] ) [EOL] [EOL] [comment] [EOL] Vsoil , Vsurf , = transpose ( [ ( c . layers [ [number] ] . volume , c . surfacewater . volume ) for t in solver . run ( cmf . Time ( [number] , [number] , [number] ) , cmf . Time ( [number] , [number] , [number] ) , cmf . min ) ] ) [EOL] [EOL] [comment] [EOL] plt . figure ( ) [EOL] plt . plot ( Vsurf , label = [string] ) [EOL] plt . plot ( Vsoil , label = [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( loc = [number] ) [EOL] plt . show ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import win_cmf as wc [EOL] [EOL] wc . surface_flux_results ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0
import win_cmf as wc [EOL] [EOL] wc . layer_results ( [string] , [string] , [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import hydrology as hy [EOL] import cmf [EOL] import shutil [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder ) [EOL] [EOL] folder_path = [string] [EOL] unpack ( folder_path ) [EOL] [EOL] model = hy . CMFModel ( folder_path ) [EOL] case = model . run_model ( ) [EOL] [EOL] cmf . describe ( case , out = open ( folder_path + [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import cmf [EOL] from cmf . geos_shapereader import Shapefile as cmf_shape [EOL] [EOL] p = cmf . project ( ) [EOL] r_curve = cmf . VanGenuchtenMualem ( ) [EOL] [EOL] [comment] [EOL] path = [string] [EOL] polygons = cmf_shape ( path ) [EOL] [EOL] [comment] [EOL] cells = p . cells_from_polygons ( polygons ) [EOL] [EOL] for c in p . cells : [EOL] [comment] [EOL] for i in range ( [number] ) : [EOL] c . AddLayer ( ( i + [number] ) * [number] , r_curve ) [EOL] cmf . Richards . use_for_cell ( c ) [EOL] c . surfacewater_as_storage ( ) [EOL] [comment] [EOL] cmf . connect_cells_with_flux ( p , cmf . Richards_lateral ) [EOL] [comment] [EOL] cmf . connect_cells_with_flux ( p , cmf . Manning_Kinematic )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import win_cmf as wc [EOL] [EOL] wc . cell_results ( [string] , [string] , [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import multiprocessing [EOL] import multiprocessing [EOL] import numpy as np [EOL] [EOL] def doubler ( number ) : [EOL] return number [ [number] ] * [number] [EOL] [EOL] [EOL] numbers = [ [ [number] , [number] ] , [ [number] , [number] ] , [ [number] , ] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] pool = multiprocessing . Pool ( processes = [number] ) [EOL] result = pool . map ( doubler , numbers ) [EOL] print ( result )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 $typing.List[typing.Any]$ 0
from typing import Any [EOL] import typing [EOL] import geopandas [EOL] [EOL] path = [string] [EOL] [EOL] mesh = geopandas . read_file ( path ) [EOL] [EOL] print ( mesh )	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import livestock . air as la [EOL] [comment] [EOL] if __name__ == [string] : [EOL] la . new_temperature_and_relative_humidity ( [string] ) [EOL] [comment] [EOL] print ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] import io [EOL] import sys [EOL] sys . path . insert ( [number] , [string] ) [EOL] from livestock . hydrology import run_model [EOL] [comment] [EOL] run_model ( [string] ) [EOL] [comment] [EOL] print ( [string] ) [EOL] file_obj = open ( [string] , [string] ) [EOL] file_obj . close ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import logging [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import logging [EOL] import os [EOL] import shutil [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def log_path ( ) : [EOL] livestock_path = [string] [EOL] [EOL] log_folder = os . path . join ( livestock_path , [string] ) [EOL] [EOL] if not os . path . exists ( log_folder ) : [EOL] os . mkdir ( log_folder ) [EOL] [EOL] return log_folder [EOL] [EOL] [EOL] def livestock_logger ( ) : [EOL] [EOL] if os . listdir ( log_path ( ) ) : [EOL] shutil . rmtree ( log_path ( ) ) [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] log . setLevel ( logging . DEBUG ) [EOL] [EOL] [comment] [EOL] formatter = logging . Formatter ( [string] [string] ) [EOL] [EOL] [comment] [EOL] stream = logging . StreamHandler ( ) [EOL] stream . setLevel ( logging . INFO ) [EOL] stream_formatter = logging . Formatter ( [string] ) [EOL] stream . setFormatter ( stream_formatter ) [EOL] [EOL] [comment] [EOL] file_info = logging . FileHandler ( os . path . join ( log_path ( ) , [string] ) ) [EOL] file_info . setLevel ( logging . INFO ) [EOL] file_info . setFormatter ( formatter ) [EOL] [EOL] file_debug = logging . FileHandler ( os . path . join ( log_path ( ) , [string] ) ) [EOL] file_debug . setLevel ( logging . DEBUG ) [EOL] file_debug . setFormatter ( formatter ) [EOL] [EOL] log . addHandler ( stream ) [EOL] log . addHandler ( file_debug ) [EOL] log . addHandler ( file_info ) [EOL] [EOL] return log [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import shutil [EOL] [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import air as air [EOL] import shutil [EOL] [EOL] [EOL] [EOL] folder_path = [string] [EOL] [EOL] if __name__ == [string] : [EOL] air . new_temperature_and_relative_humidity ( folder_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Any [EOL] import typing [EOL] import hydrology as hy [EOL] from matplotlib import pyplot as plt [EOL] import numpy as np [EOL] import tests . archive . helper_functions as helper [EOL] import xmltodict [EOL] import xml . etree . ElementTree as ET [EOL] import cmf [EOL] [EOL] [EOL] [EOL] def load_results ( folder ) : [EOL] result_file = folder + [string] [EOL] [EOL] [comment] [EOL] result_tree = ET . tostring ( ET . parse ( result_file ) . getroot ( ) ) [EOL] result = xmltodict . parse ( result_tree ) [EOL] [EOL] cell_0 = eval ( result [ [string] ] [ [string] ] [ [string] ] ) [EOL] layer_0 = eval ( result [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL] cell_1 = eval ( result [ [string] ] [ [string] ] [ [string] ] ) [EOL] layer_1 = eval ( result [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] return cell_0 , cell_1 , layer_0 , layer_1 [EOL] [EOL] def plot_outlet ( folder ) : [EOL] cell0_vol , cell1_vol , layer0_vol , layer1_vol = load_results ( folder ) [EOL] [EOL] x = np . linspace ( [number] , len ( cell0_vol ) , len ( cell0_vol ) ) [EOL] [EOL] plt . figure ( ) [EOL] plt . title ( [string] ) [EOL] plt . plot ( x , cell0_vol , label = [string] ) [EOL] plt . plot ( x , cell1_vol , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] plt . figure ( ) [EOL] plt . title ( [string] ) [EOL] plt . plot ( x , layer0_vol , label = [string] ) [EOL] plt . plot ( x , layer1_vol , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] def test_inlet ( ) : [EOL] [EOL] folder_path = [string] [EOL] helper . unpack ( folder_path ) [EOL] [EOL] model = hy . CMFModel ( folder_path ) [EOL] p = model . run_model ( ) [EOL] [EOL] print ( cmf . describe ( p ) ) [EOL] [EOL] plot_outlet ( folder_path ) [EOL] [EOL] [EOL] test_inlet ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import lib_cmf as lc [EOL] import cmf [EOL] from matplotlib import pyplot as plt [EOL] import numpy as np [EOL] import shutil [EOL] import xmltodict [EOL] import xml . etree . ElementTree as ET [EOL] [EOL] [EOL] def unpack ( folder ) : [EOL] test_files = folder + [string] [EOL] shutil . unpack_archive ( test_files , folder ) [EOL] [EOL] [EOL] def load_results ( folder ) : [EOL] result_file = folder + [string] [EOL] [EOL] [comment] [EOL] result_tree = ET . tostring ( ET . parse ( result_file ) . getroot ( ) ) [EOL] result = xmltodict . parse ( result_tree ) [EOL] [EOL] cell_0 = eval ( result [ [string] ] [ [string] ] [ [string] ] ) [EOL] layer_0 = eval ( result [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL] cell_1 = eval ( result [ [string] ] [ [string] ] [ [string] ] ) [EOL] layer_1 = eval ( result [ [string] ] [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] return cell_0 , cell_1 , layer_0 , layer_1 [EOL] [EOL] def plot_inlet ( folder ) : [EOL] cell0_vol , cell1_vol , layer0_vol , layer1_vol = load_results ( folder ) [EOL] [EOL] x = np . linspace ( [number] , len ( cell0_vol ) , len ( cell0_vol ) ) [EOL] [EOL] plt . figure ( ) [EOL] plt . title ( [string] ) [EOL] plt . plot ( x , cell0_vol , label = [string] ) [EOL] plt . plot ( x , cell1_vol , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] plt . figure ( ) [EOL] plt . title ( [string] ) [EOL] plt . plot ( x , layer0_vol , label = [string] ) [EOL] plt . plot ( x , layer1_vol , label = [string] ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . legend ( ) [EOL] plt . show ( ) [EOL] [EOL] [EOL] def test_inlet ( ) : [EOL] [EOL] folder_path = [string] [EOL] unpack ( folder_path ) [EOL] [EOL] model = lc . CMFModel ( folder_path ) [EOL] p = model . run_model ( ) [EOL] [EOL] [comment] [EOL] [EOL] plot_inlet ( folder_path ) [EOL] [EOL] [EOL] test_inlet ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import hydrology as hy [EOL] import cmf [EOL] import tests . archive . helper_functions as helper [EOL] [EOL] [EOL] folder_path = [string] [EOL] helper . unpack ( folder_path ) [EOL] [EOL] model = hy . CMFModel ( folder_path ) [EOL] case = model . run_model ( ) [EOL] [EOL] cmf . describe ( case , out = open ( folder_path + [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import io [EOL] import typing [EOL] import builtins [EOL] import paramiko [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import os [EOL] import paramiko [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def check_for_remote_folder ( sftp_connect , folder_to_check , check_for ) : [EOL] [docstring] [EOL] [EOL] dir_contains = sftp_connect . listdir ( folder_to_check ) [EOL] [EOL] found = False [EOL] [EOL] for name in dir_contains : [EOL] if name == check_for : [EOL] found = True [EOL] break [EOL] else : [EOL] pass [EOL] [EOL] if found : [EOL] return True [EOL] else : [EOL] sftp_connect . mkdir ( folder_to_check + [string] + check_for ) [EOL] return True [EOL] [EOL] [EOL] def ssh_connection ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] local_folder = [string] [EOL] in_data = [string] [EOL] [EOL] file_obj = open ( local_folder + in_data , [string] ) [EOL] data = file_obj . readlines ( ) [EOL] file_obj . close ( ) [EOL] [EOL] [comment] [EOL] ip = data [ [number] ] [ : - [number] ] [EOL] port = int ( data [ [number] ] [ : - [number] ] ) [EOL] user = data [ [number] ] [ : - [number] ] [EOL] pw = data [ [number] ] [ : - [number] ] [EOL] trans = data [ [number] ] [ : - [number] ] . split ( [string] ) [EOL] run = data [ [number] ] [ : - [number] ] [EOL] ret = data [ [number] ] . split ( [string] ) [EOL] [EOL] remote_folder = [string] + user + [string] [EOL] [EOL] [comment] [EOL] ssh = paramiko . SSHClient ( ) [EOL] ssh . set_missing_host_key_policy ( paramiko . AutoAddPolicy ( ) ) [EOL] [EOL] ssh . connect ( ip , port = port , username = user , password = pw ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] sftp = ssh . open_sftp ( ) [EOL] check_for_remote_folder ( sftp , [string] + user + [string] , [string] ) [EOL] [EOL] for f in trans : [EOL] sftp . put ( local_folder + [string] + f , remote_folder + [string] + f ) [EOL] sftp . put ( local_folder + [string] , remote_folder + [string] ) [EOL] [EOL] channel = ssh . invoke_shell ( ) [EOL] [EOL] channel_data = [string] [EOL] [EOL] com_send = False [EOL] folder_send = False [EOL] outfile = False [EOL] [EOL] while True : [EOL] [comment] [EOL] if channel . recv_ready ( ) : [EOL] channel_bytes = channel . recv ( [number] ) [EOL] channel_data += channel_bytes . decode ( [string] ) [EOL] print ( channel_data ) [EOL] [EOL] else : [EOL] pass [EOL] [EOL] [comment] [EOL] if not folder_send : [EOL] sftp . chdir ( remote_folder ) [EOL] channel . send ( [string] + remote_folder + [string] ) [EOL] print ( [string] ) [EOL] folder_send = True [EOL] [EOL] elif folder_send and not com_send : [EOL] channel . send ( [string] + [string] ) [EOL] channel . send ( [string] + run + [string] ) [EOL] print ( [string] ) [EOL] com_send = True [EOL] [EOL] else : [EOL] pass [EOL] [EOL] [comment] [EOL] try : [EOL] outfile = sftp . file ( remote_folder + [string] ) [EOL] except Exception : [EOL] pass [EOL] [EOL] if outfile : [EOL] print ( [string] ) [EOL] sftp . get ( remote_folder + [string] , local_folder + [string] ) [EOL] sftp . remove ( [string] ) [EOL] [EOL] [comment] [EOL] if os . path . isfile ( local_folder + [string] ) : [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] for f in ret : [EOL] print ( f ) [EOL] sftp . get ( remote_folder + [string] + f , local_folder + [string] + f ) [EOL] sftp . remove ( f ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] for f in sftp . listdir ( ) : [EOL] print ( f ) [EOL] sftp . remove ( f ) [EOL] [EOL] print ( [string] ) [EOL] break [EOL] [EOL] else : [EOL] pass [EOL] [EOL] [comment] [EOL] print ( [string] ) [EOL] sftp . close ( ) [EOL] ssh . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
__author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] try : [EOL] import bpy [EOL] except ModuleNotFoundError : [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def clean ( ) : [EOL] for o in bpy . data . objects : [EOL] if o . type == [string] : [EOL] o . select = True [EOL] else : [EOL] o . select = False [EOL] [EOL] [comment] [EOL] bpy . ops . object . delete ( ) [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import io [EOL] import typing [EOL] import subprocess [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def run_cfd ( files_path ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] zip_file = files_path + [string] [EOL] file_obj = open ( files_path + [string] , [string] ) [EOL] lines = file_obj . readlines ( ) [EOL] file_obj . close ( ) [EOL] os . remove ( files_path + [string] ) [EOL] [EOL] commands = lines [ [number] ] [ : - [number] ] . split ( [string] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] shutil . unpack_archive ( zip_file , files_path ) [EOL] os . remove ( zip_file ) [EOL] [EOL] [comment] [EOL] for i in range ( [number] , len ( commands ) ) : [EOL] bash_command = str ( commands [ i ] ) [EOL] thread = subprocess . Popen ( bash_command ) [EOL] thread . wait ( ) [EOL] thread . kill ( ) [EOL] [EOL] [comment] [EOL] shutil . make_archive ( files_path + [string] , [string] , files_path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import threading [EOL] import io [EOL] import queue [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] __version__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import threading [EOL] import queue [EOL] import pymesh as pm [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] import livestock_linux . geometry as ls_geo [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def drain_mesh_paths ( files_path ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] mesh_path = files_path + [string] [EOL] cpus = open ( files_path + [string] , [string] ) . readline ( ) [EOL] [EOL] [comment] [EOL] mesh = pm . load_mesh ( mesh_path ) [EOL] mesh . enable_connectivity ( ) [EOL] [EOL] [comment] [EOL] drain_points = [ ] [EOL] drain_faces = [ ] [EOL] [EOL] [comment] [EOL] mesh . add_attribute ( [string] ) [EOL] mesh . add_attribute ( [string] ) [EOL] start_pts = mesh . get_attribute ( [string] ) [EOL] center_z = [ ] [EOL] face_index = mesh . get_attribute ( [string] ) [EOL] faces = mesh . faces [EOL] vertices = mesh . vertices [EOL] face_destination = [ ] [EOL] ray_points = [ ] [EOL] [EOL] [comment] [EOL] start_points = [ ] [EOL] i = [number] [EOL] while i < len ( start_pts ) : [EOL] for j in range ( [number] , len ( face_index ) ) : [EOL] start_points . append ( [ face_index [ j ] , np . array ( [ start_pts [ i ] , start_pts [ i + [number] ] , start_pts [ i + [number] ] ] ) ] ) [EOL] center_z . append ( start_pts [ i + [number] ] ) [EOL] i += [number] [EOL] [EOL] [comment] [EOL] def face_vertices ( face_index_ ) : [EOL] face = faces [ int ( face_index_ ) ] [EOL] v0 = vertices [ face [ [number] ] ] [EOL] v1 = vertices [ face [ [number] ] ] [EOL] v2 = vertices [ face [ [number] ] ] [EOL] return v0 , v1 , v2 [EOL] [EOL] def over_edge ( point ) : [EOL] [docstring] [EOL] [EOL] for k in range ( [number] , len ( face_index ) ) : [EOL] if center_z [ k ] >= point [ [number] ] : [EOL] pass [EOL] [EOL] elif center_z [ k ] <= point [ [number] ] : [EOL] [comment] [EOL] [EOL] for j_ in range ( [number] , len ( ray_points ) ) : [EOL] if np . allclose ( point , ray_points [ j_ ] ) : [EOL] return face_destination [ j_ ] [EOL] [EOL] [comment] [EOL] v = face_vertices ( k ) [EOL] intersect = ls_geo . ray_triangle_intersection ( point , np . array ( [ [number] , [number] , - [number] ] ) , v ) [EOL] [EOL] if intersect [ [number] ] : [EOL] ray_points . append ( point ) [EOL] face_destination . append ( k ) [EOL] return k [EOL] [EOL] else : [EOL] pass [EOL] [EOL] else : [EOL] print ( [string] ) [EOL] print ( [string] , center_z [ k ] ) [EOL] print ( [string] , point ) [EOL] return None [EOL] [EOL] [comment] [EOL] def drain_path ( ) : [EOL] [EOL] while [number] : [EOL] [comment] [EOL] job = q . get ( ) [EOL] index = job [ [number] ] [EOL] pt = job [ [number] ] [EOL] [EOL] particles = [ ] [EOL] particles . append ( pt ) [EOL] face_indices = [ ] [EOL] face_indices . append ( int ( index ) ) [EOL] run = True [EOL] [comment] [EOL] [comment] [EOL] [EOL] while run : [EOL] [comment] [EOL] adjacent_faces = mesh . get_face_adjacent_faces ( int ( index ) ) [EOL] [EOL] [comment] [EOL] z = None [EOL] [EOL] for ad in adjacent_faces : [EOL] if not z : [EOL] z = center_z [ ad ] [EOL] i = ad [EOL] [EOL] elif z > center_z [ ad ] : [EOL] z = center_z [ ad ] [EOL] i = ad [EOL] [EOL] if z > pt [ [number] ] : [EOL] v0 , v1 , v2 = face_vertices ( index ) [EOL] pt = ls_geo . lowest_face_vertex ( v0 , v1 , v2 ) [EOL] [EOL] if len ( adjacent_faces ) < [number] : [EOL] over = over_edge ( pt ) [EOL] [EOL] if over : [EOL] particles . append ( pt ) [EOL] index = over [EOL] pt = start_points [ index ] [ [number] ] [EOL] [EOL] else : [EOL] run = False [EOL] [EOL] else : [EOL] run = False [EOL] [EOL] else : [EOL] index = start_points [ i ] [ [number] ] [EOL] pt = start_points [ i ] [ [number] ] [EOL] [EOL] particles . append ( pt ) [EOL] face_indices . append ( int ( index ) ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] drain_points . append ( particles ) [EOL] drain_faces . append ( face_indices ) [EOL] q . task_done ( ) [EOL] [EOL] [comment] [EOL] q = queue . Queue ( ) [EOL] [EOL] for i in range ( int ( cpus ) ) : [EOL] t = threading . Thread ( target = drain_path ) [EOL] t . setDaemon ( True ) [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] for pts in start_points : [EOL] q . put ( pts ) [EOL] [EOL] [comment] [EOL] q . join ( ) [EOL] [EOL] [comment] [EOL] pt_file = open ( [string] , [string] ) [EOL] face_file = open ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] for particles in drain_points : [EOL] for pt in particles : [EOL] pt_file . write ( str ( pt [ [number] ] ) + [string] + str ( pt [ [number] ] ) + [string] + str ( pt [ [number] ] ) + [string] ) [EOL] pt_file . write ( [string] ) [EOL] [EOL] [comment] [EOL] for curves in drain_faces : [EOL] for index in curves : [EOL] face_file . write ( str ( index ) + [string] ) [EOL] face_file . write ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] pt_file . close ( ) [EOL] face_file . close ( ) [EOL] pm . save_mesh ( [string] , mesh ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def drain_pools ( path ) : [EOL] import pymesh as pm [EOL] from numpy import array , allclose [EOL] from numpy import sum as npsum [EOL] from scipy . optimize import newton [EOL] [EOL] [comment] [EOL] meshFile = path + [string] [EOL] endPtsFile = path + [string] [EOL] volPtsFile = path + [string] [EOL] [EOL] [comment] [EOL] mesh = pm . load_mesh ( meshFile ) [EOL] mesh . enable_connectivity ( ) [EOL] mesh . add_attribute ( [string] ) [EOL] mesh . add_attribute ( [string] ) [EOL] mesh . add_attribute ( [string] ) [EOL] cenPts = mesh . get_attribute ( [string] ) [EOL] faceIndex = mesh . get_attribute ( [string] ) [EOL] faceArea = mesh . get_attribute ( [string] ) [EOL] faceVert = mesh . faces [EOL] vertices = mesh . vertices [EOL] [comment] [EOL] boolWarning = None [EOL] poolWarning = None [EOL] [EOL] [comment] [EOL] faceCen = [ ] [EOL] i = [number] [EOL] while i < len ( cenPts ) : [EOL] faceCen . append ( array ( [ float ( cenPts [ i ] ) , float ( cenPts [ i + [number] ] ) , float ( cenPts [ i + [number] ] ) ] ) ) [EOL] i += [number] [EOL] [EOL] [comment] [EOL] ptsLine = open ( endPtsFile , [string] ) . readlines ( ) [EOL] endPts = [ ] [EOL] for l in ptsLine : [EOL] l = l [ : - [number] ] [EOL] l = l . split ( [string] ) [EOL] endPts . append ( array ( [ float ( l [ [number] ] ) , float ( l [ [number] ] ) , float ( l [ [number] ] ) ] ) ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] volLine = open ( volPtsFile , [string] ) . readlines ( ) [EOL] vol = [ ] [EOL] for v in volLine : [EOL] v = v [ : - [number] ] [EOL] vol . append ( float ( v ) ) [EOL] [EOL] pts = [ ] [EOL] vols = [ ] [EOL] fI = [ ] [EOL] [EOL] for i , pt in enumerate ( endPts ) : [EOL] [EOL] [comment] [EOL] if i == [number] : [EOL] pts . append ( pt ) [EOL] vols . append ( vol [ i ] ) [EOL] [EOL] [comment] [EOL] for index , cen in enumerate ( faceCen ) : [EOL] if allclose ( cen , pt ) : [EOL] fI . append ( index ) [EOL] break [EOL] [EOL] else : [EOL] found = False [EOL] j = [number] [EOL] while j < len ( pts ) : [EOL] [comment] [EOL] if allclose ( pts [ j ] , pt ) : [EOL] vols [ j ] += vol [ i ] [EOL] j = len ( pts ) [EOL] found = True [EOL] j += [number] [EOL] [EOL] [comment] [EOL] if not found : [EOL] pts . append ( pt ) [EOL] vols . append ( vol [ i ] ) [EOL] [EOL] [comment] [EOL] for index , cen in enumerate ( faceCen ) : [EOL] if allclose ( cen , pt ) : [EOL] fI . append ( index ) [EOL] break [EOL] [EOL] [comment] [EOL] def pool ( faceIndex , point , volume ) : [EOL] found = False [EOL] [EOL] [comment] [EOL] A = faceArea [ faceIndex ] [EOL] h = volume / A [EOL] Z = point [ [number] ] + h [EOL] [EOL] [comment] [EOL] adjFace = [ faceIndex , ] [EOL] faceZ = [ point [ [number] ] , ] [EOL] faceA = [ A , ] [EOL] [EOL] [comment] [EOL] for faceIn in adjFace : [EOL] [EOL] for af in mesh . get_face_adjacent_faces ( faceIn ) : [EOL] [EOL] [comment] [EOL] fc = faceCen [ af ] [ [number] ] [EOL] [EOL] [comment] [EOL] if fc < Z : [EOL] if af not in adjFace : [EOL] [EOL] [comment] [EOL] if af in fI : [EOL] [comment] [EOL] queueIndex = fI . index ( af ) [EOL] [EOL] if queueIndex in notDoneList : [EOL] [comment] [EOL] volume += vols [ queueIndex ] [EOL] notDoneList . remove ( queueIndex ) [EOL] doneList . append ( queueIndex ) [EOL] [EOL] elif queueIndex in doneList : [EOL] [comment] [EOL] vols [ queueIndex ] += volume [EOL] notDoneList . append ( queueIndex ) [EOL] doneList . remove ( queueIndex ) [EOL] return [EOL] [EOL] else : [EOL] pass [EOL] [EOL] [comment] [EOL] faceZ . append ( fc ) [EOL] faceA . append ( faceArea [ af ] ) [EOL] adjFace . append ( int ( af ) ) [EOL] [EOL] [comment] [EOL] faZ = array ( faceZ ) [EOL] faA = array ( faceA ) [EOL] [EOL] [comment] [EOL] Z = ( npsum ( faZ * faA ) + volume ) / npsum ( faA ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] apxVert = [ ] [EOL] apxFace = [ ] [EOL] iApxVert = [number] [EOL] [EOL] for af in adjFace : [EOL] iApxVert = len ( apxVert ) [EOL] apxVert . append ( vertices [ faceVert [ af ] [ [number] ] ] ) [EOL] apxVert . append ( vertices [ faceVert [ af ] [ [number] ] ] ) [EOL] apxVert . append ( vertices [ faceVert [ af ] [ [number] ] ] ) [EOL] apxFace . append ( [ iApxVert , iApxVert + [number] , iApxVert + [number] ] ) [EOL] [EOL] [comment] [EOL] apxVert = array ( apxVert ) [EOL] apxFace = array ( apxFace ) [EOL] apxMesh = pm . form_mesh ( apxVert , apxFace ) [EOL] [EOL] [comment] [EOL] maxmin = apxMesh . bbox [EOL] x1 , y1 , z1 = maxmin [ [number] ] [EOL] x2 , y2 , z2 = maxmin [ [number] ] * [number] [comment] [EOL] x1 = x1 * [number] [comment] [EOL] y1 = y1 * [number] [comment] [EOL] [EOL] [comment] [EOL] [EOL] zMax = mesh . bbox [ [number] ] [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def createBbox ( z ) : [EOL] bVert = [ ] [EOL] bFace = [ ] [EOL] bVox = [ ] [EOL] [EOL] [comment] [EOL] bVert . append ( array ( [ x1 , y1 , z1 ] ) ) [comment] [EOL] bVert . append ( array ( [ x1 , y2 , z1 ] ) ) [comment] [EOL] bVert . append ( array ( [ x1 , y2 , z ] ) ) [comment] [EOL] bVert . append ( array ( [ x1 , y1 , z ] ) ) [comment] [EOL] [EOL] bVert . append ( array ( [ x2 , y2 , z ] ) ) [comment] [EOL] bVert . append ( array ( [ x2 , y2 , z1 ] ) ) [comment] [EOL] bVert . append ( array ( [ x2 , y1 , z1 ] ) ) [comment] [EOL] bVert . append ( array ( [ x2 , y1 , z ] ) ) [comment] [EOL] [EOL] [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] bFace . append ( [ [number] , [number] , [number] ] ) [comment] [EOL] [EOL] [comment] [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] bVox . append ( [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] bVert = array ( bVert ) [EOL] bFace = array ( bFace ) [EOL] bVox = array ( bVox ) [EOL] bMesh = pm . form_mesh ( bVert , bFace , bVox ) [EOL] [comment] [EOL] [EOL] return bMesh [EOL] [EOL] def getVolMesh ( newMesh , bottomFaces , z ) : [EOL] [EOL] [comment] [EOL] newMeshVert = newMesh . vertices [EOL] volVert = [ ] [EOL] volFace = [ ] [EOL] volVox = [ ] [EOL] [EOL] [comment] [EOL] for f in bottomFaces : [EOL] iVer = len ( volVert ) [EOL] [EOL] oldVerts = [ ] [EOL] newVerts = [ ] [EOL] for v in f : [EOL] oldVerts . append ( newMeshVert [ v ] ) [EOL] newV = array ( [ newMeshVert [ v ] [ [number] ] , newMeshVert [ v ] [ [number] ] , z ] ) [EOL] newVerts . append ( newV ) [EOL] [EOL] [comment] [EOL] volVert += oldVerts [EOL] volVert += newVerts [EOL] [EOL] [comment] [EOL] volFace . append ( [ iVer , iVer + [number] , iVer + [number] ] ) [EOL] volFace . append ( [ iVer + [number] , iVer + [number] , iVer + [number] ] ) [EOL] [EOL] [comment] [EOL] volVox . append ( [ iVer , iVer + [number] , iVer + [number] , iVer + [number] ] ) [EOL] volVox . append ( [ iVer + [number] , iVer + [number] , iVer + [number] , iVer + [number] ] ) [EOL] volVox . append ( [ iVer + [number] , iVer + [number] , iVer + [number] , iVer + [number] ] ) [EOL] [EOL] [comment] [EOL] volVert = array ( volVert ) [EOL] volFace = array ( volFace ) [EOL] volVox = array ( volVox ) [EOL] volMesh = pm . form_mesh ( volVert , volFace , volVox ) [EOL] [EOL] return volMesh [EOL] [EOL] def intersectAndBottomFaces ( bMesh , z ) : [EOL] warning = None [EOL] [EOL] [comment] [EOL] newMesh = pm . boolean ( mesh , bMesh , [string] ) [EOL] [EOL] if newMesh . num_faces == [number] : [EOL] [comment] [EOL] warning = [string] [EOL] print ( warning ) [EOL] newMesh = pm . boolean ( bMesh , mesh , [string] , engine = [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] try : [EOL] newSource = newMesh . get_attribute ( [string] ) [EOL] newFace = newMesh . faces [EOL] bottomFaces = [ ] [EOL] [EOL] for i , s in enumerate ( newSource ) : [EOL] if int ( s ) == [number] : [EOL] bottomFaces . append ( newFace [ i ] ) [EOL] [EOL] return newMesh , bottomFaces , warning [EOL] [EOL] except RuntimeError : [EOL] [comment] [EOL] newMesh . add_attribute ( [string] ) [EOL] newFace = newMesh . faces [EOL] [comment] [EOL] [comment] [EOL] newCen = newMesh . get_attribute ( [string] ) [EOL] bottomFaces = [ ] [EOL] [EOL] for newFaceIndex in range ( len ( newFace ) ) : [EOL] newCenZ = newCen [ newFaceIndex * [number] + [number] ] [EOL] if newCenZ < z : [EOL] bottomFaces . append ( newFace [ newFaceIndex ] ) [EOL] [EOL] return newMesh , bottomFaces , warning [EOL] [EOL] [comment] [EOL] def findHeight ( z ) : [EOL] [comment] [EOL] [EOL] [comment] [EOL] if z > zMax : [EOL] z = zMax [EOL] [EOL] [comment] [EOL] bMesh = createBbox ( z ) [EOL] [EOL] [comment] [EOL] newMesh , bottomFaces , warning = intersectAndBottomFaces ( bMesh , z ) [EOL] [EOL] [comment] [EOL] volMesh = getVolMesh ( newMesh , bottomFaces , z ) [EOL] [EOL] if z == zMax : [EOL] return [number] [EOL] [EOL] else : [EOL] [comment] [EOL] volMesh . add_attribute ( [string] ) [EOL] volVol = volMesh . get_attribute ( [string] ) [EOL] volVol = sum ( list ( ( map ( abs , volVol ) ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return volume - volVol [EOL] [EOL] [comment] [EOL] zFinal = newton ( findHeight , Z ) [EOL] [EOL] [comment] [EOL] def finalMesh ( z ) : [EOL] poolWarning = None [EOL] [EOL] [comment] [EOL] if z > zMax : [EOL] z = zMax [EOL] poolWarning = [string] [EOL] [EOL] [comment] [EOL] bMesh = createBbox ( z ) [EOL] [EOL] [comment] [EOL] newMesh , bottomFaces , boolWarning = intersectAndBottomFaces ( bMesh , z ) [EOL] [EOL] [comment] [EOL] volMesh = getVolMesh ( newMesh , bottomFaces , z ) [EOL] [EOL] volMesh . add_attribute ( [string] ) [EOL] volVol = volMesh . get_attribute ( [string] ) [EOL] volVol = sum ( list ( map ( abs , volVol ) ) ) [EOL] [EOL] [comment] [EOL] volMesh , info = pm . remove_isolated_vertices ( volMesh ) [EOL] [comment] [EOL] volMesh , info = pm . remove_duplicated_faces ( volMesh ) [EOL] [EOL] return volMesh , volVol , poolWarning , poolWarning [EOL] [EOL] [comment] [EOL] [comment] [EOL] finalMesh , finalVol , poolWarning , boolWarning = finalMesh ( zFinal ) [EOL] meshName = [string] + str ( faceIndex ) + [string] [EOL] hullMesh = pm . compute_outer_hull ( finalMesh ) [EOL] pm . save_mesh ( meshName , hullMesh ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] , [string] . format ( volume ) ) [EOL] print ( [string] , [string] . format ( finalVol ) ) [EOL] print ( [string] , finalMesh . is_closed ( ) ) [EOL] print ( [string] ) [EOL] [EOL] return meshName [EOL] [EOL] [EOL] [comment] [EOL] Z = [ ] [EOL] i = [number] [EOL] doneList = [ ] [EOL] notDoneList = list ( range ( [number] , len ( pts ) ) ) [EOL] loopLength = len ( notDoneList ) [EOL] meshNames = [ ] [EOL] [EOL] [comment] [EOL] while i < loopLength : [EOL] I = notDoneList . pop ( i ) [EOL] names = pool ( fI [ I ] , pts [ I ] , vols [ I ] ) [EOL] [EOL] [comment] [EOL] if names : [EOL] if not names in meshNames : [EOL] meshNames . append ( names ) [EOL] else : [EOL] pass [EOL] [EOL] doneList . append ( i ) [EOL] loopLength = len ( notDoneList ) [EOL] [EOL] [comment] [EOL] file_obj = open ( [string] , [string] ) [EOL] file = file_obj . readlines ( ) [EOL] file_obj . close ( ) [EOL] [EOL] mNames = [string] [EOL] for n in meshNames : [EOL] mNames += [string] + n [EOL] [EOL] file [ [number] ] = [string] + mNames [EOL] [EOL] outfile_obj = open ( [string] , [string] ) [EOL] outfile_obj . writelines ( file ) [EOL] [EOL] [comment] [EOL] file_obj = open ( [string] , [string] ) [EOL] file_obj . write ( mNames ) [EOL] file_obj . close ( ) [EOL] [EOL] [comment] [EOL] if boolWarning or poolWarning : [EOL] return [ boolWarning , poolWarning ] [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class simple_rain ( ) : [EOL] def __init__ ( self , cpus , precipitation , windSpeed , windDirection , testPoints , testVectors , context , temperature , k ) : [EOL] self . prec = precipitation [EOL] self . windSpeed = windSpeed [EOL] self . windDir = windDirection [EOL] self . testPts = testPoints [EOL] self . testVecs = testVectors [EOL] self . context = context [EOL] self . temp = temperature [EOL] self . kMiss = k [ [number] ] [EOL] self . kHit = k [ [number] ] [EOL] self . dirVec = False [EOL] self . hourlyResult = False [EOL] self . wdr = False [EOL] self . xyAngles = [ ] [EOL] self . yzAngles = [ ] [EOL] self . cpus = int ( cpus ) [EOL] [EOL] [comment] [EOL] def rainHits ( self ) : [EOL] from math import degrees , exp , log , acos , sqrt , pi , cos , radians [EOL] from rhinoscriptsyntax import XformMultiply , VectorCreate , AddPoint , VectorTransform , XformRotation2 [EOL] from Rhino . Geometry . Intersect . Intersection import RayShoot [EOL] from Rhino . Geometry import Ray3d [EOL] import threading [EOL] import Queue [EOL] [EOL] [comment] [EOL] [EOL] def rain_vector ( Vw , regn ) : [EOL] [EOL] [comment] [EOL] A = [number] [EOL] p = [number] [EOL] n = [number] [EOL] [EOL] if regn == [number] : [EOL] return [number] [EOL] [EOL] def f_a ( I ) : [EOL] return A * I ** p [EOL] [EOL] a = f_a ( regn ) [EOL] r = a * exp ( log ( - log ( [number] ) ) / n ) / [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] a = ( [number] * Vw ** [number] * r ** [number] ) / sqrt ( r ** [number] * ( [number] * Vw ** [number] + [number] * [number] ** [number] * r ** [number] ) ) [EOL] if a > [number] : [EOL] a = [number] [EOL] alpha = acos ( a ) [EOL] [EOL] return alpha [EOL] [EOL] def rotate_yz ( angle ) : [EOL] return XformRotation2 ( angle , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] [EOL] def rotate_xy ( angle ) : [EOL] return XformRotation2 ( angle , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] def B_wind ( angle , direction ) : [EOL] c = [number] - ( angle + [number] ) [EOL] [comment] [EOL] [EOL] a = abs ( c - direction ) [EOL] if a < [number] : [EOL] b = a [EOL] else : [EOL] b = [number] - a [EOL] [EOL] return radians ( b ) [EOL] [EOL] def rayShoot ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] while not q . empty ( ) : [EOL] numOfBounce = [number] [EOL] startPt , xyAngle , yzAngle = q . get ( ) [EOL] [EOL] vector = direction_vector [EOL] ray = Ray3d ( startPt , vector ) [EOL] [comment] [EOL] B = B_wind ( xyAngle , self . windDir [ i ] ) [EOL] [comment] [EOL] if B > pi / [number] : [EOL] [comment] [EOL] hourly_rain . append ( [number] ) [EOL] hourly_result . append ( False ) [EOL] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] K_wind = cos ( B ) / sqrt ( [number] + [number] * ( sqrt ( self . prec [ i ] ) / self . windSpeed [ i ] ** [number] ) ) * exp ( - [number] / ( self . windSpeed [ i ] * [number] * self . prec [ i ] ** [number] ) ) [EOL] [EOL] [comment] [EOL] intPt = RayShoot ( ray , [ self . context ] , numOfBounce ) [EOL] [EOL] [comment] [EOL] if intPt : [EOL] [comment] [EOL] hourly_result . append ( True ) [EOL] kRain = self . kHit [EOL] [comment] [EOL] [comment] [EOL] hourly_rain . append ( ( K_wind * kRain * self . prec [ i ] ) ) [EOL] [EOL] else : [EOL] [comment] [EOL] hourly_result . append ( False ) [EOL] kRain = self . kMiss [EOL] [comment] [EOL] [comment] [EOL] hourly_rain . append ( ( K_wind * kRain * self . prec [ i ] ) ) [EOL] [EOL] [comment] [EOL] q . task_done ( ) [EOL] [EOL] result = [ ] [EOL] dirVec_hourly = [ ] [EOL] wdr = [ ] [EOL] [EOL] for i in range ( [number] , len ( self . prec ) ) : [EOL] [EOL] if self . temp [ i ] <= - [number] or self . windSpeed [ i ] <= [number] or self . prec [ i ] <= [number] : [EOL] dirVec_hourly . append ( None ) [EOL] result . append ( [ False ] * len ( self . testPts ) ) [EOL] [EOL] else : [EOL] [EOL] [comment] [EOL] R_v = rain_vector ( self . windSpeed [ i ] , self . prec [ i ] ) [EOL] towards_sky = rotate_yz ( degrees ( R_v ) ) [EOL] [EOL] [comment] [EOL] w_d = self . windDir [ i ] [EOL] towards_wind = rotate_xy ( w_d ) [EOL] [EOL] [comment] [EOL] transformation = XformMultiply ( towards_wind , towards_sky ) [EOL] north_vector = VectorCreate ( AddPoint ( [number] , [number] , [number] ) , AddPoint ( [number] , - [number] , [number] ) ) [EOL] direction_vector = VectorTransform ( north_vector , transformation ) [EOL] hourly_result = [ ] [EOL] hourly_rain = [ ] [EOL] [EOL] [comment] [EOL] q = Queue . Queue ( ) [EOL] for fi , pts in enumerate ( self . testPts ) : [EOL] q . put ( ( pts , self . xyAngles [ fi ] , self . yzAngles [ fi ] ) ) [EOL] [comment] [EOL] [EOL] for c in range ( self . cpus ) : [EOL] t = threading . Thread ( target = rayShoot ) [EOL] t . setDaemon ( True ) [EOL] t . start ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] q . join ( ) [EOL] [EOL] dirVec_hourly . append ( direction_vector ) [EOL] result . append ( hourly_result ) [EOL] wdr . append ( hourly_rain ) [EOL] [EOL] self . hourlyResult = result [EOL] self . dirVec = dirVec_hourly [EOL] self . wdr = wdr [EOL] [EOL] def computeAngles ( self ) : [EOL] import Rhino . Geometry as rc [EOL] from math import degrees [EOL] [EOL] [comment] [EOL] zero = rc . Point3d ( [number] , [number] , [number] ) [EOL] z = rc . Vector3d ( [number] , [number] , [number] ) [EOL] x = rc . Vector3d ( [number] , [number] , [number] ) [EOL] y = rc . Vector3d ( [number] , [number] , [number] ) [EOL] xy = rc . Plane ( zero , z ) . WorldXY [EOL] yz = rc . Plane ( zero , x ) . WorldYZ [EOL] [EOL] [comment] [EOL] for fn in self . testVecs : [EOL] self . xyAngles . append ( degrees ( rc . Vector3d . VectorAngle ( fn , y , xy ) ) ) [EOL] yz_tmp = degrees ( rc . Vector3d . VectorAngle ( fn , z , yz ) ) [EOL] [EOL] [comment] [EOL] if yz_tmp > [number] : [EOL] yz_tmp = [number] - yz_tmp [EOL] elif yz_tmp > [number] : [EOL] yz_tmp = yz_tmp - [number] [EOL] elif yz_tmp > [number] : [EOL] yz_tmp = abs ( yz_tmp - [number] ) [EOL] elif yz_tmp < [number] : [EOL] yz_tmp = yz_tmp * ( - [number] ) [EOL] [EOL] self . yzAngles . append ( yz_tmp ) [EOL] [EOL] [EOL] def topographic_index ( meshPath , drainCurvesPath ) : [EOL] import numpy as np [EOL] import GeometryClasses as gc [EOL] import pymesh as pm [EOL] [EOL] [comment] [EOL] mesh = pm . load_mesh ( meshPath ) [EOL] drainCurves = [ ] [EOL] file = open ( drainCurvesPath , [string] ) [EOL] lines = file . readlines ( ) [EOL] for l in lines : [EOL] drainCurves . append ( int ( i ) for i in l . split ( [string] ) [ [number] : - [number] ] ) [EOL] [EOL] [comment] [EOL] mesh . add_attribute ( [string] ) [EOL] mesh . add_attribute ( [string] ) [EOL] faceArea = mesh . get_attribute ( [string] ) [EOL] fn = mesh . get_attribute ( [string] ) [EOL] faceNormal = [ ] [EOL] i = [number] [EOL] while i < len ( fn ) : [EOL] faceNormal . append ( np . array ( [ fn [ i ] , fn [ i + [number] ] , fn [ i + [number] ] ] ) ) [EOL] i += [number] [EOL] drainArea = faceArea [EOL] TI = [ ] [EOL] [EOL] def topoIndex ( a , beta ) : [EOL] return np . log ( a / np . tan ( beta ) ) [EOL] [EOL] def computeBeta ( normal ) : [EOL] z = np . array ( [ [number] , [number] , [number] ] ) [EOL] return gc . angleBetweenVectors ( z , normal , forceAngle = [string] ) [ [number] ] [EOL] [EOL] def processDrainCurve ( curveIndex ) : [EOL] [docstring] [EOL] [EOL] A = [number] [EOL] [EOL] for face in drainCurves [ curveIndex ] : [EOL] a = faceArea [ face ] [EOL] drainArea [ face ] += a [EOL] A += a [EOL] [EOL] return True [EOL] [EOL] for curve in range ( len ( drainCurves ) ) : [EOL] processDrainCurve ( curve ) [EOL] [EOL] for face in range ( mesh . num_faces ) : [EOL] a = drainArea [ face ] [EOL] b = computeBeta ( faceNormal [ face ] ) [EOL] TI . append ( topoIndex ( a , b ) ) [EOL] [EOL] [comment] [EOL] topoFile = open ( [string] , [string] ) [EOL] [EOL] for face in TI : [EOL] topoFile . write ( str ( face ) + [string] ) [EOL] topoFile . write ( [string] ) [EOL] [EOL] topoFile . close ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.bool$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 $typing.List[typing.Any]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] __author__ = [string] [EOL] __license__ = [string] [EOL] __version__ = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import threading [EOL] import queue [EOL] import pymesh as pm [EOL] import numpy as np [EOL] [EOL] [comment] [EOL] import livestock_linux . geometry as ls_geo [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def fix_mesh ( mesh , detail = [string] ) : [EOL] [EOL] bbox_min , bbox_max = mesh . bbox [EOL] diag_len = norm ( bbox_max - bbox_min ) [EOL] [EOL] if detail == [string] : [EOL] target_len = diag_len * [number] [EOL] [EOL] elif detail == [string] : [EOL] target_len = diag_len * [number] [EOL] [EOL] elif detail == [string] : [EOL] target_len = diag_len * [number] [EOL] [EOL] print ( [string] . format ( target_len ) ) [EOL] [EOL] count = [number] [EOL] mesh , __ = pymesh . remove_degenerated_triangles ( mesh , [number] ) [EOL] mesh , __ = pymesh . split_long_edges ( mesh , target_len ) [EOL] num_vertices = mesh . num_vertices [EOL] [EOL] while True : [EOL] mesh , __ = pymesh . collapse_short_edges ( mesh , [number] ) [EOL] mesh , __ = pymesh . collapse_short_edges ( mesh , target_len , preserve_feature = True ) [EOL] mesh , __ = pymesh . remove_obtuse_triangles ( mesh , [number] , [number] ) [EOL] [EOL] if mesh . num_vertices == num_vertices : [EOL] break [EOL] [EOL] num_vertices = mesh . num_vertices [EOL] print ( [string] . format ( num_vertices ) ) [EOL] count += [number] [EOL] if count > [number] : [EOL] break [EOL] [EOL] mesh = pymesh . resolve_self_intersection ( mesh ) [EOL] mesh , __ = pymesh . remove_duplicated_faces ( mesh ) [EOL] mesh = pymesh . compute_outer_hull ( mesh ) [EOL] mesh , __ = pymesh . remove_duplicated_faces ( mesh ) [EOL] mesh , __ = pymesh . remove_obtuse_triangles ( mesh , [number] , [number] ) [EOL] mesh , __ = pymesh . remove_isolated_vertices ( mesh ) [EOL] [EOL] return mesh	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List [EOL] import typing [EOL] import io [EOL] import os [EOL] import subprocess [EOL] import datetime [EOL] [EOL] [comment] [EOL] def delete_old_files ( ) : [EOL] dist_folder = [string] [EOL] [EOL] dist_files = os . listdir ( dist_folder ) [EOL] [EOL] for f in dist_files : [EOL] os . remove ( dist_folder + [string] + f ) [EOL] [EOL] [EOL] def edit_version ( ) : [EOL] setup_file = [string] [EOL] [EOL] file_obj = open ( setup_file , [string] ) [EOL] data = file_obj . readlines ( ) [EOL] file_obj . close ( ) [EOL] [EOL] version = data [ [number] ] . split ( [string] ) [ [number] ] . strip ( ) [ [number] : - [number] ] [EOL] date_version = datetime . datetime . now ( ) . strftime ( [string] ) [EOL] old_version_parts = version . split ( [string] ) [EOL] if date_version == old_version_parts [ [number] ] + [string] + old_version_parts [ [number] ] : [EOL] subversion = int ( old_version_parts [ [number] ] . split ( [string] ) [ [number] ] ) + [number] [EOL] new_version = date_version + [string] + str ( subversion ) [EOL] else : [EOL] new_version = date_version + [string] [EOL] [EOL] data [ [number] ] = [string] + new_version + [string] [EOL] [EOL] print ( f" [string] { version } [string] " f" [string] { new_version }" ) [EOL] [EOL] file_obj = open ( setup_file , [string] ) [EOL] file_obj . writelines ( data ) [EOL] file_obj . close ( ) [EOL] [EOL] [EOL] def call_upload ( ) : [EOL] subprocess . call ( [string] , cwd = [string] ) [EOL] [EOL] subprocess . call ( [string] , cwd = [string] ) [EOL] [EOL] [EOL] [comment] [EOL] delete_old_files ( ) [EOL] edit_version ( ) [EOL] call_upload ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0