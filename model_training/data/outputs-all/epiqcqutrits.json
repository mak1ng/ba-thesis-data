[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import io [EOL] from setuptools import find_packages , setup [EOL] [EOL] [comment] [EOL] __version__ = None [EOL] exec ( open ( [string] ) . read ( ) ) [EOL] [EOL] description = ( [string] [string] ) [EOL] [EOL] [comment] [EOL] long_description = ( [string] [string] [string] ) [EOL] stream = io . open ( [string] , encoding = [string] ) [EOL] stream . readline ( ) [EOL] long_description += stream . read ( ) [EOL] [EOL] [comment] [EOL] requirements = open ( [string] ) . readlines ( ) [EOL] requirements = [ r . strip ( ) for r in requirements ] [EOL] [EOL] cirq_packages = [ [string] ] + [ [string] + package for package in find_packages ( where = [string] ) ] [EOL] [EOL] setup ( name = [string] , version = __version__ , url = [string] , author = [string] , author_email = [string] , python_requires = [string] , install_requires = requirements , license = [string] , description = description , long_description = long_description , packages = cirq_packages , package_data = { [string] : [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict , List [EOL] import dev_tools [EOL] import typing [EOL] import requests [EOL] import builtins [EOL] from typing import Optional , List , Any , Dict [EOL] [EOL] import json [EOL] import os [EOL] import time [EOL] import sys [EOL] [EOL] import requests [EOL] [EOL] from dev_tools . github_repository import GithubRepository [EOL] [EOL] [EOL] cla_access_token = None [EOL] [EOL] [EOL] class CurrentStuckGoToNextError ( RuntimeError ) : [EOL] pass [EOL] [EOL] [EOL] class PullRequestDetails : [EOL] def __init__ ( self , payload , repo ) : [EOL] self . payload = payload [EOL] self . repo = repo [EOL] [EOL] @ staticmethod def from_github ( repo , pull_id ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , repo . access_token ) ) [EOL] [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] return PullRequestDetails ( payload , repo ) [EOL] [EOL] @ property def remote_repo ( self ) : [EOL] return GithubRepository ( organization = self . payload [ [string] ] [ [string] ] [ [string] ] [ [string] ] , name = self . payload [ [string] ] [ [string] ] [ [string] ] , access_token = self . repo . access_token ) [EOL] [EOL] @ property def marked_automergeable ( self ) : [EOL] return any ( label [ [string] ] == [string] for label in self . payload [ [string] ] ) [EOL] [EOL] @ property def marked_cla_no ( self ) : [EOL] return any ( label [ [string] ] == [string] for label in self . payload [ [string] ] ) [EOL] [EOL] @ property def pull_id ( self ) : [EOL] return self . payload [ [string] ] [EOL] [EOL] @ property def branch_name ( self ) : [EOL] return self . payload [ [string] ] [ [string] ] [EOL] [EOL] @ property def base_branch_name ( self ) : [EOL] return self . payload [ [string] ] [ [string] ] [EOL] [EOL] @ property def branch_sha ( self ) : [EOL] return self . payload [ [string] ] [ [string] ] [EOL] [EOL] @ property def title ( self ) : [EOL] return self . payload [ [string] ] [EOL] [EOL] @ property def body ( self ) : [EOL] return self . payload [ [string] ] [EOL] [EOL] [EOL] def check_collaborator_has_write ( repo , username ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , username , repo . access_token ) ) [EOL] [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] if payload [ [string] ] not in [ [string] , [string] ] : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] [EOL] def check_auto_merge_labeler ( repo , pull_id ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , repo . access_token ) ) [EOL] [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] relevant = [ event for event in payload if event [ [string] ] == [string] and event [ [string] ] [ [string] ] == [string] ] [EOL] if not relevant : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] check_collaborator_has_write ( repo , relevant [ - [number] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def find_existing_status_comment ( repo , pull_id ) : [EOL] expected_user = [string] [EOL] expected_text = [string] [EOL] [EOL] comments = list_pr_comments ( repo , pull_id ) [EOL] for comment in comments : [EOL] if comment [ [string] ] [ [string] ] == expected_user : [EOL] if expected_text in comment [ [string] ] : [EOL] return comment [EOL] [EOL] return None [EOL] [EOL] [EOL] def add_comment ( repo , pull_id , text ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , repo . access_token ) ) [EOL] data = { [string] : text } [EOL] response = requests . post ( url , json = data ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def edit_comment ( repo , text , comment_id ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , comment_id , repo . access_token ) ) [EOL] data = { [string] : text } [EOL] response = requests . patch ( url , json = data ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def leave_status_comment ( repo , pull_id , success , state_description ) : [EOL] cur = find_existing_status_comment ( repo , pull_id ) [EOL] if success : [EOL] body = [string] [EOL] elif success is None : [EOL] body = [string] . format ( state_description ) [EOL] else : [EOL] body = [string] . format ( state_description ) [EOL] if cur is None : [EOL] add_comment ( repo , pull_id , body ) [EOL] else : [EOL] edit_comment ( repo , body , cur [ [string] ] ) [EOL] [EOL] [EOL] def get_pr_check_status ( pr ) : [EOL] [docstring] [EOL] [EOL] url = ( [string] [string] . format ( pr . repo . organization , pr . repo . name , pr . branch_sha , pr . repo . access_token ) ) [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] return json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] [EOL] [EOL] def get_pr_review_status ( pr ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( pr . repo . organization , pr . repo . name , pr . pull_id , pr . repo . access_token ) ) [EOL] response = requests . get ( url ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] return json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] [EOL] [EOL] def wait_a_tick ( ) : [EOL] print ( [string] , end = [string] , flush = True ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def wait_for_status ( repo , pull_id , prev_pr , fail_if_same , ) : [EOL] while True : [EOL] pr = PullRequestDetails . from_github ( repo , pull_id ) [EOL] if pr . payload [ [string] ] != [string] : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] if prev_pr and pr . branch_sha == prev_pr . branch_sha : [EOL] if fail_if_same : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] wait_a_tick ( ) [EOL] continue [EOL] [EOL] if not pr . marked_automergeable : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] if pr . base_branch_name != [string] : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] review_status = get_pr_review_status ( pr ) [EOL] if not any ( review [ [string] ] == [string] for review in review_status ) : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] if any ( review [ [string] ] == [string] for review in review_status ) : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] check_status = get_pr_check_status ( pr ) [EOL] if check_status [ [string] ] == [string] : [EOL] wait_a_tick ( ) [EOL] continue [EOL] if check_status [ [string] ] != [string] : [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] if pr . payload [ [string] ] is None : [EOL] [comment] [EOL] wait_a_tick ( ) [EOL] continue [EOL] [EOL] return pr [EOL] [EOL] [EOL] def get_repo_ref ( repo , ref ) : [EOL] [docstring] [EOL] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , ref , repo . access_token ) ) [EOL] response = requests . get ( url ) [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] return payload [EOL] [EOL] [EOL] def get_master_sha ( repo ) : [EOL] ref = get_repo_ref ( repo , [string] ) [EOL] return ref [ [string] ] [ [string] ] [EOL] [EOL] [EOL] def watch_for_spurious_cla_failure ( pr ) : [EOL] [comment] [EOL] if pr . marked_cla_no : [EOL] return False [EOL] [EOL] print ( [string] , flush = True , end = [string] ) [EOL] for _ in range ( [number] ) : [EOL] wait_a_tick ( ) [EOL] new_pr = PullRequestDetails . from_github ( pr . repo , pr . pull_id ) [EOL] if new_pr . marked_cla_no : [EOL] print ( [string] ) [EOL] return True [EOL] [EOL] print ( [string] ) [EOL] return False [EOL] [EOL] [EOL] def watch_for_cla_restore ( pr ) : [EOL] print ( [string] , flush = True , end = [string] ) [EOL] for _ in range ( [number] ) : [EOL] wait_a_tick ( ) [EOL] new_pr = PullRequestDetails . from_github ( pr . repo , pr . pull_id ) [EOL] if not new_pr . marked_cla_no : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] [EOL] def list_pr_comments ( repo , pull_id ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , repo . access_token ) ) [EOL] response = requests . get ( url ) [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] return payload [EOL] [EOL] [EOL] def delete_comment ( repo , comment_id ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , comment_id , repo . access_token ) ) [EOL] response = requests . delete ( url ) [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def find_spurious_coauthor_comment_id ( pr ) : [EOL] expected_user = [string] [EOL] expected_text = ( [string] [string] ) [EOL] [EOL] comments = list_pr_comments ( pr . repo , pr . pull_id ) [EOL] for comment in comments : [EOL] if comment [ [string] ] [ [string] ] == expected_user : [EOL] if expected_text in comment [ [string] ] : [EOL] return comment [ [string] ] [EOL] [EOL] return None [EOL] [EOL] [EOL] def find_spurious_fixed_comment_id ( pr ) : [EOL] expected_user = [string] [EOL] expected_text = [string] [EOL] [EOL] comments = list_pr_comments ( pr . repo , pr . pull_id ) [EOL] for comment in comments : [EOL] if comment [ [string] ] [ [string] ] == expected_user : [EOL] if expected_text in comment [ [string] ] : [EOL] return comment [ [string] ] [EOL] [EOL] return None [EOL] [EOL] [EOL] def fight_cla_bot ( pr ) : [EOL] [docstring] [EOL] if not watch_for_spurious_cla_failure ( pr ) : [EOL] return [EOL] [EOL] [comment] [EOL] add_labels_to_pr ( pr . repo , pr . pull_id , [string] , override_token = cla_access_token ) [EOL] [EOL] spurious_comment_id = find_spurious_coauthor_comment_id ( pr ) [EOL] if spurious_comment_id is not None : [EOL] print ( [string] ) [EOL] delete_comment ( pr . repo , spurious_comment_id ) [EOL] [EOL] watch_for_cla_restore ( pr ) [EOL] [EOL] spurious_comment_id_2 = find_spurious_fixed_comment_id ( pr ) [EOL] if spurious_comment_id_2 is not None : [EOL] print ( [string] ) [EOL] delete_comment ( pr . repo , spurious_comment_id_2 ) [EOL] [EOL] [EOL] def sync_with_master ( pr ) : [EOL] [docstring] [EOL] master_sha = get_master_sha ( pr . repo ) [EOL] remote = pr . remote_repo [EOL] url = ( [string] [string] . format ( remote . organization , remote . name , remote . access_token ) ) [EOL] data = { [string] : pr . branch_name , [string] : master_sha , [string] : [string] . format ( pr . branch_name ) } [EOL] response = requests . post ( url , json = data ) [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] fight_cla_bot ( pr ) [EOL] return True [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] return False [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] raise CurrentStuckGoToNextError ( [string] ) [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] raise CurrentStuckGoToNextError ( [string] [string] [string] ) [EOL] [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def squash_merge ( pr ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( pr . repo . organization , pr . repo . name , pr . pull_id , pr . repo . access_token ) ) [EOL] data = { [string] : [string] . format ( pr . title , pr . pull_id ) , [string] : pr . body , [string] : pr . branch_sha , [string] : [string] } [EOL] response = requests . put ( url , json = data ) [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] return True [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] return False [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] return False [EOL] [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def auto_delete_pr_branch ( pr ) : [EOL] [docstring] [EOL] [EOL] open_pulls = list_open_pull_requests ( pr . repo , base_branch = pr . branch_name ) [EOL] if any ( open_pulls ) : [EOL] print ( [string] . format ( pr . branch_name ) ) [EOL] return False [EOL] [EOL] remote = pr . remote_repo [EOL] if ( pr . repo . organization . lower ( ) != remote . organization . lower ( ) or pr . repo . name . lower ( ) != remote . name . lower ( ) ) : [EOL] print ( [string] . format ( pr . branch_name , pr . remote_repo . organization , pr . remote_repo . name ) ) [EOL] return False [EOL] [EOL] url = ( [string] [string] . format ( remote . organization , remote . name , pr . branch_name , remote . access_token ) ) [EOL] response = requests . delete ( url ) [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] print ( [string] . format ( pr . branch_name ) ) [EOL] return True [EOL] [EOL] print ( [string] . format ( response . status_code , response . content ) ) [EOL] return False [EOL] [EOL] [EOL] def add_labels_to_pr ( repo , pull_id , * labels , override_token = None ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , override_token or repo . access_token ) ) [EOL] response = requests . post ( url , json = list ( labels ) ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def remove_label_from_pr ( repo , pull_id , label ) : [EOL] [docstring] [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , pull_id , label , repo . access_token ) ) [EOL] response = requests . delete ( url ) [EOL] [EOL] if response . status_code == [number] : [EOL] payload = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] if payload [ [string] ] == [string] : [EOL] return False [EOL] [EOL] if response . status_code == [number] : [EOL] [comment] [EOL] return True [EOL] [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] [EOL] def list_open_pull_requests ( repo , base_branch = None ) : [EOL] url = ( [string] [string] . format ( repo . organization , repo . name , repo . access_token ) ) [EOL] data = { [string] : [string] , } [EOL] if base_branch is not None : [EOL] data [ [string] ] = base_branch [EOL] response = requests . get ( url , json = data ) [EOL] [EOL] if response . status_code != [number] : [EOL] raise RuntimeError ( [string] . format ( response . status_code , response . content ) ) [EOL] [EOL] pulls = json . JSONDecoder ( ) . decode ( response . content . decode ( ) ) [EOL] results = [ PullRequestDetails ( pull , repo ) for pull in pulls ] [EOL] [EOL] [comment] [EOL] if base_branch is not None : [EOL] results = [ result for result in results if result . base_branch_name == base_branch ] [EOL] return results [EOL] [EOL] [EOL] def find_auto_mergeable_prs ( repo ) : [EOL] open_prs = list_open_pull_requests ( repo ) [EOL] auto_mergeable_prs = [ pr for pr in open_prs if pr . marked_automergeable ] [EOL] return [ pr . payload [ [string] ] for pr in auto_mergeable_prs ] [EOL] [EOL] [EOL] def auto_merge_pull_request ( repo , pull_id ) : [EOL] [docstring] [EOL] [EOL] pr = PullRequestDetails . from_github ( repo , pull_id ) [EOL] print ( [string] . format ( pull_id , repr ( pr . title ) ) ) [EOL] prev_pr = None [EOL] fail_if_same = False [EOL] while True : [EOL] check_auto_merge_labeler ( repo , pull_id ) [EOL] [EOL] print ( [string] , end = [string] , flush = True ) [EOL] pr = wait_for_status ( repo , pull_id , prev_pr , fail_if_same ) [EOL] [EOL] check_auto_merge_labeler ( repo , pull_id ) [EOL] [EOL] print ( [string] ) [EOL] if pr . payload [ [string] ] != [string] : [EOL] if sync_with_master ( pr ) : [EOL] print ( [string] ) [EOL] prev_pr = pr [EOL] fail_if_same = False [EOL] continue [EOL] [EOL] print ( [string] ) [EOL] if not squash_merge ( pr ) : [EOL] print ( [string] ) [EOL] prev_pr = pr [EOL] fail_if_same = True [EOL] continue [EOL] [EOL] print ( [string] ) [EOL] break [EOL] [EOL] auto_delete_pr_branch ( pr ) [EOL] print ( [string] . format ( pr . title , pull_id ) ) [EOL] print ( ) [EOL] [EOL] [EOL] def auto_merge_multiple_pull_requests ( repo , pull_ids ) : [EOL] print ( [string] . format ( pull_ids ) ) [EOL] for pull_id in pull_ids : [EOL] try : [EOL] leave_status_comment ( repo , pull_id , None , [string] ) [EOL] auto_merge_pull_request ( repo , pull_id ) [EOL] leave_status_comment ( repo , pull_id , True , [string] ) [EOL] except CurrentStuckGoToNextError as ex : [EOL] print ( [string] . format ( pull_id , ex . args ) ) [EOL] print ( [string] ) [EOL] leave_status_comment ( repo , pull_id , False , ex . args [ [number] ] ) [EOL] except Exception : [EOL] leave_status_comment ( repo , pull_id , False , [string] ) [EOL] raise [EOL] finally : [EOL] remove_label_from_pr ( repo , pull_id , [string] ) [EOL] print ( [string] . format ( pull_ids ) ) [EOL] [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def watch_for_auto_mergeable_pull_requests ( repo ) : [EOL] while True : [EOL] print ( [string] , end = [string] , flush = True ) [EOL] while True : [EOL] auto_ids = find_auto_mergeable_prs ( repo ) [EOL] if auto_ids : [EOL] print ( [string] . format ( auto_ids ) ) [EOL] break [EOL] wait_a_tick ( ) [EOL] auto_merge_multiple_pull_requests ( repo , auto_ids ) [EOL] [EOL] [EOL] def main ( ) : [EOL] global cla_access_token [EOL] pull_ids = [ int ( e ) for e in sys . argv [ [number] : ] ] [EOL] access_token = os . getenv ( [string] ) [EOL] cla_access_token = os . getenv ( [string] ) [EOL] if not access_token : [EOL] print ( [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] if not cla_access_token : [EOL] print ( [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] repo = GithubRepository ( organization = [string] , name = [string] , access_token = access_token ) [EOL] [EOL] if pull_ids : [EOL] auto_merge_multiple_pull_requests ( repo , pull_ids ) [EOL] else : [EOL] watch_for_auto_mergeable_pull_requests ( repo ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $'PullRequestDetails'$ 0 $dev_tools.github_repository.GithubRepository$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $dev_tools.github_repository.GithubRepository$ 0 0 0 $dev_tools.github_repository.GithubRepository$ 0 0 0 $builtins.int$ 0 $dev_tools.github_repository.GithubRepository$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dev_tools.github_repository.GithubRepository$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $PullRequestDetails$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[PullRequestDetails]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import os , sys , glob , json , itertools [EOL] [EOL] [EOL] def find_files ( in_dir ) : [EOL] return sorted ( f for f in itertools . chain . from_iterable ( glob . glob ( os . path . join ( x [ [number] ] , [string] ) ) for x in os . walk ( in_dir ) ) if os . path . isfile ( f ) ) [EOL] [EOL] def parse_line ( line , version_group , parse_val ) : [EOL] colon = - [number] - line [ : : - [number] ] . find ( [string] ) [EOL] params = line [ : colon ] [comment] [EOL] version , timestamp , val_str = line [ colon + [number] : ] . split ( ) [EOL] timestamp = float ( timestamp ) [EOL] val = parse_val ( val_str ) [EOL] version_g = version_group ( version ) [EOL] return params , version_g , timestamp , val [EOL] [EOL] def collect_file ( fname , out , version_group , parse_val ) : [EOL] with open ( fname ) as f : [EOL] for line in f : [EOL] line = line . strip ( ) [EOL] if not line : continue [EOL] if line [ : [number] ] == [string] : continue [EOL] try : [EOL] params , version_g , timestamp , val = parse_line ( line , version_group , parse_val ) [EOL] except BaseException as e : [EOL] print ( [string] . format ( line ) ) [EOL] continue [EOL] key = params if version_g is None else ( params , version_g ) [EOL] val_list = out . get ( key , [ ] ) [EOL] val_list . append ( val ) [comment] [EOL] out [ key ] = val_list [EOL] [EOL] def collect_files ( fnames , out , version_group , parse_val ) : [EOL] for fname in fnames : [EOL] collect_file ( fname , out , version_group , parse_val ) [EOL] [EOL] [EOL] def main ( in_dir ) : [EOL] out = { } [EOL] [EOL] def version_group ( v ) : [EOL] return None [EOL] [EOL] def parse_val ( val ) : [EOL] return float ( val ) [EOL] [EOL] collect_files ( find_files ( in_dir ) , out , version_group , parse_val ) [EOL] [EOL] for key in sorted ( out . keys ( ) ) : [EOL] val_arr = out [ key ] [EOL] print ( [string] . format ( key ) ) [EOL] print ( [string] . format ( len ( val_arr ) ) ) [EOL] print ( [string] . format ( sum ( val_arr ) / len ( val_arr ) ) ) [EOL] print ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] in_dir = [string] [EOL] if len ( sys . argv ) >= [number] : [EOL] in_dir = sys . argv [ [number] ] [EOL] [EOL] main ( in_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Set , Optional , Any , Tuple [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Tuple , List , Optional [EOL] [EOL] import numpy as np [EOL] [EOL] [EOL] def reflection_matrix_pow ( reflection_matrix , exponent ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] squared_phase = np . dot ( reflection_matrix [ : , [number] ] , reflection_matrix [ [number] , : ] ) [EOL] phase = complex ( np . sqrt ( squared_phase ) ) [EOL] [EOL] [comment] [EOL] i = np . eye ( reflection_matrix . shape [ [number] ] ) * phase [EOL] pos_part = ( i + reflection_matrix ) * [number] [EOL] neg_part = ( i - reflection_matrix ) * [number] [EOL] [EOL] [comment] [EOL] pos_factor = phase ** ( exponent - [number] ) [EOL] neg_factor = pos_factor * complex ( - [number] ) ** exponent [EOL] pos_part_raised = pos_factor * pos_part [EOL] neg_part_raised = neg_part * neg_factor [EOL] return pos_part_raised + neg_part_raised [EOL] [EOL] [EOL] def match_global_phase ( a , b ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if a . shape != b . shape : [EOL] return a , b [EOL] [EOL] [comment] [EOL] k = max ( np . ndindex ( * a . shape ) , key = lambda t : abs ( b [ t ] ) ) [EOL] [EOL] def dephase ( v ) : [EOL] r = np . real ( v ) [EOL] i = np . imag ( v ) [EOL] [EOL] [comment] [EOL] if i == [number] : [EOL] return - [number] if r < [number] else [number] [EOL] if r == [number] : [EOL] return [number] if i < [number] else - [number] [EOL] [EOL] return np . exp ( - [number] * np . arctan2 ( i , r ) ) [EOL] [EOL] [comment] [EOL] return a * dephase ( a [ k ] ) , b * dephase ( b [ k ] ) [EOL] [EOL] [EOL] def targeted_left_multiply ( left_matrix , right_target , target_axes , out = None ) : [EOL] [docstring] [EOL] k = len ( target_axes ) [EOL] d = len ( right_target . shape ) [EOL] work_indices = tuple ( range ( k ) ) [EOL] data_indices = tuple ( range ( k , k + d ) ) [EOL] used_data_indices = tuple ( data_indices [ q ] for q in target_axes ) [EOL] input_indices = work_indices + used_data_indices [EOL] output_indices = list ( data_indices ) [EOL] for w , t in zip ( work_indices , target_axes ) : [EOL] output_indices [ t ] = w [EOL] [EOL] all_indices = set ( input_indices + data_indices + tuple ( output_indices ) ) [EOL] [EOL] return np . einsum ( left_matrix , input_indices , right_target , data_indices , output_indices , optimize = len ( all_indices ) >= [number] , ** ( { [string] : out } if out is not None else { } ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[numpy.ndarray,numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import cmath [EOL] import numpy as np [EOL] [EOL] from cirq . linalg import predicates [EOL] from cirq . linalg . tolerance import Tolerance [EOL] [EOL] [EOL] def test_is_diagonal ( ) : [EOL] assert predicates . is_diagonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert predicates . is_diagonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert predicates . is_diagonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . is_diagonal ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] [EOL] [EOL] def test_is_diagonal_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_diagonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_is_hermitian ( ) : [EOL] assert predicates . is_hermitian ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_hermitian ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_hermitian ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) ) [EOL] [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] + [number] ] , [ - [number] , [number] + [number] * [number] ] ] ) ) [EOL] [EOL] [EOL] def test_is_hermitian_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_hermitian ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_hermitian ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_is_unitary ( ) : [EOL] assert predicates . is_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] + [number] ] , [ [number] , [number] + [number] * [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] [EOL] def test_is_unitary_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_unitary ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_unitary ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_is_orthogonal ( ) : [EOL] assert predicates . is_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . is_orthogonal ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] + [number] ] ] ) ) [EOL] [EOL] [EOL] def test_is_orthogonal_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_orthogonal ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_orthogonal ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_is_special_orthogonal ( ) : [EOL] assert predicates . is_special_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_special_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_special_orthogonal ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] ] , [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ - [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] + [number] ] ] ) ) [EOL] [EOL] [EOL] def test_is_special_orthogonal_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] / [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_orthogonal ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] / [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_is_special_unitary ( ) : [EOL] assert predicates . is_special_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_special_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . is_special_unitary ( np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ - [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert predicates . is_special_unitary ( np . array ( [ [ - [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] + [number] ] , [ [number] , [number] + [number] * [number] ] ] ) * np . sqrt ( [number] ) ) [EOL] [EOL] [EOL] def test_is_special_unitary_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] [comment] [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ - [number] , [number] ] ] ) , tol ) [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * cmath . exp ( [number] * [number] ) , tol ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * cmath . exp ( [number] * [number] ) , tol ) [EOL] [EOL] [comment] [EOL] assert predicates . is_special_unitary ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] / [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) , tol ) [EOL] assert not predicates . is_special_unitary ( np . array ( [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] / [number] ] ] ) , tol ) [EOL] [EOL] [EOL] def test_commutes ( ) : [EOL] assert predicates . commutes ( np . empty ( ( [number] , [number] ) ) , np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . commutes ( np . empty ( ( [number] , [number] ) ) , np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . commutes ( np . empty ( ( [number] , [number] ) ) , np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . commutes ( np . empty ( ( [number] , [number] ) ) , np . empty ( ( [number] , [number] ) ) ) [EOL] assert not predicates . commutes ( np . empty ( ( [number] , [number] ) ) , np . empty ( ( [number] , [number] ) ) ) [EOL] [EOL] assert predicates . commutes ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . commutes ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] x = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] y = np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) [EOL] z = np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) [EOL] xx = np . kron ( x , x ) [EOL] zz = np . kron ( z , z ) [EOL] [EOL] assert predicates . commutes ( x , x ) [EOL] assert predicates . commutes ( y , y ) [EOL] assert predicates . commutes ( z , z ) [EOL] assert not predicates . commutes ( x , y ) [EOL] assert not predicates . commutes ( x , z ) [EOL] assert not predicates . commutes ( y , z ) [EOL] [EOL] assert predicates . commutes ( xx , zz ) [EOL] assert predicates . commutes ( xx , np . diag ( [ [number] , - [number] , - [number] , [number] + [number] ] ) ) [EOL] [EOL] [EOL] def test_commutes_tolerance ( ) : [EOL] tol = Tolerance ( atol = [number] ) [EOL] [EOL] x = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] z = np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) [EOL] [EOL] [comment] [EOL] assert predicates . commutes ( x , x + z * [number] , tol ) [EOL] assert not predicates . commutes ( x , x + z * [number] , tol ) [EOL] [EOL] [EOL] def test_allclose_up_to_global_phase ( ) : [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [number] ] ) , np . array ( [ [number] ] ) ) [EOL] [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ - [number] ] ] ) ) [EOL] [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL] [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] , [number] ] ] ) , np . array ( [ [ [number] , [number] ] ] ) ) [EOL] [EOL] assert predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] , [number] ] ] ) , np . array ( [ [ [number] , [number] ] ] ) ) [EOL] [EOL] assert not predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] , [number] ] ] ) ) [EOL] assert not predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL] assert not predicates . allclose_up_to_global_phase ( np . array ( [ [ [number] ] ] ) , np . array ( [ [ [number] ] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import cirq [EOL] import builtins [EOL] from typing import TYPE_CHECKING [EOL] [EOL] from cirq . line . placement import greedy [EOL] from cirq . line . placement . place_strategy import LinePlacementStrategy [EOL] from cirq . line . placement . sequence import GridQubitLineTuple [EOL] [EOL] if TYPE_CHECKING : [EOL] [comment] [EOL] import cirq . google [EOL] [EOL] [EOL] def line_on_device ( device , length , method = greedy . GreedySequenceSearchStrategy ( ) ) : [EOL] [docstring] [EOL] return method . place_line ( device , length ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.line.placement.sequence.GridQubitLineTuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterable , Any , List [EOL] import cirq [EOL] import typing [EOL] from typing import Iterable [EOL] import pytest [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] from cirq . line . placement import greedy [EOL] from cirq . line . placement . sequence import GridQubitLineTuple , NotFoundError [EOL] from cirq . testing . mock import mock [EOL] [EOL] [EOL] def _create_device ( qubits ) : [EOL] return cg . XmonDevice ( cirq . Duration ( nanos = [number] ) , cirq . Duration ( nanos = [number] ) , cirq . Duration ( nanos = [number] ) , qubits ) [EOL] [EOL] [EOL] def test_greedy_sequence_search_fails_on_wrong_start_qubit ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] with pytest . raises ( ValueError ) : [EOL] greedy . GreedySequenceSearch ( _create_device ( [ q00 ] ) , q01 ) [EOL] [EOL] [EOL] def test_get_or_search_calls_find_sequence_once ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] search = greedy . GreedySequenceSearch ( _create_device ( [ q00 , q01 ] ) , q00 ) [EOL] with mock . patch . object ( search , [string] ) as find_sequence : [EOL] sequence = [ q00 , q01 ] [EOL] find_sequence . return_value = sequence [EOL] [EOL] assert search . get_or_search ( ) == sequence [EOL] find_sequence . assert_called_once_with ( ) [EOL] [EOL] assert search . get_or_search ( ) == sequence [EOL] find_sequence . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_find_sequence_assembles_head_and_tail ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 ] [EOL] start = q01 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] with mock . patch . object ( search , [string] ) as sequence_search : [EOL] head = [ q01 , q00 ] [EOL] tail = [ q01 , q02 ] [EOL] sequence_search . side_effect = [ tail , head ] [EOL] assert search . _find_sequence ( ) == qubits [EOL] sequence_search . assert_has_calls ( [ mock . call ( start , [ ] ) , mock . call ( start , tail ) ] ) [EOL] [EOL] [EOL] def test_find_sequence_calls_expand_sequence ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 ] [EOL] start = q01 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] with mock . patch . object ( search , [string] ) as sequence_search , mock . patch . object ( search , [string] ) as expand_sequence : [EOL] head = [ q01 , q00 ] [EOL] tail = [ q01 , q02 ] [EOL] sequence_search . side_effect = [ tail , head ] [EOL] [EOL] search . _find_sequence ( ) [EOL] expand_sequence . assert_called_once_with ( qubits ) [EOL] [EOL] [EOL] def test_search_sequence_calls_choose_next_qubit ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 ] [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , q01 ) [EOL] [EOL] with mock . patch . object ( search , [string] ) as choose_next_qubit : [EOL] choose_next_qubit . return_value = None [EOL] search . _sequence_search ( q01 , [ ] ) [EOL] choose_next_qubit . assert_called_once_with ( q01 , { q01 } ) [EOL] [EOL] with mock . patch . object ( search , [string] ) as choose_next_qubit : [EOL] choose_next_qubit . return_value = None [EOL] search . _sequence_search ( q01 , [ q00 ] ) [EOL] choose_next_qubit . assert_called_once_with ( q01 , { q00 , q01 } ) [EOL] [EOL] [EOL] def test_search_sequence_assembles_sequence ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 ] [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , q01 ) [EOL] [EOL] with mock . patch . object ( search , [string] ) as choose_next_qubit : [EOL] choose_next_qubit . side_effect = [ q01 , q02 , None ] [EOL] assert search . _sequence_search ( q00 , [ ] ) == [ q00 , q01 , q02 ] [EOL] [EOL] [EOL] def test_find_path_between_finds_path ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q11 = cirq . GridQubit ( [number] , [number] ) [EOL] q12 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q21 = cirq . GridQubit ( [number] , [number] ) [EOL] q22 = cirq . GridQubit ( [number] , [number] ) [EOL] [EOL] qubits = [ q00 , q01 , q10 , q11 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _find_path_between ( q00 , q01 , { q00 , q01 } ) == [ q10 , q11 ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q10 , q20 , q21 , q22 , q12 ] [EOL] path_1 = [ q00 , q01 , q02 ] [EOL] path_2 = [ q00 , q10 , q20 , q21 , q22 , q12 , q02 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _find_path_between ( q00 , q02 , set ( path_1 ) ) == path_2 [ [number] : - [number] ] [EOL] assert search . _find_path_between ( q02 , q00 , set ( path_1 ) ) == path_2 [ - [number] : [number] : - [number] ] [EOL] assert search . _find_path_between ( q00 , q02 , set ( path_2 ) ) == path_1 [ [number] : - [number] ] [EOL] assert search . _find_path_between ( q02 , q00 , set ( path_2 ) ) == path_1 [ - [number] : [number] : - [number] ] [EOL] [EOL] [EOL] def test_find_path_between_does_not_find_path ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q22 = cirq . GridQubit ( [number] , [number] ) [EOL] q12 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _find_path_between ( q00 , q01 , { q00 , q01 } ) is None [EOL] [EOL] qubits = [ q00 , q01 , q10 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _find_path_between ( q00 , q01 , { q00 , q01 } ) is None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q10 , q20 , q22 , q12 ] [EOL] path_1 = [ q00 , q01 , q02 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _find_path_between ( q00 , q02 , set ( path_1 ) ) is None [EOL] [EOL] [EOL] def test_expand_sequence_expands_sequence ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q03 = cirq . GridQubit ( [number] , [number] ) [EOL] q04 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q11 = cirq . GridQubit ( [number] , [number] ) [EOL] q12 = cirq . GridQubit ( [number] , [number] ) [EOL] q13 = cirq . GridQubit ( [number] , [number] ) [EOL] q14 = cirq . GridQubit ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q10 , q11 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _expand_sequence ( [ q00 , q01 ] ) == [ q00 , q10 , q11 , q01 ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q10 , q11 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _expand_sequence ( [ q00 , q01 , q02 ] ) == [ q00 , q10 , q11 , q01 , q02 ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q11 , q12 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _expand_sequence ( [ q00 , q01 , q02 ] ) == [ q00 , q01 , q11 , q12 , q02 ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q03 , q11 , q12 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _expand_sequence ( [ q00 , q01 , q02 , q03 ] ) == [ q00 , q01 , q11 , q12 , q02 , q03 ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q03 , q04 , q10 , q11 , q13 , q14 ] [EOL] start = q00 [EOL] search = greedy . GreedySequenceSearch ( _create_device ( qubits ) , start ) [EOL] assert search . _expand_sequence ( [ q00 , q01 , q02 , q03 , q04 ] ) == [ q00 , q10 , q11 , q01 , q02 , q03 , q13 , q14 , q04 ] [EOL] [EOL] [EOL] def test_minimal_sequence_search_chooses_minimal ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q21 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 , q20 , q21 ] [EOL] search = greedy . _PickFewestNeighbors ( _create_device ( qubits ) , q10 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q10 , { q10 } ) == q20 [EOL] assert search . _choose_next_qubit ( q20 , { q10 , q20 } ) == q21 [EOL] [EOL] [EOL] def test_minimal_sequence_search_does_not_use_used ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q21 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 , q20 , q21 ] [EOL] search = greedy . _PickFewestNeighbors ( _create_device ( qubits ) , q10 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q10 , { q00 , q10 } ) == q20 [EOL] [EOL] [EOL] def test_minimal_sequence_search_returns_none_for_single_node ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 ] [EOL] search = greedy . _PickFewestNeighbors ( _create_device ( qubits ) , q00 ) [EOL] assert search . _choose_next_qubit ( q00 , { q00 } ) is None [EOL] [EOL] [EOL] def test_minimal_sequence_search_returns_none_when_blocked ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 ] [EOL] search = greedy . _PickFewestNeighbors ( _create_device ( qubits ) , q10 ) [EOL] assert search . _choose_next_qubit ( q10 , { q00 , q10 } ) is None [EOL] [EOL] [EOL] def test_minimal_sequence_search_traverses_grid ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q11 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q03 = cirq . GridQubit ( [number] , [number] ) [EOL] q04 = cirq . GridQubit ( [number] , [number] ) [EOL] q14 = cirq . GridQubit ( [number] , [number] ) [EOL] q24 = cirq . GridQubit ( [number] , [number] ) [EOL] q05 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q11 , q02 , q03 , q04 , q05 , q14 , q24 ] [EOL] device = _create_device ( qubits ) [EOL] search = greedy . _PickFewestNeighbors ( device , q02 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q02 , { q02 } ) == q03 [EOL] assert search . _choose_next_qubit ( q03 , { q02 , q03 } ) == q04 [EOL] assert search . _choose_next_qubit ( q04 , { q02 , q03 , q04 } ) == q14 [EOL] assert search . _choose_next_qubit ( q14 , { q02 , q03 , q04 , q14 } ) == q24 [EOL] assert search . _choose_next_qubit ( q24 , { q02 , q03 , q04 , q14 , q24 } ) is None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q24 , { q24 } ) == q14 [EOL] assert search . _choose_next_qubit ( q14 , { q24 , q14 } ) == q04 [EOL] assert search . _choose_next_qubit ( q04 , { q24 , q14 , q04 } ) == q03 [EOL] assert search . _choose_next_qubit ( q03 , { q24 , q14 , q04 , q03 } ) == q02 [EOL] assert search . _choose_next_qubit ( q02 , { q24 , q14 , q04 , q03 , q02 } ) == q01 [EOL] assert search . _choose_next_qubit ( q01 , { q24 , q14 , q04 , q03 , q02 , q01 } ) in [ q00 , q11 ] [EOL] assert search . _choose_next_qubit ( q00 , { q24 , q14 , q04 , q03 , q02 , q01 , q00 } ) is None [EOL] assert search . _choose_next_qubit ( q11 , { q24 , q14 , q04 , q03 , q02 , q01 , q11 } ) is None [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] qubits = [ q00 , q01 , q02 , q03 , q04 , q05 , q14 , q24 ] [EOL] device = _create_device ( qubits ) [EOL] method = greedy . GreedySequenceSearchStrategy ( [string] ) [EOL] assert method . place_line ( device , [number] ) == ( q00 , q01 , q02 , q03 ) [EOL] assert method . place_line ( device , [number] ) == ( q00 , q01 , q02 , q03 , q04 , q14 , q24 ) [EOL] with pytest . raises ( NotFoundError ) : [EOL] _ = method . place_line ( device , [number] ) [EOL] [EOL] [EOL] def test_largest_sequence_search_chooses_largest ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q21 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 , q20 , q21 ] [EOL] search = greedy . _PickLargestArea ( _create_device ( qubits ) , q10 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q10 , { q10 } ) == q20 [EOL] [EOL] [EOL] def test_largest_sequence_search_does_not_use_used ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q21 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 , q20 , q21 ] [EOL] search = greedy . _PickLargestArea ( _create_device ( qubits ) , q10 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q10 , { q10 , q20 } ) == q00 [EOL] [EOL] [EOL] def test_largest_sequence_search_traverses_grid ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] q11 = cirq . GridQubit ( [number] , [number] ) [EOL] q20 = cirq . GridQubit ( [number] , [number] ) [EOL] q30 = cirq . GridQubit ( [number] , [number] ) [EOL] q40 = cirq . GridQubit ( [number] , [number] ) [EOL] q41 = cirq . GridQubit ( [number] , [number] ) [EOL] q42 = cirq . GridQubit ( [number] , [number] ) [EOL] q50 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q10 , q11 , q20 , q30 , q40 , q50 , q41 , q42 ] [EOL] device = _create_device ( qubits ) [EOL] search = greedy . _PickLargestArea ( device , q20 ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert search . _choose_next_qubit ( q20 , { q20 } ) == q30 [EOL] assert search . _choose_next_qubit ( q30 , { q20 , q30 } ) == q40 [EOL] assert search . _choose_next_qubit ( q40 , { q20 , q30 , q40 } ) == q41 [EOL] assert search . _choose_next_qubit ( q41 , { q20 , q30 , q40 , q41 } ) == q42 [EOL] assert search . _choose_next_qubit ( q42 , { q20 , q30 , q40 , q41 , q42 } ) is None [EOL] [EOL] method = greedy . GreedySequenceSearchStrategy ( [string] ) [EOL] assert method . place_line ( device , [number] ) == GridQubitLineTuple ( [ q00 , q10 , q20 , q30 , q40 , q41 , q42 ] ) [EOL] with pytest . raises ( NotFoundError ) : [EOL] _ = method . place_line ( device , [number] ) [EOL] [EOL] [EOL] def test_largest_collect_unused_collects_all_for_empty ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q12 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 , q12 ] [EOL] start = q01 [EOL] search = greedy . _PickLargestArea ( _create_device ( qubits ) , start ) [EOL] assert search . _collect_unused ( start , set ( ) ) == set ( qubits ) [EOL] assert search . _collect_unused ( start , { start } ) == set ( qubits ) [EOL] [EOL] [EOL] def test_largest_collect_unused_collects ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q12 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q02 , q12 ] [EOL] start = q01 [EOL] search = greedy . _PickLargestArea ( _create_device ( qubits ) , start ) [EOL] assert search . _collect_unused ( start , { q00 , q01 } ) == { q01 , q02 , q12 } [EOL] [EOL] [EOL] def test_largest_collect_stops_on_used ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] q02 = cirq . GridQubit ( [number] , [number] ) [EOL] q03 = cirq . GridQubit ( [number] , [number] ) [EOL] q04 = cirq . GridQubit ( [number] , [number] ) [EOL] q05 = cirq . GridQubit ( [number] , [number] ) [EOL] q11 = cirq . GridQubit ( [number] , [number] ) [EOL] q14 = cirq . GridQubit ( [number] , [number] ) [EOL] q24 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 , q11 , q02 , q03 , q04 , q05 , q14 , q24 ] [EOL] start = q02 [EOL] search = greedy . _PickLargestArea ( _create_device ( qubits ) , start ) [EOL] assert search . _collect_unused ( start , { start , q04 } ) == { q00 , q01 , q11 , q02 , q03 } [EOL] [EOL] [EOL] def test_greedy_search_method_calls_all ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 ] [EOL] length = [number] [EOL] method = greedy . GreedySequenceSearchStrategy ( ) [EOL] assert len ( method . place_line ( _create_device ( qubits ) , length ) ) == [number] [EOL] [EOL] [EOL] def test_greedy_search_method_fails_when_unknown ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] qubits = [ q00 , q01 ] [EOL] length = [number] [EOL] [EOL] method = greedy . GreedySequenceSearchStrategy ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] method . place_line ( _create_device ( qubits ) , length ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_greedy_search_method_calls_largest_only ( minimal , largest ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] device = _create_device ( [ q00 , q01 ] ) [EOL] length = [number] [EOL] sequence = [ q00 , q01 ] [EOL] largest . return_value . get_or_search . return_value = sequence [EOL] [EOL] method = greedy . GreedySequenceSearchStrategy ( [string] ) [EOL] assert method . place_line ( device , length ) == GridQubitLineTuple ( sequence ) [EOL] [EOL] largest . return_value . get_or_search . assert_called_once_with ( ) [EOL] minimal . return_value . get_or_search . assert_not_called ( ) [EOL] [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_greedy_search_method_calls_minimal_only ( minimal , largest ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] device = _create_device ( [ q00 , q01 ] ) [EOL] length = [number] [EOL] sequence = [ q00 , q01 ] [EOL] minimal . return_value . get_or_search . return_value = sequence [EOL] [EOL] method = greedy . GreedySequenceSearchStrategy ( [string] ) [EOL] assert method . place_line ( device , length ) == GridQubitLineTuple ( sequence ) [EOL] [EOL] largest . return_value . get_or_search . assert_not_called ( ) [EOL] minimal . return_value . get_or_search . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_greedy_search_method_returns_longest ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q10 = cirq . GridQubit ( [number] , [number] ) [EOL] device = _create_device ( [ q00 , q10 ] ) [EOL] length = [number] [EOL] [EOL] method = greedy . GreedySequenceSearchStrategy ( ) [EOL] assert method . place_line ( device , length ) == GridQubitLineTuple ( [ q00 ] ) [EOL] [EOL] [EOL] def test_greedy_search_method_returns_empty_when_empty ( ) : [EOL] device = _create_device ( [ ] ) [EOL] length = [number] [EOL] method = greedy . GreedySequenceSearchStrategy ( ) [EOL] assert method . place_line ( device , length ) == GridQubitLineTuple ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List [EOL] import cirq [EOL] import typing [EOL] [docstring] [EOL] [EOL] import numpy as np [EOL] from matplotlib import pyplot as pl [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] from cirq . devices import GridQubit [EOL] from cirq . study import visualize [EOL] [EOL] [EOL] def test_plot_state_histogram ( ) : [EOL] pl . switch_backend ( [string] ) [EOL] simulator = cg . XmonSimulator ( ) [EOL] [EOL] rot_w_gate = cg . ExpWGate ( half_turns = [number] ) [EOL] [EOL] q0 = GridQubit ( [number] , [number] ) [EOL] q1 = GridQubit ( [number] , [number] ) [EOL] circuit = cirq . Circuit ( ) [EOL] circuit . append ( [ rot_w_gate ( q0 ) , rot_w_gate ( q1 ) ] ) [EOL] circuit . append ( [ cg . XmonMeasurementGate ( key = [string] ) ( q0 ) , cg . XmonMeasurementGate ( key = [string] ) ( q1 ) ] ) [EOL] results = simulator . run_sweep ( program = circuit , repetitions = [number] ) [EOL] [EOL] values_plotted = visualize . plot_state_histogram ( results [ [number] ] ) [EOL] expected_values = [ [number] , [number] , [number] , [number] ] [EOL] [EOL] np . testing . assert_equal ( values_plotted , expected_values ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] from typing import Iterable , Union [EOL] [EOL] from cirq . study . resolver import ParamResolver [EOL] from cirq . study . sweeps import Sweep [EOL] [EOL] [EOL] Sweepable = Union [ ParamResolver , Iterable [ ParamResolver ] , Sweep , Iterable [ Sweep ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pytest [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] [EOL] from cirq . testing import ( assert_circuits_with_terminal_measurements_are_equivalent , ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] ) def test_swap_field ( n , d ) : [EOL] before = cirq . Circuit . from_ops ( cirq . ISWAP ( cirq . LineQubit ( j ) , cirq . LineQubit ( j + [number] ) ) for i in range ( d ) for j in range ( i % [number] , n - [number] , [number] ) ) [EOL] before . append ( cirq . measure ( * before . all_qubits ( ) ) ) [EOL] [EOL] after = cg . optimized_for_xmon ( before ) [EOL] [EOL] assert len ( after ) == d * [number] + [number] [EOL] if n <= [number] : [EOL] assert_circuits_with_terminal_measurements_are_equivalent ( before , after , atol = [number] ) [EOL] [EOL] [EOL] def test_ccz ( ) : [EOL] before = cirq . Circuit . from_ops ( cirq . CCZ ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ) [EOL] [EOL] after = cg . optimized_for_xmon ( before ) [EOL] [EOL] assert len ( after ) <= [number] [EOL] assert_circuits_with_terminal_measurements_are_equivalent ( before , after , atol = [number] ) [EOL] [EOL] [EOL] def test_adjacent_cz_get_split_apart ( ) : [EOL] before = cirq . Circuit ( [ cirq . Moment ( [ cirq . CZ ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) , cirq . CZ ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ] ) ] ) [EOL] [EOL] after = cg . optimized_for_xmon ( before , new_device = cg . Foxtail ) [EOL] [EOL] assert after == cirq . Circuit ( [ cirq . Moment ( [ cg . Exp11Gate ( ) . on ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ] ) , cirq . Moment ( [ cg . Exp11Gate ( ) . on ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ] ) ] , device = cg . Foxtail ) [EOL] [EOL] [EOL] def test_remap_qubits ( ) : [EOL] before = cirq . Circuit ( [ cirq . Moment ( [ cirq . CZ ( cirq . LineQubit ( [number] ) , cirq . LineQubit ( [number] ) ) ] ) ] ) [EOL] [EOL] after = cg . optimized_for_xmon ( before , new_device = cg . Foxtail , qubit_map = lambda q : cirq . GridQubit ( q . x , [number] ) ) [EOL] [EOL] assert after == cirq . Circuit ( [ cirq . Moment ( [ cg . Exp11Gate ( ) . on ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ] ) ] , device = cg . Foxtail ) [EOL] [EOL] [EOL] def test_dont_allow_partial_czs ( ) : [EOL] before = cirq . Circuit ( [ cirq . Moment ( [ cirq . CZ ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ** [number] ] ) ] ) [EOL] [EOL] after = cg . optimized_for_xmon ( before , allow_partial_czs = False ) [EOL] [EOL] cz_gates = [ op . gate for op in after . all_operations ( ) if cg . XmonGate . is_xmon_op ( op ) and isinstance ( op . gate , cg . Exp11Gate ) ] [EOL] num_full_cz = sum ( [number] for cz in cz_gates if cz . half_turns == [number] ) [EOL] num_part_cz = sum ( [number] for cz in cz_gates if cz . half_turns != [number] ) [EOL] assert num_full_cz == [number] [EOL] assert num_part_cz == [number] [EOL] [EOL] [EOL] def test_allow_partial_czs ( ) : [EOL] before = cirq . Circuit ( [ cirq . Moment ( [ cirq . CZ ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) ** [number] ] ) ] ) [EOL] [EOL] after = cg . optimized_for_xmon ( before , allow_partial_czs = True ) [EOL] [EOL] cz_gates = [ op . gate for op in after . all_operations ( ) if cg . XmonGate . is_xmon_op ( op ) and isinstance ( op . gate , cg . Exp11Gate ) ] [EOL] num_full_cz = sum ( [number] for cz in cz_gates if cz . half_turns == [number] ) [EOL] num_part_cz = sum ( [number] for cz in cz_gates if cz . half_turns != [number] ) [EOL] assert num_full_cz == [number] [EOL] assert num_part_cz == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Optional , List [EOL] import cirq [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Optional , Callable , cast [EOL] [EOL] from cirq import circuits , ops , devices [EOL] from cirq . google import ( convert_to_xmon_gates , merge_rotations , eject_full_w , eject_z , xmon_device ) [EOL] [EOL] _TOLERANCE = [number] [EOL] [EOL] _OPTIMIZERS = [ convert_to_xmon_gates . ConvertToXmonGates ( ) , circuits . MergeInteractions ( tolerance = _TOLERANCE , allow_partial_czs = False ) , convert_to_xmon_gates . ConvertToXmonGates ( ) , merge_rotations . MergeRotations ( tolerance = _TOLERANCE ) , eject_full_w . EjectFullW ( tolerance = _TOLERANCE ) , eject_z . EjectZ ( tolerance = _TOLERANCE ) , circuits . DropNegligible ( tolerance = _TOLERANCE ) , merge_rotations . MergeRotations ( tolerance = _TOLERANCE ) , ] [EOL] [EOL] _OPTIMIZERS_PART_CZ = [ convert_to_xmon_gates . ConvertToXmonGates ( ) , circuits . MergeInteractions ( tolerance = _TOLERANCE , allow_partial_czs = True ) , convert_to_xmon_gates . ConvertToXmonGates ( ) , merge_rotations . MergeRotations ( tolerance = _TOLERANCE ) , eject_full_w . EjectFullW ( tolerance = _TOLERANCE ) , eject_z . EjectZ ( tolerance = _TOLERANCE ) , circuits . DropNegligible ( tolerance = _TOLERANCE ) , merge_rotations . MergeRotations ( tolerance = _TOLERANCE ) , ] [EOL] [EOL] [EOL] def optimized_for_xmon ( circuit , new_device = None , qubit_map = lambda e : cast ( devices . GridQubit , e ) , allow_partial_czs = False , ) : [EOL] [docstring] [EOL] copy = circuit . copy ( ) [EOL] opts = _OPTIMIZERS_PART_CZ if allow_partial_czs else _OPTIMIZERS [EOL] for optimizer in opts : [EOL] optimizer . optimize_circuit ( copy ) [EOL] [EOL] return circuits . Circuit . from_ops ( ( op . transform_qubits ( qubit_map ) for op in copy . all_operations ( ) ) , strategy = circuits . InsertStrategy . EARLIEST , device = new_device or copy . device ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $cirq.circuits.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Iterable , Any [EOL] import cirq [EOL] import typing [EOL] import builtins [EOL] from typing import Iterable [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] [EOL] [EOL] def assert_optimizes ( before , expected , compare_unitaries = True ) : [EOL] opt = cg . EjectFullW ( ) [EOL] [EOL] circuit = before . copy ( ) [EOL] opt . optimize_circuit ( circuit ) [EOL] [EOL] [comment] [EOL] if compare_unitaries : [EOL] cirq . testing . assert_circuits_with_terminal_measurements_are_equivalent ( circuit , expected , [number] ) [EOL] [EOL] [comment] [EOL] if circuit != expected : [EOL] [comment] [EOL] print ( [string] ) [EOL] print ( before ) [EOL] print ( [string] ) [EOL] print ( expected ) [EOL] print ( [string] ) [EOL] print ( circuit ) [EOL] print ( repr ( circuit ) ) [EOL] assert circuit == expected [EOL] [EOL] [comment] [EOL] opt . optimize_circuit ( circuit ) [EOL] assert circuit == expected [EOL] [EOL] [EOL] def quick_circuit ( * moments ) : [EOL] return cirq . Circuit ( [ cirq . Moment ( cirq . flatten_op_tree ( m ) ) for m in moments ] ) [EOL] [EOL] [EOL] def test_absorbs_z ( ) : [EOL] q = cirq . NamedQubit ( [string] ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cirq . Z ( q ) ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cirq . S ( q ) ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cirq . S ( q ) ] , [ cirq . T ( q ) ** - [number] ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ ] , [ ] , ) ) [EOL] [EOL] [EOL] def test_crosses_czs ( ) : [EOL] a = cirq . NamedQubit ( [string] ) [EOL] b = cirq . NamedQubit ( [string] ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cirq . CZ ( a , b ) ] , ) , expected = quick_circuit ( [ cg . ExpZGate ( ) . on ( b ) ] , [ cg . Exp11Gate ( ) . on ( a , b ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , ) ) [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cirq . CZ ( b , a ) ] , ) , expected = quick_circuit ( [ cg . ExpZGate ( ) . on ( b ) ] , [ cg . Exp11Gate ( ) . on ( a , b ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cirq . CZ ( a , b ) ** [number] ] , ) , expected = quick_circuit ( [ cg . ExpZGate ( half_turns = [number] ) . on ( b ) ] , [ cg . Exp11Gate ( half_turns = - [number] ) . on ( a , b ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( b ) ] , [ cirq . CZ ( a , b ) ** [number] ] , ) , expected = quick_circuit ( [ ] , [ ] , [ cirq . CZ ( a , b ) ** [number] ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) , cg . ExpWGate ( axis_half_turns = [number] ) . on ( b ) ] , ) ) [EOL] [EOL] [EOL] def test_toggles_measurements ( ) : [EOL] a = cirq . NamedQubit ( [string] ) [EOL] b = cirq . NamedQubit ( [string] ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cirq . measure ( a , b ) ] , ) , expected = quick_circuit ( [ ] , [ cirq . measure ( a , b , invert_mask = ( True , ) ) ] , ) ) [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( b ) ] , [ cirq . measure ( a , b ) ] , ) , expected = quick_circuit ( [ ] , [ cirq . measure ( a , b , invert_mask = ( False , True ) ) ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( b ) ] , [ cirq . measure ( a , b ) ] , ) , expected = quick_circuit ( [ ] , [ ] , [ cirq . measure ( a , b , invert_mask = ( True , True ) ) ] , ) ) [EOL] [EOL] [comment] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( a ) ] , [ cg . XmonMeasurementGate ( key = [string] ) . on ( a , b ) ] , ) , expected = quick_circuit ( [ ] , [ cg . XmonMeasurementGate ( key = [string] , invert_mask = ( True , ) ) . on ( a , b ) ] , ) ) [EOL] [EOL] [EOL] def test_cancels_other_full_w ( ) : [EOL] q = cirq . NamedQubit ( [string] ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpZGate ( half_turns = - [number] ) . on ( q ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpZGate ( half_turns = [number] ) . on ( q ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpZGate ( half_turns = - [number] ) . on ( q ) ] , ) ) [EOL] [EOL] [EOL] def test_phases_partial_ws ( ) : [EOL] q = cirq . NamedQubit ( [string] ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpWGate ( axis_half_turns = - [number] , half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( ) . on ( q ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) . on ( q ) ] , ) , expected = quick_circuit ( [ ] , [ cg . ExpWGate ( half_turns = [number] ) . on ( q ) ] , [ cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( q ) ] , [ cg . ExpWGate ( half_turns = - [number] , axis_half_turns = [number] ) . on ( q ) ] ) , expected = quick_circuit ( [ ] , [ cg . ExpWGate ( half_turns = - [number] , axis_half_turns = - [number] ) . on ( q ) ] , [ cg . ExpWGate ( ) . on ( q ) ] , ) ) [EOL] [EOL] [EOL] def test_blocked_by_unknown_and_symbols ( ) : [EOL] a = cirq . NamedQubit ( [string] ) [EOL] b = cirq . NamedQubit ( [string] ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cirq . SWAP ( a , b ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cirq . SWAP ( a , b ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) . on ( a ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) . on ( a ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) , compare_unitaries = False ) [EOL] [EOL] assert_optimizes ( before = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) . on ( a , b ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) , expected = quick_circuit ( [ cg . ExpWGate ( ) . on ( a ) ] , [ cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) . on ( a , b ) ] , [ cg . ExpWGate ( ) . on ( a ) ] , ) , compare_unitaries = False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Iterable , Any , List [EOL] import numpy [EOL] import typing [EOL] import cirq [EOL] from typing import Iterable , List [EOL] [EOL] import random [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] import cirq [EOL] from cirq . google import decompositions [EOL] [EOL] [EOL] def _operations_to_matrix ( operations , qubits ) : [EOL] return cirq . Circuit . from_ops ( operations ) . to_unitary_matrix ( qubit_order = cirq . QubitOrder . explicit ( qubits ) , qubits_that_should_be_present = qubits ) [EOL] [EOL] [EOL] def assert_gates_implement_unitary ( gates , intended_effect ) : [EOL] actual_effect = cirq . dot ( * [ cirq . unitary ( g ) for g in reversed ( gates ) ] ) [EOL] assert cirq . allclose_up_to_global_phase ( actual_effect , intended_effect ) [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_known_x ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . X ] [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_known_y ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , - [number] ] , [ [number] , [number] ] ] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . Y ] [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_known_z ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . Z ] [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_known_s ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . Z ** [number] ] [EOL] [EOL] [EOL] def test_known_s_dag ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . Z ** - [number] ] [EOL] [EOL] [EOL] def test_known_h ( ) : [EOL] actual = decompositions . single_qubit_matrix_to_native_gates ( np . array ( [ [ [number] , [number] ] , [ [number] , - [number] ] ] ) * np . sqrt ( [number] ) , tolerance = [number] ) [EOL] [EOL] assert actual == [ cirq . Y ** - [number] , cirq . Z ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) , ] + [ cirq . testing . random_unitary ( [number] ) for _ in range ( [number] ) ] ) def test_single_qubit_matrix_to_native_gates_cases ( intended_effect ) : [EOL] gates = decompositions . single_qubit_matrix_to_native_gates ( intended_effect , tolerance = [number] ) [EOL] assert len ( gates ) <= [number] [EOL] assert_gates_implement_unitary ( gates , intended_effect ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( random . random ( ) , random . random ( ) ) for _ in range ( [number] ) ] ) def test_single_qubit_matrix_to_native_gates_fuzz_half_turns_always_one_gate ( pre_turns , post_turns ) : [EOL] intended_effect = cirq . dot ( cirq . unitary ( cirq . RotZGate ( half_turns = [number] * pre_turns ) ) , cirq . unitary ( cirq . X ) , cirq . unitary ( cirq . RotZGate ( half_turns = [number] * post_turns ) ) ) [EOL] [EOL] gates = decompositions . single_qubit_matrix_to_native_gates ( intended_effect , tolerance = [number] ) [EOL] [EOL] assert len ( gates ) == [number] [EOL] assert_gates_implement_unitary ( gates , intended_effect ) [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_tolerance_z ( ) : [EOL] z = np . diag ( [ [number] , np . exp ( [number] * [number] ) ] ) [EOL] [EOL] optimized_away = decompositions . single_qubit_matrix_to_native_gates ( z , tolerance = [number] ) [EOL] assert len ( optimized_away ) == [number] [EOL] [EOL] kept = decompositions . single_qubit_matrix_to_native_gates ( z , tolerance = [number] ) [EOL] assert len ( kept ) == [number] [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_tolerance_xy ( ) : [EOL] c , s = np . cos ( [number] ) , np . sin ( [number] ) [EOL] xy = np . array ( [ [ c , - s ] , [ s , c ] ] ) [EOL] [EOL] optimized_away = decompositions . single_qubit_matrix_to_native_gates ( xy , tolerance = [number] ) [EOL] assert len ( optimized_away ) == [number] [EOL] [EOL] kept = decompositions . single_qubit_matrix_to_native_gates ( xy , tolerance = [number] ) [EOL] assert len ( kept ) == [number] [EOL] [EOL] [EOL] def test_single_qubit_matrix_to_native_gates_tolerance_half_turn_phasing ( ) : [EOL] a = np . pi / [number] + [number] [EOL] c , s = np . cos ( a ) , np . sin ( a ) [EOL] nearly_x = np . array ( [ [ c , - s ] , [ s , c ] ] ) [EOL] z1 = np . diag ( [ [number] , np . exp ( [number] * [number] ) ] ) [EOL] z2 = np . diag ( [ [number] , np . exp ( [number] * [number] ) ] ) [EOL] phased_nearly_x = z1 . dot ( nearly_x ) . dot ( z2 ) [EOL] [EOL] optimized_away = decompositions . single_qubit_matrix_to_native_gates ( phased_nearly_x , tolerance = [number] ) [EOL] assert len ( optimized_away ) == [number] [EOL] [EOL] kept = decompositions . single_qubit_matrix_to_native_gates ( phased_nearly_x , tolerance = [number] ) [EOL] assert len ( kept ) == [number] [EOL] [EOL] [EOL] def test_controlled_op_to_gates_concrete_case ( ) : [EOL] c = cirq . NamedQubit ( [string] ) [EOL] t = cirq . NamedQubit ( [string] ) [EOL] operations = decompositions . controlled_op_to_native_gates ( control = c , target = t , operation = np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) * np . sqrt ( [number] ) , tolerance = [number] ) [EOL] [EOL] assert operations == [ cirq . Y ( t ) ** - [number] , cirq . CZ ( c , t ) ** [number] , cirq . Z ( c ) ** [number] , cirq . Y ( t ) ** [number] ] [EOL] [EOL] [EOL] def test_controlled_op_to_gates_omits_negligible_global_phase ( ) : [EOL] qc = cirq . QubitId ( ) [EOL] qt = cirq . QubitId ( ) [EOL] operations = decompositions . controlled_op_to_native_gates ( control = qc , target = qt , operation = cirq . unitary ( cirq . H ) , tolerance = [number] ) [EOL] [EOL] assert operations == [ cirq . Y ( qt ) ** - [number] , cirq . CZ ( qc , qt ) , cirq . Y ( qt ) ** [number] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ np . eye ( [number] ) , cirq . unitary ( cirq . H ) , cirq . unitary ( cirq . X ) , cirq . unitary ( cirq . X ** [number] ) , cirq . unitary ( cirq . Y ) , cirq . unitary ( cirq . Z ) , cirq . unitary ( cirq . Z ** [number] ) , ] + [ cirq . testing . random_unitary ( [number] ) for _ in range ( [number] ) ] ) def test_controlled_op_to_gates_equivalent_on_known_and_random ( mat ) : [EOL] qc = cirq . QubitId ( ) [EOL] qt = cirq . QubitId ( ) [EOL] operations = decompositions . controlled_op_to_native_gates ( control = qc , target = qt , operation = mat ) [EOL] actual_effect = _operations_to_matrix ( operations , ( qc , qt ) ) [EOL] intended_effect = cirq . kron_with_controls ( cirq . CONTROL_TAG , mat ) [EOL] assert cirq . allclose_up_to_global_phase ( actual_effect , intended_effect ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Any , Dict , List [EOL] import cirq [EOL] import typing [EOL] import pytest [EOL] import numpy as np [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] [EOL] [EOL] def assert_proto_dict_convert ( gate_cls , gate , proto_dict , * qubits ) : [EOL] assert gate . to_proto_dict ( * qubits ) == proto_dict [EOL] assert gate_cls . from_proto_dict ( proto_dict ) == gate ( * qubits ) [EOL] [EOL] [EOL] def test_parameterized_value_from_proto ( ) : [EOL] from_proto = cg . XmonGate . parameterized_value_from_proto_dict [EOL] [EOL] m1 = { [string] : [number] } [EOL] assert from_proto ( m1 ) == [number] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] from_proto ( { } ) [EOL] [EOL] m3 = { [string] : [string] } [EOL] assert from_proto ( m3 ) == cirq . Symbol ( [string] ) [EOL] [EOL] [EOL] def test_measurement_eq ( ) : [EOL] eq = cirq . testing . EqualsTester ( ) [EOL] eq . make_equality_group ( lambda : cg . XmonMeasurementGate ( key = [string] ) ) [EOL] eq . make_equality_group ( lambda : cg . XmonMeasurementGate ( [string] ) ) [EOL] eq . make_equality_group ( lambda : cg . XmonMeasurementGate ( [string] ) ) [EOL] eq . make_equality_group ( lambda : cg . XmonMeasurementGate ( key = [string] , invert_mask = ( True , ) ) ) [EOL] eq . make_equality_group ( lambda : cg . XmonMeasurementGate ( key = [string] , invert_mask = ( False , ) ) ) [EOL] [EOL] [EOL] def test_single_qubit_measurement_proto_dict_convert ( ) : [EOL] gate = cg . XmonMeasurementGate ( [string] ) [EOL] proto_dict = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : [string] } } [EOL] assert_proto_dict_convert ( cg . XmonMeasurementGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_single_qubit_measurement_invalid_dict ( ) : [EOL] proto_dict = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } ] , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . XmonMeasurementGate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } ] , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . XmonMeasurementGate . from_proto_dict ( proto_dict ) [EOL] [EOL] [EOL] def test_single_qubit_measurement_to_proto_dict_convert_invert_mask ( ) : [EOL] gate = cg . XmonMeasurementGate ( [string] , invert_mask = ( True , ) ) [EOL] proto_dict = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } ] , [string] : [string] , [string] : [ [string] ] } } [EOL] assert_proto_dict_convert ( cg . XmonMeasurementGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_multi_qubit_measurement_to_proto_dict ( ) : [EOL] gate = cg . XmonMeasurementGate ( [string] ) [EOL] proto_dict = { [string] : { [string] : [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] , [string] : [string] } } [EOL] assert_proto_dict_convert ( cg . XmonMeasurementGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] @ cirq . testing . only_test_in_python3 def test_measurement_repr ( ) : [EOL] gate = cg . XmonMeasurementGate ( [string] , invert_mask = ( True , ) ) [EOL] assert repr ( gate ) == [string] [EOL] [EOL] [EOL] def test_invalid_measurement_gate ( ) : [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] cg . XmonMeasurementGate ( [string] , invert_mask = ( True , ) ) . to_proto_dict ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] cg . XmonMeasurementGate ( [string] ) . to_proto_dict ( ) [EOL] [EOL] [EOL] def test_z_eq ( ) : [EOL] eq = cirq . testing . EqualsTester ( ) [EOL] eq . make_equality_group ( lambda : cg . ExpZGate ( half_turns = [number] ) ) [EOL] eq . add_equality_group ( cg . ExpZGate ( ) , cg . ExpZGate ( half_turns = [number] ) , cg . ExpZGate ( degs = [number] ) , cg . ExpZGate ( rads = np . pi ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . add_equality_group ( cg . ExpZGate ( half_turns = - [number] ) , cg . ExpZGate ( half_turns = [number] ) ) [EOL] [EOL] [EOL] def test_z_proto_dict_convert ( ) : [EOL] gate = cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } } } [EOL] assert_proto_dict_convert ( cg . ExpZGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] gate = cg . ExpZGate ( half_turns = [number] ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] } } } [EOL] assert_proto_dict_convert ( cg . ExpZGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_z_invalid_dict ( ) : [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpZGate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : { [string] : [string] } } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpZGate . from_proto_dict ( proto_dict ) [EOL] [EOL] [EOL] def test_z_matrix ( ) : [EOL] assert np . allclose ( cirq . unitary ( cg . ExpZGate ( half_turns = [number] ) ) , np . array ( [ [ - [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert np . allclose ( cirq . unitary ( cg . ExpZGate ( half_turns = [number] ) ) , np . array ( [ [ [number] - [number] , [number] ] , [ [number] , [number] + [number] ] ] ) / np . sqrt ( [number] ) ) [EOL] assert np . allclose ( cirq . unitary ( cg . ExpZGate ( half_turns = [number] ) ) , np . array ( [ [ [number] , [number] ] , [ [number] , [number] ] ] ) ) [EOL] assert np . allclose ( cirq . unitary ( cg . ExpZGate ( half_turns = - [number] ) ) , np . array ( [ [ [number] + [number] , [number] ] , [ [number] , [number] - [number] ] ] ) / np . sqrt ( [number] ) ) [EOL] [EOL] [EOL] def test_z_parameterize ( ) : [EOL] parameterized_gate = cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) [EOL] assert parameterized_gate . is_parameterized ( ) [EOL] assert cirq . unitary ( parameterized_gate , None ) is None [EOL] resolver = cirq . ParamResolver ( { [string] : [number] } ) [EOL] resolved_gate = parameterized_gate . with_parameters_resolved_by ( resolver ) [EOL] assert resolved_gate == cg . ExpZGate ( half_turns = [number] ) [EOL] [EOL] [EOL] def test_z_repr ( ) : [EOL] gate = cg . ExpZGate ( half_turns = [number] ) [EOL] assert repr ( gate ) == [string] [EOL] [EOL] [EOL] def test_cz_eq ( ) : [EOL] eq = cirq . testing . EqualsTester ( ) [EOL] eq . make_equality_group ( lambda : cg . Exp11Gate ( half_turns = [number] ) ) [EOL] eq . add_equality_group ( cg . Exp11Gate ( ) , cg . Exp11Gate ( half_turns = [number] ) , cg . Exp11Gate ( degs = [number] ) , cg . Exp11Gate ( rads = np . pi ) ) [EOL] eq . make_equality_group ( lambda : cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . make_equality_group ( lambda : cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . add_equality_group ( cg . Exp11Gate ( half_turns = - [number] ) , cg . Exp11Gate ( half_turns = [number] ) ) [EOL] [EOL] [EOL] def test_cz_proto_dict_convert ( ) : [EOL] gate = cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } } } [EOL] assert_proto_dict_convert ( cg . Exp11Gate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] gate = cg . Exp11Gate ( half_turns = [number] ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] } } } [EOL] assert_proto_dict_convert ( cg . Exp11Gate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_cz_invalid_dict ( ) : [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . Exp11Gate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . Exp11Gate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] , [string] : [number] } , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . Exp11Gate . from_proto_dict ( proto_dict ) [EOL] [EOL] [EOL] def test_cz_potential_implementation ( ) : [EOL] assert cirq . unitary ( cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) , None ) is None [EOL] assert cirq . unitary ( cg . Exp11Gate ( ) ) is not None [EOL] [EOL] [EOL] def test_cz_parameterize ( ) : [EOL] parameterized_gate = cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) [EOL] assert parameterized_gate . is_parameterized ( ) [EOL] assert cirq . unitary ( parameterized_gate , None ) is None [EOL] resolver = cirq . ParamResolver ( { [string] : [number] } ) [EOL] resolved_gate = parameterized_gate . with_parameters_resolved_by ( resolver ) [EOL] assert resolved_gate == cg . Exp11Gate ( half_turns = [number] ) [EOL] [EOL] [EOL] def test_cz_repr ( ) : [EOL] gate = cg . Exp11Gate ( half_turns = [number] ) [EOL] assert repr ( gate ) == [string] [EOL] [EOL] [EOL] def test_w_eq ( ) : [EOL] eq = cirq . testing . EqualsTester ( ) [EOL] eq . add_equality_group ( cg . ExpWGate ( ) , cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) , cg . ExpWGate ( degs = [number] , axis_degs = [number] ) , cg . ExpWGate ( rads = np . pi , axis_rads = [number] ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpWGate ( half_turns = [number] ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpWGate ( half_turns = [number] , axis_half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) , cg . ExpWGate ( half_turns = [number] , axis_rads = np . pi / [number] ) ) [EOL] eq . make_equality_group ( lambda : cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) , axis_half_turns = cirq . Symbol ( [string] ) ) ) [EOL] [EOL] [comment] [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) , cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) ) [EOL] [comment] [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) , axis_half_turns = [number] ) ) [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) , axis_half_turns = [number] ) ) [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = [number] , axis_half_turns = cirq . Symbol ( [string] ) ) ) [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = [number] , axis_half_turns = cirq . Symbol ( [string] ) ) ) [EOL] [EOL] [comment] [EOL] eq . add_equality_group ( cg . ExpWGate ( half_turns = - [number] , axis_half_turns = [number] ) , cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) ) [EOL] [EOL] [EOL] def test_w_str ( ) : [EOL] assert str ( cg . ExpWGate ( ) ) == [string] [EOL] assert str ( cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) ) == [string] [EOL] assert str ( cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) ) == [string] [EOL] assert str ( cg . ExpWGate ( axis_half_turns = [number] , half_turns = [number] ) ) == [string] [EOL] [EOL] [EOL] def test_w_to_proto_dict ( ) : [EOL] gate = cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) , axis_half_turns = [number] ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] } , [string] : { [string] : [string] } } } [EOL] assert_proto_dict_convert ( cg . ExpWGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] gate = cg . ExpWGate ( half_turns = [number] , axis_half_turns = cirq . Symbol ( [string] ) ) [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } , [string] : { [string] : [number] } } } [EOL] assert_proto_dict_convert ( cg . ExpWGate , gate , proto_dict , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_w_invalid_dict ( ) : [EOL] proto_dict = { [string] : { [string] : { [string] : [number] } , [string] : { [string] : [string] } } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpWGate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [string] } } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpWGate . from_proto_dict ( proto_dict ) [EOL] [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , [string] : { [string] : [number] } , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpWGate . from_proto_dict ( proto_dict ) [EOL] [EOL] [EOL] def test_w_decomposition ( ) : [EOL] q = cirq . NamedQubit ( [string] ) [EOL] cirq . testing . assert_allclose_up_to_global_phase ( cirq . Circuit . from_ops ( cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) . on ( q ) ) . to_unitary_matrix ( ) , cirq . Circuit . from_ops ( cirq . Z ( q ) ** - [number] , cirq . X ( q ) ** [number] , cirq . Z ( q ) ** [number] ) . to_unitary_matrix ( ) , atol = [number] ) [EOL] [EOL] [EOL] def test_w_potential_implementation ( ) : [EOL] assert not cirq . can_cast ( cirq . ReversibleEffect , cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) ) ) [EOL] assert cirq . can_cast ( cirq . ReversibleEffect , cg . ExpWGate ( ) ) [EOL] [EOL] [EOL] def test_w_parameterize ( ) : [EOL] parameterized_gate = cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) , axis_half_turns = cirq . Symbol ( [string] ) ) [EOL] assert parameterized_gate . is_parameterized ( ) [EOL] assert cirq . unitary ( parameterized_gate , None ) is None [EOL] resolver = cirq . ParamResolver ( { [string] : [number] , [string] : [number] } ) [EOL] resolved_gate = parameterized_gate . with_parameters_resolved_by ( resolver ) [EOL] assert resolved_gate == cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) [EOL] [EOL] [EOL] def test_w_repr ( ) : [EOL] gate = cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) [EOL] assert repr ( gate ) == [string] [EOL] [EOL] [EOL] def test_trace_bound ( ) : [EOL] assert cg . ExpZGate ( half_turns = [number] ) . trace_distance_bound ( ) < [number] [EOL] assert cg . ExpWGate ( half_turns = [number] ) . trace_distance_bound ( ) < [number] [EOL] assert cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) . trace_distance_bound ( ) >= [number] [EOL] assert cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) ) . trace_distance_bound ( ) >= [number] [EOL] [EOL] [EOL] def test_has_inverse ( ) : [EOL] assert cg . ExpZGate ( half_turns = [number] ) . has_inverse ( ) [EOL] assert cg . ExpWGate ( half_turns = [number] ) . has_inverse ( ) [EOL] assert not cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) . has_inverse ( ) [EOL] assert not cg . ExpWGate ( half_turns = cirq . Symbol ( [string] ) ) . has_inverse ( ) [EOL] [EOL] [EOL] def test_measure_key_on ( ) : [EOL] q = cirq . GridQubit ( [number] , [number] ) [EOL] [EOL] assert cg . XmonMeasurementGate ( key = [string] ) . on ( q ) == cirq . GateOperation ( gate = cg . XmonMeasurementGate ( key = [string] ) , qubits = ( q , ) ) [EOL] assert cg . XmonMeasurementGate ( key = [string] ) . on ( q ) == cirq . GateOperation ( gate = cg . XmonMeasurementGate ( key = [string] ) , qubits = ( q , ) ) [EOL] [EOL] [EOL] def test_unsupported_op ( ) : [EOL] proto_dict = { [string] : { [string] : { [string] : [number] , [string] : [number] } , } } [EOL] with pytest . raises ( ValueError ) : [EOL] cg . XmonGate . from_proto_dict ( proto_dict ) [EOL] [EOL] [EOL] def test_invalid_to_proto_dict_qubit_number ( ) : [EOL] with pytest . raises ( ValueError ) : [EOL] cg . Exp11Gate ( half_turns = [number] ) . to_proto_dict ( cirq . GridQubit ( [number] , [number] ) ) [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpZGate ( half_turns = [number] ) . to_proto_dict ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] with pytest . raises ( ValueError ) : [EOL] cg . ExpWGate ( half_turns = [number] , axis_half_turns = [number] ) . to_proto_dict ( cirq . GridQubit ( [number] , [number] ) , cirq . GridQubit ( [number] , [number] ) ) [EOL] [EOL] [EOL] def test_cirq_symbol_diagrams ( ) : [EOL] q00 = cirq . GridQubit ( [number] , [number] ) [EOL] q01 = cirq . GridQubit ( [number] , [number] ) [EOL] c = cirq . Circuit . from_ops ( cg . ExpWGate ( axis_half_turns = cirq . Symbol ( [string] ) , half_turns = cirq . Symbol ( [string] ) ) . on ( q00 ) , cg . ExpZGate ( half_turns = cirq . Symbol ( [string] ) ) . on ( q01 ) , cg . Exp11Gate ( half_turns = cirq . Symbol ( [string] ) ) . on ( q00 , q01 ) , ) [EOL] assert c . to_text_diagram ( ) == [string] . strip ( ) [EOL] [EOL] [EOL] def test_z_diagram_chars ( ) : [EOL] q = cirq . GridQubit ( [number] , [number] ) [EOL] c = cirq . Circuit . from_ops ( cg . ExpZGate ( ) . on ( q ) , cg . ExpZGate ( half_turns = [number] ) . on ( q ) , cg . ExpZGate ( half_turns = [number] ) . on ( q ) , cg . ExpZGate ( half_turns = [number] ) . on ( q ) , cg . ExpZGate ( half_turns = - [number] ) . on ( q ) , cg . ExpZGate ( half_turns = - [number] ) . on ( q ) , ) [EOL] assert c . to_text_diagram ( ) == [string] . strip ( ) [EOL] [EOL] [EOL] def test_w_diagram_chars ( ) : [EOL] q = cirq . GridQubit ( [number] , [number] ) [EOL] c = cirq . Circuit . from_ops ( cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) , cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) , cg . ExpWGate ( axis_half_turns = [number] ) . on ( q ) , cg . ExpWGate ( axis_half_turns = cirq . Symbol ( [string] ) ) . on ( q ) , ) [EOL] assert c . to_text_diagram ( ) == [string] . strip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from cirq import ops [EOL] from cirq . extension import Extensions [EOL] from cirq . google import xmon_gates [EOL] [EOL] [EOL] xmon_gate_ext = Extensions ( ) [EOL] [EOL] xmon_gate_ext . add_cast ( desired_type = xmon_gates . XmonGate , actual_type = ops . RotXGate , conversion = lambda e : xmon_gates . ExpWGate ( half_turns = e . half_turns , axis_half_turns = [number] ) ) [EOL] [EOL] xmon_gate_ext . add_cast ( desired_type = xmon_gates . XmonGate , actual_type = ops . RotYGate , conversion = lambda e : xmon_gates . ExpWGate ( half_turns = e . half_turns , axis_half_turns = [number] ) ) [EOL] [EOL] xmon_gate_ext . add_cast ( desired_type = xmon_gates . XmonGate , actual_type = ops . RotZGate , conversion = lambda e : xmon_gates . ExpZGate ( half_turns = e . half_turns ) ) [EOL] [EOL] xmon_gate_ext . add_cast ( desired_type = xmon_gates . XmonGate , actual_type = ops . Rot11Gate , conversion = lambda e : xmon_gates . Exp11Gate ( half_turns = e . half_turns ) ) [EOL] [EOL] xmon_gate_ext . add_cast ( desired_type = xmon_gates . XmonGate , actual_type = ops . MeasurementGate , conversion = lambda e : xmon_gates . XmonMeasurementGate ( key = e . key , invert_mask = e . invert_mask ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Union , Any , Dict , List [EOL] import typing [EOL] import pytest [EOL] [EOL] from cirq . google import params [EOL] from cirq . study . sweeps import Linspace , Points , Product , UnitSweep , Zip [EOL] [EOL] [EOL] def test_gen_sweep_points ( ) : [EOL] points = [ [number] , [number] , [number] , [number] , [number] ] [EOL] sweep = { [string] : [string] , [string] : { [string] : list ( points ) } } [EOL] out = params . _sweep_from_single_param_sweep_proto_dict ( sweep ) [EOL] assert out == Points ( [string] , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] def test_gen_sweep_linspace ( ) : [EOL] sweep = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] out = params . _sweep_from_single_param_sweep_proto_dict ( sweep ) [EOL] assert out == Linspace ( [string] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_gen_param_sweep_zip ( ) : [EOL] s1 = { [string] : [string] , [string] : { [string] : [ [number] , [number] , [number] ] } } [EOL] s2 = { [string] : [string] , [string] : { [string] : [ [number] , [number] ] } } [EOL] sweep = { [string] : [ s1 , s2 ] } [EOL] out = params . _sweep_from_param_sweep_zip_proto_dict ( sweep ) [EOL] assert out == Points ( [string] , [ [number] , [number] , [number] ] ) + Points ( [string] , [ [number] , [number] ] ) [EOL] [EOL] [EOL] def test_gen_empty_param_sweep ( ) : [EOL] out = params . sweep_from_proto_dict ( { } ) [EOL] assert out == UnitSweep [EOL] [EOL] [EOL] def test_gen_param_sweep ( ) : [EOL] s1 = { [string] : [string] , [string] : { [string] : [ [number] , [number] , [number] ] } } [EOL] s2 = { [string] : [string] , [string] : { [string] : [ [number] , [number] ] } } [EOL] ps = { [string] : { [string] : [ { [string] : [ s1 ] } , { [string] : [ s2 ] } ] } } [EOL] out = params . sweep_from_proto_dict ( ps ) [EOL] assert out == Product ( Zip ( Points ( [string] , [ [number] , [number] , [number] ] ) ) , Zip ( Points ( [string] , [ [number] , [number] ] ) ) ) [EOL] [EOL] [EOL] def test_empty_param_sweep_keys ( ) : [EOL] assert params . sweep_from_proto_dict ( { } ) . keys == [ ] [EOL] [EOL] [EOL] def test_sweep_from_proto_dict_missing_type ( ) : [EOL] s1 = { [string] : [string] , } [EOL] ps = { [string] : { [string] : [ { [string] : [ s1 ] } , ] } } [EOL] with pytest . raises ( ValueError ) : [EOL] params . sweep_from_proto_dict ( ps ) [EOL] [EOL] [EOL] def test_param_sweep_keys ( ) : [EOL] s11 = { [string] : [string] , [string] : { [string] : range ( [number] ) } , } [EOL] s12 = { [string] : [string] , [string] : { [string] : range ( [number] ) } , } [EOL] [EOL] s21 = { [string] : [string] , [string] : { [string] : range ( [number] ) } , } [EOL] s22 = { [string] : [string] , [string] : { [string] : range ( [number] ) } } [EOL] ps = { [string] : { [string] : [ { [string] : [ s11 , s12 ] , } , { [string] : [ s21 , s22 ] } ] } } [EOL] out = params . sweep_from_proto_dict ( ps ) [EOL] assert out . keys == [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_empty_param_sweep_size ( ) : [EOL] assert len ( params . sweep_from_proto_dict ( { } ) ) == [number] [EOL] [EOL] [EOL] def test_param_sweep_size ( ) : [EOL] s11 = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] s12 = { [string] : [string] , [string] : { [string] : range ( [number] ) } } [EOL] s21 = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] s22 = { [string] : [string] , [string] : { [string] : range ( [number] ) } } [EOL] ps = { [string] : { [string] : [ { [string] : [ s11 , s12 ] , } , { [string] : [ s21 , s22 ] } ] } } [EOL] [comment] [EOL] [comment] [EOL] assert len ( params . sweep_from_proto_dict ( ps ) ) == [number] * [number] [EOL] [EOL] [EOL] def test_param_sweep_size_no_sweeps ( ) : [EOL] ps = { [string] : { [string] : [ { } , { } ] } } [EOL] assert len ( params . sweep_from_proto_dict ( ps ) ) == [number] [EOL] [EOL] [EOL] def example_sweeps ( ) : [EOL] empty_sweep = { } [EOL] empty_product = { [string] : { } } [EOL] empty_zip = { [string] : { [string] : [ { } , { } ] } } [EOL] s11 = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] s12 = { [string] : [string] , [string] : { [string] : range ( [number] ) } } [EOL] s21 = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] } } [EOL] s22 = { [string] : [string] , [string] : { [string] : range ( [number] ) } } [EOL] full_sweep = { [string] : { [string] : [ { [string] : [ s11 , s12 ] , } , { [string] : [ s21 , s22 ] } ] } } [EOL] return [ empty_sweep , empty_product , empty_zip , full_sweep ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , example_sweeps ( ) ) def test_param_sweep_size_versus_gen ( param_sweep ) : [EOL] sweep = params . sweep_from_proto_dict ( param_sweep ) [EOL] print ( sweep ) [EOL] predicted_size = len ( sweep ) [EOL] out = list ( sweep ) [EOL] assert len ( out ) == predicted_size [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( UnitSweep , UnitSweep ) , ( Linspace ( [string] , [number] , [number] , [number] ) , Product ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) ) ) ) , ( Points ( [string] , [ [number] , [number] , [number] ] ) , Product ( Zip ( Points ( [string] , [ [number] , [number] , [number] ] ) ) ) ) , ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Product ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) ) , ) , ( Product ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Product ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) ) , Zip ( Points ( [string] , [ [number] , [number] , [number] ] ) ) ) , ) , ( Product ( Zip ( Points ( [string] , [ [number] , [number] , [number] ] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Linspace ( [string] , [number] , [number] , [number] ) , ) , Product ( Zip ( Points ( [string] , [ [number] , [number] , [number] ] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Zip ( Linspace ( [string] , [number] , [number] , [number] ) ) , ) , ) , ( Product ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] , [number] ] ) ) , ) , Product ( Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] ] ) ) , Zip ( Linspace ( [string] , [number] , [number] , [number] ) , Points ( [string] , [ [number] , [number] , [number] , [number] ] ) ) , ) , ) , ] ) [EOL] [EOL] def test_sweep_to_proto_dict ( sweep , expected ) : [EOL] proto = params . sweep_to_proto_dict ( sweep ) [EOL] out = params . sweep_from_proto_dict ( proto ) [EOL] assert out == expected [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ Zip ( Product ( Linspace ( [string] , [number] , [number] , [number] ) , Linspace ( [string] , [number] , [number] , [number] ) ) ) , ] ) def test_sweep_to_proto_fail ( bad_sweep ) : [EOL] with pytest . raises ( ValueError ) : [EOL] params . sweep_to_proto_dict ( bad_sweep ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from cirq . google . sim . xmon_simulator import ( XmonOptions , XmonSimulator , XmonStepResult , XmonSimulateTrialResult , ) [EOL] from cirq . google . sim . xmon_stepper import ( Stepper , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from cirq . google . engine . engine import ( Engine , JobConfig , ) [EOL] [EOL] from cirq . google . engine . env_config import ( engine_from_environment , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import os [EOL] import pytest [EOL] from apiclient import discovery [EOL] [EOL] import cirq [EOL] from cirq . testing . mock import mock [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_engine_from_environment ( build ) : [EOL] [comment] [EOL] with mock . patch . dict ( os . environ , { [string] : [string] } , clear = True ) : [EOL] eng = cirq . google . engine_from_environment ( ) [EOL] assert eng . default_project_id is None [EOL] assert eng . api_key == [string] [EOL] [EOL] [comment] [EOL] with mock . patch . dict ( os . environ , { } , clear = True ) : [EOL] with pytest . raises ( EnvironmentError , match = [string] ) : [EOL] _ = cirq . google . engine_from_environment ( ) [EOL] [EOL] [comment] [EOL] with mock . patch . dict ( os . environ , { [string] : [string] } , clear = True ) : [EOL] with pytest . raises ( EnvironmentError , match = [string] ) : [EOL] _ = cirq . google . engine_from_environment ( ) [EOL] [EOL] [comment] [EOL] with mock . patch . dict ( os . environ , { [string] : [string] , [string] : [string] , } , clear = True ) : [EOL] eng = cirq . google . engine_from_environment ( ) [EOL] assert eng . default_project_id == [string] [EOL] assert eng . api_key == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Union , Any , Dict , List [EOL] import unittest [EOL] import typing [EOL] [docstring] [EOL] import base64 [EOL] import re [EOL] [EOL] import numpy as np [EOL] import pytest [EOL] [EOL] from apiclient import discovery [EOL] [EOL] import cirq [EOL] import cirq . google as cg [EOL] from cirq . testing . mock import mock [EOL] [EOL] [EOL] _A_RESULT = { [string] : [ { [string] : [number] , [string] : [ { [string] : [string] , [string] : [ { [string] : [number] , [string] : [number] } ] } ] , [string] : [ { [string] : { [string] : { [string] : [number] } } , [string] : base64 . b64encode ( [string] ) } ] } ] } [EOL] [EOL] [EOL] _RESULTS = { [string] : [ { [string] : [number] , [string] : [ { [string] : [string] , [string] : [ { [string] : [number] , [string] : [number] } ] } ] , [string] : [ { [string] : { [string] : { [string] : [number] } } , [string] : base64 . b64encode ( [string] ) } , { [string] : { [string] : { [string] : [number] } } , [string] : base64 . b64encode ( [string] ) } ] } ] } [EOL] [EOL] [EOL] @ cirq . testing . only_test_in_python3 def test_repr ( ) : [EOL] v = cirq . google . JobConfig ( project_id = [string] , program_id = [string] , job_id = [string] ) [EOL] [EOL] assert repr ( v ) == ( [string] [string] [string] [string] ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_run_circuit ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . getResult ( ) . execute . return_value = { [string] : _A_RESULT } [EOL] [EOL] result = cg . Engine ( api_key = [string] ) . run ( program = cirq . Circuit ( ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) ) [EOL] assert result . repetitions == [number] [EOL] assert result . params . param_dict == { [string] : [number] } [EOL] assert result . measurements == { [string] : np . array ( [ [ [number] ] ] , dtype = [string] ) } [EOL] build . assert_called_with ( [string] , [string] , discoveryServiceUrl = ( [string] [string] [string] ) ) [EOL] assert programs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] assert jobs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] assert jobs . get ( ) . execute . call_count == [number] [EOL] assert jobs . getResult ( ) . execute . call_count == [number] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_circuit_device_validation_fails ( build ) : [EOL] circuit = cirq . Circuit ( device = cg . Foxtail ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] circuit . _moments . append ( cirq . Moment ( [ cg . ExpZGate ( ) . on ( cirq . NamedQubit ( [string] ) ) ] ) ) [EOL] [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] cg . Engine ( api_key = [string] ) . run ( program = circuit , job_config = cg . JobConfig ( [string] ) ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_schedule_device_validation_fails ( build ) : [EOL] scheduled_op = cirq . ScheduledOperation ( time = None , duration = None , operation = cirq . H . on ( cirq . NamedQubit ( [string] ) ) ) [EOL] schedule = cirq . Schedule ( device = cg . Foxtail , scheduled_operations = [ scheduled_op ] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] cg . Engine ( api_key = [string] ) . run ( program = schedule , job_config = cg . JobConfig ( [string] ) ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_circuit_device_validation_passes_non_xmon_gate ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . getResult ( ) . execute . return_value = { [string] : _A_RESULT } [EOL] [EOL] circuit = cirq . Circuit . from_ops ( cirq . H . on ( cirq . GridQubit ( [number] , [number] ) ) , device = cg . Foxtail ) [EOL] result = cg . Engine ( api_key = [string] ) . run ( program = circuit , job_config = cg . JobConfig ( [string] ) ) [EOL] assert result . repetitions == [number] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_unsupported_program_type ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] with pytest . raises ( TypeError , match = [string] ) : [EOL] eng . run ( program = [string] , job_config = cg . JobConfig ( [string] ) ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_run_circuit_failed ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] with pytest . raises ( RuntimeError , match = [string] ) : [EOL] cg . Engine ( api_key = [string] ) . run ( program = cirq . Circuit ( ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_default_prefix ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . getResult ( ) . execute . return_value = { [string] : _A_RESULT } [EOL] [EOL] result = cg . Engine ( api_key = [string] ) . run ( program = cirq . Circuit ( ) , job_config = cg . JobConfig ( [string] ) ) [EOL] assert result . repetitions == [number] [EOL] assert result . params . param_dict == { [string] : [number] } [EOL] assert result . measurements == { [string] : np . array ( [ [ [number] ] ] , dtype = [string] ) } [EOL] build . assert_called_with ( [string] , [string] , discoveryServiceUrl = ( [string] [string] [string] ) ) [EOL] assert programs . create . call_args [ [number] ] [ [string] ] [ [string] ] [ [string] ] . startswith ( [string] ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_run_sweep_params ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . getResult ( ) . execute . return_value = { [string] : _RESULTS } [EOL] [EOL] job = cg . Engine ( api_key = [string] ) . run_sweep ( program = cirq . moment_by_moment_schedule ( cirq . UnconstrainedDevice , cirq . Circuit ( ) ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) , params = [ cirq . ParamResolver ( { [string] : [number] } ) , cirq . ParamResolver ( { [string] : [number] } ) ] ) [EOL] results = job . results ( ) [EOL] assert len ( results ) == [number] [EOL] for i , v in enumerate ( [ [number] , [number] ] ) : [EOL] assert results [ i ] . repetitions == [number] [EOL] assert results [ i ] . params . param_dict == { [string] : v } [EOL] assert results [ i ] . measurements == { [string] : np . array ( [ [ [number] ] ] , dtype = [string] ) } [EOL] build . assert_called_with ( [string] , [string] , discoveryServiceUrl = ( [string] [string] [string] ) ) [EOL] assert programs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] sweeps = programs . create . call_args [ [number] ] [ [string] ] [ [string] ] [ [string] ] [EOL] assert len ( sweeps ) == [number] [EOL] for i , v in enumerate ( [ [number] , [number] ] ) : [EOL] assert sweeps [ i ] [ [string] ] == [number] [EOL] assert sweeps [ i ] [ [string] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [ v ] [EOL] assert jobs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] assert jobs . get ( ) . execute . call_count == [number] [EOL] assert jobs . getResult ( ) . execute . call_count == [number] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_run_sweep_sweeps ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . getResult ( ) . execute . return_value = { [string] : _RESULTS } [EOL] [EOL] job = cg . Engine ( api_key = [string] ) . run_sweep ( program = cirq . moment_by_moment_schedule ( cirq . UnconstrainedDevice , cirq . Circuit ( ) ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) , params = cirq . Points ( [string] , [ [number] , [number] ] ) ) [EOL] results = job . results ( ) [EOL] assert len ( results ) == [number] [EOL] for i , v in enumerate ( [ [number] , [number] ] ) : [EOL] assert results [ i ] . repetitions == [number] [EOL] assert results [ i ] . params . param_dict == { [string] : v } [EOL] assert results [ i ] . measurements == { [string] : np . array ( [ [ [number] ] ] , dtype = [string] ) } [EOL] build . assert_called_with ( [string] , [string] , discoveryServiceUrl = ( [string] [string] [string] ) ) [EOL] assert programs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] sweeps = programs . create . call_args [ [number] ] [ [string] ] [ [string] ] [ [string] ] [EOL] assert len ( sweeps ) == [number] [EOL] assert sweeps [ [number] ] [ [string] ] == [number] [EOL] assert sweeps [ [number] ] [ [string] ] [ [string] ] [ [number] ] [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [ [number] , [number] ] [EOL] assert jobs . create . call_args [ [number] ] [ [string] ] == [string] [EOL] assert jobs . get ( ) . execute . call_count == [number] [EOL] assert jobs . getResult ( ) . execute . call_count == [number] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_bad_priority ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] eng . run ( program = cirq . Circuit ( ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) , priority = [number] ) [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_cancel ( build ) : [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] jobs = programs . jobs ( ) [EOL] programs . create ( ) . execute . return_value = { [string] : [string] } [EOL] jobs . create ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] jobs . get ( ) . execute . return_value = { [string] : [string] , [string] : { [string] : [string] } } [EOL] [EOL] job = cg . Engine ( api_key = [string] ) . run_sweep ( program = cirq . Circuit ( ) , job_config = cg . JobConfig ( [string] , gcs_prefix = [string] ) ) [EOL] job . cancel ( ) [EOL] assert job . job_resource_name == ( [string] [string] ) [EOL] assert job . status ( ) == [string] [EOL] assert jobs . cancel . call_args [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_program_labels ( build ) : [EOL] program_name = [string] [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] programs = service . projects ( ) . programs ( ) [EOL] engine = cg . Engine ( api_key = [string] ) [EOL] [EOL] def body ( ) : [EOL] return programs . patch . call_args [ [number] ] [ [string] ] [EOL] [EOL] programs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } } [EOL] engine . add_program_labels ( program_name , { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert body ( ) [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] programs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] engine . set_program_labels ( program_name , { [string] : [string] , [string] : [string] } ) [EOL] assert body ( ) [ [string] ] == { [string] : [string] , [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] programs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] engine . remove_program_labels ( program_name , [ [string] , [string] ] ) [EOL] assert body ( ) [ [string] ] == { [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_job_labels ( build ) : [EOL] job_name = [string] [EOL] service = mock . Mock ( ) [EOL] build . return_value = service [EOL] jobs = service . projects ( ) . programs ( ) . jobs ( ) [EOL] engine = cg . Engine ( api_key = [string] ) [EOL] [EOL] def body ( ) : [EOL] return jobs . patch . call_args [ [number] ] [ [string] ] [EOL] [EOL] jobs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } } [EOL] engine . add_job_labels ( job_name , { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert body ( ) [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] jobs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] engine . set_job_labels ( job_name , { [string] : [string] , [string] : [string] } ) [EOL] assert body ( ) [ [string] ] == { [string] : [string] , [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] jobs . get ( ) . execute . return_value = { [string] : { [string] : [string] , [string] : [string] } , [string] : [string] } [EOL] engine . remove_job_labels ( job_name , [ [string] , [string] ] ) [EOL] assert body ( ) [ [string] ] == { [string] : [string] } [EOL] assert body ( ) [ [string] ] == [string] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_implied_job_config_project_id ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] _ = eng . implied_job_config ( None ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] _ = eng . implied_job_config ( cg . JobConfig ( ) ) [EOL] assert eng . implied_job_config ( cg . JobConfig ( project_id = [string] ) ) . project_id == [string] [EOL] [EOL] eng_with = cg . Engine ( api_key = [string] , default_project_id = [string] ) [EOL] [EOL] [comment] [EOL] assert eng_with . implied_job_config ( None ) . project_id == [string] [EOL] [EOL] [comment] [EOL] assert eng_with . implied_job_config ( cg . JobConfig ( project_id = [string] ) ) . project_id == [string] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_implied_job_config_gcs_prefix ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] config = cg . JobConfig ( project_id = [string] ) [EOL] [EOL] [comment] [EOL] assert eng . implied_job_config ( config ) . gcs_prefix == [string] [EOL] [EOL] [comment] [EOL] eng_with_bad = cg . Engine ( api_key = [string] , default_gcs_prefix = [string] ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] _ = eng_with_bad . implied_job_config ( config ) [EOL] [EOL] [comment] [EOL] eng_with = cg . Engine ( api_key = [string] , default_gcs_prefix = [string] ) [EOL] assert eng_with . implied_job_config ( config ) . gcs_prefix == [string] [EOL] [EOL] [comment] [EOL] eng_with = cg . Engine ( api_key = [string] , default_gcs_prefix = [string] ) [EOL] assert eng_with . implied_job_config ( config ) . gcs_prefix == [string] [EOL] [EOL] [comment] [EOL] config . gcs_prefix = [string] [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] _ = eng . implied_job_config ( config ) [EOL] with pytest . raises ( ValueError , match = [string] ) : [EOL] _ = eng_with_bad . implied_job_config ( config ) [EOL] [EOL] [comment] [EOL] config . gcs_prefix = [string] [EOL] assert eng . implied_job_config ( config ) . gcs_prefix == [string] [EOL] assert eng_with . implied_job_config ( config ) . gcs_prefix == [string] [EOL] [EOL] [comment] [EOL] config . gcs_prefix = [string] [EOL] assert eng . implied_job_config ( config ) . gcs_prefix == [string] [EOL] assert eng_with . implied_job_config ( config ) . gcs_prefix == [string] [EOL] [EOL] [EOL] @ cirq . testing . only_test_in_python3 @ mock . patch . object ( discovery , [string] ) def test_implied_job_config ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] [EOL] [comment] [EOL] implied = eng . implied_job_config ( cg . JobConfig ( project_id = [string] ) ) [EOL] assert implied . project_id == [string] [EOL] assert re . fullmatch ( [string] , implied . program_id ) [EOL] assert implied . job_id == [string] [EOL] assert implied . gcs_prefix == [string] [EOL] assert re . fullmatch ( [string] , implied . gcs_program ) [EOL] assert re . fullmatch ( [string] , implied . gcs_results ) [EOL] [EOL] [comment] [EOL] implied = eng . implied_job_config ( cg . JobConfig ( project_id = [string] , program_id = [string] ) ) [EOL] assert implied . project_id == [string] [EOL] assert implied . program_id == [string] [EOL] assert implied . job_id == [string] [EOL] assert implied . gcs_prefix == [string] [EOL] assert implied . gcs_program == [string] [EOL] assert implied . gcs_results == [string] [EOL] [EOL] [comment] [EOL] implied = eng . implied_job_config ( cg . JobConfig ( project_id = [string] , program_id = [string] , job_id = [string] , gcs_prefix = [string] , gcs_program = [string] , gcs_results = [string] ) ) [EOL] assert implied . project_id == [string] [EOL] assert implied . program_id == [string] [EOL] assert implied . job_id == [string] [EOL] assert implied . gcs_prefix == [string] [EOL] assert implied . gcs_program == [string] [EOL] assert implied . gcs_results == [string] [EOL] [EOL] [EOL] @ mock . patch . object ( discovery , [string] ) def test_bad_job_config_inference_order ( build ) : [EOL] eng = cg . Engine ( api_key = [string] ) [EOL] config = cg . JobConfig ( ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] eng . _infer_gcs_prefix ( config ) [EOL] config . project_id = [string] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] eng . _infer_gcs_results ( config ) [EOL] with pytest . raises ( ValueError ) : [EOL] eng . _infer_gcs_program ( config ) [EOL] eng . _infer_gcs_prefix ( config ) [EOL] [EOL] eng . _infer_gcs_results ( config ) [EOL] eng . _infer_gcs_program ( config ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Set [EOL] import cirq [EOL] import typing [EOL] import builtins [EOL] import networkx [EOL] [EOL] from cirq import circuits , linalg [EOL] from cirq . contrib . paulistring . pauli_string_raw_types import ( PauliStringGateOperation ) [EOL] from cirq . contrib . paulistring . pauli_string_dag import ( pauli_string_dag_from_circuit ) [EOL] from cirq . contrib . paulistring . separate import ( convert_and_separate_circuit ) [EOL] from cirq . contrib . paulistring . recombine import ( move_pauli_strings_into_circuit ) [EOL] [EOL] [EOL] def pauli_string_optimized_circuit ( circuit , move_cliffords = True , tolerance = [number] ) : [EOL] cl , cr = convert_and_separate_circuit ( circuit , leave_cliffords = not move_cliffords , tolerance = tolerance ) [EOL] string_dag = pauli_string_dag_from_circuit ( cl ) [EOL] [EOL] [comment] [EOL] while True : [EOL] before_len = len ( string_dag . nodes ( ) ) [EOL] merge_equal_strings ( string_dag ) [EOL] remove_negligible_strings ( string_dag ) [EOL] if len ( string_dag . nodes ( ) ) >= before_len : [EOL] break [EOL] [EOL] c_all = move_pauli_strings_into_circuit ( string_dag , cr ) [EOL] [EOL] assert_no_multi_qubit_pauli_strings ( c_all ) [EOL] [EOL] return c_all [EOL] [EOL] [EOL] def assert_no_multi_qubit_pauli_strings ( circuit ) : [EOL] for op in circuit . all_operations ( ) : [EOL] if isinstance ( op , PauliStringGateOperation ) : [EOL] assert len ( op . pauli_string ) == [number] , ( [string] ) [EOL] [EOL] [EOL] def merge_equal_strings ( string_dag ) : [EOL] for node in tuple ( string_dag . nodes ( ) ) : [EOL] if node not in string_dag . nodes ( ) : [EOL] [comment] [EOL] continue [EOL] commuting_nodes = ( set ( string_dag . nodes ( ) ) - set ( networkx . dag . ancestors ( string_dag , node ) ) - set ( networkx . dag . descendants ( string_dag , node ) ) - set ( [ node ] ) ) [EOL] for other_node in commuting_nodes : [EOL] if node . val . pauli_string . equal_up_to_sign ( other_node . val . pauli_string ) : [EOL] string_dag . remove_node ( other_node ) [EOL] node . val = node . val . merged_with ( other_node . val ) [EOL] [EOL] [EOL] def remove_negligible_strings ( string_dag , tolerance = linalg . Tolerance . DEFAULT ) : [EOL] for node in tuple ( string_dag . nodes ( ) ) : [EOL] if tolerance . all_near_zero_mod ( node . val . half_turns , [number] ) : [EOL] string_dag . remove_node ( node ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import cirq [EOL] [docstring] [EOL] [EOL] from cirq . circuits . circuit import Circuit [EOL] from cirq . circuits . optimization_pass import OptimizationPass [EOL] [EOL] [EOL] class DropEmptyMoments ( OptimizationPass ) : [EOL] [docstring] [EOL] [EOL] def optimize_circuit ( self , circuit ) : [EOL] circuit [ : ] = ( m for m in circuit if m . operations ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import cirq [EOL] [EOL] [EOL] def test_repr ( ) : [EOL] assert repr ( cirq . InsertStrategy . NEW ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Sequence , Any , TypeVar , Iterable , Callable [EOL] import cirq [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Any , Iterable , TypeVar , Callable , Sequence [EOL] [EOL] from cirq import ops [EOL] [EOL] TSelf_Moment = TypeVar ( [string] , bound = [string] ) [EOL] [EOL] class Moment ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , operations = ( ) ) : [EOL] [docstring] [EOL] self . operations = tuple ( operations ) [EOL] [EOL] [comment] [EOL] affected_qubits = [ q for op in self . operations for q in op . qubits ] [EOL] self . qubits = frozenset ( affected_qubits ) [EOL] if len ( affected_qubits ) != len ( self . qubits ) : [EOL] raise ValueError ( [string] . format ( self . operations ) ) [EOL] [EOL] def operates_on ( self , qubits ) : [EOL] [docstring] [EOL] qubits = frozenset ( qubits ) [EOL] return any ( q in qubits for op in self . operations for q in op . qubits ) [EOL] [EOL] def with_operation ( self , operation ) : [EOL] [docstring] [EOL] return Moment ( self . operations + ( operation , ) ) [EOL] [EOL] def without_operations_touching ( self , qubits ) : [EOL] [docstring] [EOL] qubits = frozenset ( qubits ) [EOL] if not self . operates_on ( qubits ) : [EOL] return self [EOL] return Moment ( operation for operation in self . operations if qubits . isdisjoint ( frozenset ( operation . qubits ) ) ) [EOL] [EOL] def __copy__ ( self ) : [EOL] return type ( self ) ( self . operations ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , type ( self ) ) : [EOL] return NotImplemented [EOL] return self . operations == other . operations [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( Moment , self . operations ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] if not self . operations : [EOL] return [string] [EOL] return [string] . format ( _list_repr_with_indented_item_lines ( self . operations ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . join ( str ( op ) for op in self . operations ) [EOL] [EOL] def transform_qubits ( self , func ) : [EOL] return self . __class__ ( op . transform_qubits ( func ) for op in self . operations ) [EOL] [EOL] [EOL] def _list_repr_with_indented_item_lines ( items ) : [EOL] block = [string] . join ( [ repr ( op ) + [string] for op in items ] ) [EOL] indented = [string] + [string] . join ( block . split ( [string] ) ) [EOL] return [string] . format ( indented ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 $builtins.frozenset[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $TSelf_Moment$ 0 $TSelf_Moment$ 0 $typing.Callable[[cirq.ops.QubitId],cirq.ops.QubitId]$ 0 0 0 0 $TSelf_Moment$ 0 0 0 0 0 0 0 $typing.Callable[[cirq.ops.QubitId],cirq.ops.QubitId]$ 0 0 0 0 $TSelf_Moment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Iterable , Optional [EOL] import cirq [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Callable , Iterable , Optional , Sequence , TYPE_CHECKING [EOL] [EOL] from collections import defaultdict [EOL] [EOL] from cirq import abc , ops [EOL] from cirq . circuits . circuit import Circuit [EOL] [EOL] if TYPE_CHECKING : [EOL] [comment] [EOL] from cirq . ops import QubitId [EOL] from typing import Dict [EOL] [EOL] [EOL] class OptimizationPass : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def optimize_circuit ( self , circuit ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class PointOptimizationSummary : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , clear_span , clear_qubits , new_operations ) : [EOL] [docstring] [EOL] self . new_operations = tuple ( ops . flatten_op_tree ( new_operations ) ) [EOL] self . clear_span = clear_span [EOL] self . clear_qubits = tuple ( clear_qubits ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if not isinstance ( other , type ( self ) ) : [EOL] return NotImplemented [EOL] return ( self . clear_span == other . clear_span and self . clear_qubits == other . clear_qubits and self . new_operations == other . new_operations ) [EOL] [EOL] def __ne__ ( self , other ) : [EOL] return not self == other [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( PointOptimizationSummary , self . clear_span , self . clear_qubits , self . new_operations ) ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . clear_span , self . clear_qubits , self . new_operations ) [EOL] [EOL] [EOL] class PointOptimizer ( OptimizationPass ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , post_clean_up = lambda op_list : op_list ) : [EOL] [docstring] [EOL] self . post_clean_up = post_clean_up [EOL] [EOL] @ abc . abstractmethod def optimization_at ( self , circuit , index , op ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def optimize_circuit ( self , circuit ) : [EOL] frontier = defaultdict ( lambda : [number] ) [comment] [EOL] i = [number] [EOL] while i < len ( circuit ) : [comment] [EOL] for op in circuit [ i ] . operations : [EOL] [comment] [EOL] if any ( frontier [ q ] > i for q in op . qubits ) : [EOL] continue [EOL] [EOL] [comment] [EOL] if i >= len ( circuit ) : [EOL] continue [EOL] [comment] [EOL] if op not in circuit [ i ] . operations : [EOL] continue [EOL] opt = self . optimization_at ( circuit , i , op ) [EOL] [comment] [EOL] if opt is None : [EOL] continue [EOL] [EOL] [comment] [EOL] circuit . clear_operations_touching ( opt . clear_qubits , [ e for e in range ( i , i + opt . clear_span ) ] ) [EOL] new_operations = self . post_clean_up ( opt . new_operations ) [EOL] circuit . insert_at_frontier ( new_operations , i , frontier ) [EOL] [EOL] i += [number] [EOL] [EOL] def __call__ ( self , circuit ) : [EOL] return self . optimize_circuit ( circuit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PointOptimizationSummary]$ 0 0 0 $cirq.circuits.circuit.Circuit$ 0 $builtins.int$ 0 $cirq.ops.Operation$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0 0 0 0 0 0 0 $cirq.circuits.circuit.Circuit$ 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0