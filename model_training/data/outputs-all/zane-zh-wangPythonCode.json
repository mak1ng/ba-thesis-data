	0
	0
	0
[comment] [EOL] alphabet_size = [number] [EOL] [comment] [EOL] modulus = [number] [EOL] [EOL] [EOL] def rabin_karp ( pattern , text ) : [EOL] [docstring] [EOL] p_len = len ( pattern ) [EOL] t_len = len ( text ) [EOL] if p_len > t_len : [EOL] return False [EOL] [EOL] p_hash = [number] [EOL] text_hash = [number] [EOL] modulus_power = [number] [EOL] [EOL] [comment] [EOL] for i in range ( p_len ) : [EOL] p_hash = ( ord ( pattern [ i ] ) + p_hash * alphabet_size ) % modulus [EOL] text_hash = ( ord ( text [ i ] ) + text_hash * alphabet_size ) % modulus [EOL] if i == p_len - [number] : [EOL] continue [EOL] modulus_power = ( modulus_power * alphabet_size ) % modulus [EOL] [EOL] for i in range ( [number] , t_len - p_len + [number] ) : [EOL] if text_hash == p_hash and text [ i : i + p_len ] == pattern : [EOL] return True [EOL] if i == t_len - p_len : [EOL] continue [EOL] [comment] [EOL] text_hash = ( ( text_hash - ord ( text [ i ] ) * modulus_power ) * alphabet_size + ord ( text [ i + p_len ] ) ) % modulus [EOL] return False [EOL] [EOL] [EOL] def test_rabin_karp ( ) : [EOL] [docstring] [EOL] [comment] [EOL] pattern = [string] [EOL] text1 = [string] [EOL] text2 = [string] [EOL] assert rabin_karp ( pattern , text1 ) and not rabin_karp ( pattern , text2 ) [EOL] [EOL] [comment] [EOL] pattern = [string] [EOL] text = [string] [EOL] assert rabin_karp ( pattern , text ) [EOL] [EOL] [comment] [EOL] pattern = [string] [EOL] text = [string] [EOL] assert rabin_karp ( pattern , text ) [EOL] [EOL] [comment] [EOL] pattern = [string] [EOL] text = [string] [EOL] assert rabin_karp ( pattern , text ) [EOL] [EOL] [comment] [EOL] pattern = [string] [EOL] text = [string] [EOL] assert rabin_karp ( pattern , text ) [EOL] pattern = [string] [EOL] assert not rabin_karp ( pattern , text ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] test_rabin_karp ( ) [EOL]	0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import math [EOL] [EOL] [EOL] class vertex ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , id ) : [EOL] [docstring] [EOL] self . id = str ( id ) [EOL] self . key = None [EOL] self . pi = None [EOL] self . neighbors = [ ] [EOL] self . edges = { } [comment] [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [docstring] [EOL] return ( self . key < other . key ) [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return self . id [EOL] [EOL] def addNeighbor ( self , vertex ) : [EOL] [docstring] [EOL] self . neighbors . append ( vertex ) [EOL] [EOL] def addEdge ( self , vertex , weight ) : [EOL] [docstring] [EOL] self . edges [ vertex . id ] = weight [EOL] [EOL] [EOL] def prim ( graph , root ) : [EOL] [docstring] [EOL] A = [ ] [EOL] for u in graph : [EOL] u . key = math . inf [EOL] u . pi = None [EOL] root . key = [number] [EOL] Q = graph [ : ] [EOL] while Q : [EOL] u = min ( Q ) [EOL] Q . remove ( u ) [EOL] for v in u . neighbors : [EOL] if ( v in Q ) and ( u . edges [ v . id ] < v . key ) : [EOL] v . pi = u [EOL] v . key = u . edges [ v . id ] [EOL] for i in range ( [number] , len ( graph ) ) : [EOL] A . append ( [ graph [ i ] . id , graph [ i ] . pi . id ] ) [EOL] return (A) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Union , Dict , Any , List [EOL] import typing [EOL] def check_bipartite_dfs ( l ) : [EOL] visited = [ False ] * len ( l ) [EOL] color = [ - [number] ] * len ( l ) [EOL] [EOL] def dfs ( v , c ) : [EOL] visited [ v ] = True [EOL] color [ v ] = c [EOL] for u in l [ v ] : [EOL] if not visited [ u ] : [EOL] dfs ( u , [number] - c ) [EOL] [EOL] for i in range ( len ( l ) ) : [EOL] if not visited [ i ] : [EOL] dfs ( i , [number] ) [EOL] [EOL] for i in range ( len ( l ) ) : [EOL] for j in l [ i ] : [EOL] if color [ i ] == color [ j ] : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] l = { [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ ] } [EOL] print ( check_bipartite_dfs ( l ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.Union[typing.List[typing.Any],typing.List[builtins.int]]]$ 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] def BFS ( graph , s , t , parent ) : [EOL] [comment] [EOL] visited = [ False ] * len ( graph ) [EOL] queue = [ ] [EOL] queue . append ( s ) [EOL] visited [ s ] = True [EOL] [EOL] while queue : [EOL] u = queue . pop ( [number] ) [EOL] for ind in range ( len ( graph [ u ] ) ) : [EOL] if visited [ ind ] == False and graph [ u ] [ ind ] > [number] : [EOL] queue . append ( ind ) [EOL] visited [ ind ] = True [EOL] parent [ ind ] = u [EOL] [EOL] return True if visited [ t ] else False [EOL] [EOL] def FordFulkerson ( graph , source , sink ) : [EOL] [comment] [EOL] parent = [ - [number] ] * ( len ( graph ) ) [EOL] max_flow = [number] [EOL] while BFS ( graph , source , sink , parent ) : [EOL] path_flow = float ( [string] ) [EOL] s = sink [EOL] [EOL] while ( s != source ) : [EOL] [comment] [EOL] path_flow = min ( path_flow , graph [ parent [ s ] ] [ s ] ) [EOL] s = parent [ s ] [EOL] [EOL] max_flow += path_flow [EOL] v = sink [EOL] [EOL] while ( v != source ) : [EOL] u = parent [ v ] [EOL] graph [ u ] [ v ] -= path_flow [EOL] graph [ v ] [ u ] += path_flow [EOL] v = parent [ v ] [EOL] return max_flow [EOL] [EOL] graph = [ [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] [EOL] source , sink = [number] , [number] [EOL] print ( FordFulkerson ( graph , source , sink ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0
[EOL]	0
[docstring] [EOL] [EOL] [EOL] def abs_val ( num ) : [EOL] [docstring] [EOL] if num < [number] : [EOL] return - num [EOL] [EOL] [comment] [EOL] return num [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] print ( abs_val ( - [number] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] NUM = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] FACTORIAL = [number] [EOL] [EOL] [comment] [EOL] if NUM < [number] : [EOL] print ( [string] ) [EOL] elif NUM == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , NUM + [number] ) : [EOL] FACTORIAL = FACTORIAL * i [EOL] print ( [string] , NUM , [string] , FACTORIAL ) [EOL]	0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import math [EOL] [EOL] [EOL] def sieve ( n ) : [EOL] [docstring] [EOL] in_prime = [ ] [EOL] start = [number] [EOL] end = int ( math . sqrt ( n ) ) [comment] [EOL] temp = [ True ] * ( end + [number] ) [EOL] prime = [ ] [EOL] [EOL] while start <= end : [EOL] if temp [ start ] is True : [EOL] in_prime . append ( start ) [EOL] for i in range ( start * start , end + [number] , start ) : [EOL] if temp [ i ] is True : [EOL] temp [ i ] = False [EOL] start += [number] [EOL] prime += in_prime [EOL] [EOL] low = end + [number] [EOL] high = low + end - [number] [EOL] if high > n : [EOL] high = n [EOL] [EOL] while low <= n : [EOL] temp = [ True ] * ( high - low + [number] ) [EOL] for each in in_prime : [EOL] [EOL] t = math . floor ( low / each ) * each [EOL] if t < low : [EOL] t += each [EOL] [EOL] for j in range ( t , high + [number] , each ) : [EOL] temp [ j - low ] = False [EOL] [EOL] for j in range ( len ( temp ) ) : [EOL] if temp [ j ] is True : [EOL] prime . append ( j + low ) [EOL] [EOL] low = high + [number] [EOL] high = low + end - [number] [EOL] if high > n : [EOL] high = n [EOL] [EOL] return prime [EOL] [EOL] [EOL] print ( sieve ( [number] ** [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] def abs_max ( x ) : [EOL] [docstring] [EOL] j = x [ [number] ] [EOL] for i in x : [EOL] if abs ( i ) > abs ( j ) : [EOL] j = i [EOL] return j [EOL] [EOL] def abs_max_sort ( x ) : [EOL] [docstring] [EOL] return sorted ( x , key = abs ) [ - [number] ] [EOL] [EOL] def main ( ) : [EOL] a = [ [number] , [number] , - [number] ] [EOL] assert abs_max ( a ) == - [number] [EOL] assert abs_max_sort ( a ) == - [number] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def fact ( n ) : [EOL] [docstring] [EOL] return [number] if n <= [number] else n * fact ( n - [number] ) [EOL] [EOL] [EOL] [docstring] [EOL] for i in range ( [number] , [number] ) : [EOL] print ( i , [string] , fact ( i ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] def recur_fibo ( n ) : [EOL] if n <= [number] : [EOL] return n [EOL] else : [EOL] ( recur_fibo ( n - [number] ) + recur_fibo ( n - [number] ) ) [EOL] [EOL] def isPositiveInteger ( limit ) : [EOL] return limit >= [number] [EOL] [EOL] def main ( ) : [EOL] limit = int ( input ( [string] ) ) [EOL] if isPositiveInteger ( limit ) : [EOL] print ( [string] ) [EOL] print ( [ recur_fibo ( n ) for n in range ( limit ) ] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def find_max ( nums ) : [EOL] max = nums [ [number] ] [EOL] for x in nums : [EOL] if x > max : [EOL] max = x [EOL] print ( max ) [EOL] [EOL] def main ( ) : [EOL] find_max ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] def is_square_free ( factors ) : [EOL] [docstring] [EOL] return len ( set ( factors ) ) == len ( factors ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] import doctest [EOL] [EOL] doctest . testmod ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] def find_min ( x ) : [EOL] min_num = x [ [number] ] [EOL] for i in x : [EOL] if min_num > i : [EOL] min_num = i [EOL] return min_num [EOL] [EOL] print ( find_min ( [ [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , - [number] ] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] import builtins [EOL] from typing import Tuple , Callable , Any , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] def collatz_sequence ( n ) : [EOL] [docstring] [EOL] sequence = [ n ] [EOL] while n != [number] : [EOL] if n % [number] == [number] : [EOL] n //= [number] [EOL] else : [EOL] n = [number] * n + [number] [EOL] sequence . append ( n ) [EOL] return sequence [EOL] [EOL] [EOL] def solution ( n ) : [EOL] [docstring] [EOL] [EOL] result = max ( [ ( len ( collatz_sequence ( i ) ) , i ) for i in range ( [number] , n ) ] ) [EOL] return { [string] : result [ [number] ] , [string] : result [ [number] ] } [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] result = solution ( int ( raw_input ( ) . strip ( ) ) ) [EOL] print ( [string] % ( result [ [string] ] , result [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
	0
	0
	0
from typing import Type [EOL] import typing [EOL] [docstring] [EOL] [EOL] try : [EOL] xrange [EOL] except NameError : [EOL] xrange = range [EOL] [EOL] [EOL] def solution ( ) : [EOL] [docstring] [EOL] total = [number] [EOL] for i in xrange ( [number] , [number] ) : [EOL] total += i ** i [EOL] return str ( total ) [ - [number] : ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
[comment] [EOL] import builtins [EOL] from typing import Callable , Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] import math [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] def solution ( n ) : [EOL] [docstring] [EOL] sum_of_squares = sum ( [ i * i for i in range ( [number] , n + [number] ) ] ) [EOL] square_of_sum = int ( math . pow ( sum ( range ( [number] , n + [number] ) ) , [number] ) ) [EOL] return square_of_sum - sum_of_squares [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( int ( raw_input ( ) . strip ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
import builtins [EOL] from typing import Callable , Any , List [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] def solution ( n ) : [EOL] [docstring] [EOL] [EOL] xmulti = [ ] [EOL] zmulti = [ ] [EOL] z = [number] [EOL] x = [number] [EOL] temp = [number] [EOL] while True : [EOL] result = z * temp [EOL] if result < n : [EOL] zmulti . append ( result ) [EOL] temp += [number] [EOL] else : [EOL] temp = [number] [EOL] break [EOL] while True : [EOL] result = x * temp [EOL] if result < n : [EOL] xmulti . append ( result ) [EOL] temp += [number] [EOL] else : [EOL] break [EOL] collection = list ( set ( xmulti + zmulti ) ) [EOL] return sum ( collection ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( int ( raw_input ( ) . strip ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] def solution ( n ) : [EOL] [docstring] [EOL] [EOL] return sum ( [ e for e in range ( [number] , n ) if e % [number] == [number] or e % [number] == [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( int ( raw_input ( ) . strip ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Callable , Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] def solution ( n ) : [EOL] [docstring] [EOL] [EOL] sum = [number] [EOL] num = [number] [EOL] while [number] : [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] num += [number] [EOL] if num >= n : [EOL] break [EOL] sum += num [EOL] return sum [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( int ( raw_input ( ) . strip ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
[docstring] [EOL] [EOL] [EOL] def solution ( power ) : [EOL] [docstring] [EOL] n = [number] ** power [EOL] r = [number] [EOL] while n : [EOL] r , n = r + n % [number] , n // [number] [EOL] return r [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( int ( str ( input ( ) ) . strip ( ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from itertools import permutations [EOL] [EOL] [EOL] def solution ( ) : [EOL] [docstring] [EOL] result = list ( map ( [string] . join , permutations ( [string] ) ) ) [EOL] return result [ [number] ] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( solution ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
from typing import Any , List [EOL] import builtins [EOL] import data_structures [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] class TrieNode : [EOL] def __init__ ( self ) : [EOL] self . nodes = dict ( ) [comment] [EOL] self . is_leaf = False [EOL] [EOL] def insert_many ( self , words ) : [comment] [EOL] [docstring] [EOL] for word in words : [EOL] self . insert ( word ) [EOL] [EOL] def insert ( self , word ) : [comment] [EOL] [docstring] [EOL] curr = self [EOL] for char in word : [EOL] if char not in curr . nodes : [EOL] curr . nodes [ char ] = TrieNode ( ) [EOL] curr = curr . nodes [ char ] [EOL] curr . is_leaf = True [EOL] [EOL] def find ( self , word ) : [comment] [EOL] [docstring] [EOL] curr = self [EOL] for char in word : [EOL] if char not in curr . nodes : [EOL] return False [EOL] curr = curr . nodes [ char ] [EOL] return curr . is_leaf [EOL] [EOL] [EOL] def print_words ( node , word ) : [comment] [EOL] [docstring] [EOL] if node . is_leaf : [EOL] print ( word , end = [string] ) [EOL] [EOL] for key , value in node . nodes . items ( ) : [EOL] print_words ( value , word + key ) [EOL] [EOL] [EOL] def test ( ) : [EOL] words = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] root = TrieNode ( ) [EOL] root . insert_many ( words ) [EOL] [comment] [EOL] assert root . find ( [string] ) [EOL] assert not root . find ( [string] ) [EOL] assert not root . find ( [string] ) [EOL] assert root . find ( [string] ) [EOL] [EOL] test ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] from __future__ import absolute_import [EOL] [EOL] from . stack import Stack [EOL] [EOL] __author__ = [string] [EOL] [EOL] [EOL] def balanced_parentheses ( parentheses ) : [EOL] [docstring] [EOL] stack = Stack ( len ( parentheses ) ) [EOL] for parenthesis in parentheses : [EOL] if parenthesis == [string] : [EOL] stack . push ( parenthesis ) [EOL] elif parenthesis == [string] : [EOL] if stack . is_empty ( ) : [EOL] return False [EOL] stack . pop ( ) [EOL] return stack . is_empty ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] examples = [ [string] , [string] , [string] ] [EOL] print ( [string] ) [EOL] for example in examples : [EOL] print ( example + [string] + str ( balanced_parentheses ( example ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Callable , Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] [EOL] def bubble_sort ( collection ) : [EOL] [docstring] [EOL] length = len ( collection ) [EOL] for i in range ( length - [number] ) : [EOL] swapped = False [EOL] for j in range ( length - [number] - i ) : [EOL] if collection [ j ] > collection [ j + [number] ] : [EOL] swapped = True [EOL] collection [ j ] , collection [ j + [number] ] = collection [ j + [number] ] , collection [ j ] [EOL] if not swapped : break [comment] [EOL] return collection [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] user_input = raw_input ( [string] ) . strip ( ) [EOL] unsorted = [ int ( item ) for item in user_input . split ( [string] ) ] [EOL] print ( * bubble_sort ( unsorted ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0
import builtins [EOL] from typing import Callable , Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] def comb_sort ( data ) : [EOL] [docstring] [EOL] shrink_factor = [number] [EOL] gap = len ( data ) [EOL] swapped = True [EOL] i = [number] [EOL] [EOL] while gap > [number] or swapped : [EOL] [comment] [EOL] gap = int ( float ( gap ) / shrink_factor ) [EOL] [EOL] swapped = False [EOL] i = [number] [EOL] [EOL] while gap + i < len ( data ) : [EOL] if data [ i ] > data [ i + gap ] : [EOL] [comment] [EOL] data [ i ] , data [ i + gap ] = data [ i + gap ] , data [ i ] [EOL] swapped = True [EOL] i += [number] [EOL] [EOL] return data [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] user_input = raw_input ( [string] ) . strip ( ) [EOL] unsorted = [ int ( item ) for item in user_input . split ( [string] ) ] [EOL] print ( comb_sort ( unsorted ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0
import builtins [EOL] from typing import Callable , Any , List [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] def quick_sort_3partition ( sorting , left , right ) : [EOL] if right <= left : [EOL] return [EOL] a = i = left [EOL] b = right [EOL] pivot = sorting [ left ] [EOL] while i <= b : [EOL] if sorting [ i ] < pivot : [EOL] sorting [ a ] , sorting [ i ] = sorting [ i ] , sorting [ a ] [EOL] a += [number] [EOL] i += [number] [EOL] elif sorting [ i ] > pivot : [EOL] sorting [ b ] , sorting [ i ] = sorting [ i ] , sorting [ b ] [EOL] b -= [number] [EOL] else : [EOL] i += [number] [EOL] quick_sort_3partition ( sorting , left , a - [number] ) [EOL] quick_sort_3partition ( sorting , b + [number] , right ) [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] user_input = raw_input ( [string] ) . strip ( ) [EOL] unsorted = [ int ( item ) for item in user_input . split ( [string] ) ] [EOL] quick_sort_3partition ( unsorted , [number] , len ( unsorted ) - [number] ) [EOL] print ( unsorted ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0
from typing import Any , List [EOL] import argparse [EOL] import typing [EOL] [docstring] [EOL] [EOL] import argparse [EOL] import struct [EOL] import hashlib [comment] [EOL] import unittest [EOL] [EOL] [EOL] class SHA1Hash : [EOL] [docstring] [EOL] def __init__ ( self , data ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . h = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] @ staticmethod def rotate ( n , b ) : [EOL] [docstring] [EOL] return ( ( n << b ) | ( n >> ( [number] - b ) ) ) & [number] [EOL] [EOL] def padding ( self ) : [EOL] [docstring] [EOL] padding = [string] + [string] * ( [number] - ( len ( self . data ) + [number] ) % [number] ) [EOL] padded_data = self . data + padding + struct . pack ( [string] , [number] * len ( self . data ) ) [EOL] return padded_data [EOL] [EOL] def split_blocks ( self ) : [EOL] [docstring] [EOL] return [ self . padded_data [ i : i + [number] ] for i in range ( [number] , len ( self . padded_data ) , [number] ) ] [EOL] [EOL] [comment] [EOL] def expand_block ( self , block ) : [EOL] [docstring] [EOL] w = list ( struct . unpack ( [string] , block ) ) + [ [number] ] * [number] [EOL] for i in range ( [number] , [number] ) : [EOL] w [ i ] = self . rotate ( ( w [ i - [number] ] ^ w [ i - [number] ] ^ w [ i - [number] ] ^ w [ i - [number] ] ) , [number] ) [EOL] return w [EOL] [EOL] def final_hash ( self ) : [EOL] [docstring] [EOL] self . padded_data = self . padding ( ) [EOL] self . blocks = self . split_blocks ( ) [EOL] for block in self . blocks : [EOL] expanded_block = self . expand_block ( block ) [EOL] a , b , c , d , e = self . h [EOL] for i in range ( [number] , [number] ) : [EOL] if [number] <= i < [number] : [EOL] f = ( b & c ) | ( ( ~ b ) & d ) [EOL] k = [number] [EOL] elif [number] <= i < [number] : [EOL] f = b ^ c ^ d [EOL] k = [number] [EOL] elif [number] <= i < [number] : [EOL] f = ( b & c ) | ( b & d ) | ( c & d ) [EOL] k = [number] [EOL] elif [number] <= i < [number] : [EOL] f = b ^ c ^ d [EOL] k = [number] [EOL] a , b , c , d , e = self . rotate ( a , [number] ) + f + e + k + expanded_block [ i ] & [number] , a , self . rotate ( b , [number] ) , c , d [EOL] self . h = self . h [ [number] ] + a & [number] , self . h [ [number] ] + b & [number] , self . h [ [number] ] + c & [number] , self . h [ [number] ] + d & [number] , self . h [ [number] ] + e & [number] [EOL] return [string] % tuple ( self . h ) [EOL] [EOL] [EOL] class SHA1HashTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] def testMatchHashes ( self ) : [EOL] msg = bytes ( [string] , [string] ) [EOL] self . assertEqual ( SHA1Hash ( msg ) . final_hash ( ) , hashlib . sha1 ( msg ) . hexdigest ( ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] [comment] [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , default = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] input_string = args . input_string [EOL] [comment] [EOL] if args . input_file : [EOL] with open ( args . input_file , [string] ) as f : [EOL] hash_input = f . read ( ) [EOL] else : [EOL] hash_input = bytes ( input_string , [string] ) [EOL] print ( SHA1Hash ( hash_input ) . final_hash ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] import doctest [EOL] doctest . testmod ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0