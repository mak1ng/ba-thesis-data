from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] , url = [string] , author = [string] , packages = [ [string] , [string] ] , install_requires = [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from unittest import TestCase [EOL] [EOL] [EOL] class ZipTestCase ( TestCase ) : [EOL] def test_when_arguments_are_empty ( self ) : [EOL] self . assertEqual ( list ( zip ( ) ) , [ ] ) [EOL] [EOL] def test_single_iterable ( self ) : [EOL] self . assertEqual ( list ( zip ( [ [number] , [number] ] ) ) , [ ( [number] , ) , ( [number] , ) ] ) [EOL] [EOL] def test_single_empty_iterable ( self ) : [EOL] self . assertEqual ( list ( zip ( [ ] ) ) , [ ] ) [EOL] [EOL] def test_single_generator ( self ) : [EOL] self . assertEqual ( list ( zip ( range ( [number] ) ) ) , [ ( i , ) for i in range ( [number] ) ] ) [EOL] [EOL] def test_two_iterables ( self ) : [EOL] self . assertEqual ( list ( zip ( [ [number] , [number] ] , [ [number] , [number] ] ) ) , [ ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] [EOL] def test_two_empty_iterables ( self ) : [EOL] self . assertEqual ( list ( zip ( [ ] , [ ] ) ) , [ ] ) [EOL] [EOL] def test_two_iterables_when_one_is_empty ( self ) : [EOL] self . assertEqual ( list ( zip ( [ ] , [ [number] , [number] ] ) ) , [ ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] from cxtest import describe [EOL] [EOL] global_list = [ ] [EOL] [EOL] [EOL] def append ( thing ) : [EOL] global_list . append ( thing ) [EOL] return thing [EOL] [EOL] [EOL] @ describe ( [string] ) def _ ( context ) : [EOL] @ context . before_each def clear_global_list ( context ) : [EOL] del global_list [ : ] [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = lambda _ : append ( [string] ) [EOL] [EOL] assert global_list == [ ] [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( global_list , [ ] ) [EOL] context [ [string] ] [EOL] self . assertEqual ( global_list , [ [string] ] ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] [EOL] context [ [string] ] [EOL] self . assertEqual ( global_list , [ [string] ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = append ( [string] ) [EOL] [EOL] assert global_list == [ [string] ] [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( global_list , [ ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] context . before_each ( lambda _ : append ( [string] ) ) [EOL] [EOL] [comment] [EOL] assert global_list == [ [string] ] [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( global_list , [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0
from typing import Any , Callable [EOL] import typing [EOL] import builtins [EOL] from typing import TYPE_CHECKING , Any , Callable [EOL] [EOL] import inflection [EOL] [EOL] if TYPE_CHECKING : [EOL] from cxtest . contexts . concrete_context import ConcreteContext [comment] [EOL] [EOL] [EOL] class Test ( object ) : [EOL] def __init__ ( self , context , function ) : [EOL] self . context = context [EOL] self . function = function [EOL] [EOL] @ property def name ( self ) : [EOL] name = [string] + self . context . description [EOL] return inflection . underscore ( inflection . parameterize ( name ) ) [EOL] [EOL] @ property def method ( self ) : [EOL] def test_method ( self_ ) : [EOL] try : [EOL] self . context . run_before ( ) [EOL] self . function ( self_ , self . context ) [EOL] finally : [EOL] self . context . run_after ( ) [EOL] return test_method [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Callable[...,None]$ 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Type , Dict , Any , Tuple , Callable [EOL] import builtins [EOL] import typing [EOL] import cxtest [EOL] from typing import Callable , Tuple , Type , Union [EOL] from unittest import TestCase [EOL] [EOL] from cxtest . contexts . root_context import RootContext [EOL] [EOL] [EOL] [comment] [EOL] class TestCaseFactory ( object ) : [EOL] def __init__ ( self , description , cls = TestCase ) : [EOL] self . description = description [EOL] self . cls = cls [EOL] [EOL] @ property def _class_name ( self ) : [EOL] return [string] . join ( self . description . title ( ) . split ( ) ) + [string] [EOL] [EOL] @ property def _class_bases ( self ) : [EOL] return ( self . cls , ) if not isinstance ( self . cls , tuple ) else self . cls [EOL] [EOL] def __call__ ( self , f ) : [EOL] root_context = RootContext ( self . description ) [EOL] [EOL] f ( root_context ) [EOL] [EOL] class_dict = { } [EOL] for test in root_context . tests : [EOL] class_dict [ test . name ] = test . method [EOL] [EOL] return type ( self . _class_name , self . _class_bases , class_dict ) [EOL] [EOL] [EOL] describe = TestCaseFactory [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Union[typing.Type,typing.Tuple[typing.Type]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Union[typing.Type,typing.Tuple[typing.Type]]$ 0 $typing.Union[typing.Type,typing.Tuple[typing.Type]]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Type]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.type$ 0 0 0 $typing.Callable[[cxtest.contexts.root_context.RootContext],None]$ 0 0 0 $cxtest.contexts.root_context.RootContext$ 0 0 0 0 0 0 0 0 0 $typing.Callable[[cxtest.contexts.root_context.RootContext],None]$ 0 $cxtest.contexts.root_context.RootContext$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $cxtest.contexts.root_context.RootContext$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Type[cxtest.TestCaseFactory]$ 0 0 0
import builtins [EOL] class BaseContext ( object ) : [EOL] def __init__ ( self , description , parent ) : [EOL] self . _description = description [EOL] self . parent = parent [EOL] [EOL] @ property def description ( self ) : [EOL] prefix = self . parent . description + [string] if self . parent else [string] [EOL] return prefix + self . _description [EOL]	0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $BaseContext$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $BaseContext$ 0 $BaseContext$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
	0
from typing import Any , Callable , Dict , List [EOL] import cxtest [EOL] import typing [EOL] import builtins [EOL] from typing import Any , Callable , cast , Dict , List [EOL] [EOL] from cxtest . contexts . base_context import BaseContext [EOL] from cxtest . contexts . concrete_context import ConcreteContext [EOL] from cxtest . test import Test [EOL] [EOL] [EOL] class Context ( BaseContext ) : [EOL] def __init__ ( self , description , parent ) : [EOL] super ( ) . __init__ ( description , parent ) [EOL] [EOL] self . _context = { } [EOL] self . _hooks = { [string] : [ ] , [string] : [ ] } [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] self . _context [ key ] = value [EOL] [EOL] def get_value ( self , key ) : [EOL] if key in self . _context : [EOL] return self . _context [ key ] [EOL] if self . parent : [EOL] return cast ( Context , self . parent ) . get_value ( key ) [EOL] raise KeyError ( key ) [EOL] [EOL] def __call__ ( self , description ) : [EOL] def decorator ( f ) : [EOL] f ( Context ( description , self ) ) [EOL] return decorator [EOL] [EOL] def it ( self , description ) : [EOL] def decorator ( f ) : [EOL] test = Test ( ConcreteContext ( [string] + description , self ) , f ) [EOL] self . append_test ( test ) [EOL] return decorator [EOL] [EOL] def append_test ( self , test ) : [comment] [EOL] cast ( Context , self . parent ) . append_test ( test ) [EOL] [EOL] def before_each ( self , f ) : [EOL] self . _hooks [ [string] ] . append ( f ) [EOL] [EOL] def after_each ( self , f ) : [EOL] self . _hooks [ [string] ] . append ( f ) [EOL] [EOL] def run_hooks ( self , hooks , context ) : [EOL] if self . parent : [EOL] cast ( Context , self . parent ) . run_hooks ( hooks , context ) [EOL] for hook in self . _hooks [ hooks ] : [EOL] hook ( context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $'Context'$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $'Context'$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Callable[[cxtest.contexts.concrete_context.ConcreteContext],None]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Callable[[typing.Callable],None]$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Callable],None]$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 $cxtest.test.Test$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[typing.Any,typing.Callable],None]$ 0 0 0 0 0 0 $cxtest.test.Test$ 0 0 0 0 0 0 0 $None$ 0 0 0 $cxtest.test.Test$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $cxtest.test.Test$ 0 0 0 0 $None$ 0 0 0 $typing.Callable[[cxtest.contexts.concrete_context.ConcreteContext],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[cxtest.contexts.concrete_context.ConcreteContext],None]$ 0 0 0 0 $None$ 0 0 0 $typing.Callable[[cxtest.contexts.concrete_context.ConcreteContext],None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[cxtest.contexts.concrete_context.ConcreteContext],None]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $cxtest.contexts.concrete_context.ConcreteContext$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $cxtest.contexts.concrete_context.ConcreteContext$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $cxtest.contexts.concrete_context.ConcreteContext$ 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List , TYPE_CHECKING [EOL] [EOL] from cxtest . contexts . context import Context [EOL] [EOL] if TYPE_CHECKING : [EOL] from cxtest . test import Test [comment] [EOL] [EOL] [EOL] class RootContext ( Context ) : [EOL] def __init__ ( self , description ) : [EOL] super ( ) . __init__ ( description , None ) [EOL] self . tests = [ ] [EOL] [EOL] def append_test ( self , test ) : [EOL] self . tests . append ( test ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $'Test'$ 0 0 0 0 0 0 0 0 0 $'Test'$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Any , cast , Dict , TYPE_CHECKING [EOL] [EOL] from cxtest . contexts . base_context import BaseContext [EOL] [EOL] if TYPE_CHECKING : [EOL] from cxtest . contexts . context import Context [comment] [EOL] [EOL] [EOL] class ConcreteContext ( BaseContext ) : [EOL] def __init__ ( self , description , parent ) : [EOL] super ( ) . __init__ ( description , parent ) [EOL] self . _cache = { } [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] if key in self . _cache : [EOL] return self . _cache [ key ] [EOL] [EOL] value = cast ( [string] , self . parent ) . get_value ( key ) [EOL] self . _cache [ key ] = value ( self ) if callable ( value ) else value [EOL] return self . _cache [ key ] [EOL] [EOL] def run_before ( self ) : [EOL] cast ( [string] , self . parent ) . run_hooks ( [string] , self ) [EOL] [EOL] def run_after ( self ) : [EOL] cast ( [string] , self . parent ) . run_hooks ( [string] , self ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $'Context'$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $'Context'$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from unittest import TestCase [EOL] [EOL] from cxtest import describe [EOL] [EOL] [EOL] @ describe ( [string] ) def _ ( context ) : [EOL] def dummy_test ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] pass [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] pass [EOL] [EOL] context [ [string] ] = { } [EOL] context [ [string] ] = ( lambda _ : describe ( [string] , ** _ [ [string] ] ) ( dummy_test ) ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertTrue ( issubclass ( context [ [string] ] , TestCase ) ) [EOL] self . assertEqual ( context [ [string] ] . __name__ , [string] ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] methods = dir ( context [ [string] ] ) [EOL] self . assertIn ( [string] , methods ) [EOL] self . assertIn ( [string] , methods ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] class CustomTestCase ( TestCase ) : [EOL] pass [EOL] [EOL] context [ [string] ] = { [string] : CustomTestCase } [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertTrue ( issubclass ( context [ [string] ] , CustomTestCase ) ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from cxtest import describe [EOL] from cxtest . contexts . concrete_context import ConcreteContext [EOL] from cxtest . contexts . context import Context [EOL] from cxtest . contexts . root_context import RootContext [EOL] [EOL] [EOL] @ describe ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = lambda _ : RootContext ( [string] ) [EOL] context [ [string] ] = lambda _ : Context ( [string] , _ [ [string] ] ) [EOL] context [ [string] ] = ( lambda _ : ConcreteContext ( [string] , _ [ [string] ] ) ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( context [ [string] ] . description , [string] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] [ [string] ] = [string] [EOL] self . assertEqual ( context [ [string] ] [ [string] ] , [string] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = [string] [EOL] context [ [string] ] = ( lambda _ : Mock ( return_value = _ [ [string] ] ) ) [EOL] [EOL] @ context . before_each def _ ( context ) : [EOL] context [ [string] ] [ [string] ] = context [ [string] ] [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] . assert_not_called ( ) [EOL] [EOL] self . assertEqual ( context [ [string] ] [ [string] ] , context [ [string] ] ) [EOL] context [ [string] ] . assert_called_once_with ( context [ [string] ] ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( context [ [string] ] [ [string] ] , context [ [string] ] ) [EOL] self . assertEqual ( context [ [string] ] [ [string] ] , context [ [string] ] ) [EOL] self . assertEqual ( context [ [string] ] . call_count , [number] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = lambda _ : lambda : [string] [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] self . assertEqual ( context [ [string] ] [ [string] ] , context [ [string] ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] root_before_hook = Mock ( ) [EOL] context [ [string] ] . before_each ( root_before_hook ) [EOL] [EOL] parent_before_hook = Mock ( ) [EOL] context [ [string] ] . before_each ( parent_before_hook ) [EOL] [EOL] context [ [string] ] . run_before ( ) [EOL] [EOL] root_before_hook . assert_called_with ( context [ [string] ] ) [EOL] parent_before_hook . assert_called_with ( context [ [string] ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] root_after_hook = Mock ( ) [EOL] context [ [string] ] . after_each ( root_after_hook ) [EOL] [EOL] parent_after_hook = Mock ( ) [EOL] context [ [string] ] . after_each ( parent_after_hook ) [EOL] [EOL] context [ [string] ] . run_after ( ) [EOL] [EOL] root_after_hook . assert_called_with ( context [ [string] ] ) [EOL] parent_after_hook . assert_called_with ( context [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from unittest . mock import Mock [EOL] [EOL] from cxtest import describe [EOL] from cxtest . contexts . context import Context [EOL] from cxtest . contexts . root_context import RootContext [EOL] from cxtest . test import Test [EOL] [EOL] [EOL] @ describe ( [string] ) def _ ( context ) : [EOL] context [ [string] ] = lambda _ : RootContext ( [string] ) [EOL] context [ [string] ] = lambda _ : Context ( [string] , _ [ [string] ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] [ [string] ] = [string] [EOL] self . assertEqual ( context [ [string] ] . get_value ( [string] ) , [string] ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] [ [string] ] = [string] [EOL] self . assertEqual ( context [ [string] ] . get_value ( [string] ) , [string] ) [EOL] [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] with self . assertRaises ( KeyError ) : [EOL] context [ [string] ] . get_value ( [string] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] mock_function = Mock ( ) [EOL] context [ [string] ] ( [string] ) ( mock_function ) [EOL] nested_context = mock_function . call_args [ [number] ] [ [number] ] [EOL] [EOL] self . assertIsInstance ( nested_context , Context ) [EOL] self . assertEqual ( nested_context . parent , context [ [string] ] ) [EOL] [EOL] @ context ( [string] ) def _ ( context ) : [EOL] @ context . it ( [string] ) def _ ( self , context ) : [EOL] context [ [string] ] . it ( [string] ) ( lambda self , context : None ) [EOL] [EOL] test = context [ [string] ] . tests [ [number] ] [EOL] self . assertIsInstance ( test , Test ) [EOL] self . assertEqual ( test . context . description , [string] ) [EOL] self . assertEqual ( test . context . parent , context [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0