[comment] [EOL] from typing import Any [EOL] import typing [EOL] from setuptools import Extension [EOL] from setuptools import find_packages [EOL] from setuptools import setup [EOL] [EOL] [EOL] long_description = open ( [string] ) . read ( ) + [string] [EOL] changelog = open ( [string] ) . read ( ) [EOL] found = [number] [EOL] for line in changelog . splitlines ( ) : [EOL] if len ( line ) > [number] and line [ - [number] ] == [string] and line [ - [number] ] == [string] : [EOL] found += [number] [EOL] if found >= [number] : [EOL] break [EOL] long_description += [string] + line [EOL] [EOL] [EOL] long_description += [string] [EOL] [EOL] lru_module = Extension ( [string] , sources = [ [string] ] ) [EOL] [EOL] setup ( name = [string] , python_requires = [string] , version = open ( [string] ) . read ( ) . strip ( ) , description = [string] , long_description = long_description , keywords = [ [string] , [string] , [string] , [string] , [string] ] , author = [string] , author_email = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , ] , url = [string] , license = [string] , setup_requires = [ [string] ] , zip_safe = False , include_package_data = True , ext_modules = [ lru_module ] , package_data = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] ] } , packages = find_packages ( ) , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , extras_require = { [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , [string] : [ [string] , [string] , ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] ] , } , entry_points = { [string] : [ [string] , [string] , ] } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import asyncio [EOL] import asyncpg [EOL] import asyncio [EOL] [EOL] [EOL] async def run ( ) : [EOL] [comment] [EOL] [comment] [EOL] conn = await asyncpg . connect ( [string] ) [EOL] [comment] [EOL] await conn . execute ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] event_loop = asyncio . get_event_loop ( ) [EOL] event_loop . run_until_complete ( run ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import argparse [EOL] import asyncio [EOL] import argparse [EOL] import asyncio [EOL] import asyncpg [EOL] [EOL] [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , default = [string] ) [EOL] parser . add_argument ( [string] , type = int , default = [number] ) [EOL] [EOL] [EOL] async def run ( ) : [EOL] args = parser . parse_args ( ) [EOL] conn = await asyncpg . connect ( args . connection ) [EOL] [EOL] count = ( await conn . fetch ( [string] ) ) [ [number] ] [ [number] ] [EOL] print ( f"{ count } [string] " ) [EOL] keys = [ ] [EOL] ids = [ ] [EOL] for idx in range ( args . segments - [number] ) : [EOL] offset = round ( ( count / args . segments ) * ( idx + [number] ) ) [EOL] print ( f" [string] { offset }" ) [EOL] keys . append ( ( await conn . fetch ( f" [string] { offset } [string] " ) ) [ [number] ] [ [number] ] ) [EOL] ids . append ( ( await conn . fetch ( f" [string] { offset } [string] " ) ) [ [number] ] [ [number] ] ) [EOL] [EOL] print ( f" [string] { keys }" ) [EOL] sql = [string] . format ( [string] . join ( [ f" [string] { k } [string] " for k in keys ] ) ) [EOL] print ( f" [string] { sql }" ) [EOL] await conn . execute ( sql ) [EOL] [EOL] sql = [string] . format ( [string] . join ( [ f" [string] { k } [string] " for k in keys ] ) ) [EOL] print ( f" [string] { sql }" ) [EOL] await conn . execute ( sql ) [EOL] [EOL] sql = [string] . format ( [string] . join ( [ f" [string] { k } [string] " for k in keys ] ) ) [EOL] print ( f" [string] { sql }" ) [EOL] await conn . execute ( sql ) [EOL] [EOL] sql = [string] . format ( [string] . join ( [ f" [string] { k } [string] " for k in ids ] ) ) [EOL] print ( f" [string] { sql }" ) [EOL] await conn . execute ( sql ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] event_loop = asyncio . get_event_loop ( ) [EOL] event_loop . run_until_complete ( run ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 $asyncio.events.AbstractEventLoop$ 0 0 0 0 0 0 0 0
from guillotina import configure [EOL] [EOL] [EOL] @ configure . service ( name = [string] ) async def foobar ( context , request ) : [EOL] return { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import guillotina [EOL] from guillotina import configure [EOL] from guillotina import content [EOL] from guillotina import Interface [EOL] from guillotina import schema [EOL] [EOL] [EOL] class IMyType ( Interface ) : [EOL] foobar = schema . TextLine ( ) [EOL] [EOL] [EOL] @ configure . contenttype ( type_name = [string] , schema = IMyType , behaviors = [ [string] ] ) class Foobar ( content . Item ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $guillotina.schema._bootstrapfields.TextLine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] [EOL] class LRU ( Dict [ str , Any ] ) : [EOL] def __init__ ( self , size ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] [EOL] class Config ( object ) : [EOL] def __init__ ( self , app , ** kwargs ) : [EOL] ... [EOL] [EOL] [EOL] class Server ( object ) : [EOL] def __init__ ( self , config ) : [EOL] ...	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Config$ 0 0 0 0
import builtins [EOL] def html2text ( val ) : [EOL] ... [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] [EOL] class PreparedStatement : [EOL] def _PreparedStatement__bind_execute ( self , * args , ** kwargs ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
class Record ( dict ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0
class PostgresConnectionError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] class InterfaceError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] class InternalClientError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] class InvalidCatalogNameError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] class ConnectionDoesNotExistError ( Exception ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import types [EOL] import builtins [EOL] from . types import Record [EOL] from typing import List [EOL] [EOL] [EOL] class Connection : [EOL] async def _do_execute ( self , query , * args , ** kwargs ) : [EOL] ... [EOL] [EOL] async def fetch ( self , sql ) : [EOL] ... [EOL] [EOL] async def close ( self ) : [EOL] ... [EOL] [EOL] async def execute ( self , sql ) : [EOL] ... [EOL] [EOL] [EOL] class ServerCapabilities : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import connection [EOL] from . import prepared_stmt [comment] [EOL] from . connection import Connection [EOL] from . types import Record [comment] [EOL] [EOL] [EOL] async def connect ( dsn , ** kwargs ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $connection.Connection$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] [EOL] class JWE : [EOL] def __init__ ( self , payload , key ) : [EOL] ... [EOL] [EOL] def add_recipient ( self , key ) : [EOL] ... [EOL] [EOL] def serialize ( self , compact ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] [EOL] def json_encode ( payload ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0
	0
	0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Dict [EOL] [EOL] [EOL] class JWK : [EOL] def generate ( self , kty , size = [number] ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import Optional , Union , Any [EOL] import typing [EOL] import multidict [EOL] import builtins [EOL] from typing import Any [EOL] from typing import Dict , Optional , Union [EOL] from multidict import CIMultiDict [EOL] [EOL] [EOL] class TestClient ( object ) : [EOL] def __init__ ( self , application , use_cookies = True , timeout = None , headers = None , ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 $typing.Optional[typing.Union[builtins.dict,multidict.CIMultiDict]]$ 0 0 0 0 0 0 0 0
from typing import AsyncIterator [EOL] import typing [EOL] import builtins [EOL] from typing import AsyncIterator [EOL] [EOL] [EOL] class Channel : [EOL] async def wait_message ( self ) : [EOL] ... [EOL] [EOL] async def get ( self ) : [EOL] ... [EOL] [EOL] [EOL] class Redis : [EOL] def __init__ ( self , conn ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.AsyncIterator[builtins.bool]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class ConnectionClosedError ( Exception ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0
import builtins [EOL] class SMTP : [EOL] def __init__ ( self , host , port ) : [EOL] ... [EOL] [EOL] async def connect ( self ) : [EOL] ... [EOL] [EOL] async def login ( self , username , password ) : [EOL] ... [EOL] [EOL] async def starttls ( self ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Optional , Type , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Callable [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] from typing import Type [EOL] [EOL] [EOL] expo = [string] [EOL] [EOL] [EOL] def on_exception ( type_ , exceptions , max_time = None , max_tries = None , ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class PasswordHasher : [EOL] def hash ( self , val ) : [EOL] ... [EOL] [EOL] def verify ( self , hashed , value ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
	0
class ValidationError ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] def validate ( instance , schema ) : [EOL] ... [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class ValidationError ( Exception ) : [EOL] [EOL] message = ... [EOL] validator = ... [EOL] validator_value = ... [EOL] path = ... [EOL] schema_path = ...	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] from typing import Dict [EOL] [EOL] [EOL] class RefResolver : [EOL] @ classmethod def from_schema ( cls , schema ) : [EOL] ... [EOL] [EOL] [EOL] class Validator : [EOL] def __init__ ( self ) : [EOL] ... [EOL] [EOL] def check_schema ( self , schema ) : [EOL] ... [EOL] [EOL] def __call__ ( self , schema , resolver ) : [EOL] ... [EOL] [EOL] [EOL] def validator_for ( schema ) : [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"RefResolver"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $"Validator"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $RefResolver$ 0 0 0 0 0 0 0 0 $Validator$ 0 0 0 0 0 0 0
from setuptools import find_packages [EOL] from setuptools import setup [EOL] [EOL] [EOL] try : [EOL] README = open ( [string] ) . read ( ) [EOL] except IOError : [EOL] README = None [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = README , install_requires = [ [string] ] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( exclude = [ [string] ] ) , include_package_data = True , tests_require = [ [string] , ] , extras_require = { [string] : [ [string] ] } , classifiers = [ ] , entry_points = { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional , Union , Dict [EOL] import typing [EOL] import guillotina [EOL] from guillotina . component import get_utility [EOL] from guillotina . contrib . cache import CACHE_PREFIX [EOL] from guillotina . contrib . cache import serialize [EOL] from guillotina . contrib . cache . strategy import BasicCache [EOL] from guillotina . interfaces import ICacheUtility [EOL] from guillotina . tests import mocks [EOL] from guillotina . utils import resolve_dotted_name [EOL] [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] DEFAULT_SETTINGS = { [string] : [ [string] , [string] , [string] ] , [string] : { [string] : None , [string] : [string] } , } [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_set ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] [comment] [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] [EOL] val = await driver . get ( CACHE_PREFIX + [string] ) [EOL] assert serialize . loads ( val ) == [string] [EOL] [comment] [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] [comment] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] await util . finalize ( None ) [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_delete ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] [comment] [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] [EOL] assert serialize . loads ( await driver . get ( CACHE_PREFIX + [string] ) ) == [string] [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] [EOL] [comment] [EOL] await rcache . delete ( [string] ) [EOL] assert await rcache . get ( oid = [string] ) is None [EOL] await util . finalize ( None ) [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_clear ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] [comment] [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] [EOL] assert serialize . loads ( await driver . get ( CACHE_PREFIX + [string] ) ) == [string] [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] [EOL] await rcache . clear ( ) [EOL] assert await rcache . get ( oid = [string] ) is None [EOL] await util . finalize ( None ) [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_set_multiple_cache_keys_size ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( { [string] : [string] } , keyset = [ { [string] : [string] } , { [string] : [string] , [string] : [string] } ] ) [EOL] assert util . _memory_cache . get_memory ( ) == [number] [EOL] await util . finalize ( None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import guillotina [EOL] from guillotina . contrib . cache . utility import CacheUtility [EOL] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_get_size_of_item ( ) : [EOL] rcache = CacheUtility ( ) [EOL] from guillotina . contrib . cache . utility import _default_size [EOL] import sys [EOL] [EOL] assert rcache . get_size ( dict ( a = [number] ) ) == _default_size [EOL] assert rcache . get_size ( [number] ) == sys . getsizeof ( [number] ) [EOL] assert rcache . get_size ( dict ( state = [string] * [number] ) ) == [number] [EOL] [EOL] item = [ [string] * [number] , [string] * [number] , [string] * [number] ] [EOL] [EOL] assert rcache . get_size ( item ) == sys . getsizeof ( [string] * [number] ) * [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import typing [EOL] import guillotina [EOL] from guillotina . component import get_utility [EOL] from guillotina . contrib . cache . strategy import BasicCache [EOL] from guillotina . db . transaction import Transaction [EOL] from guillotina . interfaces import ICacheUtility [EOL] from guillotina . tests import mocks [EOL] from guillotina . tests . utils import create_content [EOL] [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] DEFAULT_SETTINGS = { [string] : [ [string] , [string] ] , [string] : { [string] : None , [string] : None } , } [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_set ( guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] assert util . initialized [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] [comment] [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] [comment] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_delete ( guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] [comment] [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] [EOL] [comment] [EOL] await rcache . delete ( [string] ) [EOL] assert await rcache . get ( oid = [string] ) is None [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_clear ( guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = [string] ) [EOL] assert util . _memory_cache . get ( [string] ) == [string] [EOL] assert await rcache . get ( oid = [string] ) == [string] [EOL] [EOL] await rcache . clear ( ) [EOL] assert await rcache . get ( oid = [string] ) is None [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_invalidate_object ( guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] content = create_content ( ) [EOL] trns . modified = { content . __uuid__ : content } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = content . __uuid__ ) [EOL] assert util . _memory_cache . get ( [string] + content . __uuid__ ) == [string] [EOL] assert await rcache . get ( oid = content . __uuid__ ) == [string] [EOL] [EOL] await rcache . close ( invalidate = True ) [EOL] assert await rcache . get ( oid = content . __uuid__ ) is None [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_object ( guillotina_main ) : [EOL] tm = mocks . MockTransactionManager ( ) [EOL] storage = tm . _storage [EOL] txn = Transaction ( tm ) [EOL] cache = BasicCache ( txn ) [EOL] txn . _cache = cache [EOL] ob = create_content ( ) [EOL] storage . store ( None , None , None , ob , txn ) [EOL] loaded = await txn . get ( ob . __uuid__ ) [EOL] assert id ( loaded ) != id ( ob ) [EOL] assert loaded . __uuid__ == ob . __uuid__ [EOL] assert cache . _hits == [number] [EOL] assert cache . _misses == [number] [EOL] [EOL] [comment] [EOL] await txn . get ( ob . __uuid__ ) [EOL] assert cache . _hits == [number] [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_cache_object_from_child ( guillotina_main ) : [EOL] tm = mocks . MockTransactionManager ( ) [EOL] storage = tm . _storage [EOL] txn = Transaction ( tm ) [EOL] cache = BasicCache ( txn ) [EOL] txn . _cache = cache [EOL] ob = create_content ( ) [EOL] parent = create_content ( ) [EOL] ob . __parent__ = parent [EOL] storage . store ( None , None , None , parent , txn ) [EOL] storage . store ( None , None , None , ob , txn ) [EOL] [EOL] loaded = await txn . get_child ( parent , ob . id ) [EOL] assert cache . _hits == [number] [EOL] loaded = await txn . get_child ( parent , ob . id ) [EOL] assert cache . _hits == [number] [EOL] [EOL] assert id ( loaded ) != id ( ob ) [EOL] assert loaded . __uuid__ == ob . __uuid__ [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_do_not_cache_large_object ( guillotina_main ) : [EOL] tm = mocks . MockTransactionManager ( ) [EOL] storage = tm . _storage [EOL] txn = Transaction ( tm ) [EOL] cache = BasicCache ( txn ) [EOL] txn . _cache = cache [EOL] ob = create_content ( ) [EOL] ob . foobar = [string] * cache . max_cache_record_size [comment] [EOL] storage . store ( None , None , None , ob , txn ) [EOL] loaded = await txn . get ( ob . __uuid__ ) [EOL] assert id ( loaded ) != id ( ob ) [EOL] assert loaded . __uuid__ == ob . __uuid__ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,None],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] _bytes = [string] * [number] [EOL] [EOL] [EOL] def test_lrusized_acts_like_a_dict ( ) : [EOL] from guillotina . contrib . cache . lru import LRU [EOL] [EOL] m = LRU ( [number] ) [EOL] m . set ( [string] , _bytes , [number] ) [EOL] assert m [ [string] ] == _bytes [EOL] assert [string] in m [EOL] assert m . get ( [string] ) == _bytes [EOL] assert m . get_memory ( ) == [number] [EOL] del m [ [string] ] [EOL] assert len ( m . keys ( ) ) == [number] [EOL] assert m . get_memory ( ) == [number] [EOL] [EOL] [EOL] def test_clean_till_it_has_enought_space ( ) : [EOL] from guillotina . contrib . cache . lru import LRU [EOL] [EOL] m = LRU ( [number] ) [EOL] for k in range ( [number] ) : [EOL] m . set ( k , k , [number] ) [EOL] [EOL] m . set ( [string] , [number] , [number] ) [EOL] assert [number] not in m . keys ( ) [EOL] r = m [ [number] ] [EOL] assert r == [number] [EOL] m . set ( [string] , [number] , [number] ) [EOL] assert [number] in m . keys ( ) [EOL] assert [number] not in m . keys ( ) [EOL] m . set ( [string] , [number] , [number] ) [EOL] assert len ( m . keys ( ) ) == [number] [EOL] assert [number] in m . keys ( ) [EOL] [EOL] assert m . get_memory ( ) == [number] [EOL] del m [ [string] ] [EOL] assert m . get_memory ( ) == [number] [EOL] assert len ( m . keys ( ) ) == [number] [EOL] [EOL] [comment] [EOL] assert m . get_stats ( ) == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_setting_a_bigger_value_than_cache_doesnt_brake ( ) : [EOL] from guillotina . contrib . cache . lru import LRU [EOL] [EOL] m = LRU ( [number] ) [EOL] m . set ( [string] , [string] , [number] ) [EOL] assert [string] not in m . keys ( ) [EOL] [EOL] [EOL] def test_cache_stats_are_hit ( ) : [EOL] from guillotina . contrib . cache . lru import LRU [EOL] [EOL] m = LRU ( [number] ) [EOL] try : [EOL] m [ [string] ] [EOL] except KeyError : [EOL] pass [EOL] assert m . get_stats ( ) == ( [number] , [number] , [number] ) [EOL] [EOL] m . set ( [string] , [number] , [number] ) [EOL] assert m [ [string] ] == [number] [EOL] assert m . get_stats ( ) == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_cache_clear_resets_memory ( ) : [EOL] from guillotina . contrib . cache . lru import LRU [EOL] [EOL] m = LRU ( [number] ) [EOL] m . set ( [string] , [number] , [number] ) [EOL] assert m . get_memory ( ) == [number] [EOL] m . clear ( ) [EOL] assert m . get_memory ( ) == [number] [EOL] assert [string] not in m . keys ( ) [EOL]	0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Optional , Union , Dict [EOL] import typing [EOL] import guillotina [EOL] from guillotina import app_settings [EOL] from guillotina . annotations import AnnotationData [EOL] from guillotina . api . container import create_container [EOL] from guillotina . component import get_utility [EOL] from guillotina . interfaces import IAnnotations [EOL] from guillotina . interfaces import ICacheUtility [EOL] from guillotina . transactions import transaction [EOL] from guillotina . utils import get_database [EOL] [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] DEFAULT_SETTINGS = { [string] : [ [string] , [string] , [string] ] , [string] : { [string] : None , [string] : [string] } , } [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_txn_uses_cached_hits_on_annotations ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] root = await txn . manager . get_root ( ) [EOL] container = await create_container ( root , [string] ) [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] [comment] [EOL] await txn . get_annotation ( container , [string] ) [EOL] [comment] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] with pytest . raises ( KeyError ) : [EOL] [comment] [EOL] await txn . get_annotation ( container , [string] ) [EOL] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] [comment] [EOL] annotations_container = IAnnotations ( container ) [EOL] adata = AnnotationData ( ) [EOL] await annotations_container . async_set ( [string] , adata ) [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] [comment] [EOL] root = await txn . manager . get_root ( ) [EOL] container = await root . async_get ( [string] ) [EOL] [EOL] adata = await txn . get_annotation ( container , [string] ) [EOL] [comment] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] [comment] [EOL] root = await txn . manager . get_root ( ) [EOL] container = await root . async_get ( [string] ) [EOL] [EOL] adata = await txn . get_annotation ( container , [string] ) [EOL] adata [ [string] ] = [string] [EOL] adata . register ( ) [EOL] [comment] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] [comment] [EOL] root = await txn . manager . get_root ( ) [EOL] container = await root . async_get ( [string] ) [EOL] [EOL] adata = await txn . get_annotation ( container , [string] ) [EOL] assert adata [ [string] ] == [string] [EOL] [comment] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] [comment] [EOL] await util . clear ( ) [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] [comment] [EOL] root = await txn . manager . get_root ( ) [EOL] container = await root . async_get ( [string] ) [EOL] [EOL] adata = await txn . get_annotation ( container , [string] ) [EOL] assert adata [ [string] ] == [string] [EOL] [comment] [EOL] assert txn . _cache . _hits == [number] [EOL] assert txn . _cache . _misses == [number] [EOL] [EOL] [EOL] class MockSubscriber : [EOL] def __init__ ( self ) : [EOL] self . data = [ ] [EOL] [EOL] async def publish ( self , channel , tid , info ) : [EOL] self . data . append ( info ) [EOL] [EOL] async def unsubscribe ( self , channel , uid ) : [EOL] pass [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_txn_push_updates_to_subscriber ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] app_settings [ [string] ] [ [string] ] = [string] [EOL] util . _subscriber = MockSubscriber ( ) [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] root = await txn . manager . get_root ( ) [EOL] await create_container ( root , [string] ) [EOL] [EOL] assert len ( util . _subscriber . data ) == [number] [EOL] assert [string] in util . _subscriber . data [ [number] ] [ [string] ] [EOL] assert [string] in util . _subscriber . data [ [number] ] [ [string] ] [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_txn_set_value_with_no_parent ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] app_settings [ [string] ] [ [string] ] = [string] [EOL] util . _subscriber = MockSubscriber ( ) [EOL] [EOL] async with transaction ( db = await get_database ( [string] ) ) as txn : [EOL] root = await txn . manager . get_root ( ) [EOL] [comment] [EOL] root . foo = [string] [EOL] root . register ( ) [EOL] [EOL] assert len ( util . _subscriber . data ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.str]],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import typing [EOL] import guillotina [EOL] from guillotina import app_settings [EOL] from guillotina . component import get_utility [EOL] from guillotina . contrib . cache import CACHE_PREFIX [EOL] from guillotina . contrib . cache import serialize [EOL] from guillotina . contrib . cache . strategy import BasicCache [EOL] from guillotina . interfaces import ICacheUtility [EOL] from guillotina . tests import mocks [EOL] from guillotina . tests . utils import create_content [EOL] from guillotina . utils import resolve_dotted_name [EOL] [EOL] import asyncio [EOL] import pickle [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] DEFAULT_SETTINGS = { [string] : [ [string] , [string] , [string] , [string] , ] , [string] : { [string] : [string] , [string] : [string] } , } [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_invalidate_object ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] assert util . _subscriber is not None [EOL] [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] content = create_content ( ) [EOL] trns . modified = { content . __uuid__ : content } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = content . __uuid__ ) [EOL] [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] assert serialize . loads ( await driver . get ( CACHE_PREFIX + [string] + content . __uuid__ ) ) == [string] [EOL] assert util . _memory_cache . get ( [string] + content . __uuid__ ) == [string] [EOL] assert await rcache . get ( oid = content . __uuid__ ) == [string] [EOL] [EOL] await rcache . close ( invalidate = True ) [EOL] assert await rcache . get ( oid = content . __uuid__ ) is None [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_subscriber_invalidates ( redis_container , guillotina_main ) : [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] assert util . _subscriber is not None [EOL] [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] content = create_content ( ) [EOL] trns . modified = { content . __uuid__ : content } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] [EOL] await rcache . set ( [string] , oid = content . __uuid__ ) [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] [EOL] assert serialize . loads ( await driver . get ( CACHE_PREFIX + [string] + content . __uuid__ ) ) == [string] [EOL] assert util . _memory_cache . get ( [string] + content . __uuid__ ) == [string] [EOL] assert await rcache . get ( oid = content . __uuid__ ) == [string] [EOL] [EOL] assert [string] + content . __uuid__ in util . _memory_cache [EOL] [EOL] await driver . publish ( app_settings [ [string] ] [ [string] ] , pickle . dumps ( { [string] : serialize . dumps ( { [string] : [number] , [string] : [ [string] + content . __uuid__ ] } ) , [string] : [string] } ) , ) [EOL] await asyncio . sleep ( [number] ) [comment] [EOL] assert [string] + content . __uuid__ not in util . _memory_cache [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( DEFAULT_SETTINGS ) async def test_subscriber_ignores_trsn_on_invalidate ( redis_container , guillotina_main ) : [EOL] [EOL] util = get_utility ( ICacheUtility ) [EOL] await util . initialize ( ) [EOL] assert util . initialized [EOL] assert util . _obj_driver is not None [EOL] assert util . _subscriber is not None [EOL] [EOL] trns = mocks . MockTransaction ( mocks . MockTransactionManager ( ) ) [EOL] trns . added = trns . deleted = { } [EOL] content = create_content ( ) [EOL] trns . modified = { content . __uuid__ : content } [EOL] rcache = BasicCache ( trns ) [EOL] await rcache . clear ( ) [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] [EOL] await rcache . set ( [string] , oid = content . __uuid__ ) [EOL] assert serialize . loads ( await driver . get ( CACHE_PREFIX + [string] + content . __uuid__ ) ) == [string] [EOL] assert util . _memory_cache . get ( [string] + content . __uuid__ ) == [string] [EOL] assert await rcache . get ( oid = content . __uuid__ ) == [string] [EOL] [EOL] assert [string] + content . __uuid__ in util . _memory_cache [EOL] [EOL] util . ignore_tid ( [number] ) [EOL] [EOL] await driver . publish ( app_settings [ [string] ] [ [string] ] , pickle . dumps ( { [string] : serialize . dumps ( { [string] : [number] , [string] : [ [string] + content . __uuid__ ] } ) , [string] : [string] } ) , ) [EOL] await asyncio . sleep ( [number] ) [comment] [EOL] [comment] [EOL] assert [string] + content . __uuid__ in util . _memory_cache [EOL] [comment] [EOL] assert [number] not in util . _ignored_tids [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from guillotina . component import get_utility [EOL] from guillotina . interfaces import IMailer [EOL] [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( { [string] : [ [string] , [string] ] , [string] : { [string] : [string] } , } ) async def test_send_mail ( guillotina_main , event_loop ) : [EOL] [EOL] util = get_utility ( IMailer ) [EOL] await util . send ( recipient = [string] , subject = [string] , message = [string] , text = [string] , html = [string] , sender = None , message_id = None , endpoint = [string] , priority = [number] , immediate = False , attachments = [ ] , ) [EOL] [EOL] assert util . mail [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( { [string] : [ [string] , [string] ] , [string] : { [string] : [string] } , } ) async def test_send_mail_print ( guillotina_main , event_loop ) : [EOL] [EOL] util = get_utility ( IMailer ) [EOL] await util . send ( recipient = [string] , subject = [string] , html = [string] , sender = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from guillotina . component import get_utility [EOL] from guillotina . interfaces import IPubSubUtility [EOL] [EOL] import asyncio [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( { [string] : [ [string] , [string] , [string] ] } ) @ pytest . mark . asyncio async def test_pubsub ( redis_container , guillotina_main ) : [EOL] util = get_utility ( IPubSubUtility ) [EOL] await util . initialize ( ) [EOL] RESULT = [ ] [EOL] [EOL] async def callback ( * , data = None , sender = None ) : [EOL] RESULT . append ( data ) [EOL] [EOL] await util . subscribe ( [string] , [string] , callback ) [EOL] [EOL] await util . publish ( [string] , [string] , [string] ) [EOL] [EOL] assert len ( RESULT ) == [number] [EOL] [EOL] await util . publish ( [string] , [string] , [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] assert len ( RESULT ) == [number] [EOL] assert RESULT [ [number] ] == [string] [EOL] [EOL] await util . publish ( [string] , [string] , [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] assert len ( RESULT ) == [number] [EOL] [EOL] await util . unsubscribe ( [string] , [string] ) [EOL] [EOL] await util . publish ( [string] , [string] , [string] ) [EOL] assert len ( RESULT ) == [number] [EOL] [EOL] await util . finalize ( None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import asyncio [EOL] from guillotina . utils import resolve_dotted_name [EOL] [EOL] import asyncio [EOL] import pytest [EOL] [EOL] [EOL] pytestmark = pytest . mark . asyncio [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( { [string] : [ [string] , [string] ] } ) async def test_redis_ops ( redis_container , guillotina_main ) : [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] assert driver . initialized [EOL] assert driver . pool is not None [EOL] [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] result = await driver . get ( [string] ) [EOL] assert result == [string] [EOL] [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] await driver . set ( [string] , [string] , expire = [number] ) [EOL] await driver . expire ( [string] , [number] ) [EOL] [EOL] await driver . delete ( [string] ) [EOL] result = await driver . get ( [string] ) [EOL] assert result is None [EOL] [EOL] result = await driver . keys_startswith ( [string] ) [EOL] assert len ( result ) == [number] [EOL] [EOL] await driver . delete_all ( [ [string] , [string] ] ) [EOL] result = await driver . get ( [string] ) [EOL] assert result is None [EOL] [EOL] await asyncio . sleep ( [number] ) [EOL] result = await driver . get ( [string] ) [EOL] assert result is None [EOL] [EOL] result = await driver . get ( [string] ) [EOL] assert result is None [EOL] [EOL] await driver . flushall ( ) [EOL] result = await driver . get ( [string] ) [EOL] assert result is None [EOL] [EOL] result = await driver . info ( ) [EOL] await driver . finalize ( ) [EOL] assert driver . initialized is False [EOL] [EOL] [EOL] @ pytest . mark . app_settings ( { [string] : [ [string] , [string] ] } ) async def test_redis_pubsub ( redis_container , guillotina_main ) : [EOL] driver = await resolve_dotted_name ( [string] ) . get_driver ( ) [EOL] assert driver . initialized [EOL] [EOL] channel = await driver . subscribe ( [string] ) [EOL] assert channel is not None [EOL] RESULTS = [ ] [EOL] [EOL] async def receiver ( callback ) : [EOL] async for obj in callback : [EOL] RESULTS . append ( obj ) [EOL] break [EOL] [EOL] task = asyncio . ensure_future ( receiver ( channel ) ) [EOL] [EOL] await driver . publish ( [string] , [string] ) [EOL] await asyncio . sleep ( [number] ) [EOL] [EOL] assert len ( RESULTS ) > [number] [EOL] assert RESULTS [ [number] ] == [string] [EOL] [EOL] task . cancel ( ) [EOL] await driver . finalize ( ) [EOL] assert driver . initialized is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0