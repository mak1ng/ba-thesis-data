import os [EOL] from distutils . core import setup [EOL] [EOL] [EOL] PROJECT_DIR = os . path . dirname ( __file__ ) [EOL] [EOL] if PROJECT_DIR : [EOL] os . chdir ( PROJECT_DIR ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = open ( os . path . join ( PROJECT_DIR , [string] ) ) . read ( ) , author = [string] , author_email = [string] , packages = [ [string] ] , install_requires = open ( os . path . join ( PROJECT_DIR , [string] ) ) . read ( ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import PIL [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple [EOL] [EOL] from PIL import Image [EOL] [EOL] [EOL] class ImageError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def get_pixel ( image , location ) : [EOL] try : [EOL] return image . getpixel ( location ) [EOL] except IndexError as e : [EOL] raise ImageError ( f"{ e } [string] { location }" ) [EOL] [EOL] [EOL] def put_pixel ( image , location , colour ) : [EOL] try : [EOL] image . putpixel ( location , colour ) [EOL] return image [EOL] except IndexError as e : [EOL] raise ImageError ( f"{ e } [string] { location } [string] { colour }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import numpy [EOL] [EOL] [EOL] def clip ( item , min = None , max = None ) : [EOL] return numpy . clip ( a = item , a_max = max , a_min = min ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import typing [EOL] from datetime import datetime [EOL] from os import environ , path [EOL] from subprocess import call [EOL] [EOL] from boop import IMAGES_DIR [EOL] [EOL] [EOL] class OutputError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class PNGFormat ( object ) : [EOL] driver = [string] [EOL] extension = [string] [EOL] [EOL] [EOL] def save ( image , display = True ) : [EOL] [EOL] absfile_path = save_path ( image_format = PNGFormat ) [EOL] image . save ( absfile_path , PNGFormat . driver ) [EOL] [EOL] if display : [EOL] show ( absfile_path ) [EOL] [EOL] [EOL] def root_path ( ) : [EOL] env_var_value = environ . get ( IMAGES_DIR , None ) [EOL] [EOL] if not env_var_value : [EOL] raise OutputError ( f" [string] { IMAGES_DIR } [string] " ) [EOL] [EOL] absolute_path = path . abspath ( env_var_value ) [EOL] return absolute_path [EOL] [EOL] [EOL] def save_path ( image_format , counter = None ) : [EOL] [EOL] if counter is None : [EOL] counter = [number] [EOL] [EOL] directory = root_path ( ) [EOL] [EOL] iso_date = datetime . today ( ) . isoformat ( ) [EOL] filename = iso_date + [string] + str ( counter ) + image_format . extension [EOL] filepath = path . join ( directory , filename ) [EOL] [EOL] if path . exists ( filepath ) : [EOL] return save_path ( image_format = image_format , counter = counter ) [EOL] else : [EOL] return filepath [EOL] [EOL] [EOL] def show ( filepath ) : [EOL] call ( [ [string] , filepath ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import logging [EOL] import typing [EOL] import logging [EOL] from os import environ [EOL] [EOL] [EOL] IMAGES_DIR = [string] [EOL] DEBUG = [string] [EOL] [EOL] debug = environ . get ( DEBUG , None ) [EOL] [EOL] [EOL] class BoopError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] logger = logging . getLogger ( [string] ) [EOL] logger . setLevel ( logging . DEBUG if debug else logging . INFO ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple , Callable [EOL] import boop [EOL] import typing [EOL] import builtins [EOL] import random [EOL] from typing import Tuple [EOL] [EOL] import numpy [EOL] [EOL] from boop import BoopError , logger , maths [EOL] [EOL] [EOL] MIN_COLOUR = [number] [EOL] MAX_COLOUR = [number] [EOL] [EOL] [EOL] class ColourError ( BoopError ) : [EOL] pass [EOL] [EOL] [EOL] def random_saturation ( ) : [EOL] return random . randint ( MIN_COLOUR , MAX_COLOUR ) [EOL] [EOL] [EOL] def random_rgb ( ) : [EOL] return ( random_saturation ( ) , random_saturation ( ) , random_saturation ( ) ) [EOL] [EOL] [EOL] def random_palette ( number_of_colours , mode = None ) : [EOL] [EOL] if number_of_colours < [number] : [EOL] raise ColourError ( f" [string] { number_of_colours }" ) [EOL] [EOL] if number_of_colours == [number] : [EOL] logger . warning ( [string] ) [EOL] [EOL] if mode == [string] : [EOL] colour_generator = random_rgb [EOL] elif mode == [string] : [EOL] colour_generator = random_saturation [EOL] else : [EOL] colour_generator = random_rgb [EOL] [EOL] return [ colour_generator ( ) for _ in range ( [number] , number_of_colours ) ] [EOL] [EOL] [EOL] def adjust_saturation ( ratio , colour ) : [EOL] [EOL] if ratio < [number] : [EOL] raise ColourError ( [string] ) [EOL] [EOL] try : [EOL] return tuple ( int ( ratio * value ) for value in colour ) [EOL] except TypeError : [EOL] return int ( ratio * colour ) [EOL] [EOL] [EOL] def add_colours ( c1 , c2 ) : [EOL] added_colours = numpy . add ( c1 , c2 ) [EOL] result = maths . clip ( added_colours , max = MAX_COLOUR , min = MIN_COLOUR ) [EOL] [EOL] try : [EOL] return tuple ( result ) [EOL] except TypeError : [EOL] return int ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , List , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import random [EOL] [EOL] import numpy [EOL] from PIL import Image [EOL] [EOL] from boop import colours , images , maths , output [EOL] [EOL] [EOL] def add_ball ( image , centre , inner_radius , fade_distance , inverted , colour ) : [EOL] outer_radius = fade_distance + inner_radius [EOL] x_max , y_max = image . size [EOL] [EOL] top_left_corner = numpy . subtract ( centre , outer_radius ) [EOL] corrected_top_left_corner = maths . clip ( top_left_corner , min = [number] ) [EOL] [EOL] bottom_right_corner = numpy . add ( centre , outer_radius ) [EOL] corrected_bottom_right_corner = maths . clip ( bottom_right_corner , max = [ x_max , y_max ] ) [EOL] [EOL] for y in range ( corrected_top_left_corner . item ( [number] ) , corrected_bottom_right_corner . item ( [number] ) ) : [EOL] for x in range ( corrected_top_left_corner . item ( [number] ) , corrected_bottom_right_corner . item ( [number] ) ) : [EOL] pixel_loc = ( x , y ) [EOL] [EOL] vector = numpy . subtract ( pixel_loc , centre ) [EOL] distance_from_centre = int ( numpy . linalg . norm ( vector ) ) [EOL] [EOL] restricted_distance = maths . clip ( distance_from_centre , min = inner_radius , max = outer_radius ) [EOL] [EOL] fade_progress = restricted_distance - inner_radius [EOL] [EOL] ratio = fade_progress / fade_distance [EOL] ratio = [number] - ratio if not inverted else ratio [EOL] adjusted_colour = colours . adjust_saturation ( ratio , colour ) [EOL] current_colour = images . get_pixel ( image , pixel_loc ) [EOL] colour_value = colours . add_colours ( adjusted_colour , current_colour ) [EOL] image = images . put_pixel ( image , pixel_loc , colour_value ) [EOL] [EOL] return image [EOL] [EOL] [EOL] def make_random_ball_image ( image_size , number_of_dots , centre_range , fade_range , palette , mode ) : [EOL] [EOL] image = Image . new ( mode , image_size ) [EOL] for colour in random . choices ( palette , k = number_of_dots ) : [EOL] centre , inner_radius , fade_distance = random_ball ( image . size , centre_range , fade_range ) [EOL] image = add_ball ( image , centre , inner_radius , fade_distance , False , colour ) [EOL] [EOL] return image [EOL] [EOL] [EOL] def random_ball ( size , centre_range , fade_range , colour_generator = None ) : [EOL] [EOL] height , width = size [EOL] minimum_centre_radius , maximum_centre_radius = centre_range [EOL] minimum_fade_distance , maximum_fade_distance = fade_range [EOL] [EOL] centre = ( random . randint ( [number] , height ) , random . randint ( [number] , width ) ) [EOL] inner_radius = random . randint ( minimum_centre_radius , maximum_centre_radius ) [EOL] fade_distance = random . randint ( minimum_fade_distance , maximum_fade_distance ) [EOL] [EOL] if colour_generator : [EOL] return centre , inner_radius , fade_distance , colour_generator ( ) [EOL] else : [EOL] return centre , inner_radius , fade_distance [EOL] [EOL] [EOL] def reduce_palette ( image , palette_size ) : [EOL] return apply_pallete ( image , palette_size , image ) [EOL] [EOL] [EOL] def apply_pallete ( palette_image , palette , image ) : [EOL] converted_palette_image = palette_image . quantize ( colors = palette ) [EOL] return image . quantize ( palette = converted_palette_image ) [EOL] [EOL] [EOL] def greyscale_balls ( ** kwargs ) : [EOL] return make_random_ball_image ( mode = [string] , ** kwargs ) [EOL] [EOL] [EOL] def randomcolour_balls ( ** kwargs ) : [EOL] return make_random_ball_image ( mode = [string] , ** kwargs ) [EOL] [EOL] [EOL] def white_balls ( ** kwargs ) : [EOL] palette = [ colours . MAX_COLOUR ] [EOL] return greyscale_balls ( palette = palette , ** kwargs ) [EOL] [EOL] [EOL] def draw_balls ( image , ball_details ) : [EOL] [EOL] updated_balls = list ( ) [EOL] [EOL] for location , centre , fade , colour in ball_details : [EOL] add_ball ( image , location , centre , fade , False , colour ) [EOL] [EOL] if centre : [EOL] centre = centre - [number] [EOL] [EOL] if fade : [EOL] fade = fade - [number] [EOL] [EOL] if centre + fade > [number] : [EOL] updated_balls . append ( ( location , centre , fade , colour ) ) [EOL] [EOL] return updated_balls [EOL] [EOL] [EOL] def fading_balls_image ( ) : [EOL] [EOL] size = ( [number] , [number] ) [EOL] ball_details = [ ] [EOL] centre_range = ( [number] , [number] ) [EOL] fade_range = ( [number] , [number] ) [EOL] [EOL] for _ in range ( [number] , [number] ) : [EOL] [EOL] image = Image . new ( [string] , size ) [EOL] new_ball = random . choice ( [ True , True , False ] ) [EOL] [EOL] if new_ball : [EOL] details = random_ball ( size , centre_range , fade_range , colour_generator = colours . random_rgb ) [EOL] ball_details . append ( details ) [EOL] [EOL] ball_details = draw_balls ( image , ball_details ) [EOL] output . save ( image , display = False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] fading_balls_image ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Any , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] import mock [EOL] import pytest [EOL] [EOL] from boop import colours [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_saturation_calls_random_with_expected_params ( mocked_class ) : [EOL] colours . random_saturation ( ) [EOL] mocked_class . assert_called_once_with ( colours . MIN_COLOUR , colours . MAX_COLOUR ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_rgb_calls_random_saturation_three_times ( mocked_class ) : [EOL] colours . random_rgb ( ) [EOL] expected_calls = [number] [EOL] assert ( mocked_class . call_count == expected_calls ) , f" [string] { mocked_class . call_count } [string] { expected_calls }" [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_iterable_and_ratio_is_zero_expected_result ( ) : [EOL] colour = ( [number] , [number] , [number] ) [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_iterable_and_ratio_is_more_than_1_expected_result ( ) : [EOL] colour = ( [number] , [number] , [number] ) [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_iterable_and_ratio_is_less_than_1_expected_result ( ) : [EOL] colour = ( [number] , [number] , [number] ) [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_iterable_and_ratio_is_1_expected_result ( ) : [EOL] colour = ( [number] , [number] , [number] ) [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_number_and_ratio_is_zero_expected_result ( ) : [EOL] colour = [number] [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_number_and_ratio_is_more_than_1_expected_result ( ) : [EOL] colour = [number] [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_number_and_ratio_is_less_than_1_expected_result ( ) : [EOL] colour = [number] [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_adjust_saturation_where_colour_is_number_and_ratio_is_1_expected_result ( ) : [EOL] colour = [number] [EOL] result = colours . adjust_saturation ( [number] , colour ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_adjust_saturation_where_ratio_is_less_than_1 ( ) : [EOL] with pytest . raises ( colours . ColourError ) : [EOL] colours . adjust_saturation ( - [number] , [number] ) [EOL] [EOL] [EOL] def test_random_palette_default_generator_zero_colours_expected_result ( ) : [EOL] with pytest . raises ( colours . ColourError ) : [EOL] colours . random_palette ( [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_default_generator_with_one_colour_called_once ( mocked_method ) : [EOL] colours . random_palette ( [number] ) [EOL] mocked_method . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_random_palette_default_generator_with_one_colour_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] ) ) == [number] [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_default_generator_many_colours_called_that_many_times ( mocked_method ) : [EOL] colours . random_palette ( [number] ) [EOL] expected_call = [number] [EOL] assert ( mocked_method . call_count == expected_call ) , f" [string] { mocked_method . call_count } [string] { expected_call }" [EOL] [EOL] [EOL] def test_random_palette_default_generator_with_many_colours_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] ) ) == [number] [EOL] [EOL] [EOL] def test_random_palette_rgb_mode_zero_colours_expected_result ( ) : [EOL] [EOL] with pytest . raises ( colours . ColourError ) : [EOL] colours . random_palette ( [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_l_mode_with_one_colour_called_once ( mocked_method ) : [EOL] colours . random_palette ( [number] , mode = [string] ) [EOL] mocked_method . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_random_palette_l_mode_with_one_colour_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] , mode = [string] ) ) == [number] [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_l_mode_many_colours_called_that_many_times ( mocked_method ) : [EOL] colours . random_palette ( [number] , mode = [string] ) [EOL] expected_call = [number] [EOL] assert ( mocked_method . call_count == expected_call ) , f" [string] { mocked_method . call_count } [string] { expected_call }" [EOL] [EOL] [EOL] def test_random_palette_l_mode_with_many_colours_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] , mode = [string] ) ) == [number] [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_rgb_mode_with_one_colour_called_once ( mocked_method ) : [EOL] colours . random_palette ( [number] , mode = [string] ) [EOL] mocked_method . assert_called_once_with ( ) [EOL] [EOL] [EOL] def test_random_palette_rgb_mode_with_one_colour_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] , mode = [string] ) ) == [number] [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_random_palette_rgb_mode_many_colours_called_that_many_times ( mocked_method ) : [EOL] colours . random_palette ( [number] , mode = [string] ) [EOL] expected_call = [number] [EOL] assert ( mocked_method . call_count == expected_call ) , f" [string] { mocked_method . call_count } [string] { expected_call }" [EOL] [EOL] [EOL] def test_random_palette_rgb_mode_with_many_colours_expected_result ( ) : [EOL] assert len ( colours . random_palette ( [number] , mode = [string] ) ) == [number] [EOL] [EOL] [EOL] def test_add_colours_array ( ) : [EOL] result = colours . add_colours ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_add_colours_array_clipping ( ) : [EOL] result = colours . add_colours ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_add_colours_number ( ) : [EOL] result = colours . add_colours ( [number] , [number] ) [EOL] assert result == [number] [EOL] [EOL] [EOL] def test_add_colours_number_clipping ( ) : [EOL] result = colours . add_colours ( ( [number] , [number] , [number] ) , ( [number] , [number] , [number] ) ) [EOL] assert result == ( [number] , [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import mock [EOL] [EOL] from boop import maths [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_clip_with_min_and_max_calls_numpy ( mocked_method ) : [EOL] maths . clip ( [number] , min = [number] , max = [number] ) [EOL] mocked_method . assert_called_once_with ( a = [number] , a_max = [number] , a_min = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_clip_with_min_calls_numpy ( mocked_method ) : [EOL] maths . clip ( [number] , min = [number] ) [EOL] mocked_method . assert_called_once_with ( a = [number] , a_max = None , a_min = [number] ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , autospec = True ) def test_clip_with_max_calls_numpy ( mocked_method ) : [EOL] maths . clip ( [number] , max = [number] ) [EOL] mocked_method . assert_called_once_with ( a = [number] , a_max = [number] , a_min = None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0