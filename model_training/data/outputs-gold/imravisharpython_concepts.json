[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import Any [EOL] import descriptors [EOL] import typing [EOL] class Order : [EOL] def __init__ ( self , name , price , quantity ) : [EOL] self . name = name [EOL] self . price = price [EOL] self . quantity = quantity [EOL] [EOL] def total ( self ) : [EOL] return self . price * self . quantity [EOL] [EOL] [EOL] apple_order = Order ( [string] , [number] , [number] ) [EOL] print ( apple_order . total ( ) ) [EOL] [EOL] [comment] [EOL] apple_order . quantity = - [number] [EOL] print ( apple_order . total ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] class Order : [EOL] def __init__ ( self , name , price , quantity ) : [EOL] self . _name = name [EOL] self . price = price [comment] [EOL] self . _quantity = quantity [EOL] [EOL] @ property def quantity ( self ) : [EOL] return self . _quantity [EOL] [EOL] @ quantity . setter def quantity ( self , value ) : [EOL] if value < [number] : [EOL] raise ValueError ( [string] ) [EOL] self . _quantity = value [EOL] [EOL] def total ( self ) : [EOL] return self . price * self . quantity [EOL] [EOL] [EOL] apple_order = Order ( [string] , [number] , [number] ) [EOL] try : [EOL] apple_order . quantity = - [number] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] print ( apple_order . total ( ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class NonNegative : [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] [EOL] def __get__ ( self , instance , owner ) : [EOL] return instance . __dict__ [ self . name ] [EOL] [EOL] def __set__ ( self , instance , value ) : [EOL] if value < [number] : [EOL] raise ValueError ( [string] ) [EOL] instance . __dict__ [ self . name ] = value [EOL] [EOL] [EOL] [comment] [EOL] class Order : [EOL] price = NonNegative ( [string] ) [comment] [EOL] quantity = NonNegative ( [string] ) [EOL] [EOL] def __init__ ( self , name , price , quantity ) : [EOL] self . _name = name [EOL] self . price = price [EOL] self . quantity = quantity [EOL] [EOL] def total ( self ) : [EOL] return self . price * self . quantity [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] apple_order = Order ( [string] , [number] , [number] ) [EOL] apple_order . total ( ) [EOL] try : [EOL] apple_order . price = - [number] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] [EOL] try : [EOL] apple_order . quantity = - [number] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class NonNegative : [EOL] def __get__ ( self , instance , owner ) : [comment] [EOL] return instance . __dict__ [ self . name ] [EOL] [EOL] def __set__ ( self , instance , value ) : [EOL] print ( [string] , instance , value ) [EOL] if value < [number] : [EOL] raise ValueError ( [string] ) [EOL] instance . __dict__ [ self . name ] = value [EOL] [EOL] [comment] [EOL] def __set_name__ ( self , owner , name ) : [EOL] print ( [string] , name ) [EOL] self . name = name [EOL] [EOL] [EOL] class Order : [EOL] price = NonNegative ( ) [EOL] quantity = NonNegative ( ) [EOL] [EOL] def __init__ ( self , name , price , quantity ) : [EOL] self . _name = name [EOL] self . price = price [EOL] self . quantity = quantity [EOL] [EOL] def total ( self ) : [EOL] return self . price * self . quantity [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] apple_order = Order ( [string] , [number] , [number] ) [EOL] apple_order . total ( ) [EOL] apple_order . price = [number] [EOL] try : [EOL] apple_order . price = - [number] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] [EOL] try : [EOL] apple_order . quantity = - [number] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] print ( Order . __dict__ ) [EOL] print ( [string] ) [EOL] print ( apple_order . __dict__ )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $descriptors.NonNegative$ 0 0 0 0 0 0 0 $descriptors.NonNegative$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $descriptors.NonNegative$ 0 0 0 0 0 $descriptors.NonNegative$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] import method_resolution_order [EOL] class A : [EOL] def whoami ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class B : [EOL] def whoami ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class C ( A , B ) : [comment] [EOL] pass [EOL] [EOL] [EOL] class D ( B , A ) : [comment] [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] c = C ( ) [EOL] c . whoami ( ) [EOL] [EOL] d = D ( ) [EOL] d . whoami ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class F ( A ) : [EOL] def whoami ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class G ( A ) : [EOL] def whoami ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class H ( F , G ) : [EOL] def whoami ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class I ( G , F ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [EOL] h = H ( ) [EOL] h . whoami ( ) [EOL] [EOL] i = I ( ) [EOL] i . whoami ( ) [EOL] [EOL] print ( I . __mro__ ) [EOL] print ( H . __mro__ ) [EOL] [EOL] [EOL] [comment] [EOL] class Base : [EOL] def basem ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class DerivedBase1 ( Base ) : [EOL] def basem ( self ) : [EOL] super ( ) . basem ( ) [EOL] [EOL] [EOL] class DerivedBase2 ( Base ) : [EOL] def basem ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class Derive ( DerivedBase1 , DerivedBase2 ) : [EOL] def basem ( self ) : [EOL] super ( ) . basem ( ) [EOL] [EOL] [EOL] print ( Derive . __mro__ ) [EOL] derive = Derive ( ) [EOL] derive . basem ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $method_resolution_order.C$ 0 0 0 0 0 $method_resolution_order.C$ 0 0 0 0 0 0 $method_resolution_order.D$ 0 0 0 0 0 $method_resolution_order.D$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $method_resolution_order.H$ 0 0 0 0 0 $method_resolution_order.H$ 0 0 0 0 0 0 $method_resolution_order.I$ 0 0 0 0 0 $method_resolution_order.I$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $method_resolution_order.Derive$ 0 0 0 0 0 $method_resolution_order.Derive$ 0 0 0 0 0
class Counter : [EOL] def __init__ ( self , low , high ) : [EOL] self . current = low [EOL] self . high = high [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __iter__ ( self ) : [EOL] [comment] [EOL] return self [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def __next__ ( self ) : [comment] [EOL] if self . current > self . high : [EOL] raise StopIteration [EOL] else : [EOL] self . current += [number] [EOL] return self . current - [number] [EOL] [EOL] [EOL] for c in Counter ( [number] , [number] ) : [EOL] print ( c ) [EOL] [EOL] [EOL] class Fib : [EOL] def __init__ ( self , max ) : [EOL] self . max = max [EOL] [EOL] def __iter__ ( self ) : [EOL] self . a = [number] [EOL] self . b = [number] [EOL] return self [EOL] [EOL] def __next__ ( self ) : [EOL] fib = self . a [EOL] if fib > self . max : [EOL] raise StopIteration [EOL] self . a , self . b = self . b , self . a + self . b [EOL] return fib [EOL] [EOL] [EOL] for n in Fib ( [number] ) : [EOL] print ( n , end = [string] ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class Counter : [EOL] def __init__ ( self , low , high ) : [EOL] self . current = low [EOL] self . high = high [EOL] [EOL] def __iter__ ( self ) : [EOL] while self . current <= self . high : [EOL] yield self . current [EOL] self . current += [number]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
from environment_configs import config [EOL] [EOL] print ( config . DATABASE_URI ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import init_new_call [EOL] import typing [EOL] class Demo : [EOL] def __new__ ( cls , * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] instance = super ( Demo , cls ) . __new__ ( cls , * args , ** kwargs ) [EOL] return instance [EOL] [EOL] def __init__ ( self ) : [EOL] print ( [string] ) [EOL] [EOL] def __call__ ( self , * args , ** kwargs ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] demo = Demo ( ) [EOL] demo ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( callable ( demo ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $init_new_call.Demo$ 0 0 0 0 0 $init_new_call.Demo$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $init_new_call.Demo$ 0 0 0
[comment] [EOL] [comment] [EOL] import inspect [EOL] from inspect import signature [EOL] [EOL] [EOL] def foo ( a , b ) : [EOL] print ( f"{ a } [string] { b } [string] { ( a + b ) }" ) [EOL] [EOL] [EOL] import inspect [EOL] [EOL] print ( inspect . signature ( foo ) ) [EOL] [EOL] sig = signature ( foo ) [EOL] [EOL] bound = sig . bind ( [number] , [number] ) [EOL] print ( bound . args ) [EOL] print ( bound . kwargs ) [EOL] print ( bound . arguments ) [EOL] foo ( * bound . args , ** bound . kwargs ) [EOL] [EOL] bound = sig . bind ( [number] ) [EOL] print ( bound . args ) [EOL] print ( bound . kwargs ) [EOL] print ( bound . arguments ) [EOL] foo ( * bound . args , ** bound . kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $inspect.Signature$ 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 $inspect.Signature$ 0 0 0 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 $inspect.BoundArguments$ 0 $inspect.Signature$ 0 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0 $inspect.BoundArguments$ 0 0 0 0
import functools [EOL] from functools import partial [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] int ( [string] , base = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] basetwo = partial ( int , base = [number] ) [EOL] basetwo ( [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $functools.partial[builtins.int]$ 0 0 0
import sqlite3 [EOL] from contextlib import contextmanager [EOL] from sqlite3 import connect [EOL] [EOL] [EOL] @ contextmanager def temptable ( cur ) : [EOL] cur . execute ( [string] ) [EOL] yield [EOL] cur . execute ( [string] ) [EOL] [EOL] [EOL] with connect ( [string] ) as conn : [EOL] cur = conn . cursor ( ) [EOL] with temptable ( cur ) : [EOL] for x , y in zip ( range ( [number] ) , range ( [number] , [number] ) ) : [EOL] cur . execute ( [string] , ( x , y ) ) [EOL] for row in cur . execute ( [string] ) : [EOL] print ( row ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $sqlite3.dbapi2.Cursor$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any [EOL] import setter_getter [EOL] import typing [EOL] class BaseMeta ( type ) : [EOL] def __new__ ( cls , name , bases , body ) : [EOL] return super ( ) . __new__ ( cls , name , bases , body ) [EOL] [EOL] def __getattribute__ ( self , item ) : [EOL] print ( [string] , item ) [EOL] return super ( ) . __getattribute__ ( item ) [EOL] [EOL] def __setattr__ ( self , key , value ) : [EOL] print ( [string] , key , value ) [EOL] super ( ) . __setattr__ ( key , value ) [EOL] [EOL] [EOL] class MyClass ( object , metaclass = BaseMeta ) : [EOL] ClassVar = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] self . var1 = [string] [EOL] self . var2 = [string] [EOL] [EOL] def __setattr__ ( self , key , value ) : [EOL] print ( [string] , key , value ) [EOL] self . __dict__ [ key ] = value [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] print ( [string] , item ) [EOL] [EOL] def __getattribute__ ( self , item ) : [EOL] if item != [string] : [EOL] print ( [string] , item ) [EOL] return super ( ) . __getattribute__ ( item ) [EOL] [EOL] [EOL] instance = MyClass ( ) [EOL] instance . var1 = [string] [comment] [EOL] instance . var3 = [string] [comment] [EOL] instance . random_var [comment] [EOL] instance . var1 [comment] [EOL] MyClass . ClassVar = [string] [comment] [EOL] MyClass . ClassVar [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import threading_queue [EOL] import threading [EOL] from threading import Thread [EOL] [EOL] [EOL] class Person ( object ) : [EOL] def __init__ ( self ) : [EOL] self . _age = [number] [EOL] [EOL] def get_age ( self ) : [EOL] return self . _age [EOL] [EOL] def increment_age ( self ) : [EOL] self . _age += [number] [EOL] [EOL] [EOL] def task1 ( person ) : [EOL] person . increment_age ( ) [EOL] [comment] [EOL] print ( [string] , person . get_age ( ) ) [EOL] print ( [string] , person . get_age ( ) == [number] ) [EOL] [EOL] [EOL] def task2 ( person ) : [EOL] person . increment_age ( ) [EOL] print ( [string] , person . get_age ( ) ) [EOL] print ( [string] , person . get_age ( ) == [number] ) [EOL] [EOL] [EOL] person = Person ( ) [EOL] [comment] [EOL] thread1 = Thread ( target = task1 , args = ( person , ) ) [EOL] thread2 = Thread ( target = task2 , args = ( person , ) ) [EOL] thread1 . start ( ) [EOL] thread2 . start ( ) [EOL] thread1 . join ( ) [EOL] thread2 . join ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 $threading_queue.synchronization_errors_2.Person$ 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] from typing import Any [EOL] import queue [EOL] import typing [EOL] import queue as queue [EOL] [EOL] print ( [string] ) [EOL] q = queue . Queue ( ) [comment] [EOL] [EOL] for index in range ( [number] ) : [EOL] q . put ( index ) [EOL] [EOL] while not q . empty ( ) : [EOL] print ( q . get ( ) , end = [string] ) [EOL] [EOL] print ( [string] ) [EOL] lq = queue . LifoQueue ( ) [comment] [EOL] [EOL] for index in range ( [number] ) : [EOL] lq . put ( index ) [EOL] [EOL] while not lq . empty ( ) : [EOL] print ( lq . get ( ) , end = [string] ) [EOL] [EOL] print ( [string] ) [EOL] pq = queue . PriorityQueue ( ) [comment] [EOL] pq . put ( ( [number] , [string] ) ) [EOL] pq . put ( ( [number] , [string] ) ) [EOL] pq . put ( ( [number] , [string] ) ) [EOL] pq . put ( ( [number] , [string] ) ) [EOL] [EOL] for i in range ( pq . qsize ( ) ) : [EOL] print ( pq . get ( ) [ [number] ] , end = [string] ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] q . put ( [string] ) [EOL] print ( q . get ( ) ) [EOL] print ( [string] ) [comment] [EOL] [EOL] print ( q . get ( ) ) [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.LifoQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.LifoQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 $queue.LifoQueue[typing.Any]$ 0 0 0 0 0 0 0 0 $queue.LifoQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 $queue.PriorityQueue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $queue.Queue[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import datetime [EOL] import threading [EOL] import typing [EOL] import datetime [EOL] import threading [EOL] [EOL] [EOL] def timeit ( func ) : [EOL] def wrapper ( * args , ** kargs ) : [EOL] start_time = datetime . datetime . now ( ) [EOL] func ( * args , ** kargs ) [EOL] end_time = datetime . datetime . now ( ) [EOL] print ( f'{ threading . current_thread ( ) } [string] { abs ( ( end_time - start_time ) . microseconds ) } [string] ' ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ timeit def countdown ( n ) : [EOL] initial_val = n [EOL] print ( threading . current_thread ( ) ) [EOL] while n > [number] : [EOL] n -= [number] [EOL] print ( [string] . format ( threading . current_thread ( ) , initial_val ) ) [EOL] [EOL] [EOL] COUNT = [number] [EOL] countdown ( COUNT ) [EOL] [EOL] t1 = threading . Thread ( target = countdown , args = ( COUNT / [number] , ) ) [EOL] t2 = threading . Thread ( target = countdown , args = ( COUNT / [number] , ) ) [EOL] t1 . start ( ) [EOL] t2 . start ( ) [EOL] t1 . join ( ) [EOL] t2 . join ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0 $threading.Thread$ 0 0 0 0 0
from typing import Iterator , Any , List [EOL] import concurrent [EOL] import typing [EOL] import os [EOL] import threading [EOL] from concurrent . futures import ThreadPoolExecutor , wait , as_completed [EOL] from random import randint [EOL] from time import sleep [EOL] [EOL] messages = [ [string] , [string] ] [EOL] futures = [ ] [EOL] [EOL] [EOL] def return_after_5_secs ( message ) : [EOL] sleep ( randint ( [number] , [number] ) ) [EOL] print ( f" [string] { os . getpid ( ) } [string] { threading . current_thread ( ) }" ) [EOL] return message [EOL] [EOL] [EOL] pool = ThreadPoolExecutor ( [number] ) [EOL] future1 = pool . submit ( return_after_5_secs , ( [string] ) ) [comment] [EOL] [comment] [EOL] print ( future1 . done ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] with ThreadPoolExecutor ( ) as executor : [EOL] result = executor . map ( return_after_5_secs , messages ) [EOL] [EOL] print ( tuple ( result ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with ThreadPoolExecutor ( ) as executor : [EOL] for message in messages : [EOL] futures . append ( pool . submit ( return_after_5_secs , message ) ) [EOL] [EOL] for x in as_completed ( futures ) : [EOL] print ( [string] , x . result ( ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] with ThreadPoolExecutor ( ) as executor : [EOL] for message in messages : [EOL] futures . append ( pool . submit ( return_after_5_secs , message ) ) [EOL] print ( [string] , wait ( futures ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] def done ( completed_future ) : [EOL] if completed_future . cancelled ( ) : [EOL] print ( [string] . format ( completed_future ) ) [EOL] elif completed_future . done ( ) : [EOL] error = completed_future . exception ( ) [EOL] if error : [EOL] print ( [string] . format ( completed_future , error ) ) [EOL] else : [EOL] res = completed_future . result ( ) [EOL] print ( [string] . format ( completed_future , res ) ) [EOL] [EOL] [EOL] with ThreadPoolExecutor ( ) as executor : [EOL] future = executor . submit ( return_after_5_secs , ( [string] ) ) [EOL] future . add_done_callback ( done ) [EOL] print ( [string] , future . result ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $concurrent.futures.thread.ThreadPoolExecutor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def my_gen ( ) : [EOL] n = [number] [EOL] print ( [string] ) [EOL] yield n [EOL] [EOL] n += [number] [EOL] print ( [string] ) [EOL] yield n [EOL] [EOL] n += [number] [EOL] print ( [string] ) [EOL] yield n [EOL] [EOL] [EOL] gen = my_gen ( ) [EOL] next ( gen ) [EOL] next ( gen ) [EOL] next ( gen ) [EOL] [EOL] [EOL] def countdown ( n ) : [EOL] print ( [string] ) [EOL] while n > [number] : [EOL] print ( [string] , n ) [EOL] yield n [EOL] print ( [string] , n ) [EOL] n -= [number] [EOL] [EOL] [EOL] countd = countdown ( [number] ) [EOL] for n in countd : [EOL] print ( n ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import typing [EOL] def double ( ) : [EOL] try : [EOL] while True : [EOL] item = yield [EOL] print ( [string] , item ) [EOL] yield [number] * item [EOL] print ( [string] ) [EOL] except GeneratorExit : [EOL] print ( [string] ) [EOL] [EOL] [EOL] db = double ( ) [EOL] res = next ( db ) [EOL] print ( [string] , res ) [EOL] res = db . send ( [number] ) [EOL] print ( [string] , res ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List [EOL] import typing [EOL] def chain ( x , y ) : [EOL] yield from x [EOL] yield from y [EOL] [EOL] [EOL] a = [ [number] , [number] , [number] ] [EOL] b = [ [number] , [number] , [number] ] [EOL] [EOL] for n in chain ( a , b ) : [EOL] print ( n ) [EOL] [EOL] [EOL] [comment] [EOL] def chain1 ( x , y ) : [EOL] for n in x : [EOL] yield n [EOL] for n in y : [EOL] yield n [EOL] [EOL] [EOL] for n in chain1 ( a , b ) : [EOL] print ( n ) [EOL] [EOL] for n in chain ( chain ( a , b ) , chain ( b , b ) ) : [EOL] print ( n ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Generator [EOL] import typing [EOL] def receiver ( ) : [EOL] index = [number] [EOL] while True : [EOL] print ( f"{ index } [string] " ) [EOL] item = yield [EOL] print ( f"{ index } [string] " ) [EOL] print ( f'{ index } [string] ' , item ) [EOL] index = index + [number] [EOL] [EOL] [EOL] recv = receiver ( ) [EOL] next ( recv ) [comment] [EOL] [comment] [EOL] [comment] [EOL] recv . send ( [string] ) [EOL] recv . send ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Literal , Any , Generator [EOL] import typing_extensions [EOL] import typing [EOL] def func ( ) : [EOL] print ( [string] ) [EOL] result = yield [number] [EOL] print ( [string] ) [EOL] print ( [string] , result ) [EOL] [EOL] [EOL] [comment] [EOL] gen = func ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] res = gen . send ( None ) [EOL] print ( res ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] gen . send ( [string] ) [EOL] except StopIteration : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def whizbang ( ) : [EOL] for i in range ( [number] ) : [EOL] print ( f"{ i } [string] " ) [EOL] x = yield i [comment] [EOL] print ( f"{ i } [string] " ) [EOL] print ( [string] . format ( x ) ) [EOL] [EOL] [EOL] whiz = whizbang ( ) [EOL] res = next ( whiz ) [EOL] print ( res ) [EOL] print ( [string] ) [EOL] res = next ( whiz ) [EOL] print ( res ) [EOL] print ( [string] ) [EOL] res = next ( whiz ) [EOL] print ( res ) [EOL] print ( [string] ) [EOL] res = whiz . send ( [string] ) [EOL] print ( res ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
def fib ( a = [number] , b = [number] , n = [number] ) : [EOL] res = [ ] [EOL] for _ in range ( n ) : [EOL] res . append ( a ) [EOL] a , b = b , a + b [EOL] return res [EOL] [EOL] [EOL] print ( fib ( ) ) [EOL] [EOL] [EOL] def fib ( a = [number] , b = [number] ) : [EOL] while True : [EOL] yield a [EOL] a , b = b , a + b [EOL] [EOL] [EOL] from itertools import islice , takewhile , dropwhile [EOL] [EOL] print ( list ( islice ( fib ( ) , [number] ) ) ) [EOL] print ( list ( takewhile ( lambda x : x < [number] , fib ( ) ) ) ) [EOL] print ( list ( dropwhile ( lambda x : x < [number] , islice ( fib ( ) , [number] ) ) ) ) [EOL] [EOL] print ( list ( dropwhile ( lambda x : x < [number] , takewhile ( lambda x : x < [number] , islice ( fib ( ) , [number] ) ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import os [EOL] import psutil [EOL] import sys [EOL] [EOL] [EOL] def memory_footprint ( ) : [EOL] [docstring] [EOL] mem = psutil . Process ( os . getpid ( ) ) . memory_info ( ) . rss [EOL] [comment] [EOL] return mem / [number] ** [number] [EOL] [EOL] [EOL] print ( f" [string] { memory_footprint ( ) }" ) [EOL] N = ( [number] ** [number] ) // sys . getsizeof ( float ( ) ) [comment] [EOL] x = [ float ( i ) for i in range ( [number] , [number] * N ) ] [EOL] [EOL] print ( f" [string] { memory_footprint ( ) }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import design_patterns [EOL] from abc import ABCMeta , abstractmethod [EOL] [EOL] [EOL] class SomeInterface ( metaclass = ABCMeta ) : [EOL] [EOL] @ abstractmethod def some_method ( self ) : [EOL] pass [EOL] [EOL] [EOL] class MyClass ( SomeInterface ) : [EOL] def some_method ( self ) : [EOL] pass [EOL] [EOL] [EOL] mc = MyClass ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $design_patterns.interface.MyClass$ 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import design_patterns [EOL] import typing [EOL] class Elf : [EOL] name = [string] [EOL] [EOL] def nall_nin ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class Dwarf : [EOL] def estver_narho ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class Human : [EOL] def ring_mig ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class MinionAdapter : [EOL] _initialised = False [EOL] [EOL] def __init__ ( self , minion , ** adapted_methods ) : [EOL] self . minion = minion [EOL] [EOL] for key , value in adapted_methods . items ( ) : [EOL] func = getattr ( self . minion , value ) [EOL] self . __setattr__ ( key , func ) [EOL] [EOL] self . _initialised = True [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] [docstring] [EOL] return getattr ( self . minion , attr ) [EOL] [EOL] def __setattr__ ( self , key , value ) : [EOL] [docstring] [EOL] if not self . _initialised : [EOL] super ( ) . __setattr__ ( key , value ) [EOL] else : [EOL] [docstring] [EOL] setattr ( self . minion , key , value ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] minion_adapters = [ MinionAdapter ( Elf ( ) , call_me = [string] ) , MinionAdapter ( Dwarf ( ) , call_me = [string] ) , MinionAdapter ( Human ( ) , call_me = [string] ) ] [EOL] [EOL] for adapter in minion_adapters : [EOL] adapter . call_me ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[design_patterns.adapter.MinionAdapter]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[design_patterns.adapter.MinionAdapter]$ 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import design_patterns [EOL] import typing [EOL] class Elf : [EOL] name = [string] [EOL] [EOL] def nall_nin ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class Dwarf : [EOL] def estver_narho ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class Human : [EOL] def ring_mig ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] class MinionAdapter : [EOL] _initialised = False [EOL] [EOL] def __init__ ( self , minion , ** adapted_methods ) : [EOL] self . minion = minion [EOL] [EOL] for key , value in adapted_methods . items ( ) : [EOL] func = getattr ( self . minion , value ) [EOL] self . __setattr__ ( key , func ) [EOL] [EOL] self . _initialised = True [EOL] [EOL] def __getattr__ ( self , attr ) : [EOL] [docstring] [EOL] return getattr ( self . minion , attr ) [EOL] [EOL] def __setattr__ ( self , key , value ) : [EOL] [docstring] [EOL] if not self . _initialised : [EOL] super ( ) . __setattr__ ( key , value ) [EOL] else : [EOL] [docstring] [EOL] setattr ( self . minion , key , value ) [EOL] [EOL] [EOL] class MinionFacade : [EOL] minion_adapters = None [EOL] [EOL] @ classmethod def create_minions ( cls ) : [EOL] print ( [string] ) [EOL] cls . minion_adapters = [ MinionAdapter ( Elf ( ) , call_me = [string] ) , MinionAdapter ( Dwarf ( ) , call_me = [string] ) , MinionAdapter ( Human ( ) , call_me = [string] ) ] [EOL] [EOL] @ classmethod def summon_minions ( cls ) : [EOL] print ( [string] ) [EOL] for adapter in cls . minion_adapters : [EOL] adapter . call_me ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] MinionFacade . create_minions ( ) [EOL] MinionFacade . summon_minions ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import collections . abc [EOL] [EOL] [EOL] class ParentClass : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] class ChildClass ( ParentClass ) : [EOL] pass [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] collections . abc . Sequence . register ( tuple ) [EOL] collections . abc . Sequence . register ( str ) [EOL] collections . abc . Sequence . register ( range ) [EOL] collections . abc . MutableSequence . register ( list ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import collections [EOL] [EOL] [EOL] class MyClass : [EOL] pass [EOL] [EOL] [EOL] issubclass ( MyClass , collections . abc . Sequence ) [comment] [EOL] collections . abc . Sequence . register ( MyClass ) [comment] [EOL] issubclass ( MyClass , collections . abc . Sequence ) [comment] [EOL] [EOL] [comment] [EOL] from abc import ABCMeta [EOL] [EOL] [EOL] class MyAbc ( metaclass = ABCMeta ) : [EOL] pass [EOL] [EOL] [EOL] MyAbc . register ( tuple ) [EOL] [EOL] assert issubclass ( tuple , MyAbc ) [EOL] assert isinstance ( ( ) , MyAbc ) [EOL] [EOL] [EOL] class AnswerType ( type ) : [EOL] def __init__ ( self , name , bases , namespace ) : [EOL] self . answer = [number] [EOL] [EOL] def __new__ ( metacls , name , bases , namespace , ** kwds ) : [EOL] result = type . __new__ ( metacls , name , bases , dict ( namespace ) ) [EOL] import pdb ; pdb . set_trace ( ) [EOL] result . _filters = [ value for value in namespace . values ( ) if hasattr ( value , [string] ) ] [EOL] return result [EOL] [EOL] [EOL] class Book ( metaclass = AnswerType ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] __all__ = [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class Base : [EOL] DEBUG = False [EOL] TESTING = False [EOL] [EOL] [EOL] class Development ( Base ) : [EOL] DEBUG = True [EOL] DATABASE_URI = [string] [EOL] [EOL] [EOL] class Testing ( Base ) : [EOL] DEBUG = False [EOL] DATABASE_URI = [string] [EOL] [EOL] [EOL] class Production ( Base ) : [EOL] DEBUG = False [EOL] DATABASE_URI = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] import docx [EOL] import os [EOL] import docx [EOL] from docx . document import Document [EOL] [EOL] document = docx . Document ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] print ( document . paragraphs ) [EOL] print ( document . paragraphs [ [number] ] . text ) [EOL] print ( document . paragraphs [ [number] ] . runs ) [comment] [EOL] print ( document . paragraphs [ [number] ] . runs ) [EOL] print ( document . paragraphs [ [number] ] . runs [ [number] ] . bold ) [EOL] print ( document . paragraphs [ [number] ] . runs [ [number] ] . text ) [EOL] [EOL] print ( [string] ) [EOL] print ( document . paragraphs [ [number] ] . runs [ [number] ] . italic ) [EOL] print ( document . paragraphs [ [number] ] . runs [ [number] ] . text ) [EOL] [EOL] document . paragraphs [ [number] ] . runs [ [number] ] . underline = True [EOL] document . paragraphs [ [number] ] . runs [ [number] ] . text = [string] [EOL] document . save ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] [EOL] print ( document . paragraphs [ [number] ] . style ) [EOL] document . paragraphs [ [number] ] . style = [string] [EOL] document . save ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] [EOL] print ( [string] ) [EOL] new_doc = docx . Document ( ) [EOL] new_doc . add_paragraph ( [string] ) [EOL] new_doc . add_paragraph ( [string] ) [EOL] new_doc . save ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] [EOL] new_doc . paragraphs [ [number] ] . add_run ( [string] ) [EOL] new_doc . paragraphs [ [number] ] . runs [ [number] ] . bold = True [EOL] new_doc . save ( f"{ os . getenv ( [string] ) } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $docx.document.Document$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import requests [EOL] import logging [EOL] import typing [EOL] import webbrowser [EOL] import bs4 [EOL] import requests [EOL] import logging [EOL] [EOL] [comment] [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] starred_repos = [ ] [EOL] [EOL] [comment] [EOL] url = [string] [EOL] [EOL] [EOL] def get_soup ( url ) : [EOL] res = requests . get ( url ) [EOL] res . raise_for_status ( ) [EOL] return bs4 . BeautifulSoup ( res . text , [string] ) [EOL] [EOL] [EOL] def get_stared_repos ( soup ) : [EOL] all_repos = soup . select ( [string] ) [EOL] return list ( map ( lambda repo : f" [string] { repo . select ( [string] ) [ [number] ] [ [string] ] }" , all_repos ) ) [EOL] [EOL] [EOL] def next_page ( soup ) : [EOL] for pages_link in soup . find_all ( [string] , { [string] : [string] } ) : [EOL] if pages_link . text == [string] : [EOL] return pages_link [EOL] [EOL] [EOL] while True : [EOL] soup = get_soup ( url ) [EOL] starred_repos = starred_repos + get_stared_repos ( soup ) [EOL] next_link = next_page ( soup ) [EOL] if not next_link : [EOL] break [EOL] url = next_link [ [string] ] [EOL] [EOL] print ( f" [string] { len ( starred_repos ) } [string] " ) [EOL] print ( [string] . join ( starred_repos ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0
	0
from typing import Any [EOL] import PyPDF2 [EOL] import typing [EOL] import io [EOL] import PyPDF2 [EOL] import os [EOL] [EOL] from PyPDF2 . pdf import PageObject [EOL] [EOL] [comment] [EOL] pdf_file = open ( f"{ os . getenv ( [string] ) } [string] " , [string] ) [EOL] reader = PyPDF2 . PdfFileReader ( pdf_file ) [EOL] print ( reader . numPages ) [EOL] page_0 = reader . getPage ( [number] ) [EOL] print ( page_0 . extractText ( ) ) [EOL] [EOL] for page_num in range ( reader . numPages ) : [EOL] print ( reader . getPage ( page_num ) . extractText ( ) ) [EOL] [EOL] pdf_file . close ( ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] pdf1_file = open ( f"{ os . getenv ( [string] ) } [string] " , [string] ) [EOL] pdf2_file = open ( f"{ os . getenv ( [string] ) } [string] " , [string] ) [EOL] reader1 = PyPDF2 . PdfFileReader ( pdf1_file ) [EOL] reader2 = PyPDF2 . PdfFileReader ( pdf2_file ) [EOL] [EOL] writer = PyPDF2 . PdfFileWriter ( ) [EOL] for page_num in range ( reader1 . numPages ) : [EOL] writer . addPage ( reader1 . getPage ( page_num ) ) [EOL] for page_num in range ( reader2 . numPages ) : [EOL] writer . addPage ( reader2 . getPage ( page_num ) ) [EOL] [EOL] output_pdf = open ( f"{ os . getenv ( [string] ) } [string] " , [string] ) [EOL] writer . write ( output_pdf ) [EOL] output_pdf . close ( ) [EOL] pdf1_file . close ( ) [EOL] pdf2_file . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pyautogui [EOL] [EOL] pyautogui . hotkey ( [string] , [string] ) [EOL] pyautogui . typewrite ( [string] , interval = [number] ) [comment] [EOL] pyautogui . typewrite ( [ [string] , [string] , [string] , [string] , [string] ] , interval = [number] ) [EOL] print ( pyautogui . KEYBOARD_KEYS ) [EOL] pyautogui . hotkey ( [string] , [string] ) [EOL] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pyautogui [EOL] [EOL] print ( f" [string] { pyautogui . size ( ) }" ) [EOL] width , height = pyautogui . size ( ) [EOL] [EOL] print ( f" [string] { pyautogui . position ( ) }" ) [EOL] [EOL] pyautogui . moveTo ( [number] , [number] ) [EOL] pyautogui . moveTo ( [number] , [number] , duration = [number] ) [EOL] [EOL] [comment] [EOL] pyautogui . moveRel ( [number] , [number] , duration = [number] ) [comment] [EOL] pyautogui . moveRel ( [number] , - [number] , duration = [number] ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pyautogui . click ( [number] , [number] ) [EOL] pyautogui . doubleClick ( [number] , [number] ) [EOL] pyautogui . rightClick ( [number] , [number] ) [EOL] pyautogui . middleClick ( [number] , [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pyautogui . displayMousePosition ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import pyautogui [EOL] import os [EOL] [EOL] [comment] [EOL] pyautogui . screenshot ( ) [comment] [EOL] pyautogui . screenshot ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] [EOL] print ( [string] ) [EOL] location = pyautogui . locateOnScreen ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] print ( f" [string] { location }" ) [comment] [EOL] [comment] [EOL] [EOL] location = pyautogui . locateCenterOnScreen ( f"{ os . getenv ( [string] ) } [string] " ) [EOL] print ( f" [string] { location }" ) [comment] [EOL] pyautogui . moveTo ( ( [number] , [number] ) , duration = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment]	0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import mock [EOL] import typing [EOL] from mock import Mock , call [EOL] [EOL] [EOL] def test_should_test_mock ( ) : [EOL] m = Mock ( ) [EOL] [EOL] m . configure_mock ( bar = [string] ) [EOL] m . configure_mock ( baz = lambda : [string] ) [EOL] [EOL] assert isinstance ( m . foo , Mock ) [EOL] assert isinstance ( m . foo ( ) , Mock ) [EOL] assert isinstance ( m ( ) , Mock ) [EOL] [EOL] assert m . foo is not m . foo ( ) is not m ( ) [EOL] assert [string] == m . bar [EOL] assert [string] == m . baz ( ) [EOL] [EOL] [EOL] def test_return_value ( ) : [EOL] m = Mock ( ) [EOL] m . return_value = [number] [EOL] assert m ( ) == [number] [EOL] [EOL] [EOL] def test_side_effect ( ) : [EOL] m = Mock ( ) [EOL] m . side_effect = [ [string] , [string] , [string] ] [EOL] assert m ( ) == [string] [EOL] assert m ( ) == [string] [EOL] assert m ( ) == [string] [EOL] [EOL] [EOL] def test_raise_exception ( ) : [EOL] m = Mock ( ) [EOL] m . side_effect = RuntimeError ( [string] ) [EOL] try : [EOL] m ( ) [EOL] except RuntimeError : [EOL] assert True [EOL] else : [EOL] assert False [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_call_count ( ) : [EOL] m = Mock ( ) [EOL] [EOL] m ( [number] , [number] ) [EOL] m ( [number] , [number] ) [EOL] [EOL] assert [number] == m . call_count [EOL] assert call ( [number] , [number] ) == m . call_args [EOL] assert [ call ( [number] , [number] ) , call ( [number] , [number] ) ] == m . call_args_list [EOL] [EOL] [EOL] [comment] [EOL] def test_reset_mock ( ) : [EOL] m = Mock ( ) [EOL] m . configure_mock ( bar = [string] ) [EOL] [EOL] m ( [number] , [number] ) [EOL] m ( [number] , [number] ) [EOL] [EOL] m . reset_mock ( ) [EOL] [EOL] assert [number] == m . call_count [EOL] assert None == m . call_args [EOL] assert [ ] == m . call_args_list [EOL] assert [string] == m . bar [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from mock import patch [EOL] [EOL] [EOL] class Foo : [EOL] x = [number] [EOL] [EOL] [EOL] class Bar : [EOL] x = [number] [EOL] [EOL] [EOL] [comment] [EOL] def test_new_callable ( ) : [EOL] with patch ( [string] , new_callable = Bar ) as mock_foo : [EOL] assert mock_foo . x == [number] [EOL] assert isinstance ( mock_foo , Bar ) [EOL] [EOL] [EOL] [comment] [EOL] def test_new ( ) : [EOL] foo = [string] [EOL] with patch ( [string] , new = foo ) as mock_foo : [EOL] assert mock_foo == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import mock [EOL] import typing [EOL] from mock import MagicMock , Mock , NonCallableMock , NonCallableMagicMock [EOL] [EOL] [EOL] def test_magic_mock_dir ( ) : [EOL] mock = Mock ( ) [EOL] magic_mock = MagicMock ( ) [EOL] assert dir ( mock ) == dir ( magic_mock ) [EOL] int ( magic_mock ) [EOL] assert dir ( mock ) != dir ( magic_mock ) [EOL] [EOL] [EOL] def test_magic_mock ( ) : [EOL] magic_mock = MagicMock ( ) [EOL] mock = Mock ( ) [EOL] len ( magic_mock ) [EOL] try : [EOL] len ( mock ) [EOL] except TypeError : [EOL] print ( [string] ) [EOL] [EOL] [EOL] mocks = [ Mock ( ) , MagicMock ( ) , NonCallableMock ( ) , NonCallableMagicMock ( ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[mock.NonCallableMock]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import mock [EOL] import testing [EOL] import typing [EOL] from mock import PropertyMock , patch , call , MagicMock [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class Foo ( object ) : [EOL] @ property def foo ( self ) : [EOL] return [string] [EOL] [EOL] @ foo . setter def foo ( self , value ) : [EOL] pass [EOL] [EOL] [EOL] def test_property_mock ( ) : [EOL] with patch ( [string] , new_callable = PropertyMock ) as mock_foo : [EOL] mock_foo . return_value = [string] [EOL] this_foo = Foo ( ) [EOL] print ( this_foo . foo ) [EOL] this_foo . foo = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] assert mock_foo . mock_calls == [ call ( ) , call ( [number] ) ] [EOL] [EOL] [EOL] def test_property_mock_dynamic_set ( ) : [EOL] m = MagicMock ( ) [EOL] p = PropertyMock ( return_value = [number] ) [EOL] type ( m ) . foo = p [EOL] [EOL] assert m . foo == [number] [EOL] p . assert_called_once ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from mock import patch [EOL] [EOL] [EOL] class Foo : [EOL] def bar ( self ) : [EOL] pass [EOL] [EOL] [EOL] def test_kwargs ( ) : [EOL] with patch ( [string] , attribute1 = [string] ) as mock_foo : [EOL] assert mock_foo . attribute1 == [string] [EOL] [EOL] [EOL] def test_kwargs_2 ( ) : [EOL] with patch ( [string] , ** { [string] : [string] , [string] : [string] } ) as mock_foo : [EOL] assert mock_foo . method1 ( ) == [string] [EOL] assert mock_foo . attribute1 == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] from mock import patch [EOL] [EOL] [EOL] def name ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def birthday ( ) : [EOL] return [string] [EOL] [EOL] [EOL] def address ( ) : [EOL] return [string] [EOL] [EOL] [EOL] @ patch ( [string] , return_value = [string] ) @ patch ( [string] , return_value = [string] ) @ patch ( [string] , return_value = [string] ) class Test1 : [EOL] [EOL] def test_name_1 ( self , mock_address , mock_birthday , mock_name ) : [EOL] assert address ( ) == [string] [EOL] assert birthday ( ) == [string] [EOL] assert name ( ) == [string] [EOL] [EOL] def test_name_2 ( self , mock_address , mock_birthday , mock_name ) : [EOL] assert address ( ) == [string] [EOL] assert birthday ( ) == [string] [EOL] assert name ( ) == [string] [EOL] [EOL] [EOL] class Test2 : [EOL] @ pytest . fixture ( autouse = True ) def setup ( self ) : [EOL] self . mock_name = patch ( [string] ) . start ( ) [EOL] self . mock_birthday = patch ( [string] ) . start ( ) [EOL] self . mock_address = patch ( [string] ) . start ( ) [EOL] yield [EOL] patch . stopall [EOL] [EOL] def test_name_1 ( self ) : [EOL] self . mock_name . return_value = [string] [EOL] self . mock_birthday . return_value = [string] [EOL] self . mock_address . return_value = [string] [EOL] assert address ( ) == [string] [EOL] assert birthday ( ) == [string] [EOL] assert name ( ) == [string] [EOL] [EOL] def test_name_2 ( self ) : [EOL] self . mock_name . return_value = [string] [EOL] self . mock_birthday . return_value = [string] [EOL] self . mock_address . return_value = [string] [EOL] assert address ( ) == [string] [EOL] assert birthday ( ) == [string] [EOL] assert name ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any [EOL] import mock [EOL] import typing [EOL] from mock import Mock , sentinel , patch , ANY [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_sentinel ( ) : [EOL] class1 = Mock ( [string] ) [EOL] class1 . method = Mock ( name = [string] ) [EOL] class1 . method . return_value = sentinel . some_object [EOL] result = class1 . method ( ) [EOL] assert result is sentinel . some_object [EOL] [EOL] [EOL] def sum ( a , b ) : [EOL] return a + b [EOL] [EOL] [EOL] @ patch ( [string] ) def test_any ( sum_mock ) : [EOL] sum ( [number] , [number] ) [EOL] [EOL] sum_mock . assert_called_once_with ( [number] , ANY ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( ) def browser ( ) : [EOL] print ( [string] ) [EOL] yield [string] [EOL] print ( [string] ) [comment] [EOL] [EOL] [EOL] def test_should_run_setup_and_teardown ( browser ) : [EOL] print ( f" [string] { browser }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] ] ) def fruit ( request ) : [EOL] print ( f" [string] { request . function . __name__ } [string] " ) [EOL] print ( f" [string] { request . cls } [string] " ) [EOL] return request . param [EOL] [EOL] [EOL] def test_is_healthy ( fruit ) : [EOL] assert ( fruit in [ [string] , [string] , [string] ] ) is True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import pytest [EOL] [EOL] [EOL] class TestClass : [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def once_for_pytest_session ( self ) : [EOL] print ( [string] ) [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def once_for_package ( self , once_for_pytest_session ) : [EOL] print ( [string] ) [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def once_for_module ( self , once_for_package ) : [EOL] print ( [string] ) [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def once_for_class ( self , once_for_module ) : [EOL] print ( [string] ) [EOL] [EOL] @ pytest . fixture ( scope = [string] ) def each_function ( self , once_for_class ) : [EOL] print ( [string] ) [EOL] [EOL] def test_scope_order ( self , each_function ) : [EOL] pass [EOL] [EOL] def test_scope_order2 ( self , each_function , once_for_class , once_for_pytest_session ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def auto_trigger ( ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] def test_should_run_auto_trigger ( ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL]	0 0 0
[comment] [EOL] import pytest [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ pytest . fixture ( ) def fix1 ( ) : [EOL] print ( [string] ) [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def fix2 ( ) : [EOL] print ( [string] ) [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . mark . usefixtures ( [string] , [string] ) def test_1 ( fix1 , fix2 ) : [EOL] assert [string] == fix1 [EOL] assert [string] == fix2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
a = [number] [EOL] b = [string] [EOL] print ( a * b ) [EOL] [EOL] [EOL] def add ( num1 , num2 ) : [EOL] return num1 + num2 [EOL] [EOL] [EOL] class Demo : [EOL] pass [EOL]	$builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0