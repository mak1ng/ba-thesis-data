[comment] [EOL] [docstring] [EOL] [EOL] from setuptools import setup [EOL] from setuptools import find_packages [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] with open ( [string] , [string] , encoding = [string] ) as file : [EOL] readme = file . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = readme , long_description_content_type = [string] , author = [string] , author_email = [string] , packages = find_packages ( exclude = ( [string] , ) ) , package_data = { [string] : [ [string] ] } , install_requires = [ [string] , [string] , [string] , [string] , [string] , ] , url = [string] , keywords = [string] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from aioresponses import aioresponses [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . fixture def mock_aioresponse ( ) : [EOL] with aioresponses ( ) as mocked : [EOL] yield mocked [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from datetime import datetime [EOL] [EOL] import pytest [EOL] [EOL] from mediaarchiver . file_name_builder import DefaultFileNameBuilder [EOL] [EOL] [EOL] class TestDefaultFileNameBuilder : [EOL] @ staticmethod @ pytest . mark . parametrize ( [string] , [ ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , [string] , [string] ) , ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , [string] , [string] ) , ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , ( [string] [string] ) , ( [string] [string] ) ) , ] ) def test ( created_date_time , url , expected ) : [EOL] assert DefaultFileNameBuilder . build ( created_date_time , url ) == expected [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import pathlib [EOL] [docstring] [EOL] from pathlib import Path [EOL] [EOL] [EOL] class InstanceResource : [EOL] [docstring] [EOL] PATH_TESTS = Path ( __file__ ) . parent . parent [EOL] PATH_TEST_RESOURCES = PATH_TESTS / [string] [EOL] PATH_FILE_CONFIG_FOR_TEST = PATH_TEST_RESOURCES / [string] [EOL] PATH_FILE_IMAGE_97_97_BLUE = PATH_TEST_RESOURCES / [string] [EOL] PATH_FILE_IMAGE_97_97_GREEN = PATH_TEST_RESOURCES / [string] [EOL] PATH_FILE_IMAGE_97_97_RED = PATH_TEST_RESOURCES / [string] [EOL] PATH_FILE_IMAGE_97_97_YELLOW = PATH_TEST_RESOURCES / [string] [EOL] PATH_FILE_EMOJI_AMEBA_BLOG = PATH_TEST_RESOURCES / [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0
[comment] [EOL] from typing import List , TypeVar [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] import pathlib [EOL] from __future__ import annotations [EOL] from pathlib import Path [EOL] from datetime import datetime [EOL] from typing import List , Dict , TypeVar [EOL] [EOL] from dataclasses import dataclass , field [EOL] from dateutil . relativedelta import relativedelta [EOL] [EOL] [EOL] @ dataclass class Account : [EOL] _directory_download_home = ... [EOL] id = ... [EOL] name = ... [EOL] path_directory_download = field ( init = False ) [EOL] latest_file_datetime = field ( init = False ) [EOL] [EOL] def __post_init__ ( self ) : [EOL] self . path_directory_download = self . _directory_download_home / ( self . name + str ( self . id ) ) [EOL] self . path_directory_download . mkdir ( parents = True , exist_ok = True ) [EOL] files = sorted ( self . path_directory_download . glob ( [string] ) , reverse = True ) [EOL] self . latest_file_datetime = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) if not files else self . extract_datetime ( files [ [number] ] ) [EOL] [EOL] @ staticmethod def extract_datetime ( file ) : [EOL] latest_file_name = file . name [EOL] return datetime ( int ( latest_file_name [ [number] : [number] ] ) , int ( latest_file_name [ [number] : [number] ] ) , int ( latest_file_name [ [number] : [number] ] ) , int ( latest_file_name [ [number] : [number] ] ) , int ( latest_file_name [ [number] : [number] ] ) , int ( latest_file_name [ [number] : [number] ] ) ) [EOL] [EOL] def is_target_month ( self , month ) : [EOL] return self . latest_file_datetime < month + relativedelta ( months = [number] ) [EOL] [EOL] def is_target_diary ( self , created_datetime ) : [EOL] return self . latest_file_datetime < created_datetime [EOL] [EOL] [EOL] @ dataclass class AccountIterator : [EOL] [docstring] [EOL] accounts = ... [EOL] directory_download = ... [EOL] [EOL] def __iter__ ( self ) : [EOL] for account_id , account_name in self . accounts : [EOL] [comment] [EOL] yield Account ( self . directory_download , account_id , account_name ) [EOL] [EOL] [EOL] TypeVarAccount = TypeVar ( [string] , bound = Account ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Generator [EOL] import parallelmediadownloader [EOL] import pathlib [EOL] import datetime [EOL] import typing [EOL] import mediaarchiver [EOL] import builtins [EOL] from datetime import datetime [EOL] from pathlib import Path [EOL] from typing import List , Optional , Generator [EOL] [EOL] from parallelmediadownloader . media_download_coroutine import DownloadOrder [EOL] from parallelmediadownloader . media_save_coroutine import SaveOrder [EOL] [EOL] from mediaarchiver . article import Article [EOL] from mediaarchiver . file_name_builder import FileNameBuilder , DefaultFileNameBuilder [EOL] [EOL] [EOL] class DownloadOrderGenerator : [EOL] def __init__ ( self , base_url , path_directory_download , list_article , file_name_builder = None ) : [EOL] self . base_url = base_url [EOL] self . path_directory_download = path_directory_download [EOL] self . list_article = list_article [EOL] self . file_name_builder = self . set_default ( file_name_builder ) [EOL] [EOL] @ staticmethod def set_default ( file_name_builder ) : [EOL] return DefaultFileNameBuilder ( ) if file_name_builder is None else file_name_builder [EOL] [EOL] def __iter__ ( self ) : [EOL] for article in self . list_article : [EOL] for url_media in article . list_url_media : [EOL] yield self . create_coroutine ( self . build_url ( url_media ) , article . created_date_time ) [EOL] [EOL] def create_coroutine ( self , url , created_date_time ) : [EOL] return DownloadOrder ( url , SaveOrder ( self . path_directory_download , self . file_name_builder . build ( created_date_time , url ) , created_date_time ) ) [EOL] [EOL] def build_url ( self , url_media ) : [EOL] if url_media . startswith ( [string] ) : [EOL] return url_media [EOL] if url_media . startswith ( [string] ) : [EOL] return url_media . replace ( [string] , [string] , [number] ) [EOL] if url_media . startswith ( [string] ) : [EOL] return url_media . replace ( [string] , [string] , [number] ) [EOL] if url_media . startswith ( [string] ) : [EOL] return url_media . replace ( [string] , [string] , [number] ) [EOL] if url_media . startswith ( [string] ) : [EOL] return f' [string] { url_media }' [EOL] return self . base_url + url_media [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pathlib.Path$ 0 $typing.List[mediaarchiver.article.Article]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $typing.List[mediaarchiver.article.Article]$ 0 $typing.List[mediaarchiver.article.Article]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mediaarchiver.file_name_builder.FileNameBuilder$ 0 $typing.Optional[mediaarchiver.file_name_builder.FileNameBuilder]$ 0 0 0 0 0 0 0 0 $typing.Optional[mediaarchiver.file_name_builder.FileNameBuilder]$ 0 0 0 $typing.Optional[mediaarchiver.file_name_builder.FileNameBuilder]$ 0 0 0 $typing.Generator[parallelmediadownloader.media_download_coroutine.DownloadOrder,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $parallelmediadownloader.media_download_coroutine.DownloadOrder$ 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 $builtins.str$ 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] from typing import List , Tuple , Any , TypeVar [EOL] import parallelmediadownloader [EOL] import pathlib [EOL] import typing [EOL] import mediaarchiver [EOL] import builtins [EOL] [docstring] [EOL] from logging import getLogger [EOL] from pathlib import Path [EOL] from traceback import format_tb [EOL] from typing import TypeVar , Generic , List , Tuple [EOL] [EOL] from parallelmediadownloader . modeia_download_result import MediaDownloadResult [EOL] from parallelmediadownloader . parallel_media_downloader import ParallelMediaDownloader [EOL] [EOL] from mediaarchiver . download_order_generator import DownloadOrderGenerator [EOL] from mediaarchiver . models import Account [EOL] from mediaarchiver . sites import BlogSite [EOL] from mediaarchiver . micro_image_filter import MicroImageFilter [EOL] TypeVarAccount = TypeVar ( [string] , bound = Account ) [EOL] [EOL] [EOL] class MediaArchivingStep ( Generic [ TypeVarAccount ] ) : [EOL] [docstring] [EOL] def __init__ ( self , blog_site ) : [EOL] self . blog_site = blog_site [EOL] self . logger = getLogger ( __name__ ) [EOL] [EOL] def execute ( self , directory_download ) : [EOL] [docstring] [EOL] list_download_result = [ ] [EOL] list_exception = [ ] [EOL] for account in self . blog_site . web_site_context . config ( ) . account_iterator ( directory_download ) : [comment] [EOL] [comment] [EOL] try : [EOL] list_download_result . extend ( self . execute_per_account ( account ) ) [EOL] [comment] [EOL] except Exception as error : [EOL] list_exception . append ( ( account , error ) ) [EOL] for download_result in list_download_result : [EOL] self . logger . info ( f' [string] { download_result . status } [string] { download_result . url }' ) [EOL] if list_exception : [EOL] for ( account , exception ) in list_exception : [EOL] list_trace_back = [string] . join ( format_tb ( exception . __traceback__ ) ) [EOL] [comment] [EOL] self . logger . error ( f' [string] { account . id } [string] { account . name }' ) [EOL] self . logger . exception ( f'{ exception } [string] { list_trace_back }' ) [EOL] raise Exception ( [string] ) [EOL] [EOL] def execute_per_account ( self , account ) : [EOL] [docstring] [EOL] self . logger . info ( [string] ) [EOL] list_article = self . blog_site . list_up_article ( account ) [EOL] self . logger . info ( [string] ) [EOL] self . logger . debug ( list_article ) [EOL] self . logger . info ( [string] ) [EOL] download_order_generator = DownloadOrderGenerator ( self . blog_site . web_site_context . base_url , account . path_directory_download , list_article ) [EOL] list_download_result = ParallelMediaDownloader . execute ( download_order_generator , limit = self . blog_site . web_site_context . limit , media_filter = MicroImageFilter ( ) , allow_http_status = [ [number] ] ) [EOL] self . logger . info ( [string] ) [EOL] return [ download_result for download_result in list_download_result if download_result . status != [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $mediaarchiver.sites.BlogSite[typing.Any]$ 0 0 0 0 0 $mediaarchiver.sites.BlogSite[typing.Any]$ 0 $mediaarchiver.sites.BlogSite[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.List[parallelmediadownloader.modeia_download_result.MediaDownloadResult]$ 0 0 0 0 $typing.List[typing.Tuple[TypeVarAccount,builtins.Exception]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $typing.List[parallelmediadownloader.modeia_download_result.MediaDownloadResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[TypeVarAccount,builtins.Exception]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[parallelmediadownloader.modeia_download_result.MediaDownloadResult]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[TypeVarAccount,builtins.Exception]]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[TypeVarAccount,builtins.Exception]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[parallelmediadownloader.modeia_download_result.MediaDownloadResult]$ 0 0 0 $TypeVarAccount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $TypeVarAccount$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $mediaarchiver.download_order_generator.DownloadOrderGenerator$ 0 0 0 0 0 0 0 0 0 0 0 $TypeVarAccount$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $mediaarchiver.download_order_generator.DownloadOrderGenerator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
import parallelmediadownloader [EOL] import builtins [EOL] from PIL import Image [EOL] from parallelmediadownloader . media_file import MediaFile [EOL] from parallelmediadownloader . media_filter import NotImageFilter [EOL] [EOL] [EOL] class MicroImageFilter ( NotImageFilter ) : [EOL] PIXEL_EMOJI_AMEBA_BLOG = [number] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * , threshold_width = PIXEL_EMOJI_AMEBA_BLOG , threshold_height = PIXEL_EMOJI_AMEBA_BLOG ) : [EOL] self . threshold_width = threshold_width [EOL] self . threshold_height = threshold_height [EOL] [EOL] def _filter ( self , media_file ) : [EOL] if super ( ) . _filter ( media_file ) : [EOL] return True [EOL] with Image . open ( media_file . path_file ) as image : [EOL] width , height = image . size [EOL] return width <= self . threshold_width or height <= self . threshold_height [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $parallelmediadownloader.media_file.MediaFile$ 0 0 0 0 0 0 0 0 0 0 $parallelmediadownloader.media_file.MediaFile$ 0 0 0 0 0 0 0 0 0 0 0 $parallelmediadownloader.media_file.MediaFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import builtins [EOL] from abc import abstractmethod [EOL] from datetime import datetime [EOL] [EOL] [EOL] class FileNameBuilder : [EOL] @ staticmethod @ abstractmethod def build ( created_date_time , url ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] class DefaultFileNameBuilder ( FileNameBuilder ) : [EOL] @ staticmethod def build ( created_date_time , url ) : [EOL] file_name = url . replace ( [string] , created_date_time . strftime ( [string] ) ) . replace ( [string] , [string] ) [EOL] index_question = file_name . find ( [string] ) [EOL] if index_question >= [number] : [EOL] file_name = file_name [ : index_question ] [EOL] return file_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $datetime.datetime.datetime$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0
from mediaarchiver import CONFIG , Directory [EOL] from mediaarchiver . media_archiving_step import MediaArchivingStep [EOL] from mediaarchiver . sites import Site [EOL] from mediaarchiver . sites . twitter import Twitter [EOL] [EOL] [EOL] class MediaArchiver : [EOL] @ classmethod def execute ( cls ) : [EOL] CONFIG . load ( ) [EOL] MediaArchivingStep ( Twitter ( Site . TWITTER . value ) ) . execute ( Directory . DOWNLOAD . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from datetime import datetime [EOL] from dataclasses import dataclass [EOL] from typing import List [EOL] [EOL] [EOL] @ dataclass class Article : [EOL] created_date_time = ... [EOL] list_url_media = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 $typing.List[builtins.str]$ 0 0 0
[docstring] [EOL] [EOL] [EOL] class Error ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
import mediaarchiver [EOL] from abc import ABC [EOL] from parallelhtmlscraper . html_analyzer import HtmlAnalyzer [EOL] from mediaarchiver . models import TypeVarAccount [EOL] [EOL] [EOL] [comment] [EOL] class ArticlePageUrlAnalyzer ( HtmlAnalyzer , ABC ) : [EOL] def __init__ ( self , account ) : [EOL] self . account = account [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any [EOL] import bs4 [EOL] import datetime [EOL] import typing [EOL] import mediaarchiver [EOL] import builtins [EOL] from dataclasses import dataclass [EOL] from datetime import datetime [EOL] from typing import List [EOL] [EOL] [comment] [EOL] from bs4 import BeautifulSoup , Tag [EOL] from parallelhtmlscraper . html_analyzer import HtmlAnalyzer [EOL] [EOL] from mediaarchiver . article import Article [EOL] [EOL] [EOL] class DatetimeExtractor : [EOL] @ classmethod def execute ( cls , soup , tag_article_area ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] [EOL] @ dataclass class ClueArticle : [EOL] tag_article_area = ... [EOL] class_article_area = ... [EOL] datetime_extractor = ... [EOL] [EOL] [EOL] class ArticleAnalyzer ( HtmlAnalyzer ) : [EOL] PIXEL_EMOJI_AMEBA_BLOG = [number] [EOL] [EOL] def __init__ ( self , clue_article ) : [EOL] self . clue_article = clue_article [EOL] [EOL] async def execute ( self , soup ) : [EOL] list_tag_article_area = soup . find_all ( self . clue_article . tag_article_area , class_ = self . clue_article . class_article_area ) [EOL] return [ self . create_article ( soup , tag ) for tag in list_tag_article_area ] [EOL] [EOL] def create_article ( self , beautiful_soup , tag_article_area ) : [EOL] list_url_image = list ( { image_tag . get ( [string] ) for image_tag in tag_article_area . find_all ( [string] ) if self . is_target_image_tag ( image_tag ) } ) [EOL] return Article ( self . clue_article . datetime_extractor . execute ( beautiful_soup , tag_article_area ) , list_url_image ) [EOL] [EOL] @ classmethod def is_target_image_tag ( cls , image_tag ) : [EOL] return ( image_tag . has_attr ( [string] ) and image_tag . get ( [string] ) . find ( [string] ) == - [number] and ( not image_tag . has_attr ( [string] ) or int ( image_tag . get ( [string] ) ) > cls . PIXEL_EMOJI_AMEBA_BLOG ) and ( not image_tag . has_attr ( [string] ) or int ( image_tag . get ( [string] ) ) > cls . PIXEL_EMOJI_AMEBA_BLOG ) and ( not image_tag . get ( [string] ) . startswith ( [string] ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $bs4.BeautifulSoup$ 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $DatetimeExtractor$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $mediaarchiver.htmlanalyzer.article_analyzer.ClueArticle$ 0 0 0 0 0 $mediaarchiver.htmlanalyzer.article_analyzer.ClueArticle$ 0 $mediaarchiver.htmlanalyzer.article_analyzer.ClueArticle$ 0 0 0 0 $typing.List[mediaarchiver.article.Article]$ 0 0 0 $bs4.BeautifulSoup$ 0 0 0 $typing.Any$ 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $mediaarchiver.article.Article$ 0 0 0 $bs4.BeautifulSoup$ 0 $bs4.Tag$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.BeautifulSoup$ 0 $bs4.Tag$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $bs4.Tag$ 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bs4.Tag$ 0 0 0 0 0 0 0 0 0 0 0 0 0