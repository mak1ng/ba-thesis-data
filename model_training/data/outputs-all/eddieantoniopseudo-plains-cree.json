[comment] [EOL] [comment] [EOL] [EOL] from setuptools import setup [EOL] [EOL] setup ( name = [string] , version = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Pattern [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] from hypothesis import given [comment] [EOL] from hypothesis . strategies import composite , random_module [comment] [EOL] [EOL] from pseudo_plains_cree import generate , grammar [EOL] [EOL] [EOL] @ composite def utterances ( draw ) : [EOL] random = draw ( random_module ( ) ) [EOL] return generate ( ) [EOL] [EOL] [EOL] @ given ( utterances ( ) ) def test_basic_usage ( utterance ) : [EOL] [docstring] [EOL] assert any ( is_vowel ( c ) for c in utterance ) [EOL] [EOL] [EOL] @ given ( utterances ( ) ) def test_vowels ( utterance ) : [EOL] [docstring] [EOL] assert not any ( is_vowel ( g1 ) and is_vowel ( g2 ) for g1 , g2 in bigrams ( utterance ) ) [EOL] [EOL] [EOL] @ given ( utterances ( ) ) def test_doubled_grams ( utterance ) : [EOL] [docstring] [EOL] assert all ( g1 != g2 for g1 , g2 in bigrams ( utterance ) ) [EOL] [EOL] [EOL] @ given ( utterances ( ) ) def test_grammar_regular_expression ( utterance ) : [EOL] [docstring] [EOL] pattern = re . compile ( grammar . to_regex ( ) ) [EOL] assert pattern . match ( utterance ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def is_vowel ( char ) : [EOL] [docstring] [EOL] if len ( char ) != [number] : [EOL] raise ValueError ( [string] + repr ( char ) ) [EOL] return char in [string] [EOL] [EOL] [EOL] def bigrams ( text ) : [EOL] [docstring] [EOL] return zip ( text , text [ [number] : ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import TextIO , Any , Dict , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import re [EOL] from random import choice [EOL] from typing import Dict , Sequence , TextIO [EOL] [EOL] from dataclasses import dataclass [EOL] [EOL] [EOL] class Production : [EOL] def generate ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def to_regex ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class Grammar : [EOL] start_name = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . productions = { } [EOL] [EOL] def __getitem__ ( self , name ) : [EOL] return self . productions [ name ] [EOL] [EOL] def __setitem__ ( self , name , definition ) : [EOL] self . productions [ name ] = definition [EOL] if not hasattr ( self , [string] ) : [EOL] self . start_name = name [EOL] [EOL] @ property def start ( self ) : [EOL] return self [ self . start_name ] [EOL] [EOL] def generate ( self ) : [EOL] return self . start . generate ( ) [EOL] [EOL] def to_regex ( self ) : [EOL] return self . start . to_regex ( ) [EOL] [EOL] [EOL] @ dataclass class ProductionReference ( Production ) : [EOL] grammar = ... [EOL] ref = ... [EOL] [EOL] def _dereference ( self ) : [EOL] return self . grammar [ self . ref ] [EOL] [EOL] def generate ( self ) : [EOL] return self . _dereference ( ) . generate ( ) [EOL] [EOL] def to_regex ( self ) : [EOL] return self . _dereference ( ) . to_regex ( ) [EOL] [EOL] [EOL] @ dataclass class Terminal ( Production ) : [EOL] literal = ... [EOL] [EOL] def generate ( self ) : [EOL] return self . literal [EOL] [EOL] def to_regex ( self ) : [EOL] return re_uescape ( self . literal ) [EOL] [EOL] [EOL] @ dataclass class Maybe ( Production ) : [EOL] rule = ... [EOL] [EOL] def generate ( self ) : [EOL] if choice ( ( True , False ) ) : [EOL] return self . rule . generate ( ) [EOL] return [string] [EOL] [EOL] def to_regex ( self ) : [EOL] inner_re = self . rule . to_regex ( ) [EOL] [EOL] [comment] [EOL] if is_single_char_terminal ( self . rule ) or wrapped_in_parens ( inner_re ) : [EOL] return inner_re + [string] [EOL] [EOL] return f" [string] { inner_re } [string] " [EOL] [EOL] [EOL] @ dataclass class Concatenation ( Production ) : [EOL] components = ... [EOL] [EOL] def generate ( self ) : [EOL] return [string] . join ( c . generate ( ) for c in self . components ) [EOL] [EOL] def to_regex ( self ) : [EOL] return [string] . join ( c . to_regex ( ) for c in self . components ) [EOL] [EOL] [EOL] @ dataclass class Alternation ( Production ) : [EOL] alternatives = ... [EOL] [EOL] def generate ( self ) : [EOL] return choice ( self . alternatives ) . generate ( ) [EOL] [EOL] def to_regex ( self ) : [EOL] [comment] [EOL] if all ( is_single_char_terminal ( a ) for a in self . alternatives ) : [EOL] return [string] + [string] . join ( a . to_regex ( ) for a in self . alternatives ) + [string] [EOL] return [string] + [string] . join ( a . to_regex ( ) for a in self . alternatives ) + [string] [EOL] [EOL] [EOL] class Parser : [EOL] def parse_file ( self , grammar_file ) : [EOL] self . grammar = Grammar ( ) [EOL] for line in grammar_file : [EOL] self . parse_production ( line ) [EOL] return self . grammar [EOL] [EOL] def parse_production ( self , line ) : [EOL] if line . strip ( ) == [string] or line . lstrip ( ) . startswith ( [string] ) : [EOL] return [EOL] [comment] [EOL] name , definition = line . split ( [string] ) [EOL] name = name . strip ( ) [EOL] self . grammar [ name ] = self . parse_definition ( definition ) [EOL] [EOL] def parse_definition ( self , definition ) : [EOL] alternatives = [ self . parse_alternative ( d . strip ( ) ) for d in definition . split ( [string] ) ] [EOL] [EOL] if len ( alternatives ) > [number] : [EOL] return Alternation ( alternatives ) [EOL] else : [EOL] return alternatives [ [number] ] [EOL] [EOL] def parse_alternative ( self , alternative ) : [EOL] concatenation = [ a . strip ( ) for a in alternative . split ( ) ] [EOL] [comment] [EOL] if len ( concatenation ) == [number] : [EOL] return self . parse_optional ( concatenation [ [number] ] ) [EOL] return Concatenation ( [ self . parse_optional ( o ) for o in concatenation ] ) [EOL] [EOL] def parse_value ( self , text ) : [EOL] if first_char_uppercase ( text ) : [EOL] return ProductionReference ( self . grammar , text ) [EOL] else : [EOL] return Terminal ( text ) [EOL] [EOL] def parse_optional ( self , text ) : [EOL] if text . endswith ( [string] ) : [EOL] return Maybe ( self . parse_value ( text [ : - [number] ] ) ) [EOL] else : [EOL] return self . parse_value ( text ) [EOL] [EOL] [EOL] def first_char_uppercase ( text ) : [EOL] return text [ : [number] ] . upper ( ) == text [ : [number] ] [EOL] [EOL] [EOL] def is_single_char_terminal ( p ) : [EOL] return isinstance ( p , Terminal ) and len ( p . literal ) == [number] [EOL] [EOL] [EOL] def wrapped_in_parens ( s ) : [EOL] return bool ( re . match ( [string] , s ) ) [EOL] [EOL] [EOL] def re_uescape ( text ) : [EOL] [docstring] [EOL] return [string] . join ( re . escape ( c ) if c < [string] else c for c in text ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Production]$ 0 0 0 0 0 0 $Production$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $Production$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $Production$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $Production$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Grammar$ 0 0 0 $builtins.str$ 0 0 0 0 0 $Production$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Production$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[Production]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[Production]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Grammar$ 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $Production$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $Production$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $Production$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import builtins [EOL] import sys [EOL] from pseudo_plains_cree import grammar , lorem , generate [EOL] [EOL] [EOL] def main ( _program_name , command = [string] , * _ ) : [EOL] if command == [string] : [EOL] print ( lorem ( ) ) [EOL] elif command == [string] : [EOL] print ( generate ( ) ) [EOL] elif command == [string] : [EOL] print ( grammar . to_regex ( ) ) [EOL] else : [EOL] print ( [string] , file = sys . stderr ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( * sys . argv ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any , Tuple [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] import pseudo_plains_cree [EOL] [docstring] [EOL] [EOL] from pathlib import Path [EOL] from random import randint [EOL] [EOL] from . _grammar import Parser [EOL] [EOL] [EOL] here = Path ( __file__ ) . parent [EOL] with open ( here / [string] ) as grammar_file : [EOL] grammar = Parser ( ) . parse_file ( grammar_file ) [EOL] [EOL] [EOL] def generate ( min_syllables = [number] , max_syllables = [number] ) : [EOL] [docstring] [EOL] VOWELS = tuple ( [string] ) [EOL] [EOL] needed = randint ( min_syllables , max_syllables ) [EOL] [comment] [EOL] utterance = grammar . generate ( ) [EOL] [EOL] generated = [number] [EOL] while generated < needed : [EOL] syllable = grammar . generate ( ) [EOL] if utterance . endswith ( VOWELS ) and syllable . startswith ( VOWELS ) : [EOL] continue [EOL] if syllable . startswith ( utterance [ - [number] ] ) : [EOL] continue [EOL] utterance += syllable [EOL] generated += [number] [EOL] [EOL] return utterance [EOL] [EOL] [EOL] def lorem ( min_words = [number] , max_words = [number] ) : [EOL] [docstring] [EOL] needed = randint ( min_words , max_words ) [EOL] sentence = [string] . join ( generate ( ) for _ in range ( needed ) ) [EOL] return sentence . capitalize ( ) + [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pseudo_plains_cree._grammar.Grammar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pseudo_plains_cree._grammar.Grammar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pseudo_plains_cree._grammar.Grammar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0