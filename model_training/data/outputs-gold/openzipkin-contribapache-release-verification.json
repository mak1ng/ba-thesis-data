from typing import Union , Optional , Type , Dict , Any , List , Callable [EOL] import filecmp [EOL] import report [EOL] import typing [EOL] import builtins [EOL] import src [EOL] import filecmp [EOL] import functools [EOL] import logging [EOL] import os [EOL] import traceback [EOL] from abc import ABC , abstractmethod [EOL] from dataclasses import dataclass [EOL] from typing import Callable , Dict , List , Optional , Tuple , Union [EOL] [EOL] import apache_2_license [EOL] from helpers import sh , step [EOL] from report import Report , Result , ResultKind , color_result [EOL] [EOL] [EOL] @ dataclass class State : [EOL] project = ... [EOL] module = ... [EOL] version = ... [EOL] work_dir = ... [EOL] incubating = ... [EOL] zipname_template = ... [EOL] sourcedir_template = ... [EOL] github_reponame_template = ... [EOL] gpg_key = ... [EOL] git_hash = ... [EOL] build_and_test_command = ... [EOL] [EOL] def _generate_optional_placeholders ( self , key , value , condition ) : [EOL] [docstring] [EOL] separators = { [string] : [string] , [string] : [string] } [EOL] retval = { } [EOL] [comment] [EOL] retval . update ( { f"{ sep_name } [string] { key }" : f"{ sep_val }{ value }" if condition else [string] for sep_name , sep_val in separators . items ( ) } ) [EOL] [comment] [EOL] retval . update ( { f"{ key } [string] { sep_name }" : f"{ value }{ sep_val }" if condition else [string] for sep_name , sep_val in separators . items ( ) } ) [EOL] [comment] [EOL] return retval [EOL] [EOL] @ property def _pattern_placeholders ( self ) : [EOL] return { [string] : self . project , [string] : self . module or [string] , [string] : self . module or self . project , [string] : self . version , ** self . _generate_optional_placeholders ( [string] , str ( self . module ) , self . module is not None ) , ** self . _generate_optional_placeholders ( [string] , [string] , self . incubating ) , ** self . _generate_optional_placeholders ( [string] , [string] , self . incubating ) , } [EOL] [EOL] @ classmethod def list_placeholder_keys ( cls ) : [EOL] [comment] [EOL] instance = cls ( [string] , [string] , [string] , [string] , False , [string] , [string] , [string] , [string] , [string] , None ) [EOL] return list ( instance . _pattern_placeholders . keys ( ) ) [EOL] [EOL] def _format_template ( self , template ) : [EOL] try : [EOL] return template . format ( ** self . _pattern_placeholders ) [EOL] except KeyError as e : [EOL] raise Exception ( f" [string] { e . args [ [number] ] } [string] " f"{ [string] . join ( self . _pattern_placeholders . keys ( ) ) }" ) [EOL] [EOL] @ property def release_dir ( self ) : [EOL] return os . path . join ( self . work_dir , self . module or self . project , self . version ) [EOL] [EOL] @ property def base_path ( self ) : [EOL] filename = self . _format_template ( self . zipname_template ) [EOL] return os . path . join ( self . release_dir , filename ) [EOL] [EOL] @ property def zip_path ( self ) : [EOL] return self . base_path + [string] [EOL] [EOL] @ property def sha512_path ( self ) : [EOL] return self . zip_path + [string] [EOL] [EOL] @ property def keys_path ( self ) : [EOL] return os . path . join ( self . work_dir , [string] ) [EOL] [EOL] @ property def asc_path ( self ) : [EOL] return self . zip_path + [string] [EOL] [EOL] @ property def unzipped_dir ( self ) : [EOL] return os . path . join ( self . work_dir , [string] ) [EOL] [EOL] @ property def source_dir ( self ) : [EOL] dirname = self . _format_template ( self . sourcedir_template ) [EOL] return os . path . join ( self . unzipped_dir , dirname ) [EOL] [EOL] @ property def git_repo_name ( self ) : [EOL] return self . _format_template ( self . github_reponame_template ) [EOL] [EOL] @ property def git_dir ( self ) : [EOL] return os . path . join ( self . work_dir , [string] , self . git_repo_name ) [EOL] [EOL] [EOL] R = Optional [ Tuple [ str , ResultKind ] ] [EOL] CheckFun = Callable [ [ State ] , R ] [EOL] [EOL] [EOL] class Check : [EOL] def __init__ ( self , fun , name = None , hide_if_passing = False ) : [EOL] self . _fun = fun [EOL] self . name = self . _generate_nice_name ( name ) [EOL] self . hide_if_passing = hide_if_passing [EOL] [EOL] def _generate_nice_name ( self , name ) : [EOL] if name is not None : [EOL] return name [EOL] name = self . _fun . __name__ [EOL] if name . startswith ( [string] ) : [EOL] name = name [ [number] : ] [EOL] name = name . replace ( [string] , [string] ) [EOL] return name [EOL] [EOL] def __call__ ( self , state ) : [EOL] maybe_problem = self . _fun ( state ) [EOL] if maybe_problem is None : [EOL] return Result . passed ( self . name , self . hide_if_passing ) [EOL] else : [EOL] return Result . failed ( self . name , self . hide_if_passing , * maybe_problem ) [EOL] [EOL] [EOL] def check ( name = None , hide_if_passing = False ) : [EOL] def make_check ( fun ) : [EOL] c = Check ( fun , name , hide_if_passing ) [EOL] functools . update_wrapper ( c , fun ) [EOL] return c [EOL] [EOL] return make_check [EOL] [EOL] [EOL] def run_checks ( state , checks ) : [EOL] results = [ ] [EOL] for check in checks : [EOL] step ( f" [string] { check . name }" ) [EOL] try : [EOL] result = check ( state ) [EOL] except Exception as ex : [EOL] result = Result . failed ( check . name , check . hide_if_passing , [string] . join ( traceback . format_exception_only ( ex . __class__ , ex ) ) . strip ( ) , ResultKind . ERROR , ) [EOL] if not result . is_passed : [EOL] msg = str ( result . message ) [EOL] [comment] [EOL] [comment] [EOL] if result . kind is not ResultKind . NOTE : [EOL] msg = color_result ( msg , result . kind ) [EOL] print ( msg ) [EOL] results . append ( result ) [EOL] return Report ( results ) [EOL] [EOL] [EOL] def _check_sh ( cmds , workdir = None , failure_level = ResultKind . FAIL , ) : [EOL] if isinstance ( cmds , str ) : [EOL] cmds = [ cmds ] [EOL] for cmd in cmds : [EOL] status = sh ( cmd , workdir ) [EOL] if status != [number] : [EOL] msg = f" [string] { cmd } [string] " [EOL] if workdir is not None : [EOL] msg += f" [string] { workdir }" [EOL] msg += f" [string] { status } [string] " [EOL] msg += [string] [EOL] msg += [string] [EOL] return msg , failure_level [EOL] return None [EOL] [EOL] [EOL] @ check ( [string] ) def check_zip_file_exists ( state ) : [EOL] return _check_sh ( f" [string] { state . zip_path }" ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_sha512_file_exists ( state ) : [EOL] return _check_sh ( f" [string] { state . sha512_path }" ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_asc_file_exists ( state ) : [EOL] return _check_sh ( f" [string] { state . asc_path }" ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_keys_file_exists ( state ) : [EOL] return _check_sh ( f" [string] { state . keys_path }" ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_sha512 ( state ) : [EOL] return _check_sh ( f" [string] { state . sha512_path }" , workdir = state . release_dir ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_gpg_key_in_keys_file ( state ) : [EOL] return _check_sh ( [string] f" [string] { state . keys_path } [string] " [string] f" [string] { state . gpg_key } [string] " ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_gpg_signature ( state ) : [EOL] full_keyring = os . path . join ( state . work_dir , [string] ) [EOL] strict_keyfile = os . path . join ( state . work_dir , [string] ) [EOL] strict_keyring = os . path . join ( state . work_dir , [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return _check_sh ( [ ( f" [string] { full_keyring } [string] " f" [string] { state . keys_path }" ) , ( f" [string] { full_keyring } [string] " f" [string] { state . gpg_key } [string] { strict_keyfile }" ) , ( f" [string] { strict_keyring } [string] " f" [string] { strict_keyfile }" ) , ( f" [string] { strict_keyring } [string] { state . asc_path } [string] { state . zip_path }" ) , ] ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_unzip ( state ) : [EOL] return _check_sh ( f" [string] { state . unzipped_dir } [string] { state . zip_path }" ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_source_dir_in_zip ( state ) : [EOL] return _check_sh ( f" [string] { state . source_dir }" ) [EOL] [EOL] [EOL] def _check_dircmp_only_either_allowed ( diff ) : [EOL] errors = [ ] [EOL] allowed_left_only = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] allowed_right_only = [ [string] , [string] ] [EOL] [comment] [EOL] for filename in diff . left_only : [EOL] if filename not in allowed_left_only : [EOL] errors . append ( os . path . join ( diff . left , filename ) + [string] ) [EOL] [comment] [EOL] for filename in diff . right_only : [EOL] if filename not in allowed_right_only : [EOL] errors . append ( os . path . join ( diff . right , filename ) + [string] ) [EOL] [comment] [EOL] for subdiff in diff . subdirs . values ( ) : [EOL] errors += _check_dircmp_only_either_allowed ( subdiff ) [EOL] return errors [EOL] [EOL] [EOL] def _check_dircmp_no_diff_files ( diff ) : [EOL] errors = [ ] [EOL] if diff . diff_files : [EOL] errors += [string] + [string] . join ( diff . diff_files ) [EOL] for subdiff in diff . subdirs . values ( ) : [EOL] errors += _check_dircmp_no_diff_files ( subdiff ) [EOL] return errors [EOL] [EOL] [EOL] def _check_dircmp_no_funny_files ( diff ) : [EOL] errors = [ ] [EOL] if diff . funny_files : [EOL] errors += [string] + [string] . join ( diff . diff_files ) [EOL] for subdiff in diff . subdirs . values ( ) : [EOL] errors += _check_dircmp_no_diff_files ( subdiff ) [EOL] return errors [EOL] [EOL] [EOL] @ check ( [string] ) def check_git_revision ( state ) : [EOL] sh_result = _check_sh ( [ ( f" [string] { state . git_repo_name } [string] " f"{ state . git_dir }" ) , ( f" [string] { state . git_dir } [string] " f" [string] { state . git_dir } [string] " f" [string] { state . git_hash }" ) , ] ) [EOL] if sh_result is not None : [EOL] return sh_result [EOL] [EOL] logging . info ( [string] ) [EOL] logging . info ( [string] ) [EOL] sh ( f" [string] { state . git_dir } [string] { state . source_dir }" ) [EOL] [EOL] diff = filecmp . dircmp ( state . git_dir , state . source_dir , ignore = [ ] ) [EOL] errors = [ ] [EOL] [EOL] [comment] [EOL] errors += _check_dircmp_only_either_allowed ( diff ) [EOL] [EOL] [comment] [EOL] errors += _check_dircmp_no_diff_files ( diff ) [EOL] [comment] [EOL] errors += _check_dircmp_no_funny_files ( diff ) [EOL] [EOL] if errors : [EOL] errors . append ( [string] ) [EOL] return [string] . join ( errors ) , ResultKind . WARN [EOL] return None [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_blacklisted_files ( state ) : [EOL] blacklist = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] commands = [ f" [string] { state . source_dir } [string] { item } [string] " for item in blacklist ] [EOL] return _check_sh ( commands ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_gitignore_in_repo ( state ) : [EOL] return _check_sh ( [string] , workdir = state . git_dir ) [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = False ) def check_gitignore_in_release ( state ) : [EOL] result = _check_sh ( f" [string] { state . source_dir }" , workdir = state . git_dir , ) [EOL] if not result : [EOL] result = _check_sh ( [ [string] , [string] , ] , workdir = state . source_dir , ) [EOL] sh ( f" [string] { state . source_dir } [string] " ) [EOL] sh ( f" [string] { state . source_dir } [string] " ) [EOL] return result [EOL] [EOL] [EOL] def _check_file_looks_good ( path ) : [EOL] prompt = f" [string] { path } [string] " [EOL] return _check_sh ( [ f" [string] { path }" , f" [string] { prompt } [string] " ] ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_disclaimer_and_notice_look_good ( state ) : [EOL] errors = [ ] [EOL] for path in [ [string] , [string] ] : [EOL] result = _check_file_looks_good ( os . path . join ( state . source_dir , path ) ) [EOL] if result is not None : [EOL] errors . append ( result [ [number] ] ) [EOL] if errors : [EOL] return [string] . join ( errors ) , ResultKind . FAIL [EOL] return None [EOL] [EOL] [EOL] @ check ( [string] , hide_if_passing = True ) def check_license_is_apache_2 ( state ) : [EOL] actual_license_path = os . path . join ( state . source_dir , [string] ) [EOL] expected_license = apache_2_license . text [EOL] with open ( actual_license_path , [string] ) as f : [EOL] actual_license = f . read ( ) [EOL] if not actual_license . startswith ( expected_license ) : [EOL] return [string] , ResultKind . FAIL [EOL] return None [EOL] [EOL] [EOL] @ check ( [string] ) def check_license_looks_good ( state ) : [EOL] return _check_file_looks_good ( os . path . join ( state . source_dir , [string] ) ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_no_binary_files ( state ) : [EOL] return _check_sh ( f" [string] { state . source_dir } [string] " [string] , failure_level = ResultKind . NOTE , ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BuildAndTest ( ABC ) : [EOL] @ abstractmethod def name ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def should_run ( self , state ) : [EOL] pass [EOL] [EOL] @ abstractmethod def run ( self , state ) : [EOL] pass [EOL] [EOL] [EOL] class BuildAndTestMaven ( BuildAndTest ) : [EOL] def name ( self ) : [EOL] return [string] [EOL] [EOL] def should_run ( self , state ) : [EOL] return os . path . exists ( os . path . join ( state . source_dir , [string] ) ) [EOL] [EOL] def run ( self , state ) : [EOL] return _check_sh ( [ [string] , [string] , ] , workdir = state . source_dir , ) [EOL] [EOL] [EOL] class BuildAndTestNpm ( BuildAndTest ) : [EOL] def name ( self ) : [EOL] return [string] [EOL] [EOL] def should_run ( self , state ) : [EOL] return os . path . exists ( os . path . join ( state . source_dir , [string] ) ) [EOL] [EOL] def run ( self , state ) : [EOL] return _check_sh ( [string] , workdir = state . source_dir ) [EOL] [EOL] [EOL] @ check ( [string] ) def check_build_and_test ( state ) : [EOL] if state . build_and_test_command is not None : [EOL] return _check_sh ( state . build_and_test_command , workdir = state . source_dir ) [EOL] [EOL] strategies = [ BuildAndTestMaven ( ) , BuildAndTestNpm ( ) ] [EOL] errors = [ ] [EOL] executed_at_least_one = False [EOL] [EOL] for strategy in strategies : [EOL] if not strategy . should_run ( state ) : [EOL] continue [EOL] executed_at_least_one = True [EOL] print ( f" [string] { strategy . name ( ) }" ) [EOL] err = strategy . run ( state ) [EOL] if err is not None : [EOL] errors . append ( f"{ strategy . name ( ) } [string] { err }" ) [EOL] [EOL] if not executed_at_least_one : [EOL] return ( [string] [string] [string] [string] [string] , ResultKind . NOTE , ) [EOL] [EOL] if errors : [EOL] return [string] . join ( errors ) , ResultKind . FAIL [EOL] return None [EOL] [EOL] [EOL] checks = [ check_zip_file_exists , check_sha512_file_exists , check_keys_file_exists , check_asc_file_exists , check_sha512 , check_gpg_key_in_keys_file , check_gpg_signature , check_unzip , check_source_dir_in_zip , check_git_revision , check_blacklisted_files , check_disclaimer_and_notice_look_good , check_license_is_apache_2 , check_license_looks_good , check_no_binary_files , check_build_and_test , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $src.checks.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.checks.State$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $CheckFun$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $CheckFun$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $report.Result$ 0 0 0 $State$ 0 0 0 $typing.Any$ 0 0 0 0 0 $State$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Callable[[CheckFun],Check]$ 0 0 0 0 0 0 0 0 0 0 0 0 $Check$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $report.Report$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 $State$ 0 0 0 0 0 0 0 0 0 0 0 0 $R$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
text = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Any , Dict [EOL] import builtins [EOL] import src [EOL] import typing [EOL] import logging [EOL] from enum import Enum , auto [EOL] from math import ceil , floor [EOL] from typing import List , NamedTuple , Optional [EOL] [EOL] from colorama import Fore , Style [EOL] [EOL] from helpers import header [EOL] [EOL] [EOL] class ResultKind ( Enum ) : [EOL] PASS = auto ( ) [EOL] FAIL = auto ( ) [EOL] WARN = auto ( ) [EOL] NOTE = auto ( ) [EOL] ERROR = auto ( ) [EOL] [EOL] [EOL] RESULT_STYLES = { ResultKind . PASS : Fore . GREEN , ResultKind . FAIL : Fore . RED , ResultKind . WARN : Fore . YELLOW , ResultKind . NOTE : Fore . BLUE , ResultKind . ERROR : Fore . RED , } [EOL] [EOL] [EOL] class Result ( NamedTuple ) : [EOL] name = ... [EOL] hide_if_passing = ... [EOL] message = ... [EOL] kind = ... [EOL] [EOL] @ staticmethod def passed ( name , hide_if_passing ) : [EOL] return Result ( name , hide_if_passing , None , ResultKind . PASS ) [EOL] [EOL] @ staticmethod def failed ( name , hide_if_passing , message , kind ) : [EOL] return Result ( name , hide_if_passing , message , kind ) [EOL] [EOL] @ property def is_passed ( self ) : [EOL] return self . kind is ResultKind . PASS [EOL] [EOL] [EOL] class Report ( NamedTuple ) : [EOL] results = ... [EOL] [EOL] @ property def problem_count ( self ) : [EOL] problems = [number] [EOL] for result in self . results : [EOL] if not result . is_passed : [EOL] problems += [number] [EOL] return problems [EOL] [EOL] [EOL] def color_result ( msg , kind ) : [EOL] prefix = RESULT_STYLES . get ( kind , [string] ) [EOL] return f"{ prefix }{ msg }{ Style . RESET_ALL }" [EOL] [EOL] [EOL] def print_report ( report ) : [EOL] header ( [string] ) [EOL] max_len = max ( len ( result . kind . name ) for result in report . results ) [EOL] for result in report . results : [EOL] if result . is_passed and result . hide_if_passing : [EOL] continue [EOL] padding_left = [string] * ceil ( ( max_len - len ( result . kind . name ) ) / [number] ) [EOL] padding_right = [string] * floor ( ( max_len - len ( result . kind . name ) ) / [number] ) [EOL] prefix = color_result ( result . kind . name , result . kind ) [EOL] logging . info ( f" [string] { padding_left }{ prefix }{ padding_right } [string] { result . name }" ) [EOL] if not result . is_passed : [EOL] logging . info ( result . message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $ResultKind$ 0 0 0 0 0 0 0 $"Result"$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Result"$ 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.str$ 0 $ResultKind$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 $builtins.str$ 0 $ResultKind$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Result]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import subprocess [EOL] from typing import Optional [EOL] [EOL] from colorama import Back , Fore , Style [EOL] [EOL] [EOL] def header ( msg ) : [EOL] logging . info ( f"{ Back . MAGENTA }{ Style . BRIGHT } [string] { msg } [string] { Style . RESET_ALL }" ) [EOL] [EOL] [EOL] def step ( msg ) : [EOL] logging . info ( f"{ Fore . BLUE } [string] { msg }{ Style . RESET_ALL }" ) [EOL] [EOL] [EOL] def substep ( msg ) : [EOL] logging . info ( f"{ Fore . CYAN } [string] { msg }{ Style . RESET_ALL }" ) [EOL] [EOL] [EOL] def sh ( cmd , workdir = None ) : [EOL] msg = f" [string] { cmd } [string] " [EOL] if workdir is not None : [EOL] msg += f" [string] { workdir } [string] " [EOL] substep ( msg ) [EOL] return subprocess . call ( f" [string] { cmd }" , shell = True , cwd = workdir , executable = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Optional [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import os [EOL] import sys [EOL] import tempfile [EOL] from typing import Optional [EOL] [EOL] import click [EOL] import colorama [EOL] from colorama import Fore , Style [EOL] [EOL] from checks import State , checks , run_checks [EOL] from helpers import header , sh , step [EOL] from report import print_report [EOL] [EOL] DISCLAIMER = [string] . strip ( ) [EOL] USER_AGENT = [string] [EOL] [EOL] [EOL] @ click . command ( ) @ click . option ( [string] , default = [string] ) @ click . option ( [string] ) @ click . option ( [string] , required = True ) @ click . option ( [string] , required = True , help = [string] ) @ click . option ( [string] , required = True , help = [string] ) @ click . option ( [string] , default = [string] , help = [string] ) @ click . option ( [string] , is_flag = True , default = True , help = [string] [string] [string] , ) @ click . option ( [string] , default = [string] , help = [string] [string] , ) @ click . option ( [string] , default = [string] , help = [string] [string] f"{ [string] . join ( State . list_placeholder_keys ( ) ) }" , ) @ click . option ( [string] , default = [string] , help = [string] [string] , ) @ click . option ( [string] , help = [string] [string] [string] , ) @ click . option ( [string] , [string] , is_flag = True ) def main ( project , module , version , git_hash , gpg_key , repo , incubating , zipname_template , sourcedir_template , github_reponame_template , build_and_test_command , verbose , ) : [EOL] configure_logging ( verbose ) [EOL] logging . debug ( f" [string] { project } [string] { module } [string] { version } [string] " f" [string] { incubating } [string] { verbose } [string] " f" [string] { zipname_template } [string] { sourcedir_template } [string] " f" [string] { github_reponame_template } [string] " f" [string] { build_and_test_command } [string] " f" [string] { gpg_key } [string] { git_hash }" ) [EOL] [EOL] header_msg = f" [string] { project }" [EOL] if module : [EOL] header_msg += f" [string] { module }" [EOL] header_msg += f" [string] { version }" [EOL] header ( header_msg ) [EOL] logging . info ( f"{ Fore . YELLOW }{ DISCLAIMER }{ Style . RESET_ALL }" ) [EOL] [EOL] workdir = make_and_enter_workdir ( ) [EOL] logging . info ( f" [string] { workdir }" ) [EOL] [EOL] base_url = generate_base_url ( repo , project , incubating ) [EOL] logging . debug ( f" [string] { base_url }" ) [EOL] [EOL] fetch_project ( base_url , module , version , incubating ) [EOL] fetch_keys ( base_url ) [EOL] [EOL] state = State ( project = project , module = module , version = version , work_dir = workdir , incubating = incubating , zipname_template = zipname_template , sourcedir_template = sourcedir_template , github_reponame_template = github_reponame_template , gpg_key = gpg_key , git_hash = git_hash , build_and_test_command = build_and_test_command , ) [EOL] [EOL] [comment] [EOL] report = run_checks ( state , checks = checks ) [EOL] print_report ( report ) [EOL] if report . problem_count == [number] : [EOL] logging . info ( f"{ Fore . GREEN } [string] { Style . RESET_ALL }" ) [EOL] else : [EOL] logging . info ( f"{ Fore . RED } [string] { report . problem_count } [string] " f" [string] { Style . RESET_ALL }" ) [EOL] sys . exit ( [number] ) [EOL] [EOL] [EOL] def configure_logging ( verbose ) : [EOL] if verbose : [EOL] level = logging . DEBUG [EOL] else : [EOL] level = logging . INFO [EOL] logging . basicConfig ( level = level , format = [string] ) [EOL] [EOL] [EOL] def make_and_enter_workdir ( ) : [EOL] workdir = tempfile . mkdtemp ( ) [EOL] os . chdir ( workdir ) [EOL] return workdir [EOL] [EOL] [EOL] def generate_base_url ( repo , project , incubating ) : [EOL] url = f" [string] { repo } [string] " [EOL] if incubating : [EOL] url += [string] [EOL] url += project [EOL] return url [EOL] [EOL] [EOL] def fetch_project ( base_url , module , version , incubating ) : [EOL] step ( [string] ) [EOL] [EOL] version_root = f"{ base_url } [string] " [EOL] if module : [EOL] version_root += f"{ module } [string] " [EOL] version_root += version [EOL] [EOL] cut_dirs = [number] [EOL] if module : [EOL] cut_dirs += [number] [EOL] if incubating : [EOL] cut_dirs += [number] [EOL] sh ( [string] f" [string] { USER_AGENT } [string] " f" [string] { cut_dirs } [string] { version_root }" ) [EOL] [EOL] [EOL] def fetch_keys ( base_url ) : [EOL] step ( [string] ) [EOL] sh ( f" [string] { USER_AGENT } [string] { base_url } [string] " ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] colorama . init ( ) [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0