[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] from src . receiver import Receiver [EOL] [EOL] [EOL] def main ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , nargs = [string] ) [EOL] args = parser . parse_args ( ) [EOL] peers = args . ip_port_pairs [EOL] [EOL] receiver = Receiver ( [ ( peers [ i ] , int ( peers [ i + [number] ] ) ) for i in range ( [number] , len ( peers ) , [number] ) ] ) [EOL] [EOL] try : [EOL] receiver . perform_handshakes ( ) [EOL] receiver . run ( ) [EOL] except KeyboardInterrupt : [EOL] pass [EOL] finally : [EOL] receiver . cleanup ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import unittest [EOL] import time [EOL] from src . receiver import Peer [EOL] [EOL] TEST_PORT = [number] [EOL] TEST_WINDOW_SIZE = [number] [EOL] [EOL] class TestPeer ( unittest . TestCase ) : [EOL] def test_first_segment ( self ) : [EOL] peer = Peer ( TEST_PORT , TEST_WINDOW_SIZE ) [EOL] [EOL] first_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] peer . add_segment ( first_segment ) [EOL] self . assertEqual ( peer . next_ack ( ) [ [string] ] , [number] ) [EOL] [EOL] def test_out_of_order_segment ( self ) : [EOL] peer = Peer ( TEST_PORT , TEST_WINDOW_SIZE ) [EOL] [EOL] first_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] second_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] third_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] peer . add_segment ( first_segment ) [EOL] peer . add_segment ( second_segment ) [EOL] peer . add_segment ( third_segment ) [EOL] [EOL] self . assertEqual ( len ( peer . window ) , [number] ) [EOL] self . assertEqual ( peer . next_ack ( ) [ [string] ] , [number] ) [EOL] [EOL] [EOL] def test_recovery ( self ) : [EOL] peer = Peer ( TEST_PORT , TEST_WINDOW_SIZE ) [EOL] [EOL] first_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] second_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] third_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] catchup_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] peer . add_segment ( first_segment ) [EOL] peer . add_segment ( second_segment ) [EOL] peer . add_segment ( third_segment ) [EOL] self . assertEqual ( peer . next_ack ( ) [ [string] ] , [number] ) [EOL] peer . add_segment ( catchup_segment ) [EOL] self . assertEqual ( peer . next_ack ( ) [ [string] ] , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( peer . window ) , [number] ) [EOL] [EOL] def test_clears_out_window ( self ) : [EOL] peer = Peer ( TEST_PORT , [number] ) [EOL] first_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] second_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] third_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] catchup_segment = { [string] : [number] , [string] : time . time ( ) , [string] : [number] , [string] : [number] } [EOL] [EOL] peer . add_segment ( first_segment ) [EOL] peer . add_segment ( second_segment ) [EOL] peer . add_segment ( third_segment ) [EOL] peer . add_segment ( catchup_segment ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] self . assertEqual ( peer . next_ack ( ) [ [string] ] , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( peer . window ) , [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import threading [EOL] import socket [EOL] import subprocess [EOL] import matplotlib . pyplot as plt [EOL] from subprocess import Popen [EOL] import socket [EOL] from threading import Thread [EOL] from typing import Dict , List [EOL] from src . senders import Sender [EOL] [EOL] RECEIVER_FILE = [string] [EOL] AVERAGE_SEGMENT_SIZE = [number] [EOL] [EOL] def generate_mahimahi_command ( mahimahi_settings ) : [EOL] if mahimahi_settings . get ( [string] ) : [EOL] loss_directive = [string] % mahimahi_settings . get ( [string] ) [EOL] else : [EOL] loss_directive = [string] [EOL] return [string] . format ( delay = mahimahi_settings [ [string] ] , queue_size = mahimahi_settings [ [string] ] , loss_directive = loss_directive , trace_file = mahimahi_settings [ [string] ] ) [EOL] [EOL] def get_open_udp_port ( ) : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] [EOL] s . bind ( ( [string] , [number] ) ) [EOL] port = s . getsockname ( ) [ [number] ] [EOL] s . close ( ) [EOL] return port [EOL] [EOL] [EOL] def print_performance ( sender , num_seconds ) : [EOL] print ( [string] % sender . port ) [EOL] print ( [string] % sender . strategy . total_acks ) [EOL] print ( [string] % sender . strategy . num_duplicate_acks ) [EOL] [EOL] print ( [string] % ( ( float ( sender . strategy . num_duplicate_acks * [number] ) ) / sender . strategy . total_acks ) ) [EOL] print ( [string] % ( AVERAGE_SEGMENT_SIZE * ( sender . strategy . ack_count / num_seconds ) ) ) [EOL] print ( [string] % ( ( float ( sum ( sender . strategy . rtts ) ) / len ( sender . strategy . rtts ) ) * [number] ) ) [EOL] [EOL] timestamps = [ ack [ [number] ] for ack in sender . strategy . times_of_acknowledgements ] [EOL] seq_nums = [ ack [ [number] ] for ack in sender . strategy . times_of_acknowledgements ] [EOL] [EOL] plt . scatter ( timestamps , seq_nums ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] [EOL] plt . show ( ) [EOL] [EOL] plt . plot ( sender . strategy . cwnds ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . show ( ) [EOL] print ( [string] ) [EOL] [EOL] if len ( sender . strategy . slow_start_thresholds ) > [number] : [EOL] plt . plot ( sender . strategy . slow_start_thresholds ) [EOL] plt . xlabel ( [string] ) [EOL] plt . ylabel ( [string] ) [EOL] plt . show ( ) [EOL] print ( [string] ) [EOL] [EOL] def run_with_mahi_settings ( mahimahi_settings , seconds_to_run , senders ) : [EOL] mahimahi_cmd = generate_mahimahi_command ( mahimahi_settings ) [EOL] [EOL] sender_ports = [string] . join ( [ [string] % sender . port for sender in senders ] ) [EOL] [EOL] cmd = [string] % ( mahimahi_cmd , RECEIVER_FILE , sender_ports ) [EOL] receiver_process = Popen ( cmd , shell = True ) [EOL] for sender in senders : [EOL] sender . handshake ( ) [EOL] threads = [ Thread ( target = sender . run , args = [ seconds_to_run ] ) for sender in senders ] [EOL] for thread in threads : [EOL] thread . start ( ) [EOL] for thread in threads : [EOL] thread . join ( ) [EOL] [EOL] for sender in senders : [EOL] print_performance ( sender , seconds_to_run ) [EOL] receiver_process . kill ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Optional , Dict , Tuple [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import time [EOL] from typing import List , Dict , Tuple , Optional [EOL] [EOL] [EOL] class SenderStrategy ( object ) : [EOL] def __init__ ( self ) : [EOL] self . seq_num = [number] [EOL] self . next_ack = [number] [EOL] self . sent_bytes = [number] [EOL] self . start_time = time . time ( ) [EOL] self . total_acks = [number] [EOL] self . num_duplicate_acks = [number] [EOL] self . curr_duplicate_acks = [number] [EOL] self . rtts = [ ] [EOL] self . cwnds = [ ] [EOL] self . unacknowledged_packets = { } [EOL] self . times_of_acknowledgements = [ ] [EOL] self . ack_count = [number] [EOL] self . slow_start_thresholds = [ ] [EOL] self . time_of_retransmit = None [EOL] [EOL] def next_packet_to_send ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] def process_ack ( self , ack ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class FixedWindowStrategy ( SenderStrategy ) : [EOL] def __init__ ( self , cwnd ) : [EOL] self . cwnd = cwnd [EOL] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def window_is_open ( self ) : [EOL] [comment] [EOL] return self . seq_num - self . next_ack < self . cwnd [EOL] [EOL] def next_packet_to_send ( self ) : [EOL] if not self . window_is_open ( ) : [EOL] return None [EOL] [EOL] serialized_data = json . dumps ( { [string] : self . seq_num , [string] : time . time ( ) , [string] : self . sent_bytes } ) [EOL] self . unacknowledged_packets [ self . seq_num ] = True [EOL] self . seq_num += [number] [EOL] return serialized_data [EOL] [EOL] def process_ack ( self , serialized_ack ) : [EOL] ack = json . loads ( serialized_ack ) [EOL] if ack . get ( [string] ) : [EOL] return [EOL] [EOL] self . total_acks += [number] [EOL] self . times_of_acknowledgements . append ( ( ( time . time ( ) - self . start_time ) , ack [ [string] ] ) ) [EOL] if self . unacknowledged_packets . get ( ack [ [string] ] ) is None : [EOL] [comment] [EOL] self . num_duplicate_acks += [number] [EOL] self . curr_duplicate_acks += [number] [EOL] [EOL] if self . curr_duplicate_acks == [number] : [EOL] [comment] [EOL] self . curr_duplicate_acks = [number] [EOL] self . seq_num = ack [ [string] ] + [number] [EOL] else : [EOL] del self . unacknowledged_packets [ ack [ [string] ] ] [EOL] self . next_ack = max ( self . next_ack , ack [ [string] ] + [number] ) [EOL] self . sent_bytes += ack [ [string] ] [EOL] rtt = float ( time . time ( ) - ack [ [string] ] ) [EOL] self . rtts . append ( rtt ) [EOL] self . ack_count += [number] [EOL] self . cwnds . append ( self . cwnd ) [EOL] [EOL] [EOL] class TahoeStrategy ( SenderStrategy ) : [EOL] def __init__ ( self , slow_start_thresh , initial_cwnd ) : [EOL] self . slow_start_thresh = slow_start_thresh [EOL] [EOL] self . cwnd = initial_cwnd [EOL] self . fast_retransmit_packet = None [EOL] self . time_since_retransmit = None [EOL] self . retransmitting_packet = False [EOL] self . ack_count = [number] [EOL] [EOL] self . duplicated_ack = None [EOL] self . slow_start_thresholds = [ ] [EOL] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def window_is_open ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return self . seq_num - self . next_ack < self . cwnd [EOL] [EOL] def next_packet_to_send ( self ) : [EOL] send_data = None [EOL] if self . retransmitting_packet and self . time_of_retransmit and time . time ( ) - self . time_of_retransmit > [number] : [EOL] [comment] [EOL] self . retransmitting_packet = False [EOL] [EOL] if self . fast_retransmit_packet and not self . retransmitting_packet : [EOL] [comment] [EOL] self . unacknowledged_packets [ self . fast_retransmit_packet [ [string] ] ] [ [string] ] = time . time ( ) [EOL] send_data = self . fast_retransmit_packet [EOL] serialized_data = json . dumps ( send_data ) [EOL] self . retransmitting_packet = True [EOL] [EOL] self . time_of_retransmit = time . time ( ) [EOL] [EOL] elif self . window_is_open ( ) : [EOL] send_data = { [string] : self . seq_num , [string] : time . time ( ) } [EOL] [EOL] self . unacknowledged_packets [ self . seq_num ] = send_data [EOL] self . seq_num += [number] [EOL] else : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] for seq_num , segment in self . unacknowledged_packets . items ( ) : [EOL] if time . time ( ) - segment [ [string] ] > [number] : [EOL] self . unacknowledged_packets [ seq_num ] [ [string] ] = time . time ( ) [EOL] return json . dumps ( segment ) [EOL] [EOL] if send_data is None : [EOL] return None [EOL] else : [EOL] return json . dumps ( send_data ) [EOL] [EOL] [EOL] def process_ack ( self , serialized_ack ) : [EOL] ack = json . loads ( serialized_ack ) [EOL] if ack . get ( [string] ) : [EOL] return [EOL] [EOL] self . total_acks += [number] [EOL] self . times_of_acknowledgements . append ( ( ( time . time ( ) - self . start_time ) , ack [ [string] ] ) ) [EOL] [EOL] [EOL] if self . unacknowledged_packets . get ( ack [ [string] ] ) is None : [EOL] [comment] [EOL] [EOL] self . num_duplicate_acks += [number] [EOL] if self . duplicated_ack and ack [ [string] ] == self . duplicated_ack [ [string] ] : [EOL] self . curr_duplicate_acks += [number] [EOL] else : [EOL] self . duplicated_ack = ack [EOL] self . curr_duplicate_acks = [number] [EOL] [EOL] if self . curr_duplicate_acks == [number] : [EOL] [comment] [EOL] self . fast_retransmit_packet = self . unacknowledged_packets [ ack [ [string] ] + [number] ] [EOL] self . slow_start_thresh = int ( max ( [number] , self . cwnd / [number] ) ) [EOL] self . cwnd = [number] [EOL] elif ack [ [string] ] >= self . next_ack : [EOL] if self . fast_retransmit_packet : [EOL] self . fast_retransmit_packet = None [EOL] self . retransmitting_packet = False [EOL] self . curr_duplicate_acks = [number] [EOL] self . seq_num = ack [ [string] ] + [number] [EOL] [EOL] [comment] [EOL] self . unacknowledged_packets = { k : v for k , v in self . unacknowledged_packets . items ( ) if k > ack [ [string] ] } [EOL] self . next_ack = max ( self . next_ack , ack [ [string] ] + [number] ) [EOL] self . ack_count += [number] [EOL] self . sent_bytes += ack [ [string] ] [EOL] rtt = float ( time . time ( ) - ack [ [string] ] ) [EOL] self . rtts . append ( rtt ) [EOL] if self . cwnd < self . slow_start_thresh : [EOL] [comment] [EOL] self . cwnd += [number] [EOL] elif ( ack [ [string] ] + [number] ) % self . cwnd == [number] : [EOL] [comment] [EOL] self . cwnd += [number] [EOL] [EOL] self . cwnds . append ( self . cwnd ) [EOL] self . slow_start_thresholds . append ( self . slow_start_thresh ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Dict$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.float,builtins.int]]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] import src [EOL] import socket [EOL] import select [EOL] import sys [EOL] import json [EOL] import socket [EOL] import select [EOL] import time [EOL] from typing import List , Dict , Optional [EOL] from src . strategies import SenderStrategy [EOL] [EOL] READ_FLAGS = select . POLLIN | select . POLLPRI [EOL] WRITE_FLAGS = select . POLLOUT [EOL] ERR_FLAGS = select . POLLERR | select . POLLHUP | select . POLLNVAL [EOL] READ_ERR_FLAGS = READ_FLAGS | ERR_FLAGS [EOL] ALL_FLAGS = READ_FLAGS | WRITE_FLAGS | ERR_FLAGS [EOL] [EOL] [EOL] class Sender ( object ) : [EOL] def __init__ ( self , port , strategy ) : [EOL] self . port = port [EOL] self . sock = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] self . sock . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEADDR , [number] ) [EOL] self . sock . bind ( ( [string] , port ) ) [EOL] self . poller = select . poll ( ) [EOL] self . poller . register ( self . sock , ALL_FLAGS ) [EOL] self . poller . modify ( self . sock , ALL_FLAGS ) [EOL] self . peer_addr = None [EOL] [EOL] self . strategy = strategy [EOL] [EOL] def send ( self ) : [EOL] next_segment = self . strategy . next_packet_to_send ( ) [EOL] if next_segment is not None : [EOL] self . sock . sendto ( next_segment . encode ( ) , self . peer_addr ) [comment] [EOL] time . sleep ( [number] ) [EOL] [EOL] def recv ( self ) : [EOL] serialized_ack , addr = self . sock . recvfrom ( [number] ) [EOL] self . strategy . process_ack ( serialized_ack . decode ( ) ) [EOL] [EOL] [EOL] def handshake ( self ) : [EOL] [docstring] [EOL] [EOL] while True : [EOL] msg , addr = self . sock . recvfrom ( [number] ) [EOL] parsed_handshake = json . loads ( msg . decode ( ) ) [EOL] if parsed_handshake . get ( [string] ) and self . peer_addr is None : [EOL] self . peer_addr = addr [EOL] self . sock . sendto ( json . dumps ( { [string] : True } ) . encode ( ) , self . peer_addr ) [EOL] print ( [string] % addr ) [EOL] break [EOL] self . sock . setblocking ( [number] ) [EOL] [EOL] def run ( self , seconds_to_run ) : [EOL] curr_flags = ALL_FLAGS [EOL] TIMEOUT = [number] [comment] [EOL] start_time = time . time ( ) [EOL] [EOL] while time . time ( ) - start_time < seconds_to_run : [EOL] [EOL] events = self . poller . poll ( TIMEOUT ) [EOL] if not events : [EOL] self . send ( ) [EOL] for fd , flag in events : [EOL] assert self . sock . fileno ( ) == fd [EOL] [EOL] if flag & ERR_FLAGS : [EOL] sys . exit ( [string] ) [EOL] [EOL] if flag & READ_FLAGS : [EOL] self . recv ( ) [EOL] [EOL] if flag & WRITE_FLAGS : [EOL] self . send ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $src.strategies.SenderStrategy$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $socket.socket$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $select.poll$ 0 0 0 0 0 0 0 0 0 $select.poll$ 0 0 0 0 0 $socket.socket$ 0 $builtins.int$ 0 0 0 0 $select.poll$ 0 0 0 0 0 $socket.socket$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $src.strategies.SenderStrategy$ 0 $src.strategies.SenderStrategy$ 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0