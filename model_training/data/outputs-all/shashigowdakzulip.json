ZULIP_VERSION = [string] [EOL] LATEST_MAJOR_VERSION = [string] [EOL] LATEST_RELEASE_VERSION = [string] [EOL] LATEST_RELEASE_ANNOUNCEMENT = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] PROVISION_VERSION = [string] [EOL]	$builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
	0
	0
	0
	0
	0
	0
[comment] [EOL] from typing import List [EOL] import typing [EOL] EXCLUDED_FILES = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] PUPPET_CHECK_RULES_TO_EXCLUDE = [ [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] from __future__ import print_function [EOL] from __future__ import absolute_import [EOL] [EOL] import subprocess [EOL] [EOL] from zulint . linters import run_pycodestyle [EOL] [EOL] from typing import List [EOL] [EOL] def check_pep8 ( files ) : [EOL] [comment] [EOL] ignored_rules = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] return run_pycodestyle ( files , ignored_rules ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] BOT_NAME = [string] [EOL] [EOL] SPIDER_MODULES = [ [string] ] [EOL] NEWSPIDER_MODULE = [string] [EOL] COMMANDS_MODULE = [string] [EOL] LOG_LEVEL = [string] [EOL] [EOL] [EOL] [comment] [EOL] USER_AGENT = ( [string] [string] [string] ) [EOL] [EOL] [comment] [EOL] ROBOTSTXT_OBEY = False [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] from scrapy . commands . crawl import Command [EOL] from scrapy . exceptions import UsageError [EOL] from typing import List , Any [EOL] [EOL] [EOL] class StatusCommand ( Command ) : [EOL] def run ( self , args , opts ) : [EOL] if len ( args ) < [number] : [EOL] raise UsageError ( ) [EOL] elif len ( args ) > [number] : [EOL] raise UsageError ( [string] ) [EOL] spname = args [ [number] ] [EOL] if len ( vars ( opts ) [ [string] ] ) > [number] : [EOL] skip_external = vars ( opts ) [ [string] ] [ [string] ] [EOL] else : [EOL] skip_external = None [EOL] crawler = self . crawler_process . create_crawler ( spname ) [EOL] self . crawler_process . crawl ( crawler , skip_external = skip_external ) [EOL] self . crawler_process . start ( ) [EOL] [comment] [EOL] [EOL] if crawler . spider . has_error : [EOL] [comment] [EOL] self . exitcode = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0
	0
	0
	0
[EOL] from typing import Dict , Pattern , List , Any [EOL] import typing [EOL] import builtins [EOL] from typing import List , Tuple , Set , Pattern , Match [EOL] import re [EOL] [EOL] from bs4 import BeautifulSoup [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] IGNORED_PHRASES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ( [string] ) , ( [string] [string] ) , ( [string] [string] [string] ) , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] IGNORED_PHRASES . sort ( key = lambda regex : len ( regex ) , reverse = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] COMPILED_IGNORED_PHRASES = [ re . compile ( [string] . join ( BeautifulSoup ( regex , [string] ) . text . split ( ) ) ) for regex in IGNORED_PHRASES ] [EOL] [EOL] SPLIT_BOUNDARY = [string] [comment] [EOL] SPLIT_BOUNDARY_REGEX = re . compile ( [string] . format ( SPLIT_BOUNDARY ) ) [EOL] [EOL] [comment] [EOL] DISALLOWED_REGEXES = [ re . compile ( regex ) for regex in [ [string] , [string] , ] ] [EOL] [EOL] BANNED_WORDS = { [string] : ( [string] [string] ) , } [EOL] [EOL] def get_safe_phrase ( phrase ) : [EOL] [comment] [EOL] [docstring] [EOL] phrase = SPLIT_BOUNDARY_REGEX . sub ( [string] , phrase ) [EOL] return phrase . lower ( ) [EOL] [EOL] def replace_with_safe_phrase ( matchobj ) : [EOL] [comment] [EOL] [docstring] [EOL] ignored_phrase = matchobj . group ( [number] ) [EOL] safe_string = get_safe_phrase ( ignored_phrase ) [EOL] [EOL] start_index = matchobj . start ( ) [EOL] complete_string = matchobj . string [EOL] [EOL] is_string_start = start_index == [number] [EOL] [comment] [EOL] [comment] [EOL] punctuation = complete_string [ max ( start_index - [number] , [number] ) ] [EOL] is_after_split_boundary = punctuation in SPLIT_BOUNDARY [EOL] if is_string_start or is_after_split_boundary : [EOL] return safe_string . capitalize ( ) [EOL] [EOL] return safe_string [EOL] [EOL] def get_safe_text ( text ) : [EOL] [comment] [EOL] [docstring] [EOL] soup = BeautifulSoup ( text , [string] ) [EOL] text = [string] . join ( soup . text . split ( ) ) [comment] [EOL] for phrase_regex in COMPILED_IGNORED_PHRASES : [EOL] text = phrase_regex . sub ( replace_with_safe_phrase , text ) [EOL] [EOL] return text [EOL] [EOL] def is_capitalized ( safe_text ) : [EOL] [comment] [EOL] sentences = SPLIT_BOUNDARY_REGEX . split ( safe_text ) [EOL] sentences = [ sentence . strip ( ) for sentence in sentences if sentence . strip ( ) ] [EOL] [EOL] if not sentences : [EOL] return False [EOL] [EOL] for sentence in sentences : [EOL] for regex in DISALLOWED_REGEXES : [EOL] if regex . search ( sentence ) : [EOL] return False [EOL] [EOL] return True [EOL] [EOL] def check_banned_words ( text ) : [EOL] lower_cased_text = text . lower ( ) [EOL] errors = [ ] [EOL] for word , reason in BANNED_WORDS . items ( ) : [EOL] if word in lower_cased_text : [EOL] [comment] [EOL] [comment] [EOL] if [string] in lower_cased_text : [EOL] continue [EOL] kwargs = dict ( word = word , text = text , reason = reason ) [EOL] msg = [string] . format ( ** kwargs ) [EOL] errors . append ( msg ) [EOL] [EOL] return errors [EOL] [EOL] def check_capitalization ( strings ) : [EOL] [comment] [EOL] errors = [ ] [EOL] ignored = [ ] [EOL] banned_word_errors = [ ] [EOL] for text in strings : [EOL] text = [string] . join ( text . split ( ) ) [comment] [EOL] safe_text = get_safe_text ( text ) [EOL] has_ignored_phrase = text != safe_text [EOL] capitalized = is_capitalized ( safe_text ) [EOL] if not capitalized : [EOL] errors . append ( text ) [EOL] elif capitalized and has_ignored_phrase : [EOL] ignored . append ( text ) [EOL] [EOL] banned_word_errors . extend ( check_banned_words ( text ) ) [EOL] [EOL] return sorted ( errors ) , sorted ( ignored ) , sorted ( banned_word_errors ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Pattern[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
[comment] [EOL] [EOL] import argparse [EOL] import argparse [EOL] import os [EOL] import sys [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) [EOL] sys . path . append ( BASE_DIR ) [EOL] import scripts . lib . setup_path_on_import [EOL] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] import django [EOL] django . setup ( ) [EOL] from zerver . worker . queue_processors import get_active_worker_queues [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , action = [string] , dest = [string] , default = None , help = [string] ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] for worker in sorted ( get_active_worker_queues ( args . queue_type ) ) : [EOL] print ( worker ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0
	0
try : [EOL] from django . conf import settings [EOL] from zerver . models import * [EOL] from zerver . lib . actions import * [comment] [EOL] from analytics . models import * [EOL] except Exception : [EOL] import traceback [EOL] print ( [string] ) [EOL] traceback . print_exc ( ) [EOL] else : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import sys [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) [EOL] [EOL] venv = os . path . join ( BASE_DIR , [string] ) [EOL] if sys . prefix != venv : [EOL] activate_this = os . path . join ( venv , [string] , [string] ) [EOL] [comment] [EOL] if os . path . exists ( activate_this ) : [EOL] activate_locals = dict ( __file__ = activate_this ) [EOL] exec ( open ( activate_this ) . read ( ) , { } , activate_locals ) [EOL] if not os . path . exists ( activate_locals [ [string] ] ) : [EOL] raise RuntimeError ( venv + [string] ) [EOL] [EOL] sys . path . append ( BASE_DIR ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
[EOL] import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] import hashlib [EOL] import os [EOL] import hashlib [EOL] import json [EOL] [EOL] if False : [EOL] [comment] [EOL] from typing import Optional , List , IO , Tuple , Any [EOL] [EOL] from scripts . lib . zulip_tools import subprocess_text_output , run [EOL] [EOL] ZULIP_PATH = os . path . dirname ( os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) ) [EOL] ZULIP_SRV_PATH = [string] [EOL] [EOL] if [string] in os . environ : [EOL] [comment] [EOL] ZULIP_SRV_PATH = [string] [EOL] [EOL] [EOL] NODE_MODULES_CACHE_PATH = os . path . join ( ZULIP_SRV_PATH , [string] ) [EOL] YARN_BIN = os . path . join ( ZULIP_SRV_PATH , [string] ) [EOL] YARN_PACKAGE_JSON = os . path . join ( ZULIP_SRV_PATH , [string] ) [EOL] [EOL] DEFAULT_PRODUCTION = False [EOL] [EOL] def get_yarn_args ( production ) : [EOL] [comment] [EOL] if production : [EOL] yarn_args = [ [string] ] [EOL] else : [EOL] yarn_args = [ ] [EOL] return yarn_args [EOL] [EOL] def generate_sha1sum_node_modules ( setup_dir = None , production = DEFAULT_PRODUCTION ) : [EOL] [comment] [EOL] if setup_dir is None : [EOL] setup_dir = os . path . realpath ( os . getcwd ( ) ) [EOL] PACKAGE_JSON_FILE_PATH = os . path . join ( setup_dir , [string] ) [EOL] YARN_LOCK_FILE_PATH = os . path . join ( setup_dir , [string] ) [EOL] sha1sum = hashlib . sha1 ( ) [EOL] sha1sum . update ( subprocess_text_output ( [ [string] , PACKAGE_JSON_FILE_PATH ] ) . encode ( [string] ) ) [EOL] if os . path . exists ( YARN_LOCK_FILE_PATH ) : [EOL] [comment] [EOL] sha1sum . update ( subprocess_text_output ( [ [string] , YARN_LOCK_FILE_PATH ] ) . encode ( [string] ) ) [EOL] with open ( YARN_PACKAGE_JSON , [string] ) as f : [EOL] yarn_version = json . loads ( f . read ( ) ) [ [string] ] [EOL] sha1sum . update ( yarn_version . encode ( [string] ) ) [EOL] sha1sum . update ( subprocess_text_output ( [ [string] , [string] ] ) . encode ( [string] ) ) [EOL] yarn_args = get_yarn_args ( production = production ) [EOL] sha1sum . update ( [string] . join ( sorted ( yarn_args ) ) . encode ( [string] ) ) [EOL] return sha1sum . hexdigest ( ) [EOL] [EOL] def setup_node_modules ( production = DEFAULT_PRODUCTION , stdout = None , stderr = None , copy_modules = False , prefer_offline = False ) : [EOL] [comment] [EOL] yarn_args = get_yarn_args ( production = production ) [EOL] if prefer_offline : [EOL] yarn_args . append ( [string] ) [EOL] sha1sum = generate_sha1sum_node_modules ( production = production ) [EOL] target_path = os . path . join ( NODE_MODULES_CACHE_PATH , sha1sum ) [EOL] cached_node_modules = os . path . join ( target_path , [string] ) [EOL] success_stamp = os . path . join ( target_path , [string] ) [EOL] [comment] [EOL] if not os . path . exists ( success_stamp ) : [EOL] do_yarn_install ( target_path , yarn_args , success_stamp , stdout = stdout , stderr = stderr , copy_modules = copy_modules ) [EOL] [EOL] print ( [string] % ( cached_node_modules , ) ) [EOL] cmds = [ [ [string] , [string] , [string] ] , [ [string] , [string] , cached_node_modules , [string] ] , ] [EOL] for cmd in cmds : [EOL] run ( cmd , stdout = stdout , stderr = stderr ) [EOL] [EOL] def do_yarn_install ( target_path , yarn_args , success_stamp , stdout = None , stderr = None , copy_modules = False ) : [EOL] [comment] [EOL] cmds = [ [ [string] , [string] , target_path ] , [ [string] , [string] , [string] , target_path ] , ] [EOL] cached_node_modules = os . path . join ( target_path , [string] ) [EOL] if copy_modules : [EOL] print ( [string] ) [EOL] cmds . append ( [ [string] , [string] , [string] , cached_node_modules ] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] [comment] [EOL] if os . path . exists ( [string] ) : [EOL] cmds . append ( [ [string] , [string] , [string] , cached_node_modules ] ) [EOL] cd_exec = os . path . join ( ZULIP_PATH , [string] ) [EOL] if os . environ . get ( [string] ) : [EOL] cmds . append ( [ YARN_BIN , [string] , [string] , [string] , os . environ [ [string] ] ] ) [EOL] cmds . append ( [ cd_exec , target_path , YARN_BIN , [string] , [string] ] + yarn_args ) [EOL] cmds . append ( [ [string] , success_stamp ] ) [EOL] [EOL] for cmd in cmds : [EOL] run ( cmd , stdout = stdout , stderr = stderr ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple [EOL] import typing [EOL] VERSION = ( [number] , [number] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] [EOL] __revision__ = [string] [EOL] [EOL] STATUS_ACTIVE = [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0
	0
	0
	0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . CreateModel ( name = [string] , fields = [ ] , options = { [string] : True , } , bases = ( [string] , ) , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] default_app_config = [string] [EOL]	0 0 $builtins.str$ 0 0 0
	0
	0
	0
from typing import Dict , Mapping , Any , List , Set , Tuple , Optional [EOL] import typing [EOL] import django [EOL] import builtins [EOL] import zerver [EOL] import logging [EOL] import re [EOL] from typing import Any , Dict , List , Mapping , Optional , Sequence , Tuple [EOL] [EOL] import ujson [EOL] from django . conf import settings [EOL] from django . http import HttpRequest , HttpResponse [EOL] [EOL] from zerver . decorator import authenticated_api_view , to_non_negative_int [EOL] from zerver . lib . request import REQ , has_request_variables , JsonableError [EOL] from zerver . lib . response import json_success [EOL] from zerver . lib . validator import check_dict [EOL] from zerver . lib . webhooks . git import TOPIC_WITH_BRANCH_TEMPLATE , TOPIC_WITH_PR_OR_ISSUE_INFO_TEMPLATE , get_commits_comment_action_message , get_force_push_commits_event_message , get_issue_event_message , get_pull_request_event_message , get_push_commits_event_message , get_remove_branch_event_message [EOL] from zerver . models import UserProfile , get_client [EOL] from zerver . views . messages import send_message_backend [EOL] [EOL] ZULIP_TEST_REPO_NAME = [string] [EOL] ZULIP_TEST_REPO_ID = [number] [EOL] [EOL] def flexible_boolean ( boolean ) : [EOL] [docstring] [EOL] if boolean in ( [string] , [string] , [string] ) : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def is_test_repository ( repository ) : [EOL] return repository [ [string] ] == ZULIP_TEST_REPO_NAME and repository [ [string] ] == ZULIP_TEST_REPO_ID [EOL] [EOL] class UnknownEventType ( Exception ) : [EOL] pass [EOL] [EOL] def github_pull_request_content ( payload ) : [EOL] pull_request = payload [ [string] ] [EOL] action = get_pull_request_or_issue_action ( payload ) [EOL] [EOL] if action in ( [string] , [string] ) : [EOL] return get_pull_request_event_message ( payload [ [string] ] [ [string] ] , action , pull_request [ [string] ] , pull_request [ [string] ] , pull_request [ [string] ] [ [string] ] , pull_request [ [string] ] [ [string] ] , pull_request [ [string] ] , get_pull_request_or_issue_assignee ( pull_request ) ) [EOL] return get_pull_request_event_message ( payload [ [string] ] [ [string] ] , action , pull_request [ [string] ] , pull_request [ [string] ] ) [EOL] [EOL] def github_issues_content ( payload ) : [EOL] issue = payload [ [string] ] [EOL] action = get_pull_request_or_issue_action ( payload ) [EOL] [EOL] if action in ( [string] , [string] ) : [EOL] return get_issue_event_message ( payload [ [string] ] [ [string] ] , action , issue [ [string] ] , issue [ [string] ] , issue [ [string] ] , get_pull_request_or_issue_assignee ( issue ) ) [EOL] return get_issue_event_message ( payload [ [string] ] [ [string] ] , action , issue [ [string] ] , issue [ [string] ] , ) [EOL] [EOL] def github_object_commented_content ( payload , type ) : [EOL] comment = payload [ [string] ] [EOL] issue = payload [ [string] ] [EOL] action = [string] . format ( comment [ [string] ] ) [EOL] [EOL] return get_pull_request_event_message ( comment [ [string] ] [ [string] ] , action , issue [ [string] ] , issue [ [string] ] , message = comment [ [string] ] , type = type ) [EOL] [EOL] def get_pull_request_or_issue_action ( payload ) : [EOL] return [string] if payload [ [string] ] == [string] else payload [ [string] ] [EOL] [EOL] def get_pull_request_or_issue_assignee ( object_payload ) : [EOL] assignee_dict = object_payload . get ( [string] ) [EOL] if assignee_dict : [EOL] return assignee_dict . get ( [string] ) [EOL] return None [EOL] [EOL] def get_pull_request_or_issue_subject ( repository , payload_object , type ) : [EOL] return TOPIC_WITH_PR_OR_ISSUE_INFO_TEMPLATE . format ( repo = repository [ [string] ] , type = type , id = payload_object [ [string] ] , title = payload_object [ [string] ] ) [EOL] [EOL] def github_generic_subject ( noun , topic_focus , blob ) : [EOL] [comment] [EOL] return [string] % ( topic_focus , noun , blob [ [string] ] , blob [ [string] ] ) [EOL] [EOL] def api_github_v1 ( user_profile , event , payload , branches , stream , ** kwargs ) : [EOL] [docstring] [EOL] commit_stream = stream [EOL] issue_stream = [string] [EOL] return api_github_v2 ( user_profile , event , payload , branches , stream , commit_stream , issue_stream , ** kwargs ) [EOL] [EOL] [EOL] def api_github_v2 ( user_profile , event , payload , branches , default_stream , commit_stream , issue_stream , topic_focus = None ) : [EOL] [docstring] [EOL] target_stream = commit_stream if commit_stream else default_stream [EOL] issue_stream = issue_stream if issue_stream else default_stream [EOL] repository = payload [ [string] ] [EOL] updated_topic_focus = topic_focus if topic_focus else repository [ [string] ] [EOL] [EOL] [comment] [EOL] if event == [string] : [EOL] subject = get_pull_request_or_issue_subject ( repository , payload [ [string] ] , [string] ) [EOL] content = github_pull_request_content ( payload ) [EOL] elif event == [string] : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] target_stream = issue_stream [EOL] subject = get_pull_request_or_issue_subject ( repository , payload [ [string] ] , [string] ) [EOL] content = github_issues_content ( payload ) [EOL] elif event == [string] : [EOL] [comment] [EOL] issue = payload [ [string] ] [EOL] if [string] not in issue or issue [ [string] ] [ [string] ] is None : [EOL] [comment] [EOL] target_stream = issue_stream [EOL] type = [string] [EOL] subject = get_pull_request_or_issue_subject ( repository , payload [ [string] ] , type ) [EOL] else : [EOL] [comment] [EOL] type = [string] [EOL] subject = get_pull_request_or_issue_subject ( repository , payload [ [string] ] , type ) [EOL] [EOL] content = github_object_commented_content ( payload , type ) [EOL] [EOL] elif event == [string] : [EOL] subject , content = build_message_from_gitlog ( user_profile , updated_topic_focus , payload [ [string] ] , payload [ [string] ] , payload [ [string] ] , payload [ [string] ] , payload [ [string] ] , payload [ [string] ] [ [string] ] , forced = payload [ [string] ] , created = payload [ [string] ] , deleted = payload [ [string] ] ) [EOL] elif event == [string] : [EOL] subject = updated_topic_focus [EOL] [EOL] comment = payload [ [string] ] [EOL] action = [string] . format ( comment [ [string] ] ) [EOL] content = get_commits_comment_action_message ( comment [ [string] ] [ [string] ] , action , comment [ [string] ] . split ( [string] , [number] ) [ [number] ] , comment [ [string] ] , comment [ [string] ] , ) [EOL] [EOL] else : [EOL] raise UnknownEventType ( [string] % ( event , ) ) [EOL] [EOL] return target_stream , subject , content [EOL] [EOL] @ authenticated_api_view ( is_webhook = True ) @ has_request_variables def api_github_landing ( request , user_profile , event = REQ ( ) , payload = REQ ( validator = check_dict ( [ ] ) ) , branches = REQ ( default = [string] ) , stream = REQ ( default = [string] ) , version = REQ ( converter = to_non_negative_int , default = [number] ) , commit_stream = REQ ( default = [string] ) , issue_stream = REQ ( default = [string] ) , exclude_pull_requests = REQ ( converter = flexible_boolean , default = False ) , exclude_issues = REQ ( converter = flexible_boolean , default = False ) , exclude_commits = REQ ( converter = flexible_boolean , default = False ) , emphasize_branch_in_topic = REQ ( converter = flexible_boolean , default = False ) , ) : [EOL] [EOL] repository = payload [ [string] ] [EOL] [EOL] [comment] [EOL] try : [EOL] if is_test_repository ( repository ) and settings . PRODUCTION : [EOL] with open ( [string] , [string] ) as f : [EOL] f . write ( ujson . dumps ( { [string] : event , [string] : payload , [string] : branches , [string] : stream , [string] : version , [string] : commit_stream , [string] : issue_stream , [string] : exclude_pull_requests , [string] : exclude_issues , [string] : exclude_commits , [string] : emphasize_branch_in_topic , } ) ) [EOL] f . write ( [string] ) [EOL] except Exception : [EOL] logging . exception ( [string] ) [EOL] [EOL] if not stream : [EOL] stream = [string] [EOL] [EOL] short_ref = re . sub ( [string] , [string] , payload . get ( [string] , [string] ) ) [EOL] kwargs = dict ( ) [EOL] [EOL] if emphasize_branch_in_topic and short_ref : [EOL] kwargs [ [string] ] = short_ref [EOL] [EOL] allowed_events = set ( ) [EOL] if not exclude_pull_requests : [EOL] allowed_events . add ( [string] ) [EOL] [EOL] if not exclude_issues : [EOL] allowed_events . add ( [string] ) [EOL] allowed_events . add ( [string] ) [EOL] [EOL] if not exclude_commits : [EOL] allowed_events . add ( [string] ) [EOL] allowed_events . add ( [string] ) [EOL] [EOL] if event not in allowed_events : [EOL] return json_success ( ) [EOL] [EOL] [comment] [EOL] if event == [string] and payload [ [string] ] != [string] : [EOL] return json_success ( ) [EOL] [EOL] if event == [string] : [EOL] [comment] [EOL] [comment] [EOL] if branches and short_ref not in re . split ( [string] , branches ) : [EOL] return json_success ( ) [EOL] [EOL] [comment] [EOL] if version == [number] : [EOL] target_stream , subject , content = api_github_v2 ( user_profile , event , payload , branches , stream , commit_stream , issue_stream , ** kwargs ) [EOL] else : [EOL] target_stream , subject , content = api_github_v1 ( user_profile , event , payload , branches , stream , ** kwargs ) [EOL] [EOL] request . client = get_client ( [string] ) [EOL] return send_message_backend ( request , user_profile , message_type_name = [string] , message_to = [ target_stream ] , forged = False , topic_name = subject , message_content = content ) [EOL] [EOL] def build_message_from_gitlog ( user_profile , name , ref , commits , before , after , url , pusher , forced = None , created = None , deleted = False ) : [EOL] short_ref = re . sub ( [string] , [string] , ref ) [EOL] subject = TOPIC_WITH_BRANCH_TEMPLATE . format ( repo = name , branch = short_ref ) [EOL] [EOL] if re . match ( [string] , after ) : [EOL] content = get_remove_branch_event_message ( pusher , short_ref ) [EOL] [comment] [EOL] elif ( forced and not created ) or ( forced is None and len ( commits ) == [number] ) : [EOL] content = get_force_push_commits_event_message ( pusher , url , short_ref , after [ : [number] ] ) [EOL] else : [EOL] commits = _transform_commits_list_to_common_format ( commits ) [EOL] try : [EOL] content = get_push_commits_event_message ( pusher , url , short_ref , commits , deleted = deleted ) [EOL] except TypeError : [comment] [EOL] [comment] [EOL] [comment] [EOL] raise JsonableError ( [string] ) [EOL] [EOL] return subject , content [EOL] [EOL] def _transform_commits_list_to_common_format ( commits ) : [EOL] new_commits_list = [ ] [EOL] for commit in commits : [EOL] new_commits_list . append ( { [string] : commit [ [string] ] . get ( [string] ) , [string] : commit . get ( [string] ) , [string] : commit . get ( [string] ) , [string] : commit . get ( [string] ) , } ) [EOL] return new_commits_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] import builtins [EOL] import zerver [EOL] import django [EOL] from django . http import HttpRequest , HttpResponse [EOL] [EOL] from zerver . decorator import authenticated_rest_api_view [EOL] from zerver . lib . request import REQ , has_request_variables [EOL] from zerver . lib . response import json_success [EOL] from zerver . lib . webhooks . common import check_send_webhook_message [EOL] from zerver . models import UserProfile , get_client [EOL] [EOL] def truncate ( string , length ) : [EOL] if len ( string ) > length : [EOL] string = string [ : length - [number] ] + [string] [EOL] return string [EOL] [EOL] @ authenticated_rest_api_view ( webhook_client_name = [string] ) @ has_request_variables def api_zendesk_webhook ( request , user_profile , ticket_title = REQ ( ) , ticket_id = REQ ( ) , message = REQ ( ) ) : [EOL] [docstring] [EOL] subject = truncate ( [string] % ( ticket_id , ticket_title ) , [number] ) [EOL] check_send_webhook_message ( request , user_profile , subject , message ) [EOL] return json_success ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
from typing import Dict , Any [EOL] import typing [EOL] import django [EOL] import builtins [EOL] import zerver [EOL] from typing import Any , Dict [EOL] [EOL] from django . utils . translation import ugettext as _ [EOL] from django . http import HttpRequest , HttpResponse [EOL] [EOL] from zerver . lib . webhooks . common import check_send_webhook_message [EOL] from zerver . lib . response import json_success , json_error [EOL] from zerver . decorator import REQ , has_request_variables , api_key_only_webhook_view [EOL] from zerver . models import UserProfile [EOL] [EOL] import ujson [EOL] [EOL] APPVEYOR_TOPIC_TEMPLATE = [string] [EOL] APPVEYOR_MESSAGE_TEMPLATE = ( [string] [string] [string] [string] [string] ) [EOL] [EOL] @ api_key_only_webhook_view ( [string] ) @ has_request_variables def api_appveyor_webhook ( request , user_profile , payload = REQ ( argument_type = [string] ) ) : [EOL] [EOL] body = get_body_for_http_request ( payload ) [EOL] subject = get_subject_for_http_request ( payload ) [EOL] [EOL] check_send_webhook_message ( request , user_profile , subject , body ) [EOL] return json_success ( ) [EOL] [EOL] def get_subject_for_http_request ( payload ) : [EOL] event_data = payload [ [string] ] [EOL] return APPVEYOR_TOPIC_TEMPLATE . format ( project_name = event_data [ [string] ] ) [EOL] [EOL] def get_body_for_http_request ( payload ) : [EOL] event_data = payload [ [string] ] [EOL] [EOL] data = { [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] , [string] : event_data [ [string] ] } [EOL] return APPVEYOR_MESSAGE_TEMPLATE . format ( ** data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Optional , Any , Match [EOL] import typing [EOL] import django [EOL] import builtins [EOL] import zerver [EOL] import logging [EOL] import re [EOL] from typing import Any , Dict [EOL] [EOL] from django . http import HttpRequest , HttpResponse [EOL] [EOL] from zerver . decorator import api_key_only_webhook_view [EOL] from zerver . lib . request import REQ , has_request_variables [EOL] from zerver . lib . response import json_error , json_success [EOL] from zerver . lib . webhooks . common import check_send_webhook_message , UnexpectedWebhookEventType [EOL] from zerver . models import UserProfile [EOL] [EOL] from . support_event import SUPPORT_EVENTS [EOL] [EOL] DOCUMENT_TEMPLATE = [string] [EOL] QUESTION_TEMPLATE = [string] [EOL] QUESTIONS_ANSWER_TEMPLATE = ( [string] + [string] ) [EOL] COMMENT_TEMPLATE = ( [string] [string] ) [EOL] MESSAGE_TEMPLATE = [string] [EOL] TODO_LIST_TEMPLATE = [string] [EOL] TODO_TEMPLATE = [string] [EOL] [EOL] @ api_key_only_webhook_view ( [string] ) @ has_request_variables def api_basecamp_webhook ( request , user_profile , payload = REQ ( argument_type = [string] ) ) : [EOL] event = get_event_type ( payload ) [EOL] [EOL] if event not in SUPPORT_EVENTS : [EOL] raise UnexpectedWebhookEventType ( [string] , event ) [EOL] [EOL] subject = get_project_name ( payload ) [EOL] if event . startswith ( [string] ) : [EOL] body = get_document_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_questions_answer_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_questions_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_message_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_todo_list_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_todo_body ( event , payload ) [EOL] elif event . startswith ( [string] ) : [EOL] body = get_comment_body ( event , payload ) [EOL] else : [EOL] raise UnexpectedWebhookEventType ( [string] , event ) [EOL] [EOL] check_send_webhook_message ( request , user_profile , subject , body ) [EOL] return json_success ( ) [EOL] [EOL] def get_project_name ( payload ) : [EOL] return payload [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] def get_event_type ( payload ) : [EOL] return payload [ [string] ] [EOL] [EOL] def get_event_creator ( payload ) : [EOL] return payload [ [string] ] [ [string] ] [EOL] [EOL] def get_subject_url ( payload ) : [EOL] return payload [ [string] ] [ [string] ] [EOL] [EOL] def get_subject_title ( payload ) : [EOL] return payload [ [string] ] [ [string] ] [EOL] [EOL] def get_verb ( event , prefix ) : [EOL] verb = event . replace ( prefix , [string] ) [EOL] if verb == [string] : [EOL] return [string] [EOL] [EOL] matched = re . match ( [string] , verb ) [EOL] if matched : [EOL] return [string] . format ( matched . group ( [string] ) ) [EOL] return verb [EOL] [EOL] def get_document_body ( event , payload ) : [EOL] return get_generic_body ( event , payload , [string] , DOCUMENT_TEMPLATE ) [EOL] [EOL] def get_questions_answer_body ( event , payload ) : [EOL] verb = get_verb ( event , [string] ) [EOL] question = payload [ [string] ] [ [string] ] [EOL] [EOL] return QUESTIONS_ANSWER_TEMPLATE . format ( user_name = get_event_creator ( payload ) , verb = verb , answer_url = get_subject_url ( payload ) , question_title = question [ [string] ] , question_url = question [ [string] ] ) [EOL] [EOL] def get_comment_body ( event , payload ) : [EOL] verb = get_verb ( event , [string] ) [EOL] task = payload [ [string] ] [ [string] ] [EOL] [EOL] return COMMENT_TEMPLATE . format ( user_name = get_event_creator ( payload ) , verb = verb , answer_url = get_subject_url ( payload ) , task_title = task [ [string] ] , task_url = task [ [string] ] ) [EOL] [EOL] def get_questions_body ( event , payload ) : [EOL] return get_generic_body ( event , payload , [string] , QUESTION_TEMPLATE ) [EOL] [EOL] def get_message_body ( event , payload ) : [EOL] return get_generic_body ( event , payload , [string] , MESSAGE_TEMPLATE ) [EOL] [EOL] def get_todo_list_body ( event , payload ) : [EOL] return get_generic_body ( event , payload , [string] , TODO_LIST_TEMPLATE ) [EOL] [EOL] def get_todo_body ( event , payload ) : [EOL] return get_generic_body ( event , payload , [string] , TODO_TEMPLATE ) [EOL] [EOL] def get_generic_body ( event , payload , prefix , template ) : [EOL] verb = get_verb ( event , prefix ) [EOL] [EOL] return template . format ( user_name = get_event_creator ( payload ) , verb = verb , title = get_subject_title ( payload ) , url = get_subject_url ( payload ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import zerver [EOL] import django [EOL] from typing import Any , Dict [EOL] [EOL] import ujson [EOL] from django . http import HttpRequest , HttpResponse [EOL] from django . utils . translation import ugettext as _ [EOL] [EOL] from zerver . decorator import api_key_only_webhook_view [EOL] from zerver . lib . request import REQ , has_request_variables [EOL] from zerver . lib . response import json_error , json_success [EOL] from zerver . lib . webhooks . common import check_send_webhook_message [EOL] from zerver . models import UserProfile , get_client [EOL] [EOL] @ api_key_only_webhook_view ( [string] ) @ has_request_variables def api_semaphore_webhook ( request , user_profile , payload = REQ ( argument_type = [string] ) ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] branch_name = payload [ [string] ] [EOL] project_name = payload [ [string] ] [EOL] result = payload [ [string] ] [EOL] event = payload [ [string] ] [EOL] commit_id = payload [ [string] ] [ [string] ] [EOL] commit_url = payload [ [string] ] [ [string] ] [EOL] author_email = payload [ [string] ] [ [string] ] [EOL] message = payload [ [string] ] [ [string] ] [EOL] [EOL] if event == [string] : [EOL] build_url = payload [ [string] ] [EOL] build_number = payload [ [string] ] [EOL] content = [string] % ( build_number , build_url , result ) [EOL] [EOL] elif event == [string] : [EOL] build_url = payload [ [string] ] [EOL] build_number = payload [ [string] ] [EOL] deploy_url = payload [ [string] ] [EOL] deploy_number = payload [ [string] ] [EOL] server_name = payload [ [string] ] [EOL] content = [string] % ( deploy_number , deploy_url , build_number , build_url , server_name , result ) [EOL] [EOL] else : [comment] [EOL] content = [string] % ( event , result ) [EOL] [EOL] content += [string] % ( author_email , commit_id [ : [number] ] , commit_url , message ) [EOL] subject = [string] % ( project_name , branch_name ) [EOL] [EOL] check_send_webhook_message ( request , user_profile , subject , content ) [EOL] return json_success ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
from typing import Dict , List , Any [EOL] import typing [EOL] import django [EOL] import builtins [EOL] import zerver [EOL] from typing import Any , Dict , Iterable , Optional , List [EOL] [EOL] from django . utils . translation import ugettext as _ [EOL] from django . http import HttpRequest , HttpResponse [EOL] [EOL] from zerver . lib . webhooks . common import check_send_webhook_message [EOL] from zerver . lib . response import json_success , json_error [EOL] from zerver . decorator import REQ , has_request_variables , api_key_only_webhook_view [EOL] from zerver . models import UserProfile [EOL] [EOL] import ujson [EOL] import operator [EOL] [EOL] ANSIBLETOWER_DEFAULT_MESSAGE_TEMPLATE = [string] [EOL] [EOL] [EOL] ANSIBLETOWER_JOB_MESSAGE_TEMPLATE = ( [string] [string] ) [EOL] [EOL] ANSIBLETOWER_JOB_HOST_ROW_TEMPLATE = [string] [EOL] [EOL] @ api_key_only_webhook_view ( [string] ) @ has_request_variables def api_ansibletower_webhook ( request , user_profile , payload = REQ ( argument_type = [string] ) ) : [EOL] [EOL] body = get_body ( payload ) [EOL] subject = payload [ [string] ] [EOL] [EOL] check_send_webhook_message ( request , user_profile , subject , body ) [EOL] return json_success ( ) [EOL] [EOL] def get_body ( payload ) : [EOL] if ( payload [ [string] ] == [string] ) : [EOL] hosts_list_data = payload [ [string] ] [EOL] hosts_data = [ ] [EOL] for host in payload [ [string] ] : [EOL] if ( hosts_list_data [ host ] . get ( [string] ) is True ) : [EOL] hoststatus = [string] [EOL] elif ( hosts_list_data [ host ] . get ( [string] ) is False ) : [EOL] hoststatus = [string] [EOL] hosts_data . append ( { [string] : host , [string] : hoststatus } ) [EOL] [EOL] if ( payload [ [string] ] == [string] ) : [EOL] status = [string] [EOL] else : [EOL] status = [string] [EOL] [EOL] return ANSIBLETOWER_JOB_MESSAGE_TEMPLATE . format ( name = payload [ [string] ] , friendly_name = payload [ [string] ] , id = payload [ [string] ] , url = payload [ [string] ] , status = status , hosts_final_data = get_hosts_content ( hosts_data ) ) [EOL] [EOL] else : [EOL] [EOL] if ( payload [ [string] ] == [string] ) : [EOL] status = [string] [EOL] else : [EOL] status = [string] [EOL] [EOL] data = { [string] : payload [ [string] ] , [string] : payload [ [string] ] , [string] : payload [ [string] ] , [string] : payload [ [string] ] , [string] : status } [EOL] [EOL] return ANSIBLETOWER_DEFAULT_MESSAGE_TEMPLATE . format ( ** data ) [EOL] [EOL] def get_hosts_content ( hosts_data ) : [EOL] hosts_data = sorted ( hosts_data , key = operator . itemgetter ( [string] ) ) [EOL] hosts_content = [string] [EOL] for host in hosts_data : [EOL] hosts_content += ANSIBLETOWER_JOB_HOST_ROW_TEMPLATE . format ( hostname = host . get ( [string] ) , status = host . get ( [string] ) ) [EOL] return hosts_content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
class TrelloWebhookException ( Exception ) : [EOL] pass [EOL] [EOL] class UnsupportedAction ( TrelloWebhookException ) : [EOL] pass [EOL] [EOL] class UnknownUpdateCardAction ( TrelloWebhookException ) : [EOL] pass [EOL] [EOL] class UnknownUpdateBoardAction ( TrelloWebhookException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
import zerver [EOL] import django [EOL] from django . http import HttpResponse , HttpRequest [EOL] [EOL] from zerver . decorator import has_request_variables [EOL] from zerver . lib . response import json_success [EOL] from zerver . lib . actions import get_zoom_video_call_url [EOL] from zerver . models import UserProfile [EOL] [EOL] @ has_request_variables def get_zoom_url ( request , user_profile ) : [EOL] return json_success ( { [string] : get_zoom_video_call_url ( user_profile . realm ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Optional , Any [EOL] import typing [EOL] import builtins [EOL] import zerver [EOL] import django [EOL] from django . http import HttpResponse , HttpRequest [EOL] from typing import Optional [EOL] [EOL] import ujson [EOL] [EOL] from django . utils . translation import ugettext as _ [EOL] from zerver . lib . actions import do_mute_topic , do_unmute_topic [EOL] from zerver . lib . request import has_request_variables , REQ [EOL] from zerver . lib . response import json_success , json_error [EOL] from zerver . lib . topic_mutes import topic_is_muted [EOL] from zerver . lib . streams import ( access_stream_by_id , access_stream_by_name , access_stream_for_unmute_topic_by_id , access_stream_for_unmute_topic_by_name , check_for_exactly_one_stream_arg , ) [EOL] from zerver . lib . validator import check_int [EOL] from zerver . models import get_stream , Stream , UserProfile [EOL] [EOL] def mute_topic ( user_profile , stream_id , stream_name , topic_name ) : [EOL] if stream_name is not None : [EOL] ( stream , recipient , sub ) = access_stream_by_name ( user_profile , stream_name ) [EOL] else : [EOL] assert stream_id is not None [EOL] ( stream , recipient , sub ) = access_stream_by_id ( user_profile , stream_id ) [EOL] [EOL] if topic_is_muted ( user_profile , stream . id , topic_name ) : [EOL] return json_error ( _ ( [string] ) ) [EOL] [EOL] do_mute_topic ( user_profile , stream , recipient , topic_name ) [EOL] return json_success ( ) [EOL] [EOL] def unmute_topic ( user_profile , stream_id , stream_name , topic_name ) : [EOL] error = _ ( [string] ) [EOL] [EOL] if stream_name is not None : [EOL] stream = access_stream_for_unmute_topic_by_name ( user_profile , stream_name , error ) [EOL] else : [EOL] assert stream_id is not None [EOL] stream = access_stream_for_unmute_topic_by_id ( user_profile , stream_id , error ) [EOL] [EOL] if not topic_is_muted ( user_profile , stream . id , topic_name ) : [EOL] return json_error ( error ) [EOL] [EOL] do_unmute_topic ( user_profile , stream , topic_name ) [EOL] return json_success ( ) [EOL] [EOL] @ has_request_variables def update_muted_topic ( request , user_profile , stream_id = REQ ( validator = check_int , default = None ) , stream = REQ ( default = None ) , topic = REQ ( ) , op = REQ ( ) ) : [EOL] [EOL] check_for_exactly_one_stream_arg ( stream_id = stream_id , stream = stream ) [EOL] [EOL] if op == [string] : [EOL] return mute_topic ( user_profile = user_profile , stream_id = stream_id , stream_name = stream , topic_name = topic , ) [EOL] elif op == [string] : [EOL] return unmute_topic ( user_profile = user_profile , stream_id = stream_id , stream_name = stream , topic_name = topic , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import django [EOL] import zerver [EOL] from django . conf import settings [EOL] from django . shortcuts import redirect [EOL] from django . utils . translation import ugettext as _ [EOL] from django . http import HttpResponse , HttpRequest [EOL] [EOL] from zerver . decorator import require_realm_admin [EOL] from zerver . lib . actions import do_change_icon_source [EOL] from zerver . lib . realm_icon import realm_icon_url [EOL] from zerver . lib . response import json_error , json_success [EOL] from zerver . lib . upload import upload_icon_image [EOL] from zerver . models import UserProfile [EOL] [EOL] [EOL] @ require_realm_admin def upload_icon ( request , user_profile ) : [EOL] [EOL] if len ( request . FILES ) != [number] : [EOL] return json_error ( _ ( [string] ) ) [EOL] [EOL] icon_file = list ( request . FILES . values ( ) ) [ [number] ] [EOL] if ( ( settings . MAX_ICON_FILE_SIZE * [number] * [number] ) < icon_file . size ) : [EOL] return json_error ( _ ( [string] ) % ( settings . MAX_ICON_FILE_SIZE ) ) [EOL] upload_icon_image ( icon_file , user_profile ) [EOL] do_change_icon_source ( user_profile . realm , user_profile . realm . ICON_UPLOADED ) [EOL] icon_url = realm_icon_url ( user_profile . realm ) [EOL] [EOL] json_result = dict ( icon_url = icon_url ) [EOL] return json_success ( json_result ) [EOL] [EOL] [EOL] @ require_realm_admin def delete_icon_backend ( request , user_profile ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] do_change_icon_source ( user_profile . realm , user_profile . realm . ICON_FROM_GRAVATAR ) [EOL] gravatar_url = realm_icon_url ( user_profile . realm ) [EOL] json_result = dict ( icon_url = gravatar_url ) [EOL] return json_success ( json_result ) [EOL] [EOL] [EOL] def get_icon_backend ( request , user_profile ) : [EOL] url = realm_icon_url ( user_profile . realm ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert [string] in url [EOL] url += [string] + request . META [ [string] ] [EOL] return redirect ( url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import django [EOL] import builtins [EOL] import zerver [EOL] from django . http import HttpResponse , HttpRequest [EOL] [EOL] from typing import List [EOL] from zerver . models import UserProfile [EOL] [EOL] from zerver . lib . request import has_request_variables , REQ [EOL] from zerver . lib . response import json_success [EOL] from zerver . lib . validator import check_list , check_string [EOL] [EOL] from zerver . lib . actions import do_add_alert_words , do_remove_alert_words [EOL] from zerver . lib . alert_words import user_alert_words [EOL] [EOL] def list_alert_words ( request , user_profile ) : [EOL] return json_success ( { [string] : user_alert_words ( user_profile ) } ) [EOL] [EOL] def clean_alert_words ( alert_words ) : [EOL] alert_words = [ w . strip ( ) for w in alert_words ] [EOL] return [ w for w in alert_words if w != [string] ] [EOL] [EOL] @ has_request_variables def add_alert_words ( request , user_profile , alert_words = REQ ( validator = check_list ( check_string ) ) ) : [EOL] do_add_alert_words ( user_profile , clean_alert_words ( alert_words ) ) [EOL] return json_success ( { [string] : user_alert_words ( user_profile ) } ) [EOL] [EOL] @ has_request_variables def remove_alert_words ( request , user_profile , alert_words = REQ ( validator = check_list ( check_string ) ) ) : [EOL] do_remove_alert_words ( user_profile , alert_words ) [EOL] return json_success ( { [string] : user_alert_words ( user_profile ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import zerver [EOL] import django [EOL] from django . conf import settings [EOL] from django . shortcuts import redirect [EOL] from django . utils . translation import ugettext as _ [EOL] from django . http import HttpResponse , HttpRequest [EOL] [EOL] from zerver . decorator import require_realm_admin [EOL] from zerver . lib . actions import do_change_logo_source [EOL] from zerver . lib . realm_logo import realm_logo_url [EOL] from zerver . lib . response import json_error , json_success [EOL] from zerver . lib . upload import upload_logo_image [EOL] from zerver . models import Realm , UserProfile [EOL] [EOL] [EOL] @ require_realm_admin def upload_logo ( request , user_profile ) : [EOL] if user_profile . realm . plan_type == Realm . LIMITED : [EOL] return json_error ( _ ( [string] ) ) [EOL] [EOL] if len ( request . FILES ) != [number] : [EOL] return json_error ( _ ( [string] ) ) [EOL] [EOL] logo_file = list ( request . FILES . values ( ) ) [ [number] ] [EOL] if ( ( settings . MAX_LOGO_FILE_SIZE * [number] * [number] ) < logo_file . size ) : [EOL] return json_error ( _ ( [string] ) % ( settings . MAX_LOGO_FILE_SIZE ) ) [EOL] upload_logo_image ( logo_file , user_profile ) [EOL] do_change_logo_source ( user_profile . realm , user_profile . realm . LOGO_UPLOADED ) [EOL] logo_url = realm_logo_url ( user_profile . realm ) [EOL] [EOL] json_result = dict ( logo_url = logo_url ) [EOL] return json_success ( json_result ) [EOL] [EOL] [EOL] @ require_realm_admin def delete_logo_backend ( request , user_profile ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] do_change_logo_source ( user_profile . realm , user_profile . realm . LOGO_DEFAULT ) [EOL] default_url = realm_logo_url ( user_profile . realm ) [EOL] json_result = dict ( logo_url = default_url ) [EOL] return json_success ( json_result ) [EOL] [EOL] [EOL] def get_logo_backend ( request , user_profile ) : [EOL] url = realm_logo_url ( user_profile . realm ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] assert [string] in url [EOL] url += [string] + request . META [ [string] ] [EOL] return redirect ( url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import django [EOL] import ujson [EOL] [EOL] from django . http import HttpRequest , HttpResponse [EOL] from typing import Dict [EOL] [EOL] from zerver . decorator import internal_notify_view [EOL] from zerver . lib . email_mirror import mirror_email_message [EOL] from zerver . lib . request import has_request_variables , REQ [EOL] from zerver . lib . response import json_error , json_success [EOL] from zerver . lib . validator import check_dict , check_string [EOL] [EOL] [EOL] @ internal_notify_view ( False ) @ has_request_variables def email_mirror_message ( request , data = REQ ( validator = check_dict ( [ ( [string] , check_string ) , ( [string] , check_string ) ] ) ) ) : [EOL] result = mirror_email_message ( ujson . loads ( request . POST [ [string] ] ) ) [EOL] if result [ [string] ] == [string] : [EOL] return json_error ( result [ [string] ] ) [EOL] return json_success ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import django [EOL] from django . http import HttpResponse , HttpRequest [EOL] from zerver . lib . response import json_success [EOL] [EOL] [comment] [EOL] def confirmation_key ( request ) : [EOL] return json_success ( request . session . get ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.http.HttpResponse$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import django [EOL] import django . core . validators [EOL] from django . db import migrations , models [EOL] from django . db . backends . postgresql_psycopg2 . schema import DatabaseSchemaEditor [EOL] from django . db . migrations . state import StateApps [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] def emoji_to_lowercase ( apps , schema_editor ) : [EOL] RealmEmoji = apps . get_model ( [string] , [string] ) [EOL] emoji = RealmEmoji . objects . all ( ) [EOL] for e in emoji : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] e . name = e . name . lower ( ) [EOL] e . save ( ) [EOL] [EOL] operations = [ migrations . RunPython ( emoji_to_lowercase ) , migrations . AlterField ( model_name = [string] , name = [string] , field = models . TextField ( validators = [ django . core . validators . MinLengthValidator ( [number] ) , django . core . validators . RegexValidator ( message = [string] , regex = [string] ) ] ) , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $django.db.migrations.state.StateApps$ 0 $django.db.backends.postgresql_psycopg2.schema.DatabaseSchemaEditor$ 0 0 0 $typing.Any$ 0 $django.db.migrations.state.StateApps$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameModel ( old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameField ( model_name = [string] , old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameField ( model_name = [string] , old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import django [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] from django . db . backends . postgresql_psycopg2 . schema import DatabaseSchemaEditor [EOL] from django . db . migrations . state import StateApps [EOL] [EOL] def migrate_fix_invalid_bot_owner_values ( apps , schema_editor ) : [EOL] [docstring] [EOL] UserProfile = apps . get_model ( [string] , [string] ) [EOL] UserProfile . objects . filter ( is_bot = False ) . exclude ( bot_owner = None ) . update ( bot_owner = None ) [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RunPython ( migrate_fix_invalid_bot_owner_values , reverse_code = migrations . RunPython . noop ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameModel ( old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameModel ( old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import zerver [EOL] import django [EOL] import hashlib [EOL] from typing import Text [EOL] [EOL] from django . conf import settings [EOL] from django . db import migrations [EOL] from django . db . backends . postgresql_psycopg2 . schema import DatabaseSchemaEditor [EOL] from django . db . migrations . state import StateApps [EOL] from mock import patch [EOL] [EOL] from zerver . lib . upload import upload_backend [EOL] from zerver . lib . utils import make_safe_digest [EOL] from zerver . models import UserProfile [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def patched_user_avatar_path ( user_profile ) : [EOL] email = user_profile . email [EOL] user_key = email . lower ( ) + settings . AVATAR_SALT [EOL] return make_safe_digest ( user_key , hashlib . sha1 ) [EOL] [EOL] @ patch ( [string] , patched_user_avatar_path ) def verify_medium_avatar_image ( apps , schema_editor ) : [EOL] user_profile_model = apps . get_model ( [string] , [string] ) [EOL] for user_profile in user_profile_model . objects . filter ( avatar_source = [string] ) : [EOL] upload_backend . ensure_medium_avatar_image ( user_profile ) [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RunPython ( verify_medium_avatar_image ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RunSQL ( [string] , reverse_sql = [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import django [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations , models [EOL] import django . db . models . deletion [EOL] from django . db . backends . postgresql_psycopg2 . schema import DatabaseSchemaEditor [EOL] from django . db . migrations . state import StateApps [EOL] [EOL] def set_realm_for_existing_scheduledemails ( apps , schema_editor ) : [EOL] scheduledemail_model = apps . get_model ( [string] , [string] ) [EOL] preregistrationuser_model = apps . get_model ( [string] , [string] ) [EOL] for scheduledemail in scheduledemail_model . objects . all ( ) : [EOL] if scheduledemail . type == [number] : [comment] [EOL] [comment] [EOL] prereg = preregistrationuser_model . objects . filter ( email = scheduledemail . address ) . first ( ) [EOL] if prereg is not None : [EOL] scheduledemail . realm = prereg . realm [EOL] else : [EOL] scheduledemail . realm = scheduledemail . user . realm [EOL] scheduledemail . save ( update_fields = [ [string] ] ) [EOL] [EOL] [comment] [EOL] scheduledemail_model . objects . filter ( realm = None ) . delete ( ) [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . AddField ( model_name = [string] , name = [string] , field = models . ForeignKey ( null = True , on_delete = django . db . models . deletion . CASCADE , to = [string] ) , ) , migrations . RunPython ( set_realm_for_existing_scheduledemails , reverse_code = migrations . RunPython . noop ) , migrations . AlterField ( model_name = [string] , name = [string] , field = models . ForeignKey ( on_delete = django . db . models . deletion . CASCADE , to = [string] ) , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] import bitfield . models [EOL] from django . db import migrations [EOL] from zerver . lib . migrate import create_index_if_not_exist [comment] [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . AlterField ( model_name = [string] , name = [string] , field = bitfield . models . BitField ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , default = [number] ) , ) , migrations . AlterField ( model_name = [string] , name = [string] , field = bitfield . models . BitField ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , default = [number] ) , ) , migrations . RunSQL ( create_index_if_not_exist ( index_name = [string] , table_name = [string] , column_string = [string] , where_clause = [string] , ) , reverse_sql = [string] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations , models [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RenameField ( model_name = [string] , old_name = [string] , new_name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from zerver . lib . actions import do_reactivate_realm [EOL] from zerver . lib . management import ZulipBaseCommand [EOL] [EOL] class Command ( ZulipBaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] self . add_realm_args ( parser , True ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] realm = self . get_realm ( options ) [EOL] assert realm is not None [comment] [EOL] if not realm . deactivated : [EOL] print ( [string] , options [ [string] ] , [string] ) [EOL] exit ( [number] ) [EOL] print ( [string] , options [ [string] ] ) [EOL] do_reactivate_realm ( realm ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import django [EOL] import argparse [EOL] import os [EOL] import subprocess [EOL] import tempfile [EOL] import shutil [EOL] from typing import Any [EOL] [EOL] [docstring] [EOL] [EOL] from django . core . management . base import BaseCommand , CommandParser , CommandError [EOL] [EOL] from zerver . data_import . hipchat import do_convert_data [EOL] [EOL] class Command ( BaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] parser . add_argument ( [string] , nargs = [string] , metavar = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , help = [string] ) [EOL] [EOL] parser . formatter_class = argparse . RawTextHelpFormatter [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] output_dir = options [ [string] ] [EOL] [EOL] if output_dir is None : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] if os . path . exists ( output_dir ) and not os . path . isdir ( output_dir ) : [EOL] print ( output_dir + [string] ) [EOL] exit ( [number] ) [EOL] [EOL] os . makedirs ( output_dir , exist_ok = True ) [EOL] [EOL] if os . listdir ( output_dir ) : [EOL] print ( [string] ) [EOL] exit ( [number] ) [EOL] [EOL] output_dir = os . path . realpath ( output_dir ) [EOL] [EOL] for path in options [ [string] ] : [EOL] if not os . path . exists ( path ) : [EOL] print ( [string] % ( path , ) ) [EOL] exit ( [number] ) [EOL] [EOL] print ( [string] ) [EOL] do_convert_data ( input_tar_file = path , output_dir = output_dir , masking_content = options . get ( [string] , False ) , slim_mode = options [ [string] ] , api_token = options . get ( [string] ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $django.core.management.base.CommandParser$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] import tempfile [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from django . conf import settings [EOL] from django . core . management . base import CommandError [EOL] [EOL] from zerver . lib . export import do_export_realm , do_write_stats_file_for_realm_export [EOL] from zerver . lib . management import ZulipBaseCommand [EOL] from zerver . lib . utils import generate_random_token [EOL] [EOL] class Command ( ZulipBaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = [number] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , help = [string] ) [EOL] self . add_realm_args ( parser , True ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] realm = self . get_realm ( options ) [EOL] assert realm is not None [comment] [EOL] [EOL] output_dir = options [ [string] ] [EOL] if output_dir is None : [EOL] output_dir = tempfile . mkdtemp ( prefix = [string] ) [EOL] else : [EOL] output_dir = os . path . realpath ( os . path . expanduser ( output_dir ) ) [EOL] if os . path . exists ( output_dir ) : [EOL] shutil . rmtree ( output_dir ) [EOL] os . makedirs ( output_dir ) [EOL] print ( [string] % ( realm . string_id , ) ) [EOL] num_threads = int ( options [ [string] ] ) [EOL] if num_threads < [number] : [EOL] raise CommandError ( [string] ) [EOL] [EOL] do_export_realm ( realm , output_dir , threads = num_threads , public_only = options [ [string] ] ) [EOL] print ( [string] % ( output_dir , ) ) [EOL] [EOL] do_write_stats_file_for_realm_export ( output_dir ) [EOL] [EOL] tarball_path = output_dir . rstrip ( [string] ) + [string] [EOL] os . chdir ( os . path . dirname ( output_dir ) ) [EOL] subprocess . check_call ( [ [string] , [string] , tarball_path , os . path . basename ( output_dir ) ] ) [EOL] print ( [string] % ( tarball_path , ) ) [EOL] [EOL] if not options [ [string] ] : [EOL] return [EOL] [EOL] def percent_callback ( complete , total ) : [EOL] sys . stdout . write ( [string] ) [EOL] sys . stdout . flush ( ) [EOL] [EOL] if settings . LOCAL_UPLOADS_DIR is not None : [EOL] raise CommandError ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] [EOL] from zerver . lib . upload import S3Connection , get_bucket , Key [EOL] conn = S3Connection ( settings . S3_KEY , settings . S3_SECRET_KEY ) [EOL] [comment] [EOL] bucket = get_bucket ( conn , settings . S3_AVATAR_BUCKET ) [EOL] key = Key ( bucket ) [EOL] key . key = os . path . join ( [string] , generate_random_token ( [number] ) , os . path . basename ( tarball_path ) ) [EOL] key . set_contents_from_filename ( tarball_path , cb = percent_callback , num_cb = [number] ) [EOL] [EOL] public_url = [string] . format ( host = conn . server_name ( ) , bucket = bucket . name , key = key . key ) [EOL] print ( [string] % ( public_url , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import argparse [EOL] import zerver [EOL] import logging [EOL] [EOL] from argparse import ArgumentParser [EOL] from typing import Any , List [EOL] [EOL] [EOL] from django . conf import settings [EOL] from django . db . utils import IntegrityError [EOL] [EOL] from zerver . lib . logging_util import log_to_file [EOL] from zerver . lib . management import ZulipBaseCommand [EOL] from zerver . models import UserProfile [EOL] from zproject . backends import ZulipLDAPException , sync_user_from_ldap [EOL] [EOL] [comment] [EOL] logger = logging . getLogger ( [string] ) [EOL] log_to_file ( logger , settings . LDAP_SYNC_LOG_PATH ) [EOL] [EOL] [comment] [EOL] def sync_ldap_user_data ( user_profiles ) : [EOL] logger . info ( [string] ) [EOL] for u in user_profiles : [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] if sync_user_from_ldap ( u ) : [EOL] logger . info ( [string] % ( u . email , ) ) [EOL] else : [EOL] logger . warning ( [string] % ( u . email , ) ) [EOL] if settings . LDAP_DEACTIVATE_NON_MATCHING_USERS : [EOL] logger . info ( [string] % ( u . email , ) ) [EOL] except ZulipLDAPException as e : [EOL] logger . error ( [string] % ( u . email , ) ) [EOL] logger . error ( e ) [EOL] logger . info ( [string] ) [EOL] [EOL] class Command ( ZulipBaseCommand ) : [EOL] def add_arguments ( self , parser ) : [EOL] self . add_realm_args ( parser ) [EOL] self . add_user_list_args ( parser ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] if options . get ( [string] ) is not None : [EOL] realm = self . get_realm ( options ) [EOL] user_profiles = self . get_users ( options , realm , is_bot = False ) [EOL] else : [EOL] user_profiles = UserProfile . objects . select_related ( ) . filter ( is_bot = False ) [EOL] sync_ldap_user_data ( user_profiles ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] [EOL] from django . conf import settings [EOL] from django . core . mail import mail_admins , mail_managers , send_mail [EOL] from django . core . management import CommandError [EOL] from django . core . management . commands import sendtestemail [EOL] [EOL] from zerver . lib . send_email import FromAddress [EOL] [EOL] class Command ( sendtestemail . Command ) : [EOL] def handle ( self , * args , ** kwargs ) : [EOL] if settings . WARN_NO_EMAIL : [EOL] raise CommandError ( [string] [string] ) [EOL] message = ( [string] [string] [string] [string] [string] ) [EOL] send_mail ( [string] , message , FromAddress . SUPPORT , kwargs [ [string] ] ) [EOL] send_mail ( [string] , message , FromAddress . tokenized_no_reply_address ( ) , kwargs [ [string] ] ) [EOL] [EOL] if kwargs [ [string] ] : [EOL] mail_managers ( [string] , [string] ) [EOL] [EOL] if kwargs [ [string] ] : [EOL] mail_admins ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import argparse [EOL] import typing [EOL] import builtins [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from zerver . lib . actions import do_change_user_delivery_email [EOL] from zerver . lib . management import ZulipBaseCommand [EOL] [EOL] class Command ( ZulipBaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] self . add_realm_args ( parser ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , help = [string] ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] old_email = options [ [string] ] [EOL] new_email = options [ [string] ] [EOL] [EOL] realm = self . get_realm ( options ) [EOL] user_profile = self . get_user ( old_email , realm ) [EOL] [EOL] do_change_user_delivery_email ( user_profile , new_email ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0
[EOL] from typing import Set , Any [EOL] import typing [EOL] import argparse [EOL] import glob [EOL] import logging [EOL] import os [EOL] import shutil [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from django . core . management . base import BaseCommand [EOL] [EOL] from zerver . lib . export import export_usermessages_batch [EOL] [EOL] class Command ( BaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = None , help = [string] ) [EOL] parser . add_argument ( [string] , dest = [string] , action = [string] , default = None , help = [string] ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] logging . info ( [string] % ( options [ [string] ] , ) ) [EOL] files = set ( glob . glob ( os . path . join ( options [ [string] ] , [string] ) ) ) [EOL] for partial_path in files : [EOL] locked_path = partial_path . replace ( [string] , [string] ) [EOL] output_path = partial_path . replace ( [string] , [string] ) [EOL] try : [EOL] shutil . move ( partial_path , locked_path ) [EOL] except Exception : [EOL] [comment] [EOL] continue [EOL] logging . info ( [string] % ( options [ [string] ] , output_path ) ) [EOL] try : [EOL] export_usermessages_batch ( locked_path , output_path ) [EOL] except Exception : [EOL] [comment] [EOL] shutil . move ( locked_path , partial_path ) [EOL] raise [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
	0
	0
	0
from typing import Dict , Optional , Match [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Dict [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def parse_user_agent ( user_agent ) : [EOL] match = re . match ( [string] , user_agent , re . X ) [EOL] assert match is not None [EOL] return match . groupdict ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , MutableMapping , Any , List , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import MutableMapping , Any , Optional , List , Tuple [EOL] from django . conf import settings [EOL] [EOL] import re [EOL] import json [EOL] [EOL] from zerver . models import SubMessage [EOL] [EOL] [EOL] def get_widget_data ( content ) : [EOL] valid_widget_types = [ [string] , [string] , [string] ] [EOL] tokens = content . split ( [string] ) [EOL] [EOL] [comment] [EOL] if tokens [ [number] ] . startswith ( [string] ) : [EOL] widget_type = tokens [ [number] ] [ [number] : ] [EOL] if widget_type in valid_widget_types : [EOL] extra_data = get_extra_data_from_widget_type ( tokens , widget_type ) [EOL] return widget_type , extra_data [EOL] [EOL] return None , None [EOL] [EOL] def get_extra_data_from_widget_type ( tokens , widget_type ) : [EOL] if widget_type == [string] : [EOL] [comment] [EOL] [comment] [EOL] question = [string] . join ( tokens [ [number] : ] ) [EOL] if not question : [EOL] question = [string] [EOL] extra_data = { [string] : question } [EOL] return extra_data [EOL] return None [EOL] [EOL] def do_widget_post_save_actions ( message ) : [EOL] [docstring] [EOL] if not settings . ALLOW_SUB_MESSAGES : [EOL] return [EOL] content = message [ [string] ] . content [EOL] sender_id = message [ [string] ] . sender_id [EOL] message_id = message [ [string] ] . id [EOL] [EOL] widget_type = None [EOL] extra_data = None [EOL] [EOL] widget_type , extra_data = get_widget_data ( content ) [EOL] widget_content = message . get ( [string] ) [EOL] if widget_content is not None : [EOL] [comment] [EOL] [comment] [EOL] widget_type = widget_content [ [string] ] [EOL] extra_data = widget_content [ [string] ] [EOL] [EOL] if widget_type : [EOL] content = dict ( widget_type = widget_type , extra_data = extra_data ) [EOL] submessage = SubMessage ( sender_id = sender_id , message_id = message_id , msg_type = [string] , content = json . dumps ( content ) , ) [EOL] submessage . save ( ) [EOL] message [ [string] ] = SubMessage . get_raw_db_rows ( [ message_id ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Any [EOL] import typing [EOL] import builtins [EOL] import json [EOL] from typing import Any , Dict , Iterator , Optional [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] class JSONEncoderForHTML ( json . JSONEncoder ) : [EOL] [docstring] [EOL] [EOL] def encode ( self , o ) : [EOL] [comment] [EOL] [comment] [EOL] chunks = self . iterencode ( o , True ) [EOL] return [string] . join ( chunks ) [EOL] [EOL] def iterencode ( self , o , _one_shot = False ) : [EOL] chunks = super ( ) . iterencode ( o , _one_shot ) [EOL] for chunk in chunks : [EOL] chunk = chunk . replace ( [string] , [string] ) [EOL] chunk = chunk . replace ( [string] , [string] ) [EOL] chunk = chunk . replace ( [string] , [string] ) [EOL] yield chunk [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import zerver [EOL] from django . utils . translation import ugettext as _ [EOL] from typing import Any , Dict , List [EOL] [EOL] from zerver . lib . request import JsonableError [EOL] from zerver . lib . upload import delete_message_image [EOL] from zerver . models import Attachment , UserProfile [EOL] [EOL] def user_attachments ( user_profile ) : [EOL] attachments = Attachment . objects . filter ( owner = user_profile ) . prefetch_related ( [string] ) [EOL] return [ a . to_dict ( ) for a in attachments ] [EOL] [EOL] def access_attachment_by_id ( user_profile , attachment_id , needs_owner = False ) : [EOL] query = Attachment . objects . filter ( id = attachment_id ) [EOL] if needs_owner : [EOL] query = query . filter ( owner = user_profile ) [EOL] [EOL] attachment = query . first ( ) [EOL] if attachment is None : [EOL] raise JsonableError ( _ ( [string] ) ) [EOL] return attachment [EOL] [EOL] def remove_attachment ( user_profile , attachment ) : [EOL] try : [EOL] delete_message_image ( attachment . path_id ) [EOL] except Exception : [EOL] raise JsonableError ( _ ( [string] ) ) [EOL] attachment . delete ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $zerver.models.Attachment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import builtins [EOL] import zerver [EOL] from typing import Any , Dict [EOL] from django . utils . translation import ugettext as _ [EOL] [EOL] from zerver . models import UserProfile [EOL] from zerver . lib . actions import do_set_user_display_setting [EOL] from zerver . lib . exceptions import JsonableError [EOL] [EOL] def process_zcommands ( content , user_profile ) : [EOL] if not content . startswith ( [string] ) : [EOL] raise JsonableError ( _ ( [string] ) ) [EOL] command = content [ [number] : ] [EOL] [EOL] if command == [string] : [EOL] ret = dict ( ) [comment] [EOL] return ret [EOL] [EOL] night_commands = [ [string] , [string] ] [EOL] day_commands = [ [string] , [string] ] [EOL] [EOL] if command in night_commands : [EOL] if user_profile . night_mode : [EOL] msg = [string] [EOL] else : [EOL] switch_command = day_commands [ night_commands . index ( command ) ] [EOL] msg = [string] % ( switch_command , ) [EOL] do_set_user_display_setting ( user_profile , [string] , True ) [EOL] ret = dict ( msg = msg ) [EOL] return ret [EOL] [EOL] if command in day_commands : [EOL] if user_profile . night_mode : [EOL] switch_command = night_commands [ day_commands . index ( command ) ] [EOL] msg = [string] % ( switch_command , ) [EOL] do_set_user_display_setting ( user_profile , [string] , False ) [EOL] else : [EOL] msg = [string] [EOL] ret = dict ( msg = msg ) [EOL] return ret [EOL] [EOL] raise JsonableError ( _ ( [string] ) % ( command , ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import builtins [EOL] import pytz [EOL] from typing import List [EOL] [EOL] import pytz [EOL] [EOL] def get_all_timezones ( ) : [EOL] return sorted ( pytz . all_timezones ) [EOL] [EOL] def get_timezone ( tz ) : [EOL] return pytz . timezone ( tz ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import TypeVar , List , Any [EOL] import typing [EOL] import builtins [EOL] from django . db . models . query import QuerySet [EOL] from psycopg2 . extensions import cursor [EOL] from typing import Any , Callable , Dict , List , Tuple , TypeVar [EOL] [EOL] import re [EOL] import time [EOL] [EOL] CursorObj = TypeVar ( [string] , bound = cursor ) [EOL] [EOL] def create_index_if_not_exist ( index_name , table_name , column_string , where_clause ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] stmt = [string] % ( index_name , index_name , table_name , column_string , where_clause ) [EOL] return stmt [EOL] [EOL] [EOL] def do_batch_update ( cursor , table , cols , vals , batch_size = [number] , sleep = [number] , escape = True ) : [comment] [EOL] stmt = [string] % ( table , [string] . join ( cols ) , [string] . join ( [ [string] ] * len ( cols ) ) ) [EOL] [EOL] cursor . execute ( [string] % ( table , ) ) [EOL] ( min_id , max_id ) = cursor . fetchall ( ) [ [number] ] [EOL] if min_id is None : [EOL] return [EOL] [EOL] print ( [string] % ( min_id , max_id ) ) [EOL] while min_id <= max_id : [EOL] lower = min_id [EOL] upper = min_id + batch_size [EOL] print ( [string] % ( lower , upper ) ) [EOL] params = list ( vals ) + [ lower , upper ] [EOL] if escape : [EOL] cursor . execute ( stmt , params = params ) [EOL] else : [EOL] cursor . execute ( stmt % tuple ( params ) ) [EOL] [EOL] min_id = upper [EOL] time . sleep ( sleep ) [EOL] [EOL] [comment] [EOL] if min_id > max_id : [EOL] cursor . execute ( [string] % ( table , ) ) [EOL] max_id = cursor . fetchall ( ) [ [number] ] [ [number] ] [EOL] [EOL] print ( [string] , end = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Mapping , Type , IO , Sequence , Union , Any , TypeVar , List , Callable [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] import functools [EOL] [EOL] from typing import Any , Callable , IO , Mapping , Sequence , TypeVar [EOL] [EOL] def get_mapping_type_str ( x ) : [EOL] container_type = type ( x ) . __name__ [EOL] if not x : [EOL] if container_type == [string] : [EOL] return [string] [EOL] else : [EOL] return container_type + [string] [EOL] key = next ( iter ( x ) ) [EOL] key_type = get_type_str ( key ) [EOL] value_type = get_type_str ( x [ key ] ) [EOL] if container_type == [string] : [EOL] if len ( x ) == [number] : [EOL] return [string] % ( key_type , value_type ) [EOL] else : [EOL] return [string] % ( key_type , value_type ) [EOL] else : [EOL] if len ( x ) == [number] : [EOL] return [string] % ( container_type , key_type , value_type ) [EOL] else : [EOL] return [string] % ( container_type , key_type , value_type ) [EOL] [EOL] def get_sequence_type_str ( x ) : [EOL] container_type = type ( x ) . __name__ [EOL] if not x : [EOL] if container_type == [string] : [EOL] return [string] [EOL] else : [EOL] return container_type + [string] [EOL] elem_type = get_type_str ( x [ [number] ] ) [EOL] if container_type == [string] : [EOL] if len ( x ) == [number] : [EOL] return [string] + elem_type + [string] [EOL] else : [EOL] return [string] + elem_type + [string] [EOL] else : [EOL] if len ( x ) == [number] : [EOL] return [string] % ( container_type , elem_type ) [EOL] else : [EOL] return [string] % ( container_type , elem_type ) [EOL] [EOL] expansion_blacklist = [ str , bytes ] [EOL] [EOL] def get_type_str ( x ) : [EOL] if x is None : [EOL] return [string] [EOL] elif isinstance ( x , tuple ) : [EOL] types = [ ] [EOL] for v in x : [EOL] types . append ( get_type_str ( v ) ) [EOL] if len ( x ) == [number] : [EOL] return [string] + types [ [number] ] + [string] [EOL] else : [EOL] return [string] + [string] . join ( types ) + [string] [EOL] elif isinstance ( x , Mapping ) : [EOL] return get_mapping_type_str ( x ) [EOL] elif isinstance ( x , Sequence ) and not any ( isinstance ( x , t ) for t in expansion_blacklist ) : [EOL] return get_sequence_type_str ( x ) [EOL] else : [EOL] return type ( x ) . __name__ [EOL] [EOL] FuncT = TypeVar ( [string] , bound = Callable [ ... , Any ] ) [EOL] [EOL] def print_types_to ( file_obj ) : [EOL] def decorator ( func ) : [EOL] @ functools . wraps ( func ) def wrapper ( * args , ** kwargs ) : [EOL] arg_types = [ get_type_str ( arg ) for arg in args ] [EOL] kwarg_types = [ key + [string] + get_type_str ( value ) for key , value in kwargs . items ( ) ] [EOL] ret_val = func ( * args , ** kwargs ) [EOL] output = [string] % ( func . __name__ , [string] . join ( arg_types + kwarg_types ) , get_type_str ( ret_val ) ) [EOL] print ( output , file = file_obj ) [EOL] return ret_val [EOL] return wrapper [comment] [EOL] return decorator [EOL] [EOL] def print_types ( func ) : [EOL] return print_types_to ( sys . stdout ) ( func ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[FuncT],FuncT]$ 0 0 0 0 0 0 $FuncT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FuncT$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import redis [EOL] from django . conf import settings [EOL] [EOL] import redis [EOL] [EOL] def get_redis_client ( ) : [EOL] return redis . StrictRedis ( host = settings . REDIS_HOST , port = settings . REDIS_PORT , password = settings . REDIS_PASSWORD , db = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $redis.StrictRedis$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Union , Any , Literal , List , Optional [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import base64 [EOL] import struct [EOL] from typing import Union [EOL] [EOL] def force_bytes ( s , encoding = [string] ) : [EOL] [docstring] [EOL] if isinstance ( s , bytes ) : [EOL] return s [EOL] elif isinstance ( s , str ) : [EOL] return s . encode ( encoding ) [EOL] else : [EOL] raise TypeError ( [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def der_encode_length ( length ) : [EOL] if length <= [number] : [EOL] return struct . pack ( [string] , length ) [EOL] out = [string] [EOL] while length > [number] : [EOL] out = struct . pack ( [string] , length & [number] ) + out [EOL] length >>= [number] [EOL] out = struct . pack ( [string] , len ( out ) | [number] ) + out [EOL] return out [EOL] [EOL] def der_encode_tlv ( tag , value ) : [EOL] return struct . pack ( [string] , tag ) + der_encode_length ( len ( value ) ) + value [EOL] [EOL] def der_encode_integer_value ( val ) : [EOL] if not isinstance ( val , int ) : [EOL] raise TypeError ( [string] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if val == [number] : [EOL] return [string] [EOL] sign = [number] [comment] [EOL] out = [string] [EOL] [comment] [EOL] while val != sign : [EOL] byte = val & [number] [EOL] out = struct . pack ( [string] , byte ) + out [EOL] sign = - [number] if byte & [number] == [number] else [number] [EOL] val >>= [number] [EOL] return out [EOL] [EOL] def der_encode_integer ( val ) : [EOL] return der_encode_tlv ( [number] , der_encode_integer_value ( val ) ) [EOL] def der_encode_int32 ( val ) : [EOL] if val < - [number] or val > [number] : [EOL] raise ValueError ( [string] ) [EOL] return der_encode_integer ( val ) [EOL] def der_encode_uint32 ( val ) : [EOL] if val < [number] or val > [number] : [EOL] raise ValueError ( [string] ) [EOL] return der_encode_integer ( val ) [EOL] [EOL] def der_encode_string ( val ) : [EOL] if not isinstance ( val , str ) : [EOL] raise TypeError ( [string] ) [EOL] return der_encode_tlv ( [number] , val . encode ( [string] ) ) [EOL] [EOL] def der_encode_octet_string ( val ) : [EOL] if not isinstance ( val , bytes ) : [EOL] raise TypeError ( [string] ) [EOL] return der_encode_tlv ( [number] , val ) [EOL] [EOL] def der_encode_sequence ( tlvs , tagged = True ) : [EOL] body = [ ] [EOL] for i , tlv in enumerate ( tlvs ) : [EOL] [comment] [EOL] if tlv is None : [EOL] continue [EOL] if tagged : [EOL] [comment] [EOL] tlv = der_encode_tlv ( [number] | i , tlv ) [EOL] body . append ( tlv ) [EOL] return der_encode_tlv ( [number] , [string] . join ( body ) ) [EOL] [EOL] def der_encode_ticket ( tkt ) : [EOL] return der_encode_tlv ( [number] , der_encode_sequence ( [ der_encode_integer ( [number] ) , der_encode_string ( tkt [ [string] ] ) , der_encode_sequence ( [ der_encode_int32 ( tkt [ [string] ] [ [string] ] ) , der_encode_sequence ( [ der_encode_string ( c ) for c in tkt [ [string] ] [ [string] ] ] , tagged = False ) ] ) , der_encode_sequence ( [ der_encode_int32 ( tkt [ [string] ] [ [string] ] ) , ( der_encode_uint32 ( tkt [ [string] ] [ [string] ] ) [EOL] if [string] in tkt [ [string] ] [EOL] else None ) , der_encode_octet_string ( base64 . b64decode ( tkt [ [string] ] [ [string] ] ) ) ] ) ] ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def ccache_counted_octet_string ( data ) : [EOL] if not isinstance ( data , bytes ) : [EOL] raise TypeError ( [string] ) [EOL] return struct . pack ( [string] , len ( data ) ) + data [EOL] [EOL] def ccache_principal ( name , realm ) : [EOL] header = struct . pack ( [string] , name [ [string] ] , len ( name [ [string] ] ) ) [EOL] return ( header + ccache_counted_octet_string ( force_bytes ( realm ) ) + [string] . join ( ccache_counted_octet_string ( force_bytes ( c ) ) for c in name [ [string] ] ) ) [EOL] [EOL] def ccache_key ( key ) : [EOL] return ( struct . pack ( [string] , key [ [string] ] ) + ccache_counted_octet_string ( base64 . b64decode ( key [ [string] ] ) ) ) [EOL] [EOL] def flags_to_uint32 ( flags ) : [EOL] ret = [number] [EOL] for i , v in enumerate ( flags ) : [EOL] if v : [EOL] ret |= [number] << ( [number] - i ) [EOL] return ret [EOL] [EOL] def ccache_credential ( cred ) : [EOL] out = ccache_principal ( cred [ [string] ] , cred [ [string] ] ) [EOL] out += ccache_principal ( cred [ [string] ] , cred [ [string] ] ) [EOL] out += ccache_key ( cred [ [string] ] ) [EOL] out += struct . pack ( [string] , cred [ [string] ] // [number] , cred . get ( [string] , cred [ [string] ] ) // [number] , cred [ [string] ] // [number] , cred . get ( [string] , [number] ) // [number] ) [EOL] out += struct . pack ( [string] , [number] ) [EOL] out += struct . pack ( [string] , flags_to_uint32 ( cred [ [string] ] ) ) [EOL] [comment] [EOL] out += struct . pack ( [string] , [number] , [number] ) [EOL] out += ccache_counted_octet_string ( der_encode_ticket ( cred [ [string] ] ) ) [EOL] [comment] [EOL] out += ccache_counted_octet_string ( [string] ) [EOL] return out [EOL] [EOL] def make_ccache ( cred ) : [EOL] [comment] [EOL] [comment] [EOL] out = struct . pack ( [string] , [number] , [number] , [number] , [number] , [number] , [number] , ) [EOL] out += ccache_principal ( cred [ [string] ] , cred [ [string] ] ) [EOL] out += ccache_credential ( cred ) [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Pattern , Any , Optional , Match [EOL] import typing [EOL] import builtins [EOL] import requests [EOL] import re [EOL] import logging [EOL] import traceback [EOL] from typing import Any , Optional , Dict [EOL] from typing . re import Match [EOL] import requests [EOL] from zerver . lib . cache import cache_with_key , get_cache_with_key , preview_url_cache_key [EOL] from zerver . lib . url_preview . oembed import get_oembed_data [EOL] from zerver . lib . url_preview . parsers import OpenGraphParser , GenericParser [EOL] from django . utils . encoding import smart_text [EOL] [EOL] [EOL] CACHE_NAME = [string] [EOL] [comment] [EOL] link_regex = re . compile ( [string] [string] [string] [string] [string] , re . IGNORECASE ) [EOL] [EOL] [EOL] def is_link ( url ) : [EOL] return link_regex . match ( smart_text ( url ) ) [EOL] [EOL] [EOL] @ cache_with_key ( preview_url_cache_key , cache_name = CACHE_NAME , with_statsd_key = [string] ) def get_link_embed_data ( url , maxwidth = [number] , maxheight = [number] ) : [EOL] if not is_link ( url ) : [EOL] return None [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] data = get_oembed_data ( url , maxwidth = maxwidth , maxheight = maxheight ) [EOL] except requests . exceptions . RequestException : [EOL] msg = [string] [EOL] logging . error ( msg . format ( url , traceback . format_exc ( ) ) ) [EOL] return None [EOL] data = data or { } [EOL] response = requests . get ( url ) [EOL] if response . ok : [EOL] og_data = OpenGraphParser ( response . text ) . extract_data ( ) [EOL] if og_data : [EOL] data . update ( og_data ) [EOL] generic_data = GenericParser ( response . text ) . extract_data ( ) or { } [EOL] for key in [ [string] , [string] , [string] ] : [EOL] if not data . get ( key ) and generic_data . get ( key ) : [EOL] data [ key ] = generic_data [ key ] [EOL] return data [EOL] [EOL] [EOL] @ get_cache_with_key ( preview_url_cache_key , cache_name = CACHE_NAME ) def link_embed_data_from_cache ( url , maxwidth = [number] , maxheight = [number] ) : [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.re.Match[builtins.str]$ 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] from typing import Any [EOL] [EOL] class BaseParser : [EOL] def __init__ ( self , html_source ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from bs4 import BeautifulSoup [EOL] self . _soup = BeautifulSoup ( html_source , [string] ) [EOL] [EOL] def extract_data ( self ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Dict [EOL] from . base import BaseParser [EOL] [EOL] [EOL] class OpenGraphParser ( BaseParser ) : [EOL] def extract_data ( self ) : [EOL] meta = self . _soup . findAll ( [string] ) [EOL] content = { } [EOL] for tag in meta : [EOL] if tag . has_attr ( [string] ) and [string] in tag [ [string] ] : [EOL] content [ re . sub ( [string] , [string] , tag [ [string] ] ) ] = tag [ [string] ] [EOL] return content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import List [EOL] import typing [EOL] from zerver . lib . url_preview . parsers . open_graph import OpenGraphParser [EOL] from zerver . lib . url_preview . parsers . generic import GenericParser [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import Dict , Pattern , Any , List , Match [EOL] import typing [EOL] import builtins [EOL] import markdown [EOL] import re [EOL] import markdown [EOL] from typing import Any , Dict , List , Optional , Union [EOL] from typing . re import Match [EOL] from markdown . preprocessors import Preprocessor [EOL] [EOL] from zerver . lib . emoji import EMOTICON_CONVERSIONS , name_to_codepoint [EOL] [EOL] REGEXP = re . compile ( [string] ) [EOL] [EOL] TABLE_HTML = [string] [EOL] [EOL] ROW_HTML = [string] [EOL] [EOL] class EmoticonTranslationsHelpExtension ( markdown . Extension ) : [EOL] def extendMarkdown ( self , md , md_globals ) : [EOL] [docstring] [EOL] md . registerExtension ( self ) [EOL] md . preprocessors . add ( [string] , EmoticonTranslation ( ) , [string] ) [EOL] [EOL] [EOL] class EmoticonTranslation ( Preprocessor ) : [EOL] def run ( self , lines ) : [EOL] for loc , line in enumerate ( lines ) : [EOL] match = REGEXP . search ( line ) [EOL] if match : [EOL] text = self . handleMatch ( match ) [EOL] lines = lines [ : loc ] + text + lines [ loc + [number] : ] [EOL] break [EOL] return lines [EOL] [EOL] def handleMatch ( self , match ) : [EOL] rows = [ ROW_HTML . format ( emoticon = emoticon , name = name . strip ( [string] ) , codepoint = name_to_codepoint [ name . strip ( [string] ) ] ) for emoticon , name in EMOTICON_CONVERSIONS . items ( ) ] [EOL] body = [string] . join ( rows ) . strip ( ) [EOL] return TABLE_HTML . format ( body = body ) . strip ( ) . splitlines ( ) [EOL] [EOL] def makeExtension ( * args , ** kwargs ) : [EOL] return EmoticonTranslationsHelpExtension ( * args , ** kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.re.Match[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Pattern , List , Any [EOL] import typing [EOL] import builtins [EOL] import markdown [EOL] from __future__ import print_function [EOL] import re [EOL] import os [EOL] from typing import Any , Dict , Optional , List [EOL] [EOL] import markdown [EOL] from markdown_include . include import MarkdownInclude , IncludePreprocessor [EOL] [EOL] from zerver . lib . exceptions import InvalidMarkdownIncludeStatement [EOL] [EOL] INC_SYNTAX = re . compile ( [string] ) [EOL] [EOL] [EOL] class MarkdownIncludeCustom ( MarkdownInclude ) : [EOL] def extendMarkdown ( self , md , md_globals ) : [EOL] md . preprocessors . add ( [string] , IncludeCustomPreprocessor ( md , self . getConfigs ( ) ) , [string] ) [EOL] [EOL] class IncludeCustomPreprocessor ( IncludePreprocessor ) : [EOL] [docstring] [EOL] def run ( self , lines ) : [EOL] done = False [EOL] while not done : [EOL] for line in lines : [EOL] loc = lines . index ( line ) [EOL] m = INC_SYNTAX . search ( line ) [EOL] [EOL] if m : [EOL] filename = m . group ( [number] ) [EOL] filename = os . path . expanduser ( filename ) [EOL] if not os . path . isabs ( filename ) : [EOL] filename = os . path . normpath ( os . path . join ( self . base_path , filename ) ) [EOL] try : [EOL] with open ( filename , [string] , encoding = self . encoding ) as r : [EOL] text = r . readlines ( ) [EOL] except Exception as e : [EOL] print ( [string] . format ( filename , e ) ) [EOL] lines [ loc ] = INC_SYNTAX . sub ( [string] , line ) [EOL] raise InvalidMarkdownIncludeStatement ( m . group ( [number] ) . strip ( ) ) [EOL] [EOL] line_split = INC_SYNTAX . split ( line ) [EOL] if len ( text ) == [number] : [EOL] text . append ( [string] ) [EOL] for i in range ( len ( text ) ) : [EOL] text [ i ] = text [ i ] . rstrip ( [string] ) [EOL] text [ [number] ] = line_split [ [number] ] + text [ [number] ] [EOL] text [ - [number] ] = text [ - [number] ] + line_split [ [number] ] [EOL] lines = lines [ : loc ] + text + lines [ loc + [number] : ] [EOL] break [EOL] else : [EOL] done = True [EOL] [EOL] return lines [EOL] [EOL] def makeExtension ( * args , ** kwargs ) : [EOL] return MarkdownIncludeCustom ( kwargs ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $markdown.Markdown$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $markdown.Markdown$ 0 0 0 0 0 0 0 0 0 $markdown.Markdown$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $MarkdownIncludeCustom$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Type [EOL] import typing [EOL] import zilencer [EOL] from django import forms [EOL] [EOL] class EnterpriseToSForm ( forms . Form ) : [EOL] full_name = forms . CharField ( max_length = [number] ) [EOL] company = forms . CharField ( max_length = [number] ) [EOL] terms = forms . BooleanField ( required = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[zilencer.forms.EnterpriseToSForm]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[zilencer.forms.EnterpriseToSForm]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[zilencer.forms.EnterpriseToSForm]$ 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from __future__ import unicode_literals [EOL] [EOL] from django . db import migrations [EOL] [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] from typing import List , Tuple [EOL] import typing [EOL] from django . db import migrations [EOL] [EOL] class Migration ( migrations . Migration ) : [EOL] [EOL] dependencies = [ ( [string] , [string] ) , ] [EOL] [EOL] operations = [ migrations . RemoveField ( model_name = [string] , name = [string] , ) , migrations . DeleteModel ( name = [string] , ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import List , Any [EOL] import typing [EOL] from django . conf . urls import include , url [EOL] [EOL] import analytics . views [EOL] from zerver . lib . rest import rest_dispatch [EOL] [EOL] i18n_urlpatterns = [ url ( [string] , analytics . views . get_activity , name = [string] ) , url ( [string] , analytics . views . get_realm_activity , name = [string] ) , url ( [string] , analytics . views . get_user_activity , name = [string] ) , url ( [string] , analytics . views . stats_for_realm , name = [string] ) , url ( [string] , analytics . views . stats_for_installation , name = [string] ) , url ( [string] , analytics . views . stats , name = [string] ) , ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] v1_api_and_json_patterns = [ url ( [string] , rest_dispatch , { [string] : [string] } ) , url ( [string] , rest_dispatch , { [string] : [string] } ) , url ( [string] , rest_dispatch , { [string] : [string] } ) , ] [EOL] [EOL] i18n_urlpatterns += [ url ( [string] , include ( v1_api_and_json_patterns ) ) , url ( [string] , include ( v1_api_and_json_patterns ) ) , ] [EOL] [EOL] urlpatterns = i18n_urlpatterns [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0
	0
	0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] import zerver [EOL] import datetime [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from django . core . management . base import BaseCommand [EOL] from django . utils . timezone import now as timezone_now [EOL] [EOL] from zerver . models import Message , Realm , Stream , UserProfile , get_realm [EOL] [EOL] class Command ( BaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , nargs = [string] , help = [string] ) [EOL] [EOL] def messages_sent_by ( self , user , week ) : [EOL] start = timezone_now ( ) - datetime . timedelta ( days = ( week + [number] ) * [number] ) [EOL] end = timezone_now ( ) - datetime . timedelta ( days = week * [number] ) [EOL] return Message . objects . filter ( sender = user , pub_date__gt = start , pub_date__lte = end ) . count ( ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] if options [ [string] ] : [EOL] try : [EOL] realms = [ get_realm ( string_id ) for string_id in options [ [string] ] ] [EOL] except Realm . DoesNotExist as e : [EOL] print ( e ) [EOL] exit ( [number] ) [EOL] else : [EOL] realms = Realm . objects . all ( ) [EOL] [EOL] for realm in realms : [EOL] print ( realm . string_id ) [EOL] user_profiles = UserProfile . objects . filter ( realm = realm , is_active = True ) [EOL] print ( [string] % ( len ( user_profiles ) , ) ) [EOL] print ( [string] % ( len ( Stream . objects . filter ( realm = realm ) ) , ) ) [EOL] [EOL] for user_profile in user_profiles : [EOL] print ( [string] % ( user_profile . email , ) , end = [string] ) [EOL] for week in range ( [number] ) : [EOL] print ( [string] % ( self . messages_sent_by ( user_profile , week ) ) , end = [string] ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $zerver.models.UserProfile$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $zerver.models.UserProfile$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import argparse [EOL] from argparse import ArgumentParser [EOL] from typing import Any [EOL] [EOL] from django . core . management . base import BaseCommand [EOL] from django . db . models import Q [EOL] [EOL] from zerver . models import Message , Realm , Recipient , Stream , Subscription , get_realm [EOL] [EOL] class Command ( BaseCommand ) : [EOL] help = [string] [EOL] [EOL] def add_arguments ( self , parser ) : [EOL] parser . add_argument ( [string] , metavar = [string] , type = str , nargs = [string] , help = [string] ) [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] if options [ [string] ] : [EOL] try : [EOL] realms = [ get_realm ( string_id ) for string_id in options [ [string] ] ] [EOL] except Realm . DoesNotExist as e : [EOL] print ( e ) [EOL] exit ( [number] ) [EOL] else : [EOL] realms = Realm . objects . all ( ) [EOL] [EOL] for realm in realms : [EOL] print ( realm . string_id ) [EOL] print ( [string] ) [EOL] print ( [string] % ( [string] , [string] , [string] ) ) [EOL] streams = Stream . objects . filter ( realm = realm ) . exclude ( Q ( name__istartswith = [string] ) ) [EOL] invite_only_count = [number] [EOL] for stream in streams : [EOL] if stream . invite_only : [EOL] invite_only_count += [number] [EOL] continue [EOL] print ( [string] % ( stream . name , ) , end = [string] ) [EOL] recipient = Recipient . objects . filter ( type = Recipient . STREAM , type_id = stream . id ) [EOL] print ( [string] % ( len ( Subscription . objects . filter ( recipient = recipient , active = True ) ) , ) , end = [string] ) [EOL] num_messages = len ( Message . objects . filter ( recipient = recipient ) ) [EOL] print ( [string] % ( num_messages , ) ) [EOL] print ( [string] % ( invite_only_count , ) ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import datetime [EOL] import builtins [EOL] from argparse import ArgumentParser [EOL] from datetime import timedelta [EOL] [EOL] from django . core . management . base import BaseCommand [EOL] from django . utils . timezone import now as timezone_now [EOL] [EOL] from analytics . models import InstallationCount , installation_epoch , last_successful_fill [EOL] from analytics . lib . counts import COUNT_STATS , CountStat [EOL] from zerver . lib . timestamp import floor_to_hour , floor_to_day , verify_UTC , TimezoneNotUTCException [EOL] from zerver . models import Realm [EOL] [EOL] import os [EOL] import sys [EOL] import time [EOL] from typing import Any , Dict [EOL] [EOL] states = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] class Command ( BaseCommand ) : [EOL] help = [string] [EOL] [EOL] def handle ( self , * args , ** options ) : [EOL] fill_state = self . get_fill_state ( ) [EOL] status = fill_state [ [string] ] [EOL] message = fill_state [ [string] ] [EOL] [EOL] state_file_path = [string] [EOL] state_file_tmp = state_file_path + [string] [EOL] [EOL] with open ( state_file_tmp , [string] ) as f : [EOL] f . write ( [string] % ( int ( time . time ( ) ) , status , states [ status ] , message ) ) [EOL] os . rename ( state_file_tmp , state_file_path ) [EOL] [EOL] def get_fill_state ( self ) : [EOL] if not Realm . objects . exists ( ) : [EOL] return { [string] : [number] , [string] : [string] } [EOL] [EOL] warning_unfilled_properties = [ ] [EOL] critical_unfilled_properties = [ ] [EOL] for property , stat in COUNT_STATS . items ( ) : [EOL] last_fill = last_successful_fill ( property ) [EOL] if last_fill is None : [EOL] last_fill = installation_epoch ( ) [EOL] try : [EOL] verify_UTC ( last_fill ) [EOL] except TimezoneNotUTCException : [EOL] return { [string] : [number] , [string] : [string] % ( property , ) } [EOL] [EOL] if stat . frequency == CountStat . DAY : [EOL] floor_function = floor_to_day [EOL] warning_threshold = timedelta ( hours = [number] ) [EOL] critical_threshold = timedelta ( hours = [number] ) [EOL] else : [comment] [EOL] floor_function = floor_to_hour [EOL] warning_threshold = timedelta ( minutes = [number] ) [EOL] critical_threshold = timedelta ( minutes = [number] ) [EOL] [EOL] if floor_function ( last_fill ) != last_fill : [EOL] return { [string] : [number] , [string] : [string] % ( stat . frequency , property ) } [EOL] [EOL] time_to_last_fill = timezone_now ( ) - last_fill [EOL] if time_to_last_fill > critical_threshold : [EOL] critical_unfilled_properties . append ( property ) [EOL] elif time_to_last_fill > warning_threshold : [EOL] warning_unfilled_properties . append ( property ) [EOL] [EOL] if len ( critical_unfilled_properties ) == [number] and len ( warning_unfilled_properties ) == [number] : [EOL] return { [string] : [number] , [string] : [string] } [EOL] if len ( critical_unfilled_properties ) == [number] : [EOL] return { [string] : [number] , [string] : [string] % ( [string] . join ( warning_unfilled_properties ) , ) } [EOL] return { [string] : [number] , [string] : [string] % ( [string] . join ( warning_unfilled_properties ) , [string] . join ( critical_unfilled_properties ) ) } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.int,builtins.str]$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $datetime.timedelta$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $datetime.timedelta$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0
	0
	0
	0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import sys [EOL] import types [EOL] [EOL] BASE_DIR = os . path . dirname ( os . path . dirname ( os . path . abspath ( __file__ ) ) ) [EOL] sys . path . append ( BASE_DIR ) [EOL] import scripts . lib . setup_path_on_import [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] sys . modules [ [string] ] = types . ModuleType ( [string] ) [EOL] [EOL] os . environ . setdefault ( [string] , [string] ) [EOL] import django [EOL] django . setup ( ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] import zerver . models [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from django . core . wsgi import get_wsgi_application [EOL] application = get_wsgi_application ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0