from typing import Any [EOL] import typing [EOL] from aura import create_app , get_config [EOL] [EOL] config = get_config ( [string] ) [EOL] app = create_app ( config ) [EOL] [EOL] if __name__ == [string] : [EOL] app . run ( ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from sqlalchemy import text [EOL] from sqlalchemy_utils import database_exists , create_database , drop_database [EOL] import pytest [EOL] from aura import create_app , get_config [EOL] from aura . models import db , ClassTemplate [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def app ( ) : [EOL] config = get_config ( [string] ) [EOL] app = create_app ( config ) [EOL] ctx = app . app_context ( ) [EOL] ctx . push ( ) [EOL] return app [EOL] [EOL] [EOL] @ pytest . fixture ( scope = [string] , autouse = True ) def create_db ( app ) : [EOL] if not database_exists ( db . engine . url ) : [EOL] create_database ( db . engine . url ) [EOL] yield [EOL] drop_database ( db . engine . url ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def db_manager ( ) : [EOL] db . create_all ( ) [EOL] conn = db . engine . connect ( ) [EOL] conn . execute ( text ( open ( [string] , [string] ) . read ( ) ) . execution_options ( autocommit = True ) ) [EOL] yield [EOL] db . session . close ( ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def unit_template ( db_manager ) : [EOL] return ClassTemplate . query . get ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from flask import g [EOL] from aura . services . player_service import grant_unit [EOL] from aura . models import db , Player [EOL] [EOL] @ pytest . fixture ( autouse = True ) def db_managed ( db_manager ) : [EOL] yield db_manager [EOL] [EOL] [EOL] def test_grant_unit ( ) : [EOL] p = Player ( [string] ) [EOL] db . session . add ( p ) [EOL] db . session . commit ( ) [EOL] [EOL] g . current_player_id = p . id [EOL] grant_unit ( [string] ) [EOL] [EOL] player = Player . query . get ( p . id ) [EOL] assert player . unit_count == [number] [EOL] assert player . units [ [number] ] . _class . name == [string] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from flask import g [EOL] from aura . exceptions import ServiceError , DomainError [EOL] from aura . services . user_service import create_user , retrieve_user , update_password , requires_user [EOL] from aura . models import db , User [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def db_managed ( db_manager ) : [EOL] yield db_manager [EOL] [EOL] [EOL] def test_create_user_domain_error ( ) : [EOL] [comment] [EOL] with pytest . raises ( DomainError ) : [EOL] create_user ( username = [string] , password = [string] ) [EOL] [EOL] [EOL] def test_create_user_username_already_exists ( ) : [EOL] create_user ( [string] , [string] ) [EOL] with pytest . raises ( ServiceError ) : [EOL] create_user ( [string] , [string] ) [EOL] [EOL] [EOL] def test_create_user ( ) : [EOL] [comment] [EOL] user = create_user ( [string] , [string] ) [EOL] assert isinstance ( user , User ) [EOL] assert user . id is not None [EOL] assert db . session . query ( User ) . filter_by ( username = [string] ) . first ( ) is not None [EOL] [EOL] [EOL] def test_retrieve_user_invalid_credentials ( ) : [EOL] create_user ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( ServiceError ) : [EOL] retrieve_user ( [string] , [string] ) [EOL] [comment] [EOL] with pytest . raises ( ServiceError ) : [EOL] retrieve_user ( [string] , [string] ) [EOL] [EOL] [EOL] def test_retrieve_user ( ) : [EOL] create_user ( [string] , [string] ) [EOL] user = retrieve_user ( [string] , [string] ) [EOL] assert user . id is not None [EOL] assert user . username == [string] [EOL] [EOL] [EOL] def test_requires_user_no_g_player_id ( ) : [EOL] create_user ( [string] , [string] ) [EOL] g . pop ( [string] , None ) [EOL] with pytest . raises ( ServiceError ) : [EOL] requires_user ( lambda : None ) ( ) [EOL] [EOL] [EOL] def test_requires_user_invalid_player_id ( ) : [EOL] create_user ( [string] , [string] ) [EOL] g . current_player_id = - [number] [EOL] with pytest . raises ( ServiceError ) : [EOL] requires_user ( lambda : None ) ( ) [EOL] [EOL] [EOL] def test_update_password ( ) : [EOL] user = create_user ( [string] , [string] ) [EOL] g . current_player_id = user . player_id [EOL] update_password ( [string] ) [EOL] new_user = retrieve_user ( [string] , [string] ) [EOL] assert user . id == new_user . id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from flask import g [EOL] from aura . models import db , Player , Encounter [EOL] from aura . services . player_service import grant_unit [EOL] from aura . encounter . manager import EncounterManager [EOL] [EOL] [EOL] def create_player ( name ) : [EOL] player = Player ( name ) [EOL] db . session . add ( player ) [EOL] db . session . commit ( ) [EOL] g . current_player_id = player . id [EOL] g . current_player = player [EOL] grant_unit ( [string] ) [EOL] player . add_to_squad ( [number] , [number] ) [EOL] player . units [ [number] ] . name = [string] . format ( player . units [ [number] ] . name , player . name ) [EOL] return player [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def players ( db_manager ) : [EOL] player1 = create_player ( [string] ) [EOL] player2 = create_player ( [string] ) [EOL] yield ( player1 , player2 ) [EOL] [EOL] [EOL] import json [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from aura . models import Unit , ClassTemplate [EOL] from aura . units . classes import Knight [EOL] [EOL] [EOL] def test_constructor ( ) : [EOL] template = ClassTemplate ( ) [EOL] template . name = [string] [EOL] template . display_name = [string] [EOL] template . hp = [number] , [EOL] template . attack_m = [number] , [EOL] template . attack_p = [number] [EOL] template . defense_m = [number] [EOL] template . defense_p = [number] [EOL] [EOL] unit = Unit ( template ) [EOL] assert unit . _class == template [EOL] assert unit . name == template . display_name [EOL] assert unit . hp == template . hp [EOL] assert unit . attack_p == template . attack_p [EOL] assert unit . attack_m == template . attack_m [EOL] assert unit . defense_p == template . defense_p [EOL] assert unit . defense_m == template . defense_m [EOL] assert unit . initiative == template . initiative [EOL] [EOL] [EOL] def test_class_template_query ( db_manager ) : [EOL] from_id = ClassTemplate . query . get ( [number] ) [EOL] from_name = ClassTemplate . query . get ( [string] ) [EOL] assert from_id is not None [EOL] assert from_name is not None [EOL] assert from_id == from_name [EOL] [EOL] [EOL] def test_inheritance ( db_manager ) : [EOL] knight = ClassTemplate . query . get ( [number] ) [EOL] assert knight . hp_growth == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from unittest . mock import patch [EOL] from aura . exceptions import DomainError [EOL] from aura . models import User [EOL] [EOL] [EOL] @ patch ( [string] ) @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_password_failures ( mock_user , pw ) : [EOL] mock_user . return_value = None [EOL] user = User ( ) [EOL] [comment] [EOL] with pytest . raises ( DomainError ) : [EOL] user . password = pw [EOL] [EOL] [EOL] @ patch ( [string] ) @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] * [number] ] ) def test_username_failures ( mock_user , name ) : [EOL] mock_user . return_value = None [EOL] user = User ( ) [EOL] [comment] [EOL] with pytest . raises ( DomainError ) : [EOL] user . username = name [EOL] [EOL] [EOL] def test_constructor ( ) : [EOL] user = User ( username = [string] , password = [string] ) [EOL] assert user . username == [string] [EOL] assert user . password_is ( [string] ) [EOL] [EOL] [EOL] def test_hybrid_properties ( ) : [EOL] user = User ( username = [string] , password = [string] ) [EOL] assert user . username == user . _username [EOL] assert user . password == user . _password [EOL] [EOL] [EOL] def test_setter_properties ( ) : [EOL] user = User ( username = [string] , password = [string] ) [EOL] user . username = [string] [EOL] assert user . username == [string] [EOL] user . password = [string] [EOL] assert user . password_is ( [string] ) [EOL] [EOL] [EOL] def test_password_encryption ( ) : [EOL] user = User ( [string] , [string] ) [EOL] assert user . password != [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import uuid [EOL] import pytest [EOL] from aura . exceptions import DomainError [EOL] [EOL] from aura . models import Challenge , Player [EOL] from uuid import uuid4 [EOL] [EOL] [EOL] @ pytest . fixture def challenge ( ) : [EOL] p1 = Player ( [string] ) [EOL] p2 = Player ( [string] ) [EOL] room = uuid4 ( ) [EOL] return Challenge ( p1 , p2 , room ) [EOL] [EOL] def test_challenge_constructor ( ) : [EOL] p1 = Player ( [string] ) [EOL] p2 = Player ( [string] ) [EOL] room = uuid4 ( ) [EOL] challenge = Challenge ( p1 , p2 , room ) [EOL] assert challenge . challenger == p1 [EOL] assert challenge . opponent == p2 [EOL] assert challenge . room == room [EOL] assert challenge . status == [string] [EOL] [EOL] def test_challenge_refusal ( challenge ) : [EOL] challenge . refuse ( challenge . opponent ) [EOL] assert challenge . status == [string] [EOL] assert challenge . time_finished is not None [EOL] assert challenge . by == challenge . opponent . id [EOL] [EOL] def test_challenge_accept ( challenge ) : [EOL] challenge . accept ( challenge . opponent ) [EOL] assert challenge . status == [string] [EOL] assert challenge . time_finished is not None [EOL] assert challenge . by == challenge . opponent . id [EOL] [EOL] def test_challenge_accepted_by_stranger ( challenge ) : [EOL] with pytest . raises ( DomainError ) : [EOL] challenge . accept ( Player ( [string] ) ) [EOL] [EOL] def test_challenge_cancelled ( challenge ) : [EOL] challenge . cancel ( challenge . challenger ) [EOL] assert challenge . status == [string] [EOL] assert challenge . time_finished is not None [EOL] assert challenge . by == challenge . challenger . id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] from aura . exceptions import DomainError [EOL] [EOL] from aura . models import Player [EOL] [EOL] [EOL] @ pytest . fixture def player ( ) : [EOL] return Player ( [string] ) [EOL] [EOL] [EOL] def test_add_unit ( player , unit_template ) : [EOL] assert len ( player . units ) == [number] [EOL] unit = player . add_unit ( unit_template ) [EOL] assert len ( player . units ) == [number] [EOL] assert player . units [ [number] ] == unit [EOL] assert unit . player == player [EOL] [EOL] [EOL] def test_add_to_squad ( player , unit_template ) : [EOL] assert len ( player . squad ) == [number] [EOL] unit1 = player . add_unit ( unit_template ) [EOL] unit2 = player . add_unit ( unit_template ) [EOL] player . add_to_squad ( unit1 . number , [number] ) [EOL] player . add_to_squad ( unit2 . number , [number] ) [EOL] assert unit1 . position == [number] [EOL] assert unit2 . position == [number] [EOL] assert player . squad [ [number] ] == unit1 [EOL] assert player . squad [ [number] ] == unit2 [EOL] [EOL] [EOL] def test_squad_move_unit_to_empty_position ( player , unit_template ) : [EOL] unit = player . add_unit ( unit_template ) [EOL] player . add_to_squad ( unit , [number] ) [EOL] player . add_to_squad ( unit , [number] ) [EOL] assert unit . position == [number] [EOL] assert player . squad [ [number] ] is None [EOL] assert player . squad [ [number] ] == unit [EOL] [EOL] [EOL] def test_squad_switch_unit_positions ( player , unit_template ) : [EOL] unit1 = player . add_unit ( unit_template ) [EOL] unit2 = player . add_unit ( unit_template ) [EOL] player . add_to_squad ( unit1 , [number] ) [EOL] player . add_to_squad ( unit2 , [number] ) [EOL] [EOL] player . add_to_squad ( unit2 , [number] ) [EOL] assert player . squad [ [number] ] == unit2 [EOL] assert player . squad [ [number] ] == unit1 [EOL] assert unit1 . position == [number] [EOL] assert unit2 . position == [number] [EOL] [EOL] [EOL] def test_squad_replace_unit_with_reserve ( player , unit_template ) : [EOL] unit1 = player . add_unit ( unit_template ) [EOL] unit2 = player . add_unit ( unit_template ) [EOL] player . add_to_squad ( unit1 . number , [number] ) [EOL] player . add_to_squad ( unit2 . number , [number] ) [EOL] assert player . squad [ [number] ] == unit2 [EOL] assert unit1 . position is None [EOL] assert unit2 . position == [number] [EOL] [EOL] [EOL] def test_add_to_squad_wrong_number ( player ) : [EOL] with pytest . raises ( DomainError ) : [EOL] player . add_to_squad ( - [number] , [number] ) [EOL] [EOL] [EOL] def test_remove_from_squad ( player , unit_template ) : [EOL] unit = player . add_unit ( unit_template ) [EOL] player . add_to_squad ( unit , [number] ) [EOL] player . remove_from_squad ( unit ) [EOL] assert player . squad [ [number] ] is None [EOL] assert unit . position is None [EOL] [EOL] [EOL] def test_remove_from_squad_invalid_unit ( player ) : [EOL] with pytest . raises ( DomainError ) : [EOL] player . remove_from_squad ( - [number] ) [EOL] [EOL] [EOL] def test_remove_from_squad_reserve_unit ( player , unit_template ) : [EOL] unit = player . add_unit ( unit_template ) [EOL] with pytest . raises ( DomainError ) : [EOL] player . remove_from_squad ( unit . number ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class ApplicationError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class ServiceError ( ApplicationError ) : [EOL] pass [EOL] [EOL] [EOL] class DomainError ( ApplicationError ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask [EOL] import yaml [EOL] from flask import Flask , g [EOL] from flask_bcrypt import Bcrypt [EOL] from flask_jwt_extended import JWTManager [EOL] from flask_pymongo import PyMongo [EOL] from dotenv import load_dotenv [EOL] load_dotenv ( ) [EOL] [EOL] bcrypt = Bcrypt ( ) [EOL] jwt = JWTManager ( ) [EOL] mongo = PyMongo ( ) [EOL] [EOL] [EOL] def get_config ( env ) : [EOL] config = yaml . load ( open ( [string] ) ) [EOL] return { ** config [ [string] ] , ** config [ env ] } [EOL] [EOL] [EOL] def create_app ( config ) : [EOL] app = Flask ( __name__ ) [EOL] app . config . from_mapping ( config ) [EOL] [EOL] with app . app_context ( ) : [EOL] bcrypt . init_app ( app ) [EOL] jwt . init_app ( app ) [EOL] mongo . init_app ( app ) [EOL] [EOL] from aura . models import db , migrate [EOL] db . init_app ( app ) [EOL] migrate . init_app ( app ) [EOL] [EOL] from aura . blueprints import register_before , register_blueprints [EOL] register_before ( app ) [EOL] register_blueprints ( app ) [EOL] [EOL] return app [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
import aura . units . classes	0 0 0 0 0 0
from typing import Type [EOL] import aura [EOL] import typing [EOL] import server [EOL] from sqlalchemy_utc import UtcDateTime , utcnow [EOL] from sqlalchemy . dialects . postgresql import ARRAY [EOL] from aura . models import db , Player [EOL] [EOL] [EOL] class Encounter ( db . Model ) : [EOL] id = db . Column ( db . Integer , primary_key = True ) [EOL] players = db . Column ( ARRAY ( db . Integer ) ) [EOL] status = db . Column ( db . String ) [EOL] time_started = db . Column ( UtcDateTime , default = utcnow ( ) ) [EOL] [EOL] def __init__ ( self , p1 , p2 ) : [EOL] self . players = [ p1 , p2 ] [EOL] self . status = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.encounter_model.Encounter]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aura.models.Player$ 0 $aura.models.Player$ 0 0 0 0 0 0 0 0 $aura.models.Player$ 0 $aura.models.Player$ 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] import server [EOL] from aura . models import db , Unit [EOL] from aura . exceptions import DomainError [EOL] [EOL] UNIT_NOT_FOUND = [string] [EOL] UNIT_NOT_IN_SQUAD = [string] [EOL] [EOL] [EOL] class Player ( db . Model ) : [EOL] id = db . Column ( db . Integer , primary_key = True ) [EOL] name = db . Column ( db . String , nullable = False ) [EOL] unit_count = db . Column ( db . Integer , default = [number] ) [EOL] user = db . relationship ( [string] , uselist = False , back_populates = [string] ) [EOL] in_encounter = db . Column ( db . Boolean , default = False ) [EOL] [EOL] units = db . relationship ( [string] , backref = [string] , lazy = True ) [EOL] [EOL] def __init__ ( self , name ) : [EOL] self . name = name [EOL] self . unit_count = [number] [EOL] self . _squad = None [EOL] [EOL] @ property def squad ( self ) : [EOL] if self . _squad is None : [EOL] self . _squad = { } [EOL] for unit in self . units : [EOL] if unit . position is not None : [EOL] self . _squad [ unit . position ] = unit [EOL] for i in range ( [number] ) : [EOL] if i not in self . _squad : [EOL] self . _squad [ i ] = None [EOL] return self . _squad [EOL] [EOL] def get_unit ( self , unit_number ) : [EOL] if isinstance ( unit_number , Unit ) : [EOL] return unit_number [EOL] for u in self . units : [EOL] if u . number == unit_number : [EOL] return u [EOL] return None [EOL] [EOL] def remove_from_squad ( self , unit_number ) : [EOL] unit = self . get_unit ( unit_number ) [EOL] if not unit : [EOL] raise DomainError ( UNIT_NOT_FOUND . format ( unit_number ) ) [EOL] pos = unit . position [EOL] if pos is None : [EOL] raise DomainError ( UNIT_NOT_IN_SQUAD . format ( unit_number ) ) [EOL] unit . position = None [EOL] self . squad [ pos ] = None [EOL] [EOL] def add_to_squad ( self , unit_number , position ) : [EOL] unit = self . get_unit ( unit_number ) [EOL] if not unit : [EOL] raise DomainError ( UNIT_NOT_FOUND . format ( unit_number ) ) [EOL] current_unit = self . squad [ position ] [EOL] if current_unit is not None : [EOL] current_unit . position = unit . position [EOL] if unit . position is not None : [EOL] self . squad [ unit . position ] = current_unit [EOL] unit . position = position [EOL] self . squad [ position ] = unit [EOL] [EOL] def add_unit ( self , unit_template ) : [EOL] self . unit_count += [number] [EOL] unit = Unit ( unit_template ) [EOL] unit . number = self . unit_count [EOL] self . units . append ( unit ) [EOL] return unit [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.player_model.Player]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
from typing import Any , Type [EOL] import typing [EOL] import server [EOL] from sqlalchemy . ext . hybrid import hybrid_property [EOL] from datetime import datetime [EOL] from aura import bcrypt [EOL] from aura . models import db [EOL] from aura . exceptions import DomainError [EOL] [EOL] USERNAME_MIN_LENGTH = [number] [EOL] USERNAME_MAX_LENGTH = [number] [EOL] PASSWORD_MIN_LENGTH = [number] [EOL] USERNAME_LENGTH_FAIL = [string] . format ( USERNAME_MIN_LENGTH , USERNAME_MAX_LENGTH ) [EOL] PASSWORD_TOO_SHORT = [string] . format ( PASSWORD_MIN_LENGTH ) [EOL] USERNAME_EMPTY = [string] [EOL] [EOL] [EOL] class User ( db . Model ) : [EOL] id = db . Column ( [string] , db . Integer , primary_key = True ) [EOL] player_id = db . Column ( [string] , db . ForeignKey ( [string] ) , nullable = False ) [EOL] _username = db . Column ( [string] , db . String , unique = True , nullable = False ) [EOL] _password = db . Column ( [string] , db . Text , nullable = False ) [EOL] [EOL] active = db . Column ( [string] , db . Boolean , default = True ) [EOL] player = db . relationship ( [string] ) [EOL] [EOL] def __init__ ( self , username = None , password = None ) : [EOL] self . username = username [EOL] self . password = password [EOL] self . active = True [EOL] self . created_at = datetime . now ( ) [EOL] self . roles = [ ] [EOL] [EOL] @ hybrid_property def username ( self ) : return self . _username [comment] [EOL] [EOL] @ hybrid_property def password ( self ) : return self . _password [comment] [EOL] [EOL] @ username . setter def username ( self , name ) : [EOL] if not name : [EOL] raise DomainError ( USERNAME_EMPTY ) [EOL] if not USERNAME_MIN_LENGTH < len ( name ) < USERNAME_MAX_LENGTH : [EOL] raise DomainError ( USERNAME_LENGTH_FAIL ) [EOL] self . _username = name [EOL] [EOL] @ password . setter def password ( self , pw ) : [EOL] if not pw or len ( pw ) < PASSWORD_MIN_LENGTH : [EOL] raise DomainError ( PASSWORD_TOO_SHORT ) [EOL] pw = pw . encode ( [string] ) [EOL] self . _password = bcrypt . generate_password_hash ( pw ) . decode ( [string] ) [EOL] [EOL] def password_is ( self , pw ) : [EOL] pw = pw . encode ( [string] ) [EOL] return bcrypt . check_password_hash ( self . password . encode ( [string] ) , pw ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[server.aura.models.user_model.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Dict [EOL] import typing [EOL] from flask_sqlalchemy import SQLAlchemy [EOL] from flask_migrate import Migrate [EOL] from sqlalchemy import MetaData [EOL] [EOL] convention = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] metadata = MetaData ( naming_convention = convention ) [EOL] db = SQLAlchemy ( metadata = metadata ) [EOL] migrate = Migrate ( db = db ) [EOL] [EOL] from . user_model import User [EOL] from . unit_model import Unit , StatusEnum , ClassTemplate [EOL] from . player_model import Player [EOL] from . challenge_model import Challenge [EOL] from . encounter_model import Encounter [EOL] from . skill_model import Skill , DamageTypeEnum , TargetAlignment , TargetPattern [EOL] from aura . units . classes import * [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import aura [EOL] import typing [EOL] import server [EOL] import datetime [EOL] from aura . exceptions import DomainError [EOL] from sqlalchemy_utc import UtcDateTime , utc , utcnow [EOL] from aura . models import db , Player [EOL] [EOL] OPPONENT_MUST_ACCEPT = [string] [EOL] [EOL] [EOL] class Challenge ( db . Model ) : [EOL] id = db . Column ( db . Integer , primary_key = True ) [EOL] id_challenger = db . Column ( db . Integer , db . ForeignKey ( [string] ) ) [EOL] id_opponent = db . Column ( db . Integer , db . ForeignKey ( [string] ) ) [EOL] challenger = db . relationship ( [string] , foreign_keys = [ id_challenger ] ) [EOL] opponent = db . relationship ( [string] , foreign_keys = [ id_opponent ] ) [EOL] status = db . Column ( db . String ) [EOL] by = db . Column ( db . String , nullable = True ) [EOL] room = db . Column ( db . String ( [number] ) ) [EOL] time_created = db . Column ( UtcDateTime , default = utcnow ( ) ) [EOL] time_finished = db . Column ( UtcDateTime ) [EOL] [EOL] def __init__ ( self , challenger , opponent , room ) : [EOL] self . challenger = challenger [EOL] self . opponent = opponent [EOL] self . room = room [EOL] self . status = [string] [EOL] [EOL] def refuse ( self , player ) : [EOL] self . status = [string] [EOL] self . by = player . id [EOL] self . time_finished = datetime . datetime . now ( utc ) [EOL] [EOL] def accept ( self , player ) : [EOL] if player != self . opponent : [EOL] raise DomainError ( OPPONENT_MUST_ACCEPT ) [EOL] self . status = [string] [EOL] self . time_finished = datetime . datetime . now ( utc ) [EOL] [EOL] def cancel ( self , player ) : [EOL] self . status = [string] [EOL] self . by = player . id [EOL] self . time_finished = datetime . datetime . now ( utc ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aura.models.Player$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $aura.models.Player$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aura.models.Player$ 0 0 0 0 $aura.models.Player$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from functools import wraps [EOL] from flask import g [EOL] from aura . services import transactional [EOL] from aura . exceptions import ServiceError [EOL] from aura . models import db , User , Player [EOL] [EOL] REQUIRES_USER = [string] [EOL] INVALID_SESSION = [string] [EOL] USERNAME_UNAVAILABLE = [string] [EOL] INVALID_CREDENTIALS = [string] [EOL] [EOL] [EOL] def requires_user ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] if not [string] in g : [EOL] raise ServiceError ( REQUIRES_USER ) [EOL] user = User . query . filter_by ( player_id = g . current_player_id ) . first ( ) [EOL] if user is None : [EOL] raise ServiceError ( INVALID_SESSION ) [EOL] g . current_user = user [EOL] return f ( * args , ** kwargs ) [EOL] return wrapper [EOL] [EOL] [EOL] @ transactional def create_user ( username , password ) : [EOL] user = User . query . filter_by ( username = username ) . first ( ) [EOL] if user is not None : [EOL] raise ServiceError ( USERNAME_UNAVAILABLE ) [EOL] player = Player ( username ) [EOL] user = User ( username , password ) [EOL] user . player = player [EOL] db . session . add ( player ) [EOL] db . session . add ( user ) [EOL] return user [EOL] [EOL] [EOL] def retrieve_user ( username , password ) : [EOL] user = User . query . filter_by ( username = username ) . first ( ) [EOL] if user is None : [EOL] raise ServiceError ( INVALID_CREDENTIALS ) [EOL] if not user . password_is ( password ) : [EOL] raise ServiceError ( INVALID_CREDENTIALS ) [EOL] return user [EOL] [EOL] [EOL] @ transactional @ requires_user def update_password ( new_password ) : [EOL] g . current_user . password = new_password [EOL] db . session . add ( g . current_user ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flask import g [EOL] from aura . services import transactional , requires_player [EOL] from aura . models import db , ClassTemplate [EOL] [EOL] [EOL] @ transactional @ requires_player def grant_unit ( class_name ) : [EOL] template = ClassTemplate . query . get ( class_name ) [EOL] unit = g . current_player . add_unit ( template ) [EOL] db . session . add ( g . current_player ) [EOL] db . session . add ( unit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] from flask import g [EOL] from uuid import uuid4 [EOL] from datetime import timedelta , datetime [EOL] from aura . exceptions import ServiceError [EOL] from aura . models import db , Player , Challenge [EOL] from aura . services import requires_player , transactional [EOL] [EOL] OPPONENT_NOT_FOUND = [string] [EOL] CHALLENGE_TIMEOUT = [string] [EOL] CHALLENGE_NOT_FOUND = [string] [EOL] CHALLENGER_IN_ENCOUNTER = [string] [EOL] [EOL] [EOL] @ transactional @ requires_player def send_challenge ( id_opponent ) : [EOL] opponent = Player . query . get ( id_opponent ) [EOL] if not opponent : [EOL] raise ServiceError ( OPPONENT_NOT_FOUND ) [EOL] old_challenge = Challenge . query . filter_by ( challenger = g . current_player . id , opponent = opponent . id , status = [string] ) . first ( ) [EOL] if old_challenge is not None : [EOL] if old_challenge . time_created - datetime . utcnow ( ) < timedelta ( seconds = [number] ) : [EOL] raise ServiceError ( CHALLENGE_TIMEOUT ) [EOL] old_challenge . cancel ( g . current_player . id ) [EOL] db . add ( old_challenge ) [EOL] challenge = Challenge ( g . current_player , opponent , uuid4 ( ) ) [EOL] db . add ( challenge ) [EOL] return challenge . room [EOL] [EOL] [EOL] @ transactional @ requires_player def accept_challenge ( id_challenger ) : [EOL] challenge = Challenge . query . filter_by ( challenger = id_challenger , opponent = g . current_player . id , status = [string] ) . first ( ) [EOL] if challenge is None : [EOL] raise ServiceError ( CHALLENGE_NOT_FOUND ) [EOL] challenger = Player . query . get ( id_challenger ) [EOL] if challenger . in_encounter : [EOL] raise ServiceError ( CHALLENGER_IN_ENCOUNTER ) [EOL] challenge . accept ( g . current_player . id ) [EOL] db . session . add ( challenge ) [EOL] return challenge . room [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from flask import g [EOL] from functools import wraps [EOL] from aura . models import db , Player [EOL] [EOL] [EOL] def transactional ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] try : [EOL] val = f ( * args , ** kwargs ) [EOL] db . session . commit ( ) [EOL] return val [EOL] except ValueError as e : [EOL] db . session . rollback ( ) [EOL] raise e [EOL] return wrapper [EOL] [EOL] [EOL] def requires_player ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] player = Player . query . get ( g . current_player_id ) [EOL] if player is None : [EOL] [comment] [EOL] pass [EOL] g . current_player = player [EOL] return f ( * args , ** kwargs ) [EOL] return wrapper [EOL] [EOL] [EOL] import aura . services . user_service [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from aura . models import Player , Encounter	0 0 0 0 0 0 0 0
from typing import Any , Literal , Union [EOL] import aura [EOL] import typing_extensions [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import heapq [EOL] from aura import get_config [EOL] import aura . models as base [EOL] from pymongo import MongoClient [EOL] [EOL] env = os . getenv ( [string] , [string] ) [EOL] config = get_config ( env ) [EOL] client = MongoClient ( config [ [string] ] ) [EOL] db = client [ config [ [string] ] ] [EOL] [EOL] [EOL] class Action : [EOL] [EOL] def __init__ ( self , unit , skill , target ) : [EOL] self . unit = unit [EOL] self . skill = skill [EOL] self . target = target [EOL] [EOL] @ property def unit_can_use_skill ( self ) : [EOL] if self . unit . mana < self . skill . mana_cost : [EOL] return False [EOL] return True [EOL] [EOL] @ property def target_is_valid ( self ) : [EOL] if self . unit . player_id == self . target . player_id and base . TargetAlignment . ALLY not in self . skill . target_alignment : [EOL] return False [EOL] elif self . unit . player_id != self . target . player_id and base . TargetAlignment . FOE not in self . skill . target_alignment : [EOL] return False [EOL] if self . skill . frontline_only and not self . target . is_frontline : [EOL] return False [EOL] return True [EOL] [EOL] @ property def all_targets ( self ) : [EOL] if self . skill . reach == [number] : [EOL] return [ self . target ] [EOL] raise NotImplementedError [EOL] [EOL] def calculate_damage ( self , target ) : [EOL] pass [EOL] [EOL] def execute ( self ) : [EOL] if self . unit_can_use_skill and self . target_is_valid : [EOL] for target in self . all_targets : [EOL] self . calculate_damage ( target ) [EOL] [EOL] [EOL] class Unit : [EOL] [EOL] def __init__ ( self , unit , squad ) : [EOL] self . id = unit . id [EOL] self . hp = unit . hp [EOL] self . mana = unit . mana [EOL] self . attack_p = unit . attack_p [EOL] self . attack_m = unit . attack_m [EOL] self . defense_p = unit . defense_p [EOL] self . defense_m = unit . defense_m [EOL] self . skills = unit . skills [EOL] self . initiative = unit . _class . initiative [EOL] self . class_name = unit . _class . name [EOL] self . display_name = unit . name [EOL] self . player_id = unit . player_id [EOL] self . position = unit . position [EOL] self . squad = squad [EOL] self . action_delay = [number] [EOL] self . stun_counter = [number] [EOL] self . last_damaged_by = None [EOL] self . status = set ( ) [EOL] [EOL] def __le__ ( self , other ) : [EOL] return self . action_delay <= other . action_delay [EOL] [EOL] def get_skill ( self , skill_id ) : [EOL] for skill in self . skills : [EOL] if skill . id == skill_id : [EOL] return skill [EOL] return None [EOL] [EOL] def target_has_allowed_alignment ( self , skill , target ) : [EOL] if self . player_id == target . player_id and base . TargetAlignment . ALLY not in skill . target_alignment : [EOL] return False [EOL] elif self . player_id != target . player_id and base . TargetAlignment . FOE not in skill . target_alignment : [EOL] return False [EOL] return True [EOL] [EOL] @ property def is_frontline ( self ) : [EOL] pos = self . position [EOL] if pos >= [number] : [EOL] pos = pos - [number] [EOL] if self . squad [ pos ] is not None : [EOL] return False [EOL] if pos >= [number] : [EOL] pos = pos - [number] [EOL] if self . squad [ pos ] is not None : [EOL] return False [EOL] return True [EOL] [EOL] def perform_action ( self , target , skill_id ) : [EOL] skill = self . get_skill ( skill_id ) [EOL] if skill is None : [EOL] [comment] [EOL] raise Exception [EOL] if not self . target_has_allowed_alignment ( skill , target ) : [EOL] [comment] [EOL] raise Exception [EOL] if skill . frontline_only and not target . is_frontline : [EOL] [comment] [EOL] raise Exception [EOL] targets = self . get_targets ( target , skill ) [EOL] for target in targets : [EOL] self . deal_damage ( target , skill ) [EOL] self . action_delay += skill . action_cost [EOL] pass [EOL] [EOL] def get_targets ( self , target , skill ) : [EOL] if skill . reach == [number] : [EOL] return [ target ] [EOL] [EOL] [EOL] def deal_damage ( self , target , skill ) : [EOL] p_damage = skill . damage_p * skill . p_scaling [EOL] m_damage = skill . damage_m * skill . m_scaling [EOL] t_damage = skill . damage_p * skill . t_scaling [EOL] [EOL] target . take_damage ( p_damage , base . DamageTypeEnum . PHYSICAL ) [EOL] target . take_damage ( m_damage , base . DamageTypeEnum . MAGIC ) [EOL] target . take_damage ( t_damage , base . DamageTypeEnum . TRUE ) [EOL] pass [EOL] [EOL] def take_damage ( self , damage , type ) : [EOL] [docstring] [EOL] self . hp -= damage [EOL] if self . hp == [number] : [EOL] self . die ( ) [EOL] [EOL] def die ( self ) : [EOL] [docstring] [EOL] self . status = { base . StatusEnum . DEAD } [EOL] [EOL] [EOL] class EncounterManager : [EOL] [EOL] def __init__ ( self , encounter ) : [EOL] self . id = encounter . id [EOL] self . players = [ encounter . players [ [number] ] . id , encounter . players [ [number] ] . id ] [EOL] self . units = heapq . heapify ( [ ] ) [EOL] self . set_units ( ) [EOL] self . turn = [number] [EOL] self . current_unit = self . units [ [number] ] [EOL] [EOL] @ staticmethod def create_encounter_unit ( unit ) : [EOL] unit . action_delay = [number] [EOL] unit . stun_counter = [number] [EOL] unit . last_damaged_by = None [EOL] return unit [EOL] [EOL] def get_unit ( self , unit_id ) : [EOL] for unit in self . units : [EOL] if unit . id == unit_id : [EOL] return unit [EOL] return None [EOL] [EOL] def set_units ( self ) : [EOL] for player in self . players : [EOL] for _ , unit in player . squad . items ( ) : [EOL] if unit is None : continue [EOL] self . units . heappush ( Unit ( unit , player . squad ) ) [EOL] [EOL] def progress_turn ( self , action ) : [EOL] if not action . unit_id == self . current_unit : [EOL] [comment] [EOL] raise Exception [EOL] unit = self . get_unit ( action . unit_id ) [EOL] if unit is None : [EOL] [comment] [EOL] raise Exception [EOL] target = self . get_unit ( action . target_id ) [EOL] if target is None : [EOL] [comment] [EOL] raise Exception [EOL] unit . perform_action ( target , action . skill_id ) [EOL] heapq . heappop ( ) [EOL] [comment] [EOL] [comment] [EOL] heapq . heapreplace ( self . units , unit ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from flask_jwt_extended import get_jwt_identity [EOL] from flask import request , g , current_app [EOL] from functools import wraps [EOL] from schema import SchemaError [EOL] from aura . exceptions import ApplicationError [EOL] FAIL = [string] [EOL] ERROR = [string] [EOL] SUCCESS = [string] [EOL] [EOL] [EOL] def build_response ( status , content = None ) : [EOL] from flask import jsonify [EOL] if status == SUCCESS : [EOL] return jsonify ( status = status , data = content or { } ) [EOL] else : [EOL] if content is None : [EOL] raise ValueError ( [string] ) [EOL] return jsonify ( status = status , message = content ) [EOL] [EOL] [EOL] def validate ( schema , data ) : [EOL] try : [EOL] return schema . validate ( data ) [EOL] except SchemaError : [EOL] raise ApplicationError ( [string] . format ( str ( schema ) ) ) [EOL] [EOL] [EOL] def sets_player_id ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] g . current_player_id = get_jwt_identity ( ) [EOL] f ( * args , ** kwargs ) [EOL] return wrapper [EOL] [EOL] [EOL] def returns_json ( f ) : [EOL] @ wraps ( f ) def wrapper ( * args , ** kwargs ) : [EOL] try : [EOL] return build_response ( SUCCESS , f ( * args , ** kwargs ) ) [EOL] except ApplicationError as ae : [EOL] return build_response ( FAIL , str ( ae ) ) [EOL] except Exception as e : [EOL] if current_app . config [ [string] ] == [string] : [EOL] return build_response ( ERROR , str ( e ) ) [EOL] else : [EOL] raise e [EOL] return wrapper [EOL] [EOL] [EOL] from aura . blueprints . auth_blueprint import auth [EOL] [EOL] [EOL] def register_before ( app ) : [EOL] @ app . before_request def get_arguments ( ) : [EOL] if request . method == [string] : [EOL] try : [EOL] data = request . get_json ( ) [EOL] except TypeError : [EOL] data = { } [EOL] g . data = data [EOL] [EOL] [EOL] def register_blueprints ( app ) : [EOL] app . register_blueprint ( auth ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import flask [EOL] from schema import Schema [EOL] from flask import Blueprint , g [EOL] from flask_jwt_extended import ( jwt_refresh_token_required , fresh_jwt_required , create_access_token , create_refresh_token ) [EOL] from aura . services . user_service import create_user , retrieve_user , update_password [EOL] from aura . blueprints import validate , sets_player_id , returns_json [EOL] [EOL] auth = Blueprint ( [string] , __name__ ) [EOL] [EOL] [EOL] @ auth . route ( [string] , methods = [ [string] ] ) @ returns_json def route_create_user ( ) : [EOL] d = validate ( Schema ( { [string] : str , [string] : str } , ignore_extra_keys = True ) , g . data ) [EOL] user = create_user ( d [ [string] ] , d [ [string] ] ) [EOL] return { [string] : create_access_token ( identity = user . player_id ) , [string] : create_refresh_token ( identity = user . player_id ) } [EOL] [EOL] [EOL] @ auth . route ( [string] , methods = [ [string] ] ) @ returns_json def route_login ( ) : [EOL] d = validate ( Schema ( { [string] : str , [string] : str } , ignore_extra_keys = True ) , g . data ) [EOL] user = retrieve_user ( d [ [string] ] , d [ [string] ] ) [EOL] return { [string] : create_access_token ( identity = user . player_id ) , [string] : create_refresh_token ( identity = user . player_id ) , [string] : user . username } [EOL] [EOL] [EOL] @ auth . route ( [string] , methods = [ [string] ] ) @ returns_json @ sets_player_id @ jwt_refresh_token_required def refresh ( ) : [EOL] return { [string] : create_access_token ( identity = g . current_player . id ) , [string] : create_refresh_token ( identity = g . current_player . id ) } [EOL] [EOL] [EOL] @ auth . route ( [string] , methods = [ [string] ] ) @ returns_json def fresh_login ( ) : [EOL] d = validate ( Schema ( { [string] : str , [string] : str } , ignore_extra_keys = True ) , g . data ) [EOL] user = retrieve_user ( d [ [string] ] , d [ [string] ] ) [EOL] return { [string] : create_access_token ( identity = user . player_id , fresh = True ) } [EOL] [EOL] [EOL] @ auth . route ( [string] , methods = [ [string] ] ) @ returns_json @ sets_player_id @ fresh_jwt_required def change_password ( ) : [EOL] d = validate ( Schema ( { [string] : str } , ignore_extra_keys = True ) , g . data ) [EOL] update_password ( d [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0