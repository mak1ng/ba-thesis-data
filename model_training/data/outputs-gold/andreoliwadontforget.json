[docstring] [EOL]	0 0
[comment] [EOL] from typing import Tuple , Dict , Union [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import datetime [EOL] [EOL] from dontforget . repetition import next_dates , right_now [EOL] [EOL] [EOL] def test_simple_patterns_with_every_each ( ) : [EOL] [docstring] [EOL] base_date = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] mapping = { datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) : ( [string] , [string] , [string] , [string] , [string] ) , } [EOL] for expected_date , natural_patterns in mapping . items ( ) : [EOL] for natural_pattern in natural_patterns : [EOL] assert next_dates ( natural_pattern , base_date ) == expected_date [EOL] [EOL] [EOL] def test_invalid_repetition ( ) : [EOL] [docstring] [EOL] assert next_dates ( None , right_now ( ) ) is None [EOL] assert next_dates ( [string] , right_now ( ) ) is None [EOL] [EOL] [EOL] def test_invalid_count ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] ) [EOL] assert next_dates ( [string] , reference , [number] ) == datetime ( [number] , [number] , [number] ) [EOL] assert next_dates ( [string] , reference , - [number] ) == datetime ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_daily ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] ) [EOL] assert next_dates ( [string] , reference ) == datetime ( [number] , [number] , [number] ) [EOL] [EOL] reference = datetime ( [number] , [number] , [number] ) [EOL] assert next_dates ( [string] , reference ) == datetime ( [number] , [number] , [number] ) [EOL] [EOL] assert next_dates ( [string] , reference , [number] ) == datetime ( [number] , [number] , [number] ) [EOL] assert next_dates ( [string] , reference , [number] ) == [ datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ] [EOL] [EOL] assert next_dates ( [string] , datetime ( [number] , [number] , [number] ) , [number] ) == [ datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) , ] [EOL] [EOL] [EOL] def test_weekly ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] ) [EOL] for pattern in ( [string] , [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference , [number] ) == [ datetime ( [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] ) ] [EOL] [EOL] for pattern in ( [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference ) == datetime ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_monthly ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] for pattern in ( [string] , [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference , [number] ) == [ datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ] [EOL] [EOL] for pattern in ( [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference ) == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] for pattern in ( [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference ) == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] for pattern in ( [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference ) == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_yearly ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] for pattern in ( [string] , [string] , [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference ) == datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] [EOL] def test_hourly ( ) : [EOL] [docstring] [EOL] reference = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] for pattern in ( [string] , [string] , [string] ) : [EOL] assert next_dates ( pattern , reference , [number] ) == [ datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] , [number] , [number] ) , datetime ( [number] , [number] , [number] , [number] , [number] ) , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , Tuple , Dict , Optional , Any , List [EOL] import typing [EOL] import datetime [EOL] import arrow [EOL] [docstring] [EOL] import datetime [EOL] import re [EOL] from typing import Optional [EOL] [EOL] import arrow [EOL] from dateutil . relativedelta import relativedelta [EOL] [EOL] from dontforget . settings import LOCAL_TIMEZONE [EOL] [EOL] [EOL] class Unit ( object ) : [EOL] [docstring] [EOL] [EOL] DAY = [string] [EOL] WEEK = [string] [EOL] MONTH = [string] [EOL] YEAR = [string] [EOL] HOUR = [string] [EOL] MINUTE = [string] [EOL] [EOL] [EOL] REGEX_EVERY = re . compile ( [string] , re . IGNORECASE ) [EOL] FREQUENCY_MAPPING = { [string] : ( [number] , Unit . DAY ) , [string] : ( [number] , Unit . WEEK ) , [string] : ( [number] , Unit . WEEK ) , [string] : ( [number] , Unit . MONTH ) , [string] : ( [number] , Unit . MONTH ) , [string] : ( [number] , Unit . MONTH ) , [string] : ( [number] , Unit . MONTH ) , [string] : ( [number] , Unit . YEAR ) , [string] : ( [number] , Unit . HOUR ) , } [EOL] [EOL] [comment] [EOL] ABBREVIATIONS = { [string] : Unit . DAY , [string] : Unit . MONTH , [string] : Unit . YEAR , [string] : Unit . WEEK , [string] : Unit . HOUR , [string] : Unit . MINUTE , [string] : Unit . MINUTE , [string] : Unit . MINUTE , } [EOL] [EOL] [EOL] def right_now ( date = None ) : [EOL] [docstring] [EOL] if date : [EOL] return date if isinstance ( date , arrow . Arrow ) else arrow . get ( date ) [EOL] return arrow . utcnow ( ) [EOL] [EOL] [EOL] def local_right_now ( date = None ) : [EOL] [docstring] [EOL] return right_now ( date ) . to ( LOCAL_TIMEZONE ) [EOL] [EOL] [EOL] def normalise_unit ( value ) : [EOL] [docstring] [EOL] clean = value . lower ( ) . rstrip ( [string] ) [EOL] return ABBREVIATIONS . get ( clean , clean ) + [string] [EOL] [EOL] [EOL] def every ( reference_date , count , number , unit ) : [EOL] [docstring] [EOL] if not count or int ( count ) <= [number] : [EOL] count = [number] [EOL] if not number or int ( number ) <= [number] : [EOL] number = [number] [EOL] [EOL] temp_date = reference_date [EOL] results = [ ] [EOL] for _index in range ( count ) : [EOL] try : [EOL] temp_date = temp_date + relativedelta ( ** { normalise_unit ( unit ) : int ( number ) } ) [EOL] except TypeError : [EOL] return None [EOL] results . append ( temp_date ) [EOL] return results if len ( results ) > [number] else results [ [number] ] [EOL] [EOL] [EOL] def next_dates ( natural_language_repetition , reference_date = None , count = [number] ) : [EOL] [docstring] [EOL] if not natural_language_repetition : [EOL] return None [EOL] if not reference_date : [EOL] reference_date = right_now ( ) . datetime [EOL] [EOL] mapping = FREQUENCY_MAPPING . get ( natural_language_repetition . lower ( ) ) [EOL] if mapping : [EOL] return every ( reference_date , count , mapping [ [number] ] , mapping [ [number] ] ) [EOL] [EOL] match = REGEX_EVERY . match ( natural_language_repetition ) [EOL] if match : [EOL] match_dict = match . groupdict ( ) [EOL] match_dict . pop ( [string] ) [EOL] return every ( reference_date , count , ** match_dict ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $arrow.Arrow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $arrow.Arrow$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Tuple[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Union [EOL] import builtins [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import date , timedelta [EOL] from pprint import pprint [EOL] from typing import Union [EOL] [EOL] import arrow [EOL] from tapioca_toggl import Toggl [EOL] [EOL] from dontforget . default_pipes . todoist import Todoist [EOL] from dontforget . settings import ( HOME_HOURS , HOME_MINUTES_BEFORE , HOME_TODOIST_PROJECT , HOME_TODOIST_TASK , HOME_TOGGL_CLIENTS , HOME_TOGGL_NOT_WORK_DESCRIPTIONS , HOME_TOGGL_NOT_WORK_TAGS , TOGGL_API_TOKEN , ) [EOL] [EOL] [EOL] def go_home ( desired_date = None ) : [EOL] [docstring] [EOL] api = Toggl ( access_token = TOGGL_API_TOKEN ) [EOL] my_data = api . me_with_related_data ( ) . get ( ) . data [EOL] timezone = my_data . timezone ( ) . data [EOL] [EOL] final_date = arrow . get ( desired_date ) if desired_date else arrow . now ( timezone ) [EOL] day_start = final_date . to ( timezone ) . replace ( hour = [number] , minute = [number] , second = [number] , microsecond = [number] ) [EOL] day_end = day_start . replace ( hour = [number] , minute = [number] , second = [number] ) [EOL] [EOL] entries = api . time_entries ( ) . get ( params = { [string] : day_start , [string] : day_end } ) [EOL] [EOL] [comment] [EOL] toggl_clients = HOME_TOGGL_CLIENTS [EOL] print ( f" [string] { [string] . join ( toggl_clients ) }" ) [EOL] client_ids = [ client [ [string] ] for client in my_data . clients ( ) . data if client [ [string] ] in toggl_clients ] [EOL] client_projects = [ project [ [string] ] for project in my_data . projects ( ) . data if project [ [string] ] in client_ids ] [EOL] [EOL] start_dates = [ entry [ [string] ] for entry in entries ( ) . data if entry [ [string] ] in client_projects ] [EOL] if not start_dates : [EOL] print ( f" [string] { [string] . join ( toggl_clients ) } [string] { final_date . date ( ) . isoformat ( ) }" ) [EOL] return [EOL] [EOL] [comment] [EOL] arrived_at = arrow . get ( min ( start_dates ) ) . to ( timezone ) [EOL] print ( f" [string] { arrived_at }" ) [EOL] go_home_at = arrived_at + timedelta ( hours = HOME_HOURS ) - timedelta ( minutes = HOME_MINUTES_BEFORE ) [EOL] [EOL] [comment] [EOL] non_working_durations = [ entry [ [string] ] for entry in entries ( ) . data for tag in HOME_TOGGL_NOT_WORK_TAGS for desc in HOME_TOGGL_NOT_WORK_DESCRIPTIONS if tag in entry . get ( [string] , [ ] ) or desc in entry . get ( [string] , [ ] ) ] [EOL] non_working_time = timedelta ( seconds = sum ( non_working_durations ) ) [EOL] print ( f" [string] { non_working_time }" ) [EOL] go_home_at += non_working_time [EOL] print ( f" [string] { go_home_at }" ) [EOL] [EOL] todoist = Todoist . singleton ( ) [EOL] project_id = todoist . fetch_first ( [string] , [string] , { [string] : HOME_TODOIST_PROJECT } ) [EOL] if not project_id : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] task_description = HOME_TODOIST_TASK [EOL] date_string = f"{ go_home_at . format ( [string] ) } [string] { go_home_at . format ( [string] ) }" [EOL] [EOL] existing_task = todoist . fetch_first ( [string] , None , { [string] : project_id , [string] : task_description } ) [EOL] if not existing_task : [EOL] [comment] [EOL] item = todoist . api . items . add ( task_description , project_id , date_string = date_string , priority = [number] , auto_reminder = True ) [EOL] todoist . api . commit ( ) [EOL] print ( [string] ) [EOL] else : [EOL] [comment] [EOL] item = todoist . api . items . get_by_id ( existing_task [ [string] ] ) [EOL] item . update ( content = task_description , date_string = date_string , priority = [number] ) [EOL] todoist . api . commit ( ) [EOL] print ( [string] ) [EOL] pprint ( item ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Type , Dict , Iterator , Optional , Set , Any , List , Union [EOL] import dontforget [EOL] import builtins [EOL] import pathlib [EOL] import logging [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] import abc [EOL] import itertools [EOL] import json [EOL] import logging [EOL] import os [EOL] from enum import Enum [EOL] from pathlib import Path [EOL] from pprint import pprint [EOL] from typing import Dict , Iterator , List , Optional , Set , Tuple , Type , Union [EOL] [EOL] import click [EOL] import toml [EOL] from autorepr import autorepr [EOL] from jinja2 import StrictUndefined , Template [EOL] from memoized_property import memoized_property [EOL] [EOL] from dontforget . app import load_plugins [EOL] from dontforget . constants import DEFAULT_PIPES_DIR_NAME , UNIQUE_SEPARATOR [EOL] from dontforget . generic import ( SingletonMixin , classproperty , find_partial_keys , flatten , get_subclasses , pretty_plugin_name , unflatten , ) [EOL] from dontforget . settings import LOG_LEVEL , USER_PIPES_DIR [EOL] from dontforget . typedefs import JsonDict [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] LOGGER . setLevel ( LOG_LEVEL ) [EOL] [EOL] [EOL] class Pipe : [EOL] [docstring] [EOL] [EOL] class Key ( Enum ) : [EOL] [docstring] [EOL] [EOL] PIPES = [string] [EOL] SOURCE = [string] [EOL] TARGET = [string] [EOL] CLASS = [string] [EOL] [EOL] __repr__ = autorepr ( [ [string] , [string] ] ) [EOL] [EOL] def __init__ ( self , toml_file ) : [EOL] self . name = toml_file . stem [EOL] self . path = toml_file . resolve ( ) [EOL] self . source_class_name = [string] [EOL] self . target_class_name = [string] [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [docstring] [EOL] return self . name . casefold ( ) < other . name . casefold ( ) [EOL] [EOL] @ memoized_property def original_dict ( self ) : [EOL] [docstring] [EOL] [EOL] return toml . loads ( self . path . read_text ( ) ) [EOL] [EOL] @ memoized_property def merged_dict ( self ) : [EOL] [docstring] [EOL] return self . merge_parent_pipes ( ) [EOL] [EOL] def echo ( self ) : [EOL] [docstring] [EOL] click . secho ( f" [string] { self . name } [string] { self . path }" , fg = [string] ) [EOL] self . echo_dict ( ) [EOL] [EOL] def echo_dict ( self ) : [EOL] [docstring] [EOL] pprint ( self . merged_dict ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] def merge_parent_pipes ( self ) : [EOL] [docstring] [EOL] original_without_pipes = self . original_dict . copy ( ) [EOL] parent_pipes = original_without_pipes . pop ( self . Key . PIPES . value , [ ] ) [EOL] if not parent_pipes : [EOL] return original_without_pipes [EOL] [EOL] rv = { } [EOL] for name in parent_pipes : [EOL] parent_pipe = PIPE_CONFIG . get_pipe ( name ) [EOL] rv . update ( flatten ( parent_pipe . original_dict , separator = UNIQUE_SEPARATOR ) ) [EOL] [EOL] rv . update ( flatten ( original_without_pipes , separator = UNIQUE_SEPARATOR ) ) [EOL] [EOL] return unflatten ( rv , separator = UNIQUE_SEPARATOR ) [EOL] [EOL] def validate ( self ) : [EOL] [docstring] [EOL] self . source_class_name = self . merged_dict . get ( self . Key . SOURCE . value , { } ) . get ( self . Key . CLASS . value , [string] ) [EOL] if not self . source_class_name : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] self . target_class_name = self . merged_dict . get ( self . Key . TARGET . value , { } ) . get ( self . Key . CLASS . value , [string] ) [EOL] if not self . target_class_name : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] self . validate ( ) [EOL] source_class = BaseSource . get_class_from ( self . source_class_name ) [EOL] target_class = BaseTarget . get_class_from ( self . target_class_name ) [EOL] click . secho ( f" [string] { self . name } [string] { pretty_plugin_name ( source_class ) } [string] { pretty_plugin_name ( target_class ) } [string] " , fg = [string] , ) [EOL] [EOL] source_dict = self . merged_dict . get ( self . Key . SOURCE . value ) . copy ( ) [EOL] LOGGER . debug ( [string] , source_dict ) [EOL] source_dict . pop ( self . Key . CLASS . value ) [EOL] source_template = json . dumps ( source_dict ) [EOL] expanded_source_dict = json . loads ( Template ( source_template , undefined = StrictUndefined ) . render ( env = os . environ ) ) [EOL] LOGGER . debug ( [string] , expanded_source_dict ) [EOL] [EOL] target_dict = self . merged_dict . get ( self . Key . TARGET . value ) . copy ( ) [EOL] target_dict . pop ( self . Key . CLASS . value ) [EOL] target_template = json . dumps ( target_dict ) [EOL] [EOL] has_items = False [EOL] source_instance = source_class ( ) [EOL] for item_dict in source_instance . pull ( expanded_source_dict ) : [EOL] LOGGER . debug ( [string] , item_dict ) [EOL] LOGGER . debug ( [string] , target_template ) [EOL] [EOL] rendered_item = Template ( target_template ) . render ( { [string] : os . environ , source_class . name : item_dict } ) [EOL] LOGGER . debug ( [string] , rendered_item ) [EOL] expanded_item_dict = json . loads ( rendered_item ) [EOL] LOGGER . debug ( [string] , expanded_item_dict ) [EOL] click . echo ( [string] , nl = False ) [EOL] target = target_class ( ) [EOL] success = target . push ( expanded_item_dict ) [EOL] if success : [EOL] click . secho ( [string] , fg = [string] ) [EOL] source_instance . on_success ( ) [EOL] else : [EOL] click . secho ( f" [string] { target . validation_error }" , fg = [string] ) [EOL] source_instance . on_failure ( ) [EOL] has_items = True [EOL] [EOL] if not has_items : [EOL] click . echo ( [string] ) [EOL] [EOL] [EOL] class PipeType ( Enum ) : [EOL] [docstring] [EOL] [EOL] ALL = [string] [EOL] DEFAULT = [string] [EOL] USER = [string] [EOL] [EOL] [EOL] class PipeConfig ( SingletonMixin ) : [EOL] [docstring] [EOL] [EOL] @ memoized_property def default_pipes ( self ) : [EOL] [docstring] [EOL] return self . _find_pipes_in ( [ Path ( __file__ ) . parent / DEFAULT_PIPES_DIR_NAME ] ) [EOL] [EOL] @ memoized_property def user_pipes ( self ) : [EOL] [docstring] [EOL] return self . _find_pipes_in ( USER_PIPES_DIR ) [EOL] [EOL] @ memoized_property def pipes_by_name ( self ) : [EOL] [docstring] [EOL] return { pipe . name . casefold ( ) : pipe for pipe in itertools . chain ( self . default_pipes , self . user_pipes ) } [EOL] [EOL] @ memoized_property def sources ( self ) : [EOL] [docstring] [EOL] return { source_class . name : source_class for source_class in get_subclasses ( BaseSource ) } [EOL] [EOL] @ memoized_property def targets ( self ) : [EOL] [docstring] [EOL] return { target_class . name : target_class for target_class in get_subclasses ( BaseTarget ) } [EOL] [EOL] @ staticmethod def _find_pipes_in ( directories ) : [EOL] [docstring] [EOL] valid_dirs = [ ] [EOL] invalid_dirs = [ ] [EOL] for my_pipe_dir in directories : [EOL] path = Path ( my_pipe_dir ) . expanduser ( ) . resolve ( ) [EOL] if not path . exists ( ) : [EOL] invalid_dirs . append ( path ) [EOL] else : [EOL] valid_dirs . append ( path ) [EOL] [EOL] if invalid_dirs : [EOL] invalid_dirs_str = [ str ( path ) for path in invalid_dirs ] [EOL] raise RuntimeError ( f" [string] { [string] . join ( invalid_dirs_str ) }" ) [EOL] [EOL] unique_toml_files = set ( ) [EOL] for valid_dir in valid_dirs : [EOL] unique_toml_files . update ( list ( valid_dir . glob ( [string] ) ) ) [EOL] [EOL] return { Pipe ( toml_file ) for toml_file in unique_toml_files } [EOL] [EOL] def echo ( self , header , default ) : [EOL] [docstring] [EOL] click . secho ( f"{ header } [string] " , fg = [string] ) [EOL] for pipe in self . default_pipes if default else self . user_pipes : [EOL] pipe . echo ( ) [EOL] return self [EOL] [EOL] def get_pipe ( self , exact_name ) : [EOL] [docstring] [EOL] return self . pipes_by_name . get ( exact_name . casefold ( ) , None ) [EOL] [EOL] def get_pipes ( self , partial_name ) : [EOL] [docstring] [EOL] return find_partial_keys ( self . pipes_by_name , partial_name , not_found = [string] ) [EOL] [EOL] [EOL] PIPE_CONFIG = PipeConfig . singleton ( ) [EOL] [EOL] [EOL] class BaseSource ( metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ classproperty def name ( cls ) : [EOL] [docstring] [EOL] return cls . __name__ . replace ( [string] , [string] ) . casefold ( ) [comment] [EOL] [EOL] @ classmethod def get_class_from ( cls , class_name ) : [EOL] [docstring] [EOL] found = find_partial_keys ( PIPE_CONFIG . sources , class_name , not_found = [string] , multiple = [string] , ) [EOL] return found [ [number] ] [EOL] [EOL] @ abc . abstractmethod def pull ( self , connection_info ) : [EOL] [docstring] [EOL] [EOL] def on_success ( self ) : [EOL] [docstring] [EOL] [EOL] def on_failure ( self ) : [EOL] [docstring] [EOL] [EOL] [EOL] class BaseTarget ( metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [comment] [EOL] self . valid_data = { } [EOL] [EOL] [comment] [EOL] self . serialised_data = { } [EOL] [EOL] self . validation_error = None [EOL] [EOL] @ classproperty def name ( cls ) : [EOL] [docstring] [EOL] return cls . __name__ . replace ( [string] , [string] ) . casefold ( ) [comment] [EOL] [EOL] @ classmethod def get_class_from ( cls , class_name ) : [EOL] [docstring] [EOL] found = find_partial_keys ( PIPE_CONFIG . targets , class_name , not_found = [string] , multiple = [string] , ) [EOL] return found [ [number] ] [EOL] [EOL] @ abc . abstractmethod def push ( self , raw_data ) : [EOL] [docstring] [EOL] [EOL] @ property def unique_key ( self ) : [EOL] [docstring] [EOL] return f" [string] { self . valid_data [ [string] ] } [string] " [EOL] [EOL] [EOL] @ click . group ( ) def pipe ( ) : [EOL] [docstring] [EOL] load_plugins ( ) [EOL] [EOL] [EOL] @ pipe . command ( ) @ click . option ( [string] , [string] , [string] , flag_value = PipeType . ALL , default = True , help = [string] ) @ click . option ( [string] , [string] , [string] , flag_value = PipeType . DEFAULT , help = [string] ) @ click . option ( [string] , [string] , [string] , flag_value = PipeType . USER , help = [string] ) def ls ( which ) : [EOL] [docstring] [EOL] if which == PipeType . DEFAULT or which == PipeType . ALL : [EOL] PIPE_CONFIG . echo ( [string] , True ) [EOL] if which == PipeType . USER or which == PipeType . ALL : [EOL] PIPE_CONFIG . echo ( [string] , False ) [EOL] [EOL] [EOL] @ pipe . command ( ) @ click . argument ( [string] , nargs = - [number] ) def run ( partial_names ) : [EOL] [docstring] [EOL] chosen_pipes = [ ] [EOL] for partial_name in partial_names : [EOL] chosen_pipes . extend ( PIPE_CONFIG . get_pipes ( partial_name ) ) [EOL] if not chosen_pipes : [EOL] chosen_pipes = PIPE_CONFIG . user_pipes [EOL] for chosen_pipe in sorted ( chosen_pipes ) : [EOL] chosen_pipe . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Type[src.dontforget.pipes.Pipe]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.dontforget.pipes.BaseSource]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.dontforget.pipes.BaseTarget]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.dontforget.pipes.BaseSource]$ 0 0 0 0 0 0 $typing.Type[src.dontforget.pipes.BaseTarget]$ 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 $builtins.str$ 0 0 0 $src.dontforget.pipes.BaseSource$ 0 $typing.Type[src.dontforget.pipes.BaseSource]$ 0 0 0 0 0 0 $src.dontforget.pipes.BaseSource$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[src.dontforget.pipes.BaseSource]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.pipes.BaseTarget$ 0 $typing.Type[src.dontforget.pipes.BaseTarget]$ 0 0 0 $builtins.bool$ 0 $src.dontforget.pipes.BaseTarget$ 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.pipes.BaseSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.pipes.BaseTarget$ 0 0 0 0 0 0 0 0 0 $src.dontforget.pipes.BaseSource$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[Pipe]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[Pipe]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,Pipe]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type["BaseSource"]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type["BaseTarget"]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[Pipe]$ 0 $typing.List[typing.Union[builtins.str,pathlib.Path]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,pathlib.Path]]$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $pathlib.Path$ 0 0 $pathlib.Path$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $"PipeConfig"$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Pipe]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[Pipe]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type["BaseSource"]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dontforget.typedefs.JsonDict]$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type["BaseTarget"]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import MutableMapping , Any , Type [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , MutableMapping [EOL] [EOL] JsonDict = MutableMapping [ str , Any ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] APP_NAME = [string] [EOL] CONFIG_YAML = [string] [EOL] [EOL] DEVELOPMENT = [string] [EOL] [EOL] START_MODE_FLASK = [string] [EOL] START_MODE_DOCKER = [string] [EOL] [EOL] FLASK_COMMAND = [string] [EOL] DOCKER_COMMAND = [string] [EOL] [EOL] DEFAULT_PIPES_DIR_NAME = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] UNIQUE_SEPARATOR = [string] [EOL] [EOL] [comment] [EOL] DELAY = [number] [EOL] MISFIRE_GRACE_TIME = [number] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from environs import Env [EOL] [EOL] env = Env ( ) [EOL] env . read_env ( ) [EOL] [EOL] DEBUG = bool ( env ( [string] , default = False ) ) [EOL] LOG_LEVEL = ( env ( [string] , default = [string] ) or logging . getLevelName ( logging . DEBUG if DEBUG else logging . WARNING ) ) . upper ( ) [EOL] [EOL] LOCAL_TIMEZONE = env ( [string] , default = [string] ) [EOL] [EOL] TOGGL_API_TOKEN = env ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_HOURS = env . int ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_MINUTES_BEFORE = env . int ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_TOGGL_CLIENTS = env . list ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_TOGGL_NOT_WORK_TAGS = env . list ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_TOGGL_NOT_WORK_DESCRIPTIONS = env . list ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_TODOIST_PROJECT = env ( [string] ) [EOL] [EOL] [comment] [EOL] HOME_TODOIST_TASK = env ( [string] ) [EOL] [EOL] [comment] [EOL] USER_PIPES_DIR = env . list ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any , Iterator [EOL] import typing [EOL] import dontforget [EOL] [docstring] [EOL] from typing import Iterator [EOL] [EOL] from redminelib import Redmine [EOL] [EOL] from dontforget . pipes import BaseSource [EOL] from dontforget . typedefs import JsonDict [EOL] [EOL] [EOL] class RedmineSource ( BaseSource ) : [EOL] [docstring] [EOL] [EOL] def pull ( self , connection_info ) : [EOL] [docstring] [EOL] redmine = Redmine ( connection_info [ [string] ] , key = connection_info [ [string] ] , raise_attr_exception = False ) [EOL] project = redmine . project . get ( connection_info [ [string] ] ) [EOL] for item in project . issues . values ( [string] , [string] , [string] , [string] , [string] ) : [EOL] [comment] [EOL] if not item [ [string] ] : [EOL] continue [EOL] [EOL] if [string] not in item : [EOL] item [ [string] ] = None [EOL] if [string] not in item : [EOL] item [ [string] ] = None [EOL] [EOL] [comment] [EOL] if [string] in item : [EOL] item [ [string] ] = item [ [string] ] . replace ( [string] , [string] ) [EOL] [EOL] yield item [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[dontforget.typedefs.JsonDict]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Iterator , Dict , Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import dontforget [EOL] import pendulum [EOL] [docstring] [EOL] from typing import Iterator , Optional [EOL] from urllib . parse import quote_plus [EOL] [EOL] import pendulum [EOL] from imbox import Imbox [EOL] [EOL] from dontforget . pipes import BaseSource [EOL] from dontforget . typedefs import JsonDict [EOL] [EOL] [EOL] class EmailSource ( BaseSource ) : [EOL] [docstring] [EOL] [EOL] imbox = ... [EOL] current_uid = None [EOL] search_url = ... [EOL] search_date_format = ... [EOL] mark_read = False [EOL] archive = False [EOL] archive_folder = ... [EOL] [EOL] def pull ( self , connection_info ) : [EOL] [docstring] [EOL] self . imbox = Imbox ( connection_info [ [string] ] , port = connection_info . get ( [string] , None ) , username = connection_info [ [string] ] , password = connection_info [ [string] ] , ssl = True , ssl_context = None , starttls = False , ) [EOL] self . search_url = connection_info [ [string] ] [EOL] self . search_date_format = connection_info [ [string] ] [EOL] self . mark_read = connection_info . get ( [string] , False ) [EOL] self . archive = connection_info . get ( [string] , False ) [EOL] self . archive_folder = connection_info [ [string] ] [EOL] [EOL] kwargs = { } [EOL] search_from = connection_info . get ( [string] ) [EOL] if search_from : [EOL] kwargs [ [string] ] = search_from [EOL] label = connection_info . get ( [string] ) [EOL] if label : [EOL] kwargs . update ( folder = [string] , label = label ) [EOL] folder = connection_info . get ( [string] ) [EOL] if folder : [EOL] kwargs . update ( folder = folder ) [EOL] messages = self . imbox . messages ( ** kwargs ) [EOL] if not messages : [EOL] return [ ] [EOL] [EOL] for uid , message in messages : [EOL] self . current_uid = uid [EOL] date = pendulum . instance ( message . parsed_date ) . date ( ) [EOL] subject = [string] . join ( message . subject . splitlines ( ) ) [EOL] [EOL] [comment] [EOL] message_from = message . sent_from [ [number] ] . get ( [string] ) if message . sent_from else None [EOL] url = self . build_search_url ( search_from or message_from , date , date . add ( days = [number] ) , subject ) [EOL] [EOL] yield { [string] : search_from or message_from , [string] : uid . decode ( ) , [string] : url , [string] : subject , [string] : message . parsed_date . isoformat ( ) , } [EOL] [EOL] def build_search_url ( self , from_ = None , after = None , before = None , subject = None ) : [EOL] [docstring] [EOL] search_terms = [ ] [EOL] if from_ : [EOL] search_terms . append ( f" [string] { from_ } [string] " ) [EOL] if after : [EOL] search_terms . append ( f" [string] { after . format ( self . search_date_format ) }" ) [EOL] if before : [EOL] search_terms . append ( f" [string] { before . format ( self . search_date_format ) }" ) [EOL] if subject : [EOL] search_terms . append ( f' [string] { subject } [string] ' ) [EOL] [EOL] quoted_terms = quote_plus ( [string] . join ( search_terms ) ) [EOL] return f"{ self . search_url }{ quoted_terms }" [EOL] [EOL] def on_success ( self ) : [EOL] [docstring] [EOL] if not self . current_uid : [EOL] return [EOL] if self . mark_read : [EOL] self . imbox . mark_seen ( self . current_uid ) [EOL] if self . archive : [EOL] self . imbox . move ( self . current_uid , self . archive_folder ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $imbox.Imbox$ 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Iterator[dontforget.typedefs.JsonDict]$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 $builtins.str$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 $builtins.bool$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $pendulum.Date$ 0 0 0 $pendulum.Date$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pendulum.Date$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $pendulum.Date$ 0 0 0 0 0 0 0 0 0 0 0 $pendulum.Date$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $pendulum.Date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Dict , Optional , Any , List [EOL] import dontforget [EOL] import datetime [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] import logging [EOL] from datetime import datetime [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] import click [EOL] import jmespath [EOL] from deprecated import deprecated [EOL] from marshmallow import Schema , ValidationError , fields [EOL] from todoist import TodoistAPI [EOL] [EOL] from dontforget . generic import SingletonMixin [EOL] from dontforget . pipes import BaseTarget [EOL] from dontforget . settings import LOG_LEVEL [EOL] from dontforget . typedefs import JsonDict [EOL] [EOL] PROJECTS_NAME_ID_JMEX = jmespath . compile ( [string] ) [EOL] DictProjectId = Dict [ str , int ] [EOL] [EOL] LOGGER = logging . getLogger ( __name__ ) [EOL] LOGGER . setLevel ( LOG_LEVEL ) [EOL] [EOL] [EOL] class Todoist ( SingletonMixin ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_token ) : [EOL] super ( ) . __init__ ( ) [EOL] self . api = TodoistAPI ( api_token ) [EOL] self . data = { } [EOL] self . projects = { } [EOL] self . _allow_creation = False [EOL] [EOL] def smart_sync ( self ) : [EOL] [docstring] [EOL] if not self . data . get ( [string] , { } ) : [EOL] [comment] [EOL] self . api . reset_state ( ) [EOL] [EOL] partial_data = { } [EOL] for attempt in range ( [number] ) : [EOL] [comment] [EOL] [comment] [EOL] partial_data = self . api . sync ( ) [EOL] if isinstance ( partial_data , dict ) : [EOL] break [EOL] LOGGER . warning ( f" [string] { attempt + [number] } [string] { partial_data !r}" ) [EOL] [EOL] self . _merge_new_data ( partial_data ) [EOL] [EOL] self . projects = dict ( PROJECTS_NAME_ID_JMEX . search ( self . data ) ) [EOL] [EOL] def _merge_new_data ( self , partial_data ) : [EOL] if not self . data : [EOL] self . data = partial_data [EOL] return [EOL] [EOL] for key , value in partial_data . items ( ) : [EOL] if isinstance ( value , list ) : [EOL] if key not in self . data : [EOL] self . data [ key ] = [ ] [EOL] self . data [ key ] . extend ( value ) [EOL] elif isinstance ( value , dict ) : [EOL] if key not in self . data : [EOL] self . data [ key ] = { } [EOL] self . data [ key ] . update ( value ) [EOL] else : [EOL] self . data [ key ] = value [EOL] [EOL] def keys ( self ) : [EOL] [docstring] [EOL] return sorted ( self . data . keys ( ) ) [EOL] [EOL] @ deprecated ( reason = [string] ) def fetch ( self , element_name , return_field = None , filters = None , index = None , matching_function = all , ) : [EOL] [docstring] [EOL] if not filters : [EOL] values_to_list = { } [EOL] else : [EOL] values_to_list = { key : [ value ] if not isinstance ( value , list ) else value for key , value in filters . items ( ) } [EOL] found_elements = [ element [ return_field ] if return_field else element for element in self . data [ element_name ] if not filters or matching_function ( element [ key ] in value for key , value in values_to_list . items ( ) ) ] [EOL] if index is not None : [EOL] return found_elements [ index ] if found_elements else None [EOL] return found_elements [EOL] [EOL] @ deprecated ( reason = [string] ) def fetch_first ( self , element_name , return_field = None , filters = None ) : [EOL] [docstring] [EOL] return self . fetch ( element_name , return_field , filters , [number] ) [EOL] [EOL] def find_project_id ( self , exact_name ) : [EOL] [docstring] [EOL] return self . projects . get ( exact_name , None ) [EOL] [EOL] def find_projects ( self , partial_name = [string] ) : [EOL] [docstring] [EOL] return { name : project_id for name , project_id in self . projects . items ( ) if partial_name . casefold ( ) in name . casefold ( ) } [EOL] [EOL] def find_project_items ( self , exact_project_name , extra_jmes_expression = [string] ) : [EOL] [docstring] [EOL] project_id = self . find_project_id ( exact_project_name ) [EOL] if not project_id : [EOL] return [ ] [EOL] return jmespath . search ( f" [string] { project_id } [string] { extra_jmes_expression }" , self . data ) [EOL] [EOL] def find_items_by_content ( self , exact_project_name , partial_content ) : [EOL] [docstring] [EOL] clean_content = partial_content . casefold ( ) [EOL] return [ item for item in self . find_project_items ( exact_project_name ) if clean_content in item . get ( [string] , [string] ) . casefold ( ) ] [EOL] [EOL] [EOL] class TodoistSchema ( Schema ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] id = fields . String ( required = True ) [EOL] url = fields . Url ( required = True ) [EOL] content = fields . String ( required = True ) [EOL] project = fields . String ( missing = [string] ) [EOL] project_id = fields . Integer ( ) [EOL] comment = fields . String ( ) [EOL] date_string = fields . Date ( ) [EOL] priority = fields . Integer ( ) [EOL] api_token = fields . String ( ) [EOL] [EOL] [EOL] class TodoistTarget ( BaseTarget ) : [EOL] [docstring] [EOL] [EOL] todoist = ... [EOL] [EOL] def push ( self , raw_data ) : [EOL] [docstring] [EOL] schema = TodoistSchema ( ) [EOL] try : [EOL] self . valid_data = schema . load ( raw_data ) [EOL] self . serialised_data = schema . dump ( self . valid_data ) [EOL] except ValidationError as err : [EOL] self . validation_error = str ( err ) [EOL] return False [EOL] [EOL] click . echo ( f"{ self . serialised_data } [string] " , nl = False ) [EOL] [EOL] self . todoist = Todoist . singleton ( raw_data [ [string] ] ) [EOL] self . todoist . smart_sync ( ) [EOL] self . _set_project_id ( ) [EOL] project = self . serialised_data [ [string] ] [EOL] if self . todoist . find_items_by_content ( project , self . unique_key ) : [EOL] self . validation_error = f" [string] { project }" [EOL] return False [EOL] [EOL] self . _add_task ( ) [EOL] return True [EOL] [EOL] def _set_project_id ( self ) : [EOL] [docstring] [EOL] project_id = self . todoist . find_project_id ( self . serialised_data [ [string] ] ) [EOL] if project_id : [EOL] self . serialised_data [ [string] ] = project_id [EOL] [EOL] def _add_task ( self ) : [EOL] [docstring] [EOL] content = self . serialised_data . pop ( [string] , [string] ) [EOL] url = self . serialised_data . pop ( [string] , [string] ) [EOL] self . todoist . api . add_item ( f" [string] { content } [string] { self . unique_key } [string] { url } [string] " , ** self . serialised_data ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Todoist$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 $src.dontforget.default_pipes.todoist.TodoistSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.default_pipes.todoist.TodoistSchema$ 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 $src.dontforget.default_pipes.todoist.TodoistSchema$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.default_pipes.todoist.Todoist$ 0 0 0 0 0 $dontforget.typedefs.JsonDict$ 0 0 0 0 0 0 0 $src.dontforget.default_pipes.todoist.Todoist$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $src.dontforget.default_pipes.todoist.Todoist$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0