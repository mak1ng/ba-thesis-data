[comment] [EOL] [EOL] from setuptools import setup [EOL] [EOL] with open ( [string] ) as f : [EOL] readme = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = [string] , description = [string] , long_description = readme , long_description_content_type = [string] , author = [string] , author_email = [string] , maintainer = [string] , maintainer_email = [string] , url = [string] , include_package_data = True , license = [string] , entry_points = { [string] : [ [string] ] } , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] class AppException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class FlaskRequestException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class Flask400Exception ( FlaskRequestException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class Flask500Exception ( FlaskRequestException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class DbApiException ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class NoRecordsException ( DbApiException ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] class TooManyRecordsException ( DbApiException ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] VERSION = ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] def get_version ( ) : [EOL] return [string] . join ( [ str ( v ) for v in VERSION if v is not None ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Dict , Type , Any [EOL] import typing [EOL] import builtins [EOL] import tikki [EOL] [docstring] [EOL] import json [EOL] from typing import Any , Dict [EOL] [EOL] import sqlalchemy as sa [EOL] import sqlalchemy . orm as sao [EOL] from sqlalchemy . ext . declarative import declarative_base [EOL] from sqlalchemy_utils import JSONType , UUIDType [EOL] [EOL] [EOL] class TikkiBase ( object ) : [EOL] [docstring] [EOL] @ property def json_dict ( self ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return json . dumps ( self . json_dict ) [EOL] [EOL] [EOL] Base = declarative_base ( cls = TikkiBase ) [comment] [EOL] [EOL] [EOL] class Category ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , } [EOL] [EOL] [EOL] class UserType ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , } [EOL] [EOL] [EOL] class RecordType ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] schema = sa . Column ( JSONType , nullable = False ) [EOL] category_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , [string] : self . schema , [string] : self . category_id , } [EOL] [EOL] [EOL] class User ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( UUIDType , primary_key = True ) [EOL] username = sa . Column ( sa . String , nullable = False , unique = True ) [EOL] type_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] created_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] updated_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] payload = sa . Column ( JSONType , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : str ( self . id ) , [string] : self . type_id , [string] : self . username , [string] : self . created_at . isoformat ( ) , [string] : self . updated_at . isoformat ( ) , [string] : self . payload , } [EOL] [EOL] [EOL] class Record ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( UUIDType , primary_key = True ) [EOL] created_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] updated_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] user_id = sa . Column ( UUIDType , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] created_user_id = sa . Column ( UUIDType , nullable = False ) [EOL] event_id = sa . Column ( UUIDType , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] parent_record_id = sa . Column ( UUIDType , nullable = True ) [EOL] type_id = sa . Column ( sa . Integer , nullable = False , default = [number] ) [EOL] validated_user_id = sa . Column ( UUIDType , nullable = True ) [EOL] validated_at = sa . Column ( sa . DateTime , nullable = True ) [EOL] payload = sa . Column ( JSONType , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] val = { [string] : str ( self . id ) , [string] : self . created_at . isoformat ( ) , [string] : self . updated_at . isoformat ( ) , [string] : str ( self . user_id ) , [string] : str ( self . created_user_id ) , [string] : self . type_id , [string] : self . payload , } [EOL] if self . event_id is not None : [EOL] val [ [string] ] = self . event_id [EOL] if self . validated_at : [EOL] val [ [string] ] = self . validated_at . isoformat ( ) [EOL] if self . validated_user_id : [EOL] val [ [string] ] = self . validated_user_id [EOL] if self . parent_record_id : [EOL] val [ [string] ] = self . parent_record_id [EOL] return val [EOL] [EOL] [EOL] class Event ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( UUIDType , primary_key = True ) [EOL] organization_id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] description = sa . Column ( sa . String , nullable = False ) [EOL] event_at = sa . Column ( sa . DateTime , nullable = False ) [EOL] created_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] updated_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] user_id = sa . Column ( UUIDType , sa . ForeignKey ( [string] ) , nullable = True ) [EOL] address = sa . Column ( sa . String , nullable = True ) [EOL] postal_code = sa . Column ( sa . String , nullable = True ) [EOL] longitude = sa . Column ( sa . Numeric , nullable = True ) [EOL] latitude = sa . Column ( sa . Numeric , nullable = True ) [EOL] payload = sa . Column ( JSONType , nullable = False ) [EOL] participants = sao . relationship ( [string] , lazy = [string] ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] val = { [string] : str ( self . id ) , [string] : self . organization_id , [string] : self . event_at . isoformat ( ) , [string] : self . created_at . isoformat ( ) , [string] : self . updated_at . isoformat ( ) , [string] : self . name , [string] : self . description , [string] : self . address , [string] : self . postal_code , [string] : self . longitude , [string] : self . latitude , [string] : str ( self . user_id ) , [string] : list ( ) , [string] : self . payload , } [EOL] for participant in self . participants : [EOL] val [ [string] ] . append ( str ( participant . user_id ) ) [EOL] return val [EOL] [EOL] [EOL] class UserEventLink ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] user_id = sa . Column ( UUIDType , sa . ForeignKey ( [string] ) , primary_key = True ) [EOL] event_id = sa . Column ( UUIDType , sa . ForeignKey ( [string] ) , primary_key = True ) [EOL] created_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] updated_at = sa . Column ( sa . DateTime , nullable = False , default = sa . func . now ( ) ) [EOL] payload = sa . Column ( JSONType , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : str ( self . user_id ) , [string] : str ( self . event_id ) , [string] : self . created_at . isoformat ( ) , [string] : self . updated_at . isoformat ( ) , [string] : self . payload , } [EOL] [EOL] [EOL] class MilitaryStatus ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , } [EOL] [EOL] [EOL] class Gender ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , } [EOL] [EOL] [EOL] class Performance ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] id = sa . Column ( sa . Integer , primary_key = True ) [EOL] name = sa . Column ( sa . String , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . id , [string] : self . name , } [EOL] [EOL] [EOL] class TestLimit ( Base ) : [EOL] [docstring] [EOL] __tablename__ = [string] [EOL] record_type_id = sa . Column ( sa . Integer , primary_key = True ) [EOL] military_status_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , primary_key = True ) [EOL] gender_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , primary_key = True ) [EOL] age_lower_limit = sa . Column ( sa . Integer , nullable = False ) [EOL] age_upper_limit = sa . Column ( sa . Integer , nullable = False ) [EOL] lower_limit = sa . Column ( sa . Float , nullable = False ) [EOL] upper_limit = sa . Column ( sa . Float , nullable = False ) [EOL] performance_id = sa . Column ( sa . Integer , sa . ForeignKey ( [string] ) , nullable = False ) [EOL] score = sa . Column ( sa . Float , nullable = False ) [EOL] [EOL] @ property def json_dict ( self ) : [EOL] return { [string] : self . record_type_id , [string] : self . military_status_id , [string] : self . gender_id , [string] : self . age_lower_limit , [string] : self . age_upper_limit , [string] : self . lower_limit , [string] : self . upper_limit , [string] : self . performance_id , [string] : self . score } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.Category]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Category]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.UserType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.UserType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.RecordType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.RecordType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.RecordType]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.RecordType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.User]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Record]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.UserEventLink]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.UserEventLink]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.UserEventLink]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.UserEventLink]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.UserEventLink]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.MilitaryStatus]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.MilitaryStatus]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.Gender]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Gender]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.Performance]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.Performance]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[tikki.db.tables.TestLimit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , List , Any , Union , Type [EOL] import typing [EOL] import unittest [EOL] import uuid [EOL] [docstring] [EOL] from unittest import TestCase , mock [EOL] from uuid import UUID [EOL] [EOL] from tikki import exceptions , utils [EOL] [EOL] [EOL] class UtilsGetArgsTestCase ( TestCase ) : [EOL] received = { [string] : [number] , [string] : [string] } [EOL] required = { [string] : int } [EOL] defaultable = { [string] : [number] , [string] : [number] } [EOL] optional = { [string] : int , [string] : str } [EOL] constant = { [string] : [number] } [EOL] [EOL] def test_get_args_missing_args ( self ) : [EOL] self . assertRaises ( exceptions . AppException , utils . get_args , self . received ) [EOL] [EOL] def test_get_args_missing_required_keys ( self ) : [EOL] required_missing = { [string] : str } [EOL] self . assertRaises ( exceptions . AppException , utils . get_args , self . received , required = required_missing ) [EOL] [EOL] def test_get_args_required ( self ) : [EOL] expected = { [string] : [number] } [EOL] self . assertDictEqual ( utils . get_args ( self . received , required = self . required ) , expected ) [EOL] [EOL] def test_get_args_defaultable ( self ) : [EOL] expected = { [string] : [number] , [string] : [number] } [EOL] self . assertDictEqual ( utils . get_args ( self . received , defaultable = self . defaultable ) , expected ) [EOL] [EOL] def test_get_args_optional ( self ) : [EOL] expected = { [string] : [number] , [string] : [string] } [EOL] self . assertDictEqual ( utils . get_args ( self . received , optional = self . optional ) , expected ) [EOL] [EOL] def test_get_args_constant ( self ) : [EOL] expected = { [string] : [number] } [EOL] self . assertDictEqual ( utils . get_args ( self . received , constant = self . constant ) , expected ) [EOL] [EOL] def test_get_args_all ( self ) : [EOL] expected = { [string] : [number] , [string] : [number] , [string] : [string] } [EOL] self . assertDictEqual ( utils . get_args ( self . received , required = self . required , defaultable = self . defaultable , optional = self . optional , constant = self . constant ) , expected ) [EOL] [EOL] [EOL] class UuidTestCase ( TestCase ) : [EOL] def test_generate_uuid_default ( self ) : [EOL] val = utils . generate_uuid ( ) [EOL] self . assertIsInstance ( val , UUID ) [EOL] [EOL] def test_generate_uuid_many ( self ) : [EOL] obj_count = [number] [EOL] val = utils . generate_uuid ( obj_count ) [EOL] self . assertEqual ( len ( val ) , obj_count ) [EOL] self . assertIsInstance ( val [ [number] ] , UUID ) [EOL] [EOL] def test_generate_uuid_zero ( self ) : [EOL] self . assertIsNone ( utils . generate_uuid ( [number] ) ) [EOL] [EOL] [EOL] class RequestTestCase ( TestCase ) : [EOL] @ staticmethod def get_request_mock ( ) : [EOL] return mock . Mock ( ) [EOL] [EOL] def test_validate_request_is_not_json ( self ) : [EOL] request = self . get_request_mock ( ) [EOL] request . is_json = False [EOL] self . assertRaises ( exceptions . Flask400Exception , utils . flask_validate_request_is_json , request ) [EOL] [EOL] def test_validate_request_is_json ( self ) : [EOL] request = self . get_request_mock ( ) [EOL] request . is_json = True [EOL] self . assertIsNone ( utils . flask_validate_request_is_json ( request ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[builtins.int]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[typing.Union[builtins.int,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Type[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[uuid.UUID],uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[uuid.UUID],uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Union[None,typing.List[uuid.UUID],uuid.UUID]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Union[None,typing.List[uuid.UUID],uuid.UUID]$ 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Union[None,typing.List[uuid.UUID],uuid.UUID]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0
	0
	0