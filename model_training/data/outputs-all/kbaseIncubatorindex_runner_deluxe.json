	0
[EOL] [EOL] from typing import Any [EOL] import typing [EOL] def get_path ( obj , path , default = None ) : [EOL] [docstring] [EOL] for part in path : [EOL] if not isinstance ( obj , list ) and not isinstance ( obj , dict ) : [EOL] return obj [EOL] try : [EOL] obj [ part ] [EOL] except Exception : [EOL] return default [EOL] obj = obj [ part ] [EOL] return obj [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import json [EOL] import requests [EOL] [EOL] from src . utils . config import config [EOL] [EOL] [comment] [EOL] _PREFIX = config ( ) [ [string] ] [EOL] _ES_URL = [string] + config ( ) [ [string] ] + [string] + str ( config ( ) [ [string] ] ) [EOL] [EOL] [EOL] def check_doc_existence ( wsid , objid ) : [EOL] [docstring] [EOL] _id = f" [string] { wsid } [string] { objid }" [EOL] resp = requests . post ( _ES_URL + f" [string] { _PREFIX } [string] " , data = json . dumps ( { [string] : { [string] : { [string] : _id } } } ) , params = { [string] : [number] } , headers = { [string] : [string] } ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( f" [string] { resp . text }" ) [EOL] resp_json = resp . json ( ) [EOL] total = resp_json [ [string] ] [ [string] ] [ [string] ] [EOL] return total > [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] import requests [EOL] [EOL] from src . utils . config import config [EOL] from src . utils . logger import logger [EOL] [EOL] [EOL] def wait_for_dependencies ( elasticsearch = True , re_api = True , timeout = [number] ) : [EOL] [docstring] [EOL] start = int ( time . time ( ) ) [EOL] if elasticsearch : [EOL] es_url = config ( ) [ [string] ] + [string] [EOL] params = { [string] : [string] , [string] : [string] } [EOL] _wait_for_service ( es_url , [string] , start , timeout , params = params ) [EOL] if re_api : [EOL] _wait_for_service ( config ( ) [ [string] ] + [string] , [string] , start , timeout ) [EOL] [EOL] [EOL] def _wait_for_service ( url , name , start_time , timeout , params = None ) : [EOL] while True : [EOL] try : [EOL] logger . info ( f' [string] { name } [string] ' ) [EOL] requests . get ( url , params = params ) . raise_for_status ( ) [EOL] logger . info ( f'{ name } [string] ' ) [EOL] break [EOL] except Exception as err : [EOL] logger . debug ( f' [string] { name } [string] { err }' ) [EOL] time . sleep ( [number] ) [EOL] if ( int ( time . time ( ) ) - start_time ) > timeout : [EOL] raise RuntimeError ( f" [string] { timeout } [string] { name } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] from typing import Any [EOL] import typing [EOL] def get_upa_from_msg_data ( msg_data ) : [EOL] [docstring] [EOL] ws_id = msg_data . get ( [string] ) [EOL] if not ws_id : [EOL] raise RuntimeError ( f' [string] { msg_data }' ) [EOL] obj_id = msg_data . get ( [string] ) [EOL] if not obj_id : [EOL] raise RuntimeError ( f' [string] { msg_data }' ) [EOL] return f"{ ws_id } [string] { obj_id }" [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import confluent_kafka [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] from confluent_kafka import Consumer , Producer [EOL] from typing import List [EOL] import json [EOL] [EOL] from src . utils . logger import logger [EOL] from src . utils . config import config [EOL] [EOL] _KAFKA_PRODUCE_RETRIES = [number] [EOL] [EOL] [EOL] def init_consumer ( topics ) : [EOL] [docstring] [EOL] consumer = Consumer ( { [string] : config ( ) [ [string] ] , [string] : config ( ) [ [string] ] , [string] : [string] , [string] : False } ) [EOL] logger . info ( f" [string] { topics }" ) [EOL] logger . info ( f" [string] { config ( ) [ [string] ] }" ) [EOL] logger . info ( f" [string] { config ( ) [ [string] ] }" ) [EOL] consumer . subscribe ( topics ) [EOL] return consumer [EOL] [EOL] [EOL] def close_consumer ( consumer ) : [EOL] [docstring] [EOL] consumer . close ( ) [EOL] logger . info ( [string] ) [EOL] [EOL] [EOL] def produce ( data , topic = config ( ) [ [string] ] [ [string] ] , callback = None ) : [EOL] [docstring] [EOL] producer = Producer ( { [string] : config ( ) [ [string] ] } ) [EOL] tries = [number] [EOL] while True : [EOL] try : [EOL] producer . produce ( topic , json . dumps ( data ) , callback = callback ) [EOL] producer . flush ( ) [EOL] break [EOL] except BufferError : [EOL] if tries == _KAFKA_PRODUCE_RETRIES : [EOL] raise RuntimeError ( [string] ) [EOL] logger . error ( [string] ) [EOL] tries += [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $confluent_kafka.Consumer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict , Set , Any , Union , Optional , Literal [EOL] import builtins [EOL] import typing [EOL] import requests [EOL] import typing_extensions [EOL] from kbase_workspace_client import WorkspaceClient [EOL] from typing import Optional [EOL] import json [EOL] import os [EOL] import requests [EOL] import time [EOL] import urllib . request [EOL] import yaml [EOL] [EOL] from src . utils . logger import logger [EOL] [EOL] _FETCH_CONFIG_RETRIES = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] _CONFIG_SINGLETON = None [EOL] [EOL] [EOL] def _get_sample_service_url ( sw_url , ss_release ) : [EOL] [docstring] [EOL] payload = { [string] : [string] , [string] : [string] , [string] : [ { [string] : [string] , [string] : ss_release } ] , [string] : [string] } [EOL] headers = { [string] : [string] } [EOL] sw_resp = requests . post ( url = sw_url , headers = headers , data = json . dumps ( payload ) ) [EOL] if not sw_resp . ok : [EOL] raise RuntimeError ( f" [string] { sw_resp . status_code } [string] { sw_resp . text }" ) [EOL] wiz_resp = sw_resp . json ( ) [EOL] if wiz_resp . get ( [string] ) : [EOL] raise RuntimeError ( f" [string] { sw_url } [string] " f" [string] { json . dumps ( payload ) } [string] " + str ( wiz_resp [ [string] ] ) ) [EOL] return wiz_resp [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] [EOL] def config ( force_reload = False ) : [EOL] [docstring] [EOL] global _CONFIG_SINGLETON [EOL] if not _CONFIG_SINGLETON : [EOL] [comment] [EOL] _CONFIG_SINGLETON = Config ( ) [EOL] _CONFIG_SINGLETON . reload ( force_reload = force_reload ) [EOL] return _CONFIG_SINGLETON [EOL] [EOL] [EOL] class Config : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _cfg = { } [EOL] self . reload ( ) [EOL] [EOL] def reload ( self , force_reload = False ) : [EOL] [docstring] [EOL] if self . _cfg : [EOL] expired = ( time . time ( ) - self . _cfg [ [string] ] ) > self . _cfg [ [string] ] [EOL] if not expired and not force_reload : [EOL] [comment] [EOL] return [EOL] [EOL] reqs = [ [string] , [string] ] [EOL] for req in reqs : [EOL] if not os . environ . get ( req ) : [EOL] raise RuntimeError ( f'{ req } [string] ' ) [EOL] ws_token = os . environ [ [string] ] [EOL] es_host = os . environ . get ( [string] , [string] ) [EOL] es_port = os . environ . get ( [string] , [number] ) [EOL] kbase_endpoint = os . environ . get ( [string] , [string] ) . strip ( [string] ) [EOL] workspace_url = os . environ . get ( [string] , kbase_endpoint + [string] ) [EOL] catalog_url = os . environ . get ( [string] , kbase_endpoint + [string] ) [EOL] re_api_url = os . environ . get ( [string] , kbase_endpoint + [string] ) . strip ( [string] ) [EOL] sample_service_url = os . environ . get ( [string] ) [EOL] if sample_service_url is None : [EOL] service_wizard_url = os . environ . get ( [string] , kbase_endpoint + [string] ) . strip ( [string] ) [EOL] sample_service_release = os . environ . get ( [string] , [string] ) [EOL] sample_service_url = _get_sample_service_url ( service_wizard_url , sample_service_release ) [EOL] config_url = os . environ . get ( [string] , f" [string] { os . getcwd ( ) } [string] " ) [EOL] global_config = _fetch_global_config ( config_url ) [EOL] skip_indices = _get_comma_delimited_env ( [string] ) [EOL] allow_indices = _get_comma_delimited_env ( [string] ) [EOL] [comment] [EOL] proc_ready_path = [string] [comment] [EOL] [comment] [EOL] msg_log_index_name = os . environ . get ( [string] , [string] ) [EOL] if msg_log_index_name in global_config [ [string] ] : [EOL] msg_log_index_name = global_config [ [string] ] [ msg_log_index_name ] [EOL] self . _cfg = { [string] : os . environ . get ( [string] ) , [string] : os . environ . get ( [string] ) , [string] : skip_indices , [string] : allow_indices , [string] : global_config , [string] : config_url , [string] : ws_token , [string] : os . environ . get ( [string] , os . getcwd ( ) ) , [string] : kbase_endpoint , [string] : catalog_url , [string] : workspace_url , [string] : re_api_url , [string] : os . environ [ [string] ] , [string] : sample_service_url , [string] : es_host , [string] : es_port , [string] : f" [string] { es_host } [string] { es_port }" , [string] : int ( os . environ . get ( [string] , [number] ) ) , [string] : os . environ . get ( [string] , [string] ) , [string] : os . environ . get ( [string] , [string] ) , [string] : os . environ . get ( [string] , [string] ) , [string] : msg_log_index_name , [string] : os . environ . get ( [string] , [string] ) , [string] : { [string] : os . environ . get ( [string] , [string] ) , [string] : os . environ . get ( [string] , [string] ) } , [string] : [number] , [string] : time . time ( ) , [string] : proc_ready_path , [string] : os . environ . get ( [string] , [number] ) , [string] : os . environ . get ( [string] , [number] ) , [string] : _get_comma_delimited_env ( [string] ) , [string] : _get_comma_delimited_env ( [string] ) , [string] : int ( os . environ . get ( [string] , [number] ) ) , [string] : WorkspaceClient ( url = kbase_endpoint , token = ws_token ) , } [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] return self . _cfg [ key ] [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . _cfg ) [EOL] [EOL] [EOL] def _fetch_global_config ( config_url ) : [EOL] [docstring] [EOL] logger . info ( f' [string] { config_url }' ) [EOL] [comment] [EOL] with urllib . request . urlopen ( config_url ) as res : [comment] [EOL] return yaml . safe_load ( res . read ( ) ) [EOL] [EOL] [EOL] def _get_comma_delimited_env ( key ) : [EOL] [docstring] [EOL] if key not in os . environ : [EOL] return None [EOL] ret = set ( ) [EOL] for piece in os . environ . get ( key , [string] ) . split ( [string] ) : [EOL] piece = piece . strip ( ) [EOL] if piece : [EOL] ret . add ( piece ) [EOL] return ret [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Optional[typing.Set[typing.Any]]$ 0 0 0 0 0 0 $typing.Optional[typing.Set[typing.Any]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Set[typing.Any]]$ 0 0 0 $typing.Optional[typing.Set[typing.Any]]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[typing_extensions.Literal,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.set]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import src . utils . logger as logger [EOL] import src . utils . re_client as re_client [EOL] [EOL] _OBJ_COLL_NAME = [string] [EOL] _OBJ_VER_COLL_NAME = [string] [EOL] [EOL] [EOL] def delete_object ( obj_info ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] wsid = obj_info [ [number] ] [EOL] objid = obj_info [ [number] ] [EOL] obj_key = f'{ wsid } [string] { objid }' [EOL] results = re_client . get_doc ( _OBJ_COLL_NAME , obj_key ) . get ( [string] ) [EOL] if not results : [EOL] logger . warning ( f" [string] { obj_key } [string] " ) [EOL] obj_doc = results [ [number] ] [EOL] for key in [ [string] , [string] , [string] ] : [EOL] del obj_doc [ key ] [EOL] obj_doc [ [string] ] = True [EOL] [comment] [EOL] re_client . save ( _OBJ_COLL_NAME , obj_doc ) [EOL] [comment] [EOL] query = f""" [string] { _OBJ_VER_COLL_NAME } [string] """ [EOL] re_client . execute_query ( query , { [string] : wsid , [string] : objid } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from src . index_runner . es_indexers . indexer_utils import mean [EOL] [EOL] _NAMESPACE = [string] [EOL] _ASSEMBLY_INDEX_VERSION = [number] [EOL] _ASSEMBLY_INDEX_NAME = [string] + str ( _ASSEMBLY_INDEX_VERSION ) [EOL] [EOL] [EOL] def index_assembly ( obj_data , ws_info , obj_data_v1 ) : [EOL] [docstring] [EOL] info = obj_data [ [string] ] [EOL] data = obj_data [ [string] ] [EOL] workspace_id = info [ [number] ] [EOL] object_id = info [ [number] ] [EOL] [comment] [EOL] if data . get ( [string] ) : [EOL] [comment] [EOL] mean_contig_length = mean ( [ contig . get ( [string] ) for _ , contig in data [ [string] ] . items ( ) if contig . get ( [string] ) ] ) [EOL] percent_complete_contigs = mean ( [ contig . get ( [string] ) for _ , contig in data [ [string] ] . items ( ) if contig . get ( [string] ) ] ) [EOL] percent_circle_contigs = mean ( [ contig . get ( [string] ) for _ , contig in data [ [string] ] . items ( ) if contig . get ( [string] ) ] ) [EOL] else : [EOL] mean_contig_length , percent_complete_contigs , percent_circle_contigs = None , None , None [EOL] yield { [string] : [string] , [string] : { [string] : data . get ( [string] , None ) , [string] : mean_contig_length , [string] : percent_complete_contigs , [string] : percent_circle_contigs , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , [string] : data . get ( [string] , None ) , } , [string] : _ASSEMBLY_INDEX_NAME , [string] : f"{ _NAMESPACE } [string] { workspace_id } [string] { object_id }" , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from src . utils . get_path import get_path [EOL] [EOL] _NAMESPACE = [string] [EOL] _READS_INDEX_VERSION = [number] [EOL] _READS_INDEX_NAME = [string] + str ( _READS_INDEX_VERSION ) [EOL] [EOL] [EOL] def index_reads ( obj_data , ws_info , obj_data_v1 ) : [EOL] [docstring] [EOL] obj_info = obj_data [ [string] ] [EOL] data = obj_data [ [string] ] [EOL] workspace_id = obj_info [ [number] ] [EOL] object_id = obj_info [ [number] ] [EOL] [EOL] interleaved = bool ( data . get ( [string] , False ) ) [EOL] sequencing_tech = data . get ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] if data . get ( [string] ) : [EOL] size = ( get_path ( obj_data , [ [string] , [string] , [string] ] , [number] ) + get_path ( obj_data , [ [string] , [string] , [string] ] , [number] ) ) [EOL] elif data . get ( [string] ) : [EOL] size = get_path ( obj_data , [ [string] , [string] , [string] ] , [number] ) [EOL] else : [EOL] size = None [EOL] [EOL] single_genome = bool ( data . get ( [string] , False ) ) [EOL] gc_content = data . get ( [string] , None ) [EOL] [comment] [EOL] mean_read_length = data . get ( [string] , None ) [EOL] [comment] [EOL] qual_mean = data . get ( [string] , None ) [EOL] [comment] [EOL] phred_type = data . get ( [string] , None ) [EOL] [EOL] yield { [string] : [string] , [string] : { [string] : phred_type , [string] : gc_content , [string] : qual_mean , [string] : mean_read_length , [string] : sequencing_tech , [string] : size , [string] : interleaved , [string] : single_genome , } , [string] : _READS_INDEX_NAME , [string] : f'{ _NAMESPACE } [string] { workspace_id } [string] { object_id }' } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import requests [EOL] from src . utils . config import config [EOL] import json [EOL] [comment] [EOL] import requests [EOL] [EOL] [EOL] _NAMESPACE = [string] [EOL] _VER_NAMESPACE = [string] [EOL] _SAMPLE_NAMESPACE = [string] [EOL] [comment] [EOL] _SAMPLE_SET_INDEX_VERSION = [number] [EOL] _SAMPLE_SET_INDEX_NAME = [string] + str ( _SAMPLE_SET_INDEX_VERSION ) [EOL] _VER_SAMPLE_SET_INDEX_NAME = [string] + str ( _SAMPLE_SET_INDEX_VERSION ) [EOL] [comment] [EOL] _SAMPLE_INDEX_VERSION = [number] [EOL] _SAMPLE_INDEX_NAME = [string] + str ( _SAMPLE_INDEX_VERSION ) [EOL] [comment] [EOL] [EOL] [EOL] def _get_sample ( sample_info ) : [EOL] [docstring] [EOL] headers = { [string] : config ( ) [ [string] ] } [EOL] params = { [string] : sample_info [ [string] ] , [string] : True } [EOL] if sample_info . get ( [string] ) : [EOL] params [ [string] ] = sample_info [ [string] ] [EOL] payload = { [string] : [string] , [string] : [string] , [string] : [ params ] , [string] : [string] } [EOL] resp = requests . post ( url = config ( ) [ [string] ] , headers = headers , data = json . dumps ( payload ) ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( f" [string] { resp . status_code } [string] { resp . text }" ) [EOL] resp_json = resp . json ( ) [EOL] if resp_json . get ( [string] ) : [EOL] raise RuntimeError ( f" [string] { resp_json [ [string] ] }" ) [EOL] sample = resp_json [ [string] ] [ [number] ] [EOL] return sample [EOL] [EOL] [EOL] def _flatten_meta ( meta , prefix = None ) : [EOL] [docstring] [EOL] new_meta = { } [EOL] for key in meta : [EOL] if prefix : [EOL] val = prefix + [string] [EOL] else : [EOL] val = [string] [EOL] if [string] in meta [ key ] : [EOL] val += str ( meta [ key ] [ [string] ] ) [EOL] if [string] in meta [ key ] : [EOL] val += [string] + str ( meta [ key ] [ [string] ] ) [EOL] new_meta [ key ] = val [EOL] return new_meta [EOL] [EOL] [EOL] def _combine_meta ( meta , flattened_meta , idx ) : [EOL] [docstring] [EOL] for key in flattened_meta : [EOL] if key in meta : [EOL] meta [ key ] += [ [string] for _ in range ( idx - len ( meta [ key ] ) ) ] + [ flattened_meta [ key ] ] [EOL] else : [EOL] meta [ key ] = [ [string] for _ in range ( idx ) ] + [ flattened_meta [ key ] ] [EOL] return meta [EOL] [EOL] [EOL] def index_sample_set ( obj_data , ws_info , obj_data_v1 ) : [EOL] [docstring] [EOL] info = obj_data [ [string] ] [EOL] if not obj_data . get ( [string] ) : [EOL] raise Exception ( [string] ) [EOL] data = obj_data [ [string] ] [EOL] workspace_id = info [ [number] ] [EOL] object_id = info [ [number] ] [EOL] version = info [ [number] ] [EOL] sample_set_id = f"{ _NAMESPACE } [string] { workspace_id } [string] { object_id }" [EOL] ver_sample_set_id = f"{ _VER_NAMESPACE } [string] { workspace_id } [string] { object_id } [string] { version }" [EOL] [EOL] sample_set_index = { [string] : [string] , [string] : { [string] : data [ [string] ] , [string] : [ s [ [string] ] for s in data [ [string] ] ] , [string] : [ s [ [string] ] for s in data [ [string] ] ] , [string] : [ s [ [string] ] for s in data [ [string] ] ] } , [string] : _SAMPLE_SET_INDEX_NAME , [string] : sample_set_id } [EOL] yield sample_set_index [EOL] ver_sample_set_index = dict ( sample_set_index ) [EOL] ver_sample_set_index [ [string] ] = _VER_SAMPLE_SET_INDEX_NAME [EOL] ver_sample_set_index [ [string] ] = ver_sample_set_id [EOL] yield ver_sample_set_index [EOL] [EOL] for samp in data [ [string] ] : [EOL] [comment] [EOL] sample = _get_sample ( samp ) [EOL] sample_id = f"{ _SAMPLE_NAMESPACE } [string] { sample [ [string] ] } [string] { sample [ [string] ] }" [EOL] [comment] [EOL] if len ( sample [ [string] ] ) == [number] : [EOL] meta_controlled = _flatten_meta ( sample [ [string] ] [ [number] ] [ [string] ] ) [EOL] meta_user = _flatten_meta ( sample [ [string] ] [ [number] ] [ [string] ] ) [EOL] meta_controlled [ [string] ] = sample [ [string] ] [ [number] ] [ [string] ] [EOL] else : [EOL] meta_controlled , meta_user = { } , { } [EOL] for idx , node in enumerate ( sample [ [string] ] ) : [EOL] meta_controlled = _combine_meta ( meta_controlled , _flatten_meta ( node [ [string] ] ) , idx ) [EOL] meta_user = _combine_meta ( meta_user , _flatten_meta ( node [ [string] ] ) , idx ) [EOL] meta_controlled [ [string] ] = node [ [string] ] [EOL] [EOL] sample_index = { [string] : [string] , [string] : { [string] : sample [ [string] ] , [string] : sample [ [string] ] , [string] : sample [ [string] ] , [string] : sample_set_id , ** meta_user , ** meta_controlled } , [string] : _SAMPLE_INDEX_NAME , [string] : sample_id } [EOL] yield sample_index [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import sys [EOL] from bs4 import BeautifulSoup [EOL] from markdown2 import Markdown [EOL] [EOL] from src . utils . logger import logger [EOL] from src . utils . config import config [EOL] from src . utils . formatting import ts_to_epoch [EOL] from src . utils . get_path import get_path [EOL] [EOL] _NAMESPACE = [string] [EOL] _MARKDOWNER = Markdown ( ) [EOL] _NARRATIVE_INDEX_VERSION = [number] [EOL] _NARRATIVE_INDEX_NAME = [string] + str ( _NARRATIVE_INDEX_VERSION ) [EOL] [EOL] [EOL] def index_narrative ( obj_data , ws_info , obj_data_v1 ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] obj_info = obj_data [ [string] ] [EOL] obj_id = obj_info [ [number] ] [EOL] obj_metadata = obj_info [ - [number] ] [EOL] if not obj_metadata : [EOL] raise RuntimeError ( f" [string] { obj_info }" ) [EOL] [ ws_id , _ , owner , moddate , _ , _ , _ , _ , ws_metadata ] = ws_info [EOL] if not ws_metadata : [EOL] raise RuntimeError ( f" [string] { ws_info }" ) [EOL] if ws_metadata . get ( [string] ) == [string] : [EOL] logger . debug ( [string] ) [EOL] return [EOL] is_narratorial = _narrative_is_narratorial ( ws_metadata ) [EOL] narrative_title = obj_metadata . get ( [string] ) [EOL] creator = obj_data [ [string] ] [EOL] [comment] [EOL] narrative_data_objects = _fetch_objects_in_workspace ( ws_id ) [EOL] [comment] [EOL] raw_cells = obj_data [ [string] ] . get ( [string] , [ ] ) [EOL] index_cells = _extract_cells ( raw_cells , ws_id ) [EOL] result = { [string] : [string] , [string] : { [string] : narrative_title , [string] : is_narratorial , [string] : narrative_data_objects , [string] : owner , [string] : ts_to_epoch ( moddate ) , [string] : index_cells , [string] : creator , [string] : len ( raw_cells ) , [string] : ws_metadata . get ( [string] ) , [string] : ws_metadata . get ( [string] ) , } , [string] : _NARRATIVE_INDEX_NAME , [string] : f'{ _NAMESPACE } [string] { ws_id } [string] { obj_id }' , } [EOL] yield result [EOL] [EOL] [EOL] def _narrative_is_narratorial ( ws_metadata ) : [EOL] return ws_metadata . get ( [string] ) == [string] [EOL] [EOL] [EOL] def _extract_cells ( cells , workspace_id ) : [EOL] index_cells = [ ] [EOL] for cell in cells : [EOL] if cell . get ( [string] ) == [string] : [EOL] if not cell . get ( [string] ) : [EOL] [comment] [EOL] continue [EOL] if cell [ [string] ] . startswith ( [string] ) : [EOL] [comment] [EOL] continue [EOL] [comment] [EOL] cell_soup = BeautifulSoup ( _MARKDOWNER . convert ( cell [ [string] ] ) , [string] ) [EOL] index_cell = { [string] : cell_soup . get_text ( ) , [string] : [string] } [EOL] index_cell [ [string] ] = [string] [EOL] index_cell [ [string] ] = cell_soup . get_text ( ) [EOL] [comment] [EOL] elif cell . get ( [string] ) == [string] : [EOL] index_cell = _process_code_cell ( cell ) [EOL] else : [EOL] cell_type = cell . get ( [string] , [string] ) [EOL] sys . stderr . write ( f" [string] { cell_type } [string] " ) [EOL] sys . stderr . write ( str ( cell ) ) [EOL] sys . stderr . write ( [string] + ( [string] * [number] ) + [string] ) [EOL] index_cell = { [string] : [string] , [string] : [string] } [EOL] index_cells . append ( index_cell ) [EOL] return index_cells [EOL] [EOL] [EOL] def _process_code_cell ( cell ) : [EOL] [comment] [EOL] [comment] [EOL] index_cell = { [string] : [string] , [string] : [string] } [EOL] widget_data = get_path ( cell , [ [string] , [string] , [string] , [string] ] ) [EOL] app_cell = get_path ( cell , [ [string] , [string] , [string] ] ) [EOL] data_cell = get_path ( cell , [ [string] , [string] , [string] ] ) [EOL] if app_cell : [EOL] [comment] [EOL] [comment] [EOL] app_name1 = get_path ( cell , [ [string] , [string] , [string] , [string] ] ) [EOL] app_name2 = get_path ( app_cell , [ [string] , [string] ] ) [EOL] index_cell [ [string] ] = app_name1 or app_name2 or [string] [EOL] index_cell [ [string] ] = [string] [EOL] elif widget_data : [EOL] index_cell [ [string] ] = [string] [EOL] index_cell [ [string] ] = widget_data . get ( [string] , [string] ) [EOL] elif data_cell : [EOL] index_cell [ [string] ] = [string] [EOL] name = get_path ( data_cell , [ [string] , [string] ] ) [EOL] obj_type = get_path ( data_cell , [ [string] , [string] ] ) [EOL] if name and obj_type : [EOL] index_cell [ [string] ] = f'{ name } [string] { obj_type } [string] ' [EOL] else : [EOL] index_cell [ [string] ] = name or obj_type or [string] [EOL] else : [EOL] [comment] [EOL] index_cell [ [string] ] = [string] [EOL] index_cell [ [string] ] = cell . get ( [string] , [string] ) [EOL] return index_cell [EOL] [EOL] [EOL] def _fetch_objects_in_workspace ( ws_id ) : [EOL] [docstring] [EOL] obj_infos = config ( ) [ [string] ] . generate_obj_infos ( ws_id , admin = True ) [EOL] return [ { [string] : info [ [number] ] , [string] : info [ [number] ] } for info in obj_infos if [string] not in str ( info [ [number] ] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List , Dict [EOL] import typing [EOL] from src . index_runner . es_indexers . indexer_utils import mean , handle_id_to_file [EOL] from src . utils . config import config [EOL] [EOL] import tempfile [EOL] import json [EOL] import gzip [EOL] import shutil [EOL] import os [EOL] [EOL] _NAMESPACE = [string] [EOL] _VER_NAMESPACE = [string] [EOL] _AMA_INDEX_VERSION = [number] [EOL] _AMA_FEATURES_INDEX_VERSION = [number] [EOL] _AMA_INDEX_NAME = [string] + str ( _AMA_INDEX_VERSION ) [EOL] _AMA_FEATURES_INDEX_NAME = [string] + str ( _AMA_FEATURES_INDEX_VERSION ) [EOL] [comment] [EOL] _VER_AMA_INDEX_VERSION = [number] [EOL] _VER_AMA_FEATURES_INDEX_VERSION = [number] [EOL] _VER_AMA_INDEX_NAME = [string] + str ( _VER_AMA_INDEX_VERSION ) [EOL] _VER_AMA_FEATURES_INDEX_NAME = [string] + str ( _VER_AMA_FEATURES_INDEX_VERSION ) [EOL] [EOL] [EOL] def _index_ama ( features_file_gz_path , data , ama_id , ver_ama_id , tmp_dir ) : [EOL] [docstring] [EOL] publication_titles = [ pub [ [number] ] for pub in data . get ( [string] , [ ] ) ] [EOL] publication_authors = [ pub [ [number] ] for pub in data . get ( [string] , [ ] ) ] [EOL] ama_index = { [string] : [string] , [string] : { [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : mean ( data . get ( [string] , [ ] ) ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : publication_authors , [string] : publication_titles , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , } , [string] : _AMA_INDEX_NAME , [string] : ama_id } [EOL] ama_index [ [string] ] = ama_id [EOL] yield ama_index [EOL] ver_ama_index = dict ( ama_index ) [EOL] ver_ama_index [ [string] ] = ver_ama_id [EOL] ver_ama_index [ [string] ] = _VER_AMA_INDEX_NAME [EOL] yield ver_ama_index [EOL] [EOL] if config ( ) [ [string] ] : [EOL] [comment] [EOL] return [EOL] [EOL] [comment] [EOL] features_file_path = os . path . join ( tmp_dir , ver_ama_id . replace ( [string] , [string] ) + [string] ) [EOL] with gzip . open ( features_file_gz_path , [string] ) as f_in : [EOL] with open ( features_file_path , [string] ) as f_out : [EOL] shutil . copyfileobj ( f_in , f_out ) [EOL] [EOL] with open ( features_file_path ) as f : [EOL] features = json . load ( f ) [EOL] [EOL] for feat in features : [EOL] id_ = feat . get ( [string] ) [EOL] feat_id = ama_id + f" [string] { id_ }" [EOL] ver_feat_id = ver_ama_id + f" [string] { id_ }" [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if feat . get ( [string] ) : [EOL] contig_ids , starts , strands , stops = zip ( * feat . get ( [string] ) ) [EOL] contig_ids , starts , strands , stops = list ( contig_ids ) , list ( starts ) , list ( strands ) , list ( stops ) [EOL] else : [EOL] contig_ids , starts , strands , stops = None , None , None , None [EOL] [EOL] feat_index = { [string] : [string] , [string] : { [string] : id_ , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : starts , [string] : strands , [string] : stops , [string] : contig_ids , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : feat . get ( [string] ) , [string] : ama_id , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) , [string] : data . get ( [string] ) } , [string] : _AMA_FEATURES_INDEX_NAME , [string] : feat_id } [EOL] yield feat_index [EOL] ver_feat_index = dict ( feat_index ) [EOL] ver_feat_index [ [string] ] = ver_feat_id [EOL] ver_feat_index [ [string] ] [ [string] ] = ver_ama_id [EOL] ver_feat_index [ [string] ] = _VER_AMA_FEATURES_INDEX_NAME [EOL] yield ver_feat_index [EOL] [comment] [EOL] os . remove ( features_file_path ) [EOL] [EOL] [EOL] def index_annotated_metagenome_assembly ( obj_data , ws_info , obj_data_v1 ) : [EOL] [docstring] [EOL] if not obj_data . get ( [string] ) : [EOL] raise Exception ( [string] ) [EOL] data = obj_data . get ( [string] ) [EOL] info = obj_data . get ( [string] ) [EOL] workspace_id = info [ [number] ] [EOL] object_id = info [ [number] ] [EOL] version = info [ [number] ] [EOL] ama_id = f"{ _NAMESPACE } [string] { workspace_id } [string] { object_id }" [EOL] ver_ama_id = f"{ _VER_NAMESPACE } [string] { workspace_id } [string] { object_id } [string] { version }" [EOL] [EOL] if not data . get ( [string] ) : [EOL] raise Exception ( [string] [string] ) [EOL] [EOL] features_handle_ref = data . get ( [string] ) [EOL] try : [EOL] [comment] [EOL] tmp_dir = tempfile . mkdtemp ( ) [EOL] features_file_gz_path = os . path . join ( tmp_dir , ver_ama_id . replace ( [string] , [string] ) + [string] ) [EOL] handle_id_to_file ( features_handle_ref , features_file_gz_path ) [EOL] [EOL] for doc in _index_ama ( features_file_gz_path , data , ama_id , ver_ama_id , tmp_dir ) : [EOL] yield doc [EOL] finally : [EOL] shutil . rmtree ( tmp_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Union , Any , List , Dict [EOL] import argparse [EOL] import typing [EOL] import requests [EOL] from confluent_kafka import Producer [EOL] from kbase_workspace_client . exceptions import WorkspaceResponseError [EOL] import argparse [EOL] import json [EOL] import re [EOL] import requests [EOL] import sys [EOL] [EOL] from src . utils . config import config [EOL] [EOL] _ES_URL = config ( ) [ [string] ] [EOL] _ERR_IDX_NAME = config ( ) [ [string] ] + [string] + config ( ) [ [string] ] [EOL] _ERR_SEARCH_URL = f'{ _ES_URL } [string] { _ERR_IDX_NAME } [string] ' [EOL] [comment] [EOL] _STOP_ID = [number] [EOL] [EOL] [EOL] def _get_count ( args ) : [EOL] [docstring] [EOL] if args . by_type : [EOL] return _get_count_by_type ( args ) [EOL] resp = requests . get ( _ERR_SEARCH_URL , params = { [string] : [number] } ) [EOL] rj = resp . json ( ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( json . dumps ( rj , indent = [number] ) ) [EOL] print ( [string] , rj [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def _get_count_by_type ( args ) : [EOL] [docstring] [EOL] resp = requests . post ( _ERR_SEARCH_URL , data = json . dumps ( { [string] : [number] , [string] : { [string] : { [string] : { [string] : [string] } } } } ) ) [EOL] rj = resp . json ( ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( json . dumps ( rj , indent = [number] ) ) [EOL] for count_doc in rj [ [string] ] [ [string] ] [ [string] ] : [EOL] print ( _pad ( count_doc [ [string] ] , count_doc [ [string] ] , amount = [number] ) ) [EOL] [EOL] [EOL] def _get_upas ( args ) : [EOL] resp = requests . post ( _ERR_SEARCH_URL , params = { [string] : [string] } , headers = { [string] : [string] } , data = json . dumps ( { [string] : [number] , [string] : [ [string] , [string] , [string] ] } ) ) [EOL] rj = resp . json ( ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( json . dumps ( rj , indent = [number] ) ) [EOL] scrolling = True [EOL] scroll_id = rj [ [string] ] [EOL] _print_upas ( rj ) [EOL] while scrolling : [EOL] resp = requests . post ( _ES_URL + [string] , headers = { [string] : [string] } , data = json . dumps ( { [string] : [string] , [string] : scroll_id } ) ) [EOL] rj = resp . json ( ) [EOL] if not resp . ok : [EOL] raise RuntimeError ( json . dumps ( rj , indent = [number] ) ) [EOL] if rj [ [string] ] [ [string] ] : [EOL] _print_upas ( rj ) [EOL] else : [EOL] scrolling = False [EOL] [EOL] [EOL] def _print_upas ( doc ) : [EOL] for doc in doc [ [string] ] [ [string] ] : [EOL] s = doc [ [string] ] [EOL] print ( f'{ s [ [string] ] } [string] { s [ [string] ] } [string] { s [ [string] ] } [string] ' ) [EOL] [EOL] [EOL] def _pad ( left , right , amount = [number] ) : [EOL] [docstring] [EOL] pad = [string] * ( amount - len ( left ) ) [EOL] return f"{ left } [string] { pad } [string] { right }" [EOL] [EOL] [EOL] def _reindex ( args ) : [EOL] id_pieces = args . ref . split ( [string] ) [EOL] if len ( id_pieces ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] reindexing_obj = len ( id_pieces ) >= [number] [EOL] if reindexing_obj : [EOL] ev = { [string] : [string] , [string] : int ( id_pieces [ [number] ] ) , [string] : int ( id_pieces [ [number] ] ) } [EOL] if len ( id_pieces ) == [number] : [EOL] ev [ [string] ] = int ( id_pieces [ [number] ] ) [EOL] if args . overwrite : [EOL] ev [ [string] ] = [string] [EOL] else : [EOL] ev = { [string] : [string] , [string] : int ( id_pieces [ [number] ] ) } [EOL] if args . overwrite : [EOL] ev [ [string] ] = [string] [EOL] print ( [string] ) [EOL] _produce ( ev ) [EOL] [EOL] [EOL] def _reindex_ws_range ( args ) : [EOL] evtype = [string] [EOL] if args . overwrite : [EOL] evtype = [string] [EOL] count = [number] [EOL] for wsid in range ( args . min , args . max + [number] ) : [EOL] _produce ( { [string] : evtype , [string] : int ( wsid ) } ) [EOL] count += [number] [EOL] print ( f' [string] { count } [string] ' ) [EOL] [EOL] [EOL] def _reindex_ws_type ( args ) : [EOL] [docstring] [EOL] if not re . match ( [string] , args . type ) : [EOL] sys . stderr . write ( [string] ) [EOL] sys . exit ( [number] ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] evtype = [string] [EOL] if args . overwrite : [EOL] evtype = [string] [EOL] objids = [ ] [EOL] for wsid in range ( args . start , args . stop + [number] ) : [EOL] wsid = int ( wsid ) [EOL] try : [EOL] infos = config ( ) [ [string] ] . generate_obj_infos ( wsid , admin = True ) [EOL] for obj_info in infos : [EOL] obj_type = obj_info [ [number] ] [EOL] if obj_type == args . type : [EOL] objids . append ( ( wsid , int ( obj_info [ [number] ] ) ) ) [EOL] except WorkspaceResponseError : [EOL] continue [EOL] print ( f' [string] { len ( objids ) } [string] ' ) [EOL] for ( wsid , objid ) in objids : [EOL] _produce ( { [string] : evtype , [string] : wsid , [string] : objid } ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def _produce ( data , topic = config ( ) [ [string] ] [ [string] ] ) : [EOL] producer = Producer ( { [string] : config ( ) [ [string] ] } ) [EOL] producer . produce ( topic , json . dumps ( data ) , callback = _delivery_report ) [EOL] producer . flush ( ) [EOL] [EOL] [EOL] def _delivery_report ( err , msg ) : [EOL] if err is not None : [EOL] print ( [string] , err ) [EOL] else : [EOL] print ( f" [string] { msg . topic ( ) } [string] { msg . value ( ) }" ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] resp = requests . get ( _ES_URL ) [EOL] if not resp . ok : [EOL] print ( resp . text ) [EOL] raise RuntimeError ( [string] ) [EOL] parser = argparse . ArgumentParser ( prog = [string] , description = [string] ) [EOL] subparsers = parser . add_subparsers ( ) [EOL] [comment] [EOL] err_count = subparsers . add_parser ( [string] ) [EOL] err_count . add_argument ( [string] , help = [string] , action = [string] , default = False ) [EOL] err_count . set_defaults ( func = _get_count ) [EOL] [comment] [EOL] err_upas = subparsers . add_parser ( [string] , help = [string] ) [EOL] err_upas . set_defaults ( func = _get_upas ) [EOL] [comment] [EOL] reindex = subparsers . add_parser ( [string] , help = [string] ) [EOL] reindex . add_argument ( [string] , [string] , help = [string] , required = True , type = str ) [EOL] reindex . add_argument ( [string] , help = [string] , required = False , default = False , action = [string] ) [EOL] reindex . set_defaults ( func = _reindex ) [EOL] [comment] [EOL] reindex_type = subparsers . add_parser ( [string] , help = [string] , ) [EOL] reindex_type . add_argument ( [string] , [string] , help = [string] , required = True , action = [string] ) [EOL] reindex_type . add_argument ( [string] , help = [string] , required = False , default = False , action = [string] ) [EOL] reindex_type . add_argument ( [string] , help = [string] , required = False , default = [number] , type = int , action = [string] ) [EOL] reindex_type . add_argument ( [string] , help = [string] , required = False , type = int , default = _STOP_ID , action = [string] ) [EOL] reindex_type . set_defaults ( func = _reindex_ws_type ) [EOL] [comment] [EOL] reindex_range = subparsers . add_parser ( [string] , help = [string] ) [EOL] reindex_range . add_argument ( [string] , help = [string] , default = [number] , type = int , required = False , action = [string] ) [EOL] reindex_range . add_argument ( [string] , help = [string] , type = int , required = True , action = [string] ) [EOL] reindex_range . add_argument ( [string] , help = [string] , required = False , default = False , action = [string] ) [EOL] reindex_range . set_defaults ( func = _reindex_ws_range ) [EOL] args = parser . parse_args ( ) [EOL] if len ( sys . argv ) == [number] : [EOL] parser . print_help ( ) [EOL] else : [EOL] args . func ( args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._SubParsersAction$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 $argparse._SubParsersAction$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0
	0
from typing import Any [EOL] import typing [EOL] import yaml [EOL] [EOL] with open ( [string] ) as fd : [EOL] spec = yaml . safe_load ( fd ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] def test_sdk_index_names ( ) : [EOL] for ( key , val ) in spec [ [string] ] . items ( ) : [EOL] subobj_index = val . get ( [string] ) [EOL] if subobj_index is not None : [EOL] assert subobj_index in spec [ [string] ] [EOL] assert subobj_index in spec [ [string] ] [EOL] [EOL] [EOL] def test_alias_index_names ( ) : [EOL] for ( key , ls ) in spec [ [string] ] . items ( ) : [EOL] for idx in ls : [EOL] assert idx in spec [ [string] ] [EOL] [EOL] [EOL] def test_type_to_indexes ( ) : [EOL] for ( key , val ) in spec [ [string] ] . items ( ) : [EOL] assert val in spec [ [string] ] [EOL] assert val in spec [ [string] ] [EOL] [EOL] [EOL] def test_latest_version_names ( ) : [EOL] for ( key , val ) in spec [ [string] ] . items ( ) : [EOL] assert val in spec [ [string] ] [EOL] [EOL] [EOL] def test_mappings ( ) : [EOL] for ( key , val ) in spec [ [string] ] . items ( ) : [EOL] global_mappings = val . get ( [string] , [ ] ) [EOL] assert isinstance ( global_mappings , list ) [EOL] for name in global_mappings : [EOL] assert name in spec [ [string] ] [EOL] assert [string] in val [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] import os [EOL] from src . utils . config import config [EOL] [EOL] if __name__ == [string] : [EOL] tmp_ready_path = config ( ) [ [string] ] [EOL] timeout = [number] [EOL] start = time . time ( ) [EOL] while True : [EOL] if os . path . exists ( tmp_ready_path ) : [EOL] print ( [string] ) [EOL] break [EOL] if time . time ( ) - start > timeout : [EOL] raise RuntimeError ( [string] ) [EOL] print ( [string] ) [EOL] time . sleep ( [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from src . utils . config import config [EOL] from src . index_runner . event_loop import start_loop [EOL] from tests . unit . index_runner . helpers import MockConsumer [EOL] [EOL] [EOL] def test_retry_count ( ) : [EOL] [docstring] [EOL] call_count = [number] [EOL] consumer = MockConsumer ( [ ] ) [EOL] [EOL] def handler_raise ( message ) : [EOL] nonlocal call_count [EOL] call_count += [number] [EOL] raise RuntimeError ( [string] ) [EOL] consumer . produce_test ( [string] ) [EOL] start_loop ( consumer , handler_raise , return_on_empty = True , timeout = [number] ) [EOL] assert call_count == config ( ) [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0