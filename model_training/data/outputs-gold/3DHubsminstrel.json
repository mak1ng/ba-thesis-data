[comment] [EOL] import os [EOL] from setuptools import setup , find_packages [EOL] [EOL] [comment] [EOL] path = os . path . join ( os . path . dirname ( __file__ ) , [string] ) [EOL] with open ( path ) as version_file : [EOL] version = version_file . read ( ) . strip ( ) [EOL] assert version [EOL] [EOL] setup ( name = [string] , version = version , description = [string] , author = [string] , author_email = [string] , url = [string] , packages = find_packages ( ) , include_package_data = True , py_modules = [ [string] ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , entry_points = { [string] : [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import minstrel [EOL] import typing [EOL] from . patching import patch [EOL] [EOL] [EOL] class Mock : [EOL] [EOL] base = None [EOL] derivatives = None [EOL] objects = None [EOL] transport_configs = None [EOL] [EOL] def __init__ ( self , transport_configs , base , derivatives ) : [EOL] self . transport_configs = transport_configs [EOL] self . base = base [EOL] self . derivatives = derivatives [EOL] [EOL] self . generate_objects ( ) [EOL] [EOL] def generate_objects ( self ) : [EOL] self . objects = [ self . base ] [EOL] for derivative in self . derivatives : [EOL] dct = self . base . copy ( ) [EOL] if [string] in derivative : [EOL] dct . update ( derivative [ [string] ] ) [EOL] if [string] in derivative : [EOL] dct = patch ( self . base , derivative [ [string] ] ) [EOL] self . objects . append ( dct ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , Union , Tuple , Type [EOL] import typing [EOL] from typing import Union , Tuple [EOL] [EOL] Number = Union [ int , float ] [EOL] Path = Tuple [ Union [ str , int ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict , Type [EOL] import minstrel [EOL] import typing [EOL] import json [EOL] from . mock import Mock [EOL] from . import transports [EOL] [EOL] TRANSPORT_MAP = { [string] : transports . AMQPTransport , [string] : transports . SQLTransport , } [EOL] [EOL] [EOL] class Config : [EOL] [EOL] transports = None [EOL] files = None [EOL] [EOL] def __init__ ( self , config ) : [EOL] self . transport_settings = config [ [string] ] [EOL] [EOL] self . mocks = [ ] [EOL] for filename in config [ [string] ] : [EOL] with open ( filename , [string] ) as f : [EOL] data = json . load ( f ) [EOL] self . mocks . append ( Mock ( data [ [string] ] , data [ [string] ] , data [ [string] ] ) ) [EOL] [EOL] def setup ( self ) : [EOL] self . transports = { } [EOL] for transport , config in self . transport_settings . items ( ) : [EOL] self . transports [ transport ] = TRANSPORT_MAP [ transport ] ( ** config ) [EOL] [EOL] def run ( self ) : [EOL] for mock in self . mocks : [EOL] if [string] in mock . transport_configs : [EOL] self . transports [ [string] ] . write ( mock ) [EOL] elif [string] in mock . transport_configs : [EOL] self . transports [ [string] ] . write ( mock ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterable , List [EOL] import typing [EOL] import builtins [EOL] from typing import Iterable [EOL] import jsonpatch [EOL] from . jester . handling import handle_dicts [EOL] [EOL] [EOL] def differ ( dicts ) : [EOL] default , derivatives = handle_dicts ( dicts ) [EOL] [EOL] patches = [ ] [EOL] for dct in derivatives : [EOL] patches . append ( jsonpatch . make_patch ( default , dct ) ) [EOL] [EOL] return default , patches [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable [EOL] import builtins [EOL] import logging [EOL] import typing [EOL] from logging import getLogger [EOL] from typing import Iterable [EOL] [EOL] import jsonpatch [EOL] [EOL] logger = getLogger ( __name__ ) [EOL] [EOL] [EOL] def patch ( base , patches ) : [EOL] return jsonpatch . JsonPatch ( patches ) . apply ( base ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import json [EOL] [EOL] [EOL] def _load_file ( filename ) : [EOL] with open ( filename , [string] ) as data_file : [EOL] return json . loads ( data_file ) [EOL] [EOL] [EOL] def generate_mocks ( data ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class Transport : [EOL] [EOL] def __init__ ( self , config ) : [EOL] pass [EOL] [EOL] def write ( self , dct ) : [EOL] pass [EOL] [EOL] def read ( self , * args , ** kwargs ) : [EOL] raise NotImplementedError ( [string] . format ( self . __class__ . __name__ ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . amqp_transport import AMQPTransport [comment] [EOL] from . sql_transport import SQLTransport [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import minstrel [EOL] import typing [EOL] class AMQPTransport : [EOL] [EOL] host = None [EOL] user = None [EOL] password = None [EOL] [EOL] def __init__ ( self , host , user , password ) : [EOL] self . host = host [EOL] self . user = user [EOL] self . password = password [EOL] [EOL] def write ( self , mock ) : [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Type , Any , Set , Dict [EOL] import minstrel [EOL] import typing [EOL] from datetime import datetime [EOL] import collections [EOL] from sqlalchemy import create_engine , cast , Table , MetaData , and_ , Column [EOL] from sqlalchemy . inspection import inspect [EOL] import sqlalchemy . exc [EOL] from . base_transport import Transport [EOL] from . . mock import Mock [EOL] import re [EOL] [EOL] [EOL] class NoSuchColumnError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class NoSuchTableError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class SQLTransport ( Transport ) : [EOL] [EOL] server = None [EOL] host = None [EOL] user = None [EOL] password = None [EOL] database = None [EOL] [EOL] @ property def sql_url ( self ) : [EOL] return [string] . format ( server = self . server , user = self . user , password = self . password , host = self . host , database = self . database , ) [EOL] [EOL] def __init__ ( self , server , host , user , password , database ) : [EOL] self . server = server [EOL] self . host = host [EOL] self . user = user [EOL] self . password = password [EOL] self . database = database [EOL] [EOL] def _setup_table ( self , table_name ) : [EOL] self . engine = create_engine ( self . sql_url ) [EOL] meta = MetaData ( ) [EOL] [EOL] try : [EOL] table = Table ( table_name , meta , autoload_with = self . engine ) [EOL] except sqlalchemy . exc . NoSuchTableError : [EOL] raise NoSuchTableError ( f' [string] { table_name } [string] ' ) [EOL] [EOL] return table [EOL] [EOL] def write ( self , mock ) : [EOL] config = mock . transport_configs [ [string] ] [EOL] table_name = config [ [string] ] [EOL] [EOL] columns = set ( ) [EOL] for obj in mock . objects : [EOL] for key , value in obj . items ( ) : [EOL] columns . add ( key ) [EOL] [EOL] table = self . _setup_table ( table_name ) [EOL] [EOL] for column in columns : [EOL] if not hasattr ( table . c , column ) : [EOL] raise NoSuchColumnError ( f' [string] { column } [string] ' ) [EOL] [EOL] with self . engine . connect ( ) as conn : [EOL] for obj in mock . objects : [EOL] try : [EOL] conn . execute ( table . insert ( ) , obj ) [EOL] except sqlalchemy . exc . IntegrityError as e : [EOL] if [string] not in str ( e ) : [EOL] raise [EOL] pks = inspect ( table ) . primary_key [EOL] [EOL] pk_columns = [ ] [EOL] for pk in pks : [EOL] if isinstance ( pk , Column ) : [EOL] pk_columns . append ( pk ) [EOL] else : [EOL] map ( pk_columns . append , pk . columns . values ( ) ) [EOL] [EOL] pk_and = and_ ( * ( column == cast ( obj [ column . name ] , column . type ) for column in pk_columns ) ) [EOL] conn . execute ( table . update ( ) . where ( pk_and ) , obj ) [EOL] [EOL] [comment] [EOL] for col in table . columns : [EOL] if not col . autoincrement : [EOL] continue [EOL] [comment] [EOL] seq = list ( conn . execute ( f""" [string] { col . name } [string] { table . name } [string] """ ) ) [EOL] if not seq : [EOL] continue [EOL] seq_name = re . findall ( [string] , seq [ [number] ] [ [number] ] ) [EOL] seq_name = seq_name [ [number] ] if seq_name else None [EOL] if not seq_name : [EOL] continue [EOL] [EOL] print ( f' [string] { col . name } [string] { table . name } [string] { seq_name }' ) [EOL] value = conn . execute ( f""" [string] { col . name } [string] { table . name }""" ) . fetchone ( ) [ [number] ] [EOL] if value is not None : [EOL] value = int ( value ) + [number] [EOL] conn . execute ( f""" [string] { seq_name } [string] { value } [string] { value } [string] { value }""" ) [EOL] conn . execute ( [string] ) [EOL] [EOL] def read ( self , table_name ) : [EOL] table = self . _setup_table ( table_name ) [EOL] base = { column . name : None for column in table . c } [EOL] [EOL] objects = [ ] [EOL] with self . engine . connect ( ) as conn : [EOL] results = conn . execute ( table . select ( ) ) [EOL] for result in results : [EOL] obj = base . copy ( ) [EOL] for key in obj : [EOL] value = result [ key ] [EOL] if isinstance ( value , datetime ) : [EOL] value = value . isoformat ( ) [EOL] obj [ key ] = value [EOL] objects . append ( obj ) [EOL] [EOL] return { [string] : { [string] : { [string] : table_name , } , } , [string] : objects . pop ( [number] ) , [string] : [ { [string] : obj } for obj in objects ] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,None]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[unknown,None]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0
from typing import DefaultDict , List , Type , Tuple , Any , Set , Dict , Iterable [EOL] import types [EOL] import builtins [EOL] import handlers [EOL] import frozendict [EOL] import typing [EOL] import functools [EOL] from functools import partial [EOL] from frozendict import frozendict [EOL] from typing import Any , Iterable , Tuple , List [EOL] from collections import defaultdict [EOL] from . handlers import HandlerMap , get_handler_map [EOL] from . . types import Path [EOL] [EOL] [EOL] def flattenit ( pyobj , keytuple = ( ) ) : [EOL] if hasattr ( pyobj , [string] ) : [EOL] if len ( keytuple ) > [number] : [EOL] yield keytuple , pyobj [EOL] for key , value in pyobj . items ( ) : [EOL] yield from flattenit ( value , keytuple + ( key , ) ) [EOL] else : [EOL] yield keytuple , pyobj [EOL] [EOL] [EOL] def _any_of_types ( value , types ) : [EOL] return any ( isinstance ( value , type_ ) for type_ in types ) [EOL] [EOL] [EOL] def simplify_value ( path , value , handler_map ) : [EOL] for types , handler in handler_map . items ( ) : [EOL] if _any_of_types ( value , types ) : [EOL] return handler . simplify ( path , value ) [EOL] [EOL] raise TypeError ( [string] . format ( type ( value ) ) ) [EOL] [EOL] [EOL] def realify_filler ( path , filler , handler_map ) : [EOL] for types , handler in handler_map . items ( ) : [EOL] if _any_of_types ( getattr ( filler , [string] , filler ) , types ) : [EOL] return handler . realify ( path , filler ) [EOL] [EOL] raise TypeError ( [string] . format ( type ( filler . original_value ) ) ) [EOL] [EOL] [EOL] def best_default_dict ( dicts ) : [EOL] key_counts = defaultdict ( int ) [EOL] keys_map = { } [EOL] for dct in dicts : [EOL] keys = [ ] [EOL] for key , value in flattenit ( dct ) : [EOL] key_counts [ key ] += [number] [EOL] keys . append ( key ) [EOL] [EOL] keys_map [ tuple ( sorted ( keys ) ) ] = dct [EOL] [EOL] best_keys = [ ] [EOL] other_keys = { } [EOL] for key , count in key_counts . items ( ) : [EOL] if count > ( len ( dicts ) / [number] ) : [EOL] best_keys . append ( key ) [EOL] else : [EOL] other_keys [ key ] = count [EOL] best_keys . sort ( key = lambda l : l [ [number] ] ) [EOL] [EOL] if tuple ( best_keys ) in keys_map : [EOL] out = keys_map [ tuple ( best_keys ) ] [EOL] return out [EOL] [EOL] sorted_keys = sorted ( other_keys . items ( ) , key = lambda l : l [ [number] ] ) [EOL] for key , _ in sorted_keys : [EOL] best_keys . append ( key ) [EOL] best_keys . sort ( ) [EOL] [EOL] if tuple ( best_keys ) in keys_map : [EOL] return keys_map [ tuple ( best_keys ) ] [EOL] [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def handle_dicts ( dicts ) : [EOL] handler_map = get_handler_map ( ) [EOL] [EOL] bound_simplify = partial ( simplify_value , handler_map = handler_map ) [EOL] bound_realify = partial ( realify_filler , handler_map = handler_map ) [EOL] [EOL] for _ , handler in handler_map . items ( ) : [EOL] handler . simplify_value = bound_simplify [EOL] handler . realify_filler = bound_realify [EOL] [EOL] simplifieds = set ( ) [EOL] for dct in dicts : [EOL] simple = bound_simplify ( ( ) , dct ) [EOL] simplifieds . add ( simple ) [EOL] [EOL] out = [ ] [EOL] for simple in simplifieds : [EOL] out . append ( bound_realify ( ( ) , simple ) ) [EOL] [EOL] default = best_default_dict ( out ) [EOL] out . remove ( default ) [EOL] [EOL] return default , out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.dict,typing.List[builtins.dict]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Type [EOL] import minstrel [EOL] import typing [EOL] from typing import Dict , NamedTuple [EOL] from collections import defaultdict [EOL] from enum import Enum , auto [EOL] from . . . types import Number , Path [EOL] from . base_handler import BaseHandler , Filler [EOL] [EOL] [EOL] class StringForms ( Enum ) : [EOL] EMPTY = auto ( ) [EOL] FILLED = auto ( ) [EOL] [EOL] [EOL] class StringFiller ( Filler ) : [EOL] form = ... [EOL] path = ... [EOL] original_value = ... [EOL] [EOL] [EOL] class StringHandler ( BaseHandler [ str , StringFiller , StringForms ] ) : [EOL] [EOL] filler = StringFiller [EOL] [EOL] def simplify ( self , path , value ) : [EOL] if len ( value ) == [number] : [EOL] return self . create_filler ( StringForms . EMPTY , path , value ) [EOL] [EOL] return self . create_filler ( StringForms . FILLED , path , value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $StringForms$ 0 0 0 $types.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[minstrel.jester.handlers.string_handler.StringFiller]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , TypeVar [EOL] import typing [EOL] import types [EOL] from typing import ( Any , Callable , Dict , Generic , Hashable , List , NamedTuple , Set , Type , TypeVar , Union , ) [EOL] from mypy_extensions import Arg [EOL] from collections import defaultdict [EOL] from . . . types import Path [EOL] [EOL] ValueType = TypeVar ( [string] ) [EOL] Forms = TypeVar ( [string] , bound = Hashable ) [EOL] [EOL] [EOL] FillerType = TypeVar ( [string] , bound = Any ) [EOL] [EOL] [EOL] class Filler : [EOL] def __init__ ( self , form , path , original_value ) : [EOL] self . form = form [EOL] self . path = path [EOL] self . original_value = original_value [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . form , self . path ) ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return hash ( self ) == hash ( other ) [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . form , self . path , self . original_value , hash ( self ) ) [EOL] [EOL] [EOL] class ComplexFiller ( Filler ) : [EOL] def __hash__ ( self ) : [EOL] return hash ( ( self . form , self . path , self . original_value ) ) [EOL] [EOL] [EOL] class BaseHandler ( Generic [ ValueType , FillerType , Forms ] ) : [EOL] [EOL] handler_map = ... [EOL] filler = ... [EOL] path_map = ... [EOL] [EOL] simplify_value = ... [EOL] realify_value = ... [EOL] [EOL] def __init__ ( self ) : [EOL] self . path_map = defaultdict ( lambda : defaultdict ( set ) ) [EOL] [EOL] def create_filler ( self , form , path , value ) : [EOL] filler = self . filler ( form , path , value ) [EOL] self . path_map [ path ] [ form ] . add ( filler ) [EOL] return filler [EOL] [EOL] def simplify ( self , path , value ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def realify ( self , path , filler ) : [EOL] return next ( iter ( self . path_map [ path ] [ filler . form ] ) ) . original_value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Type[FillerType]$ 0 0 0 $typing.Dict[types.Path,typing.Dict[Forms,typing.Set[FillerType]]]$ 0 0 0 0 $typing.Callable[[types.Path,typing.Any],typing.Any]$ 0 0 0 $typing.Callable[[types.Path,typing.Any],typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ValueType$ 0 0 0 0 0 $FillerType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $FillerType$ 0 0 0 0 0 0 0 0
import types [EOL] from . . . types import Path [EOL] from . base_handler import BaseHandler [EOL] [EOL] [EOL] class NoneHandler ( BaseHandler [ None , None , None ] ) : [EOL] [EOL] def simplify ( self , path , value ) : [EOL] return None [EOL] [EOL] def realify ( self , path , value ) : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0
import builtins [EOL] import types [EOL] from . . . types import Path [EOL] from . base_handler import BaseHandler [EOL] [EOL] [EOL] class BoolHandler ( BaseHandler [ bool , bool , bool ] ) : [EOL] [EOL] def simplify ( self , path , value ) : [EOL] return value [EOL] [EOL] def realify ( self , path , value ) : [EOL] return value [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0
from typing import Any , Type , Dict , Tuple [EOL] import typing [EOL] from typing import Dict , Tuple , Any [EOL] from frozendict import frozendict [EOL] [EOL] HandlerMap = Dict [ Tuple [ type , ... ] , Any ] [EOL] [EOL] from . array_handler import ArrayHandler [EOL] from . bool_handler import BoolHandler [EOL] from . none_handler import NoneHandler [EOL] from . number_handler import NumberHandler [EOL] from . object_handler import ObjectHandler [EOL] from . string_handler import StringHandler [EOL] [EOL] [EOL] def get_handler_map ( ) : [EOL] return { ( type ( None ) , ) : NoneHandler ( ) , ( bool , ) : BoolHandler ( ) , ( int , float ) : NumberHandler ( ) , ( str , ) : StringHandler ( ) , ( dict , frozendict ) : ObjectHandler ( ) , ( list , tuple ) : ArrayHandler ( ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $HandlerMap$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Dict , Tuple [EOL] import minstrel [EOL] import typing [EOL] import types [EOL] import builtins [EOL] from typing import NamedTuple , Dict [EOL] from frozendict import frozendict [EOL] from . . . types import Path [EOL] from . base_handler import BaseHandler , ComplexFiller [EOL] [EOL] [EOL] class ObjectFiller ( ComplexFiller ) : [EOL] form = ... [EOL] path = ... [EOL] original_value = ... [EOL] [EOL] [EOL] class ObjectHandler ( BaseHandler [ frozendict , ObjectFiller , frozendict ] ) : [EOL] [EOL] pathed_counter = ... [EOL] filler = ObjectFiller [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . pathed_counter = { } [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def simplify ( self , path , value ) : [EOL] self . pathed_counter [ path ] = [number] [EOL] clone = value . copy ( ) [EOL] for key , value in value . items ( ) : [EOL] clone [ key ] = self . simplify_value ( path + ( key , ) , value ) [EOL] [EOL] return self . create_filler ( frozendict , path , frozendict ( clone ) ) [EOL] [EOL] def realify ( self , path , filler ) : [EOL] options = tuple ( self . path_map [ path ] [ frozendict ] ) [EOL] original = options [ self . pathed_counter [ path ] ] . original_value [EOL] if self . pathed_counter [ path ] < len ( options ) - [number] : [EOL] self . pathed_counter [ path ] += [number] [EOL] [EOL] out = { } [EOL] for key , value in original . items ( ) : [EOL] out [ key ] = self . realify_filler ( path + ( key , ) , value ) [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $frozendict.frozendict$ 0 0 0 $types.Path$ 0 0 0 $frozendict.frozendict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.tuple,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type , Tuple , Any , Set , Dict [EOL] import minstrel [EOL] import typing [EOL] import builtins [EOL] import types [EOL] from typing import NamedTuple , Dict , Any [EOL] from enum import Enum , auto [EOL] from collections import defaultdict [EOL] from frozendict import frozendict [EOL] from . . . types import Path [EOL] from . base_handler import BaseHandler , ComplexFiller [EOL] [EOL] [EOL] class ArrayForms ( Enum ) : [EOL] EMPTY = auto ( ) [EOL] FILLED = auto ( ) [EOL] [EOL] [EOL] class ArrayFiller ( ComplexFiller ) : [EOL] form = ... [EOL] path = ... [EOL] original_value = ... [EOL] [EOL] [EOL] class ArrayHandler ( BaseHandler [ tuple , ArrayFiller , ArrayForms ] ) : [EOL] [EOL] pathed_counter = ... [EOL] pathed_types = ... [EOL] [EOL] filler = ArrayFiller [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] self . pathed_counter = { } [EOL] self . pathed_types = defaultdict ( set ) [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] def simplify ( self , path , value ) : [EOL] if len ( value ) == [number] : [EOL] return self . create_filler ( ArrayForms . EMPTY , path , ( ) ) [EOL] [EOL] items = set ( ) [EOL] for index , item in enumerate ( value ) : [EOL] items . add ( self . simplify_value ( path , item ) ) [EOL] items = tuple ( items ) [EOL] [EOL] self . pathed_counter [ path ] = [number] [EOL] self . pathed_types [ path ] . add ( items ) [EOL] [EOL] return self . create_filler ( ArrayForms . FILLED , path , items ) [EOL] [EOL] def realify ( self , path , filler ) : [EOL] if filler . form == ArrayForms . EMPTY : [EOL] return [ ] [EOL] [EOL] options = tuple ( self . pathed_types [ path ] ) [EOL] [EOL] out = [ ] [EOL] for i , option in enumerate ( options [ self . pathed_counter [ path ] ] ) : [EOL] out . append ( self . realify_filler ( path , option ) ) [EOL] [EOL] if self . pathed_counter [ path ] < len ( options ) - [number] : [EOL] self . pathed_counter [ path ] += [number] [EOL] return out [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ArrayForms$ 0 0 0 $types.Path$ 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.tuple,builtins.int]$ 0 0 0 $typing.Dict[builtins.tuple,builtins.set]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type [EOL] import minstrel [EOL] import typing [EOL] from typing import Dict , NamedTuple [EOL] from enum import Enum , auto [EOL] from . . . types import Number , Path [EOL] from . base_handler import BaseHandler , Filler [EOL] [EOL] [EOL] class NumberForms ( Enum ) : [EOL] ZERO = auto ( ) [EOL] POSITIVE = auto ( ) [EOL] POSITIVE_FLOAT = auto ( ) [EOL] NEGATIVE = auto ( ) [EOL] NEGATIVE_FLOAT = auto ( ) [EOL] [EOL] [EOL] class NumberFiller ( Filler ) : [EOL] form = ... [EOL] path = ... [EOL] original_value = ... [EOL] [EOL] [EOL] class NumberHandler ( BaseHandler [ Number , NumberFiller , NumberForms ] ) : [EOL] [EOL] filler = NumberFiller [EOL] [EOL] def simplify ( self , path , value ) : [EOL] if value == [number] : [EOL] return self . create_filler ( NumberForms . ZERO , path , value ) [EOL] [EOL] if value > [number] : [EOL] form = NumberForms . POSITIVE [EOL] if value != int ( value ) : [EOL] form = NumberForms . POSITIVE_FLOAT [EOL] else : [EOL] form = NumberForms . NEGATIVE [EOL] if value != int ( value ) : [EOL] form = NumberForms . NEGATIVE_FLOAT [EOL] [EOL] return self . create_filler ( form , path , value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $NumberForms$ 0 0 0 $types.Path$ 0 0 0 $types.Number$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[minstrel.jester.handlers.number_handler.NumberFiller]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Optional , Union , Dict , List [EOL] import typing [EOL] import pytest [EOL] from minstrel . handling import handle_dicts [EOL] [EOL] [EOL] def test_handle_dicts ( ) : [EOL] d1 = { [string] : [number] , [string] : None , } [EOL] d2 = { [string] : [number] , [string] : None , } [EOL] d3 = { [string] : - [number] , [string] : None , } [EOL] [EOL] base , derivatives = handle_dicts ( [ d1 , d2 , d3 ] ) [EOL] assert len ( derivatives ) == [number] [EOL] [EOL] [EOL] def test_nested_dicts ( ) : [EOL] d1 = { [string] : { [string] : [number] , [string] : None , } , } [EOL] d2 = { [string] : { [string] : [number] , [string] : [number] , } , } [EOL] d3 = d2 . copy ( ) [EOL] [EOL] base , derivatives = handle_dicts ( [ d1 , d2 , d3 ] ) [EOL] assert len ( derivatives ) == [number] [EOL] [EOL] d4 = { [string] : { [string] : True , [string] : [string] , } , } [EOL] [EOL] d5 = d3 . copy ( ) [EOL] [EOL] base , derivatives = handle_dicts ( [ d1 , d2 , d3 , d4 , d5 ] ) [EOL] assert len ( derivatives ) == [number] [EOL] assert base == d1 or base == d2 or base == d3 [EOL] assert d4 in derivatives [EOL] [EOL] [EOL] def test_arrays ( ) : [EOL] d1 = { [string] : [ [number] , [number] , [number] ] , } [EOL] d2 = { [string] : [ ] , } [EOL] d3 = { [string] : [ [number] , [number] ] , } [EOL] d4 = { [string] : [ [string] , [string] , [number] ] , } [EOL] [EOL] base , derivatives = handle_dicts ( [ d1 , d2 , d3 , d4 ] ) [EOL] assert len ( derivatives ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0