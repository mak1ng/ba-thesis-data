from typing import List , Any [EOL] import typing [EOL] import data_structures [EOL] [docstring] [EOL] from __future__ import print_function [EOL] class Node : [EOL] [EOL] def __init__ ( self , label , parent ) : [EOL] self . label = label [EOL] self . left = None [EOL] self . right = None [EOL] [comment] [EOL] self . parent = parent [EOL] [EOL] def getLabel ( self ) : [EOL] return self . label [EOL] [EOL] def setLabel ( self , label ) : [EOL] self . label = label [EOL] [EOL] def getLeft ( self ) : [EOL] return self . left [EOL] [EOL] def setLeft ( self , left ) : [EOL] self . left = left [EOL] [EOL] def getRight ( self ) : [EOL] return self . right [EOL] [EOL] def setRight ( self , right ) : [EOL] self . right = right [EOL] [EOL] def getParent ( self ) : [EOL] return self . parent [EOL] [EOL] def setParent ( self , parent ) : [EOL] self . parent = parent [EOL] [EOL] class BinarySearchTree : [EOL] [EOL] def __init__ ( self ) : [EOL] self . root = None [EOL] [EOL] def insert ( self , label ) : [EOL] [comment] [EOL] new_node = Node ( label , None ) [EOL] [comment] [EOL] if self . empty ( ) : [EOL] self . root = new_node [EOL] else : [EOL] [comment] [EOL] curr_node = self . root [EOL] [comment] [EOL] while curr_node is not None : [EOL] [comment] [EOL] parent_node = curr_node [EOL] [comment] [EOL] if new_node . getLabel ( ) < curr_node . getLabel ( ) : [EOL] [comment] [EOL] curr_node = curr_node . getLeft ( ) [EOL] else : [EOL] [comment] [EOL] curr_node = curr_node . getRight ( ) [EOL] [comment] [EOL] if new_node . getLabel ( ) < parent_node . getLabel ( ) : [EOL] parent_node . setLeft ( new_node ) [EOL] else : [EOL] parent_node . setRight ( new_node ) [EOL] [comment] [EOL] new_node . setParent ( parent_node ) [EOL] [EOL] def delete ( self , label ) : [EOL] if ( not self . empty ( ) ) : [EOL] [comment] [EOL] node = self . getNode ( label ) [EOL] [comment] [EOL] if ( node is not None ) : [EOL] [comment] [EOL] if ( node . getLeft ( ) is None and node . getRight ( ) is None ) : [EOL] self . __reassignNodes ( node , None ) [EOL] node = None [EOL] [comment] [EOL] elif ( node . getLeft ( ) is None and node . getRight ( ) is not None ) : [EOL] self . __reassignNodes ( node , node . getRight ( ) ) [EOL] [comment] [EOL] elif ( node . getLeft ( ) is not None and node . getRight ( ) is None ) : [EOL] self . __reassignNodes ( node , node . getLeft ( ) ) [EOL] [comment] [EOL] else : [EOL] [comment] [EOL] tmpNode = self . getMax ( node . getLeft ( ) ) [EOL] [comment] [EOL] self . delete ( tmpNode . getLabel ( ) ) [EOL] [comment] [EOL] node . setLabel ( tmpNode . getLabel ( ) ) [EOL] [EOL] def getNode ( self , label ) : [EOL] curr_node = None [EOL] [comment] [EOL] if ( not self . empty ( ) ) : [EOL] [comment] [EOL] curr_node = self . getRoot ( ) [EOL] [comment] [EOL] [comment] [EOL] while curr_node is not None and curr_node . getLabel ( ) is not label : [EOL] [comment] [EOL] if label < curr_node . getLabel ( ) : [EOL] [comment] [EOL] curr_node = curr_node . getLeft ( ) [EOL] else : [EOL] [comment] [EOL] curr_node = curr_node . getRight ( ) [EOL] return curr_node [EOL] [EOL] def getMax ( self , root = None ) : [EOL] if ( root is not None ) : [EOL] curr_node = root [EOL] else : [EOL] [comment] [EOL] curr_node = self . getRoot ( ) [EOL] if ( not self . empty ( ) ) : [EOL] while ( curr_node . getRight ( ) is not None ) : [EOL] curr_node = curr_node . getRight ( ) [EOL] return curr_node [EOL] [EOL] def getMin ( self , root = None ) : [EOL] if ( root is not None ) : [EOL] curr_node = root [EOL] else : [EOL] [comment] [EOL] curr_node = self . getRoot ( ) [EOL] if ( not self . empty ( ) ) : [EOL] curr_node = self . getRoot ( ) [EOL] while ( curr_node . getLeft ( ) is not None ) : [EOL] curr_node = curr_node . getLeft ( ) [EOL] return curr_node [EOL] [EOL] def empty ( self ) : [EOL] if self . root is None : [EOL] return True [EOL] return False [EOL] [EOL] def __InOrderTraversal ( self , curr_node ) : [EOL] nodeList = [ ] [EOL] if curr_node is not None : [EOL] nodeList . insert ( [number] , curr_node ) [EOL] nodeList = nodeList + self . __InOrderTraversal ( curr_node . getLeft ( ) ) [EOL] nodeList = nodeList + self . __InOrderTraversal ( curr_node . getRight ( ) ) [EOL] return nodeList [EOL] [EOL] def getRoot ( self ) : [EOL] return self . root [EOL] [EOL] def __isRightChildren ( self , node ) : [EOL] if ( node == node . getParent ( ) . getRight ( ) ) : [EOL] return True [EOL] return False [EOL] [EOL] def __reassignNodes ( self , node , newChildren ) : [EOL] if ( newChildren is not None ) : [EOL] newChildren . setParent ( node . getParent ( ) ) [EOL] if ( node . getParent ( ) is not None ) : [EOL] [comment] [EOL] if ( self . __isRightChildren ( node ) ) : [EOL] node . getParent ( ) . setRight ( newChildren ) [EOL] else : [EOL] [comment] [EOL] node . getParent ( ) . setLeft ( newChildren ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def traversalTree ( self , traversalFunction = None , root = None ) : [EOL] if ( traversalFunction is None ) : [EOL] [comment] [EOL] return self . __InOrderTraversal ( self . root ) [EOL] else : [EOL] [comment] [EOL] return traversalFunction ( self . root ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def __str__ ( self ) : [EOL] list = self . __InOrderTraversal ( self . root ) [EOL] str = [string] [EOL] for x in list : [EOL] str = str + [string] + x . getLabel ( ) . __str__ ( ) [EOL] return str [EOL] [EOL] def InPreOrder ( curr_node ) : [EOL] nodeList = [ ] [EOL] if curr_node is not None : [EOL] nodeList = nodeList + InPreOrder ( curr_node . getLeft ( ) ) [EOL] nodeList . insert ( [number] , curr_node . getLabel ( ) ) [EOL] nodeList = nodeList + InPreOrder ( curr_node . getRight ( ) ) [EOL] return nodeList [EOL] [EOL] def testBinarySearchTree ( ) : [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] t = BinarySearchTree ( ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] t . insert ( [number] ) [EOL] [EOL] [comment] [EOL] print ( t . __str__ ( ) ) [EOL] [EOL] if ( t . getNode ( [number] ) is not None ) : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] if ( t . getNode ( - [number] ) is not None ) : [EOL] print ( [string] ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] if ( not t . empty ( ) ) : [EOL] print ( ( [string] , t . getMax ( ) . getLabel ( ) ) ) [EOL] print ( ( [string] , t . getMin ( ) . getLabel ( ) ) ) [EOL] [EOL] t . delete ( [number] ) [EOL] t . delete ( [number] ) [EOL] t . delete ( [number] ) [EOL] t . delete ( [number] ) [EOL] t . delete ( [number] ) [EOL] t . delete ( [number] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] list = t . traversalTree ( InPreOrder , t . root ) [EOL] for x in list : [EOL] print ( x ) [EOL] [EOL] if __name__ == [string] : [EOL] testBinarySearchTree ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 $data_structures.binary_tree.binary_search_tree.Node$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $str$ 0 0 0 0 0 0 $typing.Any$ 0 0 $str$ 0 $str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] from __future__ import print_function [EOL] from __future__ import absolute_import [EOL] import string [EOL] [EOL] from . Stack import Stack [EOL] [EOL] __author__ = [string] [EOL] [EOL] [EOL] def is_operand ( char ) : [EOL] return char in string . ascii_letters or char in string . digits [EOL] [EOL] [EOL] def precedence ( char ) : [EOL] [docstring] [EOL] dictionary = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] return dictionary . get ( char , - [number] ) [EOL] [EOL] [EOL] def infix_to_postfix ( expression ) : [EOL] [docstring] [EOL] stack = Stack ( len ( expression ) ) [EOL] postfix = [ ] [EOL] for char in expression : [EOL] if is_operand ( char ) : [EOL] postfix . append ( char ) [EOL] elif char not in { [string] , [string] } : [EOL] while ( not stack . is_empty ( ) [EOL] and precedence ( char ) <= precedence ( stack . peek ( ) ) ) : [EOL] postfix . append ( stack . pop ( ) ) [EOL] stack . push ( char ) [EOL] elif char == [string] : [EOL] stack . push ( char ) [EOL] elif char == [string] : [EOL] while not stack . is_empty ( ) and stack . peek ( ) != [string] : [EOL] postfix . append ( stack . pop ( ) ) [EOL] [comment] [EOL] [comment] [EOL] if stack . peek ( ) != [string] : [EOL] raise ValueError ( [string] ) [EOL] stack . pop ( ) [EOL] while not stack . is_empty ( ) : [EOL] postfix . append ( stack . pop ( ) ) [EOL] return [string] . join ( postfix ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] expression = [string] [EOL] [EOL] print ( [string] ) [EOL] print ( [string] + expression ) [EOL] print ( [string] + infix_to_postfix ( expression ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
import builtins [EOL] from typing import List , Any , Callable [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] [EOL] def insertion_sort ( collection ) : [EOL] [docstring] [EOL] [EOL] for loop_index in range ( [number] , len ( collection ) ) : [EOL] insertion_index = loop_index [EOL] while insertion_index > [number] and collection [ insertion_index - [number] ] > collection [ insertion_index ] : [EOL] collection [ insertion_index ] , collection [ insertion_index - [number] ] = collection [ insertion_index - [number] ] , collection [ insertion_index ] [EOL] insertion_index -= [number] [EOL] [EOL] return collection [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] user_input = raw_input ( [string] ) . strip ( ) [EOL] unsorted = [ int ( item ) for item in user_input . split ( [string] ) ] [EOL] print ( insertion_sort ( unsorted ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0
from typing import IO , Any [EOL] import typing [EOL] from __future__ import print_function [EOL] from random import randint [EOL] from tempfile import TemporaryFile [EOL] import numpy as np [EOL] [EOL] [EOL] [EOL] def _inPlaceQuickSort ( A , start , end ) : [EOL] count = [number] [EOL] if start < end : [EOL] pivot = randint ( start , end ) [EOL] temp = A [ end ] [EOL] A [ end ] = A [ pivot ] [EOL] A [ pivot ] = temp [EOL] [EOL] p , count = _inPlacePartition ( A , start , end ) [EOL] count += _inPlaceQuickSort ( A , start , p - [number] ) [EOL] count += _inPlaceQuickSort ( A , p + [number] , end ) [EOL] return count [EOL] [EOL] def _inPlacePartition ( A , start , end ) : [EOL] [EOL] count = [number] [EOL] pivot = randint ( start , end ) [EOL] temp = A [ end ] [EOL] A [ end ] = A [ pivot ] [EOL] A [ pivot ] = temp [EOL] newPivotIndex = start - [number] [EOL] for index in range ( start , end ) : [EOL] [EOL] count += [number] [EOL] if A [ index ] < A [ end ] :[comment] [EOL] newPivotIndex = newPivotIndex + [number] [EOL] temp = A [ newPivotIndex ] [EOL] A [ newPivotIndex ] = A [ index ] [EOL] A [ index ] = temp [EOL] [EOL] temp = A [ newPivotIndex + [number] ] [EOL] A [ newPivotIndex + [number] ] = A [ end ] [EOL] A [ end ] = temp [EOL] return newPivotIndex + [number] , count [EOL] [EOL] outfile = TemporaryFile ( ) [EOL] p = [number] [comment] [EOL] [EOL] [EOL] [EOL] [EOL] mu , sigma = [number] , [number] [comment] [EOL] X = np . random . normal ( mu , sigma , p ) [EOL] np . save ( outfile , X ) [EOL] print ( [string] ) [EOL] print ( X ) [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] [EOL] outfile . seek ( [number] ) [comment] [EOL] M = np . load ( outfile ) [EOL] r = ( len ( M ) - [number] ) [EOL] z = _inPlaceQuickSort ( M , [number] , r ) [EOL] [EOL] print ( [string] ) [EOL] print ( z ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.IO[builtins.bytes]$ 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def decimal_to_binary ( num ) : [EOL] [docstring] [EOL] binary = [ ] [EOL] while num > [number] : [EOL] binary . insert ( [number] , num % [number] ) [EOL] num >>= [number] [EOL] return [string] . join ( str ( e ) for e in binary ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] print ( decimal_to_binary ( [number] ) ) [comment] [EOL] print ( [string] ) [EOL] print ( decimal_to_binary ( [number] ) ) [comment] [EOL] print ( [string] ) [EOL] print ( decimal_to_binary ( [number] ) ) [comment] [EOL] print ( [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from math import factorial [EOL] def main ( ) : [EOL] print ( sum ( [ int ( x ) for x in str ( factorial ( [number] ) ) ] ) ) [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Callable [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] n = int ( raw_input ( ) . strip ( ) ) [EOL] print ( sum ( [ e for e in range ( [number] , n ) if e % [number] == [number] or e % [number] == [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
a = [number] [EOL] result = [number] [EOL] while a < [number] : [EOL] if ( a % [number] == [number] or a % [number] == [number] ) : [EOL] result += a [EOL] elif ( a % [number] == [number] ) : [EOL] result -= a [EOL] a += [number] [EOL] print ( result ) [EOL]	$builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0
[comment] [EOL] [docstring] [EOL] from __future__ import print_function [EOL] n = int ( input ( ) ) [EOL] suma = n * ( n + [number] ) / [number] [EOL] suma **= [number] [EOL] sumb = n * ( n + [number] ) * ( [number] * n + [number] ) / [number] [EOL] print ( suma - sumb ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0
[comment] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] suma = [number] [EOL] sumb = [number] [EOL] n = int ( input ( ) ) [EOL] for i in range ( [number] , n + [number] ) : [EOL] suma += i ** [number] [EOL] sumb += i [EOL] sum = sumb ** [number] - suma [EOL] print ( sum ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0
from functools import reduce [EOL] [EOL] def main ( ) : [EOL] number = input ( ) . strip ( ) [EOL] print ( max ( [ reduce ( lambda x , y : int ( x ) * int ( y ) , number [ i : i + [number] ] ) for i in range ( len ( number ) - [number] ) ] ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from itertools import permutations [EOL] def main ( ) : [EOL] result = list ( map ( [string] . join , permutations ( [string] ) ) ) [EOL] print ( result [ [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import print_function [EOL] n = [number] ** [number] [EOL] r = [number] [EOL] while n : [EOL] r , n = r + n % [number] , n // [number] [EOL] print ( r ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type [EOL] import typing [EOL] from __future__ import print_function [EOL] [docstring] [EOL] [EOL] try : [EOL] xrange [EOL] except NameError : [EOL] xrange = range [EOL] [EOL] total = [number] [EOL] for i in xrange ( [number] , [number] ) : [EOL] total += i ** i [EOL] [EOL] [EOL] print ( str ( total ) [ - [number] : ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Type[builtins.range]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
sum = [number] [EOL] with open ( [string] , [string] ) as f : [EOL] for line in f : [EOL] sum += int ( line ) [EOL] print ( str ( sum ) [ : [number] ] ) [EOL]	$builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] n = int ( input ( ) . strip ( ) ) [EOL] [EOL] array = [ ] [EOL] for i in range ( n ) : [EOL] array . append ( int ( input ( ) . strip ( ) ) ) [EOL] [EOL] print ( str ( sum ( array ) ) [ : [number] ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] def fibonacci_genrator ( ) : [EOL] a , b = [number] , [number] [EOL] while True : [EOL] a , b = b , a + b [EOL] yield b [EOL] answer = [number] [EOL] gen = fibonacci_genrator ( ) [EOL] while len ( str ( next ( gen ) ) ) < [number] : [EOL] answer += [number] [EOL] assert answer + [number] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [EOL] grid = [ [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ] [EOL] [EOL] [docstring] [EOL] [EOL] init = [ [number] , [number] ] [EOL] goal = [ len ( grid ) - [number] , len ( grid [ [number] ] ) - [number] ] [comment] [EOL] cost = [number] [EOL] [EOL] [comment] [EOL] heuristic = [ [ [number] for row in range ( len ( grid [ [number] ] ) ) ] for col in range ( len ( grid ) ) ] [EOL] for i in range ( len ( grid ) ) : [EOL] for j in range ( len ( grid [ [number] ] ) ) : [EOL] heuristic [ i ] [ j ] = abs ( i - goal [ [number] ] ) + abs ( j - goal [ [number] ] ) [EOL] if grid [ i ] [ j ] == [number] : [EOL] heuristic [ i ] [ j ] = [number] [comment] [EOL] [EOL] [EOL] [comment] [EOL] delta = [ [ - [number] , [number] ] , [ [number] , - [number] ] , [ [number] , [number] ] , [ [number] , [number] ] ] [comment] [EOL] [EOL] [EOL] [comment] [EOL] def search ( grid , init , goal , cost , heuristic ) : [EOL] [EOL] closed = [ [ [number] for col in range ( len ( grid [ [number] ] ) ) ] for row in range ( len ( grid ) ) ][comment] [EOL] closed [ init [ [number] ] ] [ init [ [number] ] ] = [number] [EOL] action = [ [ [number] for col in range ( len ( grid [ [number] ] ) ) ] for row in range ( len ( grid ) ) ][comment] [EOL] [EOL] x = init [ [number] ] [EOL] y = init [ [number] ] [EOL] g = [number] [EOL] f = g + heuristic [ init [ [number] ] ] [ init [ [number] ] ] [EOL] cell = [ [ f , g , x , y ] ] [EOL] [EOL] found = False [comment] [EOL] resign = False [comment] [EOL] [EOL] while not found and not resign : [EOL] if len ( cell ) == [number] : [EOL] resign = True [EOL] return [string] [EOL] else : [EOL] cell . sort ( )[comment] [EOL] cell . reverse ( ) [EOL] next = cell . pop ( ) [EOL] x = next [ [number] ] [EOL] y = next [ [number] ] [EOL] g = next [ [number] ] [EOL] f = next [ [number] ] [EOL] [EOL] [EOL] if x == goal [ [number] ] and y == goal [ [number] ] : [EOL] found = True [EOL] else : [EOL] for i in range ( len ( delta ) ) :[comment] [EOL] x2 = x + delta [ i ] [ [number] ] [EOL] y2 = y + delta [ i ] [ [number] ] [EOL] if x2 >= [number] and x2 < len ( grid ) and y2 >= [number] and y2 < len ( grid [ [number] ] ) : [EOL] if closed [ x2 ] [ y2 ] == [number] and grid [ x2 ] [ y2 ] == [number] : [EOL] g2 = g + cost [EOL] f2 = g2 + heuristic [ x2 ] [ y2 ] [EOL] cell . append ( [ f2 , g2 , x2 , y2 ] ) [EOL] closed [ x2 ] [ y2 ] = [number] [EOL] action [ x2 ] [ y2 ] = i [EOL] invpath = [ ] [EOL] x = goal [ [number] ] [EOL] y = goal [ [number] ] [EOL] invpath . append ( [ x , y ] )[comment] [EOL] while x != init [ [number] ] or y != init [ [number] ] : [EOL] x2 = x - delta [ action [ x ] [ y ] ] [ [number] ] [EOL] y2 = y - delta [ action [ x ] [ y ] ] [ [number] ] [EOL] x = x2 [EOL] y = y2 [EOL] invpath . append ( [ x , y ] ) [EOL] [EOL] path = [ ] [EOL] for i in range ( len ( invpath ) ) : [EOL] path . append ( invpath [ len ( invpath ) - [number] - i ] ) [EOL] print ( [string] ) [EOL] for i in range ( len ( action ) ) : [EOL] print ( action [ i ] ) [EOL] [EOL] return path [EOL] [EOL] a = search ( grid , init , goal , cost , heuristic ) [EOL] for i in range ( len ( a ) ) : [EOL] print ( a [ i ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List , Any , DefaultDict [EOL] import typing [EOL] import sys [EOL] from collections import defaultdict [EOL] [EOL] def PrimsAlgorithm ( l ) : [EOL] [EOL] nodePosition = [ ] [EOL] def getPosition ( vertex ) : [EOL] return nodePosition [ vertex ] [EOL] [EOL] def setPosition ( vertex , pos ) : [EOL] nodePosition [ vertex ] = pos [EOL] [EOL] def topToBottom ( heap , start , size , positions ) : [EOL] if start > size // [number] - [number] : [EOL] return [EOL] else : [EOL] if [number] * start + [number] >= size : [EOL] m = [number] * start + [number] [EOL] else : [EOL] if heap [ [number] * start + [number] ] < heap [ [number] * start + [number] ] : [EOL] m = [number] * start + [number] [EOL] else : [EOL] m = [number] * start + [number] [EOL] if heap [ m ] < heap [ start ] : [EOL] temp , temp1 = heap [ m ] , positions [ m ] [EOL] heap [ m ] , positions [ m ] = heap [ start ] , positions [ start ] [EOL] heap [ start ] , positions [ start ] = temp , temp1 [EOL] [EOL] temp = getPosition ( positions [ m ] ) [EOL] setPosition ( positions [ m ] , getPosition ( positions [ start ] ) ) [EOL] setPosition ( positions [ start ] , temp ) [EOL] [EOL] topToBottom ( heap , m , size , positions ) [EOL] [EOL] [comment] [EOL] def bottomToTop ( val , index , heap , position ) : [EOL] temp = position [ index ] [EOL] [EOL] while ( index != [number] ) : [EOL] if index % [number] == [number] : [EOL] parent = int ( ( index - [number] ) / [number] ) [EOL] else : [EOL] parent = int ( ( index - [number] ) / [number] ) [EOL] [EOL] if val < heap [ parent ] : [EOL] heap [ index ] = heap [ parent ] [EOL] position [ index ] = position [ parent ] [EOL] setPosition ( position [ parent ] , index ) [EOL] else : [EOL] heap [ index ] = val [EOL] position [ index ] = temp [EOL] setPosition ( temp , index ) [EOL] break [EOL] index = parent [EOL] else : [EOL] heap [ [number] ] = val [EOL] position [ [number] ] = temp [EOL] setPosition ( temp , [number] ) [EOL] [EOL] def heapify ( heap , positions ) : [EOL] start = len ( heap ) // [number] - [number] [EOL] for i in range ( start , - [number] , - [number] ) : [EOL] topToBottom ( heap , i , len ( heap ) , positions ) [EOL] [EOL] def deleteMinimum ( heap , positions ) : [EOL] temp = positions [ [number] ] [EOL] heap [ [number] ] = sys . maxsize [EOL] topToBottom ( heap , [number] , len ( heap ) , positions ) [EOL] return temp [EOL] [EOL] visited = [ [number] for i in range ( len ( l ) ) ] [EOL] Nbr_TV = [ - [number] for i in range ( len ( l ) ) ] [comment] [EOL] [comment] [EOL] Distance_TV = [ ] [comment] [EOL] Positions = [ ] [EOL] [EOL] for x in range ( len ( l ) ) : [EOL] p = sys . maxsize [EOL] Distance_TV . append ( p ) [EOL] Positions . append ( x ) [EOL] nodePosition . append ( x ) [EOL] [EOL] TreeEdges = [ ] [EOL] visited [ [number] ] = [number] [EOL] Distance_TV [ [number] ] = sys . maxsize [EOL] for x in l [ [number] ] : [EOL] Nbr_TV [ x [ [number] ] ] = [number] [EOL] Distance_TV [ x [ [number] ] ] = x [ [number] ] [EOL] heapify ( Distance_TV , Positions ) [EOL] [EOL] for i in range ( [number] , len ( l ) ) : [EOL] vertex = deleteMinimum ( Distance_TV , Positions ) [EOL] if visited [ vertex ] == [number] : [EOL] TreeEdges . append ( ( Nbr_TV [ vertex ] , vertex ) ) [EOL] visited [ vertex ] = [number] [EOL] for v in l [ vertex ] : [EOL] if visited [ v [ [number] ] ] == [number] and v [ [number] ] < Distance_TV [ getPosition ( v [ [number] ] ) ] : [EOL] Distance_TV [ getPosition ( v [ [number] ] ) ] = v [ [number] ] [EOL] bottomToTop ( v [ [number] ] , getPosition ( v [ [number] ] ) , Distance_TV , Positions ) [EOL] Nbr_TV [ v [ [number] ] ] = vertex [EOL] return TreeEdges [EOL] [EOL] [comment] [EOL] n = int ( input ( [string] ) ) [EOL] e = int ( input ( [string] ) ) [EOL] adjlist = defaultdict ( list ) [EOL] for x in range ( e ) : [EOL] l = [ int ( x ) for x in input ( ) . split ( ) ] [EOL] adjlist [ l [ [number] ] ] . append ( [ l [ [number] ] , l [ [number] ] ] ) [EOL] adjlist [ l [ [number] ] ] . append ( [ l [ [number] ] , l [ [number] ] ] ) [EOL] print ( PrimsAlgorithm ( adjlist ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[typing.Any,typing.List[typing.Any]]$ 0 0 0
[comment] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] def computeAP ( l ) : [EOL] n = len ( l ) [EOL] outEdgeCount = [number] [EOL] low = [ [number] ] * n [EOL] visited = [ False ] * n [EOL] isArt = [ False ] * n [EOL] [EOL] def dfs ( root , at , parent , outEdgeCount ) : [EOL] if parent == root : [EOL] outEdgeCount += [number] [EOL] visited [ at ] = True [EOL] low [ at ] = at [EOL] [EOL] for to in l [ at ] : [EOL] if to == parent : [EOL] pass [EOL] elif not visited [ to ] : [EOL] outEdgeCount = dfs ( root , to , at , outEdgeCount ) [EOL] low [ at ] = min ( low [ at ] , low [ to ] ) [EOL] [EOL] [comment] [EOL] if at < low [ to ] : [EOL] isArt [ at ] = True [EOL] [comment] [EOL] if at == low [ to ] : [EOL] isArt [ at ] = True [EOL] else : [EOL] low [ at ] = min ( low [ at ] , to ) [EOL] return outEdgeCount [EOL] [EOL] for i in range ( n ) : [EOL] if not visited [ i ] : [EOL] outEdgeCount = [number] [EOL] outEdgeCount = dfs ( i , i , - [number] , outEdgeCount ) [EOL] isArt [ i ] = ( outEdgeCount > [number] ) [EOL] [EOL] for x in range ( len ( isArt ) ) : [EOL] if isArt [ x ] == True : [EOL] print ( x ) [EOL] [EOL] [comment] [EOL] l = { [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] , [number] , [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] ] , [number] : [ [number] , [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] , [number] : [ [number] , [number] ] } [EOL] computeAP ( l ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.int]]$ 0 0
from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] def naivePatternSearch ( mainString , pattern ) : [EOL] patLen = len ( pattern ) [EOL] strLen = len ( mainString ) [EOL] position = [ ] [EOL] for i in range ( strLen - patLen + [number] ) : [EOL] match_found = True [EOL] for j in range ( patLen ) : [EOL] if mainString [ i + j ] != pattern [ j ] : [EOL] match_found = False [EOL] break [EOL] if match_found : [EOL] position . append ( i ) [EOL] return position [EOL] [EOL] mainString = [string] [EOL] pattern = [string] [EOL] position = naivePatternSearch ( mainString , pattern ) [EOL] print ( [string] ) [EOL] for x in position : [EOL] print ( x )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def generate_all_subsequences ( sequence ) : [EOL] create_state_space_tree ( sequence , [ ] , [number] ) [EOL] [EOL] [EOL] def create_state_space_tree ( sequence , current_subsequence , index ) : [EOL] [docstring] [EOL] [EOL] if index == len ( sequence ) : [EOL] print ( current_subsequence ) [EOL] return [EOL] [EOL] create_state_space_tree ( sequence , current_subsequence , index + [number] ) [EOL] current_subsequence . append ( sequence [ index ] ) [EOL] create_state_space_tree ( sequence , current_subsequence , index + [number] ) [EOL] current_subsequence . pop ( ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] sequence = [ [number] , [number] , [number] , [number] ] [EOL] generate_all_subsequences ( sequence ) [EOL] [EOL] sequence = [ [string] , [string] , [string] ] [EOL] generate_all_subsequences ( sequence ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0
[docstring] [EOL] [EOL] [EOL] def abs_val ( num ) : [EOL] [docstring] [EOL] if num < [number] : [EOL] return - num [EOL] [EOL] [comment] [EOL] return num [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] print ( abs_val ( - [number] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL]	0
def fact ( n ) : [EOL] [docstring] [EOL] return [number] if n <= [number] else n * fact ( n - [number] ) [EOL] [EOL] [EOL] [docstring] [EOL] for i in range ( [number] , [number] ) : [EOL] print ( i , [string] , fact ( i ) , sep = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] def find_max ( nums ) : [EOL] max = nums [ [number] ] [EOL] for x in nums : [EOL] if x > max : [EOL] max = x [EOL] print ( max ) [EOL] [EOL] def main ( ) : [EOL] find_max ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple , List [EOL] [EOL] def n31 ( a ) : [EOL] [docstring] [EOL] [EOL] if not isinstance ( a , int ) : [EOL] raise TypeError ( [string] . format ( type ( a ) . __name__ ) ) [EOL] if a < [number] : [EOL] raise ValueError ( [string] . format ( a ) ) [EOL] [EOL] path = [ a ] [EOL] while a != [number] : [EOL] if a % [number] == [number] : [EOL] a = a // [number] [EOL] else : [EOL] a = [number] * a + [number] [EOL] path += [ a ] [EOL] return path , len ( path ) [EOL] [EOL] def main ( ) : [EOL] num = [number] [EOL] path , length = n31 ( num ) [EOL] print ( [string] . format ( num , length , path ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.List[builtins.int],builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [comment] [EOL] NUM = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] FACTORIAL = [number] [EOL] [EOL] [comment] [EOL] if NUM < [number] : [EOL] print ( [string] ) [EOL] elif NUM == [number] : [EOL] print ( [string] ) [EOL] else : [EOL] for i in range ( [number] , NUM + [number] ) : [EOL] FACTORIAL = FACTORIAL * i [EOL] print ( [string] , NUM , [string] , FACTORIAL ) [EOL]	0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def main ( ) : [EOL] [docstring] [EOL] def find_min ( x ) : [EOL] min_num = x [ [number] ] [EOL] for i in x : [EOL] if min_num > i : [EOL] min_num = i [EOL] return min_num [EOL] [EOL] print ( find_min ( [ [number] , [number] , [number] , [number] , [number] , [number] , - [number] , [number] , - [number] ] ) ) [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from sklearn . model_selection import train_test_split [EOL] from sklearn . datasets import load_iris [EOL] from sklearn . neighbors import KNeighborsClassifier [EOL] [EOL] [comment] [EOL] iris = load_iris ( ) [EOL] iris . keys ( ) [EOL] [EOL] [EOL] print ( [string] . format ( iris . target_names ) ) [EOL] print ( [string] . format ( iris . feature_names ) ) [EOL] [EOL] [comment] [EOL] X_train , X_test , y_train , y_test = train_test_split ( iris [ [string] ] , iris [ [string] ] , random_state = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] knn = KNeighborsClassifier ( n_neighbors = [number] ) [EOL] knn . fit ( X_train , y_train ) [EOL] [EOL] [comment] [EOL] X_new = [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] [EOL] [EOL] prediction = knn . predict ( X_new ) [EOL] [EOL] print ( [string] [string] . format ( X_new , iris [ [string] ] [ prediction ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] from __future__ import print_function [EOL] [comment] [EOL] [EOL] def euclidean_gcd ( a , b ) : [EOL] while b : [EOL] t = b [EOL] b = a % b [EOL] a = t [EOL] return a [EOL] [EOL] def main ( ) : [EOL] print ( [string] + str ( euclidean_gcd ( [number] , [number] ) ) ) [EOL] print ( [string] + str ( euclidean_gcd ( [number] , [number] ) ) ) [EOL] print ( [string] + str ( euclidean_gcd ( [number] , [number] ) ) ) [EOL] print ( [string] + str ( euclidean_gcd ( [number] , [number] ) ) ) [EOL] print ( [string] + str ( euclidean_gcd ( [number] , [number] ) ) ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from __future__ import print_function [EOL] import sys , random [EOL] [EOL] LETTERS = [string] [EOL] [EOL] def main ( ) : [EOL] message = input ( [string] ) [EOL] key = [string] [EOL] resp = input ( [string] ) [EOL] [EOL] checkValidKey ( key ) [EOL] [EOL] if resp . lower ( ) . startswith ( [string] ) : [EOL] mode = [string] [EOL] translated = encryptMessage ( key , message ) [EOL] elif resp . lower ( ) . startswith ( [string] ) : [EOL] mode = [string] [EOL] translated = decryptMessage ( key , message ) [EOL] [EOL] print ( [string] % ( mode . title ( ) , translated ) ) [EOL] [EOL] def checkValidKey ( key ) : [EOL] keyList = list ( key ) [EOL] lettersList = list ( LETTERS ) [EOL] keyList . sort ( ) [EOL] lettersList . sort ( ) [EOL] [EOL] if keyList != lettersList : [EOL] sys . exit ( [string] ) [EOL] [EOL] def encryptMessage ( key , message ) : [EOL] [docstring] [EOL] return translateMessage ( key , message , [string] ) [EOL] [EOL] def decryptMessage ( key , message ) : [EOL] [docstring] [EOL] return translateMessage ( key , message , [string] ) [EOL] [EOL] def translateMessage ( key , message , mode ) : [EOL] translated = [string] [EOL] charsA = LETTERS [EOL] charsB = key [EOL] [EOL] if mode == [string] : [EOL] charsA , charsB = charsB , charsA [EOL] [EOL] for symbol in message : [EOL] if symbol . upper ( ) in charsA : [EOL] symIndex = charsA . find ( symbol . upper ( ) ) [EOL] if symbol . isupper ( ) : [EOL] translated += charsB [ symIndex ] . upper ( ) [EOL] else : [EOL] translated += charsB [ symIndex ] . lower ( ) [EOL] else : [EOL] translated += symbol [EOL] [EOL] return translated [EOL] [EOL] def getRandomKey ( ) : [EOL] key = list ( LETTERS ) [EOL] random . shuffle ( key ) [EOL] return [string] . join ( key ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
def encrypt ( strng , key ) : [EOL] encrypted = [string] [EOL] for x in strng : [EOL] indx = ( ord ( x ) + key ) % [number] [EOL] if indx > [number] : [EOL] indx = indx - [number] [EOL] encrypted = encrypted + chr ( indx ) [EOL] return encrypted [EOL] [EOL] [EOL] def decrypt ( strng , key ) : [EOL] decrypted = [string] [EOL] for x in strng : [EOL] indx = ( ord ( x ) - key ) % [number] [EOL] if indx < [number] : [EOL] indx = indx + [number] [EOL] decrypted = decrypted + chr ( indx ) [EOL] return decrypted [EOL] [EOL] def brute_force ( strng ) : [EOL] key = [number] [EOL] decrypted = [string] [EOL] while key <= [number] : [EOL] for x in strng : [EOL] indx = ( ord ( x ) - key ) % [number] [EOL] if indx < [number] : [EOL] indx = indx + [number] [EOL] decrypted = decrypted + chr ( indx ) [EOL] print ( [string] . format ( key , decrypted ) ) [EOL] decrypted = [string] [EOL] key += [number] [EOL] return None [EOL] [EOL] [EOL] def main ( ) : [EOL] while True : [EOL] print ( [string] * [number] + [string] + [string] * [number] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] print ( [string] ) [EOL] choice = input ( [string] ) [EOL] if choice not in [ [string] , [string] , [string] , [string] ] : [EOL] print ( [string] ) [EOL] elif choice == [string] : [EOL] strng = input ( [string] ) [EOL] key = int ( input ( [string] ) ) [EOL] if key in range ( [number] , [number] ) : [EOL] print ( encrypt ( strng . lower ( ) , key ) ) [EOL] elif choice == [string] : [EOL] strng = input ( [string] ) [EOL] key = int ( input ( [string] ) ) [EOL] if key in range ( [number] , [number] ) : [EOL] print ( decrypt ( strng , key ) ) [EOL] elif choice == [string] : [EOL] strng = input ( [string] ) [EOL] brute_force ( strng ) [EOL] main ( ) [EOL] elif choice == [string] : [EOL] print ( [string] ) [EOL] break [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import math [EOL] [EOL] def intersection ( function , x0 , x1 ) : [comment] [EOL] x_n = x0 [EOL] x_n1 = x1 [EOL] while True : [EOL] x_n2 = x_n1 - ( function ( x_n1 ) / ( ( function ( x_n1 ) - function ( x_n ) ) / ( x_n1 - x_n ) ) ) [EOL] if abs ( x_n2 - x_n1 ) < [number] ** - [number] : [EOL] return x_n2 [EOL] x_n = x_n1 [EOL] x_n1 = x_n2 [EOL] [EOL] def f ( x ) : [EOL] return math . pow ( x , [number] ) - ( [number] * x ) - [number] [EOL] [EOL] if __name__ == [string] : [EOL] print ( intersection ( f , [number] , [number] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import ftplib [EOL] [docstring] [EOL] [EOL] from ftplib import FTP [EOL] ftp = FTP ( [string] ) [comment] [EOL] ftp . login ( user = [string] , passwd = [string] ) [EOL] ftp . cwd ( [string] ) [EOL] [EOL] [docstring] [EOL] [EOL] def ReceiveFile ( ) : [EOL] FileName = [string] [string] [EOL] with open ( FileName , [string] ) as LocalFile : [EOL] ftp . retrbinary ( [string] + FileName , LocalFile . write , [number] ) [EOL] ftp . quit ( ) [EOL] [EOL] [docstring] [EOL] [EOL] def SendFile ( ) : [EOL] FileName = [string] [string] [EOL] with open ( FileName , [string] ) as LocalFile : [EOL] ftp . storbinary ( [string] + FileName , LocalFile ) [EOL] ftp . quit ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0 0 0 0 0 0 $ftplib.FTP$ 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Callable [EOL] import queue [EOL] import typing [EOL] import traversals [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] import queue [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] [EOL] class TreeNode : [EOL] def __init__ ( self , data ) : [EOL] self . data = data [EOL] self . right = None [EOL] self . left = None [EOL] [EOL] [EOL] def build_tree ( ) : [EOL] print ( [string] ) [EOL] print ( [string] , end = [string] ) [EOL] check = raw_input ( ) . strip ( ) . lower ( ) [EOL] if check == [string] : [EOL] return None [EOL] data = int ( check ) [EOL] q = queue . Queue ( ) [EOL] tree_node = TreeNode ( data ) [EOL] q . put ( tree_node ) [EOL] while not q . empty ( ) : [EOL] node_found = q . get ( ) [EOL] print ( [string] % node_found . data , end = [string] ) [EOL] check = raw_input ( ) . strip ( ) . lower ( ) [EOL] if check == [string] : [EOL] return tree_node [EOL] left_data = int ( check ) [EOL] left_node = TreeNode ( left_data ) [EOL] node_found . left = left_node [EOL] q . put ( left_node ) [EOL] print ( [string] % node_found . data , end = [string] ) [EOL] check = raw_input ( ) . strip ( ) . lower ( ) [EOL] if check == [string] : [EOL] return tree_node [EOL] right_data = int ( check ) [EOL] right_node = TreeNode ( right_data ) [EOL] node_found . right = right_node [EOL] q . put ( right_node ) [EOL] [EOL] [EOL] def pre_order ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] print ( node . data , end = [string] ) [EOL] pre_order ( node . left ) [EOL] pre_order ( node . right ) [EOL] [EOL] [EOL] def in_order ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] in_order ( node . left ) [EOL] print ( node . data , end = [string] ) [EOL] in_order ( node . right ) [EOL] [EOL] [EOL] def post_order ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] post_order ( node . left ) [EOL] post_order ( node . right ) [EOL] print ( node . data , end = [string] ) [EOL] [EOL] [EOL] def level_order ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] q = queue . Queue ( ) [EOL] q . put ( node ) [EOL] while not q . empty ( ) : [EOL] node_dequeued = q . get ( ) [EOL] print ( node_dequeued . data , end = [string] ) [EOL] if node_dequeued . left : [EOL] q . put ( node_dequeued . left ) [EOL] if node_dequeued . right : [EOL] q . put ( node_dequeued . right ) [EOL] [EOL] [EOL] def level_order_actual ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] q = queue . Queue ( ) [EOL] q . put ( node ) [EOL] while not q . empty ( ) : [EOL] list = [ ] [EOL] while not q . empty ( ) : [EOL] node_dequeued = q . get ( ) [EOL] print ( node_dequeued . data , end = [string] ) [EOL] if node_dequeued . left : [EOL] list . append ( node_dequeued . left ) [EOL] if node_dequeued . right : [EOL] list . append ( node_dequeued . right ) [EOL] print ( ) [EOL] for node in list : [EOL] q . put ( node ) [EOL] [EOL] [EOL] [comment] [EOL] def pre_order_iter ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] stack = [ ] [EOL] n = node [EOL] while n or stack : [EOL] while n : [comment] [EOL] print ( n . data , end = [string] ) [EOL] stack . append ( n ) [EOL] n = n . left [EOL] [comment] [EOL] n = stack . pop ( ) [EOL] [comment] [EOL] n = n . right [EOL] [EOL] [EOL] def in_order_iter ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] stack = [ ] [EOL] n = node [EOL] while n or stack : [EOL] while n : [EOL] stack . append ( n ) [EOL] n = n . left [EOL] n = stack . pop ( ) [EOL] print ( n . data , end = [string] ) [EOL] n = n . right [EOL] [EOL] [EOL] def post_order_iter ( node ) : [EOL] if not isinstance ( node , TreeNode ) or not node : [EOL] return [EOL] stack1 , stack2 = [ ] , [ ] [EOL] n = node [EOL] stack1 . append ( n ) [EOL] while stack1 : [comment] [EOL] n = stack1 . pop ( ) [EOL] if n . left : [EOL] stack1 . append ( n . left ) [EOL] if n . right : [EOL] stack1 . append ( n . right ) [EOL] stack2 . append ( n ) [EOL] while stack2 : [comment] [EOL] print ( stack2 . pop ( ) . data , end = [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] [EOL] node = build_tree ( ) [EOL] print ( [string] ) [EOL] pre_order ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] in_order ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] post_order ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] level_order ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] level_order_actual ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] pre_order_iter ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] in_order_iter ( node ) [EOL] print ( [string] ) [EOL] [EOL] print ( [string] ) [EOL] post_order_iter ( node ) [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
from typing import List , Any , Callable [EOL] import typing [EOL] import builtins [EOL] import dynamic_programming [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] [EOL] class EditDistance : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . __prepare__ ( ) [EOL] [EOL] def __prepare__ ( self , N = [number] , M = [number] ) : [EOL] self . dp = [ [ - [number] for y in range ( [number] , M ) ] for x in range ( [number] , N ) ] [EOL] [EOL] def __solveDP ( self , x , y ) : [EOL] if ( x == - [number] ) : [EOL] return y + [number] [EOL] elif ( y == - [number] ) : [EOL] return x + [number] [EOL] elif ( self . dp [ x ] [ y ] > - [number] ) : [EOL] return self . dp [ x ] [ y ] [EOL] else : [EOL] if ( self . A [ x ] == self . B [ y ] ) : [EOL] self . dp [ x ] [ y ] = self . __solveDP ( x - [number] , y - [number] ) [EOL] else : [EOL] self . dp [ x ] [ y ] = [number] + min ( self . __solveDP ( x , y - [number] ) , self . __solveDP ( x - [number] , y ) , self . __solveDP ( x - [number] , y - [number] ) ) [EOL] [EOL] return self . dp [ x ] [ y ] [EOL] [EOL] def solve ( self , A , B ) : [EOL] if isinstance ( A , bytes ) : [EOL] A = A . decode ( [string] ) [EOL] [EOL] if isinstance ( B , bytes ) : [EOL] B = B . decode ( [string] ) [EOL] [EOL] self . A = str ( A ) [EOL] self . B = str ( B ) [EOL] [EOL] self . __prepare__ ( len ( A ) , len ( B ) ) [EOL] [EOL] return self . __solveDP ( len ( A ) - [number] , len ( B ) - [number] ) [EOL] [EOL] [EOL] def min_distance_bottom_up ( word1 , word2 ) : [EOL] [docstring] [EOL] m = len ( word1 ) [EOL] n = len ( word2 ) [EOL] dp = [ [ [number] for _ in range ( n + [number] ) ] for _ in range ( m + [number] ) ] [EOL] for i in range ( m + [number] ) : [EOL] for j in range ( n + [number] ) : [EOL] [EOL] if i == [number] : [comment] [EOL] dp [ i ] [ j ] = j [EOL] elif j == [number] : [comment] [EOL] dp [ i ] [ j ] = i [EOL] elif word1 [ i - [number] ] == word2 [ j - [number] ] : [comment] [EOL] dp [ i ] [ j ] = dp [ i - [number] ] [ j - [number] ] [EOL] else : [EOL] insert = dp [ i ] [ j - [number] ] [EOL] delete = dp [ i - [number] ] [ j ] [EOL] replace = dp [ i - [number] ] [ j - [number] ] [EOL] dp [ i ] [ j ] = [number] + min ( insert , delete , replace ) [EOL] return dp [ m ] [ n ] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] solver = EditDistance ( ) [EOL] [EOL] print ( [string] ) [EOL] print ( ) [EOL] [EOL] print ( [string] , end = [string] ) [EOL] S1 = raw_input ( ) . strip ( ) [EOL] [EOL] print ( [string] , end = [string] ) [EOL] S2 = raw_input ( ) . strip ( ) [EOL] [EOL] print ( ) [EOL] print ( [string] % ( solver . solve ( S1 , S2 ) ) ) [EOL] print ( [string] % ( min_distance_bottom_up ( S1 , S2 ) ) ) [EOL] print ( ) [EOL] print ( [string] ) [EOL] [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dynamic_programming.edit_distance.EditDistance$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dynamic_programming.edit_distance.EditDistance$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import List , Any [EOL] import typing [EOL] def compare_string ( string1 , string2 ) : [EOL] l1 = list ( string1 ) ; l2 = list ( string2 ) [EOL] count = [number] [EOL] for i in range ( len ( l1 ) ) : [EOL] if l1 [ i ] != l2 [ i ] : [EOL] count += [number] [EOL] l1 [ i ] = [string] [EOL] if count > [number] : [EOL] return - [number] [EOL] else : [EOL] return ( [string] . join ( l1 ) ) [EOL] [EOL] def check ( binary ) : [EOL] pi = [ ] [EOL] while [number] : [EOL] check1 = [ [string] ] * len ( binary ) [EOL] temp = [ ] [EOL] for i in range ( len ( binary ) ) : [EOL] for j in range ( i + [number] , len ( binary ) ) : [EOL] k = compare_string ( binary [ i ] , binary [ j ] ) [EOL] if k != - [number] : [EOL] check1 [ i ] = [string] [EOL] check1 [ j ] = [string] [EOL] temp . append ( k ) [EOL] for i in range ( len ( binary ) ) : [EOL] if check1 [ i ] == [string] : [EOL] pi . append ( binary [ i ] ) [EOL] if len ( temp ) == [number] : [EOL] return pi [EOL] binary = list ( set ( temp ) ) [EOL] [EOL] def decimal_to_binary ( no_of_variable , minterms ) : [EOL] temp = [ ] [EOL] s = [string] [EOL] for m in minterms : [EOL] for i in range ( no_of_variable ) : [EOL] s = str ( m % [number] ) + s [EOL] m //= [number] [EOL] temp . append ( s ) [EOL] s = [string] [EOL] return temp [EOL] [EOL] def is_for_table ( string1 , string2 , count ) : [EOL] l1 = list ( string1 ) ; l2 = list ( string2 ) [EOL] count_n = [number] [EOL] for i in range ( len ( l1 ) ) : [EOL] if l1 [ i ] != l2 [ i ] : [EOL] count_n += [number] [EOL] if count_n == count : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] def selection ( chart , prime_implicants ) : [EOL] temp = [ ] [EOL] select = [ [number] ] * len ( chart ) [EOL] for i in range ( len ( chart [ [number] ] ) ) : [EOL] count = [number] [EOL] rem = - [number] [EOL] for j in range ( len ( chart ) ) : [EOL] if chart [ j ] [ i ] == [number] : [EOL] count += [number] [EOL] rem = j [EOL] if count == [number] : [EOL] select [ rem ] = [number] [EOL] for i in range ( len ( select ) ) : [EOL] if select [ i ] == [number] : [EOL] for j in range ( len ( chart [ [number] ] ) ) : [EOL] if chart [ i ] [ j ] == [number] : [EOL] for k in range ( len ( chart ) ) : [EOL] chart [ k ] [ j ] = [number] [EOL] temp . append ( prime_implicants [ i ] ) [EOL] while [number] : [EOL] max_n = [number] ; rem = - [number] ; count_n = [number] [EOL] for i in range ( len ( chart ) ) : [EOL] count_n = chart [ i ] . count ( [number] ) [EOL] if count_n > max_n : [EOL] max_n = count_n [EOL] rem = i [EOL] [EOL] if max_n == [number] : [EOL] return temp [EOL] [EOL] temp . append ( prime_implicants [ rem ] ) [EOL] [EOL] for i in range ( len ( chart [ [number] ] ) ) : [EOL] if chart [ rem ] [ i ] == [number] : [EOL] for j in range ( len ( chart ) ) : [EOL] chart [ j ] [ i ] = [number] [EOL] [EOL] def prime_implicant_chart ( prime_implicants , binary ) : [EOL] chart = [ [ [number] for x in range ( len ( binary ) ) ] for x in range ( len ( prime_implicants ) ) ] [EOL] for i in range ( len ( prime_implicants ) ) : [EOL] count = prime_implicants [ i ] . count ( [string] ) [EOL] for j in range ( len ( binary ) ) : [EOL] if ( is_for_table ( prime_implicants [ i ] , binary [ j ] , count ) ) : [EOL] chart [ i ] [ j ] = [number] [EOL] [EOL] return chart [EOL] [EOL] def main ( ) : [EOL] no_of_variable = int ( input ( [string] ) ) [EOL] minterms = [ int ( x ) for x in input ( [string] ) . split ( ) ] [EOL] binary = decimal_to_binary ( no_of_variable , minterms ) [EOL] [EOL] prime_implicants = check ( binary ) [EOL] print ( [string] ) [EOL] print ( prime_implicants ) [EOL] chart = prime_implicant_chart ( prime_implicants , binary ) [EOL] [EOL] essential_prime_implicants = selection ( chart , prime_implicants ) [EOL] print ( [string] ) [EOL] print ( essential_prime_implicants ) [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any , Callable [EOL] import typing [EOL] [docstring] [EOL] from __future__ import print_function [EOL] [EOL] try : [EOL] raw_input [comment] [EOL] except NameError : [EOL] raw_input = input [comment] [EOL] [EOL] def linear_search ( sequence , target ) : [EOL] [docstring] [EOL] for index , item in enumerate ( sequence ) : [EOL] if item == target : [EOL] return index [EOL] return None [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] user_input = raw_input ( [string] ) . strip ( ) [EOL] sequence = [ int ( item ) for item in user_input . split ( [string] ) ] [EOL] [EOL] target_input = raw_input ( [string] ) [EOL] target = int ( target_input ) [EOL] result = linear_search ( sequence , target ) [EOL] if result is not None : [EOL] print ( [string] . format ( target , result ) ) [EOL] else : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.int]$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0