	0
from typing import Any [EOL] import typing [EOL] import os [EOL] from urllib . parse import urljoin [EOL] [EOL] from kbase_cache_client import KBaseCacheClient [EOL] [EOL] [EOL] def load_config ( ) : [EOL] kbase_endpoint = os . environ . get ( [string] , [string] ) [EOL] service_token = os . environ [ [string] ] [EOL] caching_service_url = os . environ . get ( [string] , urljoin ( kbase_endpoint + [string] , [string] ) ) [EOL] id_mapper_url = os . environ . get ( [string] , urljoin ( kbase_endpoint + [string] , [string] ) ) [EOL] homology_url = os . environ . get ( [string] , [string] ) [EOL] client = KBaseCacheClient ( kbase_endpoint , token = service_token ) [EOL] return { [string] : homology_url , [string] : id_mapper_url , [string] : caching_service_url , [string] : service_token , [string] : kbase_endpoint , [string] : client } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class InvalidJSON ( Exception ) : [EOL] [EOL] def __init__ ( self , msg ) : [EOL] self . message = msg [EOL] [EOL] [EOL] class InvalidParams ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , req_id , msg ) : [EOL] self . req_id = req_id [EOL] self . message = msg [EOL] [EOL] [EOL] class UnknownMethod ( Exception ) : [EOL] [EOL] def __init__ ( self , req_id , msg ) : [EOL] self . req_id = req_id [EOL] self . message = msg [EOL] [EOL] [EOL] class UnrecognizedWSType ( Exception ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , typ , valid_types ) : [EOL] self . typ = typ [EOL] self . valid_types = valid_types [EOL] [EOL] def __str__ ( self ) : [EOL] return ( [string] + self . typ + [string] + str ( self . valid_types . values ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import requests [EOL] import time [EOL] import os [EOL] import sys [EOL] import requests [EOL] [EOL] from . map_refseq_ids import map_refseq_ids_to_kbase [EOL] from . map_strains import map_strains [EOL] [EOL] [EOL] def perform_search ( sketch_path , db_name , max_results = [number] ) : [EOL] [docstring] [EOL] print ( [string] ) [EOL] start_time = time . time ( ) [EOL] homology_url = os . environ . get ( [string] , [string] ) [EOL] path = [string] + db_name + [string] [EOL] with open ( sketch_path , [string] ) as fd : [EOL] response = _retry_request ( homology_url + path , fd , { [string] : max_results } ) [EOL] print ( [string] , time . time ( ) - start_time ) [EOL] resp_json = response . json ( ) [EOL] [comment] [EOL] if db_name == [string] : [EOL] resp_json [ [string] ] = map_refseq_ids_to_kbase ( resp_json [ [string] ] ) [EOL] resp_json [ [string] ] = map_strains ( resp_json [ [string] ] ) [EOL] return resp_json [EOL] [EOL] [EOL] def _retry_request ( url , data , params , max_retries = [number] ) : [EOL] [docstring] [EOL] tries = [number] [EOL] start = time . time ( ) [EOL] while True : [EOL] try : [EOL] resp = requests . post ( url , data = data , params = params , timeout = [number] ) [EOL] if resp . ok : [EOL] return resp [EOL] except Exception as err : [EOL] elapsed = time . time ( ) - start [EOL] sys . stderr . write ( f" [string] { err } [string] " ) [EOL] tries += [number] [EOL] sys . stderr . write ( f" [string] { elapsed } [string] " ) [EOL] if resp : [EOL] sys . stderr . write ( resp . text + [string] ) [EOL] if tries > max_retries : [EOL] elapsed = time . time ( ) - start [EOL] raise RuntimeError ( f" [string] { elapsed } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import requests [EOL] import json [EOL] import requests [EOL] [EOL] from src . config import load_config [EOL] [EOL] [EOL] def map_refseq_ids_to_kbase ( distances ) : [EOL] [docstring] [EOL] [comment] [EOL] config = load_config ( ) [EOL] refseq_ids = [ d [ [string] ] for d in distances ] [EOL] req_data = { [string] : refseq_ids } [EOL] req_json = json . dumps ( req_data ) [EOL] endpoint = config [ [string] ] + [string] [EOL] print ( f" [string] { refseq_ids } [string] { endpoint }" ) [EOL] resp = requests . get ( endpoint , data = req_json , timeout = [number] ) [EOL] [comment] [EOL] if not resp . ok : [EOL] print ( [string] * [number] ) [EOL] print ( f' [string] { resp . status_code }' ) [EOL] print ( resp . text ) [EOL] print ( [string] * [number] ) [EOL] raise Exception ( f" [string] { resp . text }" ) [EOL] resp_json = resp . json ( ) [EOL] print ( [string] , resp . text ) [EOL] [comment] [EOL] indexes = { } [EOL] for ( idx , dist ) in enumerate ( distances ) : [EOL] indexes [ dist [ [string] ] ] = idx [EOL] [comment] [EOL] for ( refseq_id , result ) in resp_json . items ( ) : [EOL] distance_idx = indexes [ refseq_id ] [EOL] mappings = result [ [string] ] [EOL] for mapping in mappings : [EOL] if [string] == mapping [ [string] ] : [EOL] kbase_id = mapping [ [string] ] [EOL] distances [ distance_idx ] [ [string] ] = kbase_id [EOL] return distances [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import pandas as pd [EOL] import os [EOL] [EOL] [EOL] def map_strains ( distances ) : [EOL] [comment] [EOL] curr_path = __file__ [EOL] csv_path = os . path . join ( os . path . dirname ( curr_path ) , [string] , [string] ) [EOL] df = pd . read_csv ( csv_path ) [EOL] refseq_ids = [ d [ [string] ] for d in distances ] [EOL] df = df [ df [ [string] ] . isin ( refseq_ids ) ] [EOL] d = dict ( zip ( df [ [string] ] , df [ [string] ] ) ) [EOL] for i , dist in enumerate ( distances ) : [EOL] if dist [ [string] ] not in d : [EOL] dist [ [string] ] = None [EOL] else : [EOL] dist [ [string] ] = d [ dist [ [string] ] ] [EOL] distances [ i ] = dist [EOL] return distances [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] from kbase_workspace_client import WorkspaceClient [EOL] [EOL] from src . exceptions import UnrecognizedWSType [EOL] from src . config import load_config [EOL] [EOL] [EOL] [comment] [EOL] valid_types = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def autodownload ( ref , save_dir , auth_token ) : [EOL] [docstring] [EOL] config = load_config ( ) [EOL] ws = WorkspaceClient ( url = config [ [string] ] , token = auth_token ) [EOL] ws_obj = ws . req ( [string] , { [string] : [ { [string] : ref } ] , [string] : [number] } ) [EOL] [EOL] ws_type = ws_obj [ [string] ] [ [number] ] [ [string] ] [ [number] ] [EOL] if valid_types [ [string] ] in ws_type : [EOL] paths = ws . download_reads_fastq ( ref , save_dir ) [EOL] output_path = paths [ [number] ] . replace ( [string] , [string] ) [EOL] concatenate_files ( paths , output_path ) [EOL] print ( f' [string] { output_path }' ) [EOL] return ( output_path , True ) [EOL] elif valid_types [ [string] ] in ws_type : [EOL] paths = ws . download_reads_fastq ( ref , save_dir ) [EOL] output_path = paths [ [number] ] [EOL] print ( f' [string] { output_path }' ) [EOL] return ( output_path , False ) [EOL] elif valid_types [ [string] ] in ws_type or valid_types [ [string] ] in ws_type : [EOL] path = ws . download_assembly_fasta ( ref , save_dir ) [EOL] print ( f' [string] { path }' ) [EOL] return ( path , False ) [EOL] elif valid_types [ [string] ] in ws_type : [EOL] ref = ws . get_assembly_from_genome ( ref ) [EOL] path = ws . download_assembly_fasta ( ref , save_dir ) [EOL] print ( f' [string] { path }' ) [EOL] return ( path , False ) [EOL] else : [EOL] raise UnrecognizedWSType ( ws_type , valid_types ) [EOL] [EOL] [EOL] def concatenate_files ( input_paths , output_path ) : [EOL] [docstring] [EOL] with open ( output_path , [string] ) as fd_write : [EOL] for path in input_paths : [EOL] with open ( path , [string] ) as fd_read : [EOL] for line in fd_read : [EOL] fd_write . write ( line ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import tempfile [EOL] [EOL] from src . config import load_config [EOL] [EOL] [EOL] def upload_to_cache ( cache_id , string ) : [EOL] [docstring] [EOL] config = load_config ( ) [EOL] print ( f' [string] { cache_id [ [number] : [number] ] } [string] ' ) [EOL] config [ [string] ] . upload_cache ( cache_id , string = string ) [EOL] [EOL] [EOL] def get_cache_id ( data ) : [EOL] [comment] [EOL] config = load_config ( ) [EOL] cache_id = config [ [string] ] . generate_cacheid ( data ) [EOL] print ( f' [string] { cache_id [ [number] : [number] ] } [string] ' ) [EOL] return cache_id [EOL] [EOL] [EOL] def download_cache_string ( cache_id ) : [EOL] [docstring] [EOL] config = load_config ( ) [EOL] with tempfile . NamedTemporaryFile ( ) as fd : [EOL] config [ [string] ] . download_cache ( cache_id , fd . name ) [EOL] contents = fd . read ( ) . decode ( ) [EOL] print ( f' [string] { cache_id [ [number] : [number] ] } [string] ' ) [EOL] return contents [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import requests [EOL] import subprocess [EOL] import os [EOL] import subprocess [comment] [EOL] import requests [EOL] [EOL] from src . config import load_config [EOL] [EOL] [EOL] def generate_sketch ( file_path , search_db , paired_end = False ) : [EOL] [docstring] [EOL] config = load_config ( ) [EOL] [comment] [EOL] url = f"{ config [ [string] ] } [string] { search_db }" [EOL] resp = requests . get ( url , timeout = [number] ) [EOL] json_resp = resp . json ( ) [EOL] sketch_size = str ( json_resp . get ( [string] , [number] ) ) [EOL] kmer_size = json_resp . get ( [string] , [number] ) [EOL] if isinstance ( kmer_size , list ) : [EOL] kmer_size = kmer_size [ [number] ] [EOL] output_name = os . path . basename ( file_path + [string] ) [EOL] output_path = os . path . join ( os . path . dirname ( file_path ) , output_name ) [EOL] args = [ [string] , [string] , file_path , [string] , output_path , [string] , str ( kmer_size ) , [string] , sketch_size ] [EOL] print ( f" [string] { [string] . join ( args ) }" ) [EOL] if paired_end : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] args += [ [string] , [string] ] [EOL] proc = subprocess . Popen ( args , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [comment] [EOL] ( stdout , stderr ) = proc . communicate ( ) [EOL] print ( [string] * [number] ) [EOL] print ( [string] ) [EOL] print ( stdout ) [EOL] print ( stderr ) [EOL] print ( [string] * [number] ) [EOL] if proc . returncode != [number] : [EOL] raise Exception ( f" [string] { stderr }" ) [EOL] return output_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Dict , Any , Union [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import os [EOL] import json [EOL] import unittest [EOL] import requests [EOL] from dotenv import load_dotenv [EOL] [EOL] load_dotenv ( [string] ) [EOL] [EOL] [EOL] [comment] [EOL] url = [string] [EOL] service_token = os . environ [ [string] ] [EOL] os . environ [ [string] ] = [string] [EOL] [EOL] [EOL] def make_request ( ws_ref ) : [EOL] [docstring] [EOL] post_data = { [string] : { [string] : ws_ref , [string] : [number] , [string] : True } , [string] : [string] , [string] : [number] } [EOL] headers = { [string] : [string] , [string] : service_token } [EOL] resp = requests . post ( url , data = json . dumps ( post_data ) , headers = headers ) [EOL] return resp . json ( ) [EOL] [EOL] [EOL] class TestApi ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] def test_search_reads_paired ( self ) : [EOL] [docstring] [EOL] reads_ref = [string] [EOL] json_resp = make_request ( reads_ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_reads_single ( self ) : [EOL] [docstring] [EOL] reads_ref = [string] [EOL] json_resp = make_request ( reads_ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_genome ( self ) : [EOL] [docstring] [EOL] genome_ref = [string] [EOL] json_resp = make_request ( genome_ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_genome_no_auth ( self ) : [EOL] [docstring] [EOL] genome_ref = [string] [EOL] post_data = { [string] : { [string] : genome_ref } , [string] : [string] , [string] : [number] } [EOL] headers = { [string] : [string] } [EOL] resp = requests . post ( url , data = json . dumps ( post_data ) , headers = headers ) [EOL] json_resp = resp . json ( ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_assembly ( self ) : [EOL] [docstring] [EOL] assembly_ref = [string] [EOL] json_resp = make_request ( assembly_ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_assembly_contigset ( self ) : [EOL] [docstring] [EOL] assembly_ref = [string] [EOL] json_resp = make_request ( assembly_ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( len ( result [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_genome_no_assembly_ref ( self ) : [EOL] [docstring] [EOL] genome_ref = [string] [EOL] json_resp = make_request ( genome_ref ) [EOL] self . assertTrue ( [string] in json_resp [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] def test_search_invalid_ws_id ( self ) : [EOL] [docstring] [EOL] ref = [string] [EOL] json_resp = make_request ( ref ) [EOL] self . assertTrue ( len ( json_resp [ [string] ] [ [string] ] ) ) [EOL] [EOL] [comment] [EOL] def test_search_strain ( self ) : [EOL] ref = [string] [EOL] json_resp = make_request ( ref ) [EOL] result = json_resp [ [string] ] [EOL] self . assertTrue ( [string] in result [ [string] ] [ [number] ] ) [EOL] [EOL] [comment] [EOL] def test_search_unauthorized_ws_id ( self ) : [EOL] [docstring] [EOL] ref = [string] [EOL] json_resp = make_request ( ref ) [EOL] self . assertTrue ( len ( json_resp [ [string] ] [ [string] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int,builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $typing.Any$ 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0