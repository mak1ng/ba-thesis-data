[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class Types : [EOL] [docstring] [EOL] string = [string] [EOL] table = [string] [EOL] array = [string] [EOL] integer = [string] [EOL] float = [string] [EOL] boolean = [string] [EOL] array_of_tables = [string] [EOL] path = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [EOL] class ELIBConfigError ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] from pkg_resources import DistributionNotFound , get_distribution [EOL] [EOL] [comment] [EOL] from elib_config . _file . _exc import ( ConfigFileNotFoundError , EmptyValueError , IncompleteSetupError , ) [EOL] [comment] [EOL] from elib_config . _types import Types [EOL] [comment] [EOL] from elib_config . _value . _exc import ( ConfigMissingValueError , ConfigValueError , ConfigValueTypeError , DuplicateConfigValueError , MissingTableKeyError , MissingValueError , NotAFileError , NotAFolderError , OutOfBoundError , PathMustExistError , TableKeyTypeError , ) [EOL] [comment] [EOL] from . _file . _config_example import write_example_config [EOL] [comment] [EOL] from . _logging import LOGGER [EOL] from . _setup import ELIBConfig [EOL] from . _validate import validate_config [EOL] [comment] [EOL] from . _value . _config_value import SENTINEL [EOL] [comment] [EOL] from . _value . _config_value_bool import ConfigValueBool [EOL] [comment] [EOL] from . _value . _config_value_float import ConfigValueFloat [EOL] [comment] [EOL] from . _value . _config_value_integer import ConfigValueInteger [EOL] [comment] [EOL] from . _value . _config_value_list import ConfigValueList [EOL] [comment] [EOL] from . _value . _config_value_path import ConfigValuePath [EOL] [comment] [EOL] from . _value . _config_value_string import ConfigValueString [EOL] [comment] [EOL] from . _value . _config_value_table import ConfigValueTableArray , ConfigValueTableKey [EOL] [EOL] try : [EOL] __version__ = get_distribution ( [string] ) . version [EOL] except DistributionNotFound : [comment] [EOL] [comment] [EOL] __version__ = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] LOGGER . setLevel ( logging . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Set , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from elib_config . _setup import ELIBConfig [EOL] [comment] [EOL] from elib_config . _value . _config_value import ConfigValue [EOL] [comment] [EOL] from elib_config . _value . _exc import DuplicateConfigValueError , MissingValueError [EOL] [EOL] [EOL] def validate_config ( raise_ = True ) : [EOL] [docstring] [EOL] ELIBConfig . check ( ) [EOL] known_paths = set ( ) [EOL] duplicate_values = set ( ) [EOL] missing_values = set ( ) [EOL] for config_value in ConfigValue . config_values : [EOL] if config_value . path not in known_paths : [EOL] known_paths . add ( config_value . path ) [EOL] else : [EOL] duplicate_values . add ( config_value . name ) [EOL] try : [EOL] config_value ( ) [EOL] except MissingValueError : [EOL] missing_values . add ( config_value . name ) [EOL] [EOL] if raise_ and duplicate_values : [EOL] raise DuplicateConfigValueError ( str ( duplicate_values ) ) [EOL] if raise_ and missing_values : [EOL] raise MissingValueError ( str ( missing_values ) , [string] ) [EOL] return duplicate_values , missing_values [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict , Type [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] [EOL] import tomlkit . container [EOL] import tomlkit . items [EOL] [EOL] from elib_config . _logging import LOGGER [EOL] from elib_config . _types import Types [EOL] [EOL] _TRANSLATE_TYPE = { bool : Types . boolean , str : Types . string , tomlkit . items . String : Types . string , int : Types . integer , tomlkit . items . Integer : Types . integer , float : Types . float , tomlkit . items . Float : Types . float , list : Types . array , dict : Types . table , tomlkit . container . Container : Types . table , } [EOL] [EOL] [EOL] def friendly_type_name ( raw_type ) : [EOL] [docstring] [EOL] try : [EOL] return _TRANSLATE_TYPE [ raw_type ] [EOL] except KeyError : [EOL] LOGGER . error ( [string] , raw_type ) [EOL] return str ( raw_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [comment] [EOL] from elib_config . _exc import ELIBConfigError [EOL] [EOL] [EOL] class _ConfigFileError ( ELIBConfigError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file_path , msg ) : [EOL] self . config_file_path = config_file_path [EOL] self . msg = msg [EOL] super ( _ConfigFileError , self ) . __init__ ( f'{ config_file_path } [string] { msg }' ) [EOL] [EOL] [EOL] class IncompleteSetupError ( ELIBConfigError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ConfigFileNotFoundError ( _ConfigFileError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file_path ) : [EOL] super ( ConfigFileNotFoundError , self ) . __init__ ( config_file_path , [string] ) [EOL] [EOL] [EOL] class EmptyValueError ( _ConfigFileError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , config_file_path , line_no ) : [EOL] super ( EmptyValueError , self ) . __init__ ( config_file_path , [string] + str ( line_no ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0
[comment] [EOL] from typing import Union , Container , List , Dict , Any [EOL] from collections import defaultdict [EOL] import collections [EOL] import tomlkit [EOL] import typing [EOL] import elib_config [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] import uuid [EOL] from collections import defaultdict [EOL] [EOL] import tomlkit [EOL] from tomlkit . container import Container as TOMLContainer [EOL] [EOL] from elib_config . _file . _config_example_header import HEADER [EOL] [comment] [EOL] from elib_config . _setup import ELIBConfig [EOL] [comment] [EOL] from elib_config . _value . _config_value import ConfigValue [EOL] [EOL] _NOT_SET = uuid . uuid4 ( ) . hex [EOL] [EOL] [EOL] def _nested_default_dict ( ) : [EOL] return defaultdict ( _nested_default_dict ) [EOL] [EOL] [EOL] def _default_dict_to_dict ( source ) : [EOL] for key , value in source . items ( ) : [EOL] if isinstance ( value , dict ) : [EOL] source [ key ] = _default_dict_to_dict ( value ) [EOL] return dict ( source ) [EOL] [EOL] [EOL] def _get_header ( ) : [EOL] return HEADER . format ( app_version = ELIBConfig . app_version , app_name = ELIBConfig . app_name , config_file_path = ELIBConfig . config_file_path , sep = ELIBConfig . config_sep_str , ) . split ( [string] ) + [ [string] , [string] ] [EOL] [EOL] [EOL] def _aggregate_config_values ( config_values ) : [EOL] [docstring] [EOL] _keys = _nested_default_dict ( ) [EOL] _sorted_values = sorted ( config_values , key = lambda x : x . name ) [EOL] for value in _sorted_values : [EOL] value_keys = value . path . split ( ELIBConfig . config_sep_str ) [EOL] this_config_key = _keys [EOL] for sub_key in value_keys [ : - [number] ] : [EOL] this_config_key = this_config_key [ sub_key ] [EOL] this_config_key [ value_keys [ - [number] ] ] = value [EOL] return _default_dict_to_dict ( _keys ) [EOL] [EOL] [EOL] def _add_config_values_to_toml_object ( toml_obj , data ) : [EOL] for key_name , key_data in data . items ( ) : [EOL] if isinstance ( key_data , dict ) : [EOL] table = tomlkit . table ( ) [EOL] _add_config_values_to_toml_object ( table , key_data ) [EOL] toml_obj [ key_name ] = table [EOL] else : [EOL] key_data . add_to_toml_obj ( toml_obj , _NOT_SET ) [EOL] [EOL] [EOL] def write_example_config ( example_file_path ) : [EOL] [docstring] [EOL] document = tomlkit . document ( ) [EOL] for header_line in _get_header ( ) : [EOL] document . add ( tomlkit . comment ( header_line ) ) [EOL] config_keys = _aggregate_config_values ( ConfigValue . config_values ) [EOL] _add_config_values_to_toml_object ( document , config_keys ) [EOL] _doc_as_str = document . as_string ( ) . replace ( f' [string] { _NOT_SET } [string] ' , [string] ) [EOL] with open ( example_file_path , [string] ) as stream : [EOL] stream . write ( _doc_as_str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $collections.defaultdict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import MutableMapping , Any [EOL] import pathlib [EOL] import typing [EOL] import builtins [EOL] import multiprocessing [EOL] [docstring] [EOL] import multiprocessing [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import tomlkit [EOL] import tomlkit . exceptions [EOL] [EOL] [comment] [EOL] from elib_config . _setup import ELIBConfig [EOL] [comment] [EOL] from . _exc import ConfigFileNotFoundError , EmptyValueError [EOL] [EOL] CONFIG_LOCK = multiprocessing . RLock ( ) [EOL] [docstring] [EOL] [EOL] [EOL] def _ensure_config_file_exists ( ) : [EOL] [docstring] [EOL] config_file = Path ( ELIBConfig . config_file_path ) . absolute ( ) [EOL] if not config_file . exists ( ) : [EOL] raise ConfigFileNotFoundError ( ELIBConfig . config_file_path ) [EOL] [EOL] [EOL] def _read_file ( ) : [EOL] config_file = Path ( ELIBConfig . config_file_path ) . absolute ( ) [EOL] if not config_file . exists ( ) : [EOL] return { } [EOL] with config_file . open ( encoding = [string] ) as stream : [EOL] try : [EOL] return tomlkit . parse ( stream . read ( ) ) [EOL] except tomlkit . exceptions . UnexpectedCharError as err : [EOL] if [string] in err . args [ [number] ] : [EOL] [comment] [EOL] raise EmptyValueError ( str ( config_file ) , err . _line ) [comment] [EOL] else : [EOL] raise [EOL] [EOL] [EOL] def _write_file ( config ) : [EOL] config_file = Path ( ELIBConfig . config_file_path ) . absolute ( ) [EOL] with config_file . open ( mode = [string] , encoding = [string] ) as stream : [EOL] stream . write ( tomlkit . dumps ( config ) ) [EOL] [EOL] [EOL] def read_config_file ( ) : [EOL] [docstring] [EOL] return _read_file ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.synchronize.RLock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.MutableMapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] HEADER = [string] [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0
[comment] [EOL] from typing import Container , Optional [EOL] import typing [EOL] import tomlkit [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from . _config_value_integer import ConfigValueInteger [EOL] [EOL] [EOL] class ConfigValueFloat ( ConfigValueInteger ) : [EOL] [docstring] [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . float [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , float ) : [EOL] return self . _raise_invalid_type_error ( ) [EOL] value = float ( raw_value ) [EOL] if ( self . _min and value < self . _min ) or ( self . _max and value > self . _max ) : [EOL] return self . _raise_out_of_bound_error ( value ) [EOL] return value [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [comment] [EOL] return super ( ConfigValueFloat , self ) . __call__ ( ) [EOL] [EOL] def set_limits ( self , min_ = None , max_ = None ) : [EOL] [docstring] [EOL] self . _min , self . _max = min_ , max_ [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0
[comment] [EOL] from typing import Any , Container , List [EOL] import typing [EOL] import builtins [EOL] import tomlkit [EOL] [docstring] [EOL] import abc [EOL] import typing [EOL] [EOL] import tomlkit . container [EOL] [EOL] SENTINEL = object ( ) [EOL] [EOL] [EOL] class ConfigValueTOML ( abc . ABC ) : [EOL] [docstring] [EOL] description = ... [EOL] default = ... [comment] [EOL] [EOL] @ property @ abc . abstractmethod def key ( self ) : [EOL] [docstring] [EOL] [EOL] @ property @ abc . abstractmethod def friendly_type_name ( self ) : [EOL] [docstring] [EOL] [EOL] def _toml_add_description ( self , toml_obj ) : [EOL] toml_obj . add ( tomlkit . comment ( self . description ) ) [EOL] [EOL] def _toml_add_value_type ( self , toml_obj ) : [EOL] toml_obj . add ( tomlkit . comment ( f' [string] { self . friendly_type_name }' ) ) [EOL] [EOL] def _toml_add_comments ( self , toml_obj ) : [EOL] self . _toml_add_examples ( toml_obj ) [EOL] if self . default != SENTINEL : [EOL] comments = [ [string] , [string] , ] [EOL] for comment in comments : [EOL] toml_obj . add ( tomlkit . comment ( comment ) ) [EOL] else : [EOL] toml_obj . add ( tomlkit . comment ( [string] ) ) [EOL] [EOL] def _toml_add_value ( self , toml_obj , not_set ) : [EOL] if self . default != SENTINEL : [EOL] _doc = tomlkit . document ( ) [EOL] _doc [ self . key ] = self . default [EOL] toml_obj . add ( tomlkit . comment ( _doc . as_string ( ) ) ) [EOL] else : [EOL] toml_obj [ self . key ] = not_set [EOL] toml_obj . add ( tomlkit . nl ( ) ) [EOL] [EOL] @ staticmethod def _toml_comment ( toml_obj , comment ) : [EOL] toml_obj . add ( tomlkit . comment ( comment ) ) [EOL] [EOL] @ abc . abstractmethod def _toml_add_examples ( self , toml_obj ) : [EOL] pass [EOL] [EOL] def add_to_toml_obj ( self , toml_obj , not_set ) : [EOL] [docstring] [EOL] self . _toml_add_description ( toml_obj ) [EOL] self . _toml_add_value_type ( toml_obj ) [EOL] self . _toml_add_comments ( toml_obj ) [EOL] toml_obj . add ( tomlkit . comment ( [string] ) ) [EOL] self . _toml_add_value ( toml_obj , not_set ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 $builtins.str$ 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $builtins.str$ 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $builtins.str$ 0 0
[comment] [EOL] from typing import Container [EOL] import tomlkit [EOL] import builtins [EOL] [docstring] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from . _config_value import ConfigValue [EOL] [EOL] [EOL] class ConfigValueString ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . string [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , str ) : [EOL] self . _raise_invalid_type_error ( ) [EOL] return raw_value [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return super ( ConfigValueString , self ) . __call__ ( ) [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0
[comment] [EOL] from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] import warnings [EOL] [EOL] from elib_config . _exc import ELIBConfigError [EOL] [EOL] [EOL] class _ConfigValueError ( ELIBConfigError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name , msg ) : [EOL] self . value_name = value_name [EOL] self . msg = msg [EOL] super ( _ConfigValueError , self ) . __init__ ( f'{ value_name } [string] { msg }' ) [EOL] [EOL] [EOL] class DuplicateConfigValueError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name ) : [EOL] super ( DuplicateConfigValueError , self ) . __init__ ( value_name , [string] ) [EOL] [EOL] [EOL] class MissingValueError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ConfigMissingValueError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] warnings . warn ( [string] , PendingDeprecationWarning ) [EOL] super ( ConfigMissingValueError , self ) . __init__ ( * args , ** kwargs ) [EOL] [EOL] [EOL] class ConfigValueError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class PathMustExistError ( ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name ) : [EOL] super ( PathMustExistError , self ) . __init__ ( value_name , [string] ) [EOL] [EOL] [EOL] class NotAFileError ( ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name ) : [EOL] super ( NotAFileError , self ) . __init__ ( value_name , [string] ) [EOL] [EOL] [EOL] class NotAFolderError ( ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name ) : [EOL] super ( NotAFolderError , self ) . __init__ ( value_name , [string] ) [EOL] [EOL] [EOL] class ConfigValueTypeError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class OutOfBoundError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name , value , min_ , max_ ) : [EOL] msg = f' [string] { value } [string] { min_ } [string] { max_ }' [EOL] super ( OutOfBoundError , self ) . __init__ ( value_name , msg ) [EOL] [EOL] [EOL] class MissingTableKeyError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name , key_name ) : [EOL] super ( MissingTableKeyError , self ) . __init__ ( value_name , f' [string] { key_name }' ) [EOL] [EOL] [EOL] class TableKeyTypeError ( _ConfigValueError ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value_name , key_name , key_expected_type , key_actual_type ) : [EOL] msg = f'{ key_name } [string] { key_expected_type } [string] { key_actual_type } [string] ' [EOL] super ( TableKeyTypeError , self ) . __init__ ( value_name , msg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.float$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0
[comment] [EOL] [docstring] [EOL]	0 0 0 0
[comment] [EOL] from typing import Container , Optional [EOL] import typing [EOL] import builtins [EOL] import tomlkit [EOL] [docstring] [EOL] import typing [EOL] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from . _config_value import ConfigValue , SENTINEL [EOL] from . _exc import OutOfBoundError [EOL] [EOL] [EOL] class ConfigValueInteger ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * path , description , default = SENTINEL ) : [EOL] super ( ConfigValueInteger , self ) . __init__ ( * path , description = description , default = default ) [EOL] self . _min = None [EOL] self . _max = None [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . integer [EOL] [EOL] def _raise_out_of_bound_error ( self , value ) : [EOL] raise OutOfBoundError ( self . name , value , self . _min , self . _max ) [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , int ) or isinstance ( raw_value , bool ) : [EOL] return self . _raise_invalid_type_error ( ) [EOL] value = int ( raw_value ) [EOL] if ( self . _min and value < self . _min ) or ( self . _max and value > self . _max ) : [EOL] return self . _raise_out_of_bound_error ( value ) [EOL] return int ( value ) [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return int ( super ( ConfigValueInteger , self ) . __call__ ( ) ) [EOL] [EOL] def set_limits ( self , min_ = None , max_ = None ) : [EOL] [docstring] [EOL] self . _min , self . _max = min_ , max_ [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0
[comment] [EOL] from typing import Union , Container , List , Type , Dict , Any , Iterable [EOL] import typing [EOL] import tomlkit [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] [EOL] import dataclasses [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _utils import friendly_type_name [EOL] from . _config_value import ConfigValue , SENTINEL [EOL] from . _exc import MissingTableKeyError , TableKeyTypeError [EOL] [EOL] _KEY_VALUE_EXAMPLES = { str : [string] , int : [number] , float : [number] , bool : True } [EOL] [EOL] [EOL] @ dataclasses . dataclass class ConfigValueTableKey : [EOL] [docstring] [EOL] key_name = ... [EOL] key_type = ... [EOL] description = ... [EOL] default = SENTINEL [comment] [EOL] [EOL] @ property def user_friendly_type ( self ) : [EOL] [docstring] [EOL] return friendly_type_name ( self . key_type ) [EOL] [EOL] @ property def mandatory ( self ) : [EOL] [docstring] [EOL] return self . default is SENTINEL [EOL] [EOL] [EOL] class ConfigValueTableArray ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * path , description , default = SENTINEL , keys = SENTINEL ) : [EOL] super ( ConfigValueTableArray , self ) . __init__ ( * path , description = description , default = default ) [EOL] self . keys = [ ] if keys is SENTINEL else keys [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] def _check_key_type ( self , key , key_value ) : [EOL] if not isinstance ( key_value , key . key_type ) : [EOL] raise TableKeyTypeError ( self . name , key . key_name , friendly_type_name ( key . key_type ) , friendly_type_name ( type ( key_value ) ) , ) [EOL] [EOL] def _get_key_value ( self , raw_value , key ) : [EOL] if key . key_name not in raw_value : [EOL] if key . mandatory : [EOL] raise MissingTableKeyError ( self . name , str ( key ) ) [EOL] else : [EOL] raw_value [ key . key_name ] = key . default [EOL] return key . default [EOL] [EOL] return raw_value [ key . key_name ] [EOL] [EOL] def _check_keys ( self , raw_value ) : [EOL] for key in self . keys : [EOL] key_value = self . _get_key_value ( raw_value , key ) [EOL] self . _check_key_type ( key , key_value ) [EOL] return raw_value [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , dict ) : [EOL] self . _raise_invalid_type_error ( ) [EOL] raw_value_as_dict = self . _check_keys ( dict ( raw_value ) ) [EOL] return raw_value_as_dict [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return super ( ConfigValueTableArray , self ) . __call__ ( ) [EOL] [EOL] def __getattr__ ( self , item ) : [EOL] if item in ( key . key_name for key in self . keys ) : [EOL] return self ( ) [ item ] [EOL] [EOL] raise AttributeError ( f'{ self . name } [string] { item } [string] ' ) [EOL] [EOL] def __getitem__ ( self , item ) : [EOL] return self . __getattr__ ( item ) [EOL] [EOL] @ staticmethod def _get_key_state_as_comment ( key ) : [EOL] if key . mandatory : [EOL] return [string] [EOL] [EOL] return [string] + str ( key . default ) [EOL] [EOL] def _toml_add_value_type ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , f' [string] { self . friendly_type_name }' ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] for key in self . keys : [EOL] _key_state = self . _get_key_state_as_comment ( key ) [EOL] for comment in [ f' [string] { key . key_name }' , f' [string] { key . user_friendly_type }' , key . description , _key_state , [string] , ] : [EOL] toml_obj . add ( tomlkit . comment ( ( [string] * [number] + comment ) . rstrip ( ) ) ) [EOL] [EOL] @ staticmethod def _add_key_to_example_table ( _table , key ) : [EOL] if not key . mandatory : [EOL] _value = key . default [EOL] else : [EOL] if key . key_type not in _KEY_VALUE_EXAMPLES : [EOL] raise KeyError ( f' [string] { key . key_type }' ) [EOL] else : [EOL] [comment] [EOL] _value = _KEY_VALUE_EXAMPLES [ key . key_type ] [EOL] [EOL] _table [ key . key_name ] = _value [EOL] [EOL] def _generate_example ( self ) : [EOL] _doc = tomlkit . document ( ) [EOL] _table = tomlkit . table ( ) [EOL] for key in self . keys : [EOL] self . _add_key_to_example_table ( _table , key ) [EOL] _array = tomlkit . aot ( ) [EOL] _array . append ( _table ) [EOL] _doc [ self . key ] = _array [EOL] return _doc . as_string ( ) . split ( [string] ) [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] for line in self . _generate_example ( ) : [EOL] self . _toml_comment ( toml_obj , ( [string] * [number] + line ) . rstrip ( ) ) [EOL] self . _toml_comment ( toml_obj , [string] [string] ) [EOL] [EOL] def _toml_add_comments ( self , toml_obj ) : [EOL] super ( ConfigValueTableArray , self ) . _toml_add_comments ( toml_obj ) [EOL] [EOL] def _toml_add_value ( self , toml_obj , not_set ) : [EOL] if self . default != SENTINEL : [EOL] _doc = tomlkit . document ( ) [EOL] _doc [ self . key ] = self . default [EOL] for line in _doc . as_string ( ) . split ( [string] ) : [EOL] self . _toml_comment ( toml_obj , line ) [EOL] else : [EOL] toml_obj [ self . key ] = not_set [EOL] toml_obj . add ( tomlkit . nl ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Type[typing.Union[builtins.float,builtins.str]],typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 $ConfigValueTableKey$ 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 $builtins.dict$ 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 0 $builtins.dict$ 0 $ConfigValueTableKey$ 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 $builtins.dict$ 0 $ConfigValueTableKey$ 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.dict$ 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $ConfigValueTableKey$ 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $ConfigValueTableKey$ 0 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 $typing.Union[builtins.float,builtins.str]$ 0 $ConfigValueTableKey$ 0 0 0 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 $typing.Dict[typing.Type[typing.Union[builtins.float,builtins.str]],typing.Union[builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 $ConfigValueTableKey$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.float,builtins.str]$ 0 $typing.Dict[typing.Type[typing.Union[builtins.float,builtins.str]],typing.Union[builtins.float,builtins.str]]$ 0 $ConfigValueTableKey$ 0 0 0 0 0 $tomlkit.container.Container$ 0 $ConfigValueTableKey$ 0 0 0 0 $typing.Union[builtins.float,builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 $builtins.str$ 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Container , List [EOL] import pathlib [EOL] import typing [EOL] import tomlkit [EOL] import builtins [EOL] [docstring] [EOL] import typing [EOL] from pathlib import Path [EOL] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from . _config_value import ConfigValue , SENTINEL [EOL] from . _exc import NotAFileError , NotAFolderError , PathMustExistError [EOL] [EOL] [EOL] class ConfigValuePath ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * path , description , default = SENTINEL , ) : [EOL] ConfigValue . __init__ ( self , * path , description = description , default = default ) [EOL] self . _must_be_file = False [EOL] self . _must_be_dir = False [EOL] self . _create_dir = False [EOL] self . _must_exist = False [EOL] [EOL] def must_exist ( self ) : [EOL] [docstring] [EOL] self . _must_exist = True [EOL] [EOL] def must_be_file ( self ) : [EOL] [docstring] [EOL] if self . _must_be_dir : [EOL] raise AttributeError ( [string] ) [EOL] self . _must_be_file = True [EOL] [EOL] def must_be_dir ( self ) : [EOL] [docstring] [EOL] if self . _must_be_file : [EOL] raise AttributeError ( [string] ) [EOL] self . _must_be_dir = True [EOL] [EOL] def create_dir ( self ) : [EOL] [docstring] [EOL] self . _create_dir = True [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . path [EOL] [EOL] @ property def friendly_type_name ( self ) : [EOL] [docstring] [EOL] _constraints_set = [ ] [EOL] if self . _must_be_dir : [EOL] _constraints_set . append ( [string] ) [EOL] if self . _must_be_file : [EOL] _constraints_set . append ( [string] ) [EOL] if self . _must_exist : [EOL] _constraints_set . append ( [string] ) [EOL] _constraints_as_str = [string] + [string] . join ( _constraints_set ) + [string] if _constraints_set else [string] [EOL] return [string] + _constraints_as_str [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] try : [EOL] path = Path ( raw_value ) [EOL] except TypeError : [EOL] return self . _raise_invalid_type_error ( ) [EOL] else : [EOL] if self . _must_exist and not path . exists ( ) : [EOL] raise PathMustExistError ( self . path ) [EOL] if path . exists ( ) and self . _must_be_dir and not path . is_dir ( ) : [EOL] raise NotAFolderError ( self . path ) [EOL] if path . exists ( ) and self . _must_be_file and not path . is_file ( ) : [EOL] raise NotAFileError ( self . path ) [EOL] if not path . exists ( ) and self . _create_dir : [EOL] path . mkdir ( parents = True ) [EOL] return path . absolute ( ) [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return super ( ConfigValuePath , self ) . __call__ ( ) [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0
[comment] [EOL] from typing import Any , Optional , List , Type [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import abc [EOL] import os [EOL] import typing [EOL] [EOL] [comment] [EOL] from elib_config . _file . _config_file import read_config_file [EOL] from elib_config . _setup import ELIBConfig [EOL] from elib_config . _utils import friendly_type_name [EOL] from elib_config . _value . _config_value_toml import ConfigValueTOML , SENTINEL [EOL] from . _exc import ConfigValueTypeError , MissingValueError [EOL] [EOL] [EOL] class ConfigValue ( ConfigValueTOML , abc . ABC ) : [EOL] [docstring] [EOL] config_values = [ ] [EOL] [EOL] def __init__ ( self , * path , description , default = SENTINEL ) : [EOL] self . _raw_path = path [EOL] self . default = default [EOL] self . description = description [EOL] ConfigValue . config_values . append ( self ) [EOL] [EOL] @ property def path ( self ) : [EOL] [docstring] [EOL] path = ELIBConfig . config_sep_str . join ( self . _raw_path ) [EOL] if ELIBConfig . root_path : [EOL] prefix = ELIBConfig . config_sep_str . join ( ELIBConfig . root_path ) [EOL] path = ELIBConfig . config_sep_str . join ( ( prefix , path ) ) [EOL] return path [EOL] [EOL] @ property def key ( self ) : [EOL] [docstring] [EOL] return self . _raw_path [ - [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . path . replace ( [string] , [string] ) [EOL] [EOL] def _from_environ ( self ) : [EOL] var_name = ELIBConfig . config_sep_str . join ( ( ELIBConfig . app_name , self . path ) ) . upper ( ) [EOL] for env_var in os . environ : [EOL] if env_var . upper ( ) == var_name : [EOL] return os . getenv ( env_var ) [EOL] return None [EOL] [EOL] def _from_config_file ( self ) : [EOL] value = read_config_file ( ) [EOL] for key in self . path . split ( ELIBConfig . config_sep_str ) : [EOL] try : [EOL] value = value [ key ] [EOL] except KeyError : [EOL] return None [EOL] [EOL] return value [EOL] [EOL] def _from_default ( self ) : [EOL] if self . default != SENTINEL : [EOL] return self . default [EOL] [EOL] return None [EOL] [EOL] def raw_value ( self ) : [EOL] [docstring] [EOL] raw_value = self . _from_environ ( ) [EOL] if raw_value is None : [EOL] raw_value = self . _from_config_file ( ) [EOL] if raw_value is None : [EOL] raw_value = self . _from_default ( ) [EOL] return raw_value [EOL] [EOL] def __call__ ( self ) : [EOL] raw_value = self . raw_value ( ) [EOL] if raw_value is None : [EOL] raise MissingValueError ( self . path , [string] ) [EOL] return self . _cast ( raw_value ) [EOL] [EOL] def _raise_invalid_type_error ( self ) : [EOL] _raw_value_type = type ( self . raw_value ( ) ) [EOL] actual_type = friendly_type_name ( _raw_value_type ) [EOL] raise ConfigValueTypeError ( self . path , f' [string] { self . type_name } [string] { actual_type } [string] ' ) [EOL] [EOL] @ abc . abstractmethod def _cast ( self , raw_value ) : [EOL] pass [EOL] [EOL] @ property @ abc . abstractmethod def type_name ( self ) : [EOL] [docstring] [EOL] [EOL] @ property def friendly_type_name ( self ) : [EOL] [docstring] [EOL] return self . type_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List['ConfigValue']$ 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.object]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Type[typing.Optional[builtins.object]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Container [EOL] import builtins [EOL] import tomlkit [EOL] [docstring] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from . _config_value import ConfigValue [EOL] from . _exc import ConfigValueTypeError [EOL] [EOL] [EOL] class ConfigValueBool ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . boolean [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , bool ) : [EOL] raise ConfigValueTypeError ( self . path , f' [string] { raw_value } [string] ' ) [EOL] [EOL] return raw_value [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return super ( ConfigValueBool , self ) . __call__ ( ) [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0
[comment] [EOL] from typing import Container , Any , Type [EOL] import typing [EOL] import tomlkit [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import typing [EOL] [EOL] import tomlkit . container [EOL] [EOL] from elib_config . _types import Types [EOL] from elib_config . _utils import friendly_type_name [EOL] from . _config_value import ConfigValue , SENTINEL [EOL] from . _exc import ConfigValueTypeError [EOL] [EOL] [EOL] class ConfigValueList ( ConfigValue ) : [EOL] [docstring] [EOL] [EOL] @ property def type_name ( self ) : [EOL] [docstring] [EOL] return Types . array [EOL] [EOL] @ property def friendly_type_name ( self ) : [EOL] [docstring] [EOL] return f'{ Types . array } [string] { self . _expected_element_type } [string] ' [EOL] [EOL] def __init__ ( self , * path , element_type , description , default = SENTINEL ) : [EOL] self . element_type = element_type [EOL] super ( ConfigValueList , self ) . __init__ ( * path , description = description , default = default ) [EOL] [EOL] @ property def _expected_element_type ( self ) : [EOL] return friendly_type_name ( self . element_type ) [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] if not isinstance ( raw_value , list ) : [EOL] return self . _raise_invalid_type_error ( ) [EOL] for index , item in enumerate ( raw_value ) : [EOL] if not isinstance ( item , self . element_type ) : [EOL] actual_type = friendly_type_name ( type ( item ) ) [EOL] raise ConfigValueTypeError ( self . path , f'{ self . name } [string] { index } [string] { self . _expected_element_type } [string] ' f' [string] { actual_type } [string] ' ) [EOL] return raw_value [EOL] [EOL] [comment] [EOL] def __call__ ( self ) : [EOL] return super ( ConfigValueList , self ) . __call__ ( ) [EOL] [EOL] def _toml_add_value_type ( self , toml_obj ) : [EOL] super ( ConfigValueList , self ) . _toml_add_value_type ( toml_obj ) [EOL] self . _toml_comment ( toml_obj , f' [string] { self . _expected_element_type }' ) [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] if self . element_type == str : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] elif self . element_type == int : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] elif self . element_type == float : [EOL] self . _toml_comment ( toml_obj , [string] ) [EOL] else : [EOL] raise KeyError ( f' [string] { self . element_type }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $builtins.str$ 0 $typing.Type[typing.Any]$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_config [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ( ConfigValueTableArray , ConfigValueTableKey , ConfigValueTypeError , MissingTableKeyError , TableKeyTypeError , ) [EOL] [EOL] _EXAMPLE1 = [string] [EOL] [EOL] _EXAMPLE2 = [string] [EOL] [EOL] [EOL] def test_basics ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] assert { [string] : [string] , [string] : [string] } == inline_str ( ) [EOL] [EOL] [EOL] def test_wrong_key_type ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , int , description = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] with pytest . raises ( TableKeyTypeError ) : [EOL] inline_str ( ) [EOL] [EOL] [EOL] def test_missing_key ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] with pytest . raises ( MissingTableKeyError ) : [EOL] inline_str ( ) [EOL] [EOL] [EOL] def test_missing_optional_key ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] , default = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] assert { [string] : [string] , [string] : [string] , [string] : [string] } == inline_str ( ) [EOL] [EOL] [EOL] def test_get_attr ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] assert [string] == inline_str . key1 [EOL] assert [string] == inline_str [ [string] ] [EOL] [EOL] [EOL] def test_get_attr_missing ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE1 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] with pytest . raises ( AttributeError , match = [string] ) : [EOL] assert [string] == inline_str . key11 [EOL] with pytest . raises ( AttributeError , match = [string] ) : [EOL] assert [string] == inline_str [ [string] ] [EOL] [EOL] [EOL] def test_optional_key ( ) : [EOL] Path ( [string] ) . write_text ( _EXAMPLE2 ) [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] , default = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] assert { [string] : [string] } == inline_str ( ) [EOL] [EOL] [EOL] def test_cast_wrong_type ( ) : [EOL] key1 = ConfigValueTableKey ( [string] , str , description = [string] , default = [string] ) [EOL] inline_str = ConfigValueTableArray ( [string] , description = [string] , keys = ( key1 , ) ) [EOL] with pytest . raises ( ConfigValueTypeError ) : [EOL] inline_str . _cast ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [EOL] [comment] [EOL] import test [EOL] import builtins [EOL] from elib_config import _setup [EOL] [comment] [EOL] from elib_config . _value import _config_value [EOL] [EOL] [EOL] class DummyValue ( _config_value . ConfigValue ) : [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] return raw_value [EOL] [EOL] @ property def type_name ( self ) : [EOL] return [string] [EOL] [EOL] def _toml_add_examples ( self ) : [EOL] pass [EOL] [EOL] [EOL] def test_config_value_with_root_path ( ) : [EOL] value = DummyValue ( [string] , description = [string] , default = [string] ) [EOL] assert value . path == [string] [EOL] _setup . ELIBConfig . root_path = [ [string] ] [EOL] value = DummyValue ( [string] , description = [string] , default = [string] ) [EOL] assert value . path == [string] [EOL] _setup . ELIBConfig . root_path = [ [string] , [string] , [string] ] [EOL] value = DummyValue ( [string] , description = [string] , default = [string] ) [EOL] assert value . path == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Tuple , List , Type , Dict , Optional , Any , Iterable [EOL] import pathlib [EOL] import typing [EOL] import test [EOL] import elib_config [EOL] import builtins [EOL] import pathlib [EOL] import re [EOL] import typing [EOL] [EOL] import dataclasses [EOL] import pytest [EOL] import tomlkit [EOL] [EOL] import elib_config [EOL] [comment] [EOL] from elib_config . _file import _config_example [EOL] [comment] [EOL] from elib_config . _value . _config_value import ConfigValue [EOL] [EOL] [EOL] def _strip_header ( file ) : [EOL] file_path = pathlib . Path ( file ) [EOL] content = pathlib . Path ( file_path ) . read_text ( [string] ) [EOL] new_content = re . sub ( [string] , [string] , content , flags = re . MULTILINE ) [EOL] file_path . write_text ( new_content , [string] ) [EOL] [EOL] [EOL] @ dataclasses . dataclass class TestCase : [EOL] value_cls = ... [EOL] path = ... [EOL] run_after = dataclasses . field ( default_factory = list ) [EOL] default = None [EOL] list_elements_type = None [EOL] keys = None [EOL] [EOL] def create ( self ) : [EOL] kwargs = { [string] : [string] , } [EOL] if self . default is not None : [EOL] kwargs [ [string] ] = self . default [EOL] if self . list_elements_type is not None : [EOL] kwargs [ [string] ] = self . list_elements_type [EOL] if self . keys is not None : [EOL] kwargs [ [string] ] = self . keys [EOL] obj = self . value_cls ( * self . path , ** kwargs ) [EOL] for _func_name in self . run_after : [EOL] getattr ( obj , _func_name ) ( ) [EOL] [EOL] [EOL] TEST_DATA = [ ( TestCase ( value_cls = elib_config . ConfigValueBool , path = ( [string] , [string] ) , default = True ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueBool , path = ( [string] , [string] ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueBool , path = ( [string] , [string] , [string] , [string] ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueBool , path = ( [string] , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueString , path = ( [string] , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueInteger , path = ( [string] , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueFloat , path = ( [string] , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueList , path = ( [string] , ) , list_elements_type = str ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueList , path = ( [string] , ) , list_elements_type = float ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueList , path = ( [string] , ) , list_elements_type = int ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) , run_after = [ [string] ] ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) , run_after = [ [string] ] ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) , run_after = [ [string] ] ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) , run_after = [ [string] , [string] ] ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValuePath , path = ( [string] , ) , run_after = [ [string] , [string] ] ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueTableArray , path = ( [string] , ) , keys = ( elib_config . ConfigValueTableKey ( [string] , str , [string] ) , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueTableArray , path = ( [string] , ) , keys = ( elib_config . ConfigValueTableKey ( [string] , str , [string] , default = [string] ) , ) ) , [string] ) , ( TestCase ( value_cls = elib_config . ConfigValueTableArray , path = ( [string] , ) , default = [ { [string] : [string] } ] , keys = ( elib_config . ConfigValueTableKey ( [string] , str , [string] , default = [string] ) , ) ) , [string] ) , ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , TEST_DATA ) def test_config_values_to_text ( test_case , expected ) : [EOL] test_case . create ( ) [EOL] _config_example . write_example_config ( [string] ) [EOL] _ , content = pathlib . Path ( [string] ) . read_text ( [string] ) . split ( [string] ) [EOL] content = content . lstrip ( ) [EOL] test_file = pathlib . Path ( [string] ) [EOL] test_file . write_text ( content , [string] ) [EOL] if test_case . default is not None : [EOL] tomlkit . loads ( test_file . read_text ( [string] ) ) [EOL] assert expected == content , content [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[elib_config._value._config_value.ConfigValue]$ 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 $typing.List$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Any]$ 0 0 0 $typing.Optional[typing.Type]$ 0 0 0 $typing.Optional[typing.Iterable[elib_config.ConfigValueTableKey]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $elib_config._value._config_value.ConfigValue$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $elib_config._value._config_value.ConfigValue$ 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[test.test_example_config.TestCase,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[test.test_example_config.TestCase,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_config [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ConfigValueInteger , ConfigValueTypeError , MissingValueError , OutOfBoundError [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_string_value ( ) : [EOL] yield ConfigValueInteger ( [string] , description = [string] , default = [number] , ) [EOL] [EOL] [EOL] def test_no_default ( ) : [EOL] value = ConfigValueInteger ( [string] , [string] , description = [string] , ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_string_value_default ( value ) : [EOL] assert value ( ) is [number] [EOL] [EOL] [EOL] def test_string_value_type_name ( value ) : [EOL] assert value . type_name == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] , [string] , ] ) def test_invalid_cast_type_from_config_file ( value , file_value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { file_value }' ) [EOL] exc_msg = f'{ value . name } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = exc_msg ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) is [number] [EOL] [EOL] [EOL] def test_min ( value ) : [EOL] assert value ( ) is [number] [EOL] value . set_limits ( min_ = [number] ) [EOL] assert value ( ) is [number] [EOL] value . set_limits ( min_ = [number] ) [EOL] with pytest . raises ( OutOfBoundError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_max ( value ) : [EOL] assert value ( ) is [number] [EOL] value . set_limits ( max_ = [number] ) [EOL] assert value ( ) is [number] [EOL] value . set_limits ( max_ = [number] ) [EOL] with pytest . raises ( OutOfBoundError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_min_max ( value ) : [EOL] assert value ( ) is [number] [EOL] value . set_limits ( min_ = [number] , max_ = [number] ) [EOL] assert value ( ) is [number] [EOL] value . set_limits ( max_ = [number] ) [EOL] with pytest . raises ( OutOfBoundError ) : [EOL] value ( ) [EOL] value . set_limits ( min_ = [number] , max_ = [number] ) [EOL] with pytest . raises ( OutOfBoundError ) : [EOL] value ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Container , Any [EOL] import test [EOL] import typing [EOL] import builtins [EOL] import tomlkit [EOL] import os [EOL] import pathlib [EOL] [EOL] import pytest [EOL] import tomlkit . container [EOL] [EOL] from elib_config import MissingValueError [EOL] [comment] [EOL] from elib_config . _value import _config_value [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_value ( ) : [EOL] dummy_value = DummyConfigValue ( [string] , [string] , [string] , description = [string] ) [EOL] yield dummy_value [EOL] [EOL] [EOL] class DummyConfigValue ( _config_value . ConfigValue ) : [EOL] [EOL] def _toml_add_examples ( self , toml_obj ) : [EOL] pass [EOL] [EOL] def _cast ( self , raw_value ) : [EOL] return raw_value [EOL] [EOL] @ property def type_name ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] def test_config_value_basic ( dummy_value ) : [EOL] assert isinstance ( dummy_value , _config_value . ConfigValue ) [EOL] dummy_value . default = [string] [EOL] assert dummy_value ( ) == [string] [EOL] assert dummy_value . type_name == [string] [EOL] assert dummy_value . name == [string] [EOL] [EOL] [EOL] def test_value_no_default ( dummy_value ) : [EOL] with pytest . raises ( MissingValueError ) : [EOL] dummy_value ( ) [EOL] [EOL] [EOL] def test_value_in_environ ( dummy_value ) : [EOL] with pytest . raises ( MissingValueError ) : [EOL] dummy_value ( ) [EOL] os . environ [ [string] ] = [string] [EOL] assert dummy_value ( ) == [string] [EOL] del os . environ [ [string] ] [EOL] [EOL] [EOL] def test_value_in_config_file ( dummy_value ) : [EOL] pathlib . Path ( [string] ) . write_text ( [string] ) [EOL] assert dummy_value ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] , [string] ) , ] ) def test_config_value_name ( value_name ) : [EOL] config_value = DummyConfigValue ( * value_name , description = [string] ) [EOL] assert [string] . join ( value_name ) == config_value . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tomlkit.container.Container$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , Any [EOL] import pathlib [EOL] import typing [EOL] import os [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] import pytest [EOL] from mockito import unstub [EOL] [EOL] _HERE = Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def pytest_configure ( config ) : [EOL] [docstring] [EOL] print ( [string] , config . option ) [EOL] setattr ( sys , [string] , True ) [EOL] [EOL] [EOL] [comment] [EOL] def pytest_unconfigure ( config ) : [EOL] [docstring] [EOL] assert config [EOL] delattr ( sys , [string] ) [EOL] [EOL] [EOL] def pytest_addoption ( parser ) : [EOL] parser . addoption ( [string] , action = [string] , help = [string] ) [EOL] [EOL] [EOL] def pytest_runtest_setup ( item ) : [EOL] long_marker = item . get_marker ( [string] ) [EOL] if long_marker is not None and not item . config . getoption ( [string] ) : [EOL] pytest . skip ( f'{ item . location } [string] ' ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def clean_os_env ( ) : [EOL] env = os . environ . copy ( ) [EOL] yield [EOL] for key , value in env . items ( ) : [EOL] os . environ [ key ] = value [EOL] for key in os . environ . keys ( ) : [EOL] if key not in env . keys ( ) : [EOL] del os . environ [ key ] [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _global_tear_down ( tmpdir , monkeypatch ) : [EOL] [docstring] [EOL] try : [EOL] monkeypatch . delenv ( [string] ) [EOL] except KeyError : [EOL] pass [EOL] current_dir = os . getcwd ( ) [EOL] folder = Path ( tmpdir ) . absolute ( ) [EOL] os . chdir ( folder ) [EOL] yield [EOL] unstub ( ) [EOL] [comment] [EOL] from elib_config . _setup import ELIBConfig [EOL] ELIBConfig . setup ( app_version = [string] , app_name = [string] , config_file_path = [string] , config_sep_str = [string] ) [EOL] os . chdir ( current_dir ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def dummy_setup ( request ) : [EOL] [docstring] [EOL] marker = request . node . get_marker ( [string] ) [EOL] if marker is not None : [EOL] return [EOL] [EOL] [comment] [EOL] from elib_config . _setup import ELIBConfig [EOL] ELIBConfig . setup ( app_version = [string] , app_name = [string] , config_file_path = [string] , config_sep_str = [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def _clean_known_values ( ) : [EOL] [comment] [EOL] from elib_config . _value import _config_value [EOL] _config_value . ConfigValue . config_values = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import pathlib [EOL] import elib_config [EOL] import typing [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ( ConfigValuePath , ConfigValueTypeError , MissingValueError , NotAFileError , NotAFolderError , PathMustExistError , ) [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_string_value ( ) : [EOL] yield ConfigValuePath ( [string] , description = [string] , default = [string] , ) [EOL] [EOL] [EOL] def test_no_default ( ) : [EOL] value = ConfigValuePath ( [string] , [string] , description = [string] , ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_string_value_default ( value ) : [EOL] assert value ( ) == pathlib . Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def test_string_value_type_name ( value ) : [EOL] assert value . type_name == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [string] , [string] , [string] , ] ) def test_invalid_cast_type_from_config_file ( value , file_value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { file_value }' ) [EOL] exc_msg = f'{ value . name } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = exc_msg ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) == pathlib . Path ( [string] ) . absolute ( ) [EOL] [EOL] [EOL] def test_path_value_file ( value ) : [EOL] test_file = pathlib . Path ( [string] ) . absolute ( ) [EOL] assert not test_file . exists ( ) [EOL] test_value = value ( ) [EOL] test_value . touch ( ) [EOL] assert test_file . exists ( ) [EOL] [EOL] [EOL] def test_path_value_must_exist ( value ) : [EOL] value . must_exist ( ) [EOL] test_file = pathlib . Path ( [string] ) . absolute ( ) [EOL] assert not test_file . exists ( ) [EOL] with pytest . raises ( PathMustExistError ) : [EOL] value ( ) [EOL] test_file . touch ( ) [EOL] value ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_file_with_file ( value ) : [EOL] value . must_be_file ( ) [EOL] test_path = pathlib . Path ( [string] ) [EOL] test_path . touch ( ) [EOL] value ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_file_with_dir ( value ) : [EOL] value . must_be_file ( ) [EOL] test_path = pathlib . Path ( [string] ) [EOL] test_path . mkdir ( ) [EOL] with pytest . raises ( NotAFileError ) : [EOL] value ( ) [EOL] test_path . rmdir ( ) [EOL] value . must_exist ( ) [EOL] with pytest . raises ( PathMustExistError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_dir_with_dir ( value ) : [EOL] value . must_be_dir ( ) [EOL] test_path = pathlib . Path ( [string] ) [EOL] test_path . mkdir ( ) [EOL] value ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_dir_with_file ( value ) : [EOL] value . must_be_dir ( ) [EOL] test_path = pathlib . Path ( [string] ) [EOL] test_path . touch ( ) [EOL] with pytest . raises ( NotAFolderError ) : [EOL] value ( ) [EOL] test_path . unlink ( ) [EOL] value . must_exist ( ) [EOL] with pytest . raises ( PathMustExistError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_path_value_create_missing_dir ( value ) : [EOL] test_path = pathlib . Path ( [string] ) [EOL] value . create_dir ( ) [EOL] assert not test_path . exists ( ) [EOL] value ( ) [EOL] assert test_path . exists ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_both ( value ) : [EOL] value . must_be_dir ( ) [EOL] with pytest . raises ( AttributeError ) : [EOL] value . must_be_file ( ) [EOL] [EOL] [EOL] def test_path_value_must_be_both2 ( value ) : [EOL] value . must_be_file ( ) [EOL] with pytest . raises ( AttributeError ) : [EOL] value . must_be_dir ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from elib_config import _utils [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( str , [string] ) , ( dict , [string] ) , ( list , [string] ) , ( int , [string] ) , ( float , [string] ) , ( bool , [string] ) , ] ) def test_friendly_type_name ( raw_type , friendly_name ) : [EOL] assert friendly_name == _utils . friendly_type_name ( raw_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_config [EOL] from pathlib import Path [EOL] [EOL] import elib_config [EOL] [EOL] _TOML_TEXT = [string] [EOL] [EOL] KEY1 = elib_config . ConfigValueString ( [string] , [string] , description = [string] ) [EOL] INT1 = elib_config . ConfigValueInteger ( [string] , [string] , description = [string] ) [EOL] FLOAT1 = elib_config . ConfigValueFloat ( [string] , [string] , description = [string] ) [EOL] LIST1 = elib_config . ConfigValueList ( [string] , [string] , description = [string] , element_type = str ) [EOL] [EOL] [EOL] def test_basics ( ) : [EOL] Path ( [string] ) . write_text ( _TOML_TEXT ) [EOL] assert KEY1 ( ) == [string] [EOL] assert INT1 ( ) == [number] [EOL] assert FLOAT1 ( ) == [number] [EOL] assert LIST1 ( ) == [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $elib_config._value._config_value_string.ConfigValueString$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_config._value._config_value_integer.ConfigValueInteger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_config._value._config_value_float.ConfigValueFloat$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $elib_config._value._config_value_list.ConfigValueList$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $elib_config._value._config_value_string.ConfigValueString$ 0 0 0 0 0 0 $elib_config._value._config_value_integer.ConfigValueInteger$ 0 0 0 0 0 0 $elib_config._value._config_value_float.ConfigValueFloat$ 0 0 0 0 0 0 $elib_config._value._config_value_list.ConfigValueList$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [docstring] [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] import elib_config . _file . _exc [EOL] [comment] [EOL] from elib_config import _setup [EOL] [EOL] [EOL] @ pytest . mark . skip_setup def test_no_setup ( ) : [EOL] with pytest . raises ( elib_config . _file . _exc . IncompleteSetupError ) : [EOL] _setup . ELIBConfig . check ( ) [EOL] [EOL] [EOL] def test_correct_setup ( ) : [EOL] _setup . ELIBConfig . check ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] ] ) def test_partial_setup ( attrib ) : [EOL] setattr ( _setup . ELIBConfig , attrib , [string] ) [EOL] with pytest . raises ( elib_config . _file . _exc . IncompleteSetupError ) : [EOL] _setup . ELIBConfig . check ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ( ConfigValueBool , ConfigValueInteger , ConfigValueList , ConfigValuePath , ConfigValueString , DuplicateConfigValueError , MissingValueError , validate_config , ) [EOL] [EOL] [EOL] def _create_values_with_default ( ) : [EOL] ConfigValueBool ( [string] , description = [string] , default = True ) [EOL] ConfigValueString ( [string] , description = [string] , default = [string] ) [EOL] ConfigValueInteger ( [string] , description = [string] , default = [number] ) [EOL] ConfigValuePath ( [string] , description = [string] , default = pathlib . Path ( [string] ) ) [EOL] ConfigValueList ( [string] , description = [string] , default = [ ] , element_type = str ) [EOL] [EOL] [EOL] def test_valid_bare_config ( ) : [EOL] _create_values_with_default ( ) [EOL] validate_config ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ConfigValueBool , ConfigValueString , ConfigValueInteger , ConfigValuePath ] ) def test_config_without_default ( val_cls ) : [EOL] val_cls ( [string] , description = [string] ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] validate_config ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , [string] ) ) def test_duplicate_path ( val_name ) : [EOL] _create_values_with_default ( ) [EOL] with pytest . raises ( DuplicateConfigValueError ) : [EOL] ConfigValueBool ( val_name , description = [string] , default = True ) [EOL] validate_config ( ) [EOL] [EOL] [EOL] def test_missing_multiple ( ) : [EOL] ConfigValueBool ( [string] , [string] , [string] , description = [string] ) [EOL] ConfigValueBool ( [string] , [string] , description = [string] ) [EOL] try : [EOL] validate_config ( ) [EOL] except MissingValueError as e : [EOL] assert [string] in str ( e ) [EOL] assert [string] in str ( e ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_config [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ConfigValueString , ConfigValueTypeError , MissingValueError [EOL] from elib_config . _types import Types [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_string_value ( ) : [EOL] yield ConfigValueString ( [string] , description = [string] , default = [string] , ) [EOL] [EOL] [EOL] def test_no_default ( ) : [EOL] value = ConfigValueString ( [string] , [string] , description = [string] , ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_string_value_default ( value ) : [EOL] assert value ( ) == [string] [EOL] [EOL] [EOL] def test_string_value_type_name ( value ) : [EOL] assert value . type_name == Types . string [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [string] , [string] , [string] , ] ) def test_invalid_cast_type_from_config_file ( value , file_value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { file_value }' ) [EOL] exc_msg = f'{ value . name } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = exc_msg ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) == [string] [EOL] assert isinstance ( value ( ) , str ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file_single_quotes ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) == [string] [EOL] assert isinstance ( value ( ) , str ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import elib_config [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] from elib_config import ConfigValueBool , ConfigValueTypeError , MissingValueError [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_string_value ( ) : [EOL] yield ConfigValueBool ( [string] , description = [string] , default = True , ) [EOL] [EOL] [EOL] def test_no_default ( ) : [EOL] value = ConfigValueBool ( [string] , [string] , description = [string] , ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_string_value_default ( value ) : [EOL] assert value ( ) is True [EOL] [EOL] [EOL] def test_string_value_type_name ( value ) : [EOL] assert value . type_name == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [number] , [string] , [string] , [string] , ] ) def test_invalid_cast_type_from_config_file ( value , file_value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { file_value }' ) [EOL] exc_msg = f'{ value . name } [string] ' f' [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = exc_msg ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) is False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] import builtins [EOL] from typing import Any [EOL] import elib_config [EOL] import typing [EOL] import pathlib [EOL] [EOL] import pytest [EOL] [EOL] [comment] [EOL] from elib_config import ConfigValueList , ConfigValueTypeError , MissingValueError , _types , _utils [EOL] [EOL] [EOL] @ pytest . fixture ( name = [string] ) def _dummy_string_value ( ) : [EOL] yield ConfigValueList ( [string] , element_type = str , description = [string] , default = [ [string] , [string] ] , ) [EOL] [EOL] [EOL] def test_no_default ( ) : [EOL] value = ConfigValueList ( [string] , [string] , element_type = str , description = [string] , ) [EOL] with pytest . raises ( MissingValueError ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_string_value_default ( value ) : [EOL] assert value ( ) == [ [string] , [string] ] [EOL] [EOL] [EOL] def test_string_value_type_name ( value ) : [EOL] assert value . type_name == [string] [EOL] assert value . friendly_type_name == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [number] , [string] ) , ( [number] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] ) def test_invalid_cast_type_from_config_file ( value , file_value , wrong_type ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { file_value }' ) [EOL] exc_msg = f'{ value . name } [string] { _types . Types . array } [string] { wrong_type } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = exc_msg ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_valid_cast_type_from_config_file ( value ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] ' ) [EOL] assert value ( ) == [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( True , False , [number] , [number] , [ [string] , [string] ] , { [string] : [string] } ) ) def test_element_type_check ( value , not_a_string ) : [EOL] value . default = [ [string] , [string] , not_a_string ] [EOL] actual_type = _utils . friendly_type_name ( type ( not_a_string ) ) [EOL] error = f'{ value . name } [string] { actual_type } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = error ) : [EOL] value ( ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , [string] , [string] ) ) def test_element_type_check_from_file ( value , not_a_string ) : [EOL] pathlib . Path ( [string] ) . write_text ( f' [string] { not_a_string } [string] ' ) [EOL] error = f'{ value . name } [string] ' [EOL] with pytest . raises ( ConfigValueTypeError , match = error ) : [EOL] value ( ) [EOL] [EOL] [EOL] def test_toml_example_unmanaged_element_type ( ) : [EOL] value = ConfigValueList ( [string] , element_type = bool , description = [string] ) [EOL] with pytest . raises ( KeyError ) : [EOL] value . _toml_add_examples ( { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Dict , MutableMapping , Any [EOL] import pathlib [EOL] import typing [EOL] import pathlib [EOL] [EOL] import pytest [EOL] import tomlkit . exceptions [EOL] [EOL] from elib_config import ConfigFileNotFoundError , EmptyValueError [EOL] [comment] [EOL] from elib_config . _file import _config_file [EOL] [EOL] [EOL] def test_ensure_config_file_exists_missing ( ) : [EOL] with pytest . raises ( ConfigFileNotFoundError ) : [EOL] _config_file . _ensure_config_file_exists ( ) [EOL] [EOL] [EOL] def test_ensure_config_file_exists ( ) : [EOL] pathlib . Path ( [string] ) . touch ( ) [EOL] _config_file . _ensure_config_file_exists ( ) [EOL] [EOL] [EOL] def test_read_file_empty ( ) : [EOL] config = _config_file . _read_file ( ) [EOL] assert isinstance ( config , dict ) [EOL] assert not config [EOL] [EOL] [EOL] def test_read_file_basic ( ) : [EOL] pathlib . Path ( [string] ) . write_text ( [string] ) [EOL] config = _config_file . _read_file ( ) [EOL] assert isinstance ( config , dict ) [EOL] assert config [EOL] assert [string] in config [EOL] assert config [ [string] ] == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , ] ) def test_invalid_file ( file_content ) : [EOL] pathlib . Path ( [string] ) . write_text ( file_content ) [EOL] with pytest . raises ( tomlkit . exceptions . UnexpectedCharError ) : [EOL] _config_file . _read_file ( ) [EOL] [EOL] [EOL] def test_empty_value ( ) : [EOL] pathlib . Path ( [string] ) . write_text ( [string] ) [EOL] with pytest . raises ( EmptyValueError ) : [EOL] _config_file . read_config_file ( ) [EOL] [EOL] [EOL] def test_write_file ( ) : [EOL] config_file_path = pathlib . Path ( [string] ) [EOL] original_config = _config_file . read_config_file ( ) [EOL] assert original_config == { } [EOL] assert not config_file_path . exists ( ) [EOL] new_config = { [string] : [string] } [EOL] _config_file . _write_file ( new_config ) [EOL] assert config_file_path . exists ( ) [EOL] assert _config_file . read_config_file ( ) == new_config [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0