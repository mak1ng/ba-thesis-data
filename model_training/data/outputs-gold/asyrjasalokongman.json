[comment] [EOL] [comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] from os . path import abspath , dirname , join [EOL] from setuptools import setup , find_packages [EOL] [EOL] from kong import __version__ [EOL] [EOL] [EOL] classifiers = [string] . strip ( ) . splitlines ( ) [EOL] [EOL] curdir = dirname ( abspath ( __file__ ) ) [EOL] with open ( join ( curdir , [string] ) , encoding = [string] ) as f : [EOL] readme = f . read ( ) [EOL] with open ( join ( curdir , [string] ) , encoding = [string] ) as f : [EOL] requirements = f . read ( ) [EOL] [EOL] setup ( name = [string] , version = __version__ , description = [string] , long_description = readme , long_description_content_type = [string] , author = [string] , author_email = [string] , url = [string] , platforms = [string] , keywords = [string] , classifiers = classifiers , install_requires = requirements , packages = find_packages ( exclude = ( [string] , [string] ) ) , entry_points = { [string] : ( [string] ) } , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from . components import CrudComponent , KongEntity [EOL] [EOL] [EOL] class Certificates ( CrudComponent ) : [EOL] [docstring] [EOL] [EOL] def wrap ( self , data ) : [EOL] return Certificate ( self , data ) [EOL] [EOL] [EOL] class Certificate ( KongEntity ) : [EOL] def add_sni ( self , host ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] from . components import CrudComponent , KongEntity , KongError [EOL] [EOL] [EOL] class Consumers ( CrudComponent ) : [EOL] def wrap ( self , data ) : [EOL] return Consumer ( self , data ) [EOL] [EOL] async def apply_json ( self , data ) : [EOL] if not isinstance ( data , list ) : [EOL] data = [ data ] [EOL] result = [ ] [EOL] for entry in data : [EOL] if not isinstance ( entry , dict ) : [EOL] raise KongError ( [string] ) [EOL] username = entry . pop ( [string] , None ) [EOL] groups = entry . pop ( [string] , [ ] ) [EOL] if not username : [EOL] raise KongError ( [string] ) [EOL] try : [EOL] consumer = await self . get ( username ) [EOL] except KongError as exc : [EOL] if exc . status == [number] : [EOL] consumer = await self . create ( username = username , ** entry ) [EOL] else : [EOL] raise [EOL] else : [EOL] if entry : [EOL] consumer = await self . update ( username , ** entry ) [EOL] acls = await consumer . acls ( ) [EOL] current_groups = dict ( ( ( a [ [string] ] , a ) for a in acls ) ) [EOL] for group in groups : [EOL] if group not in current_groups : [EOL] await consumer . create_acls ( group ) [EOL] else : [EOL] current_groups . pop ( group ) [EOL] [EOL] for acl in current_groups . values ( ) : [EOL] await consumer . delete_acls ( acl [ [string] ] ) [EOL] [EOL] result . append ( consumer . data ) [EOL] [EOL] return result [EOL] [EOL] [EOL] class Consumer ( KongEntity ) : [EOL] @ property def username ( self ) : [EOL] return self . data . get ( [string] ) [EOL] [EOL] async def jwts ( self ) : [EOL] url = f"{ self . url } [string] " [EOL] result = await self . cli . execute ( url , [string] ) [EOL] return result [ [string] ] [EOL] [EOL] def create_jwt ( self ) : [EOL] url = f"{ self . url } [string] " [EOL] return self . cli . execute ( url , [string] , headers = { [string] : [string] } , ) [EOL] [EOL] async def get_or_create_jwt ( self ) : [EOL] url = f"{ self . url } [string] " [EOL] result = await self . cli . execute ( url , [string] ) [EOL] secrets = result [ [string] ] [EOL] return secrets [ [number] ] if secrets else await self . create_jwt ( ) [EOL] [EOL] def get_jwt ( self , id ) : [EOL] url = f"{ self . url } [string] { id }" [EOL] return self . cli . execute ( url ) [EOL] [EOL] def delete_jwt ( self , id ) : [EOL] url = f"{ self . url } [string] { id }" [EOL] return self . cli . execute ( url , [string] ) [EOL] [EOL] async def key_auths ( self ) : [EOL] url = f"{ self . url } [string] " [EOL] result = await self . cli . execute ( url , [string] ) [EOL] return result [ [string] ] [EOL] [EOL] def create_key_auth ( self ) : [EOL] url = f"{ self . url } [string] " [EOL] return self . cli . execute ( url , [string] , headers = { [string] : [string] } , ) [EOL] [EOL] def delete_key_auth ( self , id ) : [EOL] url = f"{ self . url } [string] { id }" [EOL] return self . cli . execute ( url , [string] ) [EOL] [EOL] def create_acls ( self , group ) : [EOL] url = f"{ self . url } [string] " [EOL] return self . cli . execute ( url , [string] , json = dict ( group = group ) ) [EOL] [EOL] def delete_acls ( self , id ) : [EOL] url = f"{ self . url } [string] { id }" [EOL] return self . cli . execute ( url , [string] ) [EOL] [EOL] def acls ( self , ** params ) : [EOL] params [ [string] ] = self . id [EOL] return self . cli . acls . get_list ( ** params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import socket [EOL] import typing [EOL] import socket [EOL] from multidict import MultiDict [EOL] [EOL] [EOL] def as_list ( key , data ) : [EOL] v = data . get ( key ) [EOL] if isinstance ( v , str ) : [EOL] v = [ v ] [EOL] elif not isinstance ( v , list ) : [EOL] v = [ ] [EOL] data [ key ] = v [EOL] return data [EOL] [EOL] [EOL] def local_ip ( ) : [EOL] s = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) [EOL] s . connect ( ( [string] , [number] ) ) [EOL] try : [EOL] return s . getsockname ( ) [ [number] ] [EOL] finally : [EOL] s . close ( ) [EOL] [EOL] [EOL] def as_params ( * , params = None , ** kwargs ) : [EOL] params = MultiDict ( params if params is not None else { } ) [EOL] params . update ( kwargs ) [EOL] return params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] __version__ = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] from . components import CrudComponent , KongEntity [EOL] [EOL] [EOL] class Snis ( CrudComponent ) : [EOL] [docstring] [EOL] [EOL] def wrap ( self , data ) : [EOL] return Sni ( self , data ) [EOL] [EOL] async def apply_json ( self , data ) : [EOL] [docstring] [EOL] if not isinstance ( data , list ) : [EOL] data = [ data ] [EOL] result = [ ] [EOL] for entry in data : [EOL] name = entry . pop ( [string] ) [EOL] if await self . has ( name ) : [EOL] sni = await self . update ( name , ** entry ) [EOL] else : [EOL] sni = await self . create ( name = name , ** entry ) [EOL] result . append ( sni . data ) [EOL] return result [EOL] [EOL] [EOL] class Sni ( KongEntity ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0
from . components import CrudComponent , KongEntity [EOL] [EOL] [EOL] class Acls ( CrudComponent ) : [EOL] [docstring] [EOL] [EOL] def wrap ( self , data ) : [EOL] return Acl ( self , data ) [EOL] [EOL] [EOL] class Acl ( KongEntity ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0