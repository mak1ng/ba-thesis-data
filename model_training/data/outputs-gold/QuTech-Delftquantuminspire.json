from typing import List [EOL] import typing [EOL] [docstring] [EOL] from setuptools import setup [EOL] [EOL] [EOL] def get_version_number ( module ) : [EOL] [docstring] [EOL] with open ( [string] . format ( module ) , [string] ) as file_stream : [EOL] line = file_stream . readline ( ) . split ( ) [EOL] version_number = line [ [number] ] . replace ( [string] , [string] ) [EOL] return version_number [EOL] [EOL] [EOL] def get_long_description ( ) : [EOL] [docstring] [EOL] [EOL] with open ( [string] , encoding = [string] ) as f : [EOL] long_description = f . read ( ) [EOL] [EOL] return long_description [EOL] [EOL] [EOL] setup ( name = [string] , description = [string] , long_description = get_long_description ( ) , long_description_content_type = [string] , version = get_version_number ( [string] ) , author = [string] , python_requires = [string] , package_dir = { [string] : [string] } , data_files = [ ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , ( [string] , [ [string] ] ) , ( [string] , [ [string] , [string] , [string] , [string] , [string] , [string] ] ) ] , classifiers = [ [string] , [string] , [string] , [string] , [string] ] , license = [string] , packages = [ [string] , [string] , [string] ] , install_requires = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , extras_require = { [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Optional , Match , Pattern [EOL] import typing [EOL] [docstring] [EOL] [EOL] import re [EOL] import unittest [EOL] from quantuminspire import __version__ [EOL] [EOL] [EOL] class TestVersion ( unittest . TestCase ) : [EOL] [EOL] def test_version_HasCorrectFormat ( self ) : [EOL] search_pattern = re . compile ( [string] ) [EOL] match = search_pattern . match ( __version__ ) [EOL] self . assertIsNotNone ( match ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 $typing.Pattern[builtins.str]$ 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0
	0
from typing import Union , Any , OrderedDict , Set , Dict [EOL] import unittest [EOL] import typing [EOL] import collections [EOL] [docstring] [EOL] from unittest import TestCase [EOL] from unittest . mock import Mock [EOL] from collections import OrderedDict [EOL] from coreapi . exceptions import ErrorMessage [EOL] [EOL] from quantuminspire . job import QuantumInspireJob [EOL] [EOL] [EOL] class TestQuantumInspireJob ( TestCase ) : [EOL] [EOL] def test_qi_job_invalid_api ( self ) : [EOL] api = Mock ( ) [EOL] job_identifier = [number] [EOL] self . assertRaises ( ValueError , QuantumInspireJob , api , job_identifier ) [EOL] [EOL] def test_qi_job_invalid_job_identifier ( self ) : [EOL] api = Mock ( ) [EOL] type ( api ) . __name__ = [string] [EOL] api . get_job . side_effect = ErrorMessage ( [string] ) [EOL] job_identifier = [number] [EOL] self . assertRaises ( ValueError , QuantumInspireJob , api , job_identifier ) [EOL] api . get_job . called_once ( ) [EOL] [EOL] def test_check_status ( self ) : [EOL] expected = [string] [EOL] api = Mock ( ) [EOL] api . get_job . return_value = { [string] : expected } [EOL] type ( api ) . __name__ = [string] [EOL] job_identifier = [number] [EOL] qi_job = QuantumInspireJob ( api , job_identifier ) [EOL] actual = qi_job . check_status ( ) [EOL] self . assertEqual ( expected , actual ) [EOL] [EOL] def test_retrieve_result ( self ) : [EOL] expected = OrderedDict ( [ ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , { [string] , [number] , [string] , [number] } ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) ] ) [EOL] api = Mock ( ) [EOL] api . get_result_from_job . return_value = expected [EOL] type ( api ) . __name__ = [string] [EOL] job_identifier = [number] [EOL] qi_job = QuantumInspireJob ( api , job_identifier ) [EOL] actual = qi_job . retrieve_results ( ) [EOL] self . assertDictEqual ( expected , actual ) [EOL] api . get_result_from_job . assert_called_once_with ( job_identifier ) [EOL] [EOL] def test_get_job_identifier ( self ) : [EOL] api = Mock ( ) [EOL] type ( api ) . __name__ = [string] [EOL] job_identifier = [number] [EOL] qi_job = QuantumInspireJob ( api , job_identifier ) [EOL] actual = qi_job . get_job_identifier ( ) [EOL] self . assertEqual ( actual , job_identifier ) [EOL] [EOL] def test_get_project_identifier ( self ) : [EOL] api = Mock ( ) [EOL] expected = [number] [EOL] asset = { [string] : expected } [EOL] type ( api ) . __name__ = [string] [EOL] api . get_job . return_value = { [string] : asset } [EOL] api . get_asset_from_job . return_value = asset [EOL] [EOL] job_identifier = [number] [EOL] qi_job = QuantumInspireJob ( api , job_identifier ) [EOL] actual = qi_job . get_project_identifier ( ) [EOL] self . assertEqual ( expected , actual ) [EOL] api . get_asset_from_job . assert_called_once_with ( job_identifier ) [EOL] api . get_job . assert_called_with ( job_identifier ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,typing.Union[typing.Set[typing.Union[builtins.float,builtins.str]],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $collections.OrderedDict[builtins.str,typing.Union[typing.Set[typing.Union[builtins.float,builtins.str]],builtins.float,builtins.str]]$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[builtins.str,typing.Union[typing.Set[typing.Union[builtins.float,builtins.str]],builtins.float,builtins.str]]$ 0 $typing.Any$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.int$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.int$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.int$ 0 0
from typing import List , Union , Dict , Any [EOL] import src [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] [EOL] import json [EOL] import unittest [EOL] from collections import OrderedDict [EOL] from unittest . mock import Mock , patch [EOL] [EOL] import numpy as np [EOL] import qiskit [EOL] from coreapi . exceptions import ErrorMessage [EOL] from qiskit . providers . models import QasmBackendConfiguration [EOL] from qiskit . providers . models . backendconfiguration import GateConfig [EOL] from qiskit . qobj import QasmQobjExperiment , QasmQobj [EOL] [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . exceptions import QisKitBackendError [EOL] from quantuminspire . qiskit . backend_qx import QuantumInspireBackend [EOL] from quantuminspire . qiskit . qi_job import QIJob [EOL] from quantuminspire . qiskit . quantum_inspire_provider import QuantumInspireProvider [EOL] from quantuminspire . version import __version__ as quantum_inspire_version [EOL] [EOL] [EOL] def first_item ( iterable ) : [EOL] [docstring] [EOL] return next ( iter ( iterable ) ) [EOL] [EOL] [EOL] class TestQiSimulatorPy ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] operations = [ ] [EOL] self . _basic_experiment_dictionary = { [string] : operations , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [number] ] ] } , [string] : { [string] : [string] , [string] : [string] [string] , [string] : [number] } } [EOL] self . _basic_qobj_dictionary = { [string] : [string] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [ { [string] : operations , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] , [string] : [ [ [string] , [number] ] ] } , [string] : { [string] : [string] , [string] : [string] [string] , [string] : [number] } } ] , [string] : { [string] : [string] } , [string] : [string] , [string] : [string] } [EOL] [EOL] self . _basic_job_dictionary = OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , True ) , ( [string] , [string] ) ] ) [EOL] [EOL] @ staticmethod def _instructions_to_two_qubit_experiment ( instructions ) : [EOL] experiment_dict = { [string] : instructions , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : [number] } } [EOL] experiment = qiskit . qobj . QasmQobjExperiment . from_dict ( experiment_dict ) [EOL] return experiment [EOL] [EOL] def test__collect_measurements ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] experiment = self . _instructions_to_two_qubit_experiment ( instructions ) [EOL] [EOL] measurements = QuantumInspireBackend . _collect_measurements ( experiment ) [EOL] self . assertDictEqual ( measurements , { [string] : [ [ [number] , [number] ] , [ [number] , [number] ] ] , [string] : [number] } ) [EOL] [EOL] def test__collect_measurements_without_measurements ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] experiment = self . _instructions_to_two_qubit_experiment ( instructions ) [EOL] [EOL] measurements = QuantumInspireBackend . _collect_measurements ( experiment ) [EOL] self . assertDictEqual ( measurements , { [string] : [ [ [number] , [number] ] , [ [number] , [number] ] ] , [string] : [number] } ) [EOL] [EOL] def test_backend_name ( self ) : [EOL] simulator = QuantumInspireBackend ( Mock ( ) , Mock ( ) ) [EOL] name = simulator . backend_name [EOL] self . assertEqual ( [string] , name ) [EOL] [EOL] def test_backend_default_configuration ( self ) : [EOL] simulator = QuantumInspireBackend ( Mock ( ) , Mock ( ) ) [EOL] configuration = simulator . configuration ( ) [EOL] expected_configuration = QasmBackendConfiguration ( backend_name = [string] , backend_version = quantum_inspire_version , n_qubits = [number] , basis_gates = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , gates = [ GateConfig ( name = [string] , parameters = [ [string] ] , qasm_def = [string] ) ] , conditional = True , simulator = True , local = False , memory = True , open_pulse = False , max_shots = [number] , max_experiments = [number] , coupling_map = None ) [EOL] self . assertDictEqual ( configuration . to_dict ( ) , expected_configuration . to_dict ( ) ) [EOL] [EOL] def test_run_returns_correct_result ( self ) : [EOL] api = Mock ( ) [EOL] api . create_project . return_value = { [string] : [number] } [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] qobj_dict = self . _basic_qobj_dictionary [EOL] qobj_dict [ [string] ] [ [number] ] [ [string] ] = instructions [EOL] qobj = QasmQobj . from_dict ( qobj_dict ) [EOL] [EOL] job = simulator . run ( qobj ) [EOL] self . assertEqual ( [string] , job . job_id ( ) ) [EOL] [EOL] def test_get_experiment_results_raises_simulation_error_when_no_histogram ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [number] , [string] : [string] } ] [EOL] api . get_result_from_job . return_value = { [string] : [ ] , [string] : [string] } [EOL] job = Mock ( ) [EOL] job . job_id . return_value = [string] [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] with self . assertRaises ( QisKitBackendError ) as error : [EOL] simulator . get_experiment_results ( job ) [EOL] self . assertEqual ( ( [string] , ) , error . exception . args ) [EOL] [EOL] def test_get_experiment_results_returns_correct_value ( self ) : [EOL] number_of_shots = [number] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] experiment = self . _instructions_to_two_qubit_experiment ( instructions ) [EOL] api = Mock ( ) [EOL] api . get_result_from_job . return_value = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } [EOL] api . get_raw_data_from_result . return_value = [ [number] ] * [number] + [ [number] ] * [number] [EOL] jobs = self . _basic_job_dictionary [EOL] measurements = QuantumInspireBackend . _collect_measurements ( experiment ) [EOL] user_data = { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] , [string] : measurements } [EOL] jobs [ [string] ] = json . dumps ( user_data ) [EOL] api . get_jobs_from_project . return_value = [ jobs ] [EOL] job = QIJob ( [string] , [string] , api ) [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] experiment_result = simulator . get_experiment_results ( job ) [ [number] ] [EOL] self . assertEqual ( experiment_result . data . counts [ [string] ] , [number] ) [EOL] self . assertEqual ( experiment_result . data . counts [ [string] ] , [number] ) [EOL] self . assertEqual ( experiment_result . data . probabilities [ [string] ] , [number] ) [EOL] self . assertEqual ( experiment_result . data . probabilities [ [string] ] , [number] ) [EOL] self . assertEqual ( len ( experiment_result . data . memory ) , [number] ) [EOL] self . assertEqual ( experiment_result . data . memory . count ( [string] ) , [number] ) [EOL] self . assertEqual ( experiment_result . data . memory . count ( [string] ) , [number] ) [EOL] self . assertEqual ( experiment_result . name , [string] ) [EOL] self . assertEqual ( experiment_result . shots , number_of_shots ) [EOL] [EOL] def test_get_experiment_results_returns_single_shot ( self ) : [EOL] number_of_shots = [number] [EOL] self . _basic_job_dictionary [ [string] ] = number_of_shots [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] experiment = self . _instructions_to_two_qubit_experiment ( instructions ) [EOL] api = Mock ( ) [EOL] api . get_result_from_job . return_value = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } [EOL] api . get_raw_data_from_result . return_value = [ ] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] jobs = self . _basic_job_dictionary [EOL] measurements = QuantumInspireBackend . _collect_measurements ( experiment ) [EOL] user_data = { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] , [string] : measurements } [EOL] jobs [ [string] ] = json . dumps ( user_data ) [EOL] api . get_jobs_from_project . return_value = [ jobs ] [EOL] job = QIJob ( [string] , [string] , api ) [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] experiment_result = simulator . get_experiment_results ( job ) [ [number] ] [EOL] self . assertEqual ( experiment_result . data . probabilities [ [string] ] , [number] ) [EOL] self . assertEqual ( experiment_result . data . probabilities [ [string] ] , [number] ) [EOL] self . assertTrue ( hasattr ( experiment_result . data , [string] ) ) [EOL] [comment] [EOL] self . assertEqual ( len ( experiment_result . data . counts ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( list ( experiment_result . data . counts . values ( ) ) [ [number] ] , [number] ) [EOL] [comment] [EOL] self . assertEqual ( len ( experiment_result . data . memory ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( list ( experiment_result . data . counts . keys ( ) ) [ [number] ] , experiment_result . data . memory [ [number] ] ) [EOL] self . assertEqual ( experiment_result . name , [string] ) [EOL] self . assertEqual ( experiment_result . shots , number_of_shots ) [EOL] [EOL] def test_get_experiment_results_multiple_single_shots ( self ) : [EOL] one_shot_results = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] np . random . seed ( [number] ) [EOL] for i in range ( [number] ) : [EOL] number_of_shots = [number] [EOL] self . _basic_job_dictionary [ [string] ] = number_of_shots [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] experiment = self . _instructions_to_two_qubit_experiment ( instructions ) [EOL] api = Mock ( ) [EOL] api . get_result_from_job . return_value = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } [EOL] api . get_raw_data_from_result . return_value = [ ] [EOL] jobs = self . _basic_job_dictionary [EOL] measurements = QuantumInspireBackend . _collect_measurements ( experiment ) [EOL] user_data = { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] , [string] : measurements } [EOL] jobs [ [string] ] = json . dumps ( user_data ) [EOL] api . get_jobs_from_project . return_value = [ jobs ] [EOL] job = QIJob ( [string] , [string] , api ) [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] experiment_result = simulator . get_experiment_results ( job ) [ [number] ] [EOL] [comment] [EOL] self . assertEqual ( len ( experiment_result . data . memory ) , [number] ) [EOL] [comment] [EOL] self . assertEqual ( list ( experiment_result . data . counts . keys ( ) ) [ [number] ] , experiment_result . data . memory [ [number] ] ) [EOL] one_shot_results [ experiment_result . data . memory [ [number] ] ] += [number] [EOL] [EOL] self . assertEqual ( one_shot_results [ [string] ] , [number] ) [EOL] self . assertEqual ( one_shot_results [ [string] ] , [number] ) [EOL] self . assertEqual ( one_shot_results [ [string] ] , [number] ) [EOL] self . assertEqual ( one_shot_results [ [string] ] , [number] ) [EOL] [EOL] def test_validate_shot_count ( self ) : [EOL] api = Mock ( ) [EOL] api . create_project . return_value = { [string] : [number] } [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] [EOL] job_dict = self . _basic_qobj_dictionary [EOL] job_dict [ [string] ] [ [string] ] = [number] [comment] [EOL] job = qiskit . qobj . QasmQobj . from_dict ( job_dict ) [comment] [EOL] job . config . shots = [number] [comment] [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] , simulator . run , job ) [EOL] job . config . shots = [number] [comment] [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] , simulator . run , job ) [EOL] [EOL] def test_validate_no_classical_qubits ( self ) : [EOL] api = Mock ( ) [EOL] api . create_project . return_value = { [string] : [number] } [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] job_dict = self . _basic_qobj_dictionary [EOL] job_dict [ [string] ] [ [number] ] [ [string] ] = [ ] [EOL] job_dict [ [string] ] [ [number] ] [ [string] ] [ [string] ] = [number] [EOL] job = qiskit . qobj . QasmQobj . from_dict ( job_dict ) [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] , simulator . run , job ) [EOL] [EOL] def test_validate_nr_classical_qubits_less_than_nr_qubits_conditional_gate ( self ) : [EOL] api = Mock ( ) [EOL] api . create_project . return_value = { [string] : [number] } [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] qobj_dict = self . _basic_qobj_dictionary [EOL] job_dict = self . _basic_qobj_dictionary [EOL] qobj_dict [ [string] ] [ [number] ] [ [string] ] = instructions [EOL] job_dict [ [string] ] [ [number] ] [ [string] ] [ [string] ] = [number] [EOL] job = qiskit . qobj . QasmQobj . from_dict ( job_dict ) [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] [string] , simulator . run , job ) [EOL] [EOL] def test_for_non_fsp_gate_after_measurement ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) as result_experiment : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] experiment = qobj . experiments [ [number] ] [EOL] simulator . run ( qobj ) [EOL] result_experiment . assert_called_once_with ( experiment , [number] , project = project , full_state_projection = False ) [EOL] [EOL] def test_for_non_fsp_measurements_at_begin_and_end ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) as result_experiment : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] experiment = qobj . experiments [ [number] ] [EOL] simulator . run ( qobj ) [EOL] result_experiment . assert_called_once_with ( experiment , [number] , project = project , full_state_projection = False ) [EOL] [EOL] def test_for_fsp_measurements_at_end_only ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) as result_experiment : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] experiment = qobj . experiments [ [number] ] [EOL] simulator . run ( qobj ) [EOL] result_experiment . assert_called_once_with ( experiment , [number] , project = project , full_state_projection = True ) [EOL] [EOL] def test_for_fsp_no_measurements ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) as result_experiment : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] experiment = qobj . experiments [ [number] ] [EOL] simulator . run ( qobj ) [EOL] result_experiment . assert_called_once_with ( experiment , [number] , project = project , full_state_projection = True ) [EOL] [EOL] def test_measurement_2_qubits_to_1_classical_bit ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] [string] , simulator . run , qobj ) [EOL] [EOL] def test_measurement_1_qubit_to_2_classical_bits ( self ) : [EOL] with patch . object ( QuantumInspireBackend , [string] , return_value = Mock ( ) ) : [EOL] api = Mock ( ) [EOL] project = { [string] : [number] } [EOL] api . create_project . return_value = project [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] experiment = self . _basic_experiment_dictionary [EOL] experiment [ [string] ] = instructions [EOL] qjob_dict = self . _basic_qobj_dictionary [EOL] qjob_dict [ [string] ] [ [number] ] = experiment [EOL] qobj = QasmQobj . from_dict ( qjob_dict ) [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] [string] , simulator . run , qobj ) [EOL] [EOL] def test_valid_non_fsp_measurement_qubit_to_classical ( self ) : [EOL] api = Mock ( ) [EOL] api . create_project . return_value = { [string] : [number] } [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] api . execute_qasm_async . return_value = [number] [EOL] api . get_backend_type_by_name . return_value = { [string] : [number] } [EOL] simulator = QuantumInspireBackend ( api , Mock ( ) ) [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } , { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] qobj_dict = self . _basic_qobj_dictionary [EOL] qobj_dict [ [string] ] [ [number] ] [ [string] ] = instructions [EOL] qobj = QasmQobj . from_dict ( qobj_dict ) [EOL] job = simulator . run ( qobj ) [EOL] self . assertEqual ( [string] , job . job_id ( ) ) [EOL] [EOL] def test_retrieve_job ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] backend = QuantumInspireBackend ( api , QuantumInspireProvider ( ) ) [EOL] qi_job = backend . retrieve_job ( [string] ) [EOL] api . get_project . assert_called_with ( [number] ) [EOL] self . assertEqual ( [string] , qi_job . job_id ( ) ) [EOL] [EOL] def test_retrieve_job_with_error ( self ) : [EOL] api = Mock ( side_effect = ErrorMessage ( error = [string] ) ) [EOL] api . get_project . side_effect = ErrorMessage ( error = [string] ) [EOL] backend = QuantumInspireBackend ( api , QuantumInspireProvider ( ) ) [EOL] with self . assertRaises ( QisKitBackendError ) as error : [EOL] backend . retrieve_job ( [string] ) [EOL] self . assertEqual ( ( [string] , ) , error . exception . args ) [EOL] [EOL] [EOL] class ApiMock ( Mock ) : [EOL] def __init__ ( self , spec , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( spec , * args , kwargs ) [EOL] self . result = { } [EOL] self . raw_data = [ ] [EOL] [EOL] @ staticmethod def _get_child_mock ( ** kw ) : [EOL] return Mock ( ** kw ) [EOL] [EOL] def set ( self , res1 , res2 ) : [EOL] self . result = res1 [EOL] self . raw_data = res2 [EOL] [EOL] def get_raw_data_from_result ( self , result_id ) : [EOL] if result_id == [number] : [EOL] return self . raw_data [EOL] return None [EOL] [EOL] def get_result_from_job ( self , job_id ) : [EOL] if job_id == [number] : [EOL] return self . result [EOL] return None [EOL] [EOL] [EOL] class TestQiSimulatorPyHistogram ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . mock_api = ApiMock ( spec = QuantumInspireAPI ) [EOL] self . mock_provider = Mock ( spec = QuantumInspireProvider ) [EOL] self . simulator = QuantumInspireBackend ( self . mock_api , self . mock_provider ) [EOL] self . _basic_job_dictionary = OrderedDict ( [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [number] ) , ( [string] , True ) , ( [string] , [string] ) ] ) [EOL] [EOL] def run_histogram_test ( self , single_experiment , mock_result1 , mock_result2 , expected_histogram , expected_histogram_prob , expected_memory ) : [EOL] self . mock_api . set ( mock_result1 , mock_result2 ) [EOL] jobs = self . _basic_job_dictionary [EOL] measurements = QuantumInspireBackend . _collect_measurements ( QasmQobjExperiment . from_dict ( single_experiment ) ) [EOL] user_data = { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] , [string] : measurements } [EOL] jobs [ [string] ] = json . dumps ( user_data ) [EOL] self . mock_api . get_jobs_from_project . return_value = [ jobs ] [EOL] job = QIJob ( [string] , [string] , self . mock_api ) [EOL] [EOL] result = self . simulator . get_experiment_results ( job ) [EOL] number_of_shots = jobs [ [string] ] [EOL] self . assertEqual ( [number] , len ( result ) ) [EOL] first_experiment = first_item ( result ) [EOL] actual = first_experiment . data . counts [EOL] self . assertDictEqual ( expected_histogram , actual ) [EOL] probabilities = first_experiment . data . probabilities [EOL] self . assertTrue ( len ( expected_histogram_prob . keys ( ) - probabilities . keys ( ) ) == [number] ) [EOL] for key in set ( probabilities . keys ( ) ) & set ( expected_histogram_prob . keys ( ) ) : [EOL] self . assertTrue ( np . isclose ( expected_histogram_prob [ key ] , probabilities [ key ] ) ) [EOL] self . assertTrue ( len ( first_experiment . data . memory ) == number_of_shots ) [EOL] self . assertListEqual ( expected_memory , first_experiment . data . memory ) [EOL] [EOL] @ staticmethod def _instructions_to_experiment ( instructions , memory_slots = [number] ) : [EOL] experiment_dictionary = { [string] : instructions , [string] : { [string] : [number] , [string] : memory_slots , [string] : [string] , [string] : [ [ [string] , [number] ] , [ [string] , [number] ] ] , [string] : [ [ [string] , [number] ] , [ [string] , [number] ] ] } } [EOL] return experiment_dictionary [EOL] [EOL] def test_convert_histogram_normal_measurement ( self ) : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] ) , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_classical_bits_are_displayed_correctly ( self ) : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] , memory_slots = [number] ) , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_convert_histogram_swapped_classical_qubits ( self ) : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] ) , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_convert_histogram_less_measurements_qubit_one ( self ) : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] ) , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_convert_histogram_less_measurements_qubit_two ( self ) : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] ) , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_convert_histogram_classical_bits_measure_same_qubits ( self ) : [EOL] self . run_histogram_test ( single_experiment = { [string] : [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] , [string] : { [string] : [number] , [string] : [number] , [string] : [string] , [string] : [ [ [string] , [number] ] , [ [string] , [number] ] ] , [string] : [ [ [string] , [number] ] , [ [string] , [number] ] ] } } , mock_result1 = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , [string] : [number] , [string] : [number] , [string] : [string] } , mock_result2 = [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] + [ [number] ] * [number] , expected_histogram = { [string] : [number] , [string] : [number] } , expected_histogram_prob = { [string] : [number] , [string] : [number] } , expected_memory = [ [string] ] * [number] + [ [string] ] * [number] ) [EOL] [EOL] def test_empty_histogram ( self ) : [EOL] with self . assertRaises ( QisKitBackendError ) as error : [EOL] self . run_histogram_test ( single_experiment = self . _instructions_to_experiment ( [ { [string] : [string] , [string] : [ [number] ] } , { [string] : [string] , [string] : [ [number] , [number] ] } , { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] ) , mock_result1 = { [string] : [number] , [string] : { } , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [string] } , mock_result2 = [ ] , expected_histogram = { } , expected_histogram_prob = { } , expected_memory = [ ] ) [EOL] self . assertEqual ( ( [string] , ) , error . exception . args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.tests.quantuminspire.qiskit.test_backend_qx.ApiMock$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.tests.quantuminspire.qiskit.test_backend_qx.ApiMock$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Type , Union , Any , Dict , List [EOL] import src [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from coreapi . auth import BasicAuthentication , TokenAuthentication [EOL] from qiskit . providers import QiskitBackendNotFoundError [EOL] [EOL] from quantuminspire . exceptions import ApiError [EOL] from quantuminspire . qiskit . quantum_inspire_provider import QuantumInspireProvider , QI_URL [EOL] [EOL] [EOL] class TestQuantumInspireProvider ( unittest . TestCase ) : [EOL] simulator_backend_type = { [string] : False , [string] : [string] , [string] : True , [string] : { } , [string] : [number] , [string] : [number] , [string] : { [string] : [ ] } , [string] : [number] } [EOL] hardware_backend_type = { [string] : True , [string] : [string] , [string] : True , [string] : { [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] ] , [string] : [ [string] ] , } , [string] : [number] , [string] : [number] , [string] : { [string] : [ [ [number] ] , [ [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] ] , [ [number] ] ] } , [string] : [number] } [EOL] [EOL] hardware_backend_type2 = { [string] : True , [string] : [string] , [string] : True , [string] : { [string] : [ [string] , [string] ] , [string] : [ [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] ] , } , [string] : [number] , [string] : [number] , [string] : { [string] : [ [ [number] ] , [ [number] ] ] } , [string] : [number] } [EOL] [EOL] def test_backends ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . simulator_backend_type ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] with self . assertRaises ( QiskitBackendNotFoundError ) as error : [EOL] quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( ( [string] , ) , error . exception . args ) [EOL] [EOL] def test_simulator_backend ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . simulator_backend_type ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] self . assertIsNone ( backend . configuration ( ) . coupling_map ) [EOL] self . assertTrue ( backend . configuration ( ) . simulator ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . n_qubits ) [EOL] self . assertTrue ( backend . configuration ( ) . memory ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_shots ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_experiments ) [EOL] self . assertTrue ( backend . configuration ( ) . conditional ) [EOL] self . assertEqual ( backend . configuration ( ) . basis_gates , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_hardware_backend ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . hardware_backend_type ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] self . assertEqual ( backend . configuration ( ) . coupling_map , [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertFalse ( backend . configuration ( ) . simulator ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . n_qubits ) [EOL] self . assertTrue ( backend . configuration ( ) . memory ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_shots ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_experiments ) [EOL] self . assertFalse ( backend . configuration ( ) . conditional ) [EOL] self . assertEqual ( backend . configuration ( ) . basis_gates , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_hardware_backend2 ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . hardware_backend_type2 ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] self . assertEqual ( backend . configuration ( ) . coupling_map , [ ( [number] , [number] ) , ( [number] , [number] ) ] ) [EOL] self . assertFalse ( backend . configuration ( ) . simulator ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . n_qubits ) [EOL] self . assertTrue ( backend . configuration ( ) . memory ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_shots ) [EOL] self . assertEqual ( [number] , backend . configuration ( ) . max_experiments ) [EOL] self . assertFalse ( backend . configuration ( ) . conditional ) [EOL] self . assertEqual ( backend . configuration ( ) . basis_gates , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_set_authentication_details ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_authentication_details ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . simulator_backend_type ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] [EOL] def test_set_basic_authentication ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] quantum_inpire_provider . _api . get_backend_types . return_value = [ self . simulator_backend_type ] [EOL] backend = quantum_inpire_provider . get_backend ( name = [string] ) [EOL] self . assertEqual ( [string] , backend . name ( ) ) [EOL] [EOL] def test_set_basic_authentication_with_url ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] api . get_backend_types . return_value = [ self . simulator_backend_type ] [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] email = [string] [EOL] secret = [string] [EOL] url = [string] [EOL] quantum_inpire_provider . set_basic_authentication ( email , secret , url ) [EOL] authentication = BasicAuthentication ( email , secret ) [EOL] api . assert_called_with ( url , authentication ) [EOL] [EOL] def test_set_token_authentication ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] token = [string] [EOL] quantum_inpire_provider . set_token_authentication ( token ) [EOL] api . assert_called_once ( ) [EOL] [EOL] def test_set_authentication ( self ) : [EOL] with mock . patch ( [string] ) as api : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] with self . assertRaises ( ApiError ) : [EOL] quantum_inpire_provider . backends ( name = [string] ) [EOL] token = [string] [EOL] authentication = TokenAuthentication ( token , scheme = [string] ) [EOL] quantum_inpire_provider . set_authentication ( authentication ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] authentication = BasicAuthentication ( [string] , [string] ) [EOL] quantum_inpire_provider . set_authentication ( authentication ) [EOL] api . assert_called_with ( QI_URL , authentication ) [EOL] [EOL] def test_string_method ( self ) : [EOL] quantum_inpire_provider = QuantumInspireProvider ( ) [EOL] expected = [string] [EOL] actual = str ( quantum_inpire_provider ) [EOL] self . assertEqual ( expected , actual ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.List[builtins.int]]],typing.Dict[builtins.str,typing.List[builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.List[builtins.int]]],typing.Dict[builtins.str,typing.List[builtins.str]],builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0
from typing import List , Union , Dict , Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] import numpy as np [EOL] import qiskit [EOL] from qiskit import QuantumRegister , ClassicalRegister , QuantumCircuit [EOL] from qiskit . compiler import assemble , transpile [EOL] from qiskit . circuit import Instruction [EOL] from qiskit . assembler . run_config import RunConfig [EOL] from qiskit . qobj import QobjHeader [EOL] from quantuminspire . qiskit . circuit_parser import CircuitToString [EOL] from quantuminspire . qiskit . backend_qx import QuantumInspireBackend [EOL] from quantuminspire . exceptions import ApiError [EOL] [EOL] [EOL] class TestQiCircuitToString ( unittest . TestCase ) : [EOL] [EOL] def test_generate_cqasm_with_entangle_algorithm ( self ) : [EOL] q = QuantumRegister ( [number] ) [EOL] b = ClassicalRegister ( [number] ) [EOL] circuit = QuantumCircuit ( q , b ) [EOL] [EOL] circuit . h ( q [ [number] ] ) [EOL] circuit . cx ( q [ [number] ] , q [ [number] ] ) [EOL] circuit . measure ( q [ [number] ] , b [ [number] ] ) [EOL] circuit . measure ( q [ [number] ] , b [ [number] ] ) [EOL] [EOL] backend = QuantumInspireBackend ( Mock ( ) , Mock ( ) ) [EOL] [comment] [EOL] new_circuits = transpile ( circuit , backend ) [EOL] run_config = RunConfig ( shots = [number] , max_credits = [number] , memory = False ) [EOL] [comment] [EOL] qiskit_job = assemble ( new_circuits , backend , run_config = run_config . to_dict ( ) ) [EOL] [EOL] experiment = qiskit_job . experiments [ [number] ] [EOL] result = backend . _generate_cqasm ( experiment ) [EOL] expected = [string] [string] [string] [string] [string] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] @ staticmethod def _generate_cqasm_from_instructions ( instructions , number_of_qubits = [number] , full_state_projection = True ) : [EOL] experiment_dict = { [string] : instructions , [string] : { [string] : number_of_qubits , [string] : number_of_qubits , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] , [string] : number_of_qubits } } [EOL] experiment = qiskit . qobj . QasmQobjExperiment . from_dict ( experiment_dict ) [EOL] for instruction in experiment . instructions : [EOL] if hasattr ( instruction , [string] ) : [EOL] [comment] [EOL] qiskit_instruction = Instruction ( [string] , [number] , [number] , instruction . params ) [EOL] instruction . params = qiskit_instruction . params [EOL] [EOL] simulator = QuantumInspireBackend ( Mock ( ) , Mock ( ) ) [EOL] result = simulator . _generate_cqasm ( experiment , full_state_projection ) [EOL] return result [EOL] [EOL] def test_generate_cqasm_correct_output_controlled_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_controlled_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_controlled_not ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_controlled_not ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_toffoli ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , number_of_qubits = [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_toffoli ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_measure ( self ) : [EOL] instructions = [ { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] measure_line = [string] [EOL] self . assertTrue ( measure_line not in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_measure_q0_non_fsp ( self ) : [EOL] instructions = [ { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] , False ) [EOL] measure_line = [string] [EOL] self . assertTrue ( measure_line in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_measure_q1_non_fsp ( self ) : [EOL] instructions = [ { [string] : [ [number] ] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] , False ) [EOL] measure_line = [string] [EOL] self . assertTrue ( measure_line in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_hadamard ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_hadamard ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_barrier ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_barrier ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_identity ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_identity ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_s ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_s ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_sdag ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_sdag ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_swap ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_swap ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_t ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_t ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_tdag ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_tdag ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_x ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_x ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_y ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_y ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_u ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] , np . pi / [number] , - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_u ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] , np . pi / [number] , - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_u1 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_u1 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_u2 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi , np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , np . pi ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_u2 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi , np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , np . pi ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_gate_u3 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_gate_u3 ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] , [number] , [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_sympy_special_cases ( self ) : [EOL] [comment] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] [comment] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] [comment] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] [comment] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ - [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] [comment] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_rotation_x ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_rotation_x ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_rotation_y ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_rotation_y ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_rotation_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_conditional_rotation_z ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_unknown_gate ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] self . assertRaisesRegex ( ApiError , [string] , self . _generate_cqasm_from_instructions , instructions , [number] ) [EOL] [EOL] def test_generate_cqasm_correct_output_unknown_controlled_gate ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] self . assertRaisesRegex ( ApiError , [string] , self . _generate_cqasm_from_instructions , instructions , [number] ) [EOL] [EOL] def test_generate_cqasm_correct_output_no_bit_negation ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_one_bit_condition ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] self . assertFalse ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_more_bit_condition ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] } ] [EOL] result = self . _generate_cqasm_from_instructions ( instructions , [number] ) [EOL] self . assertTrue ( [string] in result ) [EOL] [EOL] def test_generate_cqasm_correct_output_unknown_type ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] self . assertRaisesRegex ( ApiError , [string] , self . _generate_cqasm_from_instructions , instructions , [number] ) [EOL] [EOL] def test_generate_cqasm_correct_output_no_mask ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] self . assertRaisesRegex ( ApiError , [string] , self . _generate_cqasm_from_instructions , instructions , [number] ) [EOL] [EOL] def test_generate_cqasm_register_no_match ( self ) : [EOL] instructions = [ { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , [string] : [string] } , { [string] : [number] , [string] : [string] , [string] : [ [number] ] , [string] : [ - np . pi / [number] ] } ] [EOL] self . assertRaisesRegex ( ApiError , [string] , self . _generate_cqasm_from_instructions , instructions , [number] ) [EOL] [EOL] def test_get_mask_data ( self ) : [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , - [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL] [EOL] mask = [number] [EOL] lowest_mask_bit , mask_length = CircuitToString . get_mask_data ( mask ) [EOL] self . assertEqual ( lowest_mask_bit , [number] ) [EOL] self . assertEqual ( mask_length , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.List[builtins.float],typing.List[builtins.int],builtins.int,builtins.str]],typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from qiskit . qobj import QobjHeader [EOL] from qiskit . result . models import ExperimentResult , ExperimentResultData [EOL] from quantuminspire . exceptions import QisKitBackendError [EOL] from quantuminspire . qiskit . qi_result import QIResult [EOL] [EOL] [EOL] class TestQIResult ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] experiment_result_data_1 = ExperimentResultData . from_dict ( { [string] : { [string] : [number] , [string] : [number] } } ) [EOL] experiment_result_data_1 . probabilities = { [string] : [number] , [string] : [number] } [EOL] experiment_result_data_2 = ExperimentResultData . from_dict ( { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } ) [EOL] experiment_result_data_2 . probabilities = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] experiment_result_data_3 = ExperimentResultData . from_dict ( { [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } } ) [EOL] [EOL] header_1 = QobjHeader . from_dict ( { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] } ) [EOL] header_2 = QobjHeader . from_dict ( { [string] : [string] , [string] : [number] , [string] : [ [ [string] , [number] ] ] } ) [EOL] header_3 = None [EOL] self . experiment_result_dictionary_1 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data_1 , [string] : [string] , [string] : True , [string] : [number] , [string] : header_1 } [EOL] self . experiment_result_dictionary_2 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data_2 , [string] : [string] , [string] : True , [string] : [number] , [string] : header_2 } [EOL] self . experiment_result_dictionary_3 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data_3 , [string] : [string] , [string] : True , [string] : [number] , [string] : header_3 } [EOL] self . experiment_result_1 = ExperimentResult ( ** self . experiment_result_dictionary_1 ) [EOL] self . experiment_result_2 = ExperimentResult ( ** self . experiment_result_dictionary_2 ) [EOL] self . experiment_result_3 = ExperimentResult ( ** self . experiment_result_dictionary_3 ) [EOL] [EOL] def test_constructor ( self ) : [EOL] backend_name = [string] [EOL] backend_version = [string] [EOL] qobj_id = [string] [EOL] job_id = [string] [EOL] success = True [EOL] date = [string] [EOL] experiment_result = self . experiment_result_1 [EOL] qi_result = QIResult ( backend_name , backend_version , qobj_id , job_id , success , [ experiment_result ] , date ) [EOL] [EOL] self . assertEqual ( date , qi_result . date ) [EOL] self . assertEqual ( job_id , qi_result . job_id ) [EOL] self . assertIsNotNone ( qi_result . results ) [EOL] self . assertListEqual ( [ [string] ] , [ r . name for r in qi_result . results ] ) [EOL] [EOL] def test_more_results ( self ) : [EOL] backend_name = [string] [EOL] backend_version = [string] [EOL] qobj_id = [string] [EOL] job_id = [string] [EOL] success = True [EOL] experiment_result = [ self . experiment_result_1 , self . experiment_result_2 ] [EOL] qi_result = QIResult ( backend_name , backend_version , qobj_id , job_id , success , experiment_result ) [EOL] [EOL] probabilities = qi_result . get_probabilities ( [string] ) [EOL] self . assertDictEqual ( probabilities , { [string] : [number] , [string] : [number] } ) [EOL] probabilities = qi_result . get_probabilities ( [string] ) [EOL] self . assertDictEqual ( probabilities , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] probabilities = qi_result . get_probabilities ( [number] ) [EOL] self . assertDictEqual ( probabilities , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] probabilities = qi_result . get_probabilities ( ) [EOL] self . assertListEqual ( probabilities , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ] ) [EOL] [EOL] def test_no_probabilities ( self ) : [EOL] backend_name = [string] [EOL] backend_version = [string] [EOL] qobj_id = [string] [EOL] job_id = [string] [EOL] success = True [EOL] experiment_result = [ self . experiment_result_3 ] [EOL] qi_result = QIResult ( backend_name , backend_version , qobj_id , job_id , success , experiment_result ) [EOL] self . assertRaisesRegex ( QisKitBackendError , [string] , qi_result . get_probabilities , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.list$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.list$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.list$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock [EOL] [EOL] from qiskit . providers import JobStatus , JobError , JobTimeoutError [EOL] from qiskit . qobj import QasmQobj , QobjHeader , QasmQobjConfig [EOL] from qiskit . result . models import ExperimentResult , ExperimentResultData [EOL] [EOL] from quantuminspire . qiskit . qi_job import QIJob [EOL] [EOL] [EOL] class TestQIJob ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] experiment_result_data = ExperimentResultData . from_dict ( { [string] : { [string] : [number] } } ) [EOL] experiment_result_data_2 = ExperimentResultData . from_dict ( { [string] : { [string] : [number] } } ) [EOL] experiment_result_data_3 = ExperimentResultData . from_dict ( { } ) [EOL] header_1 = QobjHeader . from_dict ( { [string] : [string] } ) [EOL] header_2 = QobjHeader . from_dict ( { [string] : [string] } ) [EOL] header_3 = QobjHeader . from_dict ( { [string] : [string] } ) [EOL] self . experiment_result_dictionary_1 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data , [string] : [string] , [string] : True , [string] : [number] , [string] : header_1 } [EOL] self . experiment_result_dictionary_2 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data_2 , [string] : [string] , [string] : True , [string] : [number] , [string] : header_2 } [EOL] self . experiment_result_dictionary_3 = { [string] : [string] , [string] : [number] , [string] : experiment_result_data_3 , [string] : [string] , [string] : False , [string] : [number] , [string] : header_3 } [EOL] self . experiment_result_1 = ExperimentResult ( ** self . experiment_result_dictionary_1 ) [EOL] self . experiment_result_2 = ExperimentResult ( ** self . experiment_result_dictionary_2 ) [EOL] self . experiment_result_3 = ExperimentResult ( ** self . experiment_result_dictionary_3 ) [EOL] [EOL] def test_constructor ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] job_id = [string] [EOL] backend = [string] [EOL] job = QIJob ( backend , job_id , api ) [EOL] [EOL] self . assertEqual ( job_id , job . job_id ( ) ) [EOL] self . assertEqual ( api , job . _api ) [EOL] self . assertIsNone ( job . experiments ) [EOL] self . assertEqual ( JobStatus . CANCELLED , job . _status ) [EOL] [EOL] def test_constructor_with_qobj ( self ) : [EOL] api = Mock ( ) [EOL] job_id = [string] [EOL] backend = [string] [EOL] qobj = QasmQobj ( qobj_id = [string] , config = QasmQobjConfig ( ) , experiments = [ ] , header = QobjHeader ( ) ) [EOL] job = QIJob ( backend , job_id , api , qobj ) [EOL] [EOL] self . assertIs ( qobj , job . _qobj ) [EOL] self . assertEqual ( job . job_id ( ) , [string] ) [EOL] self . assertEqual ( api , job . _api ) [EOL] self . assertIsNone ( job . experiments ) [EOL] self . assertEqual ( JobStatus . INITIALIZING , job . _status ) [EOL] [EOL] def test_submit_raises_error ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] backend . run . return_value = [string] [EOL] job = QIJob ( backend , job_id , api ) [EOL] with self . assertRaises ( JobError ) : [EOL] job . submit ( ) [EOL] [EOL] def test_submit ( self ) : [EOL] backend = Mock ( ) [EOL] backend . run . return_value = [string] [EOL] api = Mock ( ) [EOL] job_id = [string] [EOL] qobj = QasmQobj ( qobj_id = [string] , config = QasmQobjConfig ( ) , experiments = [ ] , header = QobjHeader ( ) ) [EOL] job = QIJob ( backend , job_id , api , qobj ) [EOL] [EOL] job . submit ( ) [EOL] self . assertEqual ( [string] , job . job_id ( ) ) [EOL] [EOL] def test_result ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] backend . get_experiment_results . return_value = [ self . experiment_result_1 , self . experiment_result_2 ] [EOL] backend . backend_name = [string] [EOL] job = QIJob ( backend , job_id , api ) [EOL] results = job . result ( ) [EOL] [EOL] self . assertTrue ( results . success ) [EOL] self . assertDictEqual ( { [string] : { [string] : [number] } } , results . data ( [number] ) ) [EOL] self . assertDictEqual ( { [string] : { [string] : [number] } } , results . data ( [number] ) ) [EOL] self . assertDictEqual ( { [string] : [number] } , results . get_counts ( [number] ) ) [EOL] self . assertDictEqual ( { [string] : [number] } , results . get_counts ( [number] ) ) [EOL] self . assertEqual ( [string] , results . job_id ) [EOL] self . assertListEqual ( [ [string] , [string] ] , [ r . name for r in results . results ] ) [EOL] self . assertListEqual ( [ [string] , [string] ] , [ r . status for r in results . results ] ) [EOL] [EOL] def test_result_timeout ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] job = QIJob ( backend , job_id , api ) [EOL] with self . assertRaises ( JobTimeoutError ) : [EOL] job . result ( timeout = [number] , wait = [number] ) [EOL] [EOL] def test_result_cancelled ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] backend . get_experiment_results . return_value = [ self . experiment_result_3 ] [EOL] backend . backend_name = [string] [EOL] job = QIJob ( backend , job_id , api ) [EOL] results = job . result ( timeout = None ) . results [ [number] ] [EOL] self . assertFalse ( results . success ) [EOL] self . assertEqual ( results . status , [string] ) [EOL] [EOL] def test_cancel ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] job = QIJob ( backend , job_id , api ) [EOL] job . cancel ( ) [EOL] api . delete_project . assert_called_with ( [number] ) [EOL] [EOL] def test_status ( self ) : [EOL] api = Mock ( ) [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] job_id = [string] [EOL] backend = Mock ( ) [EOL] job = QIJob ( backend , job_id , api ) [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . RUNNING , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . DONE , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . ERROR , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . QUEUED , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . CANCELLED , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . RUNNING , status ) [EOL] [EOL] api . get_jobs_from_project . return_value = [ { [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] } ] [EOL] status = job . status ( ) [EOL] self . assertEqual ( JobStatus . RUNNING , status ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 $builtins.str$ 0 $unittest.mock.Mock$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
	0
[docstring] [EOL] [EOL] [EOL] class QisKitBackendError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ProjectQBackendError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationError ( Exception ) : [EOL] [docstring] [EOL] [EOL] [EOL] class ApiError ( Exception ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . version import __version__ [EOL]	0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Dict , Any [EOL] from coreapi . exceptions import ErrorMessage [EOL] [EOL] [EOL] class QuantumInspireJob : [EOL] [EOL] def __init__ ( self , api , job_identifier ) : [EOL] [docstring] [EOL] QuantumInspireJob . __check_arguments ( api , job_identifier ) [EOL] self . __job_identifier = job_identifier [EOL] self . __api = api [EOL] [EOL] @ staticmethod def __check_arguments ( api , job_identifier ) : [EOL] [docstring] [EOL] if type ( api ) . __name__ != [string] : [EOL] raise ValueError ( [string] ) [EOL] try : [EOL] _ = api . get_job ( job_identifier ) [EOL] except ErrorMessage as error : [EOL] raise ValueError ( [string] ) from error [EOL] [EOL] def check_status ( self ) : [EOL] [docstring] [EOL] job = self . __api . get_job ( self . __job_identifier ) [EOL] return str ( job [ [string] ] ) [EOL] [EOL] def retrieve_results ( self ) : [EOL] [docstring] [EOL] result = self . __api . get_result_from_job ( self . __job_identifier ) [EOL] return result [EOL] [EOL] def get_job_identifier ( self ) : [EOL] [docstring] [EOL] return self . __job_identifier [EOL] [EOL] def get_project_identifier ( self ) : [EOL] [docstring] [EOL] asset = self . __api . get_asset_from_job ( self . __job_identifier ) [EOL] return int ( asset [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
__version__ = [string] [EOL]	$builtins.str$ 0 0 0
from typing import Optional , Dict , Any [EOL] import builtins [EOL] import coreapi [EOL] import typing [EOL] [docstring] [EOL] [EOL] import warnings [EOL] import os [EOL] import json [EOL] from typing import Optional [EOL] from coreapi . auth import BasicAuthentication , TokenAuthentication [EOL] [EOL] DEFAULT_QIRC_FILE = os . path . join ( os . path . expanduser ( [string] ) , [string] , [string] ) [EOL] [EOL] [EOL] def load_account ( filename = DEFAULT_QIRC_FILE ) : [EOL] [docstring] [EOL] token = os . environ . get ( [string] , None ) or read_account ( filename ) [EOL] return token [EOL] [EOL] [EOL] def read_account ( filename = DEFAULT_QIRC_FILE ) : [EOL] [docstring] [EOL] try : [EOL] with open ( filename , [string] ) as file : [EOL] accounts = json . load ( file ) [EOL] token = accounts [ [string] ] [EOL] except ( OSError , KeyError , ValueError ) : [comment] [EOL] token = None [EOL] return token if ( token and len ( token ) ) else None [EOL] [EOL] [EOL] def store_account ( token , filename = DEFAULT_QIRC_FILE , overwrite = False ) : [EOL] [docstring] [EOL] stored_token = read_account ( filename ) [EOL] if stored_token and stored_token != token and not overwrite : [EOL] warnings . warn ( [string] ) [EOL] return [EOL] save_account ( token , filename ) [EOL] [EOL] [EOL] def delete_account ( token , filename = DEFAULT_QIRC_FILE ) : [EOL] [docstring] [EOL] stored_token = read_account ( filename ) [EOL] if stored_token == token : [EOL] save_account ( [string] , filename ) [EOL] [EOL] [EOL] def save_account ( token , filename = DEFAULT_QIRC_FILE ) : [EOL] [docstring] [EOL] accounts = { [string] : token } [EOL] os . makedirs ( os . path . dirname ( filename ) , exist_ok = True ) [EOL] with open ( filename , [string] ) as config_file : [EOL] json . dump ( accounts , config_file , indent = [number] ) [EOL] [EOL] [EOL] def enable_account ( token ) : [EOL] [docstring] [EOL] os . environ [ [string] ] = token [EOL] [EOL] [EOL] def get_token_authentication ( token = None ) : [EOL] [docstring] [EOL] if not token : [EOL] token = load_account ( ) [EOL] return TokenAuthentication ( token , scheme = [string] ) [EOL] [EOL] [EOL] def get_basic_authentication ( email , password ) : [EOL] [docstring] [EOL] return BasicAuthentication ( email , password ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $coreapi.auth.TokenAuthentication$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $coreapi.auth.BasicAuthentication$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from quantuminspire . qiskit . quantum_inspire_provider import QuantumInspireProvider [EOL] [EOL] QI = QuantumInspireProvider ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Optional , List , Any [EOL] import builtins [EOL] import qiskit [EOL] import typing [EOL] import quantuminspire [EOL] [docstring] [EOL] import time [EOL] from typing import List , Optional , Any [EOL] [EOL] from qiskit . providers import BaseJob , JobError , JobTimeoutError [EOL] from qiskit . providers . jobstatus import JobStatus , JOB_FINAL_STATES [EOL] from qiskit . qobj import QasmQobj , QasmQobjExperiment [EOL] from quantuminspire . qiskit . qi_result import QIResult [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . version import __version__ as quantum_inspire_version [EOL] [EOL] [EOL] class QIJob ( BaseJob ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , backend , job_id , api , qobj = None ) : [EOL] [docstring] [EOL] self . _api = api [EOL] super ( ) . __init__ ( backend , job_id ) [EOL] self . experiments = None [EOL] self . _status = JobStatus . INITIALIZING [EOL] self . _qobj = qobj [EOL] if self . _qobj is not None : [EOL] self . _job_id = [string] [comment] [EOL] else : [EOL] self . status ( ) [EOL] [EOL] def submit ( self ) : [EOL] [docstring] [EOL] if self . _job_id : [EOL] raise JobError ( [string] ) [EOL] self . _job_id = self . _backend . run ( self . _qobj ) [EOL] [EOL] def result ( self , timeout = None , wait = [number] ) : [EOL] [docstring] [EOL] start_time = time . time ( ) [EOL] while self . status ( ) not in JOB_FINAL_STATES : [EOL] elapsed_time = time . time ( ) - start_time [EOL] if timeout is not None and elapsed_time > timeout : [EOL] raise JobTimeoutError ( [string] ) [EOL] time . sleep ( wait ) [EOL] experiment_results = self . _backend . get_experiment_results ( self ) [EOL] return QIResult ( backend_name = self . _backend . backend_name , backend_version = quantum_inspire_version , job_id = self . job_id ( ) , qobj_id = self . job_id ( ) , success = True , results = experiment_results ) [EOL] [EOL] def cancel ( self ) : [EOL] [docstring] [EOL] self . _api . delete_project ( int ( self . _job_id ) ) [EOL] [EOL] def status ( self ) : [EOL] [docstring] [EOL] jobs = self . _api . get_jobs_from_project ( int ( self . _job_id ) ) [EOL] number_of_jobs = len ( jobs ) [EOL] cancelled = len ( [ job for job in jobs if job [ [string] ] == [string] ] ) [EOL] running = len ( [ job for job in jobs if job [ [string] ] == [string] ] ) [EOL] completed = len ( [ job for job in jobs if job [ [string] ] == [string] ] ) [EOL] [EOL] if [number] < cancelled < number_of_jobs : [EOL] self . _status = JobStatus . ERROR [EOL] elif cancelled == number_of_jobs : [EOL] self . _status = JobStatus . CANCELLED [EOL] elif running > [number] or ( [number] < completed < number_of_jobs ) : [EOL] self . _status = JobStatus . RUNNING [EOL] elif completed == number_of_jobs : [EOL] self . _status = JobStatus . DONE [EOL] else : [EOL] self . _status = JobStatus . QUEUED [EOL] return self . _status [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 $quantuminspire.api.QuantumInspireAPI$ 0 $typing.Optional[qiskit.qobj.QasmQobj]$ 0 0 0 0 0 0 0 0 0 $quantuminspire.api.QuantumInspireAPI$ 0 $quantuminspire.api.QuantumInspireAPI$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $typing.Optional[typing.List[qiskit.qobj.QasmQobjExperiment]]$ 0 0 0 0 0 $qiskit.providers.jobstatus.JobStatus$ 0 0 0 0 0 0 0 $typing.Optional[qiskit.qobj.QasmQobj]$ 0 $typing.Optional[qiskit.qobj.QasmQobj]$ 0 0 0 0 $typing.Optional[qiskit.qobj.QasmQobj]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $quantuminspire.qiskit.qi_result.QIResult$ 0 0 0 $typing.Optional[builtins.float]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Optional[builtins.float]$ 0 0 0 0 $builtins.float$ 0 $typing.Optional[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.jobstatus.JobStatus$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Tuple , Any [EOL] import builtins [EOL] import io [EOL] import qiskit [EOL] import typing [EOL] [docstring] [EOL] import copy [EOL] import numpy as np [EOL] from io import StringIO [EOL] from typing import Optional , Tuple , List [EOL] from qiskit . qobj import QasmQobjInstruction [EOL] from quantuminspire . exceptions import ApiError [EOL] [EOL] [EOL] class CircuitToString : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , full_state_projection = True ) : [EOL] self . bfunc_instructions = [ ] [EOL] self . full_state_projection = full_state_projection [EOL] [EOL] @ staticmethod def _gate_not_supported ( _stream , instruction , _binary_control = None ) : [EOL] [docstring] [EOL] if hasattr ( instruction , [string] ) : [EOL] raise ApiError ( f' [string] { instruction . name . lower ( ) } [string] ' ) [EOL] else : [EOL] raise ApiError ( f' [string] { instruction . name . lower ( ) } [string] ' ) [EOL] [EOL] @ staticmethod def _cz ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_cz ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _cx ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_cx ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _ccx ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_ccx ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _h ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_h ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _id ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_id ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _s ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_s ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _sdg ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_sdg ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _swap ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_swap ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _t ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_t ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _tdg ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_tdg ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _x ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_x ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _y ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_y ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _z ( stream , instruction ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _c_z ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] stream . write ( [string] . format ( binary_control , * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def _r ( stream , instruction , axis ) : [EOL] [docstring] [EOL] angle_q0 = float ( instruction . params [ [number] ] ) [EOL] stream . write ( [string] . format ( axis , * instruction . qubits , angle_q0 ) ) [EOL] [EOL] @ staticmethod def _c_r ( stream , instruction , axis , binary_control ) : [EOL] [docstring] [EOL] angle_q0 = float ( instruction . params [ [number] ] ) [EOL] stream . write ( [string] . format ( axis , binary_control , * instruction . qubits , angle_q0 ) ) [EOL] [EOL] @ staticmethod def _rx ( stream , instruction ) : [EOL] [docstring] [EOL] CircuitToString . _r ( stream , instruction , [string] ) [EOL] [EOL] @ staticmethod def _c_rx ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] CircuitToString . _c_r ( stream , instruction , [string] , binary_control ) [EOL] [EOL] @ staticmethod def _ry ( stream , instruction ) : [EOL] [docstring] [EOL] CircuitToString . _r ( stream , instruction , [string] ) [EOL] [EOL] @ staticmethod def _c_ry ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] CircuitToString . _c_r ( stream , instruction , [string] , binary_control ) [EOL] [EOL] @ staticmethod def _rz ( stream , instruction ) : [EOL] [docstring] [EOL] CircuitToString . _r ( stream , instruction , [string] ) [EOL] [EOL] @ staticmethod def _c_rz ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] CircuitToString . _c_r ( stream , instruction , [string] , binary_control ) [EOL] [EOL] @ staticmethod def _u ( stream , instruction ) : [EOL] [docstring] [EOL] CircuitToString . _u3 ( stream , instruction ) [EOL] [EOL] @ staticmethod def _c_u ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] CircuitToString . _c_u3 ( stream , instruction , binary_control ) [EOL] [EOL] @ staticmethod def _u1 ( stream , instruction ) : [EOL] [docstring] [EOL] temp_instruction = copy . deepcopy ( instruction ) [EOL] temp_instruction . params [ [number] : [number] ] = ( [number] , [number] ) [EOL] CircuitToString . _u3 ( stream , temp_instruction ) [EOL] [EOL] @ staticmethod def _c_u1 ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] temp_instruction = copy . deepcopy ( instruction ) [EOL] temp_instruction . params [ [number] : [number] ] = ( [number] , [number] ) [EOL] CircuitToString . _c_u3 ( stream , temp_instruction , binary_control ) [EOL] [EOL] @ staticmethod def _u2 ( stream , instruction ) : [EOL] [docstring] [EOL] temp_instruction = copy . deepcopy ( instruction ) [EOL] temp_instruction . params . insert ( [number] , np . pi / [number] ) [EOL] CircuitToString . _u3 ( stream , temp_instruction ) [EOL] [EOL] @ staticmethod def _c_u2 ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] temp_instruction = copy . deepcopy ( instruction ) [EOL] temp_instruction . params . insert ( [number] , np . pi / [number] ) [EOL] CircuitToString . _c_u3 ( stream , temp_instruction , binary_control ) [EOL] [EOL] @ staticmethod def _u3 ( stream , instruction ) : [EOL] [docstring] [EOL] gates = [ [string] , [string] , [string] ] [EOL] angles = list ( float ( instruction . params [ i ] ) for i in [ [number] , [number] , [number] ] ) [EOL] index_q0 = [ instruction . qubits [ [number] ] ] * [number] [EOL] for triplet in zip ( gates , index_q0 , angles ) : [EOL] if triplet [ [number] ] != [number] : [EOL] stream . write ( [string] . format ( * triplet ) ) [EOL] [EOL] @ staticmethod def _c_u3 ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] gates = [ [string] , [string] , [string] ] [EOL] binary_controls = [ binary_control ] * [number] [EOL] angles = list ( float ( instruction . params [ i ] ) for i in [ [number] , [number] , [number] ] ) [EOL] index_q0 = [ instruction . qubits [ [number] ] ] * [number] [EOL] for quadruplets in zip ( gates , binary_controls , index_q0 , angles ) : [EOL] if quadruplets [ [number] ] != [number] : [EOL] stream . write ( [string] . format ( * quadruplets ) ) [EOL] [EOL] @ staticmethod def _barrier ( stream , instruction ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] @ staticmethod def _c_barrier ( stream , instruction , binary_control ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def _measure ( self , stream , instruction ) : [EOL] [docstring] [EOL] if not self . full_state_projection : [EOL] stream . write ( [string] . format ( * instruction . qubits ) ) [EOL] [EOL] @ staticmethod def get_mask_data ( mask ) : [EOL] [docstring] [EOL] [comment] [EOL] if mask == [number] : [EOL] return - [number] , [number] [EOL] mask_length = [number] [EOL] bit_value = [number] [EOL] bit_nr = [number] [EOL] while not mask & bit_value : [EOL] bit_value <<= [number] [EOL] bit_nr += [number] [EOL] lowest_mask_bit = bit_nr [EOL] while mask & bit_value : [EOL] mask_length += [number] [EOL] bit_value <<= [number] [EOL] return lowest_mask_bit , mask_length [EOL] [EOL] def _parse_bin_ctrl_gate ( self , stream , instruction ) : [EOL] [docstring] [EOL] conditional_reg_idx = instruction . conditional [EOL] conditional = next ( ( x for x in self . bfunc_instructions if x . register == conditional_reg_idx ) , None ) [EOL] if conditional is None : [EOL] raise ApiError ( f' [string] { conditional_reg_idx }' ) [EOL] self . bfunc_instructions . remove ( conditional ) [EOL] [EOL] conditional_type = conditional . relation [EOL] if conditional_type != [string] : [EOL] raise ApiError ( f' [string] { conditional_type } [string] ' ) [EOL] mask = int ( conditional . mask , [number] ) [EOL] if mask == [number] : [EOL] raise ApiError ( f' [string] { instruction . name . lower ( ) } [string] ' ) [EOL] lowest_mask_bit , mask_length = self . get_mask_data ( mask ) [EOL] val = int ( conditional . val , [number] ) [EOL] masked_val = mask & val [EOL] [EOL] [comment] [EOL] negate_zeroes_line = [string] [EOL] if masked_val != mask : [EOL] negate_zeroes_line = [string] + [string] . join ( str ( i ) for i in range ( lowest_mask_bit , lowest_mask_bit + mask_length ) if not ( masked_val & ( [number] << i ) ) ) + [string] [EOL] [EOL] if mask_length == [number] : [EOL] binary_control = f' [string] { lowest_mask_bit } [string] ' [EOL] else : [EOL] [comment] [EOL] binary_control = f' [string] { lowest_mask_bit } [string] { lowest_mask_bit + mask_length - [number] } [string] ' [EOL] [EOL] with StringIO ( ) as gate_stream : [EOL] [comment] [EOL] gate_name = f' [string] { instruction . name . lower ( ) }' [EOL] gate_function = getattr ( self , gate_name , getattr ( self , [string] ) ) [EOL] gate_function ( gate_stream , instruction , binary_control ) [EOL] line = gate_stream . getvalue ( ) [EOL] if len ( line ) != [number] : [EOL] [comment] [EOL] stream . write ( negate_zeroes_line ) [EOL] stream . write ( line ) [EOL] [comment] [EOL] stream . write ( negate_zeroes_line ) [EOL] [EOL] def parse ( self , stream , instruction ) : [EOL] [docstring] [EOL] if instruction . name == [string] : [EOL] self . bfunc_instructions . append ( instruction ) [EOL] elif hasattr ( instruction , [string] ) : [EOL] self . _parse_bin_ctrl_gate ( stream , instruction ) [EOL] else : [EOL] gate_name = f' [string] { instruction . name . lower ( ) }' [EOL] gate_function = getattr ( self , gate_name , getattr ( self , [string] ) ) [EOL] gate_function ( stream , instruction ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.List[qiskit.qobj.QasmQobjInstruction]$ 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.float$ 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[typing.Any]$ 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $None$ 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $io.StringIO$ 0 0 0 $builtins.str$ 0 0 $io.StringIO$ 0 0 0 $builtins.str$ 0 0 0 0 $io.StringIO$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $qiskit.qobj.QasmQobjInstruction$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $io.StringIO$ 0 $qiskit.qobj.QasmQobjInstruction$ 0 0
from typing import Optional , List , Dict , Any [EOL] import coreapi [EOL] import builtins [EOL] import qiskit [EOL] import typing [EOL] import quantuminspire [EOL] [docstring] [EOL] from copy import copy [EOL] from typing import List , Optional , Any , Dict [EOL] [EOL] import coreapi [EOL] from qiskit . providers import BaseProvider [EOL] from qiskit . providers . models import QasmBackendConfiguration [EOL] [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . credentials import get_token_authentication , get_basic_authentication [EOL] from quantuminspire . exceptions import ApiError [EOL] from quantuminspire . qiskit . backend_qx import QuantumInspireBackend [EOL] [EOL] QI_URL = [string] [EOL] [EOL] [EOL] class QuantumInspireProvider ( BaseProvider ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( ) . __init__ ( * args , ** kwargs ) [EOL] self . _backends = [ ] [EOL] self . _api = None [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] [EOL] [EOL] def backends ( self , name = None , ** kwargs ) : [EOL] [docstring] [EOL] if self . _api is None : [EOL] raise ApiError ( [string] ) [EOL] [EOL] available_backends = self . _api . get_backend_types ( ) [EOL] if name is not None : [EOL] available_backends = list ( filter ( lambda b : b [ [string] ] == name , available_backends ) ) [EOL] backends = [ ] [EOL] for backend in available_backends : [EOL] if backend [ [string] ] : [EOL] config = copy ( QuantumInspireBackend . DEFAULT_CONFIGURATION ) [EOL] self . _adjust_backend_configuration ( config , backend ) [EOL] backends . append ( QuantumInspireBackend ( self . _api , provider = self , configuration = config ) ) [EOL] [EOL] return backends [EOL] [EOL] @ staticmethod def _adjust_backend_configuration ( config , backend ) : [EOL] [docstring] [EOL] config . backend_name = backend [ [string] ] [EOL] config . n_qubits = backend [ [string] ] [EOL] if len ( backend [ [string] ] ) > [number] : [EOL] config . basis_gates = [ ] [EOL] for keys in backend [ [string] ] : [EOL] if keys in [ [string] , [string] , [string] , [string] , [string] ] : [EOL] for gate in backend [ [string] ] [ keys ] : [EOL] if gate in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] config . basis_gates += [ gate ] [EOL] elif gate == [string] : [EOL] config . basis_gates += [ [string] ] [EOL] elif gate == [string] : [EOL] config . basis_gates += [ [string] ] [EOL] elif gate == [string] : [EOL] config . basis_gates += [ [string] ] [EOL] elif gate == [string] : [EOL] config . basis_gates += [ [string] ] [EOL] elif gate == [string] : [EOL] config . basis_gates += [ [string] ] [EOL] if [string] in config . basis_gates and [string] in config . basis_gates : [EOL] config . basis_gates += [ [string] , [string] , [string] ] [EOL] [EOL] config . simulator = not backend [ [string] ] [EOL] config . conditional = not backend [ [string] ] [EOL] config . max_shots = backend [ [string] ] [EOL] max_experiments = backend [ [string] ] [EOL] config . max_experiments = max_experiments if max_experiments else [number] [EOL] coupling_map = [ ] [EOL] for i in range ( len ( backend [ [string] ] [ [string] ] ) ) : [EOL] for j in backend [ [string] ] [ [string] ] [ i ] : [EOL] coupling_map . append ( ( i , j ) ) [EOL] config . coupling_map = None if len ( coupling_map ) == [number] else coupling_map [EOL] [EOL] def set_authentication_details ( self , email , password , qi_url = QI_URL ) : [EOL] [docstring] [EOL] self . set_basic_authentication ( email , password , qi_url ) [EOL] [EOL] def set_basic_authentication ( self , email , password , qi_url = QI_URL ) : [EOL] [docstring] [EOL] authentication = get_basic_authentication ( email , password ) [EOL] self . set_authentication ( authentication , qi_url ) [EOL] [EOL] def set_token_authentication ( self , token , qi_url = QI_URL ) : [EOL] [docstring] [EOL] authentication = get_token_authentication ( token ) [EOL] self . set_authentication ( authentication , qi_url ) [EOL] [EOL] def set_authentication ( self , authentication = None , qi_url = QI_URL ) : [EOL] [docstring] [EOL] self . _api = QuantumInspireAPI ( qi_url , authentication ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.List[quantuminspire.qiskit.backend_qx.QuantumInspireBackend]$ 0 0 0 0 0 0 $typing.Optional[quantuminspire.api.QuantumInspireAPI]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[quantuminspire.qiskit.backend_qx.QuantumInspireBackend]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $qiskit.providers.models.QasmBackendConfiguration$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $typing.Optional[coreapi.auth.AuthBase]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[coreapi.auth.AuthBase]$ 0 0
from typing import List , Union , Dict , Any [EOL] import builtins [EOL] import qiskit [EOL] import typing [EOL] [docstring] [EOL] from typing import List , Union , Dict , Any [EOL] from qiskit . exceptions import QiskitError [EOL] from qiskit . result import postprocess , Result [EOL] from qiskit . result . models import ExperimentResult [EOL] [EOL] from quantuminspire . exceptions import QisKitBackendError [EOL] [EOL] [EOL] class QIResult ( Result ) : [comment] [EOL] [docstring] [EOL] def __init__ ( self , backend_name , backend_version , qobj_id , job_id , success , results , date = None , status = None , header = None , ** kwargs ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( backend_name , backend_version , qobj_id , job_id , success , results , date , status , header , ** kwargs ) [EOL] [EOL] def get_probabilities ( self , experiment = None ) : [EOL] [EOL] [docstring] [EOL] if experiment is None : [EOL] exp_keys = range ( len ( self . results ) ) [EOL] else : [EOL] exp_keys = [ experiment ] [comment] [EOL] [EOL] dict_list = [ ] [EOL] for key in exp_keys : [EOL] exp = self . _get_experiment ( key ) [EOL] try : [EOL] header = exp . header . to_dict ( ) [EOL] except ( AttributeError , QiskitError ) : [comment] [EOL] header = None [EOL] [EOL] probabilities = getattr ( self . _get_experiment ( key ) . data , [string] , None ) [EOL] if probabilities is not None : [EOL] dict_list . append ( postprocess . format_counts ( self . _get_experiment ( key ) . data . probabilities , header ) ) [EOL] else : [EOL] raise QisKitBackendError ( [string] . format ( key ) ) [EOL] [EOL] [comment] [EOL] if len ( dict_list ) == [number] : [EOL] return dict_list [ [number] ] [EOL] else : [EOL] return dict_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $typing.List[qiskit.result.models.ExperimentResult]$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 $typing.List[qiskit.result.models.ExperimentResult]$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 $typing.Union[typing.Dict[builtins.str,builtins.float],typing.List[typing.Dict[builtins.str,builtins.float]]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.float]]$ 0
	0
from typing import Union , Any , List , Tuple , Dict , Optional , Iterator [EOL] import builtins [EOL] import projectq [EOL] import typing [EOL] import quantuminspire [EOL] [docstring] [EOL] import sys [EOL] import inspect [EOL] import random [EOL] from collections import defaultdict [EOL] from functools import reduce [EOL] from typing import List , Dict , Iterator , Union , Optional , Tuple , Any [EOL] [EOL] from projectq . cengines import BasicEngine [EOL] from projectq . meta import LogicalQubitIDTag , get_control_count [EOL] from projectq . ops import ( NOT , Allocate , Barrier , Deallocate , FlushGate , H , Measure , Ph , Rx , Ry , Rz , S , Sdag , Swap , T , Tdag , X , Y , Z , Command , CZ , C , R , CNOT , Toffoli ) [EOL] from projectq . types import Qubit [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . exceptions import AuthenticationError [EOL] from quantuminspire . exceptions import ProjectQBackendError [EOL] [comment] [EOL] CR = C ( R ) [EOL] [EOL] [EOL] class QIBackend ( BasicEngine ) : [comment] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , num_runs = [number] , verbose = [number] , quantum_inspire_api = None , backend_type = None ) : [EOL] [docstring] [EOL] BasicEngine . __init__ ( self ) [EOL] self . _flushed = False [EOL] [docstring] [EOL] self . _clear = True [EOL] self . _reset ( ) [EOL] self . _verbose = verbose [EOL] self . _cqasm = str ( ) [EOL] self . _measured_states = { } [EOL] self . _measured_ids = [ ] [EOL] self . _allocation_map = [ ] [EOL] self . _max_qubit_id = - [number] [EOL] if quantum_inspire_api is None : [EOL] try : [EOL] quantum_inspire_api = QuantumInspireAPI ( ) [EOL] except AuthenticationError as ex : [EOL] raise AuthenticationError ( [string] [string] ) from ex [EOL] self . _quantum_inspire_api = quantum_inspire_api [EOL] self . _backend_type = self . _quantum_inspire_api . get_backend_type ( backend_type ) [EOL] if num_runs < [number] or num_runs > self . _backend_type [ [string] ] : [EOL] raise ProjectQBackendError ( f' [string] { num_runs } [string] ' ) [EOL] self . _num_runs = num_runs [EOL] self . _full_state_projection = not self . _backend_type [ [string] ] [EOL] self . _is_simulation_backend = not self . _backend_type [ [string] ] [EOL] self . _max_number_of_qubits = self . _backend_type [ [string] ] [EOL] self . _one_qubit_gates = self . _get_one_qubit_gates ( ) [EOL] self . _two_qubit_gates = self . _get_two_qubit_gates ( ) [EOL] self . _three_qubit_gates = self . _get_three_qubit_gates ( ) [EOL] [EOL] def _get_one_qubit_gates ( self ) : [EOL] allowed_operations = self . _backend_type [ [string] ] [EOL] if len ( allowed_operations ) > [number] : [EOL] one_qubit_gates = [ ] [EOL] for gate_set in [ [string] , [string] ] : [EOL] if gate_set in allowed_operations : [EOL] for gate in allowed_operations [ gate_set ] : [EOL] if gate in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : [EOL] one_qubit_gates += [ getattr ( sys . modules [ __name__ ] , gate . capitalize ( ) ) ] [EOL] else : [EOL] one_qubit_gates = [ X , Y , Z , H , S , Sdag , T , Tdag , Rx , Ry , Rz ] [EOL] return tuple ( one_qubit_gates ) [EOL] [EOL] def _get_two_qubit_gates ( self ) : [EOL] allowed_operations = self . _backend_type [ [string] ] [EOL] if len ( allowed_operations ) > [number] : [EOL] two_qubit_gates = [ ] [EOL] for gate_set in [ [string] , [string] ] : [EOL] if gate_set in allowed_operations : [EOL] for gate in allowed_operations [ gate_set ] : [EOL] if gate in [ [string] , [string] , [string] ] : [EOL] two_qubit_gates += [ getattr ( sys . modules [ __name__ ] , gate . upper ( ) ) ] [EOL] elif gate == [string] : [EOL] two_qubit_gates += [ Swap ] [EOL] else : [EOL] two_qubit_gates = [ CZ , CNOT , CR , Swap ] [EOL] return tuple ( two_qubit_gates ) [EOL] [EOL] def _get_three_qubit_gates ( self ) : [EOL] allowed_operations = self . _backend_type [ [string] ] [EOL] if len ( allowed_operations ) > [number] : [EOL] three_qubit_gates = [ ] [EOL] for gate_set in [ [string] ] : [EOL] if gate_set in allowed_operations : [EOL] for gate in allowed_operations [ gate_set ] : [EOL] if gate == [string] : [EOL] three_qubit_gates += [ Toffoli ] [EOL] else : [EOL] three_qubit_gates = [ Toffoli ] [EOL] return tuple ( three_qubit_gates ) [EOL] [EOL] @ property def one_qubit_gates ( self ) : [EOL] [docstring] [EOL] return self . _one_qubit_gates [EOL] [EOL] @ property def two_qubit_gates ( self ) : [EOL] [docstring] [EOL] return self . _two_qubit_gates [EOL] [EOL] @ property def three_qubit_gates ( self ) : [EOL] [docstring] [EOL] return self . _three_qubit_gates [EOL] [EOL] def cqasm ( self ) : [EOL] [docstring] [EOL] return self . _cqasm [EOL] [EOL] def is_available ( self , cmd ) : [EOL] [docstring] [EOL] count = get_control_count ( cmd ) [EOL] g = cmd . gate [EOL] if self . _verbose >= [number] : [EOL] print ( f' [string] { cmd } [string] { g } [string] ' ) [EOL] if g in ( Measure , Allocate , Deallocate , Barrier ) : [EOL] return True [EOL] if g == NOT and count == [number] : [EOL] return Toffoli in self . three_qubit_gates [EOL] if g == NOT and count == [number] : [EOL] return CNOT in self . two_qubit_gates [EOL] if g == Z and count == [number] : [EOL] return CZ in self . two_qubit_gates [EOL] if ( g == R or isinstance ( g , ( R , ) ) ) and count == [number] : [EOL] return CR in self . two_qubit_gates [EOL] if count != [number] : [EOL] return False [EOL] if g == Swap : [EOL] return g in self . two_qubit_gates [EOL] if g in ( T , Tdag , S , Sdag , H , X , Y , Z ) : [EOL] return g in self . one_qubit_gates [EOL] if isinstance ( g , ( Rx , Ry , Rz ) ) : [EOL] one_qubit_types = [ ] [EOL] for gate in self . one_qubit_gates : [EOL] if inspect . isclass ( gate ) : [EOL] one_qubit_types . append ( gate ) [EOL] return isinstance ( g , tuple ( one_qubit_types ) ) [EOL] if isinstance ( g , Ph ) : [EOL] return False [EOL] [EOL] return False [EOL] [EOL] def _reset ( self ) : [EOL] [docstring] [EOL] self . _clear = True [EOL] self . qasm = [string] [EOL] [EOL] def _allocate_qubit ( self , index_to_add ) : [EOL] [docstring] [EOL] if self . _is_simulation_backend : [EOL] [comment] [EOL] if next ( iter ( x for x in self . _allocation_map if x [ [number] ] == index_to_add ) , None ) is not None : [EOL] raise RuntimeError ( f" [string] { index_to_add } [string] " ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] allocation_entry = next ( iter ( x for x in self . _allocation_map if x [ [number] ] == index_to_add ) , None ) [EOL] [comment] [EOL] if allocation_entry is None and ( index_to_add < self . _max_number_of_qubits ) : [EOL] [comment] [EOL] self . _allocation_map . append ( ( index_to_add , index_to_add ) ) [EOL] else : [EOL] [comment] [EOL] if allocation_entry is None or allocation_entry [ [number] ] != - [number] : [EOL] [comment] [EOL] [comment] [EOL] allocation_entry = next ( iter ( x for x in self . _allocation_map if x [ [number] ] == - [number] ) , None ) [EOL] [EOL] if allocation_entry is None : [EOL] [comment] [EOL] self . _allocation_map . append ( ( max ( self . _allocation_map ) [ [number] ] + [number] , index_to_add ) ) [EOL] else : [EOL] [comment] [EOL] if self . _full_state_projection : [EOL] self . _switch_fsp_to_nonfsp ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . qasm += f" [string] { allocation_entry [ [number] ] } [string] " [EOL] self . qasm += f" [string] { allocation_entry [ [number] ] } [string] { allocation_entry [ [number] ] } [string] " [EOL] index = self . _allocation_map . index ( allocation_entry ) [EOL] self . _allocation_map [ index ] = ( allocation_entry [ [number] ] , index_to_add ) [EOL] [EOL] [comment] [EOL] self . _max_qubit_id = max ( self . _allocation_map ) [ [number] ] [EOL] else : [EOL] [comment] [EOL] self . _max_qubit_id = max ( self . _max_qubit_id , index_to_add ) [EOL] [EOL] if self . _verbose >= [number] : [EOL] print ( f' [string] { ( index_to_add , ) }' ) [EOL] print ( f' [string] { self . _allocation_map }' ) [EOL] [EOL] def _deallocate_qubit ( self , index_to_remove ) : [EOL] [docstring] [EOL] if self . _is_simulation_backend : [EOL] [comment] [EOL] allocation_entry = next ( iter ( x for x in self . _allocation_map if x [ [number] ] == index_to_remove ) , None ) [EOL] if allocation_entry is None : [EOL] raise RuntimeError ( f" [string] { index_to_remove } [string] " ) [EOL] else : [EOL] [comment] [EOL] index = self . _allocation_map . index ( allocation_entry ) [EOL] self . _allocation_map [ index ] = ( allocation_entry [ [number] ] , - [number] ) [EOL] [EOL] if self . _verbose >= [number] : [EOL] print ( f' [string] { ( index_to_remove , ) }' ) [EOL] print ( f' [string] { self . _allocation_map }' ) [EOL] [EOL] def _physical_to_simulated ( self , physical_qubit_id ) : [EOL] [docstring] [EOL] if self . _is_simulation_backend : [EOL] allocation_entry = next ( iter ( x for x in self . _allocation_map if x [ [number] ] == physical_qubit_id ) , None ) [EOL] if allocation_entry is None : [EOL] raise RuntimeError ( f" [string] " f" [string] { physical_qubit_id } [string] " ) [EOL] else : [EOL] return allocation_entry [ [number] ] [EOL] else : [EOL] return physical_qubit_id [EOL] [EOL] def _switch_fsp_to_nonfsp ( self ) : [EOL] [docstring] [EOL] for logical_qubit_id in self . _measured_ids : [EOL] physical_qubit_id = self . _logical_to_physical ( logical_qubit_id ) [EOL] sim_qubit_id = self . _physical_to_simulated ( physical_qubit_id ) [EOL] self . qasm += f" [string] { sim_qubit_id } [string] " [EOL] self . _full_state_projection = False [EOL] [EOL] def _store ( self , cmd ) : [EOL] [docstring] [EOL] if self . _verbose >= [number] : [EOL] print ( f' [string] { id ( self ) } [string] { cmd }' ) [EOL] [EOL] if self . _clear : [EOL] self . _clear = False [EOL] self . qasm = [string] [EOL] self . _measured_states = { } [EOL] self . _measured_ids = [ ] [EOL] self . _full_state_projection = not self . _backend_type [ [string] ] [EOL] [EOL] gate = cmd . gate [EOL] [EOL] if gate == Deallocate : [EOL] index_to_remove = cmd . qubits [ [number] ] [ [number] ] . id [EOL] self . _deallocate_qubit ( index_to_remove ) [EOL] return [EOL] [EOL] if self . _flushed : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] if gate == Allocate : [EOL] index_to_add = cmd . qubits [ [number] ] [ [number] ] . id [EOL] self . _allocate_qubit ( index_to_add ) [EOL] return [EOL] [EOL] if gate == Measure : [EOL] assert len ( cmd . qubits ) == [number] and len ( cmd . qubits [ [number] ] ) == [number] [EOL] sim_qubit_id = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] logical_id = None [EOL] for t in cmd . tags : [EOL] if isinstance ( t , LogicalQubitIDTag ) : [EOL] logical_id = t . logical_qubit_id [EOL] break [EOL] if self . main_engine . mapper is None : [EOL] logical_id = cmd . qubits [ [number] ] [ [number] ] . id [comment] [EOL] assert logical_id is not None [EOL] self . _measured_ids += [ logical_id ] [EOL] [comment] [EOL] if not self . _full_state_projection : [EOL] if self . _is_simulation_backend : [EOL] self . qasm += f" [string] { sim_qubit_id } [string] " [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . _full_state_projection and len ( self . _measured_ids ) != [number] : [EOL] self . _switch_fsp_to_nonfsp ( ) [EOL] [EOL] if gate == NOT and get_control_count ( cmd ) == [number] : [EOL] [comment] [EOL] ctrl_pos = self . _physical_to_simulated ( cmd . control_qubits [ [number] ] . id ) [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { ctrl_pos } [string] { qb_pos } [string] " [EOL] elif gate == Swap : [EOL] q0 = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] q1 = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { q0 } [string] { q1 } [string] " [EOL] elif gate == X and get_control_count ( cmd ) == [number] : [EOL] ctrl_pos1 = self . _physical_to_simulated ( cmd . control_qubits [ [number] ] . id ) [EOL] ctrl_pos2 = self . _physical_to_simulated ( cmd . control_qubits [ [number] ] . id ) [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { ctrl_pos1 } [string] { ctrl_pos2 } [string] { qb_pos } [string] " [EOL] elif gate == Z and get_control_count ( cmd ) == [number] : [EOL] ctrl_pos = self . _physical_to_simulated ( cmd . control_qubits [ [number] ] . id ) [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { ctrl_pos } [string] { qb_pos } [string] " [EOL] elif gate == Barrier : [EOL] qb_pos_list = [ qb . id for qr in cmd . qubits for qb in qr ] [EOL] qb_str = [string] . join ( [ f' [string] { self . _physical_to_simulated ( x ) } [string] ' for x in qb_pos_list ] ) [EOL] self . qasm += f" [string] { qb_str } [string] " [EOL] elif isinstance ( gate , ( Rz , R ) ) and get_control_count ( cmd ) == [number] : [EOL] ctrl_pos = self . _physical_to_simulated ( cmd . control_qubits [ [number] ] . id ) [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] gate_name = [string] [EOL] self . qasm += f" [string] { gate_name } [string] { ctrl_pos } [string] { qb_pos } [string] { gate . angle : [string] }" [EOL] elif isinstance ( gate , ( Rx , Ry ) ) and get_control_count ( cmd ) == [number] : [EOL] raise NotImplementedError ( [string] ) [EOL] elif isinstance ( gate , ( Rx , Ry , Rz ) ) : [EOL] assert get_control_count ( cmd ) == [number] [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] gate_name = str ( gate ) [ [number] : [number] ] . lower ( ) [EOL] self . qasm += f" [string] { gate_name } [string] { qb_pos } [string] { gate . angle : [string] }" [EOL] elif gate == Tdag and get_control_count ( cmd ) == [number] : [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { qb_pos } [string] " [EOL] elif gate == Sdag and get_control_count ( cmd ) == [number] : [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { qb_pos } [string] " [EOL] elif isinstance ( gate , tuple ( type ( gate ) for gate in ( X , Y , Z , H , S , T ) ) ) : [EOL] assert get_control_count ( cmd ) == [number] [EOL] gate_str = str ( gate ) . lower ( ) [EOL] qb_pos = self . _physical_to_simulated ( cmd . qubits [ [number] ] [ [number] ] . id ) [EOL] self . qasm += f" [string] { gate_str } [string] { qb_pos } [string] " [EOL] else : [EOL] raise NotImplementedError ( f' [string] { ( cmd , ) } [string] ' ) [EOL] [EOL] def _logical_to_physical ( self , logical_qubit_id ) : [EOL] [docstring] [EOL] if self . main_engine . mapper is not None : [EOL] mapping = self . main_engine . mapper . current_mapping [EOL] if logical_qubit_id not in mapping : [EOL] raise RuntimeError ( f" [string] { logical_qubit_id } [string] " f" [string] " f" [string] " ) [EOL] [EOL] return int ( mapping [ logical_qubit_id ] ) [EOL] else : [EOL] return logical_qubit_id [comment] [EOL] [EOL] def get_probabilities ( self , qureg ) : [EOL] [docstring] [EOL] if len ( self . _measured_states ) == [number] : [EOL] raise RuntimeError ( [string] ) [EOL] mask_bits = map ( lambda qubit : self . _physical_to_simulated ( self . _logical_to_physical ( qubit . id ) ) , qureg ) [EOL] [EOL] filtered_states = QIBackend . _filter_histogram ( self . _measured_states , mask_bits ) [EOL] [EOL] probability_dict = { self . _map_state_to_bit_string ( state , qureg ) : probability for state , probability in filtered_states . items ( ) } [EOL] [EOL] return probability_dict [EOL] [EOL] def _map_state_to_bit_string ( self , state , qureg ) : [EOL] [docstring] [EOL] mapped_state = [string] [EOL] [EOL] for qubit in qureg : [EOL] logical_id = qubit . id [EOL] physical_qubit_id = self . _logical_to_physical ( logical_id ) [EOL] sim_qubit_id = self . _physical_to_simulated ( physical_qubit_id ) [EOL] if int ( state ) & ( [number] << sim_qubit_id ) : [EOL] mapped_state += [string] [EOL] else : [EOL] mapped_state += [string] [EOL] [EOL] return mapped_state [EOL] [EOL] def _run ( self ) : [EOL] [docstring] [EOL] if self . qasm == [string] : [EOL] return [EOL] [EOL] [comment] [EOL] [comment] [EOL] if not self . _measured_ids and self . _is_simulation_backend : [EOL] self . __add_measure_all_qubits ( ) [EOL] [EOL] self . _finalize_qasm ( ) [EOL] self . _execute_cqasm ( ) [EOL] self . _filter_result_by_measured_qubits ( ) [EOL] self . _register_random_measurement_outcome ( ) [EOL] self . _reset ( ) [EOL] [EOL] def _finalize_qasm ( self ) : [EOL] [docstring] [EOL] qasm = f' [string] { self . __class__ } [string] ' f' [string] { self . _number_of_qubits } [string] ' [EOL] qasm += self . qasm [EOL] [EOL] if self . _verbose >= [number] : [EOL] print ( qasm ) [EOL] self . _cqasm = qasm [EOL] [EOL] def _execute_cqasm ( self ) : [EOL] [docstring] [EOL] self . _quantum_inspire_result = self . _quantum_inspire_api . execute_qasm ( self . _cqasm , number_of_shots = self . _num_runs , backend_type = self . _backend_type , full_state_projection = self . _full_state_projection ) [EOL] [EOL] if not self . _quantum_inspire_result . get ( [string] , { } ) : [EOL] raw_text = self . _quantum_inspire_result . get ( [string] , [string] ) [EOL] raise ProjectQBackendError ( f' [string] { raw_text }' ) [EOL] [EOL] def _filter_result_by_measured_qubits ( self ) : [EOL] [docstring] [EOL] mask_bits = map ( lambda bit : self . _physical_to_simulated ( self . _logical_to_physical ( bit ) ) , self . _measured_ids ) [EOL] histogram = { int ( k ) : v for k , v in self . _quantum_inspire_result [ [string] ] . items ( ) } [EOL] self . _measured_states = QIBackend . _filter_histogram ( histogram , mask_bits ) [EOL] [EOL] @ staticmethod def _filter_histogram ( histogram , mask_bits ) : [EOL] [docstring] [EOL] mask = reduce ( lambda x , y : x | ( [number] << y ) , mask_bits , [number] ) [EOL] [EOL] filtered_states = defaultdict ( lambda : [number] ) [EOL] for state , probability in histogram . items ( ) : [EOL] filtered_states [ state & mask ] += probability [EOL] [EOL] return dict ( filtered_states ) [EOL] [EOL] def _register_random_measurement_outcome ( self ) : [EOL] [docstring] [EOL] [EOL] class QB : [EOL] def __init__ ( self , qubit_id ) : [EOL] self . id = qubit_id [EOL] [EOL] random_measurement = self . _sample_measured_states_once ( ) [EOL] [EOL] for logical_qubit_id in self . _measured_ids : [EOL] physical_qubit_id = self . _logical_to_physical ( logical_qubit_id ) [EOL] sim_qubit_id = self . _physical_to_simulated ( physical_qubit_id ) [EOL] result = bool ( random_measurement & ( [number] << sim_qubit_id ) ) [EOL] [EOL] self . main_engine . set_measurement_result ( QB ( logical_qubit_id ) , result ) [EOL] [EOL] def _sample_measured_states_once ( self ) : [EOL] [docstring] [EOL] states = list ( self . _measured_states . keys ( ) ) [EOL] weights = list ( self . _measured_states . values ( ) ) [EOL] return random . choices ( states , weights = weights ) [ [number] ] [EOL] [EOL] @ property def _number_of_qubits ( self ) : [EOL] [docstring] [EOL] if self . _is_simulation_backend : [EOL] return self . _max_qubit_id + [number] [EOL] else : [EOL] return self . _max_number_of_qubits [EOL] [EOL] def receive ( self , command_list ) : [EOL] [docstring] [EOL] for cmd in command_list : [EOL] if not cmd . gate == FlushGate ( ) : [EOL] self . _store ( cmd ) [EOL] else : [EOL] self . _run ( ) [EOL] self . _flushed = True [EOL] self . _reset ( ) [EOL] [EOL] def __add_measure_all_qubits ( self ) : [EOL] [docstring] [EOL] qubits_reference = self . main_engine . active_qubits . copy ( ) [EOL] qubits_counts = len ( qubits_reference ) [EOL] for _ in range ( qubits_counts ) : [EOL] q = qubits_reference . pop ( ) [EOL] Measure | q [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $typing.List[projectq.types.Qubit]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[projectq.types.Qubit]$ 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 $typing.List[projectq.types.Qubit]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $typing.List[projectq.types.Qubit]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[projectq.types.Qubit]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 $typing.Dict[builtins.int,builtins.float]$ 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.int]$ 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.float]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.float]$ 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[projectq.ops.C.ommand]$ 0 0 0 0 0 0 0 0 $typing.List[projectq.ops.C.ommand]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0
import builtins [EOL] from typing import Optional , Literal , Union , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import math [EOL] from getpass import getpass [EOL] [EOL] from projectq import MainEngine [EOL] from projectq . backends import ResourceCounter , Simulator [EOL] from projectq . meta import Compute , Control , Loop , Uncompute [EOL] from projectq . ops import CNOT , CZ , All , H , Measure , X , Z [EOL] from projectq . setups import restrictedgateset [EOL] [EOL] from quantuminspire . credentials import load_account , get_token_authentication , get_basic_authentication [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . projectq . backend_qx import QIBackend [EOL] [EOL] QI_EMAIL = os . getenv ( [string] ) [EOL] QI_PASSWORD = os . getenv ( [string] ) [EOL] QI_URL = os . getenv ( [string] , [string] ) [EOL] [EOL] [EOL] def run_grover ( eng , n , oracle ) : [EOL] [docstring] [EOL] x = eng . allocate_qureg ( n ) [EOL] [EOL] [comment] [EOL] All ( H ) | x [EOL] [EOL] [comment] [EOL] num_it = int ( math . pi / [number] * math . sqrt ( [number] << n ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] oracle_out = eng . allocate_qubit ( ) [EOL] X | oracle_out [EOL] H | oracle_out [EOL] [EOL] [comment] [EOL] with Loop ( eng , num_it ) : [EOL] [comment] [EOL] oracle ( eng , x , oracle_out ) [EOL] [EOL] [comment] [EOL] with Compute ( eng ) : [EOL] All ( H ) | x [EOL] All ( X ) | x [EOL] [EOL] with Control ( eng , x [ [number] : - [number] ] ) : [EOL] Z | x [ - [number] ] [EOL] [EOL] Uncompute ( eng ) [EOL] [EOL] All ( Measure ) | x [EOL] Measure | oracle_out [EOL] [EOL] eng . flush ( ) [EOL] [comment] [EOL] return [ int ( qubit ) for qubit in x ] [EOL] [EOL] [EOL] def alternating_bits_oracle ( eng , qubits , output ) : [EOL] [docstring] [EOL] with Compute ( eng ) : [EOL] All ( X ) | qubits [ [number] : : [number] ] [EOL] with Control ( eng , qubits ) : [EOL] X | output [EOL] Uncompute ( eng ) [EOL] [EOL] [EOL] def get_authentication ( ) : [EOL] [docstring] [EOL] token = load_account ( ) [EOL] if token is not None : [EOL] return get_token_authentication ( token ) [EOL] else : [EOL] if QI_EMAIL is None or QI_PASSWORD is None : [EOL] print ( [string] ) [EOL] email = input ( ) [EOL] print ( [string] ) [EOL] password = getpass ( ) [EOL] else : [EOL] email , password = QI_EMAIL , QI_PASSWORD [EOL] return get_basic_authentication ( email , password ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] [comment] [EOL] authentication = get_authentication ( ) [EOL] qi = QuantumInspireAPI ( QI_URL , authentication ) [EOL] qi_backend = QIBackend ( quantum_inspire_api = qi ) [EOL] [EOL] compiler_engines = restrictedgateset . get_engine_list ( one_qubit_gates = qi_backend . one_qubit_gates , two_qubit_gates = qi_backend . two_qubit_gates , other_gates = qi_backend . three_qubit_gates ) [EOL] compiler_engines . extend ( [ ResourceCounter ( ) ] ) [EOL] qi_engine = MainEngine ( backend = qi_backend , engine_list = compiler_engines ) [EOL] [EOL] [comment] [EOL] result_qi = run_grover ( qi_engine , [number] , alternating_bits_oracle ) [EOL] print ( [string] . format ( result_qi ) ) [EOL] [EOL] [comment] [EOL] compiler_engines = restrictedgateset . get_engine_list ( one_qubit_gates = [string] , two_qubit_gates = ( CNOT , CZ ) ) [EOL] compiler_engines . append ( ResourceCounter ( ) ) [EOL] local_engine = MainEngine ( Simulator ( ) , compiler_engines ) [EOL] [EOL] [comment] [EOL] result_local = run_grover ( local_engine , [number] , alternating_bits_oracle ) [EOL] print ( [string] . format ( result_local ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
import builtins [EOL] from typing import Optional , Literal , Union , Any [EOL] import typing_extensions [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] from getpass import getpass [EOL] [EOL] from projectq import MainEngine [EOL] from projectq . backends import ResourceCounter [EOL] from projectq . ops import CNOT , H , Measure , All [EOL] from projectq . setups import restrictedgateset [EOL] [EOL] from quantuminspire . credentials import load_account , get_token_authentication , get_basic_authentication [EOL] from quantuminspire . api import QuantumInspireAPI [EOL] from quantuminspire . projectq . backend_qx import QIBackend [EOL] [EOL] QI_EMAIL = os . getenv ( [string] ) [EOL] QI_PASSWORD = os . getenv ( [string] ) [EOL] QI_URL = os . getenv ( [string] , [string] ) [EOL] [EOL] [EOL] def get_authentication ( ) : [EOL] [docstring] [EOL] token = load_account ( ) [EOL] if token is not None : [EOL] return get_token_authentication ( token ) [EOL] else : [EOL] if QI_EMAIL is None or QI_PASSWORD is None : [EOL] print ( [string] ) [EOL] email = input ( ) [EOL] print ( [string] ) [EOL] password = getpass ( ) [EOL] else : [EOL] email , password = QI_EMAIL , QI_PASSWORD [EOL] return get_basic_authentication ( email , password ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [EOL] name = [string] [EOL] authentication = get_authentication ( ) [EOL] qi_api = QuantumInspireAPI ( QI_URL , authentication , project_name = name ) [EOL] qi_backend = QIBackend ( quantum_inspire_api = qi_api ) [EOL] [EOL] compiler_engines = restrictedgateset . get_engine_list ( one_qubit_gates = qi_backend . one_qubit_gates , two_qubit_gates = qi_backend . two_qubit_gates ) [EOL] compiler_engines . extend ( [ ResourceCounter ( ) ] ) [EOL] engine = MainEngine ( backend = qi_backend , engine_list = compiler_engines ) [EOL] [EOL] qubits = engine . allocate_qureg ( [number] ) [EOL] q1 = qubits [ [number] ] [EOL] q2 = qubits [ [number] ] [EOL] [EOL] H | q1 [EOL] CNOT | ( q1 , q2 ) [EOL] All ( Measure ) | qubits [EOL] [EOL] engine . flush ( ) [EOL] [EOL] print ( [string] . format ( [ int ( q ) for q in qubits ] ) ) [EOL] print ( [string] . format ( qi_backend . get_probabilities ( qubits ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0
from typing import Tuple , Union , List , Any [EOL] import typing [EOL] from sklearn . datasets import load_iris [EOL] from sklearn import preprocessing [EOL] import matplotlib . pyplot as plt [EOL] import numpy as np [EOL] from random import sample [EOL] [EOL] plt . style . use ( [string] ) [EOL] [EOL] [EOL] def get_bin ( x , n ) : [EOL] return format ( int ( x ) , [string] ) . zfill ( n ) [EOL] [EOL] [EOL] class DataPlotter : [EOL] [EOL] @ staticmethod def plot_original_data ( data1 , data2 ) : [EOL] [comment] [EOL] plt . rcParams [ [string] ] = [ [number] , [number] ] [EOL] plt . scatter ( data1 [ [number] ] , data1 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . scatter ( data2 [ [number] ] , data2 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] plt . xlim ( - [number] , [number] ) [comment] [EOL] plt . ylim ( - [number] , [number] ) [comment] [EOL] plt . legend ( [ [string] , [string] ] ) [EOL] fig = plt [EOL] return fig [EOL] [EOL] @ staticmethod def plot_standardised_data ( data1 , data2 ) : [EOL] plt . rcParams [ [string] ] = [ [number] , [number] ] [comment] [EOL] unit_circle = plt . Circle ( ( [number] , [number] ) , [number] , color = [string] , alpha = [number] , fill = False ) [comment] [EOL] [EOL] plt . scatter ( data1 [ [number] ] , data1 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . scatter ( data2 [ [number] ] , data2 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] plt . xlim ( - [number] , [number] ) [comment] [EOL] plt . ylim ( - [number] , [number] ) [comment] [EOL] fig = plt . gcf ( ) [comment] [EOL] ax = fig . gca ( ) [EOL] ax . add_artist ( unit_circle ) [EOL] plt . legend ( [ [string] , [string] ] ) [EOL] plt . show ( ) [EOL] [EOL] @ staticmethod def plot_normalised_data ( data1 , data2 ) : [EOL] [comment] [EOL] plt . rcParams [ [string] ] = [ [number] , [number] ] [comment] [EOL] unit_circle = plt . Circle ( ( [number] , [number] ) , [number] , color = [string] , alpha = [number] , fill = False ) [comment] [EOL] [EOL] plt . scatter ( data1 [ [number] ] , data1 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . scatter ( data2 [ [number] ] , data2 [ [number] ] , alpha = [number] , s = [number] , c = [string] ) [comment] [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] plt . xlim ( - [number] , [number] ) [comment] [EOL] plt . ylim ( - [number] , [number] ) [comment] [EOL] [EOL] fig = plt . gcf ( ) [comment] [EOL] ax = fig . gca ( ) [EOL] ax . add_artist ( unit_circle ) [EOL] plt . legend ( [ [string] , [string] ] ) [EOL] [comment] [EOL] [EOL] @ staticmethod def load_data ( max_features = [number] ) : [EOL] iris = load_iris ( ) [EOL] features = iris . data . T [EOL] if max_features > [number] : [EOL] print ( [string] ) [EOL] [comment] [EOL] data = [ el [ [number] : [number] ] for el in features ] [ [number] : max_features ] [EOL] half_len_data = len ( data [ [number] ] ) // [number] [EOL] [comment] [EOL] features_scaled = [ preprocessing . scale ( el ) for el in data ] [EOL] iris_setosa_scaled = [ el [ [number] : half_len_data ] for el in features_scaled ] [EOL] iris_versicolor_scaled = [ el [ half_len_data : ] for el in features_scaled ] [EOL] [EOL] [comment] [EOL] def normalise_data ( * args ) : [EOL] [docstring] [EOL] for idx in range ( len ( args [ [number] ] ) ) : [EOL] norm = [number] [EOL] for arg in args : [EOL] norm += arg [ idx ] ** [number] [EOL] norm **= ( [number] / [number] ) [EOL] for arg in args : [EOL] arg [ idx ] /= norm [EOL] return args [EOL] [EOL] iris_setosa_normalised = normalise_data ( * iris_setosa_scaled ) [EOL] iris_versicolor_normalised = normalise_data ( * iris_versicolor_scaled ) [EOL] return iris_setosa_normalised , iris_versicolor_normalised [EOL] [EOL] def plot_data_points ( self , test_data , data_label0 , data_label1 , results ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] plt . rcParams [ [string] ] = [ [number] , [number] ] [comment] [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data ( ) [EOL] [EOL] [comment] [EOL] plt . subplot ( [number] , [number] , [number] ) [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] plt . scatter ( test_data [ [number] ] , test_data [ [number] ] , s = [number] , c = [string] ) [EOL] [EOL] for data_point in data_label0 : [EOL] [comment] [EOL] plt . scatter ( data_point [ [number] ] , data_point [ [number] ] , s = [number] , c = [string] ) [EOL] for data_point in data_label1 : [EOL] [comment] [EOL] plt . scatter ( data_point [ [number] ] , data_point [ [number] ] , s = [number] , c = [string] ) [EOL] plt . legend ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] plt . subplot ( [number] , [number] , [number] ) [comment] [EOL] size = len ( list ( results . keys ( ) ) [ [number] ] ) [EOL] res = [ get_bin ( el , size ) for el in range ( [number] ** size ) ] [EOL] prob = [ [number] ] * [number] ** size [EOL] for key , value in results . items ( ) : [EOL] prob [ int ( key , [number] ) ] = value [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] color_list = [ [string] , [string] , [string] , [string] , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] plt . bar ( res , prob , color = color_list ) [EOL] plt . ylabel ( [string] ) [EOL] plt . title ( [string] ) [EOL] plt . ylim ( [number] , [number] ) [EOL] plt . xticks ( rotation = [string] ) [EOL] return prob [EOL] [EOL] def grab_random_data ( self , size = [number] , features = [number] ) : [EOL] [docstring] [EOL] [EOL] if size % [number] != [number] : [EOL] return [string] [EOL] [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data ( max_features = features ) [EOL] [EOL] random_label = [number] [EOL] data_label0 = [ ] [comment] [EOL] data_label1 = [ ] [comment] [EOL] [comment] [EOL] coinciding_data = True [EOL] while coinciding_data : [EOL] coinciding_data = False [EOL] [comment] [EOL] random_label = sample ( [ [number] , [number] ] , [number] ) [ [number] ] [EOL] len_label0 = int ( size / [number] + [number] - random_label ) [EOL] len_label1 = int ( size / [number] + random_label ) [EOL] [EOL] index_label0 = sample ( range ( [number] ) , len_label0 ) [EOL] index_label1 = sample ( range ( [number] ) , len_label1 ) [EOL] [EOL] [comment] [EOL] data_label0 = [ ] [comment] [EOL] data_label1 = [ ] [comment] [EOL] [EOL] for data_point in index_label0 : [EOL] data_label0 . append ( [ feature [ data_point ] for feature in iris_setosa_normalised ] ) [EOL] for data_point in index_label1 : [EOL] data_label1 . append ( [ feature [ data_point ] for feature in iris_versicolor_normalised ] ) [EOL] [EOL] for i in range ( len ( data_label0 ) ) : [EOL] for j in range ( i + [number] , len ( data_label0 ) ) : [EOL] if data_label0 [ i ] == data_label0 [ j ] : [EOL] print ( [string] ) [EOL] coinciding_data = True [EOL] [EOL] for i in range ( len ( data_label1 ) ) : [EOL] for j in range ( i + [number] , len ( data_label1 ) ) : [EOL] if data_label1 [ i ] == data_label1 [ j ] : [EOL] print ( [string] ) [EOL] coinciding_data = True [EOL] [EOL] if random_label : [EOL] test_data = data_label1 . pop ( ) [EOL] else : [EOL] test_data = data_label0 . pop ( ) [EOL] [EOL] return data_label0 , data_label1 , test_data , random_label [EOL] [EOL] def plot_data_points_multiple_features ( self , data_label0 , data_label1 , test_data , random_label , results ) : [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data ( max_features = [number] ) [EOL] [EOL] [comment] [EOL] def find_idx ( needle , hay ) : [EOL] for idx in range ( len ( hay [ [number] ] ) ) : [EOL] if hay [ [number] ] [ idx ] == needle [ [number] ] and hay [ [number] ] [ idx ] == needle [ [number] ] and hay [ [number] ] [ idx ] == needle [ [number] ]\ [EOL] and hay [ [number] ] [ idx ] == needle [ [number] ] : [EOL] return idx [EOL] return [string] [EOL] [EOL] idx_data_label0 = find_idx ( data_label0 [ [number] ] , iris_setosa_normalised ) [EOL] idx_data_label1 = find_idx ( data_label1 [ [number] ] , iris_versicolor_normalised ) [EOL] if random_label == [number] : [EOL] hay_test_data = iris_setosa_normalised [EOL] else : [EOL] hay_test_data = iris_versicolor_normalised [EOL] idx_test_data = find_idx ( test_data , hay_test_data ) [EOL] [EOL] plt . rcParams [ [string] ] = [ [number] , [number] ] [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) ) [EOL] [comment] [EOL] iris_setosa_normalised , iris_versicolor_normalised = self . load_data_selected_features ( [number] , [number] ) [EOL] [comment] [EOL] self . plot_normalised_data ( iris_setosa_normalised , iris_versicolor_normalised ) [EOL] [comment] [EOL] if random_label == [number] : [EOL] test_data = iris_setosa_normalised [EOL] else : [EOL] test_data = iris_versicolor_normalised [EOL] plt . scatter ( test_data [ [number] ] [ idx_test_data ] , test_data [ [number] ] [ idx_test_data ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , iris_setosa_normalised [ [number] ] [ idx_data_label0 ] , s = [number] , c = [string] ) [EOL] plt . scatter ( iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , iris_versicolor_normalised [ [number] ] [ idx_data_label1 ] , s = [number] , c = [string] ) [EOL] plt . xlabel ( [string] ) [comment] [EOL] plt . ylabel ( [string] ) [comment] [EOL] [EOL] [comment] [EOL] plt . subplot2grid ( ( [number] , [number] ) , ( [number] , [number] ) , colspan = [number] , rowspan = [number] ) [EOL] size = len ( list ( results . keys ( ) ) [ [number] ] ) [EOL] res = [ get_bin ( el , size ) for el in range ( [number] ** size ) ] [EOL] prob = [ [number] ] * [number] ** size [EOL] for key , value in results . items ( ) : [EOL] prob [ int ( key , [number] ) ] = value [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] color_list = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) , ( [number] , [number] , [number] , [number] ) ] [EOL] plt . bar ( res , prob , color = color_list ) [EOL] plt . ylabel ( [string] ) [EOL] plt . title ( [string] ) [EOL] plt . ylim ( [number] , [number] ) [EOL] plt . xticks ( rotation = [string] ) [EOL] return plt . show ( ) [EOL] [EOL] @ staticmethod def load_data_selected_features ( feature1 , feature2 ) : [EOL] iris = load_iris ( ) [EOL] features = iris . data . T [EOL] data = [ el [ [number] : [number] ] for el in features ] [ [number] : [number] ] [EOL] data = [ data [ feature1 ] , data [ feature2 ] ] [EOL] half_len_data = len ( data [ [number] ] ) // [number] [EOL] [comment] [EOL] features_scaled = [ preprocessing . scale ( el ) for el in data ] [EOL] iris_setosa_scaled = [ el [ [number] : half_len_data ] for el in features_scaled ] [EOL] iris_versicolor_scaled = [ el [ half_len_data : ] for el in features_scaled ] [EOL] [EOL] [comment] [EOL] def normalise_data ( * args ) : [EOL] [docstring] [EOL] for idx in range ( len ( args [ [number] ] ) ) : [EOL] norm = [number] [EOL] for arg in args : [EOL] norm += arg [ idx ] ** [number] [EOL] norm **= ( [number] / [number] ) [EOL] for arg in args : [EOL] arg [ idx ] /= norm [EOL] return args [EOL] [EOL] iris_setosa_normalised = normalise_data ( * iris_setosa_scaled ) [EOL] iris_versicolor_normalised = normalise_data ( * iris_versicolor_scaled ) [EOL] return iris_setosa_normalised , iris_versicolor_normalised [EOL] [EOL] @ staticmethod def true_classifier ( data_label0 , data_label1 , test_data ) : [EOL] label0 = [number] [EOL] label1 = [number] [EOL] for element in data_label0 : [EOL] label0 += np . linalg . norm ( np . array ( element ) - np . array ( test_data ) ) [EOL] for element in data_label1 : [EOL] label1 += np . linalg . norm ( np . array ( element ) - np . array ( test_data ) ) [EOL] if label0 > label1 : [EOL] return [number] [EOL] return [number] [EOL] [EOL] def quality_classifier ( self , input_size , input_features , sample_size ) : [EOL] correct = [number] [EOL] wrong = [number] [EOL] for idx in range ( sample_size ) : [EOL] data_label0 , data_label1 , test_data , random_label = self . grab_random_data ( size = input_size , features = input_features ) [EOL] prediction = self . true_classifier ( data_label0 , data_label1 , test_data ) [EOL] if prediction == random_label : [EOL] correct += [number] [EOL] else : [EOL] wrong += [number] [EOL] return correct / sample_size , wrong / sample_size [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[builtins.str,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[builtins.str,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Union[builtins.str,typing.Tuple[builtins.float,builtins.float,builtins.float,builtins.float]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0