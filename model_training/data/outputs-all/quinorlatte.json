from typing import List [EOL] import typing [EOL] import builtins [EOL] import typing [EOL] import enum [EOL] import attr [EOL] from . import ast , colors [EOL] [EOL] [EOL] class Kind ( enum . Enum ) : [EOL] pass [EOL] [EOL] [EOL] class ParseKind ( Kind ) : [EOL] NoDefaultValue = enum . auto ( ) [EOL] MalformedParenExpr = enum . auto ( ) [EOL] AmbiguousIf = enum . auto ( ) [EOL] ParserError = enum . auto ( ) [EOL] [EOL] [EOL] class TypeAnalysisKind ( Kind ) : [EOL] VariableDoesNotExist = enum . auto ( ) [EOL] VariableRedeclaration = enum . auto ( ) [EOL] VariableShadow = enum . auto ( ) [EOL] MultipleFunctionDefinitions = enum . auto ( ) [EOL] NoMain = enum . auto ( ) [EOL] FunctionNotCallable = enum . auto ( ) [EOL] FunctionSameParameter = enum . auto ( ) [EOL] FunctionVoidParameter = enum . auto ( ) [EOL] FunctionDoesNotReturn = enum . auto ( ) [EOL] IncorrectArgumentCount = enum . auto ( ) [EOL] ArgumentTypeMismatch = enum . auto ( ) [EOL] AssignmentTypeMismatch = enum . auto ( ) [EOL] FunctionCallMismatch = enum . auto ( ) [EOL] ReturnTypeMismatch = enum . auto ( ) [EOL] ConditionTypeMismatch = enum . auto ( ) [EOL] DeadCode = enum . auto ( ) [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Error : [EOL] start = ... [EOL] end = ... [EOL] kind = ... [EOL] message = ... [EOL] [EOL] [EOL] _l = [ ] [EOL] [EOL] [EOL] def clear_errors ( ) : [EOL] _l . clear ( ) [EOL] [EOL] [EOL] def errors ( ) : [EOL] return _l [EOL] [EOL] [EOL] def add_error ( e ) : [EOL] _l . append ( e ) [EOL] [EOL] [EOL] def print_errors ( code ) : [EOL] lines = code . split ( [string] ) [EOL] for e in errors ( ) : [EOL] print ( f" [string] { e . start } [string] { e . end } [string] { colors . red ( e . kind . name ) } [string] " ) [EOL] print ( f" [string] { e . message }" ) [EOL] if e . start is None or e . end is None : [EOL] continue [EOL] [EOL] st = max ( e . start . line - [number] , [number] ) [EOL] en = min ( e . end . line + [number] , len ( lines ) ) [EOL] for i in range ( st , en ) : [EOL] line = lines [ i ] [EOL] print ( f"{ colors . white ( str ( i + [number] ) . rjust ( [number] ) ) } [string] { colors . cyan ( line ) }" ) [EOL] if i + [number] == e . start . line and i + [number] == e . end . line : [EOL] print ( [string] * [number] + colors . red ( [string] . join ( [string] if e . start . column <= j and e . end . column >= j else [string] for j in range ( len ( line ) ) ) ) ) [EOL] elif i + [number] == e . start . line : [EOL] print ( [string] * [number] + colors . red ( [string] * e . start . column + [string] * ( len ( line ) - e . start . column ) ) ) [EOL] elif i + [number] == e . end . line : [EOL] print ( [string] * [number] + colors . red ( [string] * e . end . column + [string] * ( len ( line ) - e . end . column ) ) ) [EOL] elif i + [number] > e . start . line and i + [number] < e . end . line : [EOL] print ( [string] * [number] + colors . red ( [string] * len ( line ) ) ) [EOL] print ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[ast.Position]$ 0 0 0 $typing.Optional[ast.Position]$ 0 0 0 $Kind$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Type [EOL] import lattec [EOL] import typing [EOL] import builtins [EOL] import ast [EOL] import typing [EOL] import attr [EOL] from . import ast [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class RegType : [EOL] pass [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class I1 ( RegType ) : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class I8 ( RegType ) : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class I32 ( RegType ) : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class String ( RegType ) : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Void ( RegType ) : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Ptr ( RegType ) : [EOL] type = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . type } [string] " [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Array ( RegType ) : [EOL] cnt = ... [EOL] type = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . cnt } [string] { self . type } [string] " [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class FunctionPtr ( RegType ) : [EOL] ret = ... [EOL] args = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ self . ret } [string] { [string] . join ( map ( str , self . args ) ) } [string] " [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Val : [EOL] type = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Var ( Val ) : [EOL] name = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name }" [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class GlobalVar ( Val ) : [EOL] name = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name }" [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class SConstant ( Val ) : [EOL] value = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] r = new_str_const ( self . value . replace ( [string] , [string] ) ) [EOL] return f"{ r }" [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Constant ( Val ) : [EOL] value = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f"{ int ( self . value ) }" [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Quad : [EOL] pass [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True , repr = False ) class Label ( Quad ) : [EOL] name = ... [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name }" [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Call ( Quad ) : [EOL] target = ... [comment] [EOL] function = ... [EOL] params = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class CondBranch ( Quad ) : [EOL] cond = ... [EOL] target_true = ... [EOL] target_false = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Branch ( Quad ) : [EOL] target = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Return ( Quad ) : [EOL] val = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Assign ( Quad ) : [EOL] target = ... [EOL] source = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Alloc ( Quad ) : [EOL] target = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Load ( Quad ) : [EOL] target = ... [EOL] source = ... [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Store ( Quad ) : [EOL] source = ... [EOL] target = ... [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] @ attr . s ( frozen = True , auto_attribs = True ) class Function : [EOL] ret = ... [EOL] name = ... [EOL] params = ... [EOL] body = ... [EOL] [EOL] [EOL] Program = typing . List [ Function ] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def from_ast_type ( t ) : [EOL] if isinstance ( t , ast . Int ) : [EOL] return I32 ( ) [EOL] elif isinstance ( t , ast . Bool ) : [EOL] return I1 ( ) [EOL] elif isinstance ( t , ast . String ) : [EOL] return String ( ) [EOL] elif isinstance ( t , ast . Void ) : [EOL] return Void ( ) [EOL] elif isinstance ( t , ast . Function ) : [EOL] return FunctionPtr ( from_ast_type ( t . ret ) , list ( map ( from_ast_type , t . params ) ) ) [EOL] else : [EOL] print ( t ) [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] def identity ( t ) : [EOL] return GlobalVar ( FunctionPtr ( t , [ t ] ) , name = [string] ) [EOL] [EOL] [EOL] var_cnt = [number] [EOL] label_cnt = [number] [EOL] string_cnt = [number] [EOL] is_returned = False [EOL] [EOL] [EOL] quad_list = [ ] [EOL] defer_stack = [ ] [EOL] string_const_list = [ ] [EOL] [EOL] [EOL] def gather ( ) : [EOL] ret = quad_list [ : ] [EOL] quad_list . clear ( ) [EOL] return ret [EOL] [EOL] [EOL] def new_var ( t ) : [EOL] global var_cnt [EOL] name = f" [string] { var_cnt }" [EOL] var_cnt += [number] [EOL] return Var ( t , name ) [EOL] [EOL] [EOL] def new_str_const ( value ) : [EOL] global string_cnt [EOL] name = f" [string] { string_cnt }" [EOL] string_cnt += [number] [EOL] [EOL] vl = len ( value ) + [number] [EOL] string_const_list . append ( f" [string] { name } [string] { vl } [string] { value } [string] " f" [string] { name } [string] { [string] } [string] { vl } [string] { vl } [string] { name } [string] { [string] } [string] " ) [EOL] return GlobalVar ( String ( ) , name ) [EOL] [EOL] [EOL] def get_string_consts ( ) : [EOL] ret = string_const_list [ : ] [EOL] string_const_list . clear ( ) [EOL] return ret [EOL] [EOL] [EOL] def new_label ( ) : [EOL] global label_cnt [EOL] name = f" [string] { label_cnt }" [EOL] label_cnt += [number] [EOL] return Label ( name ) [EOL] [EOL] [EOL] def add_quad ( q ) : [EOL] quad_list . append ( q ) [EOL] [EOL] [EOL] def add_defer ( q ) : [EOL] defer_stack [ - [number] ] . append ( q ) [EOL] [EOL] [EOL] def open_defer_scope ( ) : [EOL] defer_stack . append ( [ ] ) [EOL] [EOL] [EOL] def close_defer_scope ( ) : [EOL] return defer_stack . pop ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RegType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $RegType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RegType$ 0 0 0 $typing.List[RegType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RegType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $lattec.quads.GlobalVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lattec.quads.GlobalVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Var]$ 0 0 0 0 $Val$ 0 0 0 $typing.List[Val]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Val$ 0 0 0 $Label$ 0 0 0 $Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Val]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Var$ 0 0 0 $Val$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Var$ 0 0 0 $Val$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Val$ 0 0 0 $Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $RegType$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[Var]$ 0 0 0 $typing.List[Quad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GlobalVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Quad]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Var$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GlobalVar$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Label$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[Quad]$ 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] cfg = { [string] : [string] , [string] : [string] , [string] : False , [string] : False , [string] : False , } [EOL]	0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
def black ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def red ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def green ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def yellow ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def blue ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def purple ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def cyan ( p ) : [EOL] return f" [string] { p } [string] " [EOL] [EOL] [EOL] def white ( p ) : [EOL] return f" [string] { p } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Any , List , Dict , Optional [EOL] import lattec [EOL] import typing [EOL] import ast [EOL] import typing [EOL] import attr [EOL] from . import ast [EOL] [EOL] [EOL] def traverse ( root , pre_order = [ ] , post_order = [ ] , ) : [EOL] def traverse_impl ( tree ) : [EOL] ret = None [comment] [EOL] for pre_f in pre_order : [EOL] ret = pre_f ( tree ) [EOL] if ret is not None : [EOL] tree = ret [EOL] [EOL] d = attr . asdict ( tree , recurse = False ) [EOL] for k , v in d . items ( ) : [EOL] if isinstance ( v , list ) : [EOL] for i , e in enumerate ( v ) : [EOL] if isinstance ( e , ast . Node ) : [EOL] ret = traverse_impl ( e ) [EOL] if ret is not None : [EOL] v [ i ] = ret [EOL] elif isinstance ( v , ast . Node ) : [EOL] ret = traverse_impl ( v ) [EOL] if ret is not None : [EOL] d [ k ] = ret [EOL] [EOL] tree = attr . evolve ( tree , ** d ) [EOL] [EOL] for post_f in post_order : [EOL] ret = post_f ( tree ) [EOL] if ret is not None : [EOL] tree = ret [EOL] return tree [EOL] [EOL] return traverse_impl ( root ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import quads [EOL] import typing [EOL] import collections [EOL] from . . import quads as Q [EOL] from . import resources [EOL] [EOL] [EOL] arithm_suf_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] cmp_suf_map = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def generate_function ( f ) : [EOL] var_occ = collections . defaultdict ( int ) [EOL] [EOL] for q in f . body : [EOL] if isinstance ( q , Q . Call ) and q . target is not None : [EOL] var_occ [ q . target . name ] += [number] [EOL] [EOL] ret = [ ] [EOL] ret . append ( f" [string] { f . ret } [string] { f . name } [string] { [string] . join ( f'{ p . type } [string] { p }' for p in f . params ) } [string] " [string] ) [EOL] for q in f . body : [EOL] if isinstance ( q , Q . Label ) : [EOL] ret . append ( f"{ q . name } [string] " ) [EOL] [EOL] if isinstance ( q , Q . Call ) : [EOL] assert isinstance ( q . function , ( Q . Var , Q . GlobalVar ) ) [EOL] assert isinstance ( q . function . type , Q . FunctionPtr ) [EOL] fname = q . function . name [EOL] bltn = fname . startswith ( [string] ) [EOL] suffix = fname [ len ( [string] ) : ] [EOL] rtype = q . function . type . ret [EOL] tgt = ( [string] [EOL] if q . target is None or isinstance ( q . function . type . ret , Q . Void )else [EOL] f"{ q . target } [string] " ) [EOL] [EOL] if bltn and suffix == [string] : [EOL] ret . append ( f" [string] { tgt } [string] { rtype } [string] { q . params [ [number] ] }" ) [EOL] [EOL] elif bltn and suffix == [string] : [EOL] ret . append ( f" [string] { tgt } [string] { rtype } [string] { q . params [ [number] ] }" ) [EOL] [EOL] elif bltn and suffix in arithm_suf_map : [EOL] op = arithm_suf_map [ suffix ] [EOL] ret . append ( f" [string] { tgt }{ op } [string] { rtype } [string] { q . params [ [number] ] } [string] { q . params [ [number] ] }" ) [EOL] [EOL] elif bltn and suffix in cmp_suf_map : [EOL] op = cmp_suf_map [ suffix ] [EOL] ret . append ( f" [string] { tgt } [string] { op } [string] { q . params [ [number] ] . type } [string] { q . params [ [number] ] } [string] { q . params [ [number] ] }" ) [EOL] [EOL] else : [EOL] assert isinstance ( q . function . type , Q . FunctionPtr ) [EOL] ret . append ( f" [string] { tgt } [string] { q . function . type . ret } [string] { q . function }" f" [string] { [string] . join ( f'{ e . type } [string] { e }' for e in q . params ) } [string] " ) [EOL] [EOL] if isinstance ( q , Q . CondBranch ) : [EOL] ret . append ( f" [string] { q . cond } [string] { q . target_true } [string] { q . target_false }" ) [EOL] [EOL] if isinstance ( q , Q . Branch ) : [EOL] ret . append ( f" [string] { q . target }" ) [EOL] [EOL] if isinstance ( q , Q . Return ) : [EOL] if q . val : [EOL] ret . append ( f" [string] { q . val . type } [string] { q . val }" ) [EOL] else : [EOL] ret . append ( f" [string] " ) [EOL] [EOL] if isinstance ( q , Q . Assign ) : [EOL] raise Exception ( [string] ) [EOL] [EOL] if isinstance ( q , Q . Alloc ) : [EOL] assert isinstance ( q . target . type , Q . Ptr ) [EOL] ret . append ( f" [string] { q . target } [string] { q . target . type . type }" ) [EOL] [EOL] if isinstance ( q , Q . Load ) : [EOL] ret . append ( f" [string] { q . target } [string] { q . target . type } [string] { q . source . type } [string] { q . source }" ) [EOL] [EOL] if isinstance ( q , Q . Store ) : [EOL] ret . append ( f" [string] { q . source . type } [string] { q . source } [string] { q . target . type } [string] { q . target }" ) [EOL] [EOL] ret . append ( [string] ) [EOL] ret . append ( [string] ) [EOL] return ret [EOL] [EOL] [EOL] def generate_llvm ( funcs ) : [EOL] code = resources . LLVM_RUNTIME [EOL] code += [string] . join ( l for f in funcs for l in generate_function ( f ) ) [EOL] code += [string] + [string] . join ( Q . get_string_consts ( ) ) [EOL] return code [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . backend import generate_llvm [comment] [EOL]	0 0 0 0 0 0 0
LLVM_RUNTIME = [string] [EOL]	$builtins.str$ 0 0 0