import unittest [EOL] [EOL] from clock import Clock [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ClockTest ( unittest . TestCase ) : [EOL] [comment] [EOL] def test_on_the_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_past_the_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_midnight_is_zero_hours ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_hour_rolls_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_hour_rolls_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_sixty_minutes_is_next_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_minutes_roll_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_minutes_roll_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_hour_and_minutes_roll_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_hour_and_minutes_roll_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_hour_and_minutes_roll_over_to_exactly_midnight ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_negative_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( - [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_negative_hour_rolls_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( - [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_negative_hour_rolls_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( - [number] , [number] ) ) , [string] ) [EOL] [EOL] def test_negative_minutes ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , - [number] ) ) , [string] ) [EOL] [EOL] def test_negative_minutes_roll_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , - [number] ) ) , [string] ) [EOL] [EOL] def test_negative_minutes_roll_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , - [number] ) ) , [string] ) [EOL] [EOL] def test_negative_sixty_minutes_is_previous_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , - [number] ) ) , [string] ) [EOL] [EOL] def test_negative_hour_and_minutes_both_roll_over ( self ) : [EOL] self . assertEqual ( str ( Clock ( - [number] , - [number] ) ) , [string] ) [EOL] [EOL] def test_negative_hour_and_minutes_both_roll_over_continuously ( self ) : [EOL] self . assertEqual ( str ( Clock ( - [number] , - [number] ) ) , [string] ) [EOL] [EOL] [comment] [EOL] def test_add_minutes ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_no_minutes ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_to_next_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_more_than_one_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_more_than_two_hours_with_carry ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_across_midnight ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_more_than_one_day ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_add_more_than_two_days ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) + [number] ) , [string] ) [EOL] [EOL] def test_subtract_minutes ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_to_previous_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_more_than_an_hour ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_across_midnight ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_more_than_two_hours ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_more_than_two_hours_with_borrow ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_more_than_one_day ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] def test_subtract_more_than_two_days ( self ) : [EOL] self . assertEqual ( str ( Clock ( [number] , [number] ) - [number] ) , [string] ) [EOL] [EOL] [comment] [EOL] def test_clocks_with_same_time ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_a_minute_apart ( self ) : [EOL] self . assertNotEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_an_hour_apart ( self ) : [EOL] self . assertNotEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_hour_overflow ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_hour_overflow_by_several_days ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_negative_hour ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( - [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_negative_hour_that_wraps ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( - [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_negative_hour_that_wraps_multiple_times ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( - [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_minute_overflow ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_minute_overflow_by_several_days ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] def test_clocks_with_negative_minute ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , - [number] ) ) [EOL] [EOL] def test_clocks_with_negative_minute_that_wraps ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , - [number] ) ) [EOL] [EOL] def test_clocks_with_negative_minute_that_wraps_multiple_times ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , - [number] ) ) [EOL] [EOL] def test_clocks_with_negative_hours_and_minutes ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( - [number] , - [number] ) ) [EOL] [EOL] def test_clocks_with_negative_hours_and_minutes_that_wrap ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( - [number] , - [number] ) ) [EOL] [EOL] def test_full_clock_and_zeroed_clock ( self ) : [EOL] self . assertEqual ( Clock ( [number] , [number] ) , Clock ( [number] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] HOUR_PER_DAY = [number] [EOL] MINUTE_PER_HOUR = [number] [EOL] [EOL] [EOL] class Clock ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hour , minute ) : [EOL] [docstring] [EOL] self . hour = ( hour + minute // MINUTE_PER_HOUR ) % HOUR_PER_DAY [EOL] self . minute = minute % MINUTE_PER_HOUR [EOL] [EOL] def __repr__ ( self ) : [EOL] [docstring] [EOL] return f"{ self . hour : [string] } [string] { self . minute : [string] }" [EOL] [EOL] def __eq__ ( self , other ) : [EOL] [docstring] [EOL] return ( self . hour , self . minute ) == ( other . hour , other . minute ) [EOL] [EOL] def __add__ ( self , minutes ) : [EOL] [docstring] [EOL] return Clock ( self . hour , self . minute + minutes ) [EOL] [EOL] def __sub__ ( self , minutes ) : [EOL] [docstring] [EOL] return Clock ( self . hour , self . minute - minutes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Clock"$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $"Clock"$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] import diffie_hellman [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DiffieHellmanTest ( unittest . TestCase ) : [EOL] def test_private_key_is_in_range ( self ) : [EOL] primes = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] for i in primes : [EOL] self . assertTrue ( [number] < diffie_hellman . private_key ( i ) < i ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_private_key_is_random ( self ) : [EOL] p = [number] [EOL] private_keys = [ ] [EOL] for i in range ( [number] ) : [EOL] private_keys . append ( diffie_hellman . private_key ( p ) ) [EOL] self . assertEqual ( len ( set ( private_keys ) ) , len ( private_keys ) ) [EOL] [EOL] def test_can_calculate_public_key_using_private_key ( self ) : [EOL] p = [number] [EOL] g = [number] [EOL] private = [number] [EOL] expected = [number] [EOL] [EOL] actual = diffie_hellman . public_key ( p , g , private ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_can_calculate_secret_using_other_party_s_public_key ( self ) : [EOL] p = [number] [EOL] public = [number] [EOL] private = [number] [EOL] expected = [number] [EOL] [EOL] actual = diffie_hellman . secret ( p , public , private ) [EOL] self . assertEqual ( actual , expected ) [EOL] [EOL] def test_key_exchange ( self ) : [EOL] p = [number] [EOL] g = [number] [EOL] alice_private_key = diffie_hellman . private_key ( p ) [EOL] bob_private_key = diffie_hellman . private_key ( p ) [EOL] alice_public_key = diffie_hellman . public_key ( p , g , alice_private_key ) [EOL] bob_public_key = diffie_hellman . public_key ( p , g , bob_private_key ) [EOL] secret_a = diffie_hellman . secret ( p , bob_public_key , alice_private_key ) [EOL] secret_b = diffie_hellman . secret ( p , alice_public_key , bob_private_key ) [EOL] [EOL] self . assertEqual ( secret_a , secret_b ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import secrets [EOL] [EOL] [EOL] def private_key ( p ) : [EOL] return secrets . randbelow ( p - [number] ) + [number] [EOL] [EOL] [EOL] def public_key ( p , g , private ) : [EOL] return ( g ** private ) % p [EOL] [EOL] [EOL] def secret ( p , public , private ) : [EOL] return ( public ** private ) % p [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from transpose import transpose [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TransposeTest ( unittest . TestCase ) : [EOL] def test_empty_string ( self ) : [EOL] lines = [ ] [EOL] expected = [ ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_two_characters_in_a_row ( self ) : [EOL] lines = [ [string] ] [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_two_characters_in_a_column ( self ) : [EOL] lines = [ [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_simple ( self ) : [EOL] lines = [ [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_single_line ( self ) : [EOL] lines = [ [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_first_line_longer_than_second_line ( self ) : [EOL] lines = [ [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_second_line_longer_than_first_line ( self ) : [EOL] lines = [ [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_mixed_line_length ( self ) : [EOL] lines = [ [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_square ( self ) : [EOL] lines = [ [string] , [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_rectangle ( self ) : [EOL] lines = [ [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] def test_triangle ( self ) : [EOL] lines = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( transpose ( [string] . join ( lines ) ) , [string] . join ( expected ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import itertools [EOL] [EOL] [EOL] def transpose ( lines ) : [EOL] [docstring] [EOL] transpose_matrix = itertools . zip_longest ( * lines . splitlines ( ) , fillvalue = [string] ) [EOL] return [string] . join ( [ [string] . join ( line ) . rstrip ( [string] ) . replace ( [string] , [string] ) for line in transpose_matrix ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] VOWELS = [string] [EOL] [EOL] [EOL] def translate ( text ) : [EOL] [docstring] [EOL] return [string] . join ( translate_one_word ( word ) for word in text . split ( ) ) [EOL] [EOL] [EOL] def translate_one_word ( word ) : [EOL] [docstring] [EOL] if word [ : [number] ] in ( [string] , [string] ) : [EOL] return word + [string] [EOL] prefix_index = next ( ( index for index , char in enumerate ( word ) if char in VOWELS ) , - [number] ) [EOL] if word [ prefix_index - [number] : prefix_index + [number] ] == [string] : [EOL] prefix_index = prefix_index + [number] [EOL] if prefix_index == - [number] : [EOL] prefix_index = next ( index for index , char in enumerate ( word ) if char == [string] ) [EOL] return word [ prefix_index : ] + word [ : prefix_index ] + [string] [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from pig_latin import translate [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PigLatinTest ( unittest . TestCase ) : [EOL] def test_word_beginning_with_a ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_e ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_i ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_o ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_u ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_a_vowel_and_followed_by_a_qu ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_p ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_k ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_x ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_q_without_a_following_u ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_ch ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_qu ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_qu_and_a_preceding_consonant ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_th ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_thr ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_sch ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_yt ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_word_beginning_with_xr ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_y_is_treated_like_a_consonant_at_the_beginning_of_a_word ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_y_is_treated_like_a_vowel_at_the_end_of_a_consonant_cluster ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_y_as_second_letter_in_two_letter_word ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] def test_a_whole_phrase ( self ) : [EOL] self . assertEqual ( translate ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Dict [EOL] import typing [EOL] import io [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] from grep import grep [EOL] [EOL] FILE_TEXT = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] def open_mock ( fname , * args , ** kwargs ) : [EOL] try : [EOL] return io . StringIO ( FILE_TEXT [ fname ] ) [EOL] except KeyError : [EOL] raise RuntimeError ( [string] . format ( list ( FILE_TEXT . keys ( ) ) , fname ) ) [EOL] [EOL] [EOL] @ mock . patch ( [string] , name = [string] , side_effect = open_mock , create = True ) @ mock . patch ( [string] , name = [string] , wraps = io . StringIO ) class GrepTest ( unittest . TestCase ) : [EOL] [comment] [EOL] def test_one_file_one_match_no_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] ) [EOL] [EOL] def test_one_file_one_match_print_line_numbers_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] , ) [EOL] [EOL] def test_one_file_one_match_case_insensitive_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] , ) [EOL] [EOL] def test_one_file_one_match_print_file_names_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] ) [EOL] [EOL] def test_one_file_one_match_match_entire_lines_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] , ) [EOL] [EOL] def test_one_file_one_match_multiple_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] , ) [EOL] [EOL] def test_one_file_several_matches_no_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] [string] [string] , ) [EOL] [EOL] def test_one_file_several_matches_print_line_numbers_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] [string] [string] , ) [EOL] [EOL] def test_one_file_several_matches_match_entire_lines_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] ) [EOL] [EOL] def test_one_file_several_matches_case_insensitive_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] [string] , ) [EOL] [EOL] def test_one_file_several_matches_inverted_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] [string] [string] [string] [string] , ) [EOL] [EOL] def test_one_file_no_matches_various_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] ) [EOL] [EOL] def test_one_file_one_match_file_flag_takes_precedence_over_line_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] ) [EOL] [EOL] def test_one_file_several_matches_inverted_and_match_entire_lines_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] ] ) , [string] [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] [comment] [EOL] def test_multiple_files_one_match_no_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_no_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] ) , [string] [string] [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_print_line_numbers_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] ) , [string] [string] [string] [string] , ) [EOL] [EOL] def test_multiple_files_one_match_print_file_names_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] ) , [string] [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_case_insensitive_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] ) , [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_inverted_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] ) , [string] [string] [string] , ) [EOL] [EOL] def test_multiple_files_one_match_match_entire_lines_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] , ) [EOL] [EOL] def test_multiple_files_one_match_multiple_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] , ) [EOL] [EOL] def test_multiple_files_no_matches_various_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_file_flag_takes_precedence_over_line_number_flag ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] [string] , ) [EOL] [EOL] def test_multiple_files_several_matches_inverted_and_match_entire_lines_flags ( self , mock_file , mock_open ) : [EOL] self . assertMultiLineEqual ( grep ( [string] , [string] , [ [string] , [string] , [string] ] , ) , [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Callable , List [EOL] import typing [EOL] import builtins [EOL] from typing import Callable , List [EOL] [EOL] [EOL] def YACHT ( dice ) : [EOL] return [number] if len ( set ( dice ) ) == [number] else [number] [EOL] [EOL] [EOL] def ONES ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def TWOS ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def THREES ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def FOURS ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def FIVES ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def SIXES ( dice ) : [EOL] return dice . count ( [number] ) * [number] [EOL] [EOL] [EOL] def FULL_HOUSE ( dice ) : [EOL] return ( sum ( dice ) [EOL] if all ( [ len ( set ( dice ) ) == [number] , any ( [ dice . count ( x ) == [number] for x in dice ] ) , any ( [ dice . count ( x ) == [number] for x in dice ] ) , ] ) [EOL] else [number] ) [EOL] [EOL] [EOL] def FOUR_OF_A_KIND ( dice ) : [EOL] return sum ( [ x * [number] for x in set ( dice ) if dice . count ( x ) >= [number] ] ) [EOL] [EOL] [EOL] def LITTLE_STRAIGHT ( dice ) : [EOL] return [number] if set ( [ [number] , [number] , [number] , [number] , [number] ] ) == set ( sorted ( dice ) ) else [number] [EOL] [EOL] [EOL] def BIG_STRAIGHT ( dice ) : [EOL] return [number] if set ( [ [number] , [number] , [number] , [number] , [number] ] ) == set ( sorted ( dice ) ) else [number] [EOL] [EOL] [EOL] def CHOICE ( dice ) : [EOL] return sum ( dice ) [EOL] [EOL] [EOL] def score ( dice , category ) : [EOL] return category ( dice ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] import yacht [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class YachtTest ( unittest . TestCase ) : [EOL] def test_yacht ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . YACHT ) , [number] ) [EOL] [EOL] def test_not_yacht ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . YACHT ) , [number] ) [EOL] [EOL] def test_ones ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . ONES ) , [number] ) [EOL] [EOL] def test_ones_out_of_order ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . ONES ) , [number] ) [EOL] [EOL] def test_no_ones ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . ONES ) , [number] ) [EOL] [EOL] def test_twos ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . TWOS ) , [number] ) [EOL] [EOL] def test_fours ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FOURS ) , [number] ) [EOL] [EOL] def test_yacht_counted_as_threes ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . THREES ) , [number] ) [EOL] [EOL] def test_yacht_of_3s_counted_as_fives ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FIVES ) , [number] ) [EOL] [EOL] def test_sixes ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . SIXES ) , [number] ) [EOL] [EOL] def test_full_house_two_small_three_big ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FULL_HOUSE ) , [number] ) [EOL] [EOL] def test_full_house_three_small_two_big ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FULL_HOUSE ) , [number] ) [EOL] [EOL] def test_two_pair_is_not_a_full_house ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FULL_HOUSE ) , [number] ) [EOL] [EOL] def test_four_of_a_kind_is_not_a_full_house ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FULL_HOUSE ) , [number] ) [EOL] [EOL] def test_yacht_is_not_a_full_house ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FULL_HOUSE ) , [number] ) [EOL] [EOL] def test_four_of_a_kind ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FOUR_OF_A_KIND ) , [number] ) [EOL] [EOL] def test_yacht_can_be_scored_as_four_of_a_kind ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FOUR_OF_A_KIND ) , [number] ) [EOL] [EOL] def test_full_house_is_not_four_of_a_kind ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . FOUR_OF_A_KIND ) , [number] ) [EOL] [EOL] def test_little_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . LITTLE_STRAIGHT ) , [number] ) [EOL] [EOL] def test_little_straight_as_big_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . BIG_STRAIGHT ) , [number] ) [EOL] [EOL] def test_four_in_order_but_not_a_little_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . LITTLE_STRAIGHT ) , [number] ) [EOL] [EOL] def test_no_pairs_but_not_a_little_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . LITTLE_STRAIGHT ) , [number] ) [EOL] [EOL] def test_minimum_is_1_maximum_is_5_but_not_a_little_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . LITTLE_STRAIGHT ) , [number] ) [EOL] [EOL] def test_big_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . BIG_STRAIGHT ) , [number] ) [EOL] [EOL] def test_big_straight_as_little_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . LITTLE_STRAIGHT ) , [number] ) [EOL] [EOL] def test_no_pairs_but_not_a_big_straight ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . BIG_STRAIGHT ) , [number] ) [EOL] [EOL] def test_choice ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . CHOICE ) , [number] ) [EOL] [EOL] def test_yacht_as_choice ( self ) : [EOL] self . assertEqual ( yacht . score ( [ [number] , [number] , [number] , [number] , [number] ] , yacht . CHOICE ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from house import recite [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HouseTest ( unittest . TestCase ) : [EOL] def test_verse_one_the_house_that_jack_built ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] ) [EOL] [EOL] def test_verse_two_the_malt_that_lay ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] ) [EOL] [EOL] def test_verse_three_the_rat_that_ate ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_four_the_cat_that_killed ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_five_the_dog_that_worried ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_six_the_cow_with_the_crumpled_horn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_seven_the_maiden_all_forlorn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_eight_the_man_all_tattered_and_torn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_nine_the_priest_all_shaven_and_shorn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_10_the_rooster_that_crowed_in_the_morn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_11_the_farmer_sowing_his_corn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_verse_12_the_horse_and_the_hound_and_the_horn ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] ] , ) [EOL] [EOL] def test_multiple_verses ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] def test_full_rhyme ( self ) : [EOL] self . assertEqual ( recite ( [number] , [number] ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] VERSE = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [EOL] def make_verse ( verse ) : [EOL] [docstring] [EOL] return ( [string] + [string] . join ( VERSE [ i ] [ [number] ] + [string] + VERSE [ i - [number] ] [ [number] ] for i in range ( verse , [number] , - [number] ) ) + VERSE [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] def recite ( start_verse , end_verse ) : [EOL] [docstring] [EOL] return [ make_verse ( verse ) for verse in range ( start_verse - [number] , end_verse ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from __future__ import division [EOL] [EOL] from math import gcd [EOL] [EOL] [EOL] class Rational ( object ) : [EOL] def __init__ ( self , numer , denom ) : [EOL] if denom == [number] : [EOL] raise ValueError ( [string] ) [EOL] if denom < [number] : [EOL] numer = numer * - [number] [EOL] gcd_ = gcd ( numer , denom ) [EOL] self . numer = numer // gcd_ [EOL] self . denom = abs ( denom // gcd_ ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . numer == other . numer and self . denom == other . denom [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( self . numer , self . denom ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return Rational ( self . numer * other . denom + self . denom * other . numer , self . denom * other . denom , ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return Rational ( self . numer * other . denom - self . denom * other . numer , self . denom * other . denom , ) [EOL] [EOL] def __mul__ ( self , other ) : [EOL] return Rational ( self . numer * other . numer , self . denom * other . denom ) [EOL] [EOL] def __truediv__ ( self , other ) : [EOL] return Rational ( self . numer * other . denom , self . denom * other . numer ) [EOL] [EOL] def __abs__ ( self ) : [EOL] return Rational ( abs ( self . numer ) , self . denom ) [EOL] [EOL] def __pow__ ( self , power ) : [EOL] return Rational ( self . numer ** power , self . denom ** power ) [EOL] [EOL] def __rpow__ ( self , base ) : [EOL] return base ** ( self . numer / self . denom ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 $"Rational"$ 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 $"Rational"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Rational"$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0
from __future__ import division [EOL] [EOL] import unittest [EOL] [EOL] from rational_numbers import Rational [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RationalNumbersTest ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def test_add_two_positive_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) + Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_add_a_positive_rational_number_and_a_negative_rational_number ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) + Rational ( - [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_add_two_negative_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) + Rational ( - [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_add_a_rational_number_to_its_additive_inverse ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) + Rational ( - [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_subtract_two_positive_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) - Rational ( [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_subtract_a_positive_rational_number_and_a_negative_rational_number ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) - Rational ( - [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_subtract_two_negative_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) - Rational ( - [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_subtract_a_rational_number_from_itself ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) - Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_multiply_two_positive_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) * Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_multiply_a_negative_rational_number_by_a_positive_rational_number ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) * Rational ( [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_multiply_two_negative_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) * Rational ( - [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_multiply_a_rational_number_by_its_reciprocal ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) * Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_multiply_a_rational_number_by_1 ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) * Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_multiply_a_rational_number_by_0 ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) * Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_divide_two_positive_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) / Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_divide_a_positive_rational_number_by_a_negative_rational_number ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) / Rational ( - [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_divide_two_negative_rational_numbers ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) / Rational ( - [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_divide_a_rational_number_by_1 ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) / Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_absolute_value_of_a_positive_rational_number ( self ) : [EOL] self . assertEqual ( abs ( Rational ( [number] , [number] ) ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_absolute_value_of_a_positive_rational_number_with_negative_numerator_and_denominator ( self , ) : [EOL] self . assertEqual ( abs ( Rational ( - [number] , - [number] ) ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_absolute_value_of_a_negative_rational_number ( self ) : [EOL] self . assertEqual ( abs ( Rational ( - [number] , [number] ) ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_absolute_value_of_a_negative_rational_number_with_negative_denominator ( self , ) : [EOL] self . assertEqual ( abs ( Rational ( [number] , - [number] ) ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_absolute_value_of_zero ( self ) : [EOL] self . assertEqual ( abs ( Rational ( [number] , [number] ) ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_raise_a_positive_rational_number_to_a_positive_integer_power ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) ** [number] , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_raise_a_negative_rational_number_to_a_positive_integer_power ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) ** [number] , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_raise_zero_to_an_integer_power ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) ** [number] , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_raise_one_to_an_integer_power ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) ** [number] , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_raise_a_positive_rational_number_to_the_power_of_zero ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) ** [number] , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_raise_a_negative_rational_number_to_the_power_of_zero ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) ** [number] , Rational ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_raise_a_real_number_to_a_positive_rational_number ( self ) : [EOL] self . assertAlmostEqual ( [number] ** Rational ( [number] , [number] ) , [number] , places = [number] ) [EOL] [EOL] def test_raise_a_real_number_to_a_negative_rational_number ( self ) : [EOL] self . assertAlmostEqual ( [number] ** Rational ( - [number] , [number] ) , [number] , places = [number] ) [EOL] [EOL] def test_raise_a_real_number_to_a_zero_rational_number ( self ) : [EOL] self . assertAlmostEqual ( [number] ** Rational ( [number] , [number] ) , [number] , places = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_reduce_a_positive_rational_number_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_reduce_a_negative_rational_number_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_reduce_a_rational_number_with_a_negative_denominator_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( [number] , - [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_reduce_zero_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] def test_reduce_an_integer_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( - [number] , [number] ) , Rational ( - [number] , [number] ) ) [EOL] [EOL] def test_reduce_one_to_lowest_terms ( self ) : [EOL] self . assertEqual ( Rational ( [number] , [number] ) , Rational ( [number] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Tuple , Literal , List [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def recite_one_verse ( verse ) : [EOL] [docstring] [EOL] plural = [string] if verse > [number] else [string] [EOL] day_presents = [ ( [string] , plural + [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] day = day_presents [ verse - [number] ] [ [number] ] [EOL] presents = [string] . join ( [ day_presents [ i - [number] ] [ [number] ] for i in range ( verse , [number] , - [number] ) ] ) [EOL] return [ f" [string] { day } [string] " f"{ presents }" ] [EOL] [EOL] [EOL] def recite ( start_verse , end_verse ) : [EOL] [docstring] [EOL] return [ recite_one_verse ( verse ) [ [number] ] for verse in range ( start_verse , end_verse + [number] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from twelve_days import recite [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TwelveDaysTest ( unittest . TestCase ) : [EOL] def test_verse1 ( self ) : [EOL] expected = [ [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse2 ( self ) : [EOL] expected = [ [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse3 ( self ) : [EOL] expected = [ [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse4 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse5 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse6 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse7 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse8 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse9 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse10 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse11 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_verse12 ( self ) : [EOL] expected = [ [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_first_three_verses_of_the_song ( self ) : [EOL] expected = [ recite ( n , n ) [ [number] ] for n in range ( [number] , [number] ) ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_three_verses_from_the_middle_of_the_song ( self ) : [EOL] expected = [ recite ( n , n ) [ [number] ] for n in range ( [number] , [number] ) ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] def test_the_whole_song ( self ) : [EOL] expected = [ recite ( n , n ) [ [number] ] for n in range ( [number] , [number] ) ] [EOL] self . assertEqual ( recite ( [number] , [number] ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from scrabble_score import score [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ScrabbleScoreTest ( unittest . TestCase ) : [EOL] def test_lowercase_letter ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_uppercase_letter ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_valuable_letter ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_short_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_short_valuable_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_medium_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_medium_valuable_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_long_mixed_case_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_english_like_word ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_empty_input ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] def test_entire_alphabet_available ( self ) : [EOL] self . assertEqual ( score ( [string] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Dict [EOL] [EOL] [EOL] def make_value_dict ( ) : [EOL] [docstring] [EOL] value_dict = { } [EOL] [EOL] def write_input ( key , value ) : [EOL] [docstring] [EOL] for character in key : [EOL] value_dict [ character ] = value [EOL] [EOL] values = [ ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ( [string] , [number] ) , ] [EOL] for value in values : [EOL] write_input ( value [ [number] ] , value [ [number] ] ) [EOL] return value_dict [EOL] [EOL] [EOL] def score ( word ) : [EOL] [docstring] [EOL] value_dict = make_value_dict ( ) [EOL] return sum ( value_dict [ character ] for character in word . upper ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from perfect_numbers import classify [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PerfectNumbersTest ( unittest . TestCase ) : [EOL] def test_smallest_perfect_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_medium_perfect_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_large_perfect_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] [EOL] class AbundantNumbersTest ( unittest . TestCase ) : [EOL] def test_smallest_abundant_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_medium_abundant_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_large_abundant_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] [EOL] class DeficientNumbersTest ( unittest . TestCase ) : [EOL] def test_smallest_prime_deficient_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_smallest_non_prime_deficient_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_medium_deficient_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_large_deficient_number_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] def test_edge_case_no_factors_other_than_itself_is_classified_correctly ( self ) : [EOL] self . assertIs ( classify ( [number] ) , [string] ) [EOL] [EOL] [EOL] class InvalidInputsTest ( unittest . TestCase ) : [EOL] def test_zero_is_rejected_not_a_natural_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] classify ( [number] ) [EOL] [EOL] def test_negative_integer_is_rejected_not_a_natural_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] classify ( - [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] from functools import reduce [EOL] [EOL] [EOL] def classify ( number ) : [EOL] [docstring] [EOL] if number < [number] : [EOL] raise ValueError ( [string] ) [EOL] factors_sum = ( sum ( set ( reduce ( list . __add__ , ( [ s , number // s ] for s in range ( [number] , int ( number ** [number] ) + [number] ) if not number % s ) , ) ) ) / [number] ) [EOL] if factors_sum == number : [EOL] return [string] [EOL] if factors_sum > number : [EOL] return [string] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from grade_school import School [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class GradeSchoolTest ( unittest . TestCase ) : [EOL] def test_adding_a_student_adds_them_to_the_sorted_roster ( self ) : [EOL] school = School ( ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] expected = [ [string] ] [EOL] self . assertEqual ( school . roster ( ) , expected ) [EOL] [EOL] def test_adding_more_student_adds_them_to_the_sorted_roster ( self ) : [EOL] school = School ( ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( school . roster ( ) , expected ) [EOL] [EOL] def test_adding_students_to_different_grades_adds_them_to_the_same_sorted_roster ( self , ) : [EOL] school = School ( ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( school . roster ( ) , expected ) [EOL] [EOL] def test_roster_returns_an_empty_list_if_there_are_no_students_enrolled ( self ) : [EOL] school = School ( ) [EOL] expected = [ ] [EOL] self . assertEqual ( school . roster ( ) , expected ) [EOL] [EOL] def test_student_names_with_grades_are_displayed_in_the_same_sorted_roster ( self ) : [EOL] school = School ( ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( school . roster ( ) , expected ) [EOL] [EOL] def test_grade_returns_the_students_in_that_grade_in_alphabetical_order ( self ) : [EOL] school = School ( ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] school . add_student ( name = [string] , grade = [number] ) [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( school . grade ( [number] ) , expected ) [EOL] [EOL] def test_grade_returns_an_empty_list_if_there_are_no_students_in_that_grade ( self ) : [EOL] school = School ( ) [EOL] expected = [ ] [EOL] self . assertEqual ( school . grade ( [number] ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from collections import defaultdict [EOL] from typing import List [EOL] [EOL] [EOL] class School ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . students = defaultdict ( set ) [EOL] [EOL] def add_student ( self , name , grade ) : [EOL] [docstring] [EOL] self . students [ grade ] . add ( name ) [EOL] [EOL] def roster ( self ) : [EOL] [docstring] [EOL] return [ student for grade in sorted ( self . students . keys ( ) ) for student in self . grade ( grade ) ] [EOL] [EOL] def grade ( self , grade_number ) : [EOL] [docstring] [EOL] return sorted ( self . students [ grade_number ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def find_anagrams ( word , candidates ) : [EOL] lower_word = word . lower ( ) [EOL] sorted_word = sorted ( lower_word ) [EOL] return [ candidate for candidate in candidates if sorted ( candidate . lower ( ) ) == sorted_word and candidate . lower ( ) != lower_word ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from anagram import find_anagrams [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AnagramTest ( unittest . TestCase ) : [EOL] def test_no_matches ( self ) : [EOL] candidates = [ [string] , [string] , [string] , [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_two_anagrams ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_does_not_detect_anagram_subsets ( self ) : [EOL] candidates = [ [string] , [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_anagram ( self ) : [EOL] candidates = [ [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_three_anagrams ( self ) : [EOL] candidates = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_multiple_anagrams_with_different_case ( self ) : [EOL] candidates = [ [string] , [string] ] [EOL] expected = [ [string] , [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_does_not_detect_non_anagrams_with_identical_checksum ( self ) : [EOL] candidates = [ [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_anagrams_case_insensitively ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_anagrams_using_case_insensitive_subject ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_detects_anagrams_using_case_insensitive_possible_matches ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_does_not_detect_an_anagram_if_the_original_word_is_repeated ( self ) : [EOL] candidates = [ [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_anagrams_must_use_all_letters_exactly_once ( self ) : [EOL] candidates = [ [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_words_are_not_anagrams_of_themselves_case_insensitive ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] def test_words_other_than_themselves_can_be_anagrams ( self ) : [EOL] candidates = [ [string] , [string] , [string] ] [EOL] expected = [ [string] ] [EOL] self . assertCountEqual ( find_anagrams ( [string] , candidates ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from series import slices [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SeriesTest ( unittest . TestCase ) : [EOL] def test_slices_of_one_from_one ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] ] ) [EOL] [EOL] def test_slices_of_one_from_two ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] , [string] ] ) [EOL] [EOL] def test_slices_of_two ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] ] ) [EOL] [EOL] def test_slices_of_two_overlap ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_slices_can_include_duplicates ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_slices_of_a_long_series ( self ) : [EOL] self . assertEqual ( slices ( [string] , [number] ) , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] def test_slice_length_is_too_large ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] slices ( [string] , [number] ) [EOL] [EOL] def test_slice_length_cannot_be_zero ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] slices ( [string] , [number] ) [EOL] [EOL] def test_slice_length_cannot_be_negative ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] slices ( [string] , - [number] ) [EOL] [EOL] def test_empty_series_is_invalid ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] slices ( [string] , [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def slices ( series , length ) : [EOL] if len ( series ) < length or length <= [number] : [EOL] raise ValueError ( [string] ) [EOL] return [ series [ i : i + length ] for i in range ( len ( series ) - length + [number] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from simple_linked_list import EmptyListException , LinkedList [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SimpleLinkedListTest ( unittest . TestCase ) : [EOL] def test_empty_list_has_len_zero ( self ) : [EOL] sut = LinkedList ( ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] [EOL] def test_singleton_list_has_len_one ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] [EOL] def test_non_empty_list_has_correct_len ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] [EOL] def test_error_on_empty_list_head ( self ) : [EOL] sut = LinkedList ( ) [EOL] with self . assertRaisesWithMessage ( EmptyListException ) : [EOL] sut . head ( ) [EOL] [EOL] def test_singleton_list_has_head ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertEqual ( sut . head ( ) . value ( ) , [number] ) [EOL] [EOL] def test_non_empty_list_has_correct_head ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] ] ) [EOL] self . assertEqual ( sut . head ( ) . value ( ) , [number] ) [EOL] [EOL] def test_can_push_to_non_empty_list ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] , [number] ] ) [EOL] sut . push ( [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] [EOL] def test_pushing_to_empty_list_changes_head ( self ) : [EOL] sut = LinkedList ( ) [EOL] sut . push ( [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] self . assertEqual ( sut . head ( ) . value ( ) , [number] ) [EOL] [EOL] def test_can_pop_from_non_empty_list ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( sut . pop ( ) , [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] self . assertEqual ( sut . head ( ) . value ( ) , [number] ) [EOL] [EOL] def test_pop_from_singleton_list_removes_head ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertEqual ( sut . pop ( ) , [number] ) [EOL] with self . assertRaisesWithMessage ( EmptyListException ) : [EOL] sut . head ( ) [EOL] [EOL] def test_error_on_empty_list_pop ( self ) : [EOL] sut = LinkedList ( ) [EOL] with self . assertRaisesWithMessage ( EmptyListException ) : [EOL] sut . pop ( ) [EOL] [EOL] def test_push_and_pop ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] ] ) [EOL] sut . push ( [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] self . assertEqual ( sut . pop ( ) , [number] ) [EOL] self . assertEqual ( sut . pop ( ) , [number] ) [EOL] self . assertEqual ( sut . pop ( ) , [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] sut . push ( [number] ) [EOL] self . assertEqual ( len ( sut ) , [number] ) [EOL] self . assertEqual ( sut . head ( ) . value ( ) , [number] ) [EOL] [EOL] def test_singleton_list_head_has_no_next ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertIsNone ( sut . head ( ) . next ( ) ) [EOL] [EOL] def test_non_empty_list_traverse ( self ) : [EOL] sut = LinkedList ( range ( [number] ) ) [EOL] current = sut . head ( ) [EOL] for i in range ( [number] ) : [EOL] self . assertEqual ( current . value ( ) , [number] - i ) [EOL] current = current . next ( ) [EOL] self . assertIsNone ( current ) [EOL] [EOL] def test_empty_linked_list_to_list_is_empty ( self ) : [EOL] sut = LinkedList ( ) [EOL] self . assertEqual ( list ( sut ) , [ ] ) [EOL] [EOL] def test_singleton_linked_list_to_list_list_with_singular_element ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertEqual ( list ( sut ) , [ [number] ] ) [EOL] [EOL] def test_non_empty_linked_list_to_list_is_list_with_all_elements ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( list ( sut ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_reversed_empty_list_is_empty_list ( self ) : [EOL] sut = LinkedList ( [ ] ) [EOL] self . assertEqual ( list ( sut . reversed ( ) ) , [ ] ) [EOL] [EOL] def test_reversed_singleton_list_is_same_list ( self ) : [EOL] sut = LinkedList ( [ [number] ] ) [EOL] self . assertEqual ( list ( sut . reversed ( ) ) , [ [number] ] ) [EOL] [EOL] def test_reverse_non_empty_list ( self ) : [EOL] sut = LinkedList ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( list ( sut . reversed ( ) ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Union , Optional , Any , List [EOL] import typing [EOL] import list [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Iterator , List , Optional , Union [EOL] [EOL] [EOL] class Node ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value ) : [EOL] self . node_value = value [EOL] self . next_node = None [EOL] [EOL] def value ( self ) : [EOL] return self . node_value [EOL] [EOL] def next ( self ) : [EOL] return self . next_node [EOL] [EOL] [EOL] class LinkedList ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , values = [ ] ) : [EOL] self . head_node = None [EOL] self . length = [number] [EOL] for value in values : [EOL] self . push ( value ) [EOL] self . length = len ( values ) [EOL] self . index = self . length [EOL] [EOL] def __len__ ( self ) : [EOL] return self . length [EOL] [EOL] def __iter__ ( self ) : [EOL] return ( self . pop ( ) for i in range ( self . length ) ) [EOL] [EOL] def head ( self ) : [EOL] if self . __len__ ( ) == [number] : [EOL] raise EmptyListException ( [string] ) [EOL] return self . head_node [EOL] [EOL] def push ( self , value ) : [EOL] node = Node ( value ) [EOL] node . next_node = self . head_node [EOL] self . head_node = node [EOL] self . length = self . length + [number] [EOL] [EOL] def pop ( self ) : [EOL] if self . __len__ ( ) == [number] : [EOL] raise EmptyListException ( [string] ) [EOL] to_return = self . head_node . value ( ) [EOL] self . head_node = self . head_node . next ( ) [EOL] self . length = self . length - [number] [EOL] return to_return [EOL] [EOL] def recurse_reverse ( self , current , previous ) : [EOL] if current . next ( ) is None : [EOL] current . next_node = previous [EOL] self . head_node = current [EOL] return [EOL] next_node = current . next ( ) [EOL] current . next_node = previous [EOL] self . recurse_reverse ( next_node , current ) [EOL] [EOL] def reversed ( self ) : [EOL] if self . head_node is None : [EOL] return self [EOL] self . recurse_reverse ( self . head_node , None ) [EOL] return self [EOL] [EOL] [EOL] class EmptyListException ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $Node$ 0 $typing.Optional[Node]$ 0 0 0 0 $Node$ 0 0 0 0 0 0 0 0 $Node$ 0 0 0 $typing.Optional[Node]$ 0 0 0 0 0 $Node$ 0 0 0 0 0 $Node$ 0 0 0 0 0 $Node$ 0 0 0 $typing.Optional[Node]$ 0 0 0 0 0 0 0 $Node$ 0 0 0 0 $"LinkedList"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] CODES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def color_code ( color ) : [EOL] [docstring] [EOL] return CODES [ color ] [EOL] [EOL] [EOL] def colors ( ) : [EOL] [docstring] [EOL] return [ color for color in CODES ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from resistor_color import color_code , colors [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ResistorColorTest ( unittest . TestCase ) : [EOL] def test_black ( self ) : [EOL] self . assertEqual ( color_code ( [string] ) , [number] ) [EOL] [EOL] def test_white ( self ) : [EOL] self . assertEqual ( color_code ( [string] ) , [number] ) [EOL] [EOL] def test_orange ( self ) : [EOL] self . assertEqual ( color_code ( [string] ) , [number] ) [EOL] [EOL] def test_colors ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( colors ( ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from two_fer import two_fer [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TwoFerTest ( unittest . TestCase ) : [EOL] def test_no_name_given ( self ) : [EOL] self . assertEqual ( two_fer ( ) , [string] ) [EOL] [EOL] def test_a_name_given ( self ) : [EOL] self . assertEqual ( two_fer ( [string] ) , [string] ) [EOL] [EOL] def test_another_name_given ( self ) : [EOL] self . assertEqual ( two_fer ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def two_fer ( name = [string] ) : [EOL] [docstring] [EOL] return f" [string] { name } [string] " [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import re [EOL] [EOL] [EOL] class PhoneNumber ( object ) : [EOL] def __init__ ( self , phone_number ) : [EOL] self . number = self . valid_phone_number ( phone_number ) [EOL] self . area_code = self . number [ : [number] ] [EOL] [EOL] def pretty ( self ) : [EOL] return f" [string] { self . area_code } [string] { self . number [ [number] : [number] ] } [string] { self . number [ [number] : ] }" [EOL] [EOL] def valid_phone_number ( self , phone_number ) : [EOL] number = re . sub ( [string] , [string] , phone_number ) [EOL] if len ( number ) < [number] or len ( number ) > [number] : [EOL] raise ValueError ( [string] ) [EOL] if len ( number ) == [number] and number [ [number] ] != [string] : [EOL] raise ValueError ( [string] ) [EOL] number = number [ - [number] : ] [EOL] if number [ [number] ] in [string] : [EOL] raise ValueError ( [string] ) [EOL] if number [ [number] ] in [string] : [EOL] raise ValueError ( [string] ) [EOL] return number [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from phone_number import PhoneNumber [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PhoneNumberTest ( unittest . TestCase ) : [EOL] def test_cleans_the_number ( self ) : [EOL] number = PhoneNumber ( [string] ) . number [EOL] self . assertEqual ( number , [string] ) [EOL] [EOL] def test_cleans_numbers_with_dots ( self ) : [EOL] number = PhoneNumber ( [string] ) . number [EOL] self . assertEqual ( number , [string] ) [EOL] [EOL] def test_cleans_numbers_with_multiple_spaces ( self ) : [EOL] number = PhoneNumber ( [string] ) . number [EOL] self . assertEqual ( number , [string] ) [EOL] [EOL] def test_invalid_when_9_digits ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_when_11_digits_does_not_start_with_a_1 ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_valid_when_11_digits_and_starting_with_1 ( self ) : [EOL] number = PhoneNumber ( [string] ) . number [EOL] self . assertEqual ( number , [string] ) [EOL] [EOL] def test_valid_when_11_digits_and_starting_with_1_even_with_punctuation ( self ) : [EOL] number = PhoneNumber ( [string] ) . number [EOL] self . assertEqual ( number , [string] ) [EOL] [EOL] def test_invalid_when_more_than_11_digits ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_with_letters ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_with_punctuations ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_area_code_starts_with_0 ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_area_code_starts_with_1 ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_exchange_code_starts_with_0 ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_exchange_code_starts_with_1 ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_area_code_starts_with_0_on_valid_11_digit_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_area_code_starts_with_1_on_valid_11_digit_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_exchange_code_starts_with_0_on_valid_11_digit_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] def test_invalid_if_exchange_code_starts_with_1_on_valid_11_digit_number ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] PhoneNumber ( [string] ) [EOL] [EOL] [comment] [EOL] def test_area_code ( self ) : [EOL] number = PhoneNumber ( [string] ) [EOL] self . assertEqual ( number . area_code , [string] ) [EOL] [EOL] def test_pretty_print ( self ) : [EOL] number = PhoneNumber ( [string] ) [EOL] self . assertEqual ( number . pretty ( ) , [string] ) [EOL] [EOL] def test_pretty_print_with_full_us_phone_number ( self ) : [EOL] number = PhoneNumber ( [string] ) [EOL] self . assertEqual ( number . pretty ( ) , [string] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from sieve import primes [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SieveTest ( unittest . TestCase ) : [EOL] def test_no_primes_under_two ( self ) : [EOL] self . assertEqual ( primes ( [number] ) , [ ] ) [EOL] [EOL] def test_find_first_prime ( self ) : [EOL] self . assertEqual ( primes ( [number] ) , [ [number] ] ) [EOL] [EOL] def test_find_primes_up_to_10 ( self ) : [EOL] self . assertEqual ( primes ( [number] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_limit_is_prime ( self ) : [EOL] self . assertEqual ( primes ( [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_find_primes_up_to_1000 ( self ) : [EOL] self . assertEqual ( primes ( [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def primes ( limit ) : [EOL] [docstring] [EOL] all_primes = [ ] [EOL] numbers = range ( [number] , limit + [number] ) [EOL] while numbers : [EOL] prime = numbers [ [number] ] [EOL] all_primes . append ( prime ) [EOL] numbers = [ number for number in numbers if number % prime != [number] ] [EOL] return all_primes [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from collatz_conjecture import steps [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class CollatzConjectureTest ( unittest . TestCase ) : [EOL] def test_zero_steps_for_one ( self ) : [EOL] self . assertEqual ( steps ( [number] ) , [number] ) [EOL] [EOL] def test_divide_if_even ( self ) : [EOL] self . assertEqual ( steps ( [number] ) , [number] ) [EOL] [EOL] def test_even_and_odd_steps ( self ) : [EOL] self . assertEqual ( steps ( [number] ) , [number] ) [EOL] [EOL] def test_large_number_of_even_and_odd_steps ( self ) : [EOL] self . assertEqual ( steps ( [number] ) , [number] ) [EOL] [EOL] def test_zero_is_an_error ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] steps ( [number] ) [EOL] [EOL] def test_negative_value_is_an_error ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] steps ( - [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def steps ( number ) : [EOL] if number < [number] : [EOL] raise ValueError ( [string] ) [EOL] count = [number] [EOL] while number > [number] : [EOL] if number % [number] == [number] : [EOL] number = number / [number] [EOL] else : [EOL] number = number * [number] + [number] [EOL] count = count + [number] [EOL] return count [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from queen_attack import Queen [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class QueenAttackTest ( unittest . TestCase ) : [EOL] [comment] [EOL] def test_queen_with_a_valid_position ( self ) : [EOL] Queen ( [number] , [number] ) [EOL] [EOL] def test_queen_must_have_positive_row ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Queen ( - [number] , [number] ) [EOL] [EOL] def test_queen_must_have_row_on_board ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Queen ( [number] , [number] ) [EOL] [EOL] def test_queen_must_have_positive_column ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Queen ( [number] , - [number] ) [EOL] [EOL] def test_queen_must_have_column_on_board ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Queen ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] def test_can_not_attack ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , False ) [EOL] [EOL] def test_can_attack_on_same_row ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] def test_can_attack_on_same_column ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] def test_can_attack_on_first_diagonal ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] def test_can_attack_on_second_diagonal ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] def test_can_attack_on_third_diagonal ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] def test_can_attack_on_fourth_diagonal ( self ) : [EOL] self . assertIs ( Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) , True ) [EOL] [EOL] [comment] [EOL] def test_queens_same_position_can_attack ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Queen ( [number] , [number] ) . can_attack ( Queen ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class Queen ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , row , column ) : [EOL] [docstring] [EOL] if min ( row , column ) >= [number] and max ( row , column ) < [number] : [EOL] self . row = row [EOL] self . column = column [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] [EOL] def can_attack ( self , another_queen ) : [EOL] [docstring] [EOL] if ( self . row , self . column ) == ( another_queen . row , another_queen . column ) : [EOL] raise ValueError ( [string] ) [EOL] if self . row == another_queen . row or self . column == another_queen . column : [EOL] return True [EOL] if self . row + self . column == another_queen . row + another_queen . column : [EOL] return True [EOL] if abs ( self . row - self . column ) == abs ( another_queen . row - another_queen . column ) : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Queen"$ 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Queen"$ 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Queen"$ 0 0 0 $"Queen"$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List , Optional [EOL] [EOL] [EOL] def find_fewest_coins ( coins , target ) : [EOL] [docstring] [EOL] if target == [number] : [EOL] return [ ] [EOL] target_coin_list = find_fewest_coins_recursive ( sorted ( coins , reverse = True ) , target ) [EOL] if not target_coin_list : [EOL] raise ValueError ( [string] ) [EOL] return sorted ( target_coin_list ) [EOL] [EOL] [EOL] def find_fewest_coins_recursive ( coins , target , coin_list = None ) : [EOL] [docstring] [EOL] coins = [ coin for coin in coins if coin <= target ] [EOL] if not coins : [EOL] return [ ] [EOL] if coin_list is None : [EOL] coin_list = [ ] [EOL] if target % coins [ [number] ] == [number] : [EOL] return coin_list + [ coins [ [number] ] ] * ( target // coins [ [number] ] ) [EOL] best_coin_list = [ ] [EOL] min_length = target // min ( coins ) + len ( coin_list ) + [number] [EOL] for coin in coins : [EOL] if len ( coin_list ) + target // coin < min_length : [EOL] target_coin_list = find_fewest_coins_recursive ( coins , target - coin , coin_list + [ coin ] ) [EOL] if target_coin_list and len ( target_coin_list ) < min_length : [EOL] min_length = len ( target_coin_list ) [EOL] best_coin_list = target_coin_list [EOL] return best_coin_list [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from change import find_fewest_coins [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ChangeTest ( unittest . TestCase ) : [EOL] def test_single_coin_change ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_multiple_coin_change ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_change_with_Lilliputian_Coins ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_change_with_Lower_Elbonia_Coins ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_large_target_values ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] [EOL] def test_possible_change_without_unit_coins_available ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_another_possible_change_without_unit_coins_available ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] ] , [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_no_coins_make_0_change ( self ) : [EOL] self . assertEqual ( find_fewest_coins ( [ [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ ] ) [EOL] [EOL] def test_error_testing_for_change_smaller_than_smallest_coin ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find_fewest_coins ( [ [number] , [number] ] , [number] ) [EOL] [EOL] def test_error_if_no_combination_can_add_up_to_target ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find_fewest_coins ( [ [number] , [number] ] , [number] ) [EOL] [EOL] def test_cannot_find_negative_change_values ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find_fewest_coins ( [ [number] , [number] , [number] ] , - [number] ) [EOL] [EOL] [comment] [EOL] def setUp ( self ) : [EOL] try : [EOL] self . assertRaisesRegex [EOL] except AttributeError : [EOL] self . assertRaisesRegex = self . assertRaisesRegexp [EOL] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import List [EOL] [EOL] NUMBERS = { [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , } [EOL] [EOL] [EOL] def convert_one_number ( number ) : [EOL] [docstring] [EOL] for key in NUMBERS : [EOL] if [string] . join ( number ) == [string] . join ( NUMBERS [ key ] ) : [EOL] return key [EOL] return [string] [EOL] [EOL] [EOL] def convert ( input_grid ) : [EOL] [docstring] [EOL] length = len ( input_grid [ [number] ] ) [EOL] width = len ( input_grid ) [EOL] if width % [number] != [number] or length % [number] != [number] : [EOL] raise ValueError ( [string] ) [EOL] numbers = [ [ [ line [ j : j + [number] ] for line in input_grid [ i : i + [number] ] ] for j in range ( [number] , length , [number] ) ] for i in range ( [number] , width , [number] ) ] [EOL] return [string] . join ( [ [string] . join ( [ convert_one_number ( number ) for number in line ] ) for line in numbers ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from ocr_numbers import convert [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class OcrNumbersTest ( unittest . TestCase ) : [EOL] def test_recognizes_0 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_1 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_unreadable_but_correctly_sized_inputs_return ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_input_with_a_number_of_lines_that_is_not_a_multiple_of_four_raises_an_error ( self , ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] convert ( [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_input_with_a_number_of_columns_that_is_not_a_multiple_of_three_raises_an_error ( self , ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] convert ( [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_recognizes_110101100 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] , ] ) , [string] , ) [EOL] [EOL] def test_garbled_numbers_in_a_string_are_replaced_with ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] , ] ) , [string] , ) [EOL] [EOL] def test_recognizes_2 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_3 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_4 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_5 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_6 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_7 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_8 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_9 ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] ] ) , [string] ) [EOL] [EOL] def test_recognizes_string_of_decimal_numbers ( self ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] , ] ) , [string] , ) [EOL] [EOL] def test_numbers_separated_by_empty_lines_are_recognized_lines_are_joined_by_commas ( self , ) : [EOL] self . assertEqual ( convert ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) , [string] , ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from dominoes import can_chain [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DominoesTest ( unittest . TestCase ) : [EOL] def test_empty_input_empty_output ( self ) : [EOL] input_dominoes = [ ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_singleton_input_singleton_output ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_singleton_that_can_t_be_chained ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . refute_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_three_elements ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_can_reverse_dominoes ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_can_t_be_chained ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . refute_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_disconnected_simple ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . refute_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_disconnected_double_loop ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . refute_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_disconnected_single_isolated ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . refute_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_need_backtrack ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_separate_loops ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] def test_nine_elements ( self ) : [EOL] input_dominoes = [ ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ( [number] , [number] ) , ] [EOL] output_chain = can_chain ( input_dominoes ) [EOL] self . assert_correct_chain ( input_dominoes , output_chain ) [EOL] [EOL] [comment] [EOL] [EOL] def normalize_dominoes ( self , dominoes ) : [EOL] return list ( sorted ( tuple ( sorted ( domino ) ) for domino in dominoes ) ) [EOL] [EOL] def assert_same_dominoes ( self , input_dominoes , output_chain ) : [EOL] msg = ( [string] [string] ) [EOL] input_normal = self . normalize_dominoes ( input_dominoes ) [EOL] output_normal = self . normalize_dominoes ( output_chain ) [EOL] self . assertEqual ( input_normal , output_normal , msg ) [EOL] [EOL] def assert_consecutive_dominoes_match ( self , output_chain ) : [EOL] for i in range ( len ( output_chain ) - [number] ) : [EOL] msg = ( [string] [string] ) [EOL] msg = msg . format ( output_chain , i , output_chain [ i ] , i + [number] , output_chain [ i + [number] ] ) [EOL] self . assertEqual ( output_chain [ i ] [ [number] ] , output_chain [ i + [number] ] [ [number] ] , msg ) [EOL] [EOL] def assert_dominoes_at_ends_match ( self , output_chain ) : [EOL] msg = ( [string] [string] ) [EOL] msg = msg . format ( output_chain , output_chain [ [number] ] , output_chain [ - [number] ] ) [EOL] self . assertEqual ( output_chain [ [number] ] [ [number] ] , output_chain [ - [number] ] [ [number] ] , msg ) [EOL] [EOL] def assert_correct_chain ( self , input_dominoes , output_chain ) : [EOL] msg = [string] . format ( input_dominoes ) [EOL] self . assertIsNotNone ( output_chain , msg ) [EOL] self . assert_same_dominoes ( input_dominoes , output_chain ) [EOL] if not any ( output_chain ) : [EOL] return [EOL] self . assert_consecutive_dominoes_match ( output_chain ) [EOL] self . assert_dominoes_at_ends_match ( output_chain ) [EOL] [EOL] def refute_correct_chain ( self , input_dominoes , output_chain ) : [EOL] msg = [string] . format ( input_dominoes ) [EOL] self . assertIsNone ( output_chain , msg ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import builtins [EOL] from typing import List , Tuple [EOL] [EOL] [EOL] def can_chain ( dominoes ) : [EOL] if not dominoes : [EOL] return [ ] [EOL] chain = [ dominoes [ [number] ] ] [EOL] for i in range ( [number] , len ( dominoes ) ) : [EOL] pass [EOL] if chain [ [number] ] [ [number] ] != chain [ - [number] ] [ [number] ] : [EOL] return None [EOL] return chain [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from bracket_push import is_paired [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BracketPushTest ( unittest . TestCase ) : [EOL] def test_paired_square_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_empty_string ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_unpaired_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_wrong_ordered_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_wrong_closing_bracket ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_paired_with_whitespace ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_partially_paired_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_simple_nested_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_several_paired_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_paired_and_nested_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_unopened_closing_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_unpaired_and_nested_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_paired_and_wrong_nested_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_paried_and_incomplete_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_too_many_closing_brackets ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , False ) [EOL] [EOL] def test_math_expression ( self ) : [EOL] self . assertEqual ( is_paired ( [string] ) , True ) [EOL] [EOL] def test_complex_latex_expression ( self ) : [EOL] self . assertEqual ( is_paired ( ( [string] [string] ) ) , True , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import re [EOL] [EOL] [EOL] def is_paired ( input_string ) : [EOL] [docstring] [EOL] stack = [ ] [EOL] brackets = re . sub ( [string] , [string] , input_string ) [EOL] bracket_pairs = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] for i in brackets : [EOL] if i in bracket_pairs : [EOL] stack . append ( bracket_pairs [ i ] ) [EOL] elif not stack : [EOL] return False [EOL] elif i == stack [ - [number] ] : [EOL] stack . pop ( ) [EOL] else : [EOL] return False [EOL] return not stack [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] import builtins [EOL] [docstring] [EOL] STATUS_WIN = [string] [EOL] STATUS_LOSE = [string] [EOL] STATUS_ONGOING = [string] [EOL] [EOL] [EOL] class Hangman ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , word ) : [EOL] [docstring] [EOL] self . remaining_guesses = [number] [EOL] self . status = STATUS_ONGOING [EOL] self . word = word [EOL] self . masked_word = [string] . join ( [string] for c in word ) [EOL] self . correct_guess = [ ] [EOL] [EOL] def guess ( self , char ) : [EOL] [docstring] [EOL] if self . status != STATUS_ONGOING : [EOL] raise ValueError ( [string] ) [EOL] [EOL] if char not in self . word or char in self . correct_guess : [EOL] self . remaining_guesses = self . remaining_guesses - [number] [EOL] if self . remaining_guesses < [number] : [EOL] self . status = STATUS_LOSE [EOL] else : [EOL] self . correct_guess . append ( char ) [EOL] self . masked_word = [string] . join ( c if c in self . correct_guess else [string] for c in self . word ) [EOL] if [string] not in self . masked_word : [EOL] self . status = STATUS_WIN [EOL] [EOL] def get_masked_word ( self ) : [EOL] [docstring] [EOL] return self . masked_word [EOL] [EOL] def get_status ( self ) : [EOL] [docstring] [EOL] return self . status [EOL]	0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] import hangman [EOL] from hangman import Hangman [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HangmanTests ( unittest . TestCase ) : [EOL] def test_initially_9_failures_are_allowed ( self ) : [EOL] game = Hangman ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] [EOL] def test_initially_no_letters_are_guessed ( self ) : [EOL] game = Hangman ( [string] ) [EOL] [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] def test_after_10_failures_the_game_is_over ( self ) : [EOL] game = Hangman ( [string] ) [EOL] [EOL] for i in range ( [number] ) : [EOL] game . guess ( [string] ) [EOL] [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_LOSE ) [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] game . guess ( [string] ) [EOL] [EOL] def test_feeding_a_correct_letter_removes_underscores ( self ) : [EOL] game = Hangman ( [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] def test_feeding_a_correct_letter_twice_counts_as_a_failure ( self ) : [EOL] game = Hangman ( [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] def test_getting_all_the_letters_right_makes_for_a_win ( self ) : [EOL] game = Hangman ( [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_ONGOING ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_WIN ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] game . guess ( [string] ) [EOL] [EOL] def test_winning_on_last_guess_still_counts_as_a_win ( self ) : [EOL] game = Hangman ( [string] ) [EOL] for ch in [string] : [EOL] game . guess ( ch ) [EOL] game . guess ( [string] ) [EOL] self . assertEqual ( game . remaining_guesses , [number] ) [EOL] self . assertEqual ( game . get_status ( ) , hangman . STATUS_WIN ) [EOL] self . assertEqual ( game . get_masked_word ( ) , [string] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Dict , Literal , Any , List [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] from functools import total_ordering [EOL] from typing import List [EOL] [EOL] OPPONENT_RESULT = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] MATCH_POINT = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] TEAM_FMT = [string] [EOL] [EOL] [EOL] @ total_ordering class Team : [EOL] def __init__ ( self , name ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . match = [number] [EOL] self . win = [number] [EOL] self . draw = [number] [EOL] self . loss = [number] [EOL] self . point = [number] [EOL] [EOL] def update_result ( self , result ) : [EOL] [docstring] [EOL] self . match = self . match + [number] [EOL] self . point = self . point + MATCH_POINT [ result ] [EOL] setattr ( self , result , getattr ( self , result ) + [number] ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . point , self . name ) == ( other . point , other . name ) [EOL] [EOL] def __gt__ ( self , other ) : [EOL] return ( - self . point , self . name ) < ( - other . point , other . name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return TEAM_FMT . format ( self . name , self . match , self . win , self . draw , self . loss , self . point ) [EOL] [EOL] [EOL] def tally ( rows ) : [EOL] [docstring] [EOL] teams = { } [EOL] for row in rows : [EOL] team_1 , team_2 , result = row . split ( [string] ) [EOL] teams . setdefault ( team_1 , Team ( team_1 ) ) . update_result ( result ) [EOL] teams . setdefault ( team_2 , Team ( team_2 ) ) . update_result ( OPPONENT_RESULT [ result ] ) [EOL] header_fields = ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] header = TEAM_FMT . format ( * header_fields ) [EOL] tables = [ str ( team ) for _ , team in sorted ( teams . items ( ) , key = lambda kv : kv [ [number] ] , reverse = True ) ] [EOL] tables . insert ( [number] , header ) [EOL] return tables [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $"Team"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Team"$ 0 0 0 $"Team"$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from tournament import tally [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TournamentTest ( unittest . TestCase ) : [EOL] def test_just_the_header_if_no_input ( self ) : [EOL] results = [ ] [EOL] table = [ [string] ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_a_win_is_three_points_a_loss_is_zero_points ( self ) : [EOL] results = [ [string] ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_a_win_can_also_be_expressed_as_a_loss ( self ) : [EOL] results = [ [string] ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_a_different_team_can_win ( self ) : [EOL] results = [ [string] ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_a_draw_is_one_point_each ( self ) : [EOL] results = [ [string] ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_there_can_be_more_than_one_match ( self ) : [EOL] results = [ [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_there_can_be_more_than_one_winner ( self ) : [EOL] results = [ [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_there_can_be_more_than_two_teams ( self ) : [EOL] results = [ [string] , [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_typical_input ( self ) : [EOL] results = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_incomplete_competition_not_all_pairs_have_played ( self ) : [EOL] results = [ [string] , [string] , [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] def test_ties_broken_alphabetically ( self ) : [EOL] results = [ [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] table = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( tally ( results ) , table ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Union , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Callable , Union [EOL] [EOL] year_seconds = [number] [EOL] [EOL] year_map = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] class SpaceAge ( object ) : [EOL] def __init__ ( self , seconds ) : [EOL] self . seconds = seconds [EOL] [EOL] [EOL] def on_planet ( r ) : [EOL] def inner ( self ) : [EOL] return round ( self . seconds / year_seconds / r , [number] ) [EOL] [EOL] return inner [EOL] [EOL] [EOL] for k , v in year_map . items ( ) : [EOL] setattr ( SpaceAge , [string] . format ( k ) , on_planet ( v ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[builtins.float,builtins.int]$ 0 0 0 0 0 $typing.Union[builtins.float,builtins.int]$ 0 $typing.Union[builtins.float,builtins.int]$ 0 0 0 0 $typing.Callable$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] def find ( search_list , value ) : [EOL] [docstring] [EOL] start = [number] [EOL] end = len ( search_list ) [EOL] while start < end : [EOL] index = ( start + end ) // [number] [EOL] if search_list [ index ] == value : [EOL] return index [EOL] elif search_list [ index ] > value : [EOL] end = index [EOL] else : [EOL] start = index + [number] [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from binary_search import find [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BinarySearchTest ( unittest . TestCase ) : [EOL] def test_finds_a_value_in_an_array_with_one_element ( self ) : [EOL] self . assertEqual ( find ( [ [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_finds_a_value_in_the_middle_of_an_array ( self ) : [EOL] self . assertEqual ( find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_finds_a_value_at_the_beginning_of_an_array ( self ) : [EOL] self . assertEqual ( find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_finds_a_value_at_the_end_of_an_array ( self ) : [EOL] self . assertEqual ( find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_finds_a_value_in_an_array_of_odd_length ( self ) : [EOL] self . assertEqual ( find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_finds_a_value_in_an_array_of_even_length ( self ) : [EOL] self . assertEqual ( find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_identifies_that_a_value_is_not_included_in_the_array ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_a_value_smaller_than_the_array_s_smallest_value_is_not_found ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_a_value_larger_than_the_array_s_largest_value_is_not_found ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_nothing_is_found_in_an_empty_array ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find ( [ ] , [number] ) [EOL] [EOL] def test_nothing_is_found_when_the_left_and_right_bounds_cross ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] find ( [ [number] , [number] ] , [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from math import gcd [EOL] from string import ascii_lowercase [EOL] [EOL] ALPHABET_LENGTH = [number] [EOL] [EOL] [EOL] def convert ( text , a , b ) : [EOL] [docstring] [EOL] if gcd ( a , ALPHABET_LENGTH ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] text = [string] . join ( [ char for char in text . lower ( ) if char . isalnum ( ) ] ) [EOL] plain_numbers = [ ascii_lowercase . index ( char ) if char in ascii_lowercase else - [number] for char in text ] [EOL] encoded_numbers = [ ( a * item + b ) % ALPHABET_LENGTH if item >= [number] else item for item in plain_numbers ] [EOL] encoded_text = [string] . join ( ascii_lowercase [ value ] if value >= [number] else text [ index ] for index , value in enumerate ( encoded_numbers ) ) [EOL] return encoded_text [EOL] [EOL] [EOL] def encode ( plain_text , a , b ) : [EOL] [docstring] [EOL] encoded_text = convert ( plain_text , a , b ) [EOL] return [string] . join ( [ encoded_text [ i : i + [number] ] for i in range ( [number] , len ( encoded_text ) , [number] ) ] ) [EOL] [EOL] [EOL] def decode ( ciphered_text , a , b ) : [EOL] [docstring] [EOL] mmi = [ ( a * n ) % ALPHABET_LENGTH for n in range ( ALPHABET_LENGTH ) ] . index ( [number] ) [EOL] return convert ( ciphered_text , mmi , - mmi * b ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from affine_cipher import decode , encode [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AffineCipherTest ( unittest . TestCase ) : [EOL] def test_encode_yes ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_no ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_omg ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_o_m_g ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_mindblowingly ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_numbers ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_deep_thought ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_encode_all_the_letters ( self ) : [EOL] self . assertEqual ( encode ( [string] , [number] , [number] ) , [string] , ) [EOL] [EOL] def test_encode_with_a_not_coprime_to_m ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] encode ( [string] , [number] , [number] ) [EOL] [EOL] def test_decode_exercism ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_decode_a_sentence ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] , ) [EOL] [EOL] def test_decode_numbers ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_decode_all_the_letters ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] , ) [EOL] [EOL] def test_decode_with_no_spaces_in_input ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] , ) [EOL] [EOL] def test_decode_with_too_many_spaces ( self ) : [EOL] self . assertEqual ( decode ( [string] , [number] , [number] ) , [string] ) [EOL] [EOL] def test_decode_with_a_not_coprime_to_m ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] decode ( [string] , [number] , [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Pattern , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] import re [EOL] [EOL] BOLD_RE = re . compile ( [string] ) [EOL] ITALICS_RE = re . compile ( [string] ) [EOL] HEADER_RE = re . compile ( [string] ) [EOL] LIST_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] def parse ( markdown ) : [EOL] [docstring] [EOL] lines = markdown . split ( [string] ) [EOL] result = [ ] [EOL] for line in lines : [EOL] line = BOLD_RE . sub ( [string] , line ) [EOL] line = ITALICS_RE . sub ( [string] , line ) [EOL] is_header = HEADER_RE . match ( line ) [EOL] is_list = LIST_RE . match ( line ) [EOL] if is_header : [EOL] result . append ( [string] . format ( len ( is_header . group ( [number] ) ) , is_header . group ( [number] ) ) ) [EOL] elif is_list : [EOL] if result and result [ - [number] ] == [string] : [EOL] result . pop ( ) [EOL] else : [EOL] result . append ( [string] ) [EOL] result . extend ( [ [string] + is_list . group ( [number] ) + [string] , [string] ] ) [EOL] else : [EOL] result . append ( [string] + line + [string] ) [EOL] return [string] . join ( result ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from markdown import parse [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MarkdownTest ( unittest . TestCase ) : [EOL] def test_parses_normal_text_as_a_paragraph ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_parsing_italics ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_parsing_bold_text ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_mixed_normal_italics_and_bold_text ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] def test_with_h1_header_level ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_with_h2_header_level ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_with_h6_header_level ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_unordered_lists ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] ) [EOL] [EOL] def test_with_a_little_bit_of_everything ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] def test_with_markdown_symbols_in_the_header_text_that_should_not_be_interpreted ( self , ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] def test_with_markdown_symbols_in_the_list_item_text_that_should_not_be_interpreted ( self , ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] def test_with_markdown_symbols_in_the_paragraph_text_that_should_not_be_interpreted ( self , ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] def test_unordered_lists_close_properly_with_preceding_and_following_lines ( self ) : [EOL] self . assertEqual ( parse ( [string] ) , [string] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def encode ( numbers ) : [EOL] return numbers [EOL] [EOL] [EOL] def decode ( bytes_ ) : [EOL] return bytes_ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from variable_length_quantity import decode , encode [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class VariableLengthQuantityTest ( unittest . TestCase ) : [EOL] def test_zero ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_arbitrary_single_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_largest_single_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_smallest_double_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_arbitrary_double_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_largest_double_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_smallest_triple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_arbitrary_triple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_largest_triple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_smallest_quadruple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_arbitrary_quadruple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_largest_quadruple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_smallest_quintuple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_arbitrary_quintuple_byte ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_maximum_32_bit_integer_input ( self ) : [EOL] self . assertEqual ( encode ( [ [number] ] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_two_single_byte_values ( self ) : [EOL] self . assertEqual ( encode ( [ [number] , [number] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_two_multi_byte_values ( self ) : [EOL] self . assertEqual ( encode ( [ [number] , [number] ] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_many_multi_byte_values ( self ) : [EOL] self . assertEqual ( encode ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] [EOL] def test_one_byte ( self ) : [EOL] self . assertEqual ( decode ( [ [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_two_bytes ( self ) : [EOL] self . assertEqual ( decode ( [ [number] , [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_three_bytes ( self ) : [EOL] self . assertEqual ( decode ( [ [number] , [number] , [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_four_bytes ( self ) : [EOL] self . assertEqual ( decode ( [ [number] , [number] , [number] , [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_maximum_32_bit_integer ( self ) : [EOL] self . assertEqual ( decode ( [ [number] , [number] , [number] , [number] , [number] ] ) , [ [number] ] ) [EOL] [EOL] def test_incomplete_sequence_causes_error ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] decode ( [ [number] ] ) [EOL] [EOL] def test_incomplete_sequence_causes_error_even_if_value_is_zero ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] decode ( [ [number] ] ) [EOL] [EOL] def test_multiple_values ( self ) : [EOL] self . assertEqual ( decode ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] , ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from difference_of_squares import difference_of_squares , square_of_sum , sum_of_squares [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DifferenceOfSquaresTest ( unittest . TestCase ) : [EOL] def test_square_of_sum_1 ( self ) : [EOL] self . assertEqual ( square_of_sum ( [number] ) , [number] ) [EOL] [EOL] def test_square_of_sum_5 ( self ) : [EOL] self . assertEqual ( square_of_sum ( [number] ) , [number] ) [EOL] [EOL] def test_square_of_sum_100 ( self ) : [EOL] self . assertEqual ( square_of_sum ( [number] ) , [number] ) [EOL] [EOL] def test_sum_of_squares_1 ( self ) : [EOL] self . assertEqual ( sum_of_squares ( [number] ) , [number] ) [EOL] [EOL] def test_sum_of_squares_5 ( self ) : [EOL] self . assertEqual ( sum_of_squares ( [number] ) , [number] ) [EOL] [EOL] def test_sum_of_squares_100 ( self ) : [EOL] self . assertEqual ( sum_of_squares ( [number] ) , [number] ) [EOL] [EOL] def test_difference_of_squares_1 ( self ) : [EOL] self . assertEqual ( difference_of_squares ( [number] ) , [number] ) [EOL] [EOL] def test_difference_of_squares_5 ( self ) : [EOL] self . assertEqual ( difference_of_squares ( [number] ) , [number] ) [EOL] [EOL] def test_difference_of_squares_100 ( self ) : [EOL] self . assertEqual ( difference_of_squares ( [number] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def square_of_sum ( count ) : [EOL] return sum ( range ( count + [number] ) ) ** [number] [EOL] [EOL] [EOL] def sum_of_squares ( count ) : [EOL] return sum ( [ i * i for i in range ( count + [number] ) ] ) [EOL] [EOL] [EOL] def difference_of_squares ( count ) : [EOL] return square_of_sum ( count ) - sum_of_squares ( count ) [EOL]	0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def hello ( ) : [EOL] return [string] [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from hello_world import hello [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HelloWorldTest ( unittest . TestCase ) : [EOL] def test_say_hi ( self ) : [EOL] self . assertEqual ( hello ( ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class CircularBuffer ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , capacity ) : [EOL] [docstring] [EOL] self . capacity = capacity [EOL] self . content = [ ] [EOL] [EOL] def read ( self ) : [EOL] [docstring] [EOL] if not self . content : [EOL] raise ValueError ( [string] ) [EOL] return self . content . pop ( [number] ) [EOL] [EOL] def write ( self , data ) : [EOL] [docstring] [EOL] if len ( self . content ) == self . capacity : [EOL] raise BaseException ( [string] ) [EOL] self . content . append ( data ) [EOL] [EOL] def overwrite ( self , data ) : [EOL] [docstring] [EOL] if len ( self . content ) == self . capacity : [EOL] self . content . pop ( [number] ) [EOL] self . write ( data ) [EOL] [EOL] def clear ( self ) : [EOL] [docstring] [EOL] self . content = [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from circular_buffer import CircularBuffer [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class CircularBufferTest ( unittest . TestCase ) : [EOL] def test_reading_empty_buffer_should_fail ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] with self . assertRaisesWithMessage ( BaseException ) : [EOL] buf . read ( ) [EOL] [EOL] def test_can_read_an_item_just_written ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_each_item_may_only_be_read_once ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] with self . assertRaisesWithMessage ( BaseException ) : [EOL] buf . read ( ) [EOL] [EOL] def test_items_are_read_in_the_order_they_are_written ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_full_buffer_can_t_be_written_to ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] with self . assertRaisesWithMessage ( BaseException ) : [EOL] buf . write ( [string] ) [EOL] [EOL] def test_a_read_frees_up_capacity_for_another_write ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_read_position_is_maintained_even_across_multiple_writes ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_items_cleared_out_of_buffer_can_t_be_read ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . clear ( ) [EOL] with self . assertRaisesWithMessage ( BaseException ) : [EOL] buf . read ( ) [EOL] [EOL] def test_clear_frees_up_capacity_for_another_write ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . clear ( ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_clear_does_nothing_on_empty_buffer ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . clear ( ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_overwrite_acts_like_write_on_non_full_buffer ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . overwrite ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_overwrite_replaces_the_oldest_item_on_full_buffer ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] buf . overwrite ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_overwrite_replaces_the_oldest_item_remaining_in_buffer_following_a_read ( self , ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] buf . write ( [string] ) [EOL] buf . overwrite ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] [EOL] def test_initial_clear_does_not_affect_wrapping_around ( self ) : [EOL] buf = CircularBuffer ( [number] ) [EOL] buf . clear ( ) [EOL] buf . write ( [string] ) [EOL] buf . write ( [string] ) [EOL] buf . overwrite ( [string] ) [EOL] buf . overwrite ( [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] self . assertEqual ( buf . read ( ) , [string] ) [EOL] with self . assertRaisesWithMessage ( BaseException ) : [EOL] buf . read ( ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from sgf_parsing import SgfTree , parse [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SgfParsingTest ( unittest . TestCase ) : [EOL] def test_empty_input ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_tree_with_no_nodes ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_node_without_tree ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_node_without_properties ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_single_node_tree ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] ] } ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_multiple_properties ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] ] , [string] : [ [string] ] } ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_properties_without_delimiter ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_all_lowercase_property ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_upper_and_lowercase_property ( self ) : [EOL] input_string = [string] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] parse ( input_string ) [EOL] [EOL] def test_two_nodes ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] ] } , children = [ SgfTree ( { [string] : [ [string] ] } ) ] ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_two_child_trees ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] ] } , children = [ SgfTree ( { [string] : [ [string] ] } ) , SgfTree ( { [string] : [ [string] ] } ) ] , ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_multiple_property_values ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] , [string] , [string] ] } ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] def test_escaped_property ( self ) : [EOL] input_string = [string] [EOL] expected = SgfTree ( properties = { [string] : [ [string] ] } ) [EOL] self . assertEqual ( parse ( input_string ) , expected ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Tuple , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Set , Tuple [EOL] [EOL] [EOL] def triplets_with_sum ( sum_of_triplet ) : [EOL] [docstring] [EOL] triplet = [ ] [EOL] for a in range ( [number] , sum_of_triplet // [number] ) : [EOL] b = ( sum_of_triplet ** [number] - [number] * sum_of_triplet * a ) // ( [number] * ( sum_of_triplet - a ) ) [EOL] c = sum_of_triplet - a - b [EOL] if a ** [number] + b ** [number] == c ** [number] : [EOL] triplet . append ( ( min ( a , b ) , max ( a , b ) , c ) ) [EOL] return [ list ( unique_triplet ) for unique_triplet in set ( triplet ) ] [EOL] [EOL] [EOL] def is_triplet ( triplet ) : [EOL] [docstring] [EOL] return triplet [ [number] ] ** [number] + triplet [ [number] ] ** [number] == triplet [ [number] ] ** [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] class Board : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , board ) : [EOL] pass [EOL] [EOL] def territory ( self , x , y ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] def territories ( self ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from largest_series_product import largest_product [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class LargestSeriesProductTest ( unittest . TestCase ) : [EOL] def test_finds_the_largest_product_if_span_equals_length ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_find_the_largest_product_of_2_with_numbers_in_order ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_find_the_largest_product_of_2 ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_find_the_largest_product_of_3_with_numbers_in_order ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_find_the_largest_product_of_3 ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_find_the_largest_product_of_5_with_numbers_in_order ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_can_get_the_largest_product_of_a_big_number ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] , ) [EOL] [EOL] def test_reports_zero_if_the_only_digits_are_zero ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_reports_zero_if_all_spans_include_zero ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_rejects_span_longer_than_string_length ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] largest_product ( [string] , [number] ) [EOL] [EOL] def test_reports_1_for_empty_string_and_empty_product_0_span ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_reports_1_for_nonempty_string_and_empty_product_0_span ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] ) , [number] ) [EOL] [EOL] def test_rejects_empty_string_and_nonzero_span ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] largest_product ( [string] , [number] ) [EOL] [EOL] def test_rejects_invalid_character_in_digits ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] largest_product ( [string] , [number] ) [EOL] [EOL] def test_rejects_negative_span ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] largest_product ( [string] , - [number] ) [EOL] [EOL] [comment] [EOL] def test_euler_big_number ( self ) : [EOL] self . assertEqual ( largest_product ( [string] , [number] , ) , [number] , ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from functools import reduce [EOL] from operator import mul [EOL] [EOL] [EOL] def largest_product ( series , size ) : [EOL] if size == [number] : [EOL] return [number] [EOL] if size < [number] : [EOL] raise ValueError ( [string] ) [EOL] return max ( [ reduce ( mul , [ int ( x ) for x in series [ i : i + size ] ] , [number] ) for i in range ( len ( series ) - size + [number] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def spiral_matrix ( size ) : [EOL] if size == [number] : [EOL] return [ ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from spiral_matrix import spiral_matrix [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SpiralMatrixTest ( unittest . TestCase ) : [EOL] def test_empty_spiral ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ ] ) [EOL] [EOL] def test_trivial_spiral ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ [ [number] ] ] ) [EOL] [EOL] def test_spiral_of_size_2 ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] def test_spiral_of_size_3 ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] ) [EOL] [EOL] def test_spiral_of_size_4 ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ] , ) [EOL] [EOL] def test_spiral_of_size_5 ( self ) : [EOL] self . assertEqual ( spiral_matrix ( [number] ) , [ [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] ] , ] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Union , Any , List [EOL] import builtins [EOL] import typing [EOL] import react [EOL] import functools [EOL] [docstring] [EOL] [EOL] [EOL] from functools import partial [EOL] from typing import Callable , List , Union [EOL] [EOL] [EOL] class InputCell ( object ) : [EOL] def __init__ ( self , initial_value ) : [EOL] [docstring] [EOL] self . _value = initial_value [EOL] self . observers = [ ] [EOL] self . updated = True [EOL] [EOL] @ property def value ( self ) : [EOL] return self . _value [EOL] [EOL] @ value . setter def value ( self , value ) : [EOL] self . _value = value [EOL] for observer in self . observers : [EOL] observer . updated = False [EOL] for observer in self . observers : [EOL] observer . update_value ( ) [EOL] [EOL] def register_observer ( self , observer ) : [EOL] [docstring] [EOL] self . observers . append ( observer ) [EOL] [EOL] [EOL] class ComputeCell ( InputCell ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , inputs , compute_function , ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( None ) [EOL] self . inputs = inputs [EOL] self . compute_function = compute_function [EOL] for cell in self . inputs : [EOL] cell . register_observer ( self ) [EOL] self . value = compute_function ( [ input . value for input in self . inputs ] ) [EOL] self . callbacks = [ ] [EOL] [EOL] def update_value ( self ) : [EOL] [docstring] [EOL] if all ( [ input . updated for input in self . inputs ] ) : [EOL] self . updated = True [EOL] old_value = self . value [EOL] self . value = self . compute_function ( [ input . value for input in self . inputs ] ) [EOL] for observer in self . observers : [EOL] observer . update_value ( ) [EOL] if old_value != self . value : [EOL] for callback in self . callbacks : [EOL] callback ( self . value ) [EOL] [EOL] def add_callback ( self , callback ) : [EOL] [docstring] [EOL] self . callbacks . append ( callback ) [EOL] [EOL] def remove_callback ( self , callback ) : [EOL] [docstring] [EOL] if callback in self . callbacks : [EOL] self . callbacks . remove ( callback ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"ComputeCell"$ 0 0 0 0 0 0 0 0 0 0 0 $"ComputeCell"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[typing.List[react.react.ComputeCell],typing.List[react.react.InputCell]]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[react.react.ComputeCell],typing.List[react.react.InputCell]]$ 0 $typing.Union[typing.List[react.react.ComputeCell],typing.List[react.react.InputCell]]$ 0 0 0 $typing.Callable[...,typing.Any]$ 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 $typing.Union[typing.List[react.react.ComputeCell],typing.List[react.react.InputCell]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Callable[...,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[react.react.ComputeCell],typing.List[react.react.InputCell]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $functools.partial$ 0 0 0 0 0 0 0 0 0 0 0 $functools.partial$ 0 0 0 0 $None$ 0 0 0 $functools.partial$ 0 0 0 0 0 0 $functools.partial$ 0 0 0 0 0 0 0 0 0 0 0 0 $functools.partial$ 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] from functools import partial [EOL] [EOL] from react import ComputeCell , InputCell [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ReactTest ( unittest . TestCase ) : [EOL] def test_input_cells_have_a_value ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] self . assertEqual ( input_ . value , [number] ) [EOL] [EOL] def test_can_set_input_cell_value ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( input_ . value , [number] ) [EOL] [EOL] def test_compute_cells_calculate_initial_value ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] self . assertEqual ( output . value , [number] ) [EOL] [EOL] def test_compute_cells_take_inputs_in_right_order ( self ) : [EOL] one = InputCell ( [number] ) [EOL] two = InputCell ( [number] ) [EOL] output = ComputeCell ( [ one , two ] , lambda inputs : inputs [ [number] ] + inputs [ [number] ] * [number] ) [EOL] self . assertEqual ( output . value , [number] ) [EOL] [EOL] def test_compute_cells_update_value_when_dependencies_are_changed ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] [EOL] input_ . value = [number] [EOL] self . assertEqual ( output . value , [number] ) [EOL] [EOL] def test_compute_cells_can_depend_on_other_compute_cells ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] times_two = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] * [number] ) [EOL] times_thirty = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] * [number] ) [EOL] output = ComputeCell ( [ times_two , times_thirty ] , lambda inputs : inputs [ [number] ] + inputs [ [number] ] ) [EOL] [EOL] self . assertEqual ( output . value , [number] ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( output . value , [number] ) [EOL] [EOL] def test_compute_cells_fire_callbacks ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] [EOL] observer = [ ] [EOL] callback1 = self . callback_factory ( observer ) [EOL] output . add_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_only_fire_on_change ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : [number] if inputs [ [number] ] < [number] else [number] ) [EOL] [EOL] observer = [ ] [EOL] callback1 = self . callback_factory ( observer ) [EOL] [EOL] output . add_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer , [ ] ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_do_not_report_already_reported_values ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] [EOL] observer = [ ] [EOL] callback1 = self . callback_factory ( observer ) [EOL] [EOL] output . add_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer [ - [number] ] , [number] ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_can_fire_from_multiple_cells ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] plus_one = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] minus_one = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] - [number] ) [EOL] [EOL] cb1_observer , cb2_observer = [ ] , [ ] [EOL] callback1 = self . callback_factory ( cb1_observer ) [EOL] callback2 = self . callback_factory ( cb2_observer ) [EOL] [EOL] plus_one . add_callback ( callback1 ) [EOL] minus_one . add_callback ( callback2 ) [EOL] input_ . value = [number] [EOL] [EOL] self . assertEqual ( cb1_observer [ - [number] ] , [number] ) [EOL] self . assertEqual ( cb2_observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_can_be_added_and_removed ( self ) : [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] [EOL] cb1_observer , cb2_observer , cb3_observer = [ ] , [ ] , [ ] [EOL] callback1 = self . callback_factory ( cb1_observer ) [EOL] callback2 = self . callback_factory ( cb2_observer ) [EOL] callback3 = self . callback_factory ( cb3_observer ) [EOL] [EOL] output . add_callback ( callback1 ) [EOL] output . add_callback ( callback2 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( cb1_observer [ - [number] ] , [number] ) [EOL] self . assertEqual ( cb2_observer [ - [number] ] , [number] ) [EOL] [EOL] output . remove_callback ( callback1 ) [EOL] output . add_callback ( callback3 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( cb2_observer [ - [number] ] , [number] ) [EOL] self . assertEqual ( cb3_observer [ - [number] ] , [number] ) [EOL] [EOL] [comment] [EOL] self . assertEqual ( len ( cb1_observer ) , [number] ) [EOL] [EOL] def test_removing_a_callback_multiple_times ( self ) : [EOL] [docstring] [EOL] input_ = InputCell ( [number] ) [EOL] output = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] [EOL] cb1_observer , cb2_observer = [ ] , [ ] [EOL] callback1 = self . callback_factory ( cb1_observer ) [EOL] callback2 = self . callback_factory ( cb2_observer ) [EOL] [EOL] output . add_callback ( callback1 ) [EOL] output . add_callback ( callback2 ) [EOL] output . remove_callback ( callback1 ) [EOL] output . remove_callback ( callback1 ) [EOL] output . remove_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] [EOL] self . assertEqual ( cb1_observer , [ ] ) [EOL] self . assertEqual ( cb2_observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_should_only_be_called_once ( self ) : [EOL] [docstring] [EOL] input_ = InputCell ( [number] ) [EOL] plus_one = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] minus_one1 = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] - [number] ) [EOL] minus_one2 = ComputeCell ( [ minus_one1 ] , lambda inputs : inputs [ [number] ] - [number] ) [EOL] output = ComputeCell ( [ plus_one , minus_one2 ] , lambda inputs : inputs [ [number] ] * inputs [ [number] ] ) [EOL] [EOL] observer = [ ] [EOL] callback1 = self . callback_factory ( observer ) [EOL] [EOL] output . add_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer [ - [number] ] , [number] ) [EOL] [EOL] def test_callbacks_not_called_so_long_as_output_not_changed ( self ) : [EOL] [docstring] [EOL] input_ = InputCell ( [number] ) [EOL] plus_one = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] + [number] ) [EOL] minus_one = ComputeCell ( [ input_ ] , lambda inputs : inputs [ [number] ] - [number] ) [EOL] always_two = ComputeCell ( [ plus_one , minus_one ] , lambda inputs : inputs [ [number] ] - inputs [ [number] ] ) [EOL] [EOL] observer = [ ] [EOL] callback1 = self . callback_factory ( observer ) [EOL] [EOL] always_two . add_callback ( callback1 ) [EOL] input_ . value = [number] [EOL] input_ . value = [number] [EOL] input_ . value = [number] [EOL] input_ . value = [number] [EOL] self . assertEqual ( observer , [ ] ) [EOL] [EOL] [comment] [EOL] def callback_factory ( self , observer ) : [EOL] def callback ( observer , value ) : [EOL] observer . append ( value ) [EOL] [EOL] return partial ( callback , observer ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator [EOL] import typing [EOL] import unittest [EOL] [EOL] from linked_list import LinkedList [EOL] [EOL] [EOL] class LinkedListTest ( unittest . TestCase ) : [EOL] def test_push_pop ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . push ( [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] [EOL] def test_push_shift ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . push ( [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] [EOL] def test_unshift_shift ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . unshift ( [number] ) [EOL] lst . unshift ( [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] [EOL] def test_unshift_pop ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . unshift ( [number] ) [EOL] lst . unshift ( [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] [EOL] def test_all ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . push ( [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] lst . unshift ( [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] self . assertEqual ( lst . pop ( ) , [number] ) [EOL] self . assertEqual ( lst . shift ( ) , [number] ) [EOL] [EOL] [comment] [EOL] def test_length ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . push ( [number] ) [EOL] lst . push ( [number] ) [EOL] self . assertEqual ( len ( lst ) , [number] ) [EOL] lst . shift ( ) [EOL] self . assertEqual ( len ( lst ) , [number] ) [EOL] lst . pop ( ) [EOL] self . assertEqual ( len ( lst ) , [number] ) [EOL] [EOL] [comment] [EOL] def test_iterator ( self ) : [EOL] lst = LinkedList ( ) [EOL] lst . push ( [number] ) [EOL] lst . push ( [number] ) [EOL] iterator = iter ( lst ) [EOL] self . assertEqual ( next ( iterator ) , [number] ) [EOL] self . assertEqual ( next ( iterator ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import list [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Optional [EOL] [EOL] [EOL] class Node ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , value , succeeding = None , previous = None , ) : [EOL] [docstring] [EOL] self . value = value [EOL] self . succeeding = succeeding [EOL] self . previous = previous [EOL] [EOL] [EOL] class LinkedList ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . head = None [EOL] self . tail = None [EOL] self . node = None [EOL] [EOL] def push ( self , value ) : [EOL] [docstring] [EOL] node = Node ( value , None , self . tail ) [EOL] if self . tail : [EOL] self . tail . succeeding = node [EOL] self . tail = node [EOL] if not self . head : [EOL] self . head = self . tail [EOL] [EOL] def unshift ( self , value ) : [EOL] [docstring] [EOL] node = Node ( value , self . head , None ) [EOL] if self . head : [EOL] self . head . previous = node [EOL] self . head = node [EOL] if not self . tail : [EOL] self . tail = self . head [EOL] [EOL] def pop ( self ) : [EOL] [docstring] [EOL] value = self . tail . value [EOL] self . tail = self . tail . previous [EOL] if self . tail : [EOL] self . tail . succeeding = None [EOL] else : [EOL] self . head = None [EOL] return value [EOL] [EOL] def shift ( self ) : [EOL] [docstring] [EOL] value = self . head . value [EOL] self . head = self . head . succeeding [EOL] if self . head : [EOL] self . head . previous = None [EOL] else : [EOL] self . tail = None [EOL] return value [EOL] [EOL] def __len__ ( self ) : [EOL] [docstring] [EOL] node = self . head [EOL] count = [number] [EOL] while node is not None : [EOL] count = count + [number] [EOL] node = node . succeeding [EOL] return count [EOL] [EOL] def __iter__ ( self ) : [EOL] [docstring] [EOL] node = self . head [EOL] while node : [EOL] yield node . value [EOL] node = node . succeeding [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from flatten_array import flatten [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class FlattenArrayTest ( unittest . TestCase ) : [EOL] def test_no_nesting ( self ) : [EOL] inputs = [ [number] , [number] , [number] ] [EOL] expected = [ [number] , [number] , [number] ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] def test_flattens_array_with_just_integers_present ( self ) : [EOL] inputs = [ [number] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ] [EOL] expected = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] def test_5_level_nesting ( self ) : [EOL] inputs = [ [number] , [number] , [ [ [number] , [number] ] , [number] , [number] , [number] , [ [ [ [number] ] ] ] ] , - [number] ] [EOL] expected = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , - [number] ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] def test_6_level_nesting ( self ) : [EOL] inputs = [ [number] , [ [number] , [ [ [number] ] ] , [ [number] , [ [ [number] ] ] ] , [number] , [number] ] , [number] ] [EOL] expected = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] def test_6_level_nest_list_with_null_values ( self ) : [EOL] inputs = [ [number] , [number] , [ [ [number] , [number] ] , [number] , [ [ [number] ] ] , None , [ [ None ] ] ] , - [number] ] [EOL] expected = [ [number] , [number] , [number] , [number] , [number] , [number] , - [number] ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] def test_all_values_in_nested_list_are_null ( self ) : [EOL] inputs = [ None , [ [ [ None ] ] ] , None , None , [ [ None , None ] , None ] , None ] [EOL] expected = [ ] [EOL] self . assertEqual ( flatten ( inputs ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.int],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[builtins.int],builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[typing.List[typing.List[typing.List[builtins.int]]],typing.List[builtins.int],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[typing.List[typing.List[typing.List[builtins.int]]],typing.List[builtins.int],builtins.int]],builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[typing.List[typing.List[builtins.int]],typing.List[typing.Union[typing.List[typing.List[builtins.int]],builtins.int]],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[typing.List[typing.List[builtins.int]],typing.List[typing.Union[typing.List[typing.List[builtins.int]],builtins.int]],builtins.int]],builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[None,typing.List[typing.List[None]],typing.List[typing.List[builtins.int]],typing.List[builtins.int],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.List[typing.Union[None,typing.List[typing.List[None]],typing.List[typing.List[builtins.int]],typing.List[builtins.int],builtins.int]],builtins.int]]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.List[typing.List[typing.List[None]]],typing.List[typing.Optional[typing.List[None]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.List[typing.List[typing.List[None]]],typing.List[typing.Optional[typing.List[None]]]]]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from collections . abc import Iterable [EOL] from typing import Any , List , Union [EOL] [EOL] [EOL] def flatten ( iterable ) : [EOL] [docstring] [EOL] if isinstance ( iterable , Iterable ) and not isinstance ( iterable , str ) : [EOL] return [ a for i in iterable for a in flatten ( i ) if a is not None ] [EOL] return [ iterable ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from reverse_string import reverse [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ReverseStringTest ( unittest . TestCase ) : [EOL] def test_an_empty_string ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] def test_a_word ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] def test_a_capitalized_word ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] def test_a_sentence_with_punctuation ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] def test_a_palindrome ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] def test_an_even_sized_word ( self ) : [EOL] self . assertEqual ( reverse ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def reverse ( text ) : [EOL] return text [ : : - [number] ] [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from pangram import is_pangram [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PangramTest ( unittest . TestCase ) : [EOL] def test_empty_sentence ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] def test_perfect_lower_case ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , True ) [EOL] [EOL] def test_only_lower_case ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , True ) [EOL] [EOL] def test_missing_the_letter_x ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False , ) [EOL] [EOL] def test_missing_the_letter_h ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] def test_with_underscores ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , True ) [EOL] [EOL] def test_with_numbers ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , True ) [EOL] [EOL] def test_missing_letters_replaced_by_numbers ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] def test_mixed_case_and_punctuation ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , True ) [EOL] [EOL] def test_case_insensitive ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] [comment] [EOL] [EOL] def test_sentence_without_lower_bound ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] def test_sentence_without_upper_bound ( self ) : [EOL] self . assertIs ( is_pangram ( [string] ) , False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import string [EOL] [EOL] [EOL] def is_pangram ( sentence ) : [EOL] return set ( string . ascii_lowercase ) . issubset ( sentence . lower ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from rectangles import rectangles [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RectanglesTest ( unittest . TestCase ) : [EOL] def test_no_rows ( self ) : [EOL] self . assertEqual ( rectangles ( [ ] ) , [number] ) [EOL] [EOL] def test_no_columns ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] ] ) , [number] ) [EOL] [EOL] def test_no_rectangles ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] ] ) , [number] ) [EOL] [EOL] def test_one_rectangle ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_two_rectangles_without_shared_parts ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_five_rectangles_with_shared_parts ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_rectangle_of_height_1_is_counted ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_rectangle_of_width_1_is_counted ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_1x1_square_is_counted ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_only_complete_rectangles_are_counted ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_rectangles_can_be_of_different_sizes ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] , ] ) , [number] , ) [EOL] [EOL] def test_corner_is_required_for_a_rectangle_to_be_complete ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] , ] ) , [number] , ) [EOL] [EOL] def test_large_input_with_many_rectangles ( self ) : [EOL] self . assertEqual ( rectangles ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) , [number] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from crypto_square import cipher_text [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class CryptoSquareTest ( unittest . TestCase ) : [EOL] def test_empty_plaintext_results_in_an_empty_ciphertext ( self ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_lowercase ( self ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_remove_spaces ( self ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_remove_punctuation ( self ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_9_character_plaintext_results_in_3_chunks_of_3_characters ( self ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_8_character_plaintext_results_in_3_chunks_the_last_one_with_a_trailing_space ( self , ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] def test_54_character_plaintext_results_in_7_chunks_the_last_two_with_trailing_spaces ( self , ) : [EOL] value = [string] [EOL] expected = [string] [EOL] self . assertEqual ( cipher_text ( value ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import math [EOL] import re [EOL] [EOL] [EOL] def cipher_text ( plain_text ) : [EOL] [docstring] [EOL] if not plain_text : [EOL] return [string] [EOL] pattern = re . compile ( [string] , re . UNICODE ) [EOL] clean_text = pattern . sub ( [string] , plain_text . lower ( ) ) [EOL] [EOL] sqr = math . sqrt ( len ( clean_text ) ) [EOL] rows = math . ceil ( sqr ) [EOL] columns = round ( sqr ) [EOL] return [string] . join ( f"{ row : [string] { columns }}" for row in ( clean_text [ i : : rows ] for i in range ( rows ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def leap_year ( year ) : [EOL] return year % [number] == [number] and ( year % [number] != [number] or year % [number] == [number] ) [EOL]	0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from leap import leap_year [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class LeapTest ( unittest . TestCase ) : [EOL] def test_year_not_divisible_by_4_in_common_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , False ) [EOL] [EOL] def test_year_divisible_by_2_not_divisible_by_4_in_common_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , False ) [EOL] [EOL] def test_year_divisible_by_4_not_divisible_by_100_in_leap_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , True ) [EOL] [EOL] def test_year_divisible_by_4_and_5_is_still_a_leap_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , True ) [EOL] [EOL] def test_year_divisible_by_100_not_divisible_by_400_in_common_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , False ) [EOL] [EOL] def test_year_divisible_by_100_but_not_by_3_is_still_not_a_leap_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , False ) [EOL] [EOL] def test_year_divisible_by_400_in_leap_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , True ) [EOL] [EOL] def test_year_divisible_by_400_but_not_by_125_is_still_a_leap_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , True ) [EOL] [EOL] def test_year_divisible_by_200_not_divisible_by_400_in_common_year ( self ) : [EOL] self . assertIs ( leap_year ( [number] ) , False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import json [EOL] from typing import Dict , List , Optional , Union [EOL] [EOL] [EOL] class RestAPI : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , database ) : [EOL] [docstring] [EOL] self . database = { user [ [string] ] : user for user in database [ [string] ] } [EOL] [EOL] def get ( self , url , payload = None ) : [EOL] [docstring] [EOL] if url != [string] : [EOL] raise ValueError ( [string] ) [EOL] if not payload : [EOL] return json . dumps ( { [string] : [ data for user , data in self . database . items ( ) ] } ) [EOL] payload = json . loads ( payload ) [EOL] return json . dumps ( { [string] : self . get_users ( payload [ [string] ] ) } ) [EOL] [EOL] def post ( self , url , payload = None ) : [EOL] [docstring] [EOL] payload = json . loads ( payload ) [EOL] if url == [string] : [EOL] user = { [string] : payload [ [string] ] , [string] : { } , [string] : { } , [string] : [number] } [EOL] self . database [ payload [ [string] ] ] = user [EOL] return json . dumps ( user ) [EOL] if url == [string] : [EOL] lender , borrower = payload [ [string] ] , payload [ [string] ] [EOL] new_balance = ( payload [ [string] ] + self . database [ lender ] [ [string] ] . setdefault ( borrower , [number] ) - self . database [ lender ] [ [string] ] . setdefault ( borrower , [number] ) ) [EOL] self . database [ lender ] [ [string] ] += payload [ [string] ] [EOL] self . database [ borrower ] [ [string] ] -= payload [ [string] ] [EOL] self . cleanup ( lender , borrower ) [EOL] if new_balance > [number] : [EOL] self . database [ lender ] [ [string] ] [ borrower ] = new_balance [EOL] self . database [ borrower ] [ [string] ] [ lender ] = new_balance [EOL] if new_balance < [number] : [EOL] self . database [ lender ] [ [string] ] [ borrower ] = - new_balance [EOL] self . database [ borrower ] [ [string] ] [ lender ] = - new_balance [EOL] return json . dumps ( { [string] : self . get_users ( sorted ( [ lender , borrower ] ) ) } ) [EOL] raise ValueError ( [string] ) [EOL] [EOL] def get_users ( self , users ) : [EOL] [docstring] [EOL] return [ self . database [ user ] for user in users ] [EOL] [EOL] def cleanup ( self , lender , borrower ) : [EOL] [docstring] [EOL] self . database [ lender ] [ [string] ] . pop ( borrower , None ) [EOL] self . database [ lender ] [ [string] ] . pop ( borrower , None ) [EOL] self . database [ borrower ] [ [string] ] . pop ( lender , None ) [EOL] self . database [ borrower ] [ [string] ] . pop ( lender , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Dict[builtins.str,typing.Union[builtins.str,builtins.float]]],typing.List[typing.Dict[builtins.str,typing.Union[builtins.str,typing.Dict[builtins.str,builtins.float],builtins.float]]],]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
[comment] [EOL] from typing import Union , Any , List , Dict [EOL] import typing [EOL] import json [EOL] import unittest [EOL] [EOL] from rest_api import RestAPI [EOL] [EOL] [EOL] class RestApiTest ( unittest . TestCase ) : [EOL] def test_no_users ( self ) : [EOL] database = { [string] : [ ] } [EOL] api = RestAPI ( database ) [EOL] [EOL] response = api . get ( [string] ) [EOL] expected = { [string] : [ ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_add_user ( self ) : [EOL] database = { [string] : [ ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_get_single_user ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [ [string] ] } ) [EOL] response = api . get ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_both_users_have_0_balance ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_borrower_has_negative_balance ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , { [string] : [string] , [string] : { [string] : [number] , [string] : [number] } , [string] : { } , [string] : - [number] , } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_lender_has_negative_balance ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { [string] : [number] } , [string] : { [string] : [number] } , [string] : [number] , } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_lender_owes_borrower ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_lender_owes_borrower_less_than_new_loan ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] def test_lender_owes_borrower_same_as_new_loan ( self ) : [EOL] database = { [string] : [ { [string] : [string] , [string] : { [string] : [number] } , [string] : { } , [string] : - [number] } , { [string] : [string] , [string] : { } , [string] : { [string] : [number] } , [string] : [number] } , ] } [EOL] api = RestAPI ( database ) [EOL] payload = json . dumps ( { [string] : [string] , [string] : [string] , [string] : [number] } ) [EOL] response = api . post ( [string] , payload ) [EOL] expected = { [string] : [ { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , { [string] : [string] , [string] : { } , [string] : { } , [string] : [number] } , ] } [EOL] self . assertDictEqual ( json . loads ( response ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Any]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,builtins.float],builtins.float,builtins.str]]]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.float,builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] HOUSE_1 = ( [string] , [string] , [string] , [string] , [string] ) [EOL] HOUSE_2 = ( [string] , [string] , [string] , [string] , [string] ) [EOL] HOUSE_3 = ( [string] , [string] , [string] , [string] , [string] ) [EOL] HOUSE_4 = ( [string] , [string] , [string] , [string] , [string] ) [EOL] HOUSE_5 = ( [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] [EOL] def drinks_water ( ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] def owns_zebra ( ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from darts import score [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DartsTest ( unittest . TestCase ) : [EOL] def test_missed_target ( self ) : [EOL] self . assertEqual ( score ( - [number] , [number] ) , [number] ) [EOL] [EOL] def test_on_the_outer_circle ( self ) : [EOL] self . assertEqual ( score ( [number] , [number] ) , [number] ) [EOL] [EOL] def test_on_the_middle_circle ( self ) : [EOL] self . assertEqual ( score ( - [number] , [number] ) , [number] ) [EOL] [EOL] def test_on_the_inner_circle ( self ) : [EOL] self . assertEqual ( score ( [number] , - [number] ) , [number] ) [EOL] [EOL] def test_exactly_on_centre ( self ) : [EOL] self . assertEqual ( score ( [number] , [number] ) , [number] ) [EOL] [EOL] def test_near_the_centre ( self ) : [EOL] self . assertEqual ( score ( - [number] , - [number] ) , [number] ) [EOL] [EOL] def test_just_within_the_inner_circle ( self ) : [EOL] self . assertEqual ( score ( [number] , [number] ) , [number] ) [EOL] [EOL] def test_just_outside_the_inner_circle ( self ) : [EOL] self . assertEqual ( score ( [number] , - [number] ) , [number] ) [EOL] [EOL] def test_just_within_the_middle_circle ( self ) : [EOL] self . assertEqual ( score ( - [number] , [number] ) , [number] ) [EOL] [EOL] def test_just_outside_the_middle_circle ( self ) : [EOL] self . assertEqual ( score ( - [number] , - [number] ) , [number] ) [EOL] [EOL] def test_just_within_the_outer_circle ( self ) : [EOL] self . assertEqual ( score ( - [number] , [number] ) , [number] ) [EOL] [EOL] def test_just_outside_the_outer_circle ( self ) : [EOL] self . assertEqual ( score ( [number] , - [number] ) , [number] ) [EOL] [EOL] def test_asymmetric_position_between_the_inner_and_middle_circles ( self ) : [EOL] self . assertEqual ( score ( [number] , - [number] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union [EOL] import typing [EOL] import builtins [EOL] import math [EOL] from typing import Union [EOL] [EOL] [EOL] def score ( x , y ) : [EOL] distance = math . sqrt ( x * x + y * y ) [EOL] if distance > [number] : [EOL] return [number] [EOL] if distance > [number] : [EOL] return [number] [EOL] if distance > [number] : [EOL] return [number] [EOL] return [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from connect import ConnectGame [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ConnectTest ( unittest . TestCase ) : [EOL] def test_an_empty_board_has_no_winner ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_x_can_win_on_a_1x1_board ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_o_can_win_on_a_1x1_board ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_only_edges_does_not_make_a_winner ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_illegal_diagonal_does_not_make_a_winner ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_nobody_wins_crossing_adjacent_angles ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_x_wins_crossing_from_left_to_right ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_o_wins_crossing_from_top_to_bottom ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_x_wins_using_a_convoluted_path ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] def test_x_wins_using_a_spiral_path ( self ) : [EOL] game = ConnectGame ( [string] ) [EOL] winner = game . get_winner ( ) [EOL] self . assertEqual ( winner , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class ConnectGame : [EOL] def __init__ ( self , board ) : [EOL] self . board = [ line . split ( ) for line in board . split ( [string] ) ] [EOL] self . board_length = len ( self . board ) [EOL] [EOL] def get_winner ( self ) : [EOL] if [string] not in self . board [ [number] ] and [string] not in [ line [ [number] ] for line in self . board ] : [EOL] return [string] [EOL] return [string] [EOL] [EOL] def check_if_0_win ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import pov [EOL] from json import dumps [EOL] from typing import List [EOL] [EOL] [EOL] class Tree ( object ) : [EOL] def __init__ ( self , label , children = [ ] ) : [EOL] self . label = label [EOL] self . children = children [EOL] [EOL] def __dict__ ( self ) : [EOL] return { self . label : [ c . __dict__ ( ) for c in sorted ( self . children ) ] } [EOL] [EOL] def __str__ ( self , indent = None ) : [EOL] return dumps ( self . __dict__ ( ) , indent = indent ) [EOL] [EOL] def __lt__ ( self , other ) : [EOL] return self . label < other . label [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . __dict__ ( ) == other . __dict__ ( ) [EOL] [EOL] def from_pov ( self , from_node ) : [EOL] [EOL] path = self . path_from_root ( from_node , [ self . label ] ) [EOL] print ( path ) [EOL] if path == [ [string] ] : [EOL] return self [EOL] [EOL] return None [EOL] [EOL] def path_to ( self , from_node , to_node ) : [EOL] pass [EOL] [EOL] def path_from_root ( self , to_node , path ) : [EOL] [EOL] for child in self . children : [EOL] if child . label == to_node : [EOL] return path + [ to_node ] [EOL] return self . path_from_root ( child . label , path + [ to_node ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from pov import Tree [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PovTest ( unittest . TestCase ) : [EOL] def test_results_in_the_same_tree_if_the_input_tree_is_a_singleton ( self ) : [EOL] tree = Tree ( [string] ) [EOL] expected = Tree ( [string] ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_can_reroot_a_tree_with_a_parent_and_one_sibling ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] expected = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) ] ) ] ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_can_reroot_a_tree_with_a_parent_and_many_siblings ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] expected = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) ] ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_can_reroot_a_tree_with_new_root_deeply_nested_in_tree ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) ] ) ] ) ] ) ] , ) [EOL] expected = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) ] ) ] ) ] ) ] , ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_moves_children_of_the_new_root_to_same_level_as_former_parent ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) ] ) [EOL] expected = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_can_reroot_a_complex_tree_with_cousins ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , Tree ( [string] ) , Tree ( [string] ) , ] , ) , Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , ] , ) [EOL] expected = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) ] , ) , ] , ) , ] , ) [EOL] self . assertTreeEquals ( tree . from_pov ( [string] ) , expected ) [EOL] [EOL] def test_errors_if_target_does_not_exist_in_a_singleton_tree ( self ) : [EOL] tree = Tree ( [string] ) [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree . from_pov ( [string] ) [EOL] [EOL] def test_errors_if_target_does_not_exist_in_a_large_tree ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , Tree ( [string] ) , Tree ( [string] ) , ] , ) [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree . from_pov ( [string] ) [EOL] [EOL] def test_can_find_path_to_parent ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( tree . path_to ( [string] , [string] ) , expected ) [EOL] [EOL] def test_can_find_path_to_sibling ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( tree . path_to ( [string] , [string] ) , expected ) [EOL] [EOL] def test_can_find_path_to_cousin ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , Tree ( [string] ) , Tree ( [string] ) , ] , ) , Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , ] , ) [EOL] expected = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( tree . path_to ( [string] , [string] ) , expected ) [EOL] [EOL] def test_can_find_path_not_involving_root ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) ] , ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( tree . path_to ( [string] , [string] ) , expected ) [EOL] [EOL] def test_can_find_path_from_nodes_other_than_x ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) , Tree ( [string] ) ] ) [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( tree . path_to ( [string] , [string] ) , expected ) [EOL] [EOL] def test_errors_if_destination_does_not_exist ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , Tree ( [string] ) , Tree ( [string] ) , ] , ) [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree . path_to ( [string] , [string] ) [EOL] [EOL] def test_errors_if_source_does_not_exist ( self ) : [EOL] tree = Tree ( [string] , [ Tree ( [string] , [ Tree ( [string] ) , Tree ( [string] ) ] ) , Tree ( [string] ) , Tree ( [string] ) , ] , ) [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree . path_to ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] def assertTreeEquals ( self , result , expected ) : [EOL] self . assertEqual ( result , expected , [string] . format ( result , expected ) ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from tree_building import BuildTree , Record [EOL] [EOL] [EOL] class TreeBuildingTest ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def test_empty_list_input ( self ) : [EOL] records = [ ] [EOL] root = BuildTree ( records ) [EOL] self . assertIsNone ( root ) [EOL] [EOL] def test_one_node ( self ) : [EOL] records = [ Record ( [number] , [number] ) ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_leaf ( root , node_id = [number] ) [EOL] [EOL] def test_three_nodes_in_order ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_branch ( root , node_id = [number] , children_count = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] [EOL] def test_three_nodes_in_reverse_order ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_branch ( root , node_id = [number] , children_count = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] [EOL] def test_more_than_two_children ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_branch ( root , node_id = [number] , children_count = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] , node_id = [number] ) [EOL] [EOL] def test_binary_tree ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_branch ( root , [number] , [number] ) [EOL] self . assert_node_is_branch ( root . children [ [number] ] , [number] , [number] ) [EOL] self . assert_node_is_branch ( root . children [ [number] ] , [number] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] [EOL] def test_unbalanced_tree ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , ] [EOL] root = BuildTree ( records ) [EOL] [EOL] self . assert_node_is_branch ( root , [number] , [number] ) [EOL] self . assert_node_is_branch ( root . children [ [number] ] , [number] , [number] ) [EOL] self . assert_node_is_branch ( root . children [ [number] ] , [number] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] self . assert_node_is_leaf ( root . children [ [number] ] . children [ [number] ] , [number] ) [EOL] [EOL] def test_root_node_has_parent ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def test_no_root_node ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def test_non_continuous ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def test_cycle_directly ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def test_cycle_indirectly ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) , ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def test_higher_id_parent_of_lower_id ( self ) : [EOL] records = [ Record ( [number] , [number] ) , Record ( [number] , [number] ) , Record ( [number] , [number] ) ] [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] BuildTree ( records ) [EOL] [EOL] def assert_node_is_branch ( self , node , node_id , children_count ) : [EOL] self . assertEqual ( node . node_id , node_id ) [EOL] self . assertNotEqual ( len ( node . children ) , [number] ) [EOL] self . assertEqual ( len ( node . children ) , children_count ) [EOL] [EOL] def assert_node_is_leaf ( self , node , node_id ) : [EOL] self . assertEqual ( node . node_id , node_id ) [EOL] self . assertEqual ( len ( node . children ) , [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , Optional [EOL] [EOL] [EOL] class Record : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , record_id , parent_id ) : [EOL] [docstring] [EOL] self . record_id = record_id [EOL] self . parent_id = parent_id [EOL] [EOL] [EOL] class Node : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node_id ) : [EOL] [docstring] [EOL] self . node_id = node_id [EOL] self . children = [ ] [EOL] [EOL] [EOL] def check_valid_record ( record ) : [EOL] [docstring] [EOL] if record . record_id == [number] and record . parent_id != [number] : [EOL] raise ValueError ( [string] ) [EOL] elif record . record_id < record . parent_id : [EOL] raise ValueError ( [string] ) [EOL] elif record . record_id == record . parent_id and record . record_id != [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def BuildTree ( records ) : [EOL] [docstring] [EOL] records . sort ( key = lambda x : x . record_id ) [EOL] if not records : [EOL] return None [EOL] if records [ - [number] ] . record_id != len ( records ) - [number] : [EOL] raise ValueError ( [string] ) [EOL] if records [ [number] ] . record_id != [number] : [EOL] raise ValueError ( [string] ) [EOL] trees = [ ] [EOL] for record in records : [EOL] check_valid_record ( record ) [EOL] trees . append ( Node ( record . record_id ) ) [EOL] if record . record_id > [number] : [EOL] trees [ record . parent_id ] . children . append ( trees [ record . record_id ] ) [EOL] return trees [ [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[Node]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def roman ( number ) : [EOL] [docstring] [EOL] val = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] syb = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] roman_number = [string] [EOL] i = [number] [EOL] while number > [number] : [EOL] for _ in range ( number // val [ i ] ) : [EOL] roman_number = roman_number + syb [ i ] [EOL] number = number - val [ i ] [EOL] i += [number] [EOL] return roman_number [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from roman_numerals import roman [EOL] [EOL] [EOL] [comment] [EOL] class RomanNumeralsTest ( unittest . TestCase ) : [EOL] def test_1_is_a_single_i ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_2_is_two_i_s ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_3_is_three_i_s ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_4_being_5_1_is_iv ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_5_is_a_single_v ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_6_being_5_1_is_vi ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_9_being_10_1_is_ix ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_20_is_two_x_s ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_48_is_not_50_2_but_rather_40_8 ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_49_is_not_40_5_4_but_rather_50_10_10_1 ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_50_is_a_single_l ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_90_being_100_10_is_xc ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_100_is_a_single_c ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_60_being_50_10_is_lx ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_400_being_500_100_is_cd ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_500_is_a_single_d ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_900_being_1000_100_is_cm ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_1000_is_a_single_m ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] def test_3000_is_three_m_s ( self ) : [EOL] self . assertEqual ( roman ( [number] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] from secrets import choice [EOL] from string import ascii_uppercase , digits [EOL] [EOL] [EOL] class Robot ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . name = self . generate_name ( ) [EOL] self . used_name = [ self . name ] [EOL] [EOL] def reset ( self ) : [EOL] while self . name in self . used_name : [EOL] self . name = self . generate_name ( ) [EOL] self . used_name . append ( self . name ) [EOL] [EOL] def generate_name ( self ) : [EOL] return [string] . join ( [ choice ( ascii_uppercase ) for i in range ( [number] ) ] + [ choice ( digits ) for i in range ( [number] ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List [EOL] import typing [EOL] import builtins [EOL] from typing import List , Union [EOL] [EOL] SUBLIST = [number] [EOL] SUPERLIST = [number] [EOL] EQUAL = [number] [EOL] UNEQUAL = [number] [EOL] [EOL] [EOL] def check_sublist ( sublist_ , lst ) : [EOL] [docstring] [EOL] if not isinstance ( sublist_ , list ) : [EOL] raise ValueError ( [string] ) [EOL] if not isinstance ( lst , list ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] sublist_len = len ( sublist_ ) [EOL] index = [number] [EOL] [EOL] if sublist_len > len ( lst ) : [EOL] return False [EOL] if sublist_len == [number] : [EOL] return True [EOL] for element in lst : [EOL] if element == sublist_ [ index ] : [EOL] index = index + [number] [EOL] if index == sublist_len : [EOL] return True [EOL] elif index > [number] and sublist_ [ index - [number] ] != element : [EOL] index = [number] [EOL] return False [EOL] [EOL] [EOL] def sublist ( first_list , second_list ) : [EOL] [docstring] [EOL] if first_list == second_list : [EOL] return EQUAL [EOL] [EOL] is_sublist = check_sublist ( first_list , second_list ) [EOL] is_superlist = check_sublist ( second_list , first_list ) [EOL] [EOL] if is_sublist : [EOL] return SUBLIST [EOL] if is_superlist : [EOL] return SUPERLIST [EOL] return UNEQUAL [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0
import unittest [EOL] [EOL] from sublist import EQUAL , SUBLIST , SUPERLIST , UNEQUAL , sublist [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SublistTest ( unittest . TestCase ) : [EOL] def test_empty_lists ( self ) : [EOL] self . assertEqual ( sublist ( [ ] , [ ] ) , EQUAL ) [EOL] [EOL] def test_empty_list_within_non_empty_list ( self ) : [EOL] self . assertEqual ( sublist ( [ ] , [ [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_non_empty_list_contains_empty_list ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ ] ) , SUPERLIST ) [EOL] [EOL] def test_list_equals_itself ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) , EQUAL ) [EOL] [EOL] def test_different_lists ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) , UNEQUAL ) [EOL] [EOL] def test_false_start ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_consecutive ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_sublist_at_start ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_sublist_in_middle ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_sublist_at_end ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) , SUBLIST ) [EOL] [EOL] def test_at_start_of_superlist ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) , SUPERLIST ) [EOL] [EOL] def test_in_middle_of_superlist ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] ] ) , SUPERLIST ) [EOL] [EOL] def test_at_end_of_superlist ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) , SUPERLIST ) [EOL] [EOL] def test_first_list_missing_element_from_second_list ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] ] , [ [number] , [number] , [number] ] ) , UNEQUAL ) [EOL] [EOL] def test_second_list_missing_element_from_first_list ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] ] ) , UNEQUAL ) [EOL] [EOL] def test_order_matters_to_a_list ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ) , UNEQUAL ) [EOL] [EOL] def test_same_digits_but_different_numbers ( self ) : [EOL] self . assertEqual ( sublist ( [ [number] , [number] , [number] ] , [ [number] , [number] ] ) , UNEQUAL ) [EOL] [EOL] [comment] [EOL] def test_unique_return_values ( self ) : [EOL] self . assertEqual ( len ( set ( [ SUBLIST , SUPERLIST , EQUAL , UNEQUAL ] ) ) , [number] ) [EOL] [EOL] def test_inner_spaces ( self ) : [EOL] self . assertEqual ( sublist ( [ [string] ] , [ [string] , [string] ] ) , UNEQUAL ) [EOL] [EOL] def test_large_lists ( self ) : [EOL] self . assertEqual ( sublist ( list ( range ( [number] ) ) * [number] + list ( range ( [number] , [number] ) ) , list ( range ( [number] , [number] ) ) , ) , SUPERLIST , ) [EOL] [EOL] def test_spread_sublist ( self ) : [EOL] self . assertEqual ( sublist ( list ( range ( [number] , [number] , [number] ) ) , list ( range ( [number] , [number] , [number] ) ) ) , UNEQUAL ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Optional , Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import List , Optional [EOL] [EOL] STUDENTS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] PLANT_NAMES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] class Garden ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , diagram , students = None ) : [EOL] [docstring] [EOL] try : [EOL] self . garden = [ [ PLANT_NAMES [ plant ] for plant in row ] for row in diagram . split ( [string] ) ] [EOL] except ValueError : [EOL] print ( [string] ) [EOL] [EOL] self . students = sorted ( students ) if students else STUDENTS [EOL] [EOL] def plants ( self , student ) : [EOL] [docstring] [EOL] try : [EOL] start = self . students . index ( student ) * [number] [EOL] end = start + [number] [EOL] return [ plant for row in self . garden for plant in row [ start : end ] ] [EOL] except ValueError : [EOL] print ( f"{ student } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from kindergarten_garden import Garden [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class KindergartenGardenTest ( unittest . TestCase ) : [EOL] def test_garden_with_single_student ( self ) : [EOL] self . assertEqual ( Garden ( [string] ) . plants ( [string] ) , [string] . split ( ) ) [EOL] [EOL] def test_different_garden_with_single_student ( self ) : [EOL] self . assertEqual ( Garden ( [string] ) . plants ( [string] ) , [string] . split ( ) ) [EOL] [EOL] def test_garden_with_two_students ( self ) : [EOL] garden = Garden ( [string] ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] [EOL] def test_multiple_students_for_the_same_garden_with_three_students ( self ) : [EOL] garden = Garden ( [string] ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [ [string] ] * [number] ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [ [string] ] * [number] ) [EOL] [EOL] def test_full_garden ( self ) : [EOL] garden = Garden ( [string] ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] [EOL] [comment] [EOL] def test_disordered_test ( self ) : [EOL] garden = Garden ( [string] , students = [string] . split ( ) ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] self . assertEqual ( garden . plants ( [string] ) , [string] . split ( ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from nth_prime import prime [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def prime_range ( n ) : [EOL] [docstring] [EOL] return [ prime ( i ) for i in range ( [number] , n + [number] ) ] [EOL] [EOL] [EOL] class NthPrimeTest ( unittest . TestCase ) : [EOL] def test_first_prime ( self ) : [EOL] self . assertEqual ( prime ( [number] ) , [number] ) [EOL] [EOL] def test_second_prime ( self ) : [EOL] self . assertEqual ( prime ( [number] ) , [number] ) [EOL] [EOL] def test_sixth_prime ( self ) : [EOL] self . assertEqual ( prime ( [number] ) , [number] ) [EOL] [EOL] def test_big_prime ( self ) : [EOL] self . assertEqual ( prime ( [number] ) , [number] ) [EOL] [EOL] def test_there_is_no_zeroth_prime ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] prime ( [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_first_twenty_primes ( self ) : [EOL] self . assertEqual ( prime_range ( [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , ] , ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from math import log [EOL] [EOL] [EOL] def prime ( number ) : [EOL] [docstring] [EOL] if number == [number] : [EOL] raise ValueError ( [string] ) [EOL] upper_bound = [number] + ( number + [number] ) * int ( log ( number + [number] ) + log ( log ( number + [number] ) ) ) [EOL] prime_list = range ( [number] , upper_bound ) [EOL] for i in range ( int ( number ** [number] ) + [number] ) : [EOL] prime_list = list ( filter ( lambda x : x % prime_list [ i ] != [number] or x == prime_list [ i ] , prime_list ) ) [EOL] return prime_list [ number - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Dict , List [EOL] [EOL] [EOL] def maximum_value ( maximum_weight , items , current_value = [number] ) : [EOL] [docstring] [EOL] if maximum_weight < [number] : [EOL] return - current_value [EOL] if not items or maximum_weight == [number] : [EOL] return [number] [EOL] return max ( maximum_value ( maximum_weight , items [ [number] : ] ) , maximum_value ( maximum_weight - items [ [number] ] [ [string] ] , items [ [number] : ] , items [ [number] ] [ [string] ] ) + items [ [number] ] [ [string] ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from knapsack import maximum_value [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class KnapsackTest ( unittest . TestCase ) : [EOL] def test_no_items ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ ] ) , [number] ) [EOL] [EOL] def test_one_item_too_heavy ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } ] ) , [number] ) [EOL] [EOL] def test_five_items_cannot_be_greedy_by_weight ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] , ) , [number] , ) [EOL] [EOL] def test_five_items_cannot_be_greedy_by_value ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] , ) , [number] , ) [EOL] [EOL] def test_example_knapsack ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] , ) , [number] , ) [EOL] [EOL] def test_8_items ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] , ) , [number] , ) [EOL] [EOL] def test_15_items ( self ) : [EOL] self . assertEqual ( maximum_value ( [number] , [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] , ) , [number] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from word_count import count_words [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class WordCountTest ( unittest . TestCase ) : [EOL] def test_count_one_word ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] } ) [EOL] [EOL] def test_count_one_of_each_word ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_multiple_occurrences_of_a_word ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_handles_cramped_lists ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_handles_expanded_lists ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_ignore_punctuation ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_include_numbers ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_normalize_case ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_with_apostrophes ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_with_quotations ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_substrings_from_the_beginning ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , ) [EOL] [EOL] def test_multiple_spaces_not_detected_as_a_word ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_alternating_word_separators_not_detected_as_a_word ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] [comment] [EOL] [EOL] def test_tabs ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , ) [EOL] [EOL] def test_non_alphanumeric ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_multiple_apostrophes_ignored ( self ) : [EOL] self . assertEqual ( count_words ( [string] ) , { [string] : [number] } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Counter [EOL] import builtins [EOL] import collections [EOL] [docstring] [EOL] import re [EOL] from collections import Counter [EOL] [EOL] [EOL] def count_words ( phrase ) : [EOL] [docstring] [EOL] phrase = re . sub ( [string] , [string] , phrase . lower ( ) ) [EOL] phrase = re . sub ( [string] , [string] , phrase ) [EOL] return Counter ( item for item in re . split ( [string] , phrase ) if item ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.Counter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def is_valid_square ( integer_number ) : [EOL] [docstring] [EOL] if integer_number not in range ( [number] , [number] ) : [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def square ( integer_number ) : [EOL] [docstring] [EOL] is_valid_square ( integer_number ) [EOL] return [number] ** ( integer_number - [number] ) [EOL] [EOL] [EOL] def total ( ) : [EOL] [docstring] [EOL] return [number] ** [number] - [number] [EOL]	0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from grains import square , total [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class GrainsTest ( unittest . TestCase ) : [EOL] def test_1 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_2 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_3 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_4 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_16 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_32 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_64 ( self ) : [EOL] self . assertEqual ( square ( [number] ) , [number] ) [EOL] [EOL] def test_square_0_raises_an_exception ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] square ( [number] ) [EOL] [EOL] def test_negative_square_raises_an_exception ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] square ( - [number] ) [EOL] [EOL] def test_square_greater_than_64_raises_an_exception ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] square ( [number] ) [EOL] [EOL] def test_returns_the_total_number_of_grains_on_the_board ( self ) : [EOL] self . assertEqual ( total ( ) , [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import unittest [EOL] from datetime import datetime [EOL] [EOL] from gigasecond import add_gigasecond [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class GigasecondTest ( unittest . TestCase ) : [EOL] def test_date_only_specification_of_time ( self ) : [EOL] self . assertEqual ( add_gigasecond ( datetime ( [number] , [number] , [number] ) ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] def test_another_date_only_specification_of_time ( self ) : [EOL] self . assertEqual ( add_gigasecond ( datetime ( [number] , [number] , [number] ) ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] def test_one_more_date_only_specification_of_time ( self ) : [EOL] self . assertEqual ( add_gigasecond ( datetime ( [number] , [number] , [number] ) ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) [EOL] [EOL] def test_full_time_specified ( self ) : [EOL] self . assertEqual ( add_gigasecond ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , ) [EOL] [EOL] def test_full_time_with_day_roll_over ( self ) : [EOL] self . assertEqual ( add_gigasecond ( datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) ) , datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) , ) [EOL] [EOL] def test_yourself ( self ) : [EOL] [comment] [EOL] your_birthday = datetime ( [number] , [number] , [number] ) [EOL] your_gigasecond = datetime ( [number] , [number] , [number] , [number] , [number] , [number] ) [EOL] [EOL] self . assertEqual ( add_gigasecond ( your_birthday ) , your_gigasecond ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] from datetime import datetime , timedelta [EOL] [EOL] [EOL] def add_gigasecond ( moment ) : [EOL] [docstring] [EOL] return moment + timedelta ( seconds = [number] ** [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import handling [EOL] import unittest [EOL] [EOL] import error_handling as er [EOL] [EOL] [EOL] class FileLike : [EOL] def __init__ ( self , fail_something = True ) : [EOL] self . is_open = False [EOL] self . was_open = False [EOL] self . did_something = False [EOL] self . fail_something = fail_something [EOL] [EOL] def open ( self ) : [EOL] self . was_open = False [EOL] self . is_open = True [EOL] [EOL] def close ( self ) : [EOL] self . is_open = False [EOL] self . was_open = True [EOL] [EOL] def __enter__ ( self ) : [EOL] self . open ( ) [EOL] return self [EOL] [EOL] def __exit__ ( self , * args ) : [EOL] self . close ( ) [EOL] [EOL] def do_something ( self ) : [EOL] self . did_something = True [EOL] if self . fail_something : [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] class ErrorHandlingTest ( unittest . TestCase ) : [EOL] def test_throw_exception ( self ) : [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] er . handle_error_by_throwing_exception ( ) [EOL] [EOL] def test_return_none ( self ) : [EOL] self . assertEqual ( er . handle_error_by_returning_none ( [string] ) , [number] , [string] , ) [EOL] self . assertIsNone ( er . handle_error_by_returning_none ( [string] ) , [string] , ) [EOL] [EOL] def test_return_tuple ( self ) : [EOL] successful_result , result = er . handle_error_by_returning_tuple ( [string] ) [EOL] self . assertIs ( successful_result , True , [string] ) [EOL] self . assertEqual ( result , [number] , [string] ) [EOL] [EOL] failure_result , result = er . handle_error_by_returning_tuple ( [string] ) [EOL] self . assertIs ( failure_result , False , [string] ) [EOL] [EOL] def test_filelike_objects_are_closed_on_exception ( self ) : [EOL] filelike_object = FileLike ( fail_something = True ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] er . filelike_objects_are_closed_on_exception ( filelike_object ) [EOL] self . assertIs ( filelike_object . is_open , False , [string] ) [EOL] self . assertIs ( filelike_object . was_open , True , [string] ) [EOL] self . assertIs ( filelike_object . did_something , True , [string] , ) [EOL] [EOL] def test_filelike_objects_are_closed_without_exception ( self ) : [EOL] filelike_object = FileLike ( fail_something = False ) [EOL] er . filelike_objects_are_closed_on_exception ( filelike_object ) [EOL] self . assertIs ( filelike_object . is_open , False , [string] ) [EOL] self . assertIs ( filelike_object . was_open , True , [string] ) [EOL] self . assertIs ( filelike_object . did_something , True , [string] , ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 $error-handling.error_handling_test.FileLike$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Tuple [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Optional , Tuple , Union [EOL] [EOL] [EOL] def handle_error_by_throwing_exception ( ) : [EOL] [docstring] [EOL] raise ValueError ( [string] ) [EOL] [EOL] [EOL] def handle_error_by_returning_none ( input_data ) : [EOL] [docstring] [EOL] try : [EOL] return int ( input_data ) [EOL] except ValueError : [EOL] return None [EOL] [EOL] [EOL] def handle_error_by_returning_tuple ( input_data , ) : [EOL] [docstring] [EOL] try : [EOL] return True , int ( input_data ) [EOL] except ValueError : [EOL] return False , input_data [EOL] [EOL] [EOL] def filelike_objects_are_closed_on_exception ( filelike_object ) : [EOL] [docstring] [EOL] try : [EOL] filelike_object . open ( ) [EOL] filelike_object . do_something ( ) [EOL] except Exception : [EOL] raise Exception ( [string] ) [EOL] finally : [EOL] filelike_object . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.Tuple[builtins.bool,builtins.int],typing.Tuple[builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from raindrops import raindrops [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RaindropsTest ( unittest . TestCase ) : [EOL] def test_the_sound_for_1_is_1 ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_3_is_pling ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_5_is_plang ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_7_is_plong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_6_is_pling ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_2_to_the_power_3_does_not_make_sound ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_9_is_pling ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_10_is_plang ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_14_is_plong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_15_is_plingplang ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_21_is_plingplong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_25_is_plang ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_27_is_pling ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_35_is_plangplong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_49_is_plong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_52_is_52 ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_105_is_plingplangplong ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] def test_the_sound_for_12121_is_12121 ( self ) : [EOL] self . assertEqual ( raindrops ( [number] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def raindrops ( number ) : [EOL] [docstring] [EOL] sounds = { [number] : [string] , [number] : [string] , [number] : [string] } [EOL] drops = [string] . join ( [ value for key , value in sorted ( sounds . items ( ) ) if number % key == [number] ] ) [EOL] return drops or str ( number ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import secrets [EOL] from string import ascii_lowercase [EOL] from typing import Optional [EOL] [EOL] [EOL] class Cipher ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , key = None ) : [EOL] [docstring] [EOL] self . key = ( key if key else [string] . join ( secrets . choice ( ascii_lowercase ) for _ in range ( [number] ) ) ) [EOL] [EOL] def encode ( self , text ) : [EOL] [docstring] [EOL] if not self . key : [EOL] return text [EOL] return [string] . join ( [ chr ( ( ord ( char ) + ord ( self . key [ index % len ( self . key ) ] ) - [number] * [number] ) % [number] + [number] ) for index , char in enumerate ( text ) ] ) [EOL] [EOL] def decode ( self , text ) : [EOL] [docstring] [EOL] if not self . key : [EOL] return text [EOL] return [string] . join ( [ chr ( ( ord ( char ) - ord ( self . key [ index % len ( self . key ) ] ) ) % [number] + [number] ) for index , char in enumerate ( text ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Any [EOL] import typing [EOL] import re [EOL] import unittest [EOL] [EOL] from simple_cipher import Cipher [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RandomKeyCipherTest ( unittest . TestCase ) : [EOL] def test_can_encode ( self ) : [EOL] cipher = Cipher ( ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . encode ( plaintext ) , cipher . key [ [number] : len ( plaintext ) ] ) [EOL] [EOL] def test_can_decode ( self ) : [EOL] cipher = Cipher ( ) [EOL] self . assertEqual ( cipher . decode ( cipher . key [ [number] : len ( [string] ) ] ) , [string] ) [EOL] [EOL] def test_is_reversible ( self ) : [EOL] cipher = Cipher ( ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . decode ( cipher . encode ( plaintext ) ) , plaintext ) [EOL] [EOL] def test_key_is_made_only_of_lowercase_letters ( self ) : [EOL] self . assertIsNotNone ( re . match ( [string] , Cipher ( ) . key ) ) [EOL] [EOL] [EOL] class SubstitutionCipherTest ( unittest . TestCase ) : [EOL] def test_can_encode ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . encode ( plaintext ) , cipher . key ) [EOL] [EOL] def test_can_decode ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] self . assertEqual ( cipher . decode ( cipher . key ) , [string] ) [EOL] [EOL] def test_is_reversible ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . decode ( cipher . encode ( plaintext ) ) , plaintext ) [EOL] [EOL] def test_can_double_shift_encode ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . encode ( plaintext ) , [string] ) [EOL] [EOL] def test_can_wrap_on_encode ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . encode ( plaintext ) , [string] ) [EOL] [EOL] def test_can_wrap_on_decode ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] self . assertEqual ( cipher . decode ( [string] ) , [string] ) [EOL] [EOL] def test_can_encode_messages_longer_than_the_key ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] plaintext = [string] [EOL] self . assertEqual ( cipher . encode ( plaintext ) , [string] ) [EOL] [EOL] def test_can_decode_messages_longer_than_the_key ( self ) : [EOL] cipher = Cipher ( [string] ) [EOL] self . assertEqual ( cipher . decode ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any , Dict [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import ledger [EOL] [docstring] [EOL] import locale as lc [EOL] from datetime import datetime [EOL] from typing import List [EOL] [EOL] [EOL] class LedgerEntry ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , date , description , change ) : [EOL] [docstring] [EOL] self . date = date [EOL] self . description = description [EOL] self . change = change [EOL] [EOL] def __lt__ ( self , other ) : [EOL] [docstring] [EOL] return ( self . date , self . change , self . description ) < ( other . date , other . change , other . description , ) [EOL] [EOL] [EOL] def create_entry ( date , description , change ) : [EOL] [docstring] [EOL] return LedgerEntry ( datetime . strptime ( date , [string] ) , description , change ) [EOL] [EOL] [EOL] def format_entries ( currency , locale , entries ) : [EOL] [docstring] [EOL] lc . setlocale ( lc . LC_ALL , locale + [string] ) [EOL] date_format = lc . nl_langinfo ( lc . D_FMT ) [EOL] column_name_dict = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , } [EOL] currency_dict = { [string] : [string] , [string] : [string] } [EOL] column_length = [ [number] , [number] , [number] ] [EOL] table = [ [string] . join ( [ column . ljust ( length ) for column , length in zip ( column_name_dict [ locale ] , column_length ) ] ) ] [EOL] entries = sorted ( entries ) [EOL] for entry in entries : [EOL] line = [ ] [EOL] date_str = entry . date . strftime ( date_format ) [EOL] if locale == [string] : [EOL] date_str = entry . date . strftime ( [string] ) [EOL] [EOL] line . append ( date_str ) [EOL] [EOL] field = ( entry . description [ : [number] ] + [string] [EOL] if len ( entry . description ) > [number] [EOL] else entry . description ) [EOL] line . append ( field . ljust ( [number] ) ) [EOL] change_str = currency_dict [ currency ] [EOL] if locale == [string] : [EOL] change_str = change_str + f"{ abs ( entry . change ) / [number] : [string] }" [EOL] elif locale == [string] : [EOL] change_str = change_str + [string] f"{ entry . change / [number] : [string] }" [EOL] if entry . change < [number] and locale == [string] : [EOL] change_str = [string] + change_str + [string] [EOL] else : [EOL] change_str += [string] [EOL] change_str = change_str . rjust ( [number] ) [EOL] line . append ( change_str ) [EOL] table . append ( [string] . join ( line ) ) [EOL] return [string] . join ( table ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $datetime.datetime$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 $datetime.datetime$ 0 $datetime.datetime$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $"LedgerEntry"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"LedgerEntry"$ 0 0 0 $"LedgerEntry"$ 0 0 0 $"LedgerEntry"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from ledger import create_entry , format_entries [EOL] [EOL] [EOL] class LedgerTest ( unittest . TestCase ) : [EOL] maxDiff = [number] [EOL] [EOL] def test_empty_ledger ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ ] [EOL] expected = [string] [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_one_entry ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , - [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_credit_and_debit ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , [number] ) , create_entry ( [string] , [string] , - [number] ) , ] [EOL] expected = [string] . join ( [ [string] , [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_multiple_entries_on_same_date_ordered_by_description ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , [number] ) , create_entry ( [string] , [string] , - [number] ) , ] [EOL] expected = [string] . join ( [ [string] , [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_final_order_tie_breaker_is_change ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , [number] ) , create_entry ( [string] , [string] , - [number] ) , create_entry ( [string] , [string] , [number] ) , ] [EOL] expected = [string] . join ( [ [string] , [string] , [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_overlong_description ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , - [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_euros ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , - [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_dutch_locale ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_dutch_locale_and_euros ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_dutch_negative_number_with_3_digits_before_decimal_point ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , - [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] def test_american_negative_number_with_3_digits_before_decimal_point ( self ) : [EOL] currency = [string] [EOL] locale = [string] [EOL] entries = [ create_entry ( [string] , [string] , - [number] ) ] [EOL] expected = [string] . join ( [ [string] , [string] , ] ) [EOL] self . assertEqual ( format_entries ( currency , locale , entries ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Tuple , List [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import List , Optional [EOL] [EOL] [EOL] class Point ( object ) : [EOL] def __init__ ( self , x , y ) : [EOL] self . x = x [EOL] self . y = y [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . x == other . x and self . y == other . y [EOL] [EOL] [EOL] class WordSearch ( object ) : [EOL] def __init__ ( self , puzzle ) : [EOL] self . puzzle = puzzle [EOL] [EOL] def search ( self , word ) : [EOL] result = [ ( position . start ( ) , index ) for index , row in enumerate ( self . puzzle ) for position in re . finditer ( word , row ) ] [EOL] if not result : [EOL] return None [EOL] print ( result ) [EOL] print ( [ Point ( point [ [number] ] , point [ [number] ] ) for point in result ] ) [EOL] return [ Point ( x , y ) for x , y in result ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[typing.List[Point]]$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.int,builtins.int]]$ 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from word_search import Point , WordSearch [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class WordSearchTest ( unittest . TestCase ) : [EOL] def test_should_accept_an_initial_game_grid_and_a_target_search_word ( self ) : [EOL] puzzle = WordSearch ( [ [string] ] ) [EOL] self . assertIsNone ( puzzle . search ( [string] ) ) [EOL] [EOL] def test_should_locate_one_word_written_left_to_right ( self ) : [EOL] puzzle = WordSearch ( [ [string] ] ) [EOL] self . assertEqual ( puzzle . search ( [string] ) , ( Point ( [number] , [number] ) , Point ( [number] , [number] ) ) ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Literal , Tuple , List [EOL] import typing [EOL] import builtins [EOL] import typing_extensions [EOL] [docstring] [EOL] [EOL] EAST = ( [number] , [number] ) [EOL] NORTH = ( [number] , [number] ) [EOL] WEST = ( - [number] , [number] ) [EOL] SOUTH = ( [number] , - [number] ) [EOL] DIRECTION = [ NORTH , EAST , SOUTH , WEST ] [EOL] [EOL] [EOL] class Robot ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , direction = NORTH , x = [number] , y = [number] ) : [EOL] [docstring] [EOL] self . direction = direction [EOL] self . coordinates = ( x , y ) [EOL] [EOL] def turn_left ( self ) : [EOL] [docstring] [EOL] self . direction = DIRECTION [ DIRECTION . index ( self . direction ) - [number] ] [EOL] [EOL] def turn_right ( self ) : [EOL] [docstring] [EOL] self . direction = DIRECTION [ DIRECTION . index ( self . direction ) - [number] ] [EOL] [EOL] def advance ( self ) : [EOL] [docstring] [EOL] self . coordinates = tuple ( [ item1 + item2 for item1 , item2 in zip ( self . coordinates , self . direction ) ] ) [EOL] [EOL] def move ( self , instructions ) : [EOL] [docstring] [EOL] for instruction in instructions : [EOL] if instruction == [string] : [EOL] self . turn_left ( ) [EOL] elif instruction == [string] : [EOL] self . turn_right ( ) [EOL] elif instruction == [string] : [EOL] self . advance ( ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from __future__ import division [EOL] [EOL] import math [EOL] import unittest [EOL] [EOL] from complex_numbers import ComplexNumber [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ComplexNumbersTest ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] [EOL] def test_real_part_of_a_purely_real_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . real , [number] ) [EOL] [EOL] def test_real_part_of_a_purely_imaginary_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . real , [number] ) [EOL] [EOL] def test_real_part_of_a_number_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . real , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_imaginary_part_of_a_purely_real_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . imaginary , [number] ) [EOL] [EOL] def test_imaginary_part_of_a_purely_imaginary_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . imaginary , [number] ) [EOL] [EOL] def test_imaginary_part_of_a_number_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . imaginary , [number] ) [EOL] [EOL] def test_imaginary_unit ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) * ComplexNumber ( [number] , [number] ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] def test_add_purely_real_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) + ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_add_purely_imaginary_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) + ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_add_numbers_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) + ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_subtract_purely_real_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) - ComplexNumber ( [number] , [number] ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] def test_subtract_purely_imaginary_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) - ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , - [number] ) ) [EOL] [EOL] def test_subtract_numbers_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) - ComplexNumber ( [number] , [number] ) , ComplexNumber ( - [number] , - [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_multiply_purely_real_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) * ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_multiply_purely_imaginary_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) * ComplexNumber ( [number] , [number] ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] def test_multiply_numbers_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) * ComplexNumber ( [number] , [number] ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_divide_purely_real_numbers ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , [number] ) / ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_divide_purely_imaginary_numbers ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , [number] ) / ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_divide_numbers_with_real_and_imaginary_part ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , [number] ) / ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_absolute_value_of_a_positive_purely_real_number ( self ) : [EOL] self . assertEqual ( abs ( ComplexNumber ( [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_absolute_value_of_a_negative_purely_real_number ( self ) : [EOL] self . assertEqual ( abs ( ComplexNumber ( - [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_absolute_value_of_a_purely_imaginary_number_with_positive_imaginary_part ( self , ) : [EOL] self . assertEqual ( abs ( ComplexNumber ( [number] , [number] ) ) , [number] ) [EOL] [EOL] def test_absolute_value_of_a_purely_imaginary_number_with_negative_imaginary_part ( self , ) : [EOL] self . assertEqual ( abs ( ComplexNumber ( [number] , - [number] ) ) , [number] ) [EOL] [EOL] def test_absolute_value_of_a_number_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( abs ( ComplexNumber ( [number] , [number] ) ) , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_conjugate_a_purely_real_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . conjugate ( ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_conjugate_a_purely_imaginary_number ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . conjugate ( ) , ComplexNumber ( [number] , - [number] ) ) [EOL] [EOL] def test_conjugate_a_number_with_real_and_imaginary_part ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) . conjugate ( ) , ComplexNumber ( [number] , - [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_euler_s_identity_formula ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , math . pi ) . exp ( ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] def test_exponential_of_0 ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , [number] ) . exp ( ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_exponential_of_a_purely_real_number ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( [number] , [number] ) . exp ( ) , ComplexNumber ( math . e , [number] ) ) [EOL] [EOL] def test_exponential_of_a_number_with_real_and_imaginary_part ( self ) : [EOL] self . assertAlmostEqual ( ComplexNumber ( math . log ( [number] ) , math . pi ) . exp ( ) , ComplexNumber ( - [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_equality_of_complex_numbers ( self ) : [EOL] self . assertEqual ( ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_inequality_of_real_part ( self ) : [EOL] self . assertNotEqual ( ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] def test_inequality_of_imaginary_part ( self ) : [EOL] self . assertNotEqual ( ComplexNumber ( [number] , [number] ) , ComplexNumber ( [number] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import math [EOL] from typing import Union [EOL] [EOL] [EOL] class ComplexNumber ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , real , imaginary ) : [EOL] self . real = real [EOL] self . imaginary = imaginary [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . real == other . real and self . imaginary == other . imaginary [EOL] [EOL] def __add__ ( self , other ) : [EOL] return ComplexNumber ( self . real + other . real , self . imaginary + other . imaginary ) [EOL] [EOL] def __mul__ ( self , other ) : [EOL] return ComplexNumber ( self . real * other . real - self . imaginary * other . imaginary , self . imaginary * other . real + self . real * other . imaginary , ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return ComplexNumber ( self . real - other . real , self . imaginary - other . imaginary ) [EOL] [EOL] def __truediv__ ( self , other ) : [EOL] denominator = other . real ** [number] + other . imaginary ** [number] [EOL] return ComplexNumber ( ( self . real * other . real + self . imaginary * other . imaginary ) / denominator , ( self . imaginary * other . real - self . real * other . imaginary ) / denominator , ) [EOL] [EOL] def __abs__ ( self ) : [EOL] return math . sqrt ( self . real ** [number] + self . imaginary ** [number] ) [EOL] [EOL] def conjugate ( self ) : [EOL] [docstring] [EOL] return ComplexNumber ( self . real , - self . imaginary ) [EOL] [EOL] def exp ( self ) : [EOL] [docstring] [EOL] return ComplexNumber ( math . exp ( self . real ) * math . cos ( self . imaginary ) , math . exp ( self . real ) * math . sin ( self . imaginary ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 $"ComplexNumber"$ 0 0 0 $typing.Any$ 0 $"ComplexNumber"$ 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"ComplexNumber"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from matrix import Matrix [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MatrixTest ( unittest . TestCase ) : [EOL] def test_extract_row_from_one_number_matrix ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . row ( [number] ) , [ [number] ] ) [EOL] [EOL] def test_can_extract_row ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . row ( [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_extract_row_where_numbers_have_different_widths ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . row ( [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_can_extract_row_from_non_square_matrix ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . row ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_extract_column_from_one_number_matrix ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . column ( [number] ) , [ [number] ] ) [EOL] [EOL] def test_can_extract_column ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . column ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_can_extract_column_from_non_square_matrix ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . column ( [number] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_extract_column_where_numbers_have_different_widths ( self ) : [EOL] matrix = Matrix ( [string] ) [EOL] self . assertEqual ( matrix . column ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Matrix ( object ) : [EOL] def __init__ ( self , matrix_string ) : [EOL] self . matrix = [ [ int ( cell ) for cell in row . split ( ) ] for row in matrix_string . splitlines ( ) ] [EOL] self . _columns = [ [ row [ index ] for row in self . matrix ] for index in range ( len ( self . matrix [ [number] ] ) ) ] [EOL] [EOL] def row ( self , index ) : [EOL] return self . matrix [ index - [number] ] [EOL] [EOL] def column ( self , index ) : [EOL] return self . _columns [ index - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0
from typing import Optional , Pattern [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import re [EOL] import string [EOL] from typing import Optional [EOL] [EOL] [EOL] def encode ( plain_text ) : [EOL] [docstring] [EOL] pattern = re . compile ( [string] , re . UNICODE ) [EOL] clean_text = pattern . sub ( [string] , plain_text ) . lower ( ) [EOL] ciphered_text = decode ( clean_text ) [EOL] ciphered_text = [string] . join ( [ ciphered_text [ i : i + [number] ] for i in range ( [number] , len ( ciphered_text ) , [number] ) ] ) [EOL] return ciphered_text [EOL] [EOL] [EOL] def decode ( ciphered_text ) : [EOL] [docstring] [EOL] reversed_alphabet = string . ascii_lowercase [ : : - [number] ] [EOL] return [string] . join ( reversed_alphabet [ string . ascii_lowercase . index ( char ) ] [EOL] if char . isalpha ( ) [EOL] else char for char in ciphered_text . replace ( [string] , [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def is_armstrong_number ( number ) : [EOL] return sum ( [ int ( d ) ** len ( str ( number ) ) for d in str ( number ) ] ) == number [EOL]	0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from armstrong_numbers import is_armstrong_number [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ArmstrongNumbersTest ( unittest . TestCase ) : [EOL] def test_zero_is_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , True ) [EOL] [EOL] def test_single_digit_numbers_are_armstrong_numbers ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , True ) [EOL] [EOL] def test_there_are_no_2_digit_armstrong_numbers ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , False ) [EOL] [EOL] def test_three_digit_number_that_is_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , True ) [EOL] [EOL] def test_three_digit_number_that_is_not_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , False ) [EOL] [EOL] def test_four_digit_number_that_is_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , True ) [EOL] [EOL] def test_four_digit_number_that_is_not_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , False ) [EOL] [EOL] def test_seven_digit_number_that_is_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , True ) [EOL] [EOL] def test_seven_digit_number_that_is_not_an_armstrong_number ( self ) : [EOL] self . assertIs ( is_armstrong_number ( [number] ) , False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] CODES = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] [EOL] [EOL] def value ( colors ) : [EOL] [docstring] [EOL] return int ( [string] . join ( str ( CODES [ color ] ) for color in colors [ : [number] ] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from resistor_color_duo import value [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ResistorColorDuoTest ( unittest . TestCase ) : [EOL] def test_brown_and_black ( self ) : [EOL] self . assertEqual ( value ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_blue_and_grey ( self ) : [EOL] self . assertEqual ( value ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_yellow_and_violet ( self ) : [EOL] self . assertEqual ( value ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_orange_and_orange ( self ) : [EOL] self . assertEqual ( value ( [ [string] , [string] ] ) , [number] ) [EOL] [EOL] def test_ignore_additional_colors ( self ) : [EOL] self . assertEqual ( value ( [ [string] , [string] , [string] ] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from rail_fence_cipher import decode , encode [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RailFenceCipherTest ( unittest . TestCase ) : [EOL] def test_encode_with_two_rails ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_encode_with_three_rails ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_encode_with_ending_in_the_middle ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_decode_with_three_rails ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_decode_with_five_rails ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_decode_with_six_rails ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] , [number] ) , [string] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def encode ( message , rails ) : [EOL] encoded_message = [string] [EOL] for i in range ( rails ) : [EOL] encoded_message = encoded_message + message [ i : : rails ] [EOL] return encoded_message [EOL] [EOL] [EOL] def decode ( encoded_message , rails ) : [EOL] return encoded_message [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List , Optional [EOL] [EOL] [EOL] class CustomSet : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , elements = [ ] ) : [EOL] self . elements = set ( elements ) [EOL] print ( self . elements ) [EOL] [EOL] def isempty ( self ) : [EOL] return not self . elements [EOL] [EOL] def __contains__ ( self , element ) : [EOL] return element in self . elements [EOL] [EOL] def issubset ( self , other ) : [EOL] return self . elements . issubset ( other . elements ) [EOL] [EOL] def isdisjoint ( self , other ) : [EOL] return self . elements . isdisjoint ( other . elements ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . elements == other . elements [EOL] [EOL] def add ( self , element ) : [EOL] self . elements . add ( element ) [EOL] [EOL] def intersection ( self , other ) : [EOL] return CustomSet ( self . elements . intersection ( other . elements ) ) [EOL] [EOL] def __sub__ ( self , other ) : [EOL] return CustomSet ( self . elements . difference ( other . elements ) ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] return CustomSet ( self . elements | other . elements ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from custom_set import CustomSet [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class CustomSetTest ( unittest . TestCase ) : [EOL] def test_sets_with_no_elements_are_empty ( self ) : [EOL] sut = CustomSet ( ) [EOL] self . assertIs ( sut . isempty ( ) , True ) [EOL] [EOL] def test_sets_with_elements_are_not_empty ( self ) : [EOL] sut = CustomSet ( [ [number] ] ) [EOL] self . assertIs ( sut . isempty ( ) , False ) [EOL] [EOL] def test_nothing_is_contained_in_an_empty_set ( self ) : [EOL] sut = CustomSet ( ) [EOL] self . assertNotIn ( [number] , sut ) [EOL] [EOL] def test_when_the_element_is_in_the_set ( self ) : [EOL] sut = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertIn ( [number] , sut ) [EOL] [EOL] def test_when_the_element_is_not_in_the_set ( self ) : [EOL] sut = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertNotIn ( [number] , sut ) [EOL] [EOL] def test_empty_set_is_a_subset_of_another_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , True ) [EOL] [EOL] def test_empty_set_is_a_subset_of_non_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] ] ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , True ) [EOL] [EOL] def test_non_empty_set_is_not_a_subset_of_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , False ) [EOL] [EOL] def test_set_is_a_subset_of_set_with_exact_same_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , True ) [EOL] [EOL] def test_set_is_a_subset_of_larger_set_with_same_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , True ) [EOL] [EOL] def test_set_is_not_a_subset_of_set_that_does_not_contain_its_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertIs ( set1 . issubset ( set2 ) , False ) [EOL] [EOL] def test_the_empty_set_is_disjoint_with_itself ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] self . assertIs ( set1 . isdisjoint ( set2 ) , True ) [EOL] [EOL] def test_empty_set_is_disjoint_with_non_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] ] ) [EOL] self . assertIs ( set1 . isdisjoint ( set2 ) , True ) [EOL] [EOL] def test_non_empty_set_is_disjoint_with_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] self . assertIs ( set1 . isdisjoint ( set2 ) , True ) [EOL] [EOL] def test_sets_are_not_disjoint_if_they_share_an_element ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertIs ( set1 . isdisjoint ( set2 ) , False ) [EOL] [EOL] def test_sets_are_disjoint_if_they_share_no_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertIs ( set1 . isdisjoint ( set2 ) , True ) [EOL] [EOL] def test_empty_sets_are_equal ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] self . assertEqual ( set1 , set2 ) [EOL] [EOL] def test_empty_set_is_not_equal_to_non_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertNotEqual ( set1 , set2 ) [EOL] [EOL] def test_non_empty_set_is_not_equal_to_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] self . assertNotEqual ( set1 , set2 ) [EOL] [EOL] def test_sets_with_the_same_elements_are_equal ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertEqual ( set1 , set2 ) [EOL] [EOL] def test_sets_with_different_elements_are_not_equal ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertNotEqual ( set1 , set2 ) [EOL] [EOL] def test_set_is_not_equal_to_larger_set_with_same_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertNotEqual ( set1 , set2 ) [EOL] [EOL] def test_add_to_empty_set ( self ) : [EOL] sut = CustomSet ( ) [EOL] expected = CustomSet ( [ [number] ] ) [EOL] sut . add ( [number] ) [EOL] self . assertEqual ( sut , expected ) [EOL] [EOL] def test_add_to_non_empty_set ( self ) : [EOL] sut = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] sut . add ( [number] ) [EOL] self . assertEqual ( sut , expected ) [EOL] [EOL] def test_adding_an_existing_element_does_not_change_the_set ( self ) : [EOL] sut = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] sut . add ( [number] ) [EOL] self . assertEqual ( sut , expected ) [EOL] [EOL] def test_intersection_of_two_empty_sets_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 . intersection ( set2 ) , expected ) [EOL] [EOL] def test_intersection_of_an_empty_set_and_non_empty_set_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 . intersection ( set2 ) , expected ) [EOL] [EOL] def test_intersection_of_a_non_empty_set_and_an_empty_set_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 . intersection ( set2 ) , expected ) [EOL] [EOL] def test_intersection_of_two_sets_with_no_shared_elements_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 . intersection ( set2 ) , expected ) [EOL] [EOL] def test_intersection_of_two_sets_with_shared_elements_is_a_set_of_the_shared_elements ( self , ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertEqual ( set1 . intersection ( set2 ) , expected ) [EOL] [EOL] def test_difference_of_two_empty_sets_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 - set2 , expected ) [EOL] [EOL] def test_difference_of_empty_set_and_non_empty_set_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 - set2 , expected ) [EOL] [EOL] def test_difference_of_a_non_empty_set_and_an_empty_set_is_the_non_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( [ [number] , [number] , [number] , [number] ] ) [EOL] self . assertEqual ( set1 - set2 , expected ) [EOL] [EOL] def test_difference_of_two_non_empty_sets_is_a_set_of_elements_that_are_only_in_the_first_set ( self , ) : [EOL] set1 = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] ] ) [EOL] expected = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertEqual ( set1 - set2 , expected ) [EOL] [EOL] def test_union_of_empty_sets_is_an_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( ) [EOL] self . assertEqual ( set1 + set2 , expected ) [EOL] [EOL] def test_union_of_an_empty_set_and_non_empty_set_is_the_non_empty_set ( self ) : [EOL] set1 = CustomSet ( ) [EOL] set2 = CustomSet ( [ [number] ] ) [EOL] expected = CustomSet ( [ [number] ] ) [EOL] self . assertEqual ( set1 + set2 , expected ) [EOL] [EOL] def test_union_of_a_non_empty_set_and_empty_set_is_the_non_empty_set ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] ] ) [EOL] set2 = CustomSet ( ) [EOL] expected = CustomSet ( [ [number] , [number] ] ) [EOL] self . assertEqual ( set1 + set2 , expected ) [EOL] [EOL] def test_union_of_non_empty_sets_contains_all_unique_elements ( self ) : [EOL] set1 = CustomSet ( [ [number] , [number] ] ) [EOL] set2 = CustomSet ( [ [number] , [number] ] ) [EOL] expected = CustomSet ( [ [number] , [number] , [number] ] ) [EOL] self . assertEqual ( set1 + set2 , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def is_isogram ( string ) : [EOL] [docstring] [EOL] letters = [ c for c in string . lower ( ) if c . isalpha ( ) ] [EOL] return len ( set ( letters ) ) == len ( letters ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from isogram import is_isogram [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class IsogramTest ( unittest . TestCase ) : [EOL] def test_empty_string ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_isogram_with_only_lower_case_characters ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_word_with_one_duplicated_character ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_word_with_one_duplicated_character_from_end_of_alphabet ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_longest_reported_english_isogram ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_word_with_duplicated_character_in_mixed_case ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_word_with_duplicated_letter_in_mixed_case_lowercase_first ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_hypothetical_isogrammic_word_with_hyphen ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_hypothetical_word_with_duplicate_character_following_hyphen ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_isogram_with_duplicated_hyphen ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_made_up_name_that_is_an_isogram ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , True ) [EOL] [EOL] def test_duplicated_character_in_the_middle ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] def test_same_first_and_last_characters ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] [comment] [EOL] [EOL] def test_isogram_with_duplicated_letter_and_nonletter_character ( self ) : [EOL] self . assertIs ( is_isogram ( [string] ) , False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from dnd_character import Character , modifier [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DndCharacterTest ( unittest . TestCase ) : [EOL] def test_ability_modifier_for_score_3_is_n4 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_4_is_n3 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_5_is_n3 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_6_is_n2 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_7_is_n2 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_8_is_n1 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_9_is_n1 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , - [number] ) [EOL] [EOL] def test_ability_modifier_for_score_10_is_0 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_11_is_0 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_12_is_1 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_13_is_1 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_14_is_2 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_15_is_2 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_16_is_3 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_17_is_3 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_ability_modifier_for_score_18_is_4 ( self ) : [EOL] self . assertEqual ( modifier ( [number] ) , [number] ) [EOL] [EOL] def test_random_ability_is_within_range ( self ) : [EOL] score = Character ( ) . ability ( ) [EOL] self . assertIs ( score >= [number] and score <= [number] , True ) [EOL] [EOL] def test_random_character_is_valid ( self ) : [EOL] Char = Character ( ) [EOL] self . assertIs ( Char . strength >= [number] and Char . strength <= [number] , True ) [EOL] self . assertIs ( Char . dexterity >= [number] and Char . dexterity <= [number] , True ) [EOL] self . assertIs ( Char . constitution >= [number] and Char . constitution <= [number] , True ) [EOL] self . assertIs ( Char . intelligence >= [number] and Char . intelligence <= [number] , True ) [EOL] self . assertIs ( Char . wisdom >= [number] and Char . wisdom <= [number] , True ) [EOL] self . assertIs ( Char . charisma >= [number] and Char . charisma <= [number] , True ) [EOL] self . assertIs ( Char . hitpoints == [number] + modifier ( Char . constitution ) , True ) [EOL] [EOL] def test_each_ability_is_only_calculated_once ( self ) : [EOL] Char = Character ( ) [EOL] self . assertIs ( Char . strength == Char . strength , True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from secrets import randbelow [EOL] [EOL] [EOL] class Character : [EOL] def __init__ ( self ) : [EOL] self . strength = self . ability ( ) [EOL] self . dexterity = self . ability ( ) [EOL] self . constitution = self . ability ( ) [EOL] self . intelligence = self . ability ( ) [EOL] self . wisdom = self . ability ( ) [EOL] self . charisma = self . ability ( ) [EOL] self . hitpoints = [number] + modifier ( self . constitution ) [EOL] [EOL] def ability ( self ) : [EOL] choice = [ randbelow ( [number] ) + [number] for i in range ( [number] ) ] [EOL] return sum ( choice ) - min ( choice ) [EOL] [EOL] [EOL] def modifier ( point ) : [EOL] return ( point - [number] ) // [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] import re [EOL] [EOL] [EOL] def abbreviate ( words ) : [EOL] word_list = list ( filter ( None , re . split ( [string] , words ) ) ) [EOL] return [string] . join ( [ x [ [number] ] . upper ( ) for x in word_list ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from hamming import distance [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HammingTest ( unittest . TestCase ) : [EOL] def test_empty_strands ( self ) : [EOL] self . assertEqual ( distance ( [string] , [string] ) , [number] ) [EOL] [EOL] def test_single_letter_identical_strands ( self ) : [EOL] self . assertEqual ( distance ( [string] , [string] ) , [number] ) [EOL] [EOL] def test_single_letter_different_strands ( self ) : [EOL] self . assertEqual ( distance ( [string] , [string] ) , [number] ) [EOL] [EOL] def test_long_identical_strands ( self ) : [EOL] self . assertEqual ( distance ( [string] , [string] ) , [number] ) [EOL] [EOL] def test_long_different_strands ( self ) : [EOL] self . assertEqual ( distance ( [string] , [string] ) , [number] ) [EOL] [EOL] def test_disallow_first_strand_longer ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] distance ( [string] , [string] ) [EOL] [EOL] def test_disallow_second_strand_longer ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] distance ( [string] , [string] ) [EOL] [EOL] def test_disallow_left_empty_strand ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] distance ( [string] , [string] ) [EOL] [EOL] def test_disallow_right_empty_strand ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] distance ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def distance ( strand_a , strand_b ) : [EOL] [docstring] [EOL] if len ( strand_a ) != len ( strand_b ) : [EOL] raise ValueError ( [string] ) [EOL] return sum ( i != j for i , j in zip ( strand_a , strand_b ) ) [EOL]	0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from say import say [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SayTest ( unittest . TestCase ) : [EOL] def test_zero ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_fourteen ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_twenty ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_twenty_two ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_hundred ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_hundred_twenty_three ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_thousand ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_thousand_two_hundred_thirty_four ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_million ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_million_two_thousand_three_hundred_forty_five ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_one_billion ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] ) [EOL] [EOL] def test_a_big_number ( self ) : [EOL] self . assertEqual ( say ( [number] ) , [string] , ) [EOL] [EOL] def test_numbers_below_zero_are_out_of_range ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] say ( - [number] ) [EOL] [EOL] def test_numbers_above_999_999_999_999_are_out_of_range ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] say ( [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Union [EOL] [EOL] NUMBERS_20_90 = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] NUMBERS_0_19 = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] [EOL] NUMBERS_DICT = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] ** [number] : [string] , } [EOL] [EOL] [EOL] def say ( number ) : [EOL] [docstring] [EOL] if number < [number] : [EOL] raise ValueError ( [string] ) [EOL] if number >= [number] : [EOL] raise ValueError ( [string] ) [EOL] [EOL] number = int ( number ) [EOL] if number < [number] : [EOL] return NUMBERS_0_19 [ number ] [EOL] if number < [number] : [EOL] return NUMBERS_20_90 [ number // [number] - [number] ] + ( [string] if number % [number] == [number] else [string] + NUMBERS_0_19 [ number % [number] ] ) [EOL] [EOL] maxkey = max ( [ key for key in NUMBERS_DICT if key <= number ] ) [EOL] return ( say ( number // maxkey ) + [string] + NUMBERS_DICT [ maxkey ] + ( [string] if number % maxkey == [number] else [string] + say ( number % maxkey ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from secret_handshake import commands [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SecretHandshakeTest ( unittest . TestCase ) : [EOL] def test_wink_for_1 ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] ] ) [EOL] [EOL] def test_double_blink_for_10 ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] ] ) [EOL] [EOL] def test_close_your_eyes_for_100 ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] ] ) [EOL] [EOL] def test_jump_for_1000 ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] ] ) [EOL] [EOL] def test_combine_two_actions ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] , [string] ] ) [EOL] [EOL] def test_reverse_two_actions ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] , [string] ] ) [EOL] [EOL] def test_reversing_one_action_gives_the_same_action ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] ] ) [EOL] [EOL] def test_reversing_no_actions_still_gives_no_actions ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ ] ) [EOL] [EOL] def test_all_possible_actions ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_reverse_all_possible_actions ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_do_nothing_for_zero ( self ) : [EOL] self . assertEqual ( commands ( [number] ) , [ ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] ACTIONS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def commands ( code ) : [EOL] [docstring] [EOL] actions = [ action for key , action in enumerate ( ACTIONS ) if code & [number] ** key > [number] ] [EOL] if code >= [number] : [EOL] actions = actions [ : : - [number] ] [EOL] return actions [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Union , Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] import operator [EOL] [docstring] [EOL] from operator import add , mul , sub [EOL] from operator import truediv as div [EOL] [EOL] [EOL] def calculate ( question ) : [EOL] [docstring] [EOL] elements = ( question . strip ( [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) . split ( ) ) [EOL] if ( elements [ [number] ] , elements [ [number] ] ) != ( [string] , [string] ) or len ( elements ) % [number] == [number] : [EOL] raise ValueError ( [string] ) [EOL] operator_dict = { [string] : add , [string] : sub , [string] : div , [string] : mul } [EOL] if elements [ [number] ] . lstrip ( [string] ) . isdigit ( ) : [EOL] result = int ( elements [ [number] ] ) [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] for operator , operand in zip ( elements [ [number] : : [number] ] , elements [ [number] : : [number] ] ) : [EOL] try : [EOL] result = operator_dict [ operator ] ( result , int ( operand ) ) [EOL] except Exception as ex : [EOL] raise ValueError ( f" [string] { ex }" ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from alphametics import solve [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AlphameticsTest ( unittest . TestCase ) : [EOL] def test_puzzle_with_three_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_solution_must_have_unique_value_for_each_letter ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , None ) [EOL] [EOL] def test_leading_zero_solution_is_invalid ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , None ) [EOL] [EOL] def test_puzzle_with_two_digits_final_carry ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_puzzle_with_four_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] [EOL] def test_puzzle_with_six_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_puzzle_with_seven_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_puzzle_with_eight_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } , ) [EOL] [EOL] def test_puzzle_with_ten_letters ( self ) : [EOL] self . assertEqual ( solve ( [string] ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] def test_puzzle_with_ten_letters_and_199_addends ( self ) : [EOL] [docstring] [EOL] puzzle = ( [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] self . assertEqual ( solve ( puzzle ) , { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterator , Set , Tuple , Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import string [EOL] from itertools import permutations [EOL] [EOL] [EOL] def parse_number ( number , value_dict ) : [EOL] [docstring] [EOL] return int ( [string] . join ( [ value_dict [ letter ] for letter in number ] ) ) [EOL] [EOL] [EOL] def solve ( puzzle ) : [EOL] [docstring] [EOL] letters = list ( set ( [ letter for letter in puzzle if letter in string . ascii_uppercase ] ) ) [EOL] left_side , right_side = puzzle . replace ( [string] , [string] ) . split ( [string] ) [EOL] left_side = left_side . split ( [string] ) [EOL] non_zeros = set ( [ letter [ [number] ] for letter in left_side ] ) [EOL] non_zeros . add ( right_side [ [number] ] ) [EOL] all_permutations = permutations ( range ( [number] ) , len ( letters ) ) [EOL] for permutation in all_permutations : [EOL] value_dict = { k : str ( v ) for k , v in zip ( letters , permutation ) } [EOL] if [string] not in [ value_dict [ i ] for i in non_zeros ] : [EOL] left_value = sum ( parse_number ( number , value_dict ) for number in left_side ) [EOL] right_value = parse_number ( right_side , value_dict ) [EOL] if left_value == right_value : [EOL] return { k : int ( v ) for k , v in value_dict . items ( ) } [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Tuple , List [EOL] import typing [EOL] import builtins [EOL] from typing import List , Set , Tuple [EOL] [EOL] [EOL] def saddle_points ( matrix ) : [EOL] if any ( len ( row ) != len ( matrix [ [number] ] ) for row in matrix ) : [EOL] raise ValueError ( [string] ) [EOL] max_row = [ max ( row ) for row in matrix ] [EOL] min_col = [ min ( col ) for col in zip ( * matrix ) ] [EOL] points = set ( ( nr + [number] , nc + [number] ) for nr , row in enumerate ( max_row ) for nc , col in enumerate ( min_col ) if row == col ) [EOL] return [ { [string] : point [ [number] ] , [string] : point [ [number] ] } for point in points ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from saddle_points import saddle_points [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def sorted_points ( point_list ) : [EOL] return sorted ( point_list , key = lambda p : ( p [ [string] ] , p [ [string] ] ) ) [EOL] [EOL] [EOL] class SaddlePointsTest ( unittest . TestCase ) : [EOL] def test_can_identify_single_saddle_point ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } ] ) , ) [EOL] [EOL] def test_can_identify_that_empty_matrix_has_no_saddle_points ( self ) : [EOL] matrix = [ ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ ] ) ) [EOL] [EOL] def test_can_identify_lack_of_saddle_points_when_there_are_none ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ ] ) ) [EOL] [EOL] def test_can_identify_multiple_saddle_points_in_a_column ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] ) , ) [EOL] [EOL] def test_can_identify_multiple_saddle_points_in_a_row ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } , ] ) , ) [EOL] [EOL] def test_can_identify_saddle_point_in_bottom_right_corner ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } ] ) , ) [EOL] [EOL] def test_can_identify_saddle_points_in_a_non_square_matrix ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] ) , ) [EOL] [EOL] def test_can_identify_that_saddle_points_in_a_single_column_matrix_are_those_with_the_minimum_value ( self , ) : [EOL] matrix = [ [ [number] ] , [ [number] ] , [ [number] ] , [ [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] ) , ) [EOL] [EOL] def test_can_identify_that_saddle_points_in_a_single_row_matrix_are_those_with_the_maximum_value ( self , ) : [EOL] matrix = [ [ [number] , [number] , [number] , [number] ] ] [EOL] self . assertEqual ( sorted_points ( saddle_points ( matrix ) ) , sorted_points ( [ { [string] : [number] , [string] : [number] } , { [string] : [number] , [string] : [number] } ] ) , ) [EOL] [EOL] [comment] [EOL] [EOL] def test_irregular_matrix ( self ) : [EOL] matrix = [ [ [number] , [number] , [number] ] , [ [number] , [number] ] , [ [number] , [number] , [number] ] ] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] saddle_points ( matrix ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] class Scale ( object ) : [EOL] def __init__ ( self , tonic ) : [EOL] self . tonic = tonic [EOL] self . chromatic_ = self . make_chromatic ( ) [EOL] [EOL] def chromatic ( self ) : [EOL] return self . chromatic_ [EOL] [EOL] def interval ( self , intervals ) : [EOL] pass [EOL] [EOL] def make_chromatic ( self ) : [EOL] base_chromatic = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] index = base_chromatic . index ( self . tonic ) [EOL] return base_chromatic [ index : ] + base_chromatic [ : index ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from scale_generator import Scale [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ScaleGeneratorTest ( unittest . TestCase ) : [EOL] [EOL] [comment] [EOL] def test_chromatic_scale_with_sharps ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . chromatic ( ) , expected ) [EOL] [EOL] def test_chromatic_scale_with_flats ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . chromatic ( ) , expected ) [EOL] [EOL] [comment] [EOL] def test_simple_major_scale ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_major_scale_with_sharps ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_major_scale_with_flats ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_minor_scale_with_sharps ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_minor_scale_with_flats ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_dorian_mode ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_mixolydian_mode ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_lydian_mode ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_phrygian_mode ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_locrian_mode ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_harmonic_minor ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_octatonic ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_hexatonic ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_pentatonic ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] def test_enigmatic ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( Scale ( [string] ) . interval ( [string] ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from list_ops import append , concat [EOL] from list_ops import filter as list_ops_filter [EOL] from list_ops import foldl , foldr , length [EOL] from list_ops import map as list_ops_map [EOL] from list_ops import reverse [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ListOpsTest ( unittest . TestCase ) : [EOL] def test_append_empty_lists ( self ) : [EOL] self . assertEqual ( append ( [ ] , [ ] ) , [ ] ) [EOL] [EOL] def test_append_list_to_empty_list ( self ) : [EOL] self . assertEqual ( append ( [ ] , [ [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_append_non_empty_lists ( self ) : [EOL] self . assertEqual ( append ( [ [number] , [number] ] , [ [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_concat_empty_list ( self ) : [EOL] self . assertEqual ( concat ( [ ] ) , [ ] ) [EOL] [EOL] def test_concat_list_of_lists ( self ) : [EOL] self . assertEqual ( concat ( [ [ [number] , [number] ] , [ [number] ] , [ ] , [ [number] , [number] , [number] ] ] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_concat_list_of_nested_lists ( self ) : [EOL] self . assertEqual ( concat ( [ [ [ [number] ] , [ [number] ] ] , [ [ [number] ] ] , [ [ ] ] , [ [ [number] , [number] , [number] ] ] ] ) , [ [ [number] ] , [ [number] ] , [ [number] ] , [ ] , [ [number] , [number] , [number] ] ] , ) [EOL] [EOL] def test_filter_empty_list ( self ) : [EOL] self . assertEqual ( list_ops_filter ( lambda x : x % [number] == [number] , [ ] ) , [ ] ) [EOL] [EOL] def test_filter_non_empty_list ( self ) : [EOL] self . assertEqual ( list_ops_filter ( lambda x : x % [number] == [number] , [ [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_length_empty_list ( self ) : [EOL] self . assertEqual ( length ( [ ] ) , [number] ) [EOL] [EOL] def test_length_non_empty_list ( self ) : [EOL] self . assertEqual ( length ( [ [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_map_empty_list ( self ) : [EOL] self . assertEqual ( list_ops_map ( lambda x : x + [number] , [ ] ) , [ ] ) [EOL] [EOL] def test_map_non_empty_list ( self ) : [EOL] self . assertEqual ( list_ops_map ( lambda x : x + [number] , [ [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_foldl_empty_list ( self ) : [EOL] self . assertEqual ( foldl ( lambda x , y : x * y , [ ] , [number] ) , [number] ) [EOL] [EOL] def test_foldl_direction_independent_function_applied_to_non_empty_list ( self ) : [EOL] self . assertEqual ( foldl ( lambda x , y : x + y , [ [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_foldl_direction_dependent_function_applied_to_non_empty_list ( self ) : [EOL] self . assertEqual ( foldl ( lambda x , y : x // y , [ [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_foldr_empty_list ( self ) : [EOL] self . assertEqual ( foldr ( lambda x , y : x * y , [ ] , [number] ) , [number] ) [EOL] [EOL] def test_foldr_direction_independent_function_applied_to_non_empty_list ( self ) : [EOL] self . assertEqual ( foldr ( lambda x , y : x + y , [ [number] , [number] , [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_foldr_direction_dependent_function_applied_to_non_empty_list ( self ) : [EOL] self . assertEqual ( foldr ( lambda x , y : x // y , [ [number] , [number] ] , [number] ) , [number] ) [EOL] [EOL] def test_reverse_empty_list ( self ) : [EOL] self . assertEqual ( reverse ( [ ] ) , [ ] ) [EOL] [EOL] def test_reverse_non_empty_list ( self ) : [EOL] self . assertEqual ( reverse ( [ [number] , [number] , [number] , [number] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_reverse_list_of_lists_is_not_flattened ( self ) : [EOL] self . assertEqual ( reverse ( [ [ [number] , [number] ] , [ [number] ] , [ ] , [ [number] , [number] , [number] ] ] ) , [ [ [number] , [number] , [number] ] , [ ] , [ [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_foldr_foldr_add_string ( self ) : [EOL] self . assertEqual ( foldr ( lambda x , y : x + y , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [string] ) , [string] , ) [EOL] [EOL] def test_reverse_reverse_mixed_types ( self ) : [EOL] self . assertEqual ( reverse ( [ [string] , [number] , [string] , [number] ] ) , [ [number] , [string] , [number] , [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Union , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Any , Callable , List , Union [EOL] [EOL] [EOL] def append ( list1 , list2 ) : [EOL] return list1 + list2 [EOL] [EOL] [EOL] def concat ( lists ) : [EOL] return sum ( lists , [ ] ) [EOL] [EOL] [EOL] def filter ( function , list ) : [EOL] return [ element for element in list if function ( element ) ] [EOL] [EOL] [EOL] def length ( list ) : [EOL] return len ( list ) [EOL] [EOL] [EOL] def map ( function , list ) : [EOL] return [ function ( element ) for element in list ] [EOL] [EOL] [EOL] def foldl ( function , list , initial ) : [EOL] if not list : [EOL] return initial [EOL] return foldl ( function , list [ [number] : ] , function ( initial , list [ [number] ] ) ) [EOL] [EOL] [EOL] def foldr ( function , list , initial ) : [EOL] if not list : [EOL] return initial [EOL] return foldr ( function , list [ : - [number] ] , function ( list [ - [number] ] , initial ) ) [EOL] [EOL] [EOL] def reverse ( list ) : [EOL] return list [ : : - [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from two_bucket import measure [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class TwoBucketTest ( unittest . TestCase ) : [EOL] def test_measure_using_bucket_one_of_size_3_and_bucket_two_of_size_5_start_with_bucket_one ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] def test_measure_using_bucket_one_of_size_3_and_bucket_two_of_size_5_start_with_bucket_two ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] def test_measure_using_bucket_one_of_size_7_and_bucket_two_of_size_11_start_with_bucket_one ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] def test_measure_using_bucket_one_of_size_7_and_bucket_two_of_size_11_start_with_bucket_two ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] def test_measure_one_step_using_bucket_one_of_size_1_and_bucket_two_of_size_3_start_with_bucket_two ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] def test_measure_using_bucket_one_of_size_2_and_bucket_two_of_size_3_start_with_bucket_one_and_end_with_bucket_two ( self , ) : [EOL] self . assertEqual ( measure ( [number] , [number] , [number] , [string] ) , ( [number] , [string] , [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def measure ( bucket_one , bucket_two , goal , start_bucket ) : [EOL] pass [EOL]	0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from triangle import is_equilateral , is_isosceles , is_scalene [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class is_equilateralTests ( unittest . TestCase ) : [EOL] def test_true_if_all_sides_are_equal ( self ) : [EOL] self . assertIs ( is_equilateral ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_false_if_any_side_is_unequal ( self ) : [EOL] self . assertIs ( is_equilateral ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_false_if_no_sides_are_equal ( self ) : [EOL] self . assertIs ( is_equilateral ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_false_if_all_sides_are_zero ( self ) : [EOL] self . assertIs ( is_equilateral ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_sides_may_be_floats ( self ) : [EOL] self . assertIs ( is_equilateral ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] [EOL] class is_isoscelesTests ( unittest . TestCase ) : [EOL] def test_true_if_last_two_sides_are_equal ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_true_if_first_two_sides_are_equal ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_true_if_first_and_last_sides_are_equal ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_is_equilateral_triangles_are_also_is_isosceles ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_false_if_no_sides_are_equal ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_violation_of_triangle_inequality_is_not_isosceles_1 ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_violation_of_triangle_inequality_is_not_isosceles_2 ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_violation_of_triangle_inequality_is_not_isosceles_3 ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_sides_may_be_floats ( self ) : [EOL] self . assertIs ( is_isosceles ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] [EOL] class is_scaleneTests ( unittest . TestCase ) : [EOL] def test_true_if_no_sides_are_equal ( self ) : [EOL] self . assertIs ( is_scalene ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] def test_false_if_all_sides_are_equal ( self ) : [EOL] self . assertIs ( is_scalene ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_false_if_two_sides_are_equal ( self ) : [EOL] self . assertIs ( is_scalene ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_violation_of_triangle_inequality_not_is_scalene ( self ) : [EOL] self . assertIs ( is_scalene ( [ [number] , [number] , [number] ] ) , False ) [EOL] [EOL] def test_sides_may_be_floats ( self ) : [EOL] self . assertIs ( is_scalene ( [ [number] , [number] , [number] ] ) , True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List , Union [EOL] [EOL] [EOL] def is_triangle ( sides ) : [EOL] [docstring] [EOL] return min ( sides ) > [number] and sum ( sides ) > [number] * max ( sides ) [EOL] [EOL] [EOL] def is_equilateral ( sides ) : [EOL] [docstring] [EOL] return is_triangle ( sides ) and min ( sides ) == max ( sides ) [EOL] [EOL] [EOL] def is_isosceles ( sides ) : [EOL] [docstring] [EOL] return is_triangle ( sides ) and not is_scalene ( sides ) [EOL] [EOL] [EOL] def is_scalene ( sides ) : [EOL] [docstring] [EOL] return is_triangle ( sides ) and ( len ( set ( sides ) ) == [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from string import ascii_lowercase , ascii_uppercase [EOL] from typing import Optional [EOL] [EOL] [EOL] def rotate ( text , key ) : [EOL] [docstring] [EOL] double_alphabet = ascii_lowercase * [number] + ascii_uppercase * [number] [EOL] return [string] . join ( [ double_alphabet [ double_alphabet . index ( ch ) + key ] if ch . isalpha ( ) else ch for ch in text ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from rotational_cipher import rotate [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RotationalCipherTest ( unittest . TestCase ) : [EOL] def test_rotate_a_by_0_same_output_as_input ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_a_by_1 ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_a_by_26_same_output_as_input ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_m_by_13 ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_n_by_13_with_wrap_around_alphabet ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_capital_letters ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_spaces ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_numbers ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_punctuation ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] ) [EOL] [EOL] def test_rotate_all_letters ( self ) : [EOL] self . assertEqual ( rotate ( [string] , [number] ) , [string] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from book_store import total [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BookStoreTest ( unittest . TestCase ) : [EOL] def test_only_a_single_book ( self ) : [EOL] basket = [ [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_of_the_same_book ( self ) : [EOL] basket = [ [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_empty_basket ( self ) : [EOL] basket = [ ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_different_books ( self ) : [EOL] basket = [ [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_three_different_books ( self ) : [EOL] basket = [ [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_four_different_books ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_five_different_books ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_groups_of_four_is_cheaper_than_group_of_five_plus_group_of_three ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_groups_of_four_is_cheaper_than_groups_of_five_and_three ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_group_of_four_plus_group_of_two_is_cheaper_than_two_groups_of_three ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_each_of_first_4_books_and_1_copy_each_of_rest ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_two_copies_of_each_book ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_three_copies_of_first_book_and_2_each_of_remaining ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_three_each_of_first_2_books_and_2_each_of_remaining_books ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_four_groups_of_four_are_cheaper_than_two_groups_each_of_five_and_three ( self , ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] [comment] [EOL] [EOL] def test_two_groups_of_four_and_a_group_of_five ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] def test_shuffled_book_order ( self ) : [EOL] basket = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] self . assertEqual ( total ( basket ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import datetime [EOL] from calendar import monthrange [EOL] [EOL] [EOL] def next_weekday ( day , weekday ) : [EOL] [docstring] [EOL] days_ahead = weekday - day . weekday ( ) [EOL] if days_ahead < [number] : [EOL] days_ahead += [number] [EOL] return day + datetime . timedelta ( days_ahead ) [EOL] [EOL] [EOL] def meetup ( year , month , which , day_of_the_week ) : [EOL] [docstring] [EOL] last_day_of_month = monthrange ( year , month ) [ [number] ] [EOL] days_of_the_week = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] start_days = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : last_day_of_month - [number] , } [EOL] if start_days [ which ] > last_day_of_month : [EOL] raise MeetupDayException ( [string] ) [EOL] start = datetime . date ( year , month , start_days [ which ] ) [EOL] chosen_day = next_weekday ( start , days_of_the_week [ day_of_the_week ] ) [EOL] if chosen_day . month != month : [EOL] raise MeetupDayException ( [string] ) [EOL] return chosen_day [EOL] [EOL] [EOL] class MeetupDayException ( Exception ) : [EOL] [docstring] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.date$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] from datetime import date [EOL] [EOL] from meetup import MeetupDayException , meetup [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MeetupTest ( unittest . TestCase ) : [EOL] def test_monteenth_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_monteenth_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_monteenth_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_tuesteenth_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_tuesteenth_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_tuesteenth_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_wednesteenth_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_wednesteenth_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_wednesteenth_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_thursteenth_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_thursteenth_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_thursteenth_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_friteenth_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_friteenth_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_friteenth_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_saturteenth_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_saturteenth_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_saturteenth_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_sunteenth_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_sunteenth_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_sunteenth_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_monday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_monday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_tuesday_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_tuesday_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_wednesday_of_july_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_wednesday_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_thursday_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_thursday_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_friday_of_november_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_friday_of_december_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_saturday_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_saturday_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_sunday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_sunday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_monday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_monday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_tuesday_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_tuesday_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_wednesday_of_july_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_wednesday_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_thursday_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_thursday_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_friday_of_november_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_friday_of_december_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_saturday_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_saturday_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_sunday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_second_sunday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_monday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_monday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_tuesday_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_tuesday_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_wednesday_of_july_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_wednesday_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_thursday_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_thursday_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_friday_of_november_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_friday_of_december_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_saturday_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_saturday_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_sunday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_third_sunday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_monday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_monday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_tuesday_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_tuesday_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_wednesday_of_july_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_wednesday_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_thursday_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_thursday_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_friday_of_november_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_friday_of_december_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_saturday_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_saturday_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_sunday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_fourth_sunday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_monday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_monday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_tuesday_of_may_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_tuesday_of_june_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_wednesday_of_july_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_wednesday_of_august_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_thursday_of_september_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_thursday_of_october_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_friday_of_november_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_friday_of_december_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_saturday_of_january_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_saturday_of_february_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_sunday_of_march_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_sunday_of_april_2013 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_wednesday_of_february_2012 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_wednesday_of_december_2014 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_last_sunday_of_february_2015 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_first_friday_of_december_2012 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] def test_fifth_monday_of_march_2015 ( self ) : [EOL] self . assertEqual ( meetup ( [number] , [number] , [string] , [string] ) , date ( [number] , [number] , [number] ) ) [EOL] [EOL] def test_nonexistent_fifth_monday_of_february_2015 ( self ) : [EOL] with self . assertRaisesWithMessage ( MeetupDayException ) : [EOL] meetup ( [number] , [number] , [string] , [string] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from forth import StackUnderflowError , evaluate [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ForthTest ( unittest . TestCase ) : [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] class ParsingAndNumbersTest ( ForthTest ) : [EOL] def test_numbers_just_get_pushed_onto_the_stack ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [EOL] class AdditionTest ( ForthTest ) : [EOL] def test_can_add_two_numbers ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class SubtractionTest ( ForthTest ) : [EOL] def test_can_subtract_two_numbers ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ - [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class MultiplicationTest ( ForthTest ) : [EOL] def test_can_multiply_two_numbers ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class DivisionTest ( ForthTest ) : [EOL] def test_can_divide_two_numbers ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_performs_integer_division ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_errors_if_dividing_by_zero ( self ) : [EOL] [comment] [EOL] with self . assertRaisesWithMessage ( ZeroDivisionError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class CombinedArithmeticTest ( ForthTest ) : [EOL] def test_addition_and_subtraction ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ - [number] ] ) [EOL] [EOL] def test_multiplication_and_division ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] [EOL] class DupTest ( ForthTest ) : [EOL] def test_copies_a_value_on_the_stack ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_copies_the_top_value_on_the_stack ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class DropTest ( ForthTest ) : [EOL] def test_removes_the_top_value_on_the_stack_if_it_is_the_only_one ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ ] ) [EOL] [EOL] def test_removes_the_top_value_on_the_stack_if_it_is_not_the_only_one ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class SwapTest ( ForthTest ) : [EOL] def test_swaps_the_top_two_values_on_the_stack_if_they_are_the_only_ones ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_swaps_the_top_two_values_on_the_stack_if_they_are_not_the_only_ones ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class OverTest ( ForthTest ) : [EOL] def test_copies_the_second_element_if_there_are_only_two ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_copies_the_second_element_if_there_are_more_than_two ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_errors_if_there_is_nothing_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_there_is_only_one_value_on_the_stack ( self ) : [EOL] with self . assertRaisesWithMessage ( StackUnderflowError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class UserDefinedWordsTest ( ForthTest ) : [EOL] def test_can_consist_of_built_in_words ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_execute_in_the_right_order ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_can_override_other_user_defined_words ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] , [string] ] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_can_override_built_in_words ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_can_override_built_in_operators ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_can_use_different_words_with_the_same_name ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] , [string] , [string] ] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_can_define_word_that_uses_word_with_the_same_name ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] , [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_cannot_redefine_numbers ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] def test_errors_if_executing_a_non_existent_word ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] evaluate ( [ [string] ] ) [EOL] [EOL] [EOL] class CaseInsensitivityTest ( ForthTest ) : [EOL] def test_dup_is_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_drop_is_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] ] ) [EOL] [EOL] def test_swap_is_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_over_is_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] ] ) , [ [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_user_defined_words_are_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_definitions_are_case_insensitive ( self ) : [EOL] self . assertEqual ( evaluate ( [ [string] , [string] ] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Callable , Union , Dict , Any , List [EOL] import typing [EOL] import builtins [EOL] import operator [EOL] from operator import add , floordiv , mul , sub [EOL] from typing import List [EOL] [EOL] OPERATOR_DICT = { [string] : add , [string] : sub , [string] : floordiv , [string] : mul } [EOL] [EOL] [EOL] class StackUnderflowError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def update_stack ( stack , element ) : [EOL] check_minimum_elements = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] if element in check_minimum_elements : [EOL] if len ( stack ) < check_minimum_elements [ element ] : [EOL] raise StackUnderflowError ( [string] ) [EOL] if element . isdigit ( ) : [EOL] stack . append ( int ( element ) ) [EOL] elif element == [string] : [EOL] stack . append ( stack [ - [number] ] ) [EOL] elif element == [string] : [EOL] stack [ - [number] ] , stack [ - [number] ] = stack [ - [number] ] , stack [ - [number] ] [EOL] elif element == [string] : [EOL] stack . pop ( ) [EOL] elif element == [string] : [EOL] stack . append ( stack [ - [number] ] ) [EOL] elif element in [string] : [EOL] stack = stack [ : - [number] ] + [ OPERATOR_DICT [ element ] ( stack [ - [number] ] , stack [ - [number] ] ) ] [EOL] else : [EOL] raise ValueError ( [string] ) [EOL] return stack [EOL] [EOL] [EOL] def evaluate ( input_data ) : [EOL] commands = [ command . lower ( ) . split ( ) for command in input_data ] [EOL] stack = [ ] [EOL] user_defined_words = { } [EOL] for command in commands [ : - [number] ] : [EOL] if command [ [number] ] . isdigit ( ) : [EOL] raise ValueError ( [string] ) [EOL] sub_command = [ ] [EOL] for element in command [ [number] : - [number] ] : [EOL] if element in user_defined_words : [EOL] sub_command = sub_command + user_defined_words [ element ] [EOL] else : [EOL] sub_command . append ( element ) [EOL] user_defined_words [ command [ [number] ] ] = sub_command [EOL] for element in commands [ - [number] ] : [EOL] if element in user_defined_words : [EOL] for sub_element in user_defined_words [ element ] : [EOL] stack = update_stack ( stack , sub_element ) [EOL] else : [EOL] stack = update_stack ( stack , element ) [EOL] return stack [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from bob import response [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BobTest ( unittest . TestCase ) : [EOL] def test_stating_something ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_shouting ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_shouting_gibberish ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_asking_a_question ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_asking_a_numeric_question ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_asking_gibberish ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_talking_forcefully ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_using_acronyms_in_regular_speech ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_forceful_question ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_shouting_numbers ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_no_letters ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_question_with_no_letters ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_shouting_with_special_characters ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] , ) [EOL] [EOL] def test_shouting_with_no_exclamation_mark ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_statement_containing_question_mark ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_non_letters_with_question ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_prattling_on ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_silence ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_prolonged_silence ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_alternate_silence ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_multiple_line_question ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] , ) [EOL] [EOL] def test_starting_with_whitespace ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_ending_with_whitespace ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_other_whitespace ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] def test_non_question_ending_with_whitespace ( self ) : [EOL] self . assertEqual ( response ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] [EOL] [EOL] def response ( phrase ) : [EOL] [docstring] [EOL] phrase = phrase . rstrip ( ) [EOL] if phrase == [string] : [EOL] return [string] [EOL] is_question = phrase [ - [number] ] == [string] [EOL] is_yelling = phrase == phrase . upper ( ) and any ( c . isalpha ( ) for c in phrase ) [EOL] if is_question and is_yelling : [EOL] return [string] [EOL] if is_question : [EOL] return [string] [EOL] if is_yelling : [EOL] return [string] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from sum_of_multiples import sum_of_multiples [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SumOfMultiplesTest ( unittest . TestCase ) : [EOL] def test_no_multiples_within_limit ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_one_factor_has_multiples_within_limit ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_more_than_one_multiple_within_limit ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] ] ) , [number] ) [EOL] [EOL] def test_more_than_one_factor_with_multiples_within_limit ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_each_multiple_is_only_counted_once ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_a_much_larger_limit ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_three_factors ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_factors_not_relatively_prime ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_some_pairs_of_factors_relatively_prime_and_some_not ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_one_factor_is_a_multiple_of_another ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_much_larger_factors ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_all_numbers_are_multiples_of_1 ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] ] ) , [number] ) [EOL] [EOL] def test_no_factors_means_an_empty_sum ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ ] ) , [number] ) [EOL] [EOL] def test_the_only_multiple_of_0_is_0 ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] ] ) , [number] ) [EOL] [EOL] def test_the_factor_0_does_not_affect_the_sum_of_multiples_of_other_factors ( self ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] ] ) , [number] ) [EOL] [EOL] def test_solutions_using_include_exclude_must_extend_to_cardinality_greater_than_3 ( self , ) : [EOL] self . assertEqual ( sum_of_multiples ( [number] , [ [number] , [number] , [number] , [number] , [number] ] ) , [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def sum_of_multiples ( limit , multiples ) : [EOL] [docstring] [EOL] if [number] in multiples : [EOL] multiples . remove ( [number] ) [EOL] return sum ( [ i for i in range ( limit ) if any ( i % j == [number] for j in multiples ) ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] def rebase ( input_base , digits , output_base ) : [EOL] [docstring] [EOL] if input_base <= [number] or output_base <= [number] : [EOL] raise ValueError ( [string] ) [EOL] if digits : [EOL] if min ( digits ) < [number] : [EOL] raise ValueError ( [string] ) [EOL] if max ( digits ) >= input_base : [EOL] raise ValueError ( [string] ) [EOL] return dec2base ( base2dec ( input_base , digits ) , output_base ) [ : : - [number] ] or [ [number] ] [EOL] [EOL] [EOL] def base2dec ( input_base , digits ) : [EOL] [docstring] [EOL] if not digits : [EOL] return [number] [EOL] return input_base * base2dec ( input_base , digits [ : - [number] ] ) + digits [ - [number] ] [EOL] [EOL] [EOL] def dec2base ( number , output_base ) : [EOL] [docstring] [EOL] if not number : [EOL] return [ ] [EOL] return [ number % output_base ] + dec2base ( number // output_base , output_base ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from all_your_base import rebase [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AllYourBaseTest ( unittest . TestCase ) : [EOL] def test_single_bit_one_to_decimal ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_binary_to_single_decimal ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_single_decimal_to_binary ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] ] , [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_binary_to_multiple_decimal ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_decimal_to_binary ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] ] , [number] ) , [ [number] , [number] , [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_trinary_to_hexadecimal ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_hexadecimal_to_trinary ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] ] , [number] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_15_bit_integer ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] ] , [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_empty_list ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_single_zero ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_multiple_zeros ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] ] , [number] ) , [ [number] ] ) [EOL] [EOL] def test_leading_zeros ( self ) : [EOL] self . assertEqual ( rebase ( [number] , [ [number] , [number] , [number] ] , [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_input_base_is_one ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] ] , [number] ) [EOL] [EOL] def test_input_base_is_zero ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ ] , [number] ) [EOL] [EOL] def test_input_base_is_negative ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( - [number] , [ [number] ] , [number] ) [EOL] [EOL] def test_negative_digit ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] , - [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_invalid_positive_digit ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_output_base_is_one ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] , [number] , [number] , [number] , [number] , [number] ] , [number] ) [EOL] [EOL] def test_output_base_is_zero ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] ] , [number] ) [EOL] [EOL] def test_output_base_is_negative ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( [number] , [ [number] ] , - [number] ) [EOL] [EOL] def test_both_bases_are_negative ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] rebase ( - [number] , [ [number] ] , - [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def proteins ( strand ) : [EOL] [docstring] [EOL] codons = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] protein_strand = [ codons [ strand [ i : i + [number] ] ] for i in range ( [number] , len ( strand ) , [number] ) ] [EOL] return protein_strand [ : None if [string] not in protein_strand else protein_strand . index ( [string] ) ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from protein_translation import proteins [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ProteinTranslationTest ( unittest . TestCase ) : [EOL] def test_AUG_translates_to_methionine ( self ) : [EOL] self . assertEqual ( proteins ( [string] ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Phenylalanine_codons ( self ) : [EOL] for codon in [ [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Leucine_codons ( self ) : [EOL] for codon in [ [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Serine_codons ( self ) : [EOL] for codon in [ [string] , [string] , [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Tyrosine_codons ( self ) : [EOL] for codon in [ [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Cysteine_codons ( self ) : [EOL] for codon in [ [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ [string] ] ) [EOL] [EOL] def test_identifies_Tryptophan_codons ( self ) : [EOL] self . assertEqual ( proteins ( [string] ) , [ [string] ] ) [EOL] [EOL] def test_identifies_stop_codons ( self ) : [EOL] for codon in [ [string] , [string] , [string] ] : [EOL] self . assertEqual ( proteins ( codon ) , [ ] ) [EOL] [EOL] def test_translates_rna_strand_into_correct_protein_list ( self ) : [EOL] strand = [string] [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] def test_stops_translation_if_stop_codon_at_beginning_of_sequence ( self ) : [EOL] strand = [string] [EOL] expected = [ ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] def test_stops_translation_if_stop_codon_at_end_of_two_codon_sequence ( self ) : [EOL] strand = [string] [EOL] expected = [ [string] ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] def test_stops_translation_if_stop_codon_at_end_of_three_codon_sequence ( self ) : [EOL] strand = [string] [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] def test_stops_translation_if_stop_codon_in_middle_of_three_codon_sequence ( self ) : [EOL] strand = [string] [EOL] expected = [ [string] ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] def test_stops_translation_if_stop_codon_in_middle_of_six_codon_sequence ( self ) : [EOL] strand = [string] [EOL] expected = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( proteins ( strand ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from poker import best_hands [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PokerTest ( unittest . TestCase ) : [EOL] def test_single_hand_always_wins ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_highest_card_out_of_all_hands_wins ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] , [string] ] ) , [ [string] ] , ) [EOL] [EOL] def test_a_tie_has_multiple_winners ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] , [string] , [string] , ] ) , [ [string] , [string] ] , ) [EOL] [EOL] def test_multiple_hands_with_the_same_high_cards_tie_compares_next_highest_ranked_down_to_last_card ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_one_pair_beats_high_card ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_highest_pair_wins ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_two_pairs_beats_one_pair ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_two_pairs_highest_ranked_pair_wins ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_two_pairs_with_the_same_highest_ranked_pair_tie_goes_to_low_pair ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_two_identically_ranked_pairs_tie_goes_to_remaining_card_kicker ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_three_of_a_kind_beats_two_pair ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_three_of_a_kind_tie_goes_to_highest_ranked_triplet ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_with_multiple_decks_two_players_can_have_same_three_of_a_kind_ties_go_to_highest_remaining_cards ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_a_straight_beats_three_of_a_kind ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_aces_can_end_a_straight_10_j_q_k_a ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_aces_can_start_a_straight_a_2_3_4_5 ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_with_a_straight_tie_goes_to_highest_ranked_card ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_even_though_an_ace_is_usually_high_a_5_high_straight_is_the_lowest_scoring_straight ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_flush_beats_a_straight ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_a_flush_tie_goes_to_high_card_down_to_the_last_one_if_necessary ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_full_house_beats_a_flush ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_a_full_house_tie_goes_to_highest_ranked_triplet ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_with_multiple_decks_both_hands_have_a_full_house_with_the_same_triplet_tie_goes_to_the_pair ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_four_of_a_kind_beats_a_full_house ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_four_of_a_kind_tie_goes_to_high_quad ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_with_multiple_decks_both_hands_with_identical_four_of_a_kind_tie_determined_by_kicker ( self , ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_straight_flush_beats_four_of_a_kind ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_both_hands_have_straight_flush_tie_goes_to_highest_ranked_card ( self ) : [EOL] self . assertEqual ( best_hands ( [ [string] , [string] ] ) , [ [string] ] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple , Counter , Dict [EOL] import typing [EOL] import builtins [EOL] import collections [EOL] [docstring] [EOL] [EOL] from collections import Counter [EOL] from typing import List , Tuple [EOL] [EOL] CARD_VALUE = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] ( HIGH_CARD , ONE_PAIR , TWO_PAIR , THREE_OF_A_KIND , STRAIGHT , FLUSH , FULL_HOUSE , FOUR_OF_A_KIND , STRAIGHT_FLUSH , ) = range ( [number] ) [EOL] [EOL] [EOL] def parse_hand ( hand ) : [EOL] [docstring] [EOL] numbers = [ int ( card [ : - [number] ] ) if card [ : - [number] ] . isdigit ( ) else CARD_VALUE [ card [ : - [number] ] ] for card in hand . split ( ) ] [EOL] suits = [ card [ - [number] ] for card in hand . split ( ) ] [EOL] return numbers , suits [EOL] [EOL] [EOL] def find_best_type ( hand ) : [EOL] [docstring] [EOL] numbers , suits = parse_hand ( hand ) [EOL] numbers = sorted ( numbers , reverse = True ) [EOL] counter = Counter ( numbers ) [EOL] if len ( counter ) <= [number] : [EOL] most_common_cards = counter . most_common ( [number] ) [EOL] numbers = [ [ card [ [number] ] for _ in range ( card [ [number] ] ) ] for card in most_common_cards ] [EOL] numbers = [ card if card > [number] else [number] for sublist in numbers for card in sublist ] [EOL] most_common_quantities = [ i [ [number] ] for i in most_common_cards ] [EOL] if most_common_quantities == [ [number] , [number] ] : [EOL] return ( FOUR_OF_A_KIND , numbers ) [EOL] if most_common_quantities == [ [number] , [number] ] : [EOL] return ( FULL_HOUSE , numbers ) [EOL] elif most_common_quantities == [ [number] , [number] , [number] ] : [EOL] return ( THREE_OF_A_KIND , numbers ) [EOL] elif most_common_quantities == [ [number] , [number] , [number] ] : [EOL] return ( TWO_PAIR , numbers ) [EOL] elif most_common_quantities == [ [number] , [number] , [number] , [number] ] : [EOL] return ( ONE_PAIR , numbers ) [EOL] straight = numbers == list ( range ( numbers [ [number] ] , numbers [ [number] ] - [number] , - [number] ) ) [EOL] if [number] in numbers and not straight : [EOL] numbers = [ [number] ] + numbers [ : - [number] ] [EOL] straight = numbers == list ( range ( numbers [ [number] ] , numbers [ [number] ] - [number] , - [number] ) ) [EOL] flush = len ( set ( suits ) ) == [number] [EOL] if straight and flush : [EOL] return ( STRAIGHT_FLUSH , numbers ) [EOL] if straight : [EOL] return ( STRAIGHT , numbers ) [EOL] if flush : [EOL] return ( FLUSH , numbers ) [EOL] return ( HIGH_CARD , numbers ) [EOL] [EOL] [EOL] def best_hands ( hands ) : [EOL] [docstring] [EOL] best_hand_types = [ find_best_type ( hand ) for hand in hands ] [EOL] best_hand = [ hand for index , hand in enumerate ( hands ) if best_hand_types [ index ] == max ( enumerate ( best_hand_types ) , key = lambda x : x [ [number] ] ) [ [number] ] ] [EOL] return best_hand [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from run_length_encoding import decode , encode [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RunLengthEncodingTest ( unittest . TestCase ) : [EOL] def test_encode_empty_string ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] ) [EOL] [EOL] def test_encode_single_characters_only_are_encoded_without_count ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] ) [EOL] [EOL] def test_encode_string_with_no_single_characters ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] ) [EOL] [EOL] def test_encode_single_characters_mixed_with_repeated_characters ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] , ) [EOL] [EOL] def test_encode_multiple_whitespace_mixed_in_string ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] ) [EOL] [EOL] def test_encode_lowercase_characters ( self ) : [EOL] self . assertMultiLineEqual ( encode ( [string] ) , [string] ) [EOL] [EOL] def test_decode_empty_string ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] ) [EOL] [EOL] def test_decode_single_characters_only ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] ) [EOL] [EOL] def test_decode_string_with_no_single_characters ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] ) [EOL] [EOL] def test_decode_single_characters_with_repeated_characters ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] , ) [EOL] [EOL] def test_decode_multiple_whitespace_mixed_in_string ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] ) [EOL] [EOL] def test_decode_lower_case_string ( self ) : [EOL] self . assertMultiLineEqual ( decode ( [string] ) , [string] ) [EOL] [EOL] def test_encode_followed_by_decode_gives_original_string ( self ) : [EOL] self . assertMultiLineEqual ( decode ( encode ( [string] ) ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] from itertools import groupby [EOL] [EOL] [EOL] def decode ( string ) : [EOL] [docstring] [EOL] counter , result = [number] , [string] [EOL] for is_digit , group in groupby ( string , str . isdigit ) : [EOL] if is_digit : [EOL] counter = int ( [string] . join ( group ) ) [EOL] else : [EOL] result = result + counter * next ( group ) + [string] . join ( group ) [EOL] return result [EOL] [EOL] [EOL] def encode_one_char ( char , counter ) : [EOL] [docstring] [EOL] if counter > [number] : [EOL] return str ( counter ) + char [EOL] return char [EOL] [EOL] [EOL] def encode ( string ) : [EOL] [docstring] [EOL] return [string] . join ( encode_one_char ( k , len ( list ( g ) ) ) for k , g in groupby ( string ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import Dict , List [EOL] [EOL] [EOL] def transform ( legacy_data ) : [EOL] [docstring] [EOL] return { letter . lower ( ) : score for score , letters in legacy_data . items ( ) for letter in letters } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] from etl import transform [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class EtlTest ( unittest . TestCase ) : [EOL] def test_single_letter ( self ) : [EOL] legacy_data = { [number] : [ [string] ] } [EOL] data = { [string] : [number] } [EOL] self . assertEqual ( transform ( legacy_data ) , data ) [EOL] [EOL] def test_single_score_with_multiple_letters ( self ) : [EOL] legacy_data = { [number] : [ [string] , [string] , [string] , [string] , [string] ] } [EOL] data = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] self . assertEqual ( transform ( legacy_data ) , data ) [EOL] [EOL] def test_multiple_scores_with_multiple_letters ( self ) : [EOL] legacy_data = { [number] : [ [string] , [string] ] , [number] : [ [string] , [string] ] } [EOL] data = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] self . assertEqual ( transform ( legacy_data ) , data ) [EOL] [EOL] def test_multiple_scores_with_differing_numbers_of_letters ( self ) : [EOL] legacy_data = { [number] : [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] , [number] : [ [string] , [string] ] , [number] : [ [string] , [string] , [string] , [string] ] , [number] : [ [string] , [string] , [string] , [string] , [string] ] , [number] : [ [string] ] , [number] : [ [string] , [string] ] , [number] : [ [string] , [string] ] , } [EOL] data = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] , } [EOL] self . assertEqual ( transform ( legacy_data ) , data ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,typing.List[builtins.str]]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from diamond import rows [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class DiamondTest ( unittest . TestCase ) : [EOL] def test_degenerate_case_with_a_single_a_row ( self ) : [EOL] result = [ [string] ] [EOL] self . assertEqual ( rows ( [string] ) , result ) [EOL] [EOL] def test_degenerate_case_with_no_row_containing_3_distinct_groups_of_spaces ( self ) : [EOL] result = [ [string] , [string] , [string] ] [EOL] self . assertEqual ( rows ( [string] ) , result ) [EOL] [EOL] def test_smallest_non_degenerate_case_with_odd_diamond_side_length ( self ) : [EOL] result = [ [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( rows ( [string] ) , result ) [EOL] [EOL] def test_smallest_non_degenerate_case_with_even_diamond_side_length ( self ) : [EOL] result = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( rows ( [string] ) , result ) [EOL] [EOL] def test_largest_possible_diamond ( self ) : [EOL] result = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( rows ( [string] ) , result ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from palindrome_products import largest , smallest [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PalindromeProductsTest ( unittest . TestCase ) : [EOL] def test_finds_the_smallest_palindrome_from_single_digit_factors ( self ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_finds_the_largest_palindrome_from_single_digit_factors ( self ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] , [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_the_smallest_palindrome_from_double_digit_factors ( self ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_the_largest_palindrome_from_double_digit_factors ( self ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_smallest_palindrome_from_triple_digit_factors ( self ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_the_largest_palindrome_from_triple_digit_factors ( self ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_smallest_palindrome_from_four_digit_factors ( self ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_find_the_largest_palindrome_from_four_digit_factors ( self ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertEqual ( value , [number] ) [EOL] self . assertFactorsEqual ( factors , [ [ [number] , [number] ] ] ) [EOL] [EOL] def test_empty_result_for_smallest_if_no_palindrome_in_the_range ( self ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertIsNone ( value ) [EOL] self . assertFactorsEqual ( factors , [ ] ) [EOL] [EOL] def test_empty_result_for_largest_if_no_palindrome_in_the_range ( self ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] self . assertIsNone ( value ) [EOL] self . assertFactorsEqual ( factors , [ ] ) [EOL] [EOL] def test_error_result_for_smallest_if_min_is_more_than_max ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] value , factors = smallest ( min_factor = [number] , max_factor = [number] ) [EOL] [EOL] def test_error_result_for_largest_if_min_is_more_than_max ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] value , factors = largest ( min_factor = [number] , max_factor = [number] ) [EOL] [EOL] def assertFactorsEqual ( self , actual , expected ) : [EOL] self . assertEqual ( set ( map ( frozenset , actual ) ) , set ( map ( frozenset , expected ) ) ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] from satellite import tree_from_traversals [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class SatelliteTest ( unittest . TestCase ) : [EOL] def test_empty_tree ( self ) : [EOL] preorder = [ ] [EOL] inorder = [ ] [EOL] [EOL] expected = { } [EOL] self . assertEqual ( tree_from_traversals ( preorder , inorder ) , expected ) [EOL] [EOL] def test_tree_with_one_item ( self ) : [EOL] preorder = [ [string] ] [EOL] inorder = [ [string] ] [EOL] [EOL] expected = { [string] : [string] , [string] : { } , [string] : { } } [EOL] self . assertEqual ( tree_from_traversals ( preorder , inorder ) , expected ) [EOL] [EOL] def test_tree_with_many_items ( self ) : [EOL] preorder = [ [string] , [string] , [string] , [string] , [string] ] [EOL] inorder = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] expected = { [string] : [string] , [string] : { [string] : [string] , [string] : { } , [string] : { } } , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : { } , [string] : { } } , [string] : { [string] : [string] , [string] : { } , [string] : { } } , } , } [EOL] self . assertEqual ( tree_from_traversals ( preorder , inorder ) , expected ) [EOL] [EOL] def test_reject_traversals_of_different_length ( self ) : [EOL] preorder = [ [string] , [string] ] [EOL] inorder = [ [string] , [string] , [string] ] [EOL] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree_from_traversals ( preorder , inorder ) [EOL] [EOL] def test_reject_inconsistent_traversals_of_same_length ( self ) : [EOL] preorder = [ [string] , [string] , [string] ] [EOL] inorder = [ [string] , [string] , [string] ] [EOL] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree_from_traversals ( preorder , inorder ) [EOL] [EOL] def test_reject_traversals_with_repeated_items ( self ) : [EOL] preorder = [ [string] , [string] , [string] ] [EOL] inorder = [ [string] , [string] , [string] ] [EOL] [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] tree_from_traversals ( preorder , inorder ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] [EOL] def tree_from_traversals ( preorder , inorder ) : [EOL] [docstring] [EOL] if len ( preorder ) != len ( inorder ) : [EOL] raise ValueError ( [string] ) [EOL] if len ( preorder ) != len ( set ( preorder ) ) : [EOL] raise ValueError ( [string] ) [EOL] if not preorder : [EOL] return { } [EOL] root = preorder [ [number] ] [EOL] root_index = inorder . index ( root ) [EOL] [EOL] left_inorder = inorder [ : root_index ] [EOL] right_inorder = inorder [ root_index + [number] : ] [EOL] [EOL] left_preoder = preorder [ [number] : len ( left_inorder ) + [number] ] [EOL] right_preoder = preorder [ len ( left_inorder ) + [number] : ] [EOL] [EOL] left_tree = tree_from_traversals ( left_preoder , left_inorder ) [EOL] right_tree = tree_from_traversals ( right_preoder , right_inorder ) [EOL] [EOL] return { [string] : root , [string] : left_tree , [string] : right_tree } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import math [EOL] import sys [EOL] from functools import reduce [EOL] from typing import List [EOL] [EOL] sys . setrecursionlimit ( [number] ** [number] ) [EOL] [EOL] BOOK_COST = [number] [EOL] [EOL] [EOL] def optimal_cost ( book_quantities , discount_rate ) : [EOL] [docstring] [EOL] book_quantities = tuple ( [ book for book in sorted ( book_quantities , reverse = True ) if book > [number] ] ) [EOL] if not book_quantities : [EOL] return [number] [EOL] largest_gcd = reduce ( math . gcd , book_quantities ) [EOL] core_quantities = tuple ( [ quantity // largest_gcd for quantity in book_quantities ] ) [EOL] [EOL] min_cost = None [EOL] for i in range ( len ( core_quantities ) ) : [EOL] cost = ( i + [number] ) * BOOK_COST * ( [number] - discount_rate [ i ] ) [EOL] new_basket = [ book if index > i else book - [number] for index , book in enumerate ( core_quantities ) ] [EOL] cost = cost + optimal_cost ( new_basket , discount_rate ) [EOL] min_cost = min ( min_cost , cost ) if min_cost else cost [EOL] return min_cost * largest_gcd [EOL] [EOL] [EOL] def optimal_cost1 ( book_quantities , discount_rate ) : [EOL] [docstring] [EOL] book_quantities = tuple ( [ book for book in sorted ( book_quantities , reverse = True ) if book > [number] ] ) [EOL] if not book_quantities : [EOL] return [number] [EOL] min_cost = None [EOL] for i in range ( len ( book_quantities ) ) : [EOL] cost = ( i + [number] ) * BOOK_COST * ( [number] - discount_rate [ i ] ) [EOL] new_basket = [ book if index > i else book - [number] for index , book in enumerate ( book_quantities ) ] [EOL] cost = cost + optimal_cost1 ( new_basket , discount_rate ) [EOL] min_cost = min ( min_cost , cost ) if min_cost else cost [EOL] return min_cost [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from book_store_hard import optimal_cost , optimal_cost1 [EOL] from hypothesis import given , settings [EOL] from hypothesis . strategies import integers , lists [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BookStoreTest ( unittest . TestCase ) : [EOL] @ given ( list1 = lists ( integers ( min_value = [number] , max_value = [number] ) , min_size = [number] , max_size = [number] ) , list2 = lists ( integers ( min_value = [number] , max_value = [number] ) , min_size = [number] , max_size = [number] ) , ) @ settings ( deadline = None ) def test_two_methods ( self , list1 , list2 ) : [EOL] self . assertEqual ( optimal_cost ( list1 , [ [number] ] + sorted ( list2 ) ) , optimal_cost1 ( list1 , [ [number] ] + sorted ( list2 ) ) , ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from prime_factors import factors [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PrimeFactorsTest ( unittest . TestCase ) : [EOL] def test_no_factors ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ ] ) [EOL] [EOL] def test_prime_number ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] ] ) [EOL] [EOL] def test_square_of_a_prime ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] , [number] ] ) [EOL] [EOL] def test_cube_of_a_prime ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_product_of_primes_and_non_primes ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_product_of_primes ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] , [number] , [number] , [number] ] ) [EOL] [EOL] def test_factors_include_a_large_prime ( self ) : [EOL] self . assertEqual ( factors ( [number] ) , [ [number] , [number] , [number] ] ) [EOL] [EOL] def test_factors_include_a_very_large_prime ( self ) : [EOL] self . assertEqual ( factors ( [number] ** [number] ) , [ [number] ] * [number] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import math [EOL] from typing import List , Union [EOL] [EOL] [EOL] def factors ( natural_number ) : [EOL] [docstring] [EOL] i = [number] [EOL] prime_factors = [ ] [EOL] while natural_number % [number] == [number] : [EOL] prime_factors . append ( [number] ) [EOL] natural_number = natural_number / [number] [EOL] for i in range ( [number] , int ( math . sqrt ( natural_number ) ) + [number] , [number] ) : [EOL] while natural_number % i == [number] : [EOL] prime_factors . append ( i ) [EOL] natural_number = natural_number / i [EOL] if natural_number > [number] : [EOL] prime_factors . append ( natural_number ) [EOL] return prime_factors [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing.List[typing.Union[builtins.int,builtins.float]],typing.List[builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from dot_dsl import ATTR , EDGE , NODE , Edge , Graph , Node [EOL] [EOL] [EOL] class DotDslTest ( unittest . TestCase ) : [EOL] def test_empty_graph ( self ) : [EOL] g = Graph ( ) [EOL] [EOL] self . assertEqual ( g . nodes , [ ] ) [EOL] self . assertEqual ( g . edges , [ ] ) [EOL] self . assertEqual ( g . attrs , { } ) [EOL] [EOL] def test_graph_with_one_node ( self ) : [EOL] g = Graph ( [ ( NODE , [string] , { } ) ] ) [EOL] [EOL] self . assertEqual ( g . nodes , [ Node ( [string] , { } ) ] ) [EOL] self . assertEqual ( g . edges , [ ] ) [EOL] self . assertEqual ( g . attrs , { } ) [EOL] [EOL] def test_graph_with_one_node_with_keywords ( self ) : [EOL] g = Graph ( [ ( NODE , [string] , { [string] : [string] } ) ] ) [EOL] [EOL] self . assertEqual ( g . nodes , [ Node ( [string] , { [string] : [string] } ) ] ) [EOL] self . assertEqual ( g . edges , [ ] ) [EOL] self . assertEqual ( g . attrs , { } ) [EOL] [EOL] def test_graph_with_one_edge ( self ) : [EOL] g = Graph ( [ ( EDGE , [string] , [string] , { } ) ] ) [EOL] [EOL] self . assertEqual ( g . nodes , [ ] ) [EOL] self . assertEqual ( g . edges , [ Edge ( [string] , [string] , { } ) ] ) [EOL] self . assertEqual ( g . attrs , { } ) [EOL] [EOL] def test_graph_with_one_attribute ( self ) : [EOL] g = Graph ( [ ( ATTR , [string] , [string] ) ] ) [EOL] [EOL] self . assertEqual ( g . nodes , [ ] ) [EOL] self . assertEqual ( g . edges , [ ] ) [EOL] self . assertEqual ( g . attrs , { [string] : [string] } ) [EOL] [EOL] def test_graph_with_attributes ( self ) : [EOL] g = Graph ( [ ( ATTR , [string] , [string] ) , ( ATTR , [string] , [string] ) , ( NODE , [string] , { [string] : [string] } ) , ( NODE , [string] , { } ) , ( NODE , [string] , { [string] : [string] } ) , ( EDGE , [string] , [string] , { } ) , ( EDGE , [string] , [string] , { [string] : [string] } ) , ( ATTR , [string] , [string] ) , ] ) [EOL] [EOL] self . assertEqual ( g . nodes , [ Node ( [string] , { [string] : [string] } ) , Node ( [string] , { } ) , Node ( [string] , { [string] : [string] } ) , ] , ) [EOL] self . assertEqual ( g . edges , [ Edge ( [string] , [string] , { } ) , Edge ( [string] , [string] , { [string] : [string] } ) ] ) [EOL] self . assertEqual ( g . attrs , { [string] : [string] , [string] : [string] , [string] : [string] } ) [EOL] [EOL] def test_malformed_graph ( self ) : [EOL] with self . assertRaisesWithMessage ( TypeError ) : [EOL] Graph ( [number] ) [EOL] [EOL] with self . assertRaisesWithMessage ( TypeError ) : [EOL] Graph ( [string] ) [EOL] [EOL] def test_malformed_graph_item ( self ) : [EOL] with self . assertRaisesWithMessage ( TypeError ) : [EOL] Graph ( [ ( ) ] ) [EOL] [EOL] with self . assertRaisesWithMessage ( TypeError ) : [EOL] Graph ( [ ( ATTR , ) ] ) [EOL] [EOL] def test_malformed_attr ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Graph ( [ ( ATTR , [number] , [number] , [number] ) ] ) [EOL] [EOL] def test_malformed_node ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Graph ( [ ( NODE , [number] , [number] , [number] ) ] ) [EOL] [EOL] def test_malformed_EDGE ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Graph ( [ ( EDGE , [number] , [number] ) ] ) [EOL] [EOL] def test_unknown_item ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] Graph ( [ ( [number] , [number] , [number] ) ] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] NODE , EDGE , ATTR = range ( [number] ) [EOL] [EOL] [EOL] class Node ( object ) : [EOL] def __init__ ( self , name , attrs = { } ) : [EOL] self . name = name [EOL] self . attrs = attrs [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return self . name == other . name and self . attrs == other . attrs [EOL] [EOL] [EOL] class Edge ( object ) : [EOL] def __init__ ( self , src , dst , attrs = { } ) : [EOL] self . src = src [EOL] self . dst = dst [EOL] self . attrs = attrs [EOL] [EOL] def __eq__ ( self , other ) : [EOL] return ( self . src == other . src [EOL] and self . dst == other . dst [EOL] and self . attrs == other . attrs ) [EOL] [EOL] [EOL] class Graph ( object ) : [EOL] def __init__ ( self , data = [ ] ) : [EOL] self . nodes = [ ] [EOL] self . edges = [ ] [EOL] self . attrs = { } [EOL] if not isinstance ( data , list ) : [EOL] raise TypeError ( [string] ) [EOL] for datum in data : [EOL] if len ( datum ) <= [number] : [EOL] raise TypeError ( [string] ) [EOL] if datum [ [number] ] == NODE : [EOL] if len ( datum ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] self . nodes . append ( Node ( datum [ [number] ] , datum [ [number] ] ) ) [EOL] elif datum [ [number] ] == EDGE : [EOL] if len ( datum ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] self . edges . append ( Edge ( datum [ [number] ] , datum [ [number] ] , datum [ [number] ] ) ) [EOL] elif datum [ [number] ] == ATTR : [EOL] if len ( datum ) != [number] : [EOL] raise ValueError ( [string] ) [EOL] self . attrs [ datum [ [number] ] ] = datum [ [number] ] [EOL] else : [EOL] raise ValueError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from minesweeper import annotate [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class MinesweeperTest ( unittest . TestCase ) : [EOL] def test_no_rows ( self ) : [EOL] self . assertEqual ( annotate ( [ ] ) , [ ] ) [EOL] [EOL] def test_no_columns ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_no_mines ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] ] ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_minefield_with_only_mines ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] ] ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_mine_surrounded_by_spaces ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] ] ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_space_surrounded_by_mines ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] ] ) , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_horizontal_line ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_horizontal_line_mines_at_edges ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] ] ) , [ [string] ] ) [EOL] [EOL] def test_vertical_line ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] , [string] , [string] ] ) , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_vertical_line_mines_at_edges ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] , [string] , [string] ] ) , [ [string] , [string] , [string] , [string] , [string] ] ) [EOL] [EOL] def test_cross ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] , [string] , [string] ] ) , [ [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] def test_large_minefield ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) , [ [string] , [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] [comment] [EOL] def test_annotate_9 ( self ) : [EOL] self . assertEqual ( annotate ( [ [string] , [string] , [string] , [string] , [string] ] ) , [ [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] def test_different_len ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] annotate ( [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_invalid_char ( self ) : [EOL] with self . assertRaisesWithMessage ( ValueError ) : [EOL] annotate ( [ [string] ] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] from typing import List [EOL] [EOL] [EOL] def annotate ( input_board_array ) : [EOL] if not input_board_array : [EOL] return [ ] [EOL] row_length = [ len ( row ) for row in input_board_array ] [EOL] if min ( row_length ) != max ( row_length ) : [EOL] raise ValueError ( [string] ) [EOL] invalid_char = [ char for row in input_board_array for char in row if char not in [string] ] [EOL] if invalid_char : [EOL] raise ValueError ( [string] ) [EOL] column_length = len ( input_board_array ) [EOL] row_length = len ( input_board_array [ [number] ] ) [EOL] extended_board_array = ( [ [ [string] for i in range ( row_length + [number] ) ] ] + [ [ [string] ] + [ char for char in row ] + [ [string] ] for row in input_board_array ] + [ [ [string] for i in range ( row_length + [number] ) ] ] ) [EOL] for i in range ( [number] , column_length + [number] ) : [EOL] for j in range ( [number] , row_length + [number] ) : [EOL] if extended_board_array [ i ] [ j ] != [string] : [EOL] extended_board_array [ i ] [ j ] = str ( sum ( [ extended_board_array [ ii ] [ jj ] == [string] for ii in range ( i - [number] , i + [number] ) for jj in range ( j - [number] , j + [number] ) ] ) ) [EOL] return [ [string] . join ( row [ [number] : - [number] ] ) . replace ( [string] , [string] ) for row in extended_board_array [ [number] : - [number] ] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Dict [EOL] import typing [EOL] import builtins [EOL] from typing import Dict , Optional , Union [EOL] [EOL] [EOL] class Zipper ( object ) : [EOL] def __init__ ( self , value , left , right , ) : [EOL] self . _value = value [EOL] if left is None : [EOL] self . _left = left [EOL] else : [EOL] print ( [string] , left ) [EOL] self . _left = Zipper ( left [ [string] ] , left [ [string] ] , left [ [string] ] ) [EOL] if right is None : [EOL] self . _right = right [EOL] else : [EOL] print ( [string] , right ) [EOL] self . _right = Zipper ( right [ [string] ] , right [ [string] ] , right [ [string] ] ) [EOL] print ( [string] , self . to_tree ( ) ) [EOL] [EOL] @ staticmethod def from_tree ( tree ) : [EOL] print ( tree ) [EOL] print ( tree [ [string] ] ) [EOL] return Zipper ( tree [ [string] ] , tree [ [string] ] , tree [ [string] ] ) [EOL] [EOL] def value ( self ) : [EOL] return self . _value [EOL] [EOL] def set_value ( self ) : [EOL] pass [EOL] [EOL] def left ( self ) : [EOL] return self . _left [EOL] [EOL] def set_left ( self ) : [EOL] pass [EOL] [EOL] def right ( self ) : [EOL] return self . _right [EOL] [EOL] def set_right ( self ) : [EOL] pass [EOL] [EOL] def up ( self ) : [EOL] pass [EOL] [EOL] def to_tree ( self , ) : [EOL] left = None [EOL] right = None [EOL] if self . _left is not None : [EOL] left = self . _left . to_tree ( ) [EOL] if self . _right is not None : [EOL] right = self . _right . to_tree ( ) [EOL] return { [string] : self . _value , [string] : left , [string] : right } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional["Zipper"]$ 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],],]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional["Zipper"]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Zipper"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,typing.Dict[builtins.str,typing.Union[builtins.int,None,typing.Dict[builtins.str,typing.Union[builtins.int,None]]]],typing.Dict[builtins.str,typing.Union[builtins.int,None]],None,],]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Optional , Any , Dict [EOL] import typing [EOL] import unittest [EOL] [EOL] from zipper import Zipper [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class ZipperTest ( unittest . TestCase ) : [EOL] def test_data_is_retained ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_left_right_and_value ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . right ( ) . value ( ) [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_dead_end ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . left ( ) [EOL] self . assertIsNone ( result ) [EOL] [EOL] def test_tree_from_deep_focus ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . right ( ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_traversing_up_from_top ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . up ( ) [EOL] self . assertIsNone ( result ) [EOL] [EOL] def test_left_right_and_up ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . up ( ) . right ( ) . up ( ) . left ( ) . right ( ) . value ( ) [EOL] self . assertEqual ( result , [number] ) [EOL] [EOL] def test_set_value ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . set_value ( [number] ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_set_value_after_traversing_up ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . right ( ) . up ( ) . set_value ( [number] ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_set_left_with_leaf ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : None } , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = ( zipper . left ( ) . set_left ( { [string] : [number] , [string] : None , [string] : None } ) . to_tree ( ) ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_set_right_with_null ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : None } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . set_right ( None ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_set_right_with_subtree ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : None } , [string] : { [string] : [number] , [string] : None , [string] : None } , } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . set_right ( { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : None } , [string] : { [string] : [number] , [string] : None , [string] : None } , } ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_set_value_on_deep_focus ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] expected = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] [EOL] zipper = Zipper . from_tree ( initial ) [EOL] result = zipper . left ( ) . right ( ) . set_value ( [number] ) . to_tree ( ) [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] def test_different_paths_to_same_zipper ( self ) : [EOL] initial = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] result = Zipper . from_tree ( initial ) . left ( ) . up ( ) . right ( ) . to_tree ( ) [EOL] [EOL] final = { [string] : [number] , [string] : { [string] : [number] , [string] : None , [string] : { [string] : [number] , [string] : None , [string] : None } , } , [string] : { [string] : [number] , [string] : None , [string] : None } , } [EOL] expected = Zipper . from_tree ( final ) . right ( ) . to_tree ( ) [EOL] [EOL] self . assertEqual ( result , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Union[None,typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]],typing.Dict[builtins.str,typing.Optional[builtins.int]],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Any , List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] ANIMAL_ACTIONS = [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] [EOL] [EOL] [EOL] def recite ( start_verse , end_verse ) : [EOL] song = [ ] [EOL] for i in range ( start_verse , end_verse ) : [EOL] song = song + recite_one_verse ( i ) [EOL] song . append ( [string] ) [EOL] song = song + recite_one_verse ( end_verse ) [EOL] return song [EOL] [EOL] [EOL] def recite_one_verse ( verse ) : [EOL] lyrics = [ ] [EOL] for i in range ( verse - [number] , - [number] , - [number] ) : [EOL] if i == verse - [number] : [EOL] lyrics . append ( f" [string] { ANIMAL_ACTIONS [ i ] [ [number] ] } [string] " ) [EOL] elif i == [number] : [EOL] lyrics . append ( f" [string] { ANIMAL_ACTIONS [ i + [number] ] [ [number] ] } [string] { ANIMAL_ACTIONS [ i ] [ [number] ] } [string] " ) [EOL] else : [EOL] lyrics . append ( f" [string] { ANIMAL_ACTIONS [ i + [number] ] [ [number] ] } [string] { ANIMAL_ACTIONS [ i ] [ [number] ] } [string] " ) [EOL] if i == verse - [number] or i == [number] : [EOL] lyrics . append ( f"{ ANIMAL_ACTIONS [ i ] [ [number] ] }" ) [EOL] if i == len ( ANIMAL_ACTIONS ) - [number] : [EOL] break [EOL] return lyrics [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from isbn_verifier import verify [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class IsbnVerifierTest ( unittest . TestCase ) : [EOL] def test_valid_isbn_number ( self ) : [EOL] self . assertIs ( verify ( [string] ) , True ) [EOL] [EOL] def test_invalid_check_digit ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_valid_with_X_check_digit ( self ) : [EOL] self . assertIs ( verify ( [string] ) , True ) [EOL] [EOL] def test_invalid_check_digit_other_than_X ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_character_in_isbn ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_X_other_than_check_digit ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_valid_isbn_without_separating_dashes ( self ) : [EOL] self . assertIs ( verify ( [string] ) , True ) [EOL] [EOL] def test_valid_isbn_without_separating_dashes_with_X_check_digit ( self ) : [EOL] self . assertIs ( verify ( [string] ) , True ) [EOL] [EOL] def test_invalid_isbn_without_check_digit_and_dashes ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_too_long_isbn_with_no_dashes ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_too_short_isbn ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_isbn_without_check_digit ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_check_digit_X_used_for_0 ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_valid_empty_isbn ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_input_is_nine_characters ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_invalid_characters_are_not_ignored ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] def test_input_is_too_long_but_contains_a_valid_isbn ( self ) : [EOL] self . assertIs ( verify ( [string] ) , False ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] import re [EOL] [EOL] [EOL] def verify ( isbn ) : [EOL] [docstring] [EOL] if not isbn : [EOL] return False [EOL] isbn_number = [ int ( digit ) for digit in re . sub ( [string] , [string] , isbn ) ] [EOL] if isbn [ - [number] ] == [string] : [EOL] isbn_number . append ( [number] ) [EOL] return ( sum ( [ a * b for a , b in zip ( isbn_number , range ( [number] , [number] , - [number] ) ) ] ) % [number] == [number] [EOL] if len ( isbn_number ) == [number] [EOL] else False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from beer_song import recite [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BeerSongTest ( unittest . TestCase ) : [EOL] def test_first_generic_verse ( self ) : [EOL] expected = [ [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] ) , expected ) [EOL] [EOL] def test_last_generic_verse ( self ) : [EOL] expected = [ [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] ) , expected ) [EOL] [EOL] def test_verse_with_2_bottles ( self ) : [EOL] expected = [ [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] ) , expected ) [EOL] [EOL] def test_verse_with_1_bottle ( self ) : [EOL] expected = [ [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] ) , expected ) [EOL] [EOL] def test_verse_with_0_bottles ( self ) : [EOL] expected = [ [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] ) , expected ) [EOL] [EOL] def test_first_two_verses ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] , take = [number] ) , expected ) [EOL] [EOL] def test_last_three_verses ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] , take = [number] ) , expected ) [EOL] [EOL] def test_all_verses ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . assertEqual ( recite ( start = [number] , take = [number] ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] class Allergies ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , score ) : [EOL] [docstring] [EOL] self . score = score [EOL] self . allergies = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def allergic_to ( self , item ) : [EOL] [docstring] [EOL] return item in self . lst [EOL] [EOL] @ property def lst ( self ) : [EOL] [docstring] [EOL] return [ item for index , item in enumerate ( self . allergies ) if [number] ** index & self . score != [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from allergies import Allergies [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class AllergiesTest ( unittest . TestCase ) : [EOL] def test_eggs_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_eggs ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_eggs_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_eggs ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_eggs_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_peanuts_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_peanuts ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_peanuts_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_peanuts ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_peanuts_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_shellfish_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_shellfish ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_shellfish_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_shellfish ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_shellfish_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_strawberries_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_strawberries ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_strawberries_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_strawberries ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_strawberries_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_tomatoes_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_tomatoes ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_tomatoes_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_tomatoes ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_tomatoes_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_chocolate_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_chocolate ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_chocolate_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_chocolate ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_chocolate_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_pollen_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_pollen ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_pollen_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_pollen ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_pollen_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_cats_not_allergic_to_anything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_allergic_only_to_cats ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_cats_and_something_else ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_allergic_to_something_but_not_cats ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , False ) [EOL] [EOL] def test_cats_allergic_to_everything ( self ) : [EOL] self . assertIs ( Allergies ( [number] ) . allergic_to ( [string] ) , True ) [EOL] [EOL] def test_no_allergies ( self ) : [EOL] self . assertEqual ( Allergies ( [number] ) . lst , [ ] ) [EOL] [EOL] def test_just_eggs ( self ) : [EOL] self . assertEqual ( Allergies ( [number] ) . lst , [ [string] ] ) [EOL] [EOL] def test_just_peanuts ( self ) : [EOL] self . assertEqual ( Allergies ( [number] ) . lst , [ [string] ] ) [EOL] [EOL] def test_just_strawberries ( self ) : [EOL] self . assertEqual ( Allergies ( [number] ) . lst , [ [string] ] ) [EOL] [EOL] def test_eggs_and_peanuts ( self ) : [EOL] self . assertCountEqual ( Allergies ( [number] ) . lst , [ [string] , [string] ] ) [EOL] [EOL] def test_more_than_eggs_but_not_peanuts ( self ) : [EOL] self . assertCountEqual ( Allergies ( [number] ) . lst , [ [string] , [string] ] ) [EOL] [EOL] def test_lots_of_stuff ( self ) : [EOL] self . assertCountEqual ( Allergies ( [number] ) . lst , [ [string] , [string] , [string] , [string] , [string] ] , ) [EOL] [EOL] def test_everything ( self ) : [EOL] self . assertCountEqual ( Allergies ( [number] ) . lst , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] def test_no_allergen_score_parts ( self ) : [EOL] self . assertCountEqual ( Allergies ( [number] ) . lst , [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import unittest [EOL] [EOL] from luhn import Luhn [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class LuhnTest ( unittest . TestCase ) : [EOL] def test_single_digit_strings_can_not_be_valid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_a_single_zero_is_invalid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_a_simple_valid_sin_that_remains_valid_if_reversed ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_a_simple_valid_sin_that_becomes_invalid_if_reversed ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_a_valid_canadian_sin ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_invalid_canadian_sin ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_invalid_credit_card ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_invalid_long_number_with_an_even_remainder ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_valid_number_with_an_even_number_of_digits ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_valid_number_with_an_odd_number_of_spaces ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_valid_strings_with_a_non_digit_added_at_the_end_become_invalid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_valid_strings_with_punctuation_included_become_invalid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_valid_strings_with_symbols_included_become_invalid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_single_zero_with_space_is_invalid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_more_than_a_single_zero_is_valid ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_input_digit_9_is_correctly_converted_to_output_digit_9 ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , True ) [EOL] [EOL] def test_using_ascii_value_for_non_doubled_non_digit_isn_t_allowed ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] def test_using_ascii_value_for_doubled_non_digit_isn_t_allowed ( self ) : [EOL] self . assertIs ( Luhn ( [string] ) . valid ( ) , False ) [EOL] [EOL] [comment] [EOL] [EOL] def test_is_valid_can_be_called_repeatedly ( self ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] number = Luhn ( [string] ) [EOL] self . assertIs ( number . valid ( ) , True ) [EOL] self . assertIs ( number . valid ( ) , True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] class Luhn ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , card_num ) : [EOL] [docstring] [EOL] self . card_num = card_num . replace ( [string] , [string] ) [EOL] [EOL] def valid ( self ) : [EOL] [docstring] [EOL] if not self . card_num . isdigit ( ) or self . card_num == [string] : [EOL] return False [EOL] [EOL] card_num_rev = list ( map ( int , self . card_num ) ) [ : : - [number] ] [EOL] points = sum ( card_num_rev [ : : [number] ] ) + sum ( [number] * i - [number] * ( i // [number] ) for i in card_num_rev [ [number] : : [number] ] ) [EOL] return points % [number] == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import unittest [EOL] [EOL] from high_scores import latest , personal_best , personal_top_three [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class HighScoreTest ( unittest . TestCase ) : [EOL] def test_latest_score ( self ) : [EOL] scores = [ [number] , [number] , [number] , [number] ] [EOL] expected = [number] [EOL] self . assertEqual ( latest ( scores ) , expected ) [EOL] [EOL] def test_personal_best ( self ) : [EOL] scores = [ [number] , [number] , [number] ] [EOL] expected = [number] [EOL] self . assertEqual ( personal_best ( scores ) , expected ) [EOL] [EOL] def test_personal_top_three_from_a_long_list ( self ) : [EOL] scores = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] expected = [ [number] , [number] , [number] ] [EOL] self . assertEqual ( personal_top_three ( scores ) , expected ) [EOL] [EOL] def test_personal_top_three_highest_to_lowest ( self ) : [EOL] scores = [ [number] , [number] , [number] ] [EOL] expected = [ [number] , [number] , [number] ] [EOL] self . assertEqual ( personal_top_three ( scores ) , expected ) [EOL] [EOL] def test_personal_top_three_when_there_is_a_tie ( self ) : [EOL] scores = [ [number] , [number] , [number] , [number] ] [EOL] expected = [ [number] , [number] , [number] ] [EOL] self . assertEqual ( personal_top_three ( scores ) , expected ) [EOL] [EOL] def test_personal_top_three_when_there_are_less_than_3 ( self ) : [EOL] scores = [ [number] , [number] ] [EOL] expected = [ [number] , [number] ] [EOL] self . assertEqual ( personal_top_three ( scores ) , expected ) [EOL] [EOL] def test_personal_top_three_when_there_is_only_one ( self ) : [EOL] scores = [ [number] ] [EOL] expected = [ [number] ] [EOL] self . assertEqual ( personal_top_three ( scores ) , expected ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import builtins [EOL] [docstring] [EOL] [EOL] [EOL] from typing import List [EOL] [EOL] [EOL] def latest ( scores ) : [EOL] [docstring] [EOL] return scores [ - [number] ] [EOL] [EOL] [EOL] def personal_best ( scores ) : [EOL] [docstring] [EOL] return max ( scores ) [EOL] [EOL] [EOL] def personal_top_three ( scores ) : [EOL] [docstring] [EOL] return sorted ( scores , reverse = True ) [ : [number] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittest [EOL] [EOL] from rna_transcription import to_rna [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class RnaTranscriptionTest ( unittest . TestCase ) : [EOL] def test_empty_rna_sequence ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] def test_rna_complement_of_cytosine_is_guanine ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] def test_rna_complement_of_guanine_is_cytosine ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] def test_rna_complement_of_thymine_is_adenine ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] def test_rna_complement_of_adenine_is_uracil ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] def test_rna_complement ( self ) : [EOL] self . assertEqual ( to_rna ( [string] ) , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict [EOL] import typing [EOL] import builtins [EOL] def to_rna ( dna_strand ) : [EOL] dna2rna = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] return [string] . join ( [ dna2rna [ x ] for x in dna_strand ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from bowling import BowlingGame [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BowlingTest ( unittest . TestCase ) : [EOL] def roll_new_game ( self , rolls ) : [EOL] game = BowlingGame ( ) [EOL] for roll in rolls : [EOL] game . roll ( roll ) [EOL] return game [EOL] [EOL] def test_should_be_able_to_score_a_game_with_all_zeros ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_should_be_able_to_score_a_game_with_no_strikes_or_spares ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_a_spare_followed_by_zeros_is_worth_ten_points ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_points_scored_in_the_roll_after_a_spare_are_counted_twice ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_consecutive_spares_each_get_a_one_roll_bonus ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_a_spare_in_the_last_frame_gets_a_one_roll_bonus_that_is_counted_once ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_a_strike_earns_ten_points_in_a_frame_with_a_single_roll ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_points_scored_in_the_two_rolls_after_a_strike_are_counted_twice_as_a_bonus ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_consecutive_strikes_each_get_the_two_roll_bonus ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_a_strike_in_the_last_frame_gets_a_two_roll_bonus_that_is_counted_once ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_rolling_a_spare_with_the_two_roll_bonus_does_not_get_a_bonus_roll ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_strikes_with_the_two_roll_bonus_do_not_get_bonus_rolls ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_a_strike_with_the_one_roll_bonus_after_a_spare_in_the_last_frame_does_not_get_a_bonus ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_all_strikes_is_a_perfect_game ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_rolls_cannot_score_negative_points ( self ) : [EOL] rolls = [ ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( - [number] ) [EOL] [EOL] def test_a_roll_cannot_score_more_than_10_points ( self ) : [EOL] rolls = [ ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_two_rolls_in_a_frame_cannot_score_more_than_10_points ( self ) : [EOL] rolls = [ [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_bonus_roll_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_two_bonus_rolls_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_two_bonus_rolls_after_a_strike_in_the_last_frame_can_score_more_than_10_points_if_one_is_a_strike ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] self . assertEqual ( game . score ( ) , [number] ) [EOL] [EOL] def test_the_second_bonus_rolls_after_a_strike_in_the_last_frame_cannot_be_a_strike_if_the_first_one_is_not_a_strike ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_second_bonus_roll_after_a_strike_in_the_last_frame_cannot_score_more_than_10_points ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_an_unstarted_game_cannot_be_scored ( self ) : [EOL] rolls = [ ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( ) [EOL] [EOL] def test_an_incomplete_game_cannot_be_scored ( self ) : [EOL] rolls = [ [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( ) [EOL] [EOL] def test_cannot_roll_if_game_already_has_ten_frames ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_bonus_rolls_for_a_strike_in_the_last_frame_must_be_rolled_before_score_can_be_calculated ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( ) [EOL] [EOL] def test_both_bonus_rolls_for_a_strike_in_the_last_frame_must_be_rolled_before_score_can_be_calculated ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( ) [EOL] [EOL] def test_bonus_roll_for_a_spare_in_the_last_frame_must_be_rolled_before_score_can_be_calculated ( self , ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( ) [EOL] [EOL] def test_cannot_roll_after_bonus_roll_for_spare ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] def test_cannot_roll_after_bonus_rolls_for_strike ( self ) : [EOL] rolls = [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] game = self . roll_new_game ( rolls ) [EOL] with self . assertRaisesWithMessage ( Exception ) : [EOL] game . roll ( [number] ) [EOL] [EOL] [comment] [EOL] def assertRaisesWithMessage ( self , exception ) : [EOL] return self . assertRaisesRegex ( exception , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class BowlingGame ( object ) : [EOL] def __init__ ( self ) : [EOL] self . score_ = [number] [EOL] self . last_score = [number] [EOL] self . frame_score = [number] [EOL] self . first_throw = True [EOL] self . bonus_rate = [number] [EOL] self . bonus_countdown = [number] [EOL] self . frame = [number] [EOL] [EOL] def roll ( self , pins ) : [EOL] if pins < [number] : [EOL] raise ValueError ( [string] ) [EOL] if pins > [number] : [EOL] raise ValueError ( [string] ) [EOL] if self . first_throw : [EOL] self . frame = self . frame + [number] [EOL] if self . frame > [number] : [EOL] if self . bonus_countdown == [number] : [EOL] raise IndexError ( [string] ) [EOL] self . bonus_rate = max ( self . bonus_rate - [number] , [number] ) [EOL] self . frame_score = self . frame_score + pins [EOL] if self . frame_score > [number] : [EOL] raise ValueError ( [string] ) [EOL] self . score_ = self . score_ + pins * self . bonus_rate [EOL] self . bonus_countdown = max ( self . bonus_countdown - [number] , [number] ) [EOL] if self . bonus_countdown == [number] : [EOL] self . bonus_rate = [number] [EOL] elif self . frame_score != [number] : [EOL] self . bonus_rate = [number] [EOL] if self . frame_score == [number] : [EOL] if self . frame <= [number] : [EOL] self . bonus_rate = [number] + self . bonus_countdown [EOL] if not self . first_throw : [EOL] self . bonus_countdown = [number] [EOL] else : [EOL] self . bonus_countdown = [number] [EOL] self . first_throw = True [EOL] else : [EOL] self . first_throw = not self . first_throw [EOL] if self . first_throw : [EOL] self . frame_score = [number] [EOL] [EOL] def score ( self ) : [EOL] return self . score_ [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import unittest [EOL] [EOL] from binary_search_tree import BinarySearchTree , TreeNode [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class BinarySearchTreeTest ( unittest . TestCase ) : [EOL] def test_data_is_retained ( self ) : [EOL] expected = TreeNode ( [string] , None , None ) [EOL] self . assertTreeEqual ( BinarySearchTree ( [ [string] ] ) . data ( ) , expected ) [EOL] [EOL] def test_smaller_number_at_left_node ( self ) : [EOL] expected = TreeNode ( [string] , TreeNode ( [string] , None , None ) , None ) [EOL] self . assertTreeEqual ( BinarySearchTree ( [ [string] , [string] ] ) . data ( ) , expected ) [EOL] [EOL] def test_same_number_at_left_node ( self ) : [EOL] expected = TreeNode ( [string] , TreeNode ( [string] , None , None ) , None ) [EOL] self . assertTreeEqual ( BinarySearchTree ( [ [string] , [string] ] ) . data ( ) , expected ) [EOL] [EOL] def test_greater_number_at_right_node ( self ) : [EOL] expected = TreeNode ( [string] , None , TreeNode ( [string] , None , None ) ) [EOL] self . assertTreeEqual ( BinarySearchTree ( [ [string] , [string] ] ) . data ( ) , expected ) [EOL] [EOL] def test_can_create_complex_tree ( self ) : [EOL] expected = TreeNode ( [string] , TreeNode ( [string] , TreeNode ( [string] , None , None ) , TreeNode ( [string] , None , None ) ) , TreeNode ( [string] , TreeNode ( [string] , None , None ) , TreeNode ( [string] , None , None ) ) , ) [EOL] self . assertTreeEqual ( BinarySearchTree ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) . data ( ) , expected ) [EOL] [EOL] def test_can_sort_single_number ( self ) : [EOL] expected = [ [string] ] [EOL] self . assertEqual ( BinarySearchTree ( [ [string] ] ) . sorted_data ( ) , expected ) [EOL] [EOL] def test_can_sort_if_second_number_is_smaller_than_first ( self ) : [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( BinarySearchTree ( [ [string] , [string] ] ) . sorted_data ( ) , expected ) [EOL] [EOL] def test_can_sort_if_second_number_is_same_as_first ( self ) : [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( BinarySearchTree ( [ [string] , [string] ] ) . sorted_data ( ) , expected ) [EOL] [EOL] def test_can_sort_if_second_number_is_greater_than_first ( self ) : [EOL] expected = [ [string] , [string] ] [EOL] self . assertEqual ( BinarySearchTree ( [ [string] , [string] ] ) . sorted_data ( ) , expected ) [EOL] [EOL] def test_can_sort_complex_tree ( self ) : [EOL] expected = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] self . assertEqual ( BinarySearchTree ( [ [string] , [string] , [string] , [string] , [string] , [string] ] ) . sorted_data ( ) , expected ) [EOL] [EOL] [comment] [EOL] def assertTreeEqual ( self , tree_one , tree_two ) : [EOL] try : [EOL] self . compare_tree ( tree_one , tree_two ) [EOL] except AssertionError : [EOL] raise AssertionError ( [string] . format ( tree_one , tree_two ) ) [EOL] [EOL] def compare_tree ( self , tree_one , tree_two ) : [EOL] self . assertEqual ( tree_one . data , tree_two . data ) [EOL] [EOL] [comment] [EOL] if tree_one . left and tree_two . left : [EOL] self . compare_tree ( tree_one . left , tree_two . left ) [EOL] elif tree_one . left is None and tree_two . left is None : [EOL] pass [EOL] else : [EOL] raise AssertionError [EOL] [EOL] [comment] [EOL] if tree_one . right and tree_two . right : [EOL] self . compare_tree ( tree_one . right , tree_two . right ) [EOL] elif tree_one . right is None and tree_two . right is None : [EOL] pass [EOL] else : [EOL] raise AssertionError [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import tree [EOL] [docstring] [EOL] [EOL] from typing import List , Optional [EOL] [EOL] [EOL] class TreeNode ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , left , right ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . left = left [EOL] self . right = right [EOL] [EOL] def __str__ ( self ) : [EOL] [docstring] [EOL] fmt = [string] [EOL] return fmt . format ( self . data , self . left , self . right ) [EOL] [EOL] def add ( self , value ) : [EOL] [docstring] [EOL] if value <= self . data : [EOL] if not self . left : [EOL] self . left = TreeNode ( value , None , None ) [EOL] else : [EOL] self . left . add ( value ) [EOL] else : [EOL] if not self . right : [EOL] self . right = TreeNode ( value , None , None ) [EOL] else : [EOL] self . right . add ( value ) [EOL] [EOL] [EOL] class BinarySearchTree ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tree_data ) : [EOL] [docstring] [EOL] self . tree_data = TreeNode ( tree_data [ [number] ] , None , None ) [EOL] for node in tree_data [ [number] : ] : [EOL] self . tree_data . add ( node ) [EOL] [EOL] def data ( self ) : [EOL] [docstring] [EOL] return self . tree_data [EOL] [EOL] def sorted_data ( self ) : [EOL] [docstring] [EOL] go_left = True [EOL] result = [ ] [EOL] nodes = [ ] [EOL] node = self . tree_data [EOL] while node : [EOL] if node . left and go_left : [EOL] nodes . append ( node ) [EOL] node = node . left [EOL] else : [EOL] go_left = False [EOL] result . append ( node . data ) [EOL] if node . right : [EOL] node = node . right [EOL] go_left = True [EOL] else : [EOL] if nodes : [EOL] node = nodes . pop ( ) [EOL] else : [EOL] break [EOL] return result [EOL] [EOL] def add ( self , value ) : [EOL] [docstring] [EOL] self . tree_data . add ( value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0