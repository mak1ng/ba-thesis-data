from typing import Optional , Callable , Any , TypeVar [EOL] import fcs [EOL] import BitVector [EOL] import typing [EOL] import builtins [EOL] import hashlib [EOL] import secrets [EOL] from typing import Any , Callable , Generic , Optional , TypeVar [EOL] [EOL] from BitVector import BitVector [EOL] import bchlib [EOL] [EOL] [EOL] BCH_POLYNOMIAL = [number] [EOL] [EOL] K = TypeVar ( [string] ) [comment] [EOL] [EOL] [EOL] def _byte_extractor ( value ) : [EOL] [docstring] [EOL] value_bytes = [string] [EOL] try : [EOL] value_bytes = bytes ( value ) [EOL] except TypeError as error : [EOL] raise TypeError ( [string] [string] % type ( value ) , error ) [EOL] return BitVector ( hexstring = value_bytes . hex ( ) ) [EOL] [EOL] [EOL] class FCS ( Generic [ K ] ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , witness_nbits , tolerance , extractor = None , polynomial = BCH_POLYNOMIAL ) : [EOL] [docstring] [EOL] self . _witlen = witness_nbits [EOL] if extractor is None : [EOL] extractor = _byte_extractor [EOL] self . _extractor = extractor [EOL] self . _bch = bchlib . BCH ( polynomial , tolerance ) [EOL] [comment] [EOL] [comment] [EOL] [EOL] def _commit_raw ( self , message , witness ) : [EOL] [docstring] [EOL] if len ( witness ) > self . _witlen : [EOL] raise ValueError ( [string] f" [string] { len ( witness ) } [string] { self . _witlen } [string] " ) [EOL] ecc = self . _bch . encode ( message ) [EOL] codeword = message + ecc [EOL] codeword_bv = BitVector ( hexstring = codeword . hex ( ) ) [EOL] [comment] [EOL] [comment] [EOL] assert len ( codeword_bv ) >= len ( witness ) [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] commitment = Commitment ( hashlib . sha256 ( message ) . digest ( ) , ( codeword_bv . reverse ( ) ^ witness . reverse ( ) ) . reverse ( ) , ) [EOL] return commitment [EOL] [EOL] def _commit_random_message_raw ( self , witness ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] key_len = ( self . _witlen + [number] ) // [number] [EOL] key = secrets . token_bytes ( key_len ) [EOL] return self . _commit_raw ( key , witness ) [EOL] [EOL] def commit ( self , witness , message = None ) : [EOL] [docstring] [EOL] if message : [EOL] commitment = self . _commit_raw ( message , self . _extractor ( witness ) ) [EOL] else : [EOL] commitment = self . _commit_random_message_raw ( self . _extractor ( witness ) ) [EOL] return commitment [EOL] [EOL] def _open_raw ( self , commitment , candidate ) : [EOL] [docstring] [EOL] codeword_cand = ( commitment . auxiliar . reverse ( ) ^ candidate . reverse ( ) ) . reverse ( ) [EOL] codeword_cand_bytes = bytes . fromhex ( codeword_cand . get_bitvector_in_hex ( ) ) [EOL] bitflips , msg_cand , _ = self . _bch . decode ( codeword_cand_bytes [ : - self . _bch . ecc_bytes ] , codeword_cand_bytes [ - self . _bch . ecc_bytes : ] ) [EOL] msg_match = secrets . compare_digest ( commitment . pseudonym , hashlib . sha256 ( msg_cand ) . digest ( ) ) [EOL] [comment] [EOL] is_valid = msg_match & ( bitflips != - [number] ) [EOL] return bytes ( msg_cand ) if is_valid else None [EOL] [EOL] def open ( self , commitment , candidate ) : [EOL] [docstring] [EOL] return self . _open_raw ( commitment , self . _extractor ( candidate ) ) [EOL] [EOL] def verify ( self , commitment , candidate ) : [EOL] [docstring] [EOL] return self . open ( commitment , candidate ) is not None [EOL] [EOL] [EOL] class Commitment ( object ) : [EOL] [docstring] [EOL] def __init__ ( self , pseudonym , auxiliar ) : [EOL] self . pseudonym = pseudonym [EOL] self . auxiliar = auxiliar [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $'Commitment'$ 0 0 0 $builtins.bytes$ 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 $fcs.fcs.Commitment$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fcs.fcs.Commitment$ 0 0 0 $'Commitment'$ 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $BitVector.BitVector$ 0 0 0 0 $'Commitment'$ 0 0 0 $K$ 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 $fcs.fcs.Commitment$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 $K$ 0 0 0 0 0 0 $fcs.fcs.Commitment$ 0 0 0 0 0 0 0 0 0 $K$ 0 0 0 0 $fcs.fcs.Commitment$ 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $'Commitment'$ 0 $BitVector.BitVector$ 0 0 0 0 0 $typing.Any$ 0 0 $'Commitment'$ 0 0 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $'Commitment'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 $'Commitment'$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 $'Commitment'$ 0 0 0 0 0 $K$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $'Commitment'$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 $'Commitment'$ 0 $K$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 $builtins.bytes$ 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] from . fcs import FCS , Commitment [EOL] [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Optional , Any [EOL] import fcs [EOL] import BitVector [EOL] import typing [EOL] import builtins [EOL] import unittest [EOL] import random [EOL] import secrets [EOL] [EOL] from BitVector import BitVector [EOL] [EOL] import fcs [EOL] [EOL] [EOL] def random_flip ( witness , numbits ) : [EOL] witness_mod = bytearray ( witness ) [EOL] bit_nums = random . sample ( range ( len ( witness ) * [number] ) , numbits ) [EOL] for bit_num in bit_nums : [EOL] witness_mod [ bit_num // [number] ] ^= ( [number] << ( bit_num % [number] ) ) [EOL] return bytes ( witness_mod ) [EOL] [EOL] [EOL] class TestFCS ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . threshold = [number] [EOL] self . witness = secrets . token_bytes ( [number] ) [EOL] self . cs = fcs . FCS ( len ( self . witness ) * [number] , self . threshold ) [EOL] self . commitment = self . cs . commit ( self . witness ) [EOL] [EOL] def test_unaltered_witness ( self ) : [EOL] valid = self . cs . verify ( self . commitment , self . witness ) [EOL] self . assertTrue ( valid ) [EOL] [EOL] def test_altered_tolerable ( self ) : [EOL] witness_mod = random_flip ( self . witness , self . threshold ) [EOL] valid = self . cs . verify ( self . commitment , witness_mod ) [EOL] self . assertTrue ( valid ) [EOL] [EOL] def test_altered_intolerable ( self ) : [EOL] witness_mod = random_flip ( self . witness , self . threshold + [number] ) [EOL] valid = self . cs . verify ( self . commitment , witness_mod ) [EOL] self . assertFalse ( valid ) [EOL] [EOL] [EOL] class TestFCSTwo ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] witlen = [number] [EOL] self . threshold = [number] [EOL] self . witness = secrets . token_bytes ( ( witlen + [number] ) // [number] ) [EOL] self . cs = fcs . FCS ( len ( self . witness ) * [number] , self . threshold ) [EOL] self . commitment = self . cs . commit ( self . witness ) [EOL] [EOL] def test_unaltered_witness ( self ) : [EOL] valid = self . cs . verify ( self . commitment , self . witness ) [EOL] self . assertTrue ( valid ) [EOL] [EOL] def test_altered_tolerable ( self ) : [EOL] witness_mod = random_flip ( self . witness , self . threshold ) [EOL] valid = self . cs . verify ( self . commitment , witness_mod ) [EOL] self . assertTrue ( valid ) [EOL] [EOL] def test_altered_intolerable ( self ) : [EOL] witness_mod = random_flip ( self . witness , self . threshold + [number] ) [EOL] valid = self . cs . verify ( self . commitment , witness_mod ) [EOL] self . assertFalse ( valid ) [EOL] [EOL] [EOL] def int_extractor ( value ) : [EOL] value_bytes = int . to_bytes ( value , length = [number] , byteorder = [string] ) [EOL] return BitVector ( hexstring = value_bytes . hex ( ) ) [EOL] [EOL] [EOL] class TestFCSCustomExtractor ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . threshold = [number] [EOL] self . cs = fcs . FCS [ int ] ( [number] , self . threshold , extractor = int_extractor , ) [EOL] self . witness = [number] [EOL] self . message = [string] [EOL] self . commitment = self . cs . commit ( self . witness , message = self . message ) [EOL] [EOL] def test_unaltered_witness ( self ) : [EOL] msg = self . cs . open ( self . commitment , self . witness ) [EOL] self . assertEqual ( msg , self . message ) [EOL] [EOL] def test_altered_tolerable ( self ) : [EOL] msg = self . cs . open ( self . commitment , [number] ) [comment] [EOL] self . assertEqual ( msg , self . message ) [EOL] [EOL] def test_altered_intolerable ( self ) : [EOL] msg = self . cs . open ( self . commitment , [number] ) [comment] [EOL] self . assertEqual ( msg , None ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $BitVector.BitVector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $fcs.fcs.FCS[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $fcs.fcs.FCS[builtins.int]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.bytes$ 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0