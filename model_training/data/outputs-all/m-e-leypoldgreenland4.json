[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import setuptools [EOL] import datetime [EOL] [EOL] with open ( [string] , [string] ) as fh : [EOL] long_description = fh . read ( ) [EOL] [EOL] exclude = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] def is_excluded ( p ) : [EOL] for suffix in exclude : [EOL] if p [ - len ( suffix ) - [number] : ] == [string] + suffix : return True [EOL] return False [EOL] [EOL] packages = [ package for package in setuptools . find_packages ( [string] ) if not is_excluded ( package ) ] [EOL] [EOL] loc_suffix = [string] + datetime . datetime . strftime ( datetime . datetime . now ( ) , [string] ) [EOL] [EOL] setuptools . setup ( name = [string] , version = [string] , author = [string] , author_email = [string] , description = [string] , long_description = long_description , long_description_content_type = [string] , url = [string] , packages = packages , package_dir = { [string] : [string] } , classifiers = [ [string] , [string] , [string] , ] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] [EOL] def longstr ( obj , * pargs , ** kwargs ) : [EOL] try : [EOL] return obj . __longstr__ ( * pargs , ** kwargs ) [EOL] except AttributeError : [EOL] return str ( obj ) [EOL] [EOL] [EOL] class UserError ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [EOL] def test_import ( ) : [EOL] from . . import conventions [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any , Type [EOL] import typing [EOL] import collections [EOL] [EOL] class WithDefinitionOrderMeta ( type ) : [EOL] [EOL] @ classmethod def __prepare__ ( metacls , name , bases , ** kwds ) : [EOL] return collections . OrderedDict ( ) [EOL] [EOL] def __new__ ( cls , name , bases , namespace , ** kwds ) : [EOL] Class = type . __new__ ( cls , name , bases , dict ( namespace ) ) [EOL] Class . __members_definition_order__ = tuple ( ( key for key in namespace . keys ( ) if key [ [number] ] != [string] ) ) [EOL] return Class [EOL] [EOL] class WithDefinitionOrder ( object , metaclass = WithDefinitionOrderMeta ) : pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [EOL] import re [EOL] [EOL] [comment] [EOL] [EOL] class MasterRe ( object ) : [EOL] def __init__ ( self , rxs ) : [EOL] [EOL] ctors = [ ] [EOL] partial_res = self . partial_res = [ ] [EOL] start_index = [ ] [EOL] end_index = [ ] [EOL] index = [number] [EOL] [EOL] for partial_re , ctor in rxs : [EOL] start_index . append ( index ) [EOL] rx = re . compile ( partial_re ) [comment] [EOL] index += rx . groups [EOL] end_index . append ( index ) [EOL] index += [number] [EOL] partial_res . append ( partial_re ) [EOL] ctors . append ( ctor ) [EOL] [EOL] self . ctors = { index : ( ctor , start_index [ i ] ) for i , ctor in enumerate ( ctors ) for index in range ( start_index [ i ] , end_index [ i ] + [number] ) } [EOL] [EOL] [EOL] self . re = [string] + ( [string] . join ( partial_res ) ) + [string] [EOL] self . rx = re . compile ( self . re ) [EOL] [EOL] print ( self . ctors ) [EOL] [EOL] def not_matched ( self , string , pos ) : [EOL] pass [EOL] [EOL] def construct ( self , ctor , match , group_base ) : [EOL] return ctor ( match , group_base ) [EOL] [EOL] def match ( self , string , pos = [number] ) : [EOL] m = self . rx . match ( string , pos ) [EOL] if not m : return self . not_matched ( string , pos ) [EOL] ctor , group_base = self . ctors [ m . lastindex ] [EOL] return ( m . end ( ) - m . start ( ) ) , self . construct ( ctor , m , group_base ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import lib [EOL] from . . master_regex import MasterRe [EOL] [EOL] def test_master_regex ( ) : [EOL] [EOL] mre = MasterRe ( [ ( [string] , lambda m , i : ( [string] , m , i ) ) , ( [string] , lambda m , i : ( [string] , m , i ) ) , ( [string] , lambda m , i : ( [string] , m , i ) ) ] ) [EOL] [EOL] def match ( s ) : [EOL] l , ( t , _ , i ) = mre . match ( s ) [EOL] return t , l , i [EOL] [EOL] assert match ( [string] ) == ( [string] , [number] , [number] ) [EOL] assert match ( [string] ) == ( [string] , [number] , [number] ) [EOL] [EOL] assert match ( [string] ) == ( [string] , [number] , [number] ) [EOL] assert match ( [string] ) == ( [string] , [number] , [number] ) [EOL] [EOL] assert match ( [string] ) == ( [string] , [number] , [number] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [docstring] [EOL] [EOL] from abc import abstractmethod [EOL] from infix import shift_infix as infix [EOL] [EOL] [EOL] class Predicate ( object ) : [EOL] [EOL] [docstring] [EOL] [EOL] @ abstractmethod def __call__ ( self , subject ) : [EOL] [docstring] [EOL] [EOL] @ abstractmethod def __init__ ( self , * pargs , ** kwargs ) : [EOL] [docstring] [EOL] [EOL] def __or__ ( self , term2 ) : [EOL] return Disjunction ( self , term2 ) [EOL] [EOL] def __and__ ( self , term2 ) : [EOL] return Conjunction ( self , term2 ) [EOL] [EOL] def __invert__ ( self ) : [EOL] return Negation ( self ) [EOL] [EOL] def __ror__ ( self , term1 ) : [EOL] return Disjunction ( term1 , self ) [EOL] [EOL] def __rand__ ( self , term1 ) : [EOL] return Conjunction ( term1 , self ) [EOL] [EOL] [EOL] class Conjunction ( Predicate ) : [EOL] [EOL] def __init__ ( self , term1 , term2 ) : [EOL] self . term1 = term1 [EOL] self . term2 = term2 [EOL] [EOL] def __call__ ( self , subject ) : [EOL] if self . term1 ( subject ) : [EOL] return self . term2 ( subject ) [EOL] else : [EOL] return False [EOL] [EOL] [EOL] class Disjunction ( Predicate ) : [EOL] [EOL] def __init__ ( self , term1 , term2 ) : [EOL] self . term1 = term1 [EOL] self . term2 = term2 [EOL] [EOL] def __call__ ( self , subject ) : [EOL] if self . term1 ( subject ) : [EOL] return True [EOL] else : [EOL] return self . term2 ( subject ) [EOL] [EOL] [EOL] class Negation ( Predicate ) : [EOL] def __init__ ( self , term ) : [EOL] self . term = term [EOL] [EOL] def __call__ ( self , subject ) : [EOL] return not ( self . term ( subject ) ) [EOL] [EOL] [EOL] class PredicateFromFunction ( Predicate ) : [EOL] [EOL] def __init__ ( self , pred ) : [EOL] self . pred = pred [EOL] [EOL] def __call__ ( self , subject ) : [EOL] return self . pred ( subject ) [EOL] [EOL] [EOL] def predicate ( pred ) : [EOL] [EOL] [docstring] [EOL] [EOL] return PredicateFromFunction ( pred ) [EOL] [EOL] [EOL] @ infix def AND ( a , b ) : [EOL] [EOL] [docstring] [EOL] [EOL] return Conjunction ( a , b ) [EOL] [EOL] [EOL] @ infix def OR ( a , b ) : [EOL] [EOL] [docstring] [EOL] [EOL] return Disjunction ( a , b ) [EOL] [EOL] [EOL] def NOT ( a ) : [EOL] [EOL] [docstring] [EOL] [EOL] return Negation ( a ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] class Struct ( object ) : [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . __dict__ . update ( kwargs ) [EOL] self . _attributes = kwargs [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( CLASSNAME = self . __class__ . __name__ , ATTRIBS = self . _attributes ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] try : [EOL] return self . _attributes == other . _attributes [EOL] except AttributeError : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] [EOL] def create_predicates ( ) : [EOL] [EOL] [docstring] [EOL] [EOL] from greenland . toolbox . predicates import predicate , Predicate [EOL] [EOL] [comment] [EOL] odd = predicate ( lambda x : x % [number] == [number] ) [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] @ predicate def even ( x ) : [EOL] return x % [number] == [number] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class dividable_by ( Predicate ) : [EOL] [EOL] def __init__ ( self , divisor ) : [EOL] self . divisor = divisor [EOL] [EOL] def __call__ ( self , value ) : [EOL] return ( value % self . divisor ) == [number] [EOL] [comment] [EOL] [EOL] [comment] [EOL] class greater ( Predicate ) : [EOL] [EOL] def __init__ ( self , limit ) : [EOL] self . limit = limit [EOL] [EOL] def __call__ ( self , value ) : [EOL] return value > self . limit [EOL] [comment] [EOL] [EOL] return odd , even , dividable_by , greater [EOL] [EOL] [EOL] def test_predicate_creation2 ( ) : [EOL] [docstring] [EOL] [EOL] odd , even , dividable_by , greater = create_predicates ( ) [EOL] [EOL] [comment] [EOL] assert even ( [number] ) [EOL] assert not even ( [number] ) [EOL] [EOL] assert odd ( [number] ) [EOL] assert not odd ( [number] ) [EOL] [EOL] assert ( dividable_by ( [number] ) ) ( [number] ) [comment] [EOL] [EOL] dividable_by_3 = dividable_by ( [number] ) [comment] [EOL] [EOL] assert dividable_by_3 ( [number] ) [EOL] assert not dividable_by_3 ( [number] ) [EOL] [EOL] assert ( greater ( [number] ) ) ( [number] ) [EOL] [comment] [EOL] [EOL] [EOL] def compose_predicates ( ) : [EOL] [EOL] _ , even , dividable_by , greater = create_predicates ( ) [EOL] [EOL] [comment] [EOL] def less ( x ) : [EOL] return ~ greater ( x - [number] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] def in_range ( x , y ) : [EOL] return ( ~ less ( x ) ) & ( ~ greater ( y ) ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] def in_range2 ( x , y ) : [EOL] return ~ ( less ( x ) | greater ( y ) ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] return less , in_range , in_range2 [EOL] [EOL] [EOL] def test_operators ( ) : [EOL] [EOL] [docstring] [EOL] [EOL] less , in_range , in_range2 = compose_predicates ( ) [EOL] [EOL] [comment] [EOL] assert ( less ( [number] ) ) ( [number] ) [EOL] assert not ( less ( [number] ) ( [number] ) ) [EOL] [EOL] assert in_range ( [number] , [number] ) ( [number] ) [EOL] assert in_range ( [number] , [number] ) ( [number] ) [EOL] assert in_range ( [number] , [number] ) ( [number] ) [EOL] [EOL] assert not ( in_range ( [number] , [number] ) ( [number] ) ) [EOL] assert not ( in_range ( [number] , [number] ) ( [number] ) ) [EOL] [EOL] assert in_range2 ( [number] , [number] ) ( [number] ) [EOL] assert in_range2 ( [number] , [number] ) ( [number] ) [EOL] assert in_range2 ( [number] , [number] ) ( [number] ) [EOL] [EOL] assert not ( in_range2 ( [number] , [number] ) ( [number] ) ) [EOL] assert not ( in_range2 ( [number] , [number] ) ( [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_right_side_operators ( ) : [EOL] [EOL] [docstring] [EOL] [EOL] _ , in_range , _ = compose_predicates ( ) [EOL] [EOL] [comment] [EOL] def odd ( x ) : [comment] [EOL] return ( x % [number] == [number] ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] def odd_and_in_range ( x , y ) : [EOL] return odd & in_range ( x , y ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] def odd_or_in_range ( x , y ) : [EOL] return odd | in_range ( x , y ) [EOL] [comment] [EOL] [EOL] [comment] [EOL] assert ( callable ( odd_and_in_range ) ) [EOL] [EOL] assert odd_and_in_range ( [number] , [number] ) ( [number] ) [comment] [EOL] assert not ( odd_and_in_range ( [number] , [number] ) ( [number] ) ) [comment] [EOL] assert not ( odd_and_in_range ( [number] , [number] ) ( [number] ) ) [comment] [EOL] [EOL] assert ( callable ( odd_or_in_range ) ) [EOL] [EOL] assert ( not odd_or_in_range ( [number] , [number] ) ( [number] ) ) [comment] [EOL] assert odd_or_in_range ( [number] , [number] ) ( [number] ) [comment] [EOL] assert odd_or_in_range ( [number] , [number] ) ( [number] ) [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_alternative_operators ( ) : [EOL] [EOL] [docstring] [EOL] [EOL] _ , _ , _ , greater = create_predicates ( ) [EOL] less , _ , _ = compose_predicates ( ) [EOL] [EOL] from greenland . toolbox . predicates import NOT , AND , OR [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def in_range3 ( x , y ) : [EOL] return NOT ( less ( x ) ) << AND >> NOT ( greater ( y ) ) [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def in_range4 ( x , y ) : [EOL] return NOT ( less ( x ) << OR >> greater ( y ) ) [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] assert in_range3 ( [number] , [number] ) ( [number] ) [EOL] assert in_range3 ( [number] , [number] ) ( [number] ) [EOL] assert in_range3 ( [number] , [number] ) ( [number] ) [EOL] [EOL] assert not ( in_range3 ( [number] , [number] ) ( [number] ) ) [EOL] assert not ( in_range3 ( [number] , [number] ) ( [number] ) ) [EOL] [EOL] assert in_range4 ( [number] , [number] ) ( [number] ) [EOL] assert in_range4 ( [number] , [number] ) ( [number] ) [EOL] assert in_range4 ( [number] , [number] ) ( [number] ) [EOL] [EOL] assert not ( in_range4 ( [number] , [number] ) ( [number] ) ) [EOL] assert not ( in_range4 ( [number] , [number] ) ( [number] ) ) [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import lib [EOL] import pytest [EOL] [EOL] [EOL] [comment] [EOL] [EOL] def test_structs ( ) : [EOL] [EOL] from . . structs import Struct [EOL] [EOL] s1 = Struct ( foo = [string] , bar = [string] ) [EOL] [EOL] assert hasattr ( s1 , [string] ) and s1 . foo == [string] [EOL] assert hasattr ( s1 , [string] ) and s1 . bar == [string] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any , Mapping [EOL] import typing [EOL] import lib [EOL] from . specification2 import Option , Flag , Required , Optional , no_variadic , Variadic , Subcommand [EOL] from greenland . conventions import UserError [EOL] from . parsers import append_to_list , add_to_set [EOL] [EOL] [comment] [EOL] [EOL] class CommandPackageMeta ( type ) : [EOL] [EOL] @ staticmethod def subcommand ( namespace ) : [EOL] def define ( name , aliases = [ ] , doc = None , usage = [ ] ) : [EOL] def decorate ( f ) : [EOL] from . specification2 import SubcommandSpecification [EOL] cli = SubcommandSpecification ( usage ) [EOL] nonlocal namespace [EOL] namespace [ [string] ] . append ( Subcommand ( name , aliases , f , doc , cli . parser ) ) [EOL] return f [EOL] return decorate [EOL] return define [EOL] [EOL] @ classmethod def __prepare__ ( mcls , name , bases , ** kwds ) : [EOL] namespace = type . __prepare__ ( name , name , bases , ** kwds ) [EOL] namespace [ [string] ] = [ ] [EOL] namespace [ [string] ] = mcls . subcommand ( namespace ) [EOL] return namespace [EOL] [EOL] def __init__ ( cls , name , bases , namespace , * more ) : [EOL] super ( ) . __init__ ( name , bases , namespace , * more ) [EOL] [EOL] [EOL] try : options = cls . options [EOL] except AttributeError : options = [ ] [EOL] [EOL] try : subcommands = cls . __subcommands__ [EOL] except AttributeError : subcommands = None [EOL] [EOL] if subcommands != None : [EOL] from . specification2 import CommandPackageSpecification [EOL] cls . __cli__ = cli = CommandPackageSpecification ( options , subcommands ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class CommandPackage ( object , metaclass = CommandPackageMeta ) : [EOL] [EOL] def __init__ ( self , argv = None , run = True , exit_on_error = True ) : [EOL] [EOL] import sys [EOL] from greenland . conventions import UserError , longstr [EOL] from . parsers import CommandLine [EOL] [EOL] if argv == None : argv = sys . argv [EOL] self . __argv__ = argv [EOL] [EOL] try : [EOL] with CommandLine ( argv ) as tokens : [EOL] options , subcommand , args = self . __cli__ . parse ( tokens ) [EOL] [EOL] self . __options__ = options [EOL] self . __subcommand__ = subcommand [EOL] self . __args__ = args [EOL] [EOL] self . set_options ( ** options ) [EOL] [EOL] if run : self . run ( ) [EOL] [EOL] except UserError as err : [EOL] if exit_on_error : [EOL] print ( longstr ( err ) ) [EOL] exit ( [number] ) [EOL] raise [EOL] [EOL] def set_options ( self , ** options ) : [EOL] from greenland . toolbox . structs import Struct [EOL] [EOL] try : [EOL] name = self . option_struct [EOL] except AttributeError : [EOL] name = None [EOL] [EOL] if name != None : [EOL] setattr ( self , name , Struct ( ** options ) ) [EOL] else : [EOL] self . __dict__ . update ( options ) [EOL] [EOL] def run ( self ) : [EOL] self . __subcommand__ . command ( self , ** self . __args__ ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.specification2.SubcommandSpecification$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.specification2.SubcommandSpecification$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from . specification2 import Option , Flag , Required , Optional , no_variadic , Variadic [EOL] from greenland . conventions import UserError [EOL] from . parsers import append_to_list , add_to_set [EOL] [EOL] [comment] [EOL] [EOL] class ShellCommandMeta ( type ) : [EOL] [EOL] def __init__ ( cls , name , bases , namespace , * more ) : [EOL] super ( ) . __init__ ( name , bases , namespace , * more ) [EOL] if [string] in namespace : [EOL] from . specification2 import CommandSpecification [EOL] cls . __cli__ = cli = CommandSpecification ( namespace [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class ShellCommand ( object , metaclass = ShellCommandMeta ) : [EOL] [EOL] def __init__ ( self , argv = None , run = True , exit_on_error = True ) : [EOL] [EOL] import sys [EOL] from greenland . conventions import UserError , longstr [EOL] from . parsers import CommandLine [EOL] [EOL] if argv == None : argv = sys . argv [EOL] [EOL] try : [EOL] with CommandLine ( argv ) as tokens : [EOL] options , posargs = self . __cli__ . parse ( tokens ) [EOL] [EOL] self . __argv__ = argv [EOL] self . __posargs__ = posargs [EOL] [EOL] self . set_options ( ** options ) [EOL] [EOL] [EOL] if run : self . run ( ) [EOL] [EOL] except UserError as err : [EOL] if exit_on_error : [EOL] print ( longstr ( err ) ) [EOL] exit ( [number] ) [EOL] raise [EOL] [EOL] def set_options ( self , ** options ) : [EOL] from greenland . toolbox . structs import Struct [EOL] [EOL] try : [EOL] name = self . option_struct [EOL] except AttributeError : [EOL] name = None [EOL] [EOL] if name != None : [EOL] setattr ( self , name , Struct ( ** options ) ) [EOL] else : [EOL] self . __dict__ . update ( options ) [EOL] [EOL] def run ( self ) : [EOL] [EOL] self . main ( ** self . __posargs__ ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] import lib [EOL] from . specification2 import Option , Flag , Required , Optional , no_variadic , Variadic [EOL] from greenland . conventions import UserError , longstr [EOL] from . parsers import append_to_list , add_to_set [EOL] [EOL] def run_script ( namespace , argv = None , exit_on_error = True ) : [EOL] [EOL] import sys [EOL] from . parsers import CommandLine [EOL] from . specification2 import CommandSpecification [EOL] from greenland . toolbox . structs import Struct [EOL] [EOL] if argv == None : argv = sys . argv [EOL] [EOL] assert [string] in namespace , [string] [EOL] cli = CommandSpecification ( namespace [ [string] ] ) [EOL] namespace [ [string] ] = cli [EOL] [EOL] try : [EOL] [EOL] with CommandLine ( argv ) as tokens : [EOL] options , posargs = cli . parse ( tokens ) [EOL] [EOL] namespace [ [string] ] = Struct ( ** options ) [EOL] namespace [ [string] ] = argv [EOL] namespace [ [string] ] = posargs [EOL] [EOL] namespace [ [string] ] ( ** posargs ) [EOL] [EOL] except UserError as err : [EOL] if exit_on_error : [EOL] print ( longstr ( err ) ) [EOL] exit ( [number] ) [EOL] raise [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import lib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] from . parsers import BaseParser , OptionsAndPosArgsParser , PosArgsBinder , end_of_args , nothing , SubcommandsParser , OptionsParser [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class CheckEndOfArgs ( BaseParser ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] end_of_args . parse ( tokens ) [EOL] return [ ] [EOL] [EOL] [comment] [EOL] [EOL] class ParseOptionsAndPosArgs ( BaseParser ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . options_and_posargs_parser = OptionsAndPosArgsParser ( self . options_spec ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] return list ( self . options_and_posargs_parser . parse ( tokens ) ) + super ( ) . parse ( tokens ) [EOL] [EOL] [comment] [EOL] [EOL] class ParseOptions ( object ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . options_parser = OptionsParser ( self . options_spec ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] return [ self . options_parser . parse ( tokens ) ] + super ( ) . parse ( tokens ) [EOL] [EOL] [comment] [EOL] [EOL] class BindPosArgs ( BaseParser ) : [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . posargs_binder = PosArgsBinder ( self . posargs_spec ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] options , posargs , * more = super ( ) . parse ( tokens ) [EOL] posargs = self . posargs_binder . bind ( posargs ) [EOL] [comment] [EOL] [comment] [EOL] return [ options , posargs ] + more [EOL] [EOL] [comment] [EOL] [EOL] class MergeArguments ( BaseParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] options , posargs , * more = super ( ) . parse ( tokens ) [EOL] arguments = { } [EOL] assert len ( posargs . keys ( ) & options . keys ( ) ) == [number] , [string] [comment] [EOL] arguments . update ( options ) [EOL] arguments . update ( posargs ) [EOL] return [ arguments ] + more [EOL] [EOL] [comment] [EOL] [EOL] class ParseSubcommand ( object ) : [EOL] [EOL] def __init__ ( self ) : [EOL] super ( ) . __init__ ( ) [EOL] self . subcommands_parser = SubcommandsParser ( self . subcommands_spec ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] results = self . subcommands_parser . parse ( tokens ) [EOL] return list ( results ) + super ( ) . parse ( tokens ) [EOL] [EOL] [comment] [EOL] [EOL] class CommandParser ( BindPosArgs , ParseOptionsAndPosArgs , CheckEndOfArgs ) : [EOL] [EOL] def __init__ ( self , options_spec , posargs_spec ) : [EOL] self . options_spec = options_spec [EOL] self . posargs_spec = posargs_spec [EOL] super ( ) . __init__ ( ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class SubcommandPackageParser ( ParseOptions , ParseSubcommand , CheckEndOfArgs ) : [EOL] def __init__ ( self , options_spec , subcommands_spec ) : [EOL] self . options_spec = options_spec [EOL] self . subcommands_spec = subcommands_spec [EOL] super ( ) . __init__ ( ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] results = super ( ) . parse ( tokens ) [EOL] assert len ( results ) >= [number] [EOL] return results [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.OptionsAndPosArgsParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.OptionsParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.PosArgsBinder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.SubcommandsParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any , List , Dict , Set [EOL] import typing [EOL] import lib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] from abc import abstractmethod [EOL] from more_itertools import peekable [EOL] from greenland . cmdline . tools import preprocessed , underline , flag [EOL] [EOL] [comment] [EOL] [EOL] def maybe_to_specmap ( data ) : [EOL] if hasattr ( data , [string] ) : return data [EOL] d = { } [EOL] for item in data : [EOL] d [ item . name ] = item [EOL] for key in item . aliases : [EOL] d [ key ] = item [EOL] return d [EOL] [EOL] def append_to_list ( values , new_value ) : [EOL] if values == None : return [ new_value ] [EOL] values . append ( new_value ) [EOL] return values [EOL] [EOL] def add_to_set ( values , new_value ) : [EOL] if values == None : return { new_value } [EOL] values . add ( new_value ) [EOL] return values [EOL] [EOL] [comment] [EOL] [EOL] from greenland . conventions import UserError [EOL] [EOL] class CommandLine ( peekable ) : [EOL] [EOL] [docstring] [EOL] [EOL] def __init__ ( self , cmdline , start = [number] , program = None ) : [EOL] [EOL] super ( ) . __init__ ( preprocessed ( cmdline [ start : ] ) ) [EOL] self . start = start [EOL] self . cmdline = cmdline [EOL] self . program = cmdline [ [number] ] if program == None else program [EOL] [EOL] def __enter__ ( self ) : [EOL] return self [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback ) : [EOL] if exc_type == self . Error : [EOL] raise self . ErrorInContext ( error = exc_value , cmdline = self ) [EOL] return False [EOL] [EOL] class ErrorBase ( UserError ) : [EOL] [EOL] start = [number] [EOL] [EOL] def range_string ( self ) : [EOL] [EOL] tokens = self . tokens [EOL] [EOL] assert len ( tokens ) > [number] [EOL] [EOL] if len ( tokens ) == [number] : [EOL] range = tokens [ [number] ] . origin + self . start - [number] [EOL] else : [EOL] range = [string] . format ( FROM = tokens [ [number] ] . origin + start - [number] , TO = tokens [ - [number] ] . origin + start - [number] ) [EOL] [EOL] return range [EOL] [EOL] def lexemes ( self ) : [EOL] return [ token . lexeme for token in self . tokens ] [EOL] [EOL] class Error ( ErrorBase ) : [EOL] def __init__ ( self , message , tokens ) : [EOL] self . message = message [EOL] self . tokens = tokens [EOL] [EOL] def __str__ ( self ) : [EOL] [EOL] lexemes = self . lexemes ( ) [EOL] if len ( lexemes ) == [number] : return self . message [EOL] [EOL] range = self . range_string ( ) [EOL] [EOL] return ( [string] . format ( MSG = self . message , TOKENS = lexemes , RANGE = self . range_string ( ) ) ) [EOL] [EOL] [EOL] class ErrorInContext ( Error ) : [EOL] [EOL] def __init__ ( self , error , cmdline ) : [EOL] self . error = error [EOL] self . cmdline = cmdline [EOL] [EOL] @ property def args ( self ) : return self . cmdline . cmdline [EOL] [EOL] @ property def program ( self ) : return self . cmdline . program [EOL] [EOL] @ property def start ( self ) : return self . cmdline . start [EOL] [EOL] @ property def tokens ( self ) : return self . error . tokens [EOL] [EOL] @ property def message ( self ) : return self . error . message [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] + self . __longstr__ ( ) [EOL] [EOL] def get_error_context ( self , tokens ) : [EOL] args = self . args [EOL] if tokens != None : [EOL] underlined = set ( ( token . origin + self . start - [number] for token in tokens ) ) [EOL] else : [EOL] underlined = set ( ( len ( args ) , ) ) [EOL] args = list ( args ) + [ [string] ] [EOL] return underline ( args , underlined ) [EOL] [EOL] def __longstr__ ( self ) : [EOL] return [string] . join ( [ self . program + [string] + self . __class__ . __qualname__ + [string] , [string] + [string] . join ( self . get_error_context ( self . tokens ) ) , [string] + self . message + [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class BaseParser ( object ) : [EOL] [EOL] @ abstractmethod def parse ( self , tokens ) : pass [EOL] [EOL] def raise_error ( self , message , tokens ) : [EOL] raise CommandLine . Error ( message , tokens ) [EOL] [EOL] [comment] [EOL] [EOL] class OptionsProcessor ( BaseParser ) : [EOL] [EOL] [EOL] def __init__ ( self , specs ) : [EOL] self . specs = maybe_to_specmap ( specs ) [EOL] [EOL] class Argument ( object ) : [EOL] [EOL] is_kwarg = False [EOL] is_posarg = False [EOL] is_separator = False [EOL] [EOL] def __init__ ( self , tokens ) : [EOL] self . tokens = tokens [EOL] [EOL] @ abstractmethod def store ( self , container ) : pass [EOL] [EOL] @ property def preprocessed_token ( self ) : [EOL] assert len ( self . tokens ) == [number] [EOL] return self . tokens [ [number] ] [EOL] [EOL] class KwArg ( Argument ) : [EOL] [EOL] is_kwarg = True [EOL] [EOL] def __init__ ( self , tokens , key , value , merge = ( lambda values , new_value : new_value ) ) : [EOL] super ( ) . __init__ ( tokens ) [EOL] self . key = key [EOL] self . value = value [EOL] self . merge = merge [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( TOKS = self . tokens , VALUE = self . value , KEY = self . key ) [EOL] [EOL] def store ( self , container ) : [EOL] values = container [ self . key ] if self . key in container else None [EOL] container [ self . key ] = self . merge ( values , self . value ) [EOL] [EOL] [EOL] class PosArg ( Argument ) : [EOL] [EOL] is_posarg = True [EOL] [EOL] def __init__ ( self , tokens , index , value ) : [EOL] super ( ) . __init__ ( tokens ) [EOL] assert len ( self . tokens ) == [number] , [string] [EOL] self . index = index [EOL] self . value = value [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( TOKS = self . tokens , INDEX = self . index , VALUE = self . value ) [EOL] [EOL] def store ( self , container ) : [EOL] [EOL] index = self . index [EOL] [EOL] if isinstance ( container , list ) : [EOL] while not index < len ( container ) : [EOL] container . append ( None ) [EOL] [EOL] container [ index ] = self . value [EOL] [EOL] [EOL] class Separator ( Argument ) : [EOL] [EOL] is_separator = True [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( SEP = self . tokens ) [EOL] [EOL] def conversion ( self , spec ) : [EOL] if hasattr ( spec , [string] ) : [EOL] return spec . convert [EOL] else : [EOL] return lambda x : x [comment] [EOL] [EOL] def convert ( self , spec , arg ) : [EOL] [EOL] conversion = self . conversion ( spec ) [EOL] stringval = arg . value [EOL] try : [EOL] converted = conversion ( stringval ) [EOL] except ValueError : [EOL] self . raise_error ( [string] + repr ( conversion ) , [ arg ] ) [EOL] [EOL] return converted [EOL] [EOL] def merge_method ( self , spec ) : [EOL] if hasattr ( spec , [string] ) and spec . merge != None : return spec . merge [EOL] else : return ( lambda values , new_value : new_value ) [EOL] [EOL] def apply_defaults ( self , options ) : [EOL] for alias , spec in self . specs . items ( ) : [EOL] key = spec . key [EOL] if key in options : continue [EOL] try : [EOL] options [ key ] = spec . default [EOL] except AttributeError : [EOL] pass [EOL] [EOL] def process ( self , args ) : [EOL] return peekable ( self . _process ( args ) ) [EOL] [EOL] def _process ( self , args ) : [EOL] [EOL] assert hasattr ( args , [string] ) , [string] [EOL] [EOL] def convert ( spec , arg ) : return self . convert ( spec , arg ) [EOL] [EOL] n_posargs = [number] [EOL] [EOL] for arg in args : [EOL] [EOL] if arg . is_error : self . raise_error ( [string] + arg . msg , [ arg ] ) [EOL] [EOL] if arg . is_option : [EOL] label = arg . label [EOL] if not label in self . specs : self . raise_error ( [string] , [ arg ] ) [EOL] [EOL] spec = self . specs [ label ] [EOL] [EOL] if arg . carries_value : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] yield( self . KwArg ( [ arg ] , spec . key , convert ( spec , arg ) , self . merge_method ( spec ) ) ) [EOL] [EOL] [EOL] else : [EOL] if hasattr ( spec , [string] ) : [EOL] yield( self . KwArg ( [ arg ] , spec . key , spec . implied_value , self . merge_method ( spec ) ) ) [EOL] [comment] [EOL] else : [EOL] try : [EOL] arg2 = next ( args ) [EOL] except StopIteration : [EOL] self . raise_error ( [string] , None ) [EOL] if not arg2 . is_posarg : [EOL] self . raise_error ( [string] , [ arg , arg2 ] ) [EOL] [EOL] yield( self . KwArg ( [ arg , arg2 ] , spec . key , convert ( spec , arg2 ) , self . merge_method ( spec ) ) ) [EOL] [EOL] elif arg . is_separator : [EOL] yield( self . Separator ( [ arg ] ) ) [EOL] else : [EOL] assert arg . is_posarg , [string] [EOL] [EOL] yield( self . PosArg ( [ arg ] , n_posargs , arg . lexeme ) ) [EOL] n_posargs += [number] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class OptionsParser ( OptionsProcessor ) : [EOL] [EOL] def parse ( self , args ) : [EOL] options = { } [EOL] for item in self . process ( args ) : [EOL] if item . is_kwarg : [EOL] item . store ( options ) [EOL] else : [EOL] assert item . is_posarg or item . is_separator , [string] [EOL] args . prepend ( item . preprocessed_token ) [comment] [EOL] break [EOL] self . apply_defaults ( options ) [EOL] return options [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class OptionsAndPosArgsParser ( OptionsProcessor ) : [EOL] [EOL] def parse ( self , args ) : [EOL] [EOL] options = { } [EOL] posargs = [ ] [EOL] [EOL] for item in self . process ( args ) : [EOL] if item . is_posarg : [EOL] posargs . append ( item . preprocessed_token ) [EOL] elif item . is_kwarg : [EOL] item . store ( options ) [EOL] else : [EOL] assert item . is_separator , [string] [EOL] args . prepend ( item . preprocessed_token ) [comment] [EOL] break [EOL] [EOL] self . apply_defaults ( options ) [EOL] return options , posargs [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class PosArgsCollector ( BaseParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] [EOL] pargs = [ ] [EOL] [EOL] for token in tokens : [EOL] if token . is_posarg : [EOL] pargs . append ( token ) [EOL] else : [EOL] tokens . prepend ( token ) [EOL] break [EOL] [EOL] return pargs [EOL] [EOL] posargs_collector = PosArgsCollector ( ) [EOL] [EOL] [comment] [EOL] [EOL] class PosArgsBinder ( BaseParser ) : [EOL] [EOL] def __init__ ( self , slots ) : [EOL] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . leading = slots . leading [EOL] self . trailing = slots . trailing [EOL] [EOL] self . leading_optional = slots . leading_optional [EOL] self . trailing_optional = slots . trailing_optional [EOL] [EOL] self . variadic = slots . variadic [EOL] [EOL] [EOL] @ property def have_variadic ( self ) : return self . variadic != None [EOL] [EOL] @ property def variadic_min_required ( self ) : [EOL] return [number] if not self . have_variadic else self . variadic . min_required [EOL] [EOL] @ property def variadic_max_allowed ( self ) : [EOL] return [number] if not self . have_variadic else ( None if self . variadic . unlimited_allowed else self . variadic . max_allowed ) [EOL] [EOL] @ property def variadic_unlimited_allowed ( self ) : [EOL] return self . have_variadic and self . variadic . unlimited_allowed [EOL] [EOL] @ property def unlimited_allowed ( self ) : [EOL] return self . variadic_unlimited_allowed [EOL] [EOL] [EOL] @ property def min_required ( self ) : [EOL] return ( len ( self . leading ) + self . variadic_min_required + len ( self . trailing ) ) [EOL] [EOL] @ property def max_allowed ( self ) : [EOL] if self . unlimited_allowed : return None [EOL] return ( len ( self . leading ) + len ( self . leading_optional ) + self . variadic_max_allowed + len ( self . trailing ) + len ( self . trailing_optional ) ) [EOL] [EOL] @ classmethod def conversion ( cls , spec ) : [EOL] if hasattr ( spec , [string] ) : return spec . convert [EOL] else : return ( lambda x : x ) [EOL] [EOL] [EOL] @ classmethod def bind_sequence ( cls , specs , args , result , optional = False ) : [EOL] assert optional or len ( specs ) == len ( args ) , [string] [EOL] [EOL] for i , spec in enumerate ( specs [ : len ( args ) ] ) : [EOL] result [ spec . key ] = cls . conversion ( spec ) ( args [ i ] . lexeme ) [EOL] [EOL] @ classmethod def bind_variadic ( cls , spec , args , result ) : [EOL] assert len ( args ) >= spec . min_required , [string] [EOL] assert spec . unlimited_allowed or len ( args ) <= spec . max_allowed , [string] [EOL] [EOL] result [ spec . key ] = [ ( cls . conversion ( spec ) ( arg . lexeme ) ) for arg in args ] [EOL] [EOL] def bind ( self , args ) : [EOL] [EOL] if len ( args ) < self . min_required : [EOL] self . raise_error ( [string] , None ) [EOL] [EOL] if not self . unlimited_allowed and len ( args ) > self . max_allowed : [EOL] extra_args = args [ self . max_allowed : ] [EOL] self . raise_error ( [string] , extra_args ) [EOL] [EOL] result = { } [EOL] [EOL] b1 = len ( self . leading ) [EOL] b2 = len ( self . trailing ) [EOL] self . bind_sequence ( self . leading , args [ [number] : b1 ] , result ) [EOL] if b2 > [number] : self . bind_sequence ( self . trailing , args [ - b2 : ] , result ) [EOL] [EOL] args0 = args [EOL] args = args [ b1 : len ( args ) - b2 ] [EOL] assert len ( args ) + b1 + b2 == len ( args0 ) , [string] [EOL] [EOL] b1 = min ( len ( self . leading_optional ) , len ( args ) ) [EOL] assert b1 <= len ( args ) , [string] [EOL] [EOL] b2 = ( [number] if b1 == len ( args ) else min ( len ( args ) - b1 , len ( self . trailing_optional ) ) ) [EOL] assert b1 + b2 <= len ( args ) , [string] [EOL] [EOL] self . bind_sequence ( self . leading_optional , args [ [number] : b1 ] , result , optional = True ) [EOL] if b2 > [number] : self . bind_sequence ( list ( reversed ( self . trailing_optional ) ) , list ( reversed ( args [ - b2 : ] ) ) , result , optional = True ) [EOL] [EOL] args0 = args [EOL] args = args [ b1 : len ( args ) - b2 ] [EOL] assert len ( args ) + b1 + b2 == len ( args0 ) , [string] [EOL] [EOL] if self . have_variadic : self . bind_variadic ( self . variadic , args , result ) [EOL] [EOL] return result [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class PosArgsCollectorAndBinder ( PosArgsBinder , PosArgsCollector ) : [EOL] [EOL] def __init__ ( self , slots ) : [EOL] PosArgsBinder . __init__ ( self , slots ) [EOL] PosArgsCollector . __init__ ( self ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] posargs = super ( ) . parse ( tokens ) [EOL] mapping = self . bind ( posargs ) [EOL] return mapping [EOL] [EOL] [comment] [EOL] [EOL] class OptionalSeparator ( BaseParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] token = tokens . peek ( None ) [EOL] if token == None : return [number] [EOL] if token . is_separator : [EOL] next ( tokens ) [EOL] return [number] [EOL] return [number] [EOL] [EOL] optional_separator = OptionalSeparator ( ) [EOL] [EOL] class EndOfArgs ( BaseParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] token = tokens . peek ( None ) [EOL] if token == None : return True [EOL] self . raise_error ( [string] , [ token ] ) [EOL] [EOL] end_of_args = EndOfArgs ( ) [EOL] [EOL] class Nothing ( BaseParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] return None [EOL] [EOL] nothing = Nothing ( ) [EOL] [EOL] [comment] [EOL] [EOL] class SubcommandsSwitch ( BaseParser ) : [EOL] [EOL] def __init__ ( self , subcommands_spec ) : [EOL] self . subcommands_spec = maybe_to_specmap ( subcommands_spec ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] token = tokens . peek ( None ) [EOL] command = token . lexeme if token != None else None [EOL] if command != None : [EOL] if token . is_separator : [EOL] command = None [EOL] else : [EOL] if not token . is_posarg : [EOL] self . raise_error ( [string] , [ token ] ) [EOL] if command in self . subcommands_spec : [EOL] if command != None : [EOL] next ( tokens ) [EOL] return self . subcommands_spec [ command ] [EOL] else : [EOL] if token != None : [EOL] self . raise_error ( [string] , [ token ] ) [EOL] else : [EOL] self . raise_error ( [string] , [ token ] ) [EOL] [EOL] [comment] [EOL] [EOL] class SubcommandsParser ( SubcommandsSwitch ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] subcommand = super ( ) . parse ( tokens ) [EOL] subparser = subcommand . parser [EOL] [EOL] if subparser != None : more = subparser . parse ( tokens ) [EOL] else : more = None [EOL] [EOL] if more == None : more = ( ) [EOL] elif type ( more ) == list : more = tuple ( more ) [EOL] elif type ( more ) != tuple : more = ( more , ) [EOL] [EOL] return ( subcommand , ) + more [EOL] [EOL] [comment] [EOL] [EOL] class Sequence ( BaseParser ) : [EOL] [EOL] def __init__ ( self , * parsers , convert = ( lambda * results : results ) ) : [EOL] self . parsers = parsers [EOL] self . __convert__ = ( lambda * results : results ) if convert == None else convert [EOL] assert hasattr ( convert , [string] ) , [string] [EOL] [EOL] def convert ( self , * results ) : return self . __convert__ ( * results ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] return self . convert ( * [ parser . parse ( tokens ) for parser in self . parsers ] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class OptionsThenPosArgsParser ( Sequence ) : [EOL] def __init__ ( self , options_spec , convert = None ) : [EOL] options_parser = OptionsParser ( options_spec ) [EOL] posargs_parser = PosArgsCollector ( ) [EOL] super ( ) . __init__ ( options_parser , posargs_parser , convert = convert ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Set[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $lib.greenland.cmdline.parsers.PosArgsCollector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.OptionalSeparator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $lib.greenland.cmdline.parsers.EndOfArgs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.Nothing$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $None$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.OptionsParser$ 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.PosArgsCollector$ 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.parsers.OptionsParser$ 0 $lib.greenland.cmdline.parsers.PosArgsCollector$ 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] import builtins [EOL] from typing import Any , List , Dict , Type [EOL] import typing [EOL] import lib [EOL] import re [EOL] from greenland . metaprogramming . definition_order import WithDefinitionOrder [EOL] from more_itertools import peekable [EOL] from abc import abstractmethod [EOL] [EOL] [comment] [EOL] [EOL] class ArgvPreProcessor ( WithDefinitionOrder ) : [EOL] [EOL] class Argument ( object ) : [EOL] is_separator = False [EOL] is_error = False [EOL] base_group = None [comment] [EOL] [EOL] def __init__ ( self , match , origin = None ) : [EOL] self . match = match [EOL] self . origin = origin [EOL] [EOL] @ property def is_option ( self ) : return self . rxc . groups >= [number] [EOL] @ property def is_posarg ( self ) : return ( not self . is_separator ) and ( not self . is_option ) [EOL] [EOL] @ property def carries_value ( self ) : return self . rxc . groups >= [number] [EOL] [EOL] @ property def lexeme ( self ) : return self . match . group ( [number] + self . base_group ) [EOL] @ property def label ( self ) : return self . match . group ( [number] + self . base_group ) [EOL] @ property def value ( self ) : return self . match . group ( [number] + self . base_group ) [EOL] [EOL] def __repr__ ( self ) : [EOL] s = [string] . format ( CLASSNAME = self . __class__ . __name__ , LEXEME = self . lexeme ) [EOL] if self . is_option : [EOL] s += [string] . format ( LABEL = self . label ) [EOL] if self . carries_value : [EOL] s += [string] . format ( VALUE = self . value ) [EOL] s += [string] [EOL] [EOL] return s [EOL] [EOL] class Error ( Argument ) : [EOL] is_error = True [EOL] is_option = False [EOL] is_posarg = False [EOL] carries_value = False [EOL] value = None [EOL] [EOL] [EOL] class NonOption ( Argument ) : [EOL] is_option = False [EOL] [EOL] class PositionalArgument ( NonOption ) : [EOL] rx = [string] [EOL] [EOL] @ property def value ( self ) : return self . lexeme [EOL] [EOL] class DoubleDash ( NonOption ) : [EOL] rx = [string] ; is_separator = True [EOL] [EOL] class Option ( Argument ) : [EOL] is_option = True [EOL] [EOL] class ClassicOption ( Option ) : [EOL] rx = [string] [EOL] [EOL] class ClassicAntiFlag ( Option ) : [EOL] rx = [string] [EOL] carries_value = True [EOL] value = [string] [EOL] [EOL] class AntiFlagTooLongError ( Error ) : [EOL] rx = [string] [EOL] msg = [string] [EOL] [EOL] class AntiFlagMalformedError ( Error ) : [EOL] rx = [string] [EOL] msg = [string] [EOL] [EOL] class GnuOption ( Option ) : [EOL] rx = [string] [EOL] [EOL] class GnuFlag ( Option ) : [EOL] rx = [string] [EOL] carries_value = True [EOL] value = [string] [EOL] [EOL] class GnuOptionMalformedError ( Error ) : [EOL] rx = [string] [EOL] msg = [string] [EOL] [EOL] class NegatedFlag ( Option ) : [EOL] rx = [string] [EOL] carries_value = True [EOL] value = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] [EOL] Argument = self . Argument [EOL] rxs = [ ] [EOL] classes = [ ] [EOL] base_group = [number] [EOL] last_index = { } [EOL] [EOL] for name in reversed ( self . __members_definition_order__ ) : [EOL] member = getattr ( self , name ) [EOL] if isinstance ( member , type ) and issubclass ( member , Argument ) and hasattr ( member , [string] ) : [EOL] classes . append ( member ) [EOL] [EOL] for item in classes : [EOL] [EOL] if not hasattr ( item , [string] ) : [EOL] item . rxc = re . compile ( item . rx ) [EOL] item . base_group = base_group [EOL] last_index [ base_group ] = item [EOL] n_groups = item . rxc . groups + [number] [EOL] base_group += n_groups [EOL] rxs . append ( item . rx ) [EOL] [EOL] self . class_from_lastindex = last_index [EOL] rx = self . rx = [string] + ( [string] . join ( rxs ) ) + [string] [EOL] self . rxc = re . compile ( rx ) [EOL] [EOL] def preprocessed ( self , argv ) : [EOL] for i , arg in enumerate ( argv ) : [EOL] yield self . match ( arg , i + [number] ) [EOL] [EOL] def match ( self , arg , origin = None ) : [EOL] match = self . rxc . match ( arg ) [EOL] tokenclass = self . class_from_lastindex [ match . lastindex ] [EOL] token = tokenclass ( match , origin ) [EOL] return token [EOL] [EOL] def preprocessed ( argv ) : [EOL] return ArgvPreProcessor ( ) . preprocessed ( argv ) [EOL] [EOL] def extract_lexemes ( tokens ) : [EOL] lexemes = [ ] [EOL] for token in tokens : [EOL] lexemes . append ( token . lexeme ) [EOL] return lexemes [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def underline ( args , underlined , maxlength = None ) : [EOL] [docstring] [EOL] [EOL] underlines = [ ( ( [string] if i in underlined else [string] ) * len ( arg ) ) for i , arg in enumerate ( args ) ] [EOL] [EOL] leading_ellipsis = [string] [EOL] trailing_ellipsis = [string] [EOL] [EOL] def current_length ( ) : [EOL] return [number] + len ( leading_ellipsis ) + len ( trailing_ellipsis ) + len ( args ) + sum ( ( len ( arg ) for arg in args ) ) [EOL] [EOL] def result_lines ( ) : [EOL] return ( leading_ellipsis + ( [string] . join ( args ) ) + trailing_ellipsis , [string] * len ( leading_ellipsis ) + ( [string] . join ( underlines ) ) + [string] * len ( trailing_ellipsis ) ) [EOL] [EOL] [EOL] if maxlength == None : return result_lines ( ) [EOL] [EOL] underline_start = min ( underlined ) [EOL] underline_end = max ( underlined ) [EOL] [EOL] if current_length ( ) < maxlength : [EOL] return result_lines ( ) [EOL] [EOL] args = args [ : underline_end + [number] ] [EOL] underlines = underlines [ : underline_end + [number] ] [EOL] trailing_ellipsis = [string] [EOL] [EOL] if current_length ( ) < maxlength : [EOL] return result_lines ( ) [EOL] [EOL] args = args [ underline_start - [number] : ] [EOL] underlines = underlines [ underline_start - [number] : ] [EOL] leading_ellipsis = [string] [EOL] underline_start -= underline_start - [number] [EOL] underline_end -= underline_end - [number] [EOL] [EOL] args = args [ [number] : ] [EOL] underlines = underlines [ [number] : ] [EOL] [EOL] underline_start -= [number] [EOL] underline_end -= [number] [EOL] [EOL] if current_length ( ) < maxlength : [EOL] return result_lines ( ) [EOL] [EOL] return result_lines ( ) [EOL] [EOL] [comment] [EOL] [EOL] def flag ( string ) : [EOL] [EOL] [docstring] [EOL] [EOL] if string in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : return True [EOL] elif string in [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] : return False [EOL] raise ValueError ( [string] + repr ( string ) + [string] ) [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[lib.greenland.cmdline.tools.ArgvPreProcessor.Argument]$ 0 0 0 $typing.Type[lib.greenland.cmdline.tools.ArgvPreProcessor.Argument]$ 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Type[lib.greenland.cmdline.tools.ArgvPreProcessor.Argument]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Type , Set [EOL] import typing [EOL] import lib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] from more_itertools import peekable [EOL] from greenland . toolbox . structs import Struct [EOL] from greenland . cmdline . tools import flag [EOL] from greenland . cmdline . parsers import maybe_to_specmap [EOL] from greenland . cmdline . mixins import CommandParser , SubcommandPackageParser , MergeArguments [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class Specification ( object ) : [EOL] [EOL] is_option = False [EOL] is_posarg = False [EOL] is_marker = False [EOL] is_subcommand = False [EOL] is_variadic = False [EOL] [EOL] def __init__ ( self , name , doc ) : [EOL] self . name = name [EOL] self . __doc__ = doc [EOL] self . _doc = None [EOL] [EOL] @ property def doc ( self ) : [EOL] if self . _doc == None : [EOL] if self . __doc__ != None : [EOL] self . _doc = dedent ( self . __doc__ ) . split ( [string] ) [EOL] else : self . _doc = [ [string] ] [EOL] [EOL] return self . _doc [EOL] [EOL] @ property def tagline ( self ) : [EOL] return self . doc [ [number] ] [EOL] [EOL] [EOL] class ParameterSpecification ( Specification ) : [EOL] [EOL] def __init__ ( self , name , convert , doc ) : [EOL] super ( ) . __init__ ( name , doc ) [EOL] self . convert = convert [EOL] [EOL] @ property def doc_tableline ( self ) : [EOL] return str ( self ) , self . tagline [EOL] [EOL] [comment] [EOL] [EOL] class OptionSpecification ( ParameterSpecification ) : [EOL] [EOL] def __init__ ( self , name , aliases = [ ] , convert = str , doc = None , default = None , key = None ) : [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] assert callable ( convert ) , [string] [EOL] [EOL] super ( ) . __init__ ( name , convert , doc ) [EOL] [EOL] self . aliases = aliases [EOL] [EOL] assert hasattr ( aliases , [string] ) and not type ( aliases ) == str [EOL] [EOL] if key == None : self . key = name [EOL] else : self . key = key [EOL] [EOL] if default != None : self . default = default [EOL] [EOL] @ property def labels ( self ) : [EOL] s = set ( self . aliases ) [EOL] s . add ( self . name ) [EOL] return s [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( CLASSNAME = self . __class__ . __name__ , NAME = self . name , ALIASES = self . aliases , KEY = self . key , CONVERT = self . convert , DOC = [string] ) [EOL] [EOL] [EOL] [EOL] class Option ( OptionSpecification ) : [EOL] [docstring] [EOL] [EOL] is_option = True [EOL] def __str__ ( self ) : [EOL] return [string] + self . name + [string] + self . name . upper ( ) [EOL] [EOL] class Flag ( OptionSpecification ) : [EOL] [docstring] [EOL] [EOL] [EOL] is_option = True [EOL] implied_value = True [EOL] [EOL] def __init__ ( self , name , aliases = [ ] , doc = None , key = None ) : [EOL] super ( ) . __init__ ( name , aliases , convert = flag , doc = doc , default = False , key = key ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] + self . name [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class PositionalParameterSpecification ( ParameterSpecification ) : [EOL] is_variadic = False [EOL] is_posarg = True [EOL] is_optional = False [EOL] [EOL] def __init__ ( self , name , convert = str , doc = None ) : [EOL] [EOL] assert callable ( convert ) , [string] [EOL] [EOL] super ( ) . __init__ ( name , convert , doc ) [EOL] self . key = name [EOL] [EOL] def __repr__ ( self ) : [EOL] return [string] . format ( CLASSNAME = self . __class__ . __name__ , NAME = self . name , CONVERT = self . convert , DOC = [string] ) [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] + self . name . upper ( ) [EOL] [EOL] class Required ( PositionalParameterSpecification ) : [EOL] is_optional = False [EOL] [EOL] class Optional ( PositionalParameterSpecification ) : [EOL] is_optional = True [EOL] [EOL] def __str__ ( self ) : return [string] + super ( ) . __str__ ( ) + [string] [EOL] [EOL] class Variadic ( PositionalParameterSpecification ) : [EOL] is_variadic = True [EOL] is_optional = True [EOL] [EOL] @ property def unlimited_allowed ( self ) : return self . max_allowed == None [EOL] [EOL] def __init__ ( self , name , convert = str , doc = None , min_required = [number] , max_allowed = None ) : [EOL] super ( ) . __init__ ( name , convert , doc ) [EOL] self . min_required = min_required [EOL] self . max_allowed = max_allowed [EOL] [EOL] def __str__ ( self ) : return super ( ) . __str__ ( ) + [string] [EOL] [EOL] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class Subcommand ( Specification ) : [EOL] is_subcommand = True [EOL] [EOL] def __init__ ( self , name , aliases = [ ] , command = None , doc = None , parser = None ) : [EOL] [EOL] super ( ) . __init__ ( name , doc ) [comment] [EOL] [EOL] self . aliases = aliases [EOL] self . command = command if command != None else name [EOL] self . parser = parser [EOL] [EOL] [EOL] @ property def commands ( self ) : [EOL] s = set ( self . aliases ) [EOL] s . add ( self . name ) [EOL] return s [EOL] [EOL] @ property def doc_tableline ( self ) : [EOL] return str ( self ) , self . tagline [EOL] [EOL] def __str__ ( self ) : return self . name [EOL] [EOL] [comment] [EOL] [EOL] class Marker ( Specification ) : [EOL] is_marker = True [EOL] def __init__ ( self , name ) : self . name = name [EOL] [EOL] no_variadic = Marker ( [string] ) [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] class CommandLineSpecificationBase ( object ) : [EOL] [EOL] @ staticmethod def get_option_specs ( specs ) : [EOL] options = [ ] [EOL] for spec in specs : [EOL] if spec . is_option : [EOL] options . append ( spec ) [EOL] else : [EOL] assert spec . is_marker or spec . is_posarg or spec . is_subcommand [EOL] specs . prepend ( spec ) [EOL] break [EOL] return options [EOL] [EOL] @ staticmethod def get_subcommand_specs ( specs ) : [EOL] subcommands = [ ] [EOL] for spec in specs : [EOL] if spec . is_subcommand : [EOL] subcommands . append ( spec ) [EOL] else : [EOL] assert False , [string] [EOL] return subcommands [EOL] [EOL] @ staticmethod def map_from_specs ( specs , keys = lambda obj : obj . keys ) : [EOL] [EOL] map = { } [EOL] [EOL] for spec in specs : [EOL] spec_keys = keys ( spec ) [EOL] for key in spec_keys : [EOL] assert not key in map , [string] . format ( KEY = key , SPEC = spec , SPECS = specs ) [EOL] map [ key ] = spec [EOL] return map [EOL] [EOL] @ classmethod def map_from_option_specs ( cls , specs ) : return cls . map_from_specs ( specs , ( lambda obj : obj . labels ) ) [EOL] [EOL] @ classmethod def map_from_subcommand_specs ( cls , specs ) : return cls . map_from_specs ( specs , ( lambda obj : obj . commands ) ) [EOL] [EOL] @ classmethod def get_posarg_specs ( cls , specs ) : [EOL] leading = [ ] [EOL] leading_optional = [ ] [EOL] variadic = None [EOL] trailing_optional = [ ] [EOL] trailing = [ ] [EOL] [EOL] def collect ( into , predicate ) : [EOL] for spec in specs : [EOL] if predicate ( spec ) : [EOL] into . append ( spec ) [EOL] else : [EOL] specs . prepend ( spec ) [EOL] break [EOL] [EOL] collect ( leading , lambda spec : spec . is_posarg and not spec . is_optional and not spec . is_variadic ) [EOL] collect ( leading_optional , lambda spec : spec . is_posarg and spec . is_optional and not spec . is_variadic ) [EOL] [EOL] variadics = [ ] [EOL] collect ( variadics , lambda spec : spec . is_variadic or spec . is_marker ) [EOL] assert len ( variadics ) <= [number] , [string] + str ( variadics ) [EOL] if len ( variadics ) == [number] : [EOL] variadic = None [EOL] else : [EOL] variadic = variadics [ [number] ] [EOL] [EOL] if variadic == no_variadic : [EOL] variadic = None [EOL] else : [EOL] assert variadic . is_variadic , [string] [EOL] [EOL] collect ( trailing_optional , lambda spec : spec . is_posarg and spec . is_optional and not spec . is_variadic ) [EOL] collect ( trailing , lambda spec : spec . is_posarg and not spec . is_optional and not spec . is_variadic ) [EOL] [EOL] return Struct ( leading = leading , leading_optional = leading_optional , variadic = variadic , trailing_optional = trailing_optional , trailing = trailing ) [EOL] [EOL] def parse ( self , tokens ) : [EOL] return self . parser . parse ( tokens ) [EOL] [EOL] [comment] [EOL] [EOL] class CommandSpecification ( CommandLineSpecificationBase ) : [EOL] [EOL] ParserType = CommandParser [EOL] [EOL] def __init__ ( self , specs ) : [EOL] self . specs = specs [comment] [EOL] specs = peekable ( specs ) [EOL] self . options = self . get_option_specs ( specs ) [EOL] [EOL] spec = specs . peek ( None ) [EOL] [EOL] if spec == None : [EOL] self . posargs = Struct ( leading = [ ] , leading_optional = [ ] , variadic = None , trailing = [ ] , trailing_optional = [ ] ) [EOL] else : [EOL] assert spec . is_posarg , [string] [EOL] self . posargs = self . get_posarg_specs ( specs ) [EOL] assert specs . peek ( None ) == None , [string] [EOL] [EOL] self . parser = self . ParserType ( self . options , self . posargs ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class CommandPackageSpecification ( CommandLineSpecificationBase ) : [EOL] [EOL] def __init__ ( self , options_spec , subcommands_spec ) : [EOL] [EOL] self . options = maybe_to_specmap ( options_spec ) [EOL] self . subcommands = maybe_to_specmap ( subcommands_spec ) [EOL] [EOL] self . parser = SubcommandPackageParser ( self . options , self . subcommands ) [EOL] [EOL] [EOL] class SubcommandParser ( MergeArguments , CommandParser ) : [EOL] pass [EOL] [EOL] class SubcommandSpecification ( CommandSpecification ) : [EOL] ParserType = SubcommandParser [EOL] [EOL] [comment] [EOL] [EOL] class CommandLineSpecificationUNUSED ( object ) : [EOL] [EOL] contains_subcommands = False [EOL] [EOL] [EOL] def __init__ ( self , specs ) : [EOL] self . specs = specs [comment] [EOL] specs = peekable ( specs ) [EOL] [EOL] self . options = self . get_option_specs ( specs ) [EOL] [EOL] spec = specs . peek ( None ) [EOL] [EOL] if spec != None : [EOL] if spec . is_posarg : [EOL] self . posargs = self . get_posarg_specs ( specs ) [EOL] else : [EOL] assert spec . is_subcommand , [string] [EOL] self . contains_subcommands = True [EOL] self . subcommands = self . get_subcommand_specs ( specs ) [EOL] else : [EOL] self . posargs = [ [ ] , [ ] , None , [ ] , [ ] ] [EOL] [EOL] assert specs . peek ( None ) == None , [string] [EOL] [EOL] @ staticmethod def get_option_specs ( specs ) : [EOL] options = [ ] [EOL] for spec in specs : [EOL] if spec . is_option : [EOL] options . append ( spec ) [EOL] else : [EOL] assert spec . is_marker or spec . is_posarg or spec . is_subcommand [EOL] specs . prepend ( spec ) [EOL] break [EOL] return options [EOL] [EOL] @ staticmethod def get_subcommand_specs ( specs ) : [EOL] subcommands = [ ] [EOL] for spec in specs : [EOL] if spec . is_subcommand : [EOL] subcommands . append ( spec ) [EOL] else : [EOL] assert False , [string] [EOL] return subcommands [EOL] [EOL] @ staticmethod def map_from_specs ( specs , keys = lambda obj : obj . keys ) : [EOL] [EOL] map = { } [EOL] [EOL] for spec in specs : [EOL] spec_keys = keys ( spec ) [EOL] for key in spec_keys : [EOL] assert not key in map , [string] . format ( KEY = key , SPEC = spec , SPECS = specs ) [EOL] map [ key ] = spec [EOL] return map [EOL] [EOL] @ classmethod def map_from_option_specs ( cls , specs ) : return cls . map_from_specs ( specs , ( lambda obj : obj . labels ) ) [EOL] [EOL] @ classmethod def map_from_subcommand_specs ( cls , specs ) : return cls . map_from_specs ( specs , ( lambda obj : obj . commands ) ) [EOL] [EOL] @ classmethod def get_posarg_specs ( cls , specs ) : [EOL] leading = [ ] [EOL] leading_optional = [ ] [EOL] variadic = None [EOL] trailing_optional = [ ] [EOL] trailing = [ ] [EOL] [EOL] def collect ( into , predicate ) : [EOL] for spec in specs : [EOL] if predicate ( spec ) : [EOL] into . append ( spec ) [EOL] else : [EOL] specs . prepend ( spec ) [EOL] break [EOL] [EOL] collect ( leading , lambda spec : spec . is_posarg and not spec . is_optional and not spec . is_variadic ) [EOL] collect ( leading_optional , lambda spec : spec . is_posarg and spec . is_optional and not spec . is_variadic ) [EOL] [EOL] variadics = [ ] [EOL] collect ( variadics , lambda spec : spec . is_variadic or spec . is_marker ) [EOL] assert len ( variadics ) <= [number] , [string] + str ( variadics ) [EOL] if len ( variadics ) == [number] : [EOL] variadic = None [EOL] else : [EOL] variadic = variadics [ [number] ] [EOL] [EOL] if variadic == no_variadic : [EOL] variadic = None [EOL] else : [EOL] assert variadic . is_variadic , [string] [EOL] [EOL] collect ( trailing_optional , lambda spec : spec . is_posarg and spec . is_optional and not spec . is_variadic ) [EOL] collect ( trailing , lambda spec : spec . is_posarg and not spec . is_optional and not spec . is_variadic ) [EOL] [EOL] return leading , leading_optional , variadic , trailing_optional , trailing [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $lib.greenland.cmdline.specification2.Marker$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $None$ 0 $lib.greenland.cmdline.specification2.Marker$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $None$ 0 $None$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[lib.greenland.cmdline.specification2.CommandSpecification]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[lib.greenland.cmdline.specification2.SubcommandParser]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 $None$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $None$ 0 $lib.greenland.cmdline.specification2.Marker$ 0 0 $None$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $None$ 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from greenland . cmdline . scriptomatic import * [EOL] [EOL] usage = [ Option ( [string] , [ [string] ] , int , [string] ) , Flag ( [string] , [ [string] ] , [string] ) , Required ( [string] , str , [string] ) ] [EOL] [EOL] [EOL] def main ( target ) : [EOL] print ( [string] ) [EOL] print ( option ) [EOL] print ( target ) [EOL] print ( [string] ) [EOL] [EOL] global target_saved [EOL] target_saved = target [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] run_script ( globals ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] import pytest [EOL] [EOL] from greenland . cmdline . commandpackages import CommandPackage [EOL] [EOL] class Example ( CommandPackage ) : [EOL] pass [EOL] [EOL] @ pytest . mark . bug def test_190119a ( ) : [EOL] [EOL] Example ( argv = [ [string] ] ) [comment] [EOL] [EOL] @ pytest . mark . bug def test_190119a_unknown_subcommand ( ) : [EOL] from greenland . cmdline . parsers import CommandLine [EOL] [EOL] [comment] [EOL] [EOL] with pytest . raises ( CommandLine . ErrorInContext , match = [string] ) : [EOL] Example ( argv = [ [string] , [string] ] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from greenland . conventions import longstr [EOL] from greenland . cmdline . tools import ArgvPreProcessor , flag , extract_lexemes [EOL] [EOL] import pytest [EOL] from pytest import raises , mark [EOL] import re [EOL] [EOL] from greenland . toolbox . structs import Struct [EOL] [EOL] [EOL] Spec = Struct [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def check ( lexeme , label = None , value = None , sep = False , posarg = False ) : [EOL] [EOL] token = ArgvPreProcessor ( ) . match ( lexeme ) [EOL] [EOL] assert token . is_separator == sep [EOL] assert isinstance ( token , ArgvPreProcessor . PositionalArgument ) == posarg [EOL] [EOL] if label != None : [EOL] assert token . is_option [EOL] assert token . label == label [EOL] if value != None : [EOL] assert token . carries_value [EOL] assert token . value == value [EOL] else : [EOL] assert not token . carries_value [EOL] else : [EOL] assert not token . is_option [EOL] assert not token . carries_value [EOL] [EOL] [comment] [EOL] [EOL] def test_preprocessing ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , label = [string] ) [EOL] check ( [string] , label = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , label = [string] , value = [string] ) [comment] [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , posarg = True ) [EOL] check ( [string] , posarg = True ) [EOL] [EOL] check ( [string] , posarg = True ) [EOL] check ( [string] , posarg = True ) [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , sep = True ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] check ( [string] , label = [string] , value = [string] ) [EOL] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from . import example_scriptomatic_p1 as p1 [EOL] from . . scriptomatic import run_script [EOL] [EOL] import sys [EOL] [EOL] [comment] [EOL] [EOL] def test_running_scriptomatic_script ( ) : [EOL] run_script ( p1 . __dict__ , [ [string] , [string] , [string] , [string] ] ) [EOL] assert p1 . option . alpha == [number] [EOL] assert p1 . target_saved == [string] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import List , Any [EOL] import typing [EOL] import lib [EOL] from . . parsers import CommandLine , nothing , OptionsAndPosArgsParser [EOL] [EOL] from greenland . toolbox . structs import Struct [EOL] from greenland . cmdline . tools import flag [EOL] [EOL] import pytest [EOL] import textwrap [EOL] [EOL] from . parsers import options_spec_1 , posargs_spec_1 [EOL] [EOL] [comment] [EOL] [EOL] from . . mixins import CommandParser , MergeArguments [EOL] [EOL] def test_mixins_spike ( ) : [EOL] [EOL] [EOL] class Parser ( MergeArguments , CommandParser ) : [EOL] [EOL] def parse ( self , tokens ) : [EOL] arguments = super ( ) . parse ( tokens ) [EOL] assert len ( arguments ) == [number] [EOL] return arguments [ [number] ] [EOL] [EOL] [EOL] parser = Parser ( options_spec_1 , posargs_spec_1 ) [EOL] [EOL] def parse ( * args ) : [EOL] [EOL] with CommandLine ( [ [string] ] + list ( args ) ) as tokens : [EOL] nonlocal parser [EOL] r = parser . parse ( tokens ) [EOL] return r , len ( list ( tokens ) ) [EOL] [EOL] assert parse ( [string] , [string] , [string] , [string] , [string] ) == ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [ ] , [string] : True } , [number] ) [EOL] assert parse ( [string] , [string] , [string] , [string] , [string] ) == ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [ ] , [string] : True } , [number] ) [EOL] assert parse ( [string] , [string] , [string] , [string] , [string] ) == ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [number] , [string] : [ ] , [string] : True } , [number] ) [EOL] [EOL] with pytest . raises ( CommandLine . ErrorInContext ) as info : [EOL] parse ( [string] , [string] ) [EOL] [EOL] assert str ( info . value ) == textwrap . dedent ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] from . . mixins import SubcommandPackageParser [EOL] [EOL] def test_subcommand_package_spike ( ) : [EOL] [EOL] none = Struct ( name = None , aliases = [ ] , parser = nothing ) [EOL] [EOL] foo = Struct ( name = [string] , aliases = [ [string] , [string] ] , parser = OptionsAndPosArgsParser ( [ Struct ( name = [string] , aliases = [ [string] ] , key = [string] , implied_value = True , convert = flag ) , Struct ( name = [string] , aliases = [ [string] ] , key = [string] , convert = float ) ] ) ) [EOL] [EOL] bar = Struct ( name = [string] , aliases = [ [string] ] , parser = OptionsAndPosArgsParser ( [ Struct ( name = [string] , aliases = [ [string] ] , key = [string] , convert = int ) , ] ) ) [EOL] [EOL] subcommands_spec = [ none , foo , bar ] [EOL] [EOL] parser = SubcommandPackageParser ( options_spec_1 , subcommands_spec ) [EOL] [EOL] def parse ( * args ) : [EOL] [EOL] with CommandLine ( [ [string] ] + list ( args ) ) as tokens : [EOL] nonlocal parser [EOL] r = parser . parse ( tokens ) [EOL] if len ( r ) >= [number] : [EOL] r [ [number] ] = [ token . lexeme for token in r [ [number] ] ] [EOL] return r , len ( list ( tokens ) ) [EOL] [EOL] assert parse ( [string] , [string] , [string] , [string] ) == ( [ { [string] : True } , foo , { [string] : [number] } , [ ] ] , [number] ) [EOL] assert parse ( [string] , [string] , [string] , [string] , [string] ) == ( [ { [string] : True } , foo , { [string] : [number] } , [ [string] ] ] , [number] ) [EOL] [EOL] assert parse ( [string] ) == ( [ { [string] : True } , none ] , [number] ) [EOL] assert parse ( ) == ( [ { } , none ] , [number] ) [EOL] [EOL] [EOL] with pytest . raises ( CommandLine . ErrorInContext ) as info : [EOL] parse ( [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] assert str ( info . value ) == textwrap . dedent ( [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] from fnmatch import fnmatch [EOL] [EOL] def basename ( name ) : [EOL] def basename ( obj ) : [EOL] return obj . name == name [EOL] return basename [EOL] [EOL] def matches ( wildcards ) : [EOL] def matches ( obj ) : [EOL] return fnmatch ( obj . name , wildcards ) [EOL] return matches [EOL] [EOL] def relpath_matches ( wildcards ) : [EOL] def relpath_matches ( obj ) : [EOL] return fnmatch ( obj . relpath , wildcards ) [EOL] return relpath_matches [EOL] [EOL] def extension ( ext ) : [EOL] def extension ( obj ) : [EOL] return obj . ext == ext [EOL] return extension [EOL] [EOL] def basenames ( * names ) : [EOL] def basenames ( obj ) : [EOL] return obj . name in names [EOL] return basenames [EOL] [EOL] def is_dir ( obj ) : [EOL] return obj . is_dir [EOL] [EOL] from greenland . toolbox . predicates import AND , NOT , OR [EOL] [EOL] version_control_data = ( ( is_dir << AND >> basenames ( [string] , [string] ) ) << OR >> basenames ( [string] ) ) [EOL] [EOL] backup_file = NOT ( is_dir ) << AND >> matches ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from . trees import find , find_files [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import ClassVar , List , Any , Type , Set [EOL] import typing [EOL] import lib [EOL] import os [EOL] import stat [EOL] from typing import ClassVar , List , Type [EOL] [EOL] [EOL] [comment] [EOL] [EOL] class FSObjectInitError ( Exception ) : [EOL] pass [EOL] [EOL] class FSObjectTypeError ( FSObjectInitError ) : [EOL] pass [EOL] [EOL] class FSObjectRejected ( FSObjectInitError ) : [EOL] pass [EOL] [EOL] [comment] [EOL] [EOL] TypeFSObject = Type [ [string] ] [EOL] [EOL] class Filter ( object ) : [EOL] [EOL] FSObject = ... [EOL] [EOL] def __init__ ( self , accept = ( lambda obj : True ) , descend = ( lambda obj : True ) ) : [EOL] self . __accept__ = accept [EOL] self . __descend__ = descend [EOL] [EOL] def accept ( self , obj ) : [EOL] return self . __accept__ ( obj ) [EOL] [EOL] def descend ( self , object ) : [EOL] return self . __descend__ ( obj ) [EOL] [EOL] def subfilter ( self , name ) : [EOL] return self [EOL] [EOL] [comment] [EOL] [EOL] class PathInfo ( object ) : [EOL] [EOL] def __init__ ( self , path , directory , name , root , relpath ) : [EOL] self . path = path [EOL] self . directory = directory [EOL] self . name = name [EOL] [EOL] self . root = root [EOL] self . relpath = relpath [EOL] [EOL] def extend ( self , name ) : [EOL] return PathInfo ( os . path . join ( self . path , name ) , self . path , name , self . root , os . path . join ( self . relpath , name ) ) [EOL] [EOL] class RootPathInfo ( PathInfo ) : [EOL] [EOL] name = [string] [EOL] relpath = [string] [EOL] [EOL] def __init__ ( self , path ) : [EOL] self . directory = self . path = path [EOL] [EOL] [EOL] @ property def root ( self ) : return self [EOL] [EOL] def extend ( self , name ) : [EOL] return PathInfo ( os . path . join ( self . path , name ) , self . path , name , self , name ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class FSObject ( object ) : [EOL] [EOL] letter = [string] [EOL] type = lambda self , _ : True [EOL] [EOL] rejected = False [comment] [EOL] [EOL] types = ... [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def __init__ ( self , pathinfo , stat , filter , parent = None ) : [EOL] self . stat = stat [EOL] if not self . check_type ( ) : raise FSObjectTypeError ( pathinfo . path , self . letter ) [EOL] [EOL] self . parent = parent [EOL] self . pathinfo = pathinfo [EOL] self . __basename__ = None [EOL] self . __ext__ = None [EOL] [EOL] if not self . rejected : [comment] [EOL] self . rejected = not filter . accept ( self ) [EOL] [EOL] def check_type ( self ) : [EOL] return self . type ( self . stat . st_mode ) [EOL] [EOL] @ property def path ( self ) : [EOL] return self . pathinfo . path [EOL] [EOL] @ property def relpath ( self ) : [EOL] return self . pathinfo . relpath [EOL] [EOL] @ property def dirname ( self ) : [EOL] return self . pathinfo . directory [EOL] [EOL] @ property def name ( self ) : [EOL] return self . pathinfo . name [EOL] [EOL] def splitext ( self ) : [EOL] if self . __basename__ == None : [EOL] self . __basename__ , ext = os . path . splitext ( self . name ) [EOL] self . __ext__ = ext [ [number] : ] [EOL] return self . __basename__ , self . __ext__ [EOL] [EOL] @ property def ext ( self ) : [EOL] _ , ext = self . splitext ( ) [EOL] return ext [EOL] [EOL] @ property def basename ( self ) : [EOL] basename , _ = self . splitext ( ) [EOL] return basename [EOL] [EOL] @ classmethod def create ( cls , pathinfo , filter = Filter ( ) , parent = None ) : [EOL] [EOL] for Type in reversed ( cls . types ) : [EOL] try : [EOL] obj = Type ( pathinfo , os . stat ( pathinfo . path ) , filter , parent ) [EOL] if obj . rejected and not obj . is_dir : [EOL] break [EOL] else : [EOL] return obj [EOL] except FSObjectInitError : [EOL] pass [EOL] return None [EOL] [EOL] [EOL] @ classmethod def create_root ( cls , path , filter ) : [EOL] return cls . create ( RootPathInfo ( path ) , filter ) [EOL] [EOL] [EOL] @ classmethod def create_subobj ( cls , path , name , filter ) : [EOL] return cls . create ( RootPathInfo ( path ) . extend ( name ) , filter ) [EOL] [EOL] [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] . format ( self = self ) [EOL] [EOL] @ property def is_dir ( self ) : [EOL] return stat . S_ISDIR ( self . stat . st_mode ) [EOL] [EOL] @ property def is_file ( self ) : [EOL] return stat . S_ISREG ( self . stat . st_mode ) [EOL] [EOL] class NotDirectory ( FSObject ) : [EOL] pass [EOL] [EOL] class RegularFSObject ( NotDirectory ) : [EOL] pass [EOL] [EOL] class SpecialFSObject ( NotDirectory ) : [EOL] pass [EOL] [EOL] class Directory ( FSObject ) : [EOL] [EOL] letter = [string] [EOL] type = lambda self , statinfo : stat . S_ISDIR ( statinfo ) [EOL] [EOL] def __init__ ( self , pathinfo , stat , filter , parent = None ) : [EOL] super ( ) . __init__ ( pathinfo , stat , filter , parent ) [EOL] self . filter = filter . subfilter ( pathinfo . name ) [EOL] [EOL] def get_children ( self , accept = lambda obj : obj . is_dir ) : [EOL] for name in os . listdir ( self . path ) : [EOL] child_pathinfo = self . pathinfo . extend ( name ) [EOL] child = self . filter . FSObject . create ( child_pathinfo , self . filter , parent = self ) [EOL] if child != None : [EOL] yield child [EOL] [EOL] @ property def children ( self ) : [EOL] return ( child for child in self . get_children ( ) if not child . rejected ) [EOL] [EOL] def traverse ( self , filter = None ) : [EOL] [EOL] if filter != None : [EOL] d = filter . FSObject . create ( child_pathinfo , filter ) [EOL] assert d . is_dir [EOL] dirs = [ d ] [EOL] else : [EOL] dirs = [ self ] [EOL] [EOL] while len ( dirs ) > [number] : [EOL] d = dirs . pop ( ) [EOL] if not d . rejected : [EOL] yield(d) [EOL] for child in d . get_children ( ) : [EOL] if child . is_dir : [EOL] dirs . append ( child ) [EOL] else : [EOL] assert not child . rejected [comment] [EOL] yield child [EOL] [EOL] [EOL] [EOL] [EOL] class File ( RegularFSObject ) : [EOL] [EOL] letter = [string] [EOL] type = lambda self , statinfo : stat . S_ISREG ( statinfo ) [EOL] [EOL] Filter . FSObject = FSObject [EOL] FSObject . types = [ FSObject , Directory , File ] [EOL] [EOL] [comment] [EOL] [EOL] def find ( * roots , accept = ( lambda obj : True ) , descend = ( lambda obj : True ) ) : [EOL] for rootpath in roots : [EOL] root = FSObject . create ( RootPathInfo ( rootpath ) , filter = Filter ( accept = accept , descend = descend ) ) [EOL] assert root . is_dir [EOL] print ( root . __class__ ) [EOL] for obj in root . traverse ( ) : [EOL] yield obj [EOL] [EOL] [EOL] def find_files ( * roots , accept = ( lambda obj : True ) , accept_parents = False ) : [EOL] [EOL] dirs = set ( ) [EOL] [EOL] def collect_missing_parents ( parent , parents ) : [EOL] while parent != None : [EOL] if not parent in dirs : [EOL] parents . append ( parent ) [EOL] dirs . add ( parent ) [EOL] else : [EOL] return [EOL] parent = parent . parent [EOL] [EOL] def missing_parents ( obj ) : [EOL] parents = [ ] [EOL] collect_missing_parents ( obj . parent , parents ) [EOL] return parents [EOL] [EOL] for obj in find ( * roots , accept = ( lambda obj : ( obj . is_dir ) or accept ( obj ) ) ) : [EOL] if obj . is_dir : continue [EOL] if accept_parents : [EOL] for parent in reversed ( missing_parents ( obj ) ) : [EOL] yield parent [EOL] yield obj [EOL] [EOL] [EOL] [comment] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[TypeFSObject]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.ClassVar[typing.List[TypeFSObject]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] from typing import Dict , List , Any , Union , Optional , Set [EOL] import typing [EOL] import pytest [EOL] [EOL] from . . trees import FSObject , RootPathInfo , find , find_files [EOL] [EOL] [comment] [EOL] [EOL] def create_filetree_fixture ( root , layout ) : [EOL] [EOL] def touch ( path ) : [EOL] with open ( path , [string] ) as f : pass [EOL] [EOL] for key , content in layout . items ( ) : [EOL] [EOL] if ( content == None ) : [EOL] touch ( root . join ( key ) ) [EOL] continue [EOL] [EOL] if type ( content ) == str : [EOL] with open ( root . join ( key ) , [string] ) as f : [EOL] f . write ( content ) [EOL] continue [EOL] [EOL] [EOL] if type ( content ) in [ list , dict ] : [EOL] subdir = root . join ( key ) [EOL] subdir . mkdir ( ) [EOL] [EOL] if type ( content ) == list : [EOL] for name in content : [EOL] touch ( subdir . join ( name ) ) [EOL] continue [EOL] [EOL] if type ( content ) == dict : [EOL] create_filetree_fixture ( subdir , content ) [EOL] continue [EOL] [EOL] [EOL] @ pytest . fixture def filetree1 ( tmpdir ) : [EOL] [EOL] layout = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [string] , [string] : { [string] : None , [string] : None , [string] : [ [string] , [string] , [string] ] } } [EOL] [EOL] root = tmpdir . join ( [string] ) [EOL] [EOL] root . mkdir ( ) [EOL] create_filetree_fixture ( root , layout ) ; [EOL] [EOL] yield str ( root ) [EOL] return [EOL] [EOL] [comment] [EOL] [EOL] def test_spike ( filetree1 ) : [EOL] [EOL] def find_paths ( accept = lambda obj : True ) : [EOL] return { obj . relpath for obj in find ( filetree1 , accept = accept ) } [EOL] [EOL] [EOL] def find_parents ( accept = lambda obj : True ) : [EOL] return { ( obj . parent . relpath if obj . parent != None else None ) for obj in find ( filetree1 , accept = accept ) } [EOL] [EOL] assert find_paths ( lambda obj : obj . ext == [string] ) == { [string] , [string] } [EOL] [EOL] assert find_paths ( ) == { [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] assert find_parents ( lambda obj : obj . ext == [string] ) == { [string] } [EOL] [EOL] assert find_parents ( ) == { None , [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] def find_dirs_and_files ( accept = lambda obj : True ) : [EOL] dirs = set ( ) [EOL] files = set ( ) [EOL] [EOL] for obj in find_files ( filetree1 , accept = accept , accept_parents = True ) : [EOL] if obj . is_dir : [EOL] dirs . add ( obj . relpath ) [EOL] else : [EOL] files . add ( obj . relpath ) [EOL] [EOL] return dirs , files [EOL] [EOL] assert find_dirs_and_files ( lambda obj : obj . ext == [string] ) == ( { [string] , [string] } , { [string] , [string] } ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0