[EOL] from typing import Any [EOL] import typing [EOL] import flask [EOL] import os [EOL] [EOL] from flask import Flask [EOL] [EOL] from vynd_api . api import settings [EOL] from vynd_api . api . api_blueprint import api_bp [EOL] [EOL] def create_app ( config_filename ) : [EOL] app = Flask ( __name__ ) [EOL] app . register_blueprint ( api_bp , url_prefix = [string] ) [EOL] return app [EOL] [EOL] settings . init_video_processor ( ) [EOL] [EOL] [comment] [EOL] app = create_app ( [string] ) [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[EOL] from vynd_api . models . download_vggface_model import download_vggface_model [EOL] [EOL] if __name__ == [string] : [EOL] print ( [string] ) [EOL] download_vggface_model ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from . . data . face_collection import FaceCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data import CLIENT [EOL] from . . data import db_utils [EOL] [EOL] from . . facedetection . face_detection_results import DetectedFace , FaceDetectionResults [EOL] [EOL] from . . utils import image_utils , recognition_utils , numpy_encoder , vggface2_utlis [EOL] [EOL] from . . models . download_vggface_model import download_vggface_model , vgg_exist	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import vynd_api [EOL] import facematching [EOL] import faceembedding [EOL] from typing import List , Collection , Tuple [EOL] [EOL] from . import CLIENT [EOL] from . faceembedding . image_faces_embedder import ImageFacesEmbedder [EOL] from . facematching . image_faces_matcher import ImageFacesMatcher [EOL] from . facematching . face_match import FaceMatch [EOL] from . facematching . face_matching_results import FaceMatchingResults [EOL] from . faceembedding . face_embedding_results import FaceEmbeddingResults [EOL] from . import FaceDetectionResults [EOL] [EOL] class VideoFaceRecognizer ( ) : [EOL] __image_faces_embedder = ... [EOL] __image_faces_matcher = ... [EOL] [EOL] def __init__ ( self , image_faces_embedder , face_collection = CLIENT . vynd_db . face_collection ) : [EOL] self . __image_faces_embedder = image_faces_embedder [EOL] self . __image_faces_matcher = ImageFacesMatcher ( face_collection ) [EOL] [EOL] def recognize ( self , face_detection_results ) : [EOL] embedding_results = list ( map ( lambda detection_result : self . __image_faces_embedder . faces_to_embeddings ( detection_result ) , face_detection_results ) ) [EOL] [EOL] matching_results = list ( map ( lambda embedding_result : self . __image_faces_matcher . match_faces ( embedding_result ) , embedding_results ) ) [EOL] return matching_results [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 0 0 $facematching.image_faces_matcher.ImageFacesMatcher$ 0 0 0 0 0 0 0 0 0 $faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.facerecognition.faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 $faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 0 0 $facematching.image_faces_matcher.ImageFacesMatcher$ 0 0 0 0 0 0 0 0 $typing.List[facematching.face_match.FaceMatch]$ 0 0 0 $typing.List[FaceDetectionResults]$ 0 0 0 $typing.List[typing.List[vynd_api.facerecognition.faceembedding.face_embedding.FaceEmbedding]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[FaceDetectionResults]$ 0 0 0 0 $typing.List[typing.List[vynd_api.facerecognition.facematching.image_faces_matcher.GroupMatch]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[vynd_api.facerecognition.faceembedding.face_embedding.FaceEmbedding]]$ 0 0 0 0 $typing.List[typing.List[vynd_api.facerecognition.facematching.image_faces_matcher.GroupMatch]]$ 0
[EOL] from typing import NamedTuple [EOL] [EOL] import numpy as np [EOL] [EOL] class FaceEmbedding ( NamedTuple ) : [EOL] [docstring] [EOL] features = ... [EOL] face_image = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 $numpy.ndarray$ 0 0 0
import builtins [EOL] from typing import List , Tuple , Any [EOL] import typing [EOL] import numpy [EOL] import face_embedding [EOL] from typing import List [EOL] import numpy as np [EOL] import time [EOL] [EOL] from . image_faces_embedder import ImageFacesEmbedder [EOL] from . face_embedding_results import FaceEmbeddingResults [EOL] from . face_embedding import FaceEmbedding [EOL] from . . import FaceDetectionResults [EOL] from . . import vggface2_utlis , image_utils [EOL] from . . import download_vggface_model , vgg_exist [EOL] [EOL] class VGGFaceEmbedder ( ImageFacesEmbedder ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . __default_dims = ( [number] , [number] ) [comment] [EOL] self . __vggface_path = [string] [comment] [EOL] self . __open_session ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def faces_to_embeddings ( self , detection_results ) : [EOL] [docstring] [EOL] face_embeddings = [ ] [EOL] for face in detection_results . detected_faces : [EOL] if face . image . shape != ( [number] , [number] , [number] ) and face . aligned_image . shape != ( [number] , [number] , [number] ) : [EOL] face_embedding = self . image_to_embedding ( face . aligned_image ) [EOL] face_embeddings . append ( FaceEmbedding ( features = face_embedding , face_image = face . aligned_image ) ) [EOL] [EOL] return face_embeddings [EOL] [EOL] def __open_session ( self ) : [EOL] self . __sess = vggface2_utlis . load_model ( self . __vggface_path ) [comment] [EOL] self . __initialize_tensors ( ) [EOL] [EOL] def __close_session ( self ) : [EOL] self . __sess . close ( ) [EOL] [EOL] def __initialize_tensors ( self ) : [EOL] input_tensor_name = [string] [EOL] phase_train_tensor_name = [string] [EOL] embedding_tensor_name = [string] [EOL] self . __input_tensor = self . __sess . graph . get_tensor_by_name ( input_tensor_name ) [EOL] self . __phase_train_tensor = self . __sess . graph . get_tensor_by_name ( phase_train_tensor_name ) [EOL] self . __embedding_tensor = self . __sess . graph . get_tensor_by_name ( embedding_tensor_name ) [EOL] [EOL] [comment] [EOL] def image_to_embedding ( self , image ) : [EOL] [docstring] [EOL] image = self . __preprocess_image ( image ) [EOL] embedding = self . __sess . run ( self . __embedding_tensor , feed_dict = { self . __input_tensor : image , self . __phase_train_tensor : False } ) [EOL] return np . squeeze ( embedding ) [EOL] [EOL] def __preprocess_image ( self , image ) : [EOL] [docstring] [EOL] image = image_utils . resize_image ( image , new_shape = self . __default_dims ) [EOL] image = vggface2_utlis . normalize_image ( image ) [EOL] return np . array ( [ image ] ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from . . import CLIENT [EOL] from . . import FaceCollection [EOL] [EOL] from . . import DetectedFace [EOL] [EOL] from . . import download_vggface_model , vgg_exist	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import NamedTuple , List [EOL] [EOL] from . face_embedding import FaceEmbedding [EOL] [EOL] class FaceEmbeddingResults ( NamedTuple ) : [EOL] [docstring] [EOL] faces = ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import face_embedding [EOL] from abc import ABC , abstractmethod [EOL] from typing import List [EOL] [EOL] from . import FaceCollection [EOL] from . face_embedding import FaceEmbedding [EOL] from . . import FaceDetectionResults [EOL] from . import DetectedFace [EOL] [EOL] class ImageFacesEmbedder ( ABC ) : [EOL] [EOL] def __init__ ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def faces_to_embeddings ( self , detection_results ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_embedding.FaceEmbedding]$ 0 0 0 $FaceDetectionResults$ 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import vynd_api [EOL] import faceembedding [EOL] from typing import List [EOL] [EOL] from . . faceembedding . face_embedding import FaceEmbedding [EOL] [EOL] def _get_face_connections ( face_embeddings , is_connected_fn ) : [EOL] connection_matrix = [ [ False ] * len ( face_embeddings ) for _ in range ( len ( face_embeddings ) ) ] [EOL] [EOL] for i , embedding_1 in enumerate ( face_embeddings ) : [EOL] for j in range ( i + [number] , len ( face_embeddings ) ) : [EOL] embedding_2 = face_embeddings [ j ] [EOL] connection_matrix [ i ] [ j ] = connection_matrix [ j ] [ i ] = is_connected_fn ( embedding_1 . features , embedding_2 . features ) [EOL] return connection_matrix [EOL] [EOL] def group_faces ( face_embeddings , is_connected_fn ) : [EOL] connection_matrix = _get_face_connections ( face_embeddings , is_connected_fn ) [EOL] is_grouped = [ False ] * len ( face_embeddings ) [EOL] [EOL] def get_group ( i ) : [EOL] if is_grouped [ i ] : [EOL] return [ ] [EOL] is_grouped [ i ] = True [EOL] group = [ face_embeddings [ i ] ] [EOL] for j in range ( len ( face_embeddings ) ) : [EOL] if connection_matrix [ i ] [ j ] : [EOL] group . extend ( get_group ( j ) ) [EOL] return group [EOL] [EOL] face_groups = [ ] [EOL] for i in range ( len ( face_embeddings ) ) : [EOL] cur_group = get_group ( i ) [EOL] if cur_group : [EOL] face_groups . append ( cur_group ) [EOL] [EOL] return face_groups [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Literal , Any , List , Union , Tuple , Optional [EOL] import typing_extensions [EOL] import face_match_status [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] from typing import List , Optional [EOL] [comment] [EOL] [EOL] import numpy as np [EOL] [EOL] from . import CLIENT [EOL] from . import FaceCollection [EOL] from . import FaceEmbedding [EOL] from . face_match_status import FaceMatchStatus [EOL] from . . . utils . recognition_utils import cosine_similarity_distance [EOL] from . . facegrouping . face_grouping import group_faces [EOL] [EOL] [comment] [EOL] class GroupMatch ( ) : [EOL] face_embeddings = ... [EOL] match_status = ... [EOL] matched_id = ... [EOL] [EOL] def __init__ ( self , face_embeddings , match_status , matched_id ) : [EOL] self . face_embeddings = face_embeddings [EOL] self . match_status = match_status [EOL] self . matched_id = matched_id [EOL] [EOL] class ImageFacesMatcher ( ) : [EOL] [EOL] def __init__ ( self , face_collection = CLIENT . vynd_db . face_collection ) : [EOL] self . __face_collection = FaceCollection ( face_collection ) [EOL] self . __similarity_distance_threshold = [number] [EOL] self . __default_face_dims = ( [number] , [number] ) [EOL] [EOL] def match_faces ( self , face_embeddings ) : [EOL] [docstring] [EOL] all_faces = self . __face_collection . get_all_faces_features ( ) [EOL] face_groups = group_faces ( face_embeddings , lambda features_a , features_b : cosine_similarity_distance ( features_a , features_b ) < [number] ) [EOL] [EOL] group_matches = self . __get_group_matches ( face_groups , all_faces ) [EOL] [EOL] return group_matches [EOL] [EOL] def __get_group_matches ( self , groups , all_faces ) : [EOL] [EOL] def find_most_similar_face ( group ) : [EOL] best_sum , best_face = np . inf , None [EOL] for face in all_faces : [EOL] face_sum = [number] [EOL] for embedding in group : [EOL] distance = cosine_similarity_distance ( embedding . features , face [ [string] ] ) [EOL] if distance == [number] : [EOL] return face [ [string] ] [EOL] elif distance < self . __similarity_distance_threshold : [EOL] face_sum += distance [EOL] if ( face_sum != [number] and face_sum < best_sum ) : [EOL] best_sum , best_face = face_sum , face [ [string] ] [EOL] return best_face [EOL] [EOL] def get_group_match ( group ) : [EOL] face_id = find_most_similar_face ( group ) [EOL] match_status = FaceMatchStatus . MATCHED if face_id else FaceMatchStatus . UNKNOWN_FACE [EOL] return GroupMatch ( face_embeddings = group , match_status = match_status , matched_id = face_id ) [EOL] [EOL] return list ( map ( get_group_match , groups ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[FaceEmbedding]$ 0 0 0 $face_match_status.FaceMatchStatus$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 $vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[vynd_api.facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 $typing.List[vynd_api.facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 $vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus$ 0 $vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[GroupMatch]$ 0 0 0 $typing.List[FaceEmbedding]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[FaceEmbedding]]$ 0 0 0 $typing.List[FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[GroupMatch]$ 0 0 0 0 0 $typing.List[typing.List[FaceEmbedding]]$ 0 $typing.Any$ 0 0 0 0 $typing.List[GroupMatch]$ 0 0 0 $typing.List[GroupMatch]$ 0 0 0 $typing.List[typing.List[FaceEmbedding]]$ 0 0 0 0 0 0 0 0 0 $typing.List[FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[FaceEmbedding]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $GroupMatch$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.MATCHED],typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.UNKNOWN_FACE]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.MATCHED],typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.UNKNOWN_FACE]]$ 0 $typing.Union[typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.MATCHED],typing_extensions.Literal[vynd_api.facerecognition.facematching.face_match_status.FaceMatchStatus.UNKNOWN_FACE]]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.List[FaceEmbedding]]$ 0 0 0
[EOL] from . . faceembedding . face_embedding import FaceEmbedding [EOL] [EOL] from . . import CLIENT [EOL] from . . import FaceCollection [EOL] from . . import recognition_utils , image_utils [EOL] from . . import numpy_encoder [EOL] from . . import db_utils	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from enum import Enum [EOL] [EOL] class FaceMatchStatus ( Enum ) : [EOL] [docstring] [EOL] MATCHED = [string] [EOL] UNKNOWN_FACE = [string]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
from typing import List , Optional , Tuple , Any [EOL] from collections import deque [EOL] import entities [EOL] import collections [EOL] import video_processing_results [EOL] import facedetection [EOL] import typing [EOL] import facerecognition [EOL] import builtins [EOL] import vynd_api [EOL] from typing import List [EOL] from collections import deque [EOL] [EOL] from bson import ObjectId [EOL] [EOL] from . video_processing_results import VideoProcessingResult [EOL] from . . entities . keyframe import KeyFrame [EOL] from . . utils import image_utils [EOL] from . . facedetection . yolov3_detector import YOLOv3Detector [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] [EOL] from . . facerecognition . faceembedding . image_faces_embedder import ImageFacesEmbedder [EOL] from . . facerecognition . faceembedding . vggface_embedder import VGGFaceEmbedder [EOL] from . . facerecognition . faceembedding . face_embedding import FaceEmbedding [EOL] [EOL] from . . facerecognition . facematching . face_match_status import FaceMatchStatus [EOL] from . . facerecognition . facematching . image_faces_matcher import ImageFacesMatcher , GroupMatch [EOL] [EOL] from . . data . face_collection import FaceCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data import CLIENT [EOL] [EOL] class VideoProcessor : [EOL] [EOL] def __init__ ( self , face_collection = CLIENT . vynd_db . face_collection , keyframe_collection = CLIENT . vynd_db . keyframe_collection , video_collection = CLIENT . vynd_db . video_collection ) : [EOL] self . __face_collection = FaceCollection ( face_collection ) [EOL] self . __keyframe_collection = KeyFrameCollection ( keyframe_collection ) [EOL] self . __video_collection = VideoCollection ( video_collection ) [EOL] self . __yolov3_image_face_detector = YOLOv3Detector ( ) [EOL] self . __image_face_embedder = VGGFaceEmbedder ( ) [EOL] self . __image_face_matcher = ImageFacesMatcher ( face_collection = face_collection ) [EOL] self . __default_face_dims = ( [number] , [number] ) [EOL] [EOL] def is_invalid_id ( self , video_id ) : [EOL] return not ObjectId . is_valid ( video_id ) or self . __video_collection . get_video_by_id ( video_id ) is None [EOL] [EOL] def __insert_keyframes ( self , video_id , keyframes ) : [EOL] return [ self . __keyframe_collection . insert_new_keyframe ( video_id = video_id ) for keyframe in keyframes ] [EOL] [EOL] def __add_keyframes_to_video ( self , video_id , keyframe_ids ) : [EOL] for keyframe_id in keyframe_ids : [EOL] self . __video_collection . add_keyframe ( video_id = video_id , keyframe_id = keyframe_id ) [EOL] [EOL] def process ( self , video_id , keyframes ) : [EOL] if self . is_invalid_id ( video_id ) : [EOL] return VideoProcessingResult . INVALID_VIDEO_ID [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] face_embedding_results = [ ] [EOL] [EOL] for keyframe in keyframes : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] face_detection_result = self . __yolov3_image_face_detector . detect ( keyframe ) [EOL] face_embedding_result = self . __image_face_embedder . faces_to_embeddings ( face_detection_result ) [EOL] face_embedding_results . extend ( face_embedding_result ) [EOL] [EOL] group_matches = self . __image_face_matcher . match_faces ( face_embedding_results ) [EOL] self . __update_db ( video_id , group_matches ) [EOL] [EOL] return VideoProcessingResult . SUCCESS [EOL] [EOL] def __update_db ( self , video_id , group_matches ) : [EOL] self . __add_new_faces ( video_id , group_matches ) [EOL] self . __add_video_to_faces_assocs ( video_id , group_matches ) [EOL] self . __add_faces_to_video_assocs ( video_id , group_matches ) [EOL] self . __video_collection . update_status ( video_id , True ) [EOL] [EOL] def __add_new_faces ( self , video_id , group_matches ) : [EOL] new_faces = [ ] [EOL] for group_match in group_matches : [EOL] if group_match . match_status == FaceMatchStatus . UNKNOWN_FACE : [EOL] new_faces . append ( self . __get_new_face ( video_id , group_match ) ) [EOL] [EOL] new_ids = deque ( self . __face_collection . insert_new_faces ( new_faces ) ) [EOL] for group_match in group_matches : [EOL] if group_match . match_status == FaceMatchStatus . UNKNOWN_FACE : [EOL] group_match . matched_id = new_ids . popleft ( ) [EOL] [EOL] def __get_new_face ( self , video_id , group_match ) : [EOL] face_embedding = group_match . face_embeddings [ [number] ] [EOL] resized_face_image = image_utils . resize_image ( face_embedding . face_image , new_shape = ( self . __default_face_dims ) ) [EOL] return { [string] : [ video_id ] , [string] : face_embedding . features , [string] : resized_face_image } [EOL] [EOL] def __add_video_to_faces_assocs ( self , video_id , group_matches ) : [EOL] face_ids = [ group_match . matched_id for group_match in group_matches ] [EOL] self . __video_collection . add_faces ( video_id , face_ids ) [EOL] [EOL] def __add_faces_to_video_assocs ( self , video_id , group_matches ) : [EOL] face_ids = [ ] [EOL] for group_match in group_matches : [EOL] if group_match . match_status == FaceMatchStatus . MATCHED : [EOL] face_ids . append ( group_match . matched_id ) [EOL] self . __face_collection . add_video_id_to_faces ( face_ids , video_id ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 0
	0
[docstring] [EOL] [EOL] from enum import Enum [EOL] [EOL] class VideoProcessingResult ( Enum ) : [EOL] SUCCESS = [string] [EOL] FAILURE = [string] [EOL] INVALID_VIDEO_ID = [string]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
[EOL] from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] from typing import Tuple [EOL] [EOL] class BoundingBox : [EOL] [docstring] [EOL] def __init__ ( self , coordinates , confidence ) : [EOL] self . __coordinates = coordinates [EOL] self . __confidence = confidence [EOL] [EOL] @ property def coordinates ( self ) : [EOL] return self . __coordinates [EOL] [EOL] @ property def confidence ( self ) : [EOL] return self . __confidence	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $builtins.float$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0
	0
[EOL] import entities [EOL] import face_detection_results [EOL] import numpy as np [EOL] [EOL] from abc import ABC , abstractmethod [EOL] [EOL] from . face_detection_results import FaceDetectionResults [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] class ImageFaceDetector ( ABC ) : [EOL] [EOL] def __init__ ( self , minimum_confidence = [number] , offset_value = [number] ) : [EOL] self . __minimum_confidence = minimum_confidence [EOL] self . __offset_value = offset_value [EOL] [EOL] @ abstractmethod def detect ( self , keyframe ) : [EOL] pass	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $face_detection_results.FaceDetectionResults$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0
from enum import Enum [EOL] [EOL] class FaceDetectionStatus ( Enum ) : [EOL] [docstring] [EOL] SUCCESS = [string] [EOL] FAIL_NON_RGB_INPUT = [string]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
from typing import List [EOL] import entities [EOL] import typing [EOL] import image_face_detector [EOL] import vynd_api [EOL] import face_detection_results [EOL] from typing import List [EOL] [EOL] from . image_face_detector import ImageFaceDetector [EOL] from . face_detection_results import FaceDetectionResults [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] class VideoFaceDetector ( ) : [EOL] [EOL] __image_face_detector = ... [EOL] [EOL] def __init__ ( self , image_face_detector ) : [EOL] self . __image_face_detector = image_face_detector [EOL] [EOL] def get_detected_results ( self , key_frames ) : [EOL] [docstring] [EOL] return list ( map ( lambda key_frame : self . __image_face_detector . detect ( key_frame ) , key_frames ) )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 $image_face_detector.ImageFaceDetector$ 0 0 0 0 0 $vynd_api.facedetection.image_face_detector.ImageFaceDetector$ 0 $image_face_detector.ImageFaceDetector$ 0 0 0 $typing.List[face_detection_results.FaceDetectionResults]$ 0 0 0 $typing.List[entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[entities.keyframe.KeyFrame]$ 0 0
[EOL] from typing import List , Any [EOL] import entities [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] import face_detection_results [EOL] import dlib [EOL] import cv2 [EOL] import os [EOL] [EOL] import numpy as np [EOL] [EOL] from typing import List [EOL] from dlib import rectangle [EOL] from imutils . face_utils import rect_to_bb [EOL] from pathlib import Path [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] from . image_face_detector import ImageFaceDetector [EOL] from . facealignment . face_alignment import FaceAlignment [EOL] from . face_detection_results import FaceDetectionResults [EOL] from . face_detection_status import FaceDetectionStatus [EOL] from . bounding_box import BoundingBox [EOL] from . face_detection_results import DetectedFace [EOL] [EOL] class CNNDlibDetector ( ImageFaceDetector ) : [EOL] [EOL] def __init__ ( self , offset_value = [number] ) : [EOL] cnn_weights_path = [string] [EOL] cur_dir = os . path . dirname ( __file__ ) [EOL] cnn_model_path = str ( Path ( cur_dir , cnn_weights_path ) ) [EOL] self . __face_detector = dlib . cnn_face_detection_model_v1 ( cnn_model_path ) [EOL] self . __offset_value = offset_value [EOL] self . __face_aligner = FaceAlignment ( ) [EOL] self . __expected_n_channels = [number] [EOL] [EOL] def detect ( self , keyframe ) : [EOL] [docstring] [EOL] [EOL] channels = keyframe . image . shape [ [number] ] [EOL] [EOL] if ( channels != self . __expected_n_channels ) : [EOL] print ( [string] ) [EOL] return FaceDetectionResults ( keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . FAIL_NON_RGB_INPUT ) [EOL] else : [EOL] image = np . array ( keyframe . image ) [EOL] image . setflags ( write = True ) [EOL] print ( [string] ) [EOL] faces_cnn = self . __face_detector ( image , [number] ) [EOL] print ( [string] ) [EOL] rectangles = [ face . rect for face in faces_cnn ] [EOL] cropped_images = [ ] [EOL] for rect in rectangles : [EOL] print ( [string] ) [EOL] ( x , y , w , h ) = rect_to_bb ( rect ) [EOL] x_upperleft = max ( [number] , x ) [EOL] y_upperleft = max ( [number] , y ) [EOL] x_lowerright = x + w [EOL] y_lowerright = y + h [EOL] cropped_images . append ( image [ y_upperleft : y_lowerright , x_upperleft : x_lowerright , : ] ) [EOL] [EOL] aligned_faces = self . __face_aligner . get_aligned_faces ( image , rectangles ) [EOL] [EOL] detected_faces = list ( map ( lambda image , aligned_image : DetectedFace ( image = image , aligned_image = aligned_image ) , cropped_images , aligned_faces ) ) [EOL] [EOL] return FaceDetectionResults ( detected_faces = detected_faces , keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . SUCCESS ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Tuple , Any [EOL] import entities [EOL] import numpy [EOL] import dlib [EOL] import bounding_box [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] import face_detection_results [EOL] from typing import List , Tuple [EOL] from faced import FaceDetector [EOL] from dlib import rectangle [EOL] [EOL] import numpy as np [EOL] [EOL] from . image_face_detector import ImageFaceDetector [EOL] from . face_detection_results import FaceDetectionResults , DetectedFace [EOL] from . face_detection_status import FaceDetectionStatus [EOL] from . bounding_box import BoundingBox [EOL] from . facealignment . face_alignment import FaceAlignment [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] class FacedDetector ( ImageFaceDetector ) : [EOL] [EOL] def __init__ ( self , minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) : [EOL] [docstring] [EOL] self . __faced = FaceDetector ( ) [EOL] self . __expected_n_channels = [number] [EOL] self . __minimum_confidence = minimum_confidence [EOL] self . __offset_value = offset_value [EOL] self . __pad_value = pad_value [EOL] self . __face_aligner = FaceAlignment ( ) [EOL] [EOL] def detect ( self , keyframe ) : [EOL] [docstring] [EOL] [comment] [EOL] padded_image = self . __pad_image ( keyframe . image , self . __pad_value ) [EOL] [EOL] channels = keyframe . image . shape [ [number] ] [EOL] [EOL] if ( channels != self . __expected_n_channels ) : [EOL] return FaceDetectionResults ( keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . FAIL_NON_RGB_INPUT ) [EOL] else : [EOL] predicted_bboxes = self . __faced . predict ( frame = padded_image , thresh = self . __minimum_confidence ) [EOL] [EOL] final_bboxes = self . __preprocess_predicted_bboxes ( predicted_bboxes = predicted_bboxes , image_width = keyframe . image . shape [ [number] ] , image_height = keyframe . image . shape [ [number] ] ) [EOL] [EOL] face_images = self . __get_face_images ( image = padded_image , final_bboxes = final_bboxes ) [EOL] [EOL] aligned_face_images = self . __align_faces ( image = padded_image , bboxes = final_bboxes ) [EOL] [EOL] detected_faces = list ( map ( lambda image , aligned_image : DetectedFace ( image = image , aligned_image = aligned_image ) , face_images , aligned_face_images ) ) [EOL] [EOL] return FaceDetectionResults ( detected_faces = detected_faces , keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . SUCCESS ) [EOL] [EOL] def __pad_image ( self , image , pad_value ) : [EOL] [docstring] [EOL] return np . pad ( image , ( ( pad_value , pad_value ) , ( pad_value , pad_value ) , ( [number] , [number] ) ) , mode = [string] , constant_values = [number] ) [EOL] [EOL] def __rectangle_to_square_image ( self , image ) : [EOL] [docstring] [EOL] image_width , image_height = image . shape [ [number] ] , image . shape [ [number] ] [EOL] if ( image_height == image_width ) : [EOL] return image [EOL] elif ( image_height > image_width ) : [EOL] remaining = ( image_height - image_width ) // [number] [EOL] square_image = np . pad ( image , ( ( [number] , [number] ) , ( remaining , remaining ) , ( [number] , [number] ) ) , mode = [string] , constant_values = [number] ) [EOL] return square_image [EOL] else : [EOL] remaining = ( image_width - image_height ) // [number] [EOL] square_image = np . pad ( image , ( ( remaining , remaining ) , ( [number] , [number] ) , ( [number] , [number] ) ) , mode = [string] , constant_values = [number] ) [EOL] return square_image [EOL] [EOL] [EOL] def __preprocess_predicted_bboxes ( self , predicted_bboxes , image_width , image_height ) : [EOL] final_bboxes = [ ] [EOL] [EOL] for bbox in predicted_bboxes : [EOL] x_center = bbox [ [number] ] [EOL] y_center = bbox [ [number] ] [EOL] width = bbox [ [number] ] // [number] [EOL] height = bbox [ [number] ] // [number] [EOL] confidence = bbox [ [number] ] [EOL] [EOL] x_upperleft = max ( [number] , x_center - ( width + self . __offset_value ) ) [EOL] y_upperleft = max ( [number] , y_center - ( height + self . __offset_value ) ) [EOL] x_lowerright = min ( image_width - [number] , x_center + ( width + self . __offset_value ) ) [EOL] y_lowerright = min ( image_height - [number] , y_center + ( height + self . __offset_value ) ) [EOL] [EOL] coordinates = ( x_upperleft , y_upperleft , x_lowerright , y_lowerright ) [EOL] [EOL] new_bbox = BoundingBox ( coordinates = coordinates , confidence = confidence ) [EOL] final_bboxes . append ( new_bbox ) [EOL] [EOL] return final_bboxes [EOL] [EOL] def __get_face_images ( self , image , final_bboxes ) : [EOL] def get_face ( bbox ) : [EOL] ( x_upperleft , y_upperleft , x_lowerright , y_lowerright ) = bbox . coordinates [EOL] return image [ y_upperleft : y_lowerright + [number] , x_upperleft : x_lowerright + [number] , : ] [EOL] return list ( map ( get_face , final_bboxes ) ) [EOL] [EOL] def __align_faces ( self , image , bboxes ) : [EOL] rectangles = self . __bbox_to_rect ( image , bboxes = bboxes ) [EOL] return self . __face_aligner . get_aligned_faces ( original_image = image , rectangles = rectangles ) [EOL] [EOL] def __bbox_to_rect ( self , image , bboxes ) : [EOL] rectangles = [ ] [EOL] [EOL] for bbox in bboxes : [EOL] x_upperleft , y_upperleft , x_lowerright , y_lowerright = bbox . coordinates [EOL] rectangles . append ( rectangle ( x_upperleft , y_upperleft , x_lowerright , y_lowerright ) ) [EOL] [EOL] return rectangles [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[dlib.rectangle]$ 0 0 0 0 0 $typing.List[bounding_box.BoundingBox]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0
[EOL] from typing import List , Any [EOL] import entities [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] import face_detection_results [EOL] import dlib [EOL] import cv2 [EOL] [EOL] import numpy as np [EOL] [EOL] from typing import List [EOL] from dlib import rectangle [EOL] from imutils . face_utils import rect_to_bb [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] from . image_face_detector import ImageFaceDetector [EOL] from . facealignment . face_alignment import FaceAlignment [EOL] from . face_detection_results import FaceDetectionResults [EOL] from . face_detection_status import FaceDetectionStatus [EOL] from . bounding_box import BoundingBox [EOL] from . face_detection_results import DetectedFace [EOL] [EOL] class HogDetector ( ImageFaceDetector ) : [EOL] [EOL] def __init__ ( self , offset_value = [number] ) : [EOL] self . __offset_value = offset_value [EOL] self . __face_detector = dlib . get_frontal_face_detector ( ) [EOL] self . __face_aligner = FaceAlignment ( ) [EOL] self . __expected_n_channels = [number] [EOL] [EOL] def detect ( self , keyframe ) : [EOL] [docstring] [EOL] [EOL] channels = keyframe . image . shape [ [number] ] [EOL] [EOL] if ( channels != self . __expected_n_channels ) : [EOL] return FaceDetectionResults ( keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . FAIL_NON_RGB_INPUT ) [EOL] else : [EOL] gray_image = cv2 . cvtColor ( keyframe . image , cv2 . COLOR_BGR2GRAY ) [EOL] rectangles = self . __face_detector ( gray_image , [number] ) [EOL] [EOL] cropped_images = [ ] [EOL] for rect in rectangles : [EOL] ( x , y , w , h ) = rect_to_bb ( rect ) [EOL] x_upperleft = max ( [number] , x ) [EOL] y_upperleft = max ( [number] , y ) [EOL] x_lowerright = x + w [EOL] y_lowerright = y + h [EOL] cropped_images . append ( keyframe . image [ y_upperleft : y_lowerright , x_upperleft : x_lowerright , : ] ) [EOL] [EOL] aligned_faces = self . __face_aligner . get_aligned_faces ( keyframe . image , rectangles ) [EOL] [EOL] detected_faces = list ( map ( lambda image , aligned_image : DetectedFace ( image = image , aligned_image = aligned_image ) , cropped_images , aligned_faces ) ) [EOL] [EOL] return FaceDetectionResults ( detected_faces = detected_faces , keyframe_id = keyframe . keyframe_id , video_id = keyframe . video_id , status = FaceDetectionStatus . SUCCESS ) [EOL] [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.facedetection.facealignment.face_alignment.FaceAlignment$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $face_detection_results.FaceDetectionResults$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 $numpy.int32$ 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 $numpy.int32$ 0 0 0 0 0 0 0 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $typing.Any$ 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Tuple , Any [EOL] import entities [EOL] import numpy [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] import face_detection_results [EOL] import dlib [EOL] import cv2 [EOL] import os [EOL] [EOL] import numpy as np [EOL] [EOL] from pathlib import Path [EOL] from typing import List [EOL] from dlib import rectangle [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] from . image_face_detector import ImageFaceDetector [EOL] from . facealignment . face_alignment import FaceAlignment [EOL] from . face_detection_results import FaceDetectionResults [EOL] from . face_detection_status import FaceDetectionStatus [EOL] from . bounding_box import BoundingBox [EOL] from . face_detection_results import DetectedFace [EOL] from . . utils import vggface2_utlis , image_utils [EOL] from . . test . test_utils import save_img [EOL] [EOL] class YOLOv3Detector ( ImageFaceDetector ) : [EOL] [EOL] [comment] [EOL] def __init__ ( self , offset_value = [number] ) : [EOL] yolov3_weights_path = self . __get_real_path ( [string] ) [EOL] yolov3_cfg_path = self . __get_real_path ( [string] ) [EOL] self . __yolov3 = self . __init_detector ( weights_path = yolov3_weights_path , cfg_path = yolov3_cfg_path ) [EOL] self . __offset_value = offset_value [EOL] self . __face_aligner = FaceAlignment ( ) [EOL] self . __default_dims = ( [number] , [number] ) [EOL] self . __expected_n_channels = [number] [EOL] self . __CONF_THRESHOLD = [number] [EOL] self . __NMS_THRESHOLD = [number] [EOL] [EOL] def __init_detector ( self , weights_path , cfg_path ) : [EOL] net = cv2 . dnn . readNetFromDarknet ( cfg_path , weights_path ) [EOL] net . setPreferableBackend ( cv2 . dnn . DNN_BACKEND_OPENCV ) [EOL] net . setPreferableTarget ( cv2 . dnn . DNN_TARGET_CPU ) [EOL] return net [EOL] [EOL] def __get_real_path ( self , path ) : [EOL] cur_dir = os . path . dirname ( __file__ ) [EOL] real_path = str ( Path ( cur_dir , path ) ) [EOL] return real_path [EOL] [EOL] def detect ( self , keyframe ) : [EOL] [docstring] [EOL] [EOL] channels = keyframe . image . shape [ [number] ] [EOL] [EOL] if ( channels == [number] ) : [EOL] keyframe . image = keyframe . image [ : , : , : [number] ] [EOL] [EOL] [comment] [EOL] blob = cv2 . dnn . blobFromImage ( keyframe . image , [number] / [number] , self . __default_dims , [ [number] , [number] , [number] ] , [number] , crop = False ) [EOL] [EOL] [comment] [EOL] self . __yolov3 . setInput ( blob ) [EOL] [EOL] outs = self . __yolov3 . forward ( self . __get_outputs_names ( ) ) [EOL] [EOL] faces = self . __post_process ( keyframe . image , outs , self . __CONF_THRESHOLD , self . __NMS_THRESHOLD ) [EOL] [EOL] cropped_images = [ ] [EOL] rectangles = [ ] [EOL] for face in faces : [EOL] x , y , w , h = face [ [number] ] , face [ [number] ] , face [ [number] ] , face [ [number] ] [EOL] x_upperleft = max ( [number] , x - self . __offset_value ) [EOL] y_upperleft = max ( [number] , y - self . __offset_value ) [EOL] x_lowerright = min ( keyframe . image . shape [ [number] ] , x + w + self . __offset_value ) [EOL] y_lowerright = min ( keyframe . image . shape [ [number] ] , y + h + self . __offset_value ) [EOL] cropped_images . append ( keyframe . image [ y_upperleft : y_lowerright , x_upperleft : x_lowerright , : ] ) [EOL] rectangles . append ( rectangle ( x , y , x + w , y + h ) ) [EOL] [EOL] aligned_faces = self . __face_aligner . get_aligned_faces ( keyframe . image , rectangles ) [EOL] [EOL] detected_faces = list ( map ( lambda image , aligned_image : DetectedFace ( image = image , aligned_image = aligned_image ) , cropped_images , aligned_faces ) ) [EOL] [EOL] return FaceDetectionResults ( detected_faces = detected_faces , status = FaceDetectionStatus . SUCCESS ) [EOL] [EOL] def __get_outputs_names ( self ) : [EOL] [comment] [EOL] layers_names = self . __yolov3 . getLayerNames ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] return [ layers_names [ i [ [number] ] - [number] ] for i in self . __yolov3 . getUnconnectedOutLayers ( ) ] [EOL] [EOL] def __post_process ( self , frame , outs , conf_threshold , nms_threshold ) : [EOL] frame_height = frame . shape [ [number] ] [EOL] frame_width = frame . shape [ [number] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] confidences = [ ] [EOL] boxes = [ ] [EOL] final_boxes = [ ] [EOL] for out in outs : [EOL] for detection in out : [EOL] scores = detection [ [number] : ] [EOL] class_id = np . argmax ( scores ) [EOL] confidence = scores [ class_id ] [EOL] if confidence > conf_threshold : [EOL] center_x = int ( detection [ [number] ] * frame_width ) [EOL] center_y = int ( detection [ [number] ] * frame_height ) [EOL] width = int ( detection [ [number] ] * frame_width ) [EOL] height = int ( detection [ [number] ] * frame_height ) [EOL] left = int ( center_x - width / [number] ) [EOL] top = int ( center_y - height / [number] ) [EOL] confidences . append ( float ( confidence ) ) [EOL] boxes . append ( [ left , top , width , height ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] indices = cv2 . dnn . NMSBoxes ( boxes , confidences , conf_threshold , nms_threshold ) [EOL] [EOL] for i in indices : [EOL] i = i [ [number] ] [EOL] box = boxes [ i ] [EOL] left = box [ [number] ] [EOL] top = box [ [number] ] [EOL] width = box [ [number] ] [EOL] height = box [ [number] ] [EOL] final_boxes . append ( box ) [EOL] left , top , _ , _ = self . __refined_box ( left , top , width , height ) [EOL] return final_boxes [EOL] [EOL] def __refined_box ( self , left , top , width , height ) : [EOL] right = left + width [EOL] bottom = top + height [EOL] [EOL] original_vert_height = bottom - top [EOL] top = int ( top + original_vert_height * [number] ) [EOL] bottom = int ( bottom - original_vert_height * [number] ) [EOL] [EOL] margin = ( ( bottom - top ) - ( right - left ) ) // [number] [EOL] left = left - margin if ( bottom - top - right + left ) % [number] == [number] else left - margin - [number] [EOL] [EOL] right = right + margin [EOL] [EOL] return left , top , right , bottom [EOL] [EOL] yolov3 = YOLOv3Detector ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $vynd_api.facedetection.facealignment.face_alignment.FaceAlignment$ 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $face_detection_results.FaceDetectionResults$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 $numpy.int32$ 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 $numpy.int32$ 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $entities.keyframe.KeyFrame$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[face_detection_results.DetectedFace]$ 0 $typing.List[face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $builtins.int$ 0 $typing.Any$ 0 $builtins.int$ 0 0 $vynd_api.facedetection.yolov3_detector.YOLOv3Detector$ 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import numpy [EOL] import pathlib [EOL] import dlib [EOL] import dlib [EOL] import os [EOL] import cv2 [EOL] import numpy as np [EOL] [EOL] from PIL import Image [EOL] from typing import List [EOL] from dlib import rectangle [EOL] from pathlib import Path [EOL] from imutils . face_utils import FaceAligner [EOL] [EOL] class FaceAlignment : [EOL] [EOL] def __init__ ( self ) : [EOL] cur_dir = os . path . dirname ( __file__ ) [EOL] shape_predictor_path = Path ( cur_dir , [string] ) [EOL] self . __landmarks_detector = dlib . shape_predictor ( str ( shape_predictor_path ) ) [EOL] self . __desired_face_width = [number] [EOL] self . __cropping_ratio = [number] [EOL] self . __face_aligner = FaceAligner ( self . __landmarks_detector , desiredFaceWidth = self . __desired_face_width ) [EOL] [EOL] def get_aligned_faces ( self , original_image , rectangles ) : [EOL] gray_image = cv2 . cvtColor ( original_image , cv2 . COLOR_RGB2GRAY ) [EOL] [EOL] aligned_faces = [ ] [EOL] [EOL] for rect in rectangles : [EOL] aligned_face = self . __face_aligner . align ( original_image , gray_image , rect ) [EOL] [EOL] new_start_y , new_end_y = [number] , int ( self . __desired_face_width * self . __cropping_ratio ) [EOL] new_start_x = int ( ( [number] - self . __cropping_ratio ) * self . __desired_face_width // [number] ) [EOL] new_end_x = int ( self . __desired_face_width - new_start_x ) [EOL] [EOL] aligned_face = aligned_face [ new_start_y : new_end_y , new_start_x : new_end_x , : ] [EOL] aligned_faces . append ( aligned_face ) [EOL] [EOL] return aligned_faces	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 $typing.List[dlib.rectangle]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.List[dlib.rectangle]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $numpy.ndarray$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$
	0
[EOL] import pathlib [EOL] import gdown [EOL] import os [EOL] import patoolib [EOL] import rarfile [EOL] [EOL] [comment] [EOL] from pathlib import Path [EOL] [EOL] cur_dir = os . path . dirname ( __file__ ) [EOL] pb_vgg_path = Path ( cur_dir , [string] ) [EOL] [EOL] def download_vggface_model ( ) : [EOL] if ( vgg_exist ( ) == False ) : [EOL] id_vgg_pb = [string] [EOL] pb_file_link = [string] + id_vgg_pb [EOL] gdown . download ( pb_file_link , str ( pb_vgg_path ) , False ) [comment] [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] def vgg_exist ( ) : [EOL] if ( os . path . exists ( str ( Path ( cur_dir , [string] ) ) ) == False ) : [EOL] return False [EOL] return True	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import entities [EOL] import vynd_api [EOL] import unittest [EOL] from typing import List [EOL] [EOL] from . . videoprocessing . video_processor import VideoProcessor [EOL] [EOL] from . . search . image_search import search_by_image [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data . face_collection import FaceCollection [EOL] [EOL] from . . data import CLIENT [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] from . test_utils import get_img_from_filename [EOL] [EOL] [EOL] class TestSearchByImage ( unittest . TestCase ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( TestSearchByImage , self ) . __init__ ( * args , ** kwargs ) [EOL] self . video_collection = VideoCollection ( CLIENT . vynd_db_test . video_collection ) [EOL] self . face_collection = FaceCollection ( CLIENT . vynd_db_test . face_collection ) [EOL] self . video_processor = VideoProcessor ( face_collection = CLIENT . vynd_db_test . face_collection , keyframe_collection = CLIENT . vynd_db_test . key_frame_collection , video_collection = CLIENT . vynd_db_test . video_collection ) [EOL] self . group_image_a = get_img_from_filename ( [string] ) [EOL] self . group_image_b = get_img_from_filename ( [string] ) [EOL] self . video_collection . delete_all_videos ( ) [EOL] self . face_collection . delete_all_faces ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . video_collection . delete_all_videos ( ) [EOL] self . face_collection . delete_all_faces ( ) [EOL] [EOL] def get_key_frames ( self , images ) : [EOL] return list ( map ( lambda img : KeyFrame ( img ) , images ) ) [EOL] [EOL] def test_union_faces_found ( self ) : [EOL] [comment] [EOL] video_id_a = self . video_collection . insert_new_video ( ) [EOL] key_frames = self . get_key_frames ( [ self . group_image_a ] ) [EOL] self . video_processor . process ( video_id_a , key_frames ) [EOL] [EOL] [comment] [EOL] faces_ids = search_by_image ( image = self . group_image_b , face_collection = CLIENT . vynd_db_test . face_collection ) [EOL] self . assertEqual ( len ( faces_ids ) , [number] ) [EOL] [EOL] def test_no_faces_found ( self ) : [EOL] faces_ids = search_by_image ( image = self . group_image_b , face_collection = CLIENT . vynd_db_test . face_collection ) [EOL] self . assertEqual ( faces_ids , [ ] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 $vynd_api.videoprocessing.video_processor.VideoProcessor$ 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import requests [EOL] import vynd_api [EOL] import numpy [EOL] from typing import List [EOL] from flask_api import status [EOL] [EOL] import numpy as np [EOL] import unittest [EOL] import requests [EOL] import json [EOL] import base64 [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] from . . videoprocessing . video_processor import VideoProcessor [EOL] from . test_utils import get_all_local_images [EOL] from . . utils . image_utils import rgb_to_base64 [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data . face_collection import FaceCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] from . . data import CLIENT [EOL] from . . data . db_utils import np_to_binary , binary_to_b64 [EOL] [EOL] class TestProcessKeyFrames ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . current_host_IP = [string] [EOL] [EOL] self . video_collection = VideoCollection ( CLIENT . vynd_db_test . video_collection ) [EOL] self . face_collection = FaceCollection ( CLIENT . vynd_db_test . face_collection ) [EOL] self . keyframe_collection = KeyFrameCollection ( CLIENT . vynd_db_test . keyframe_collection ) [EOL] [EOL] self . key_frames = [ ] [EOL] local_images = get_all_local_images ( [string] ) [EOL] [EOL] for img in local_images : [EOL] key_frame = KeyFrame ( img ) [EOL] self . key_frames . append ( key_frame ) [EOL] [EOL] def test_invalid_video_id ( self ) : [EOL] base64_images = [ keyframe . base64_image . decode ( ) for keyframe in self . key_frames ] [EOL] json_data = { [string] : [string] , [string] : json . dumps ( base64_images ) } [EOL] result = self . __make_post_request ( json_data ) [EOL] self . assertEqual ( result , status . HTTP_400_BAD_REQUEST ) [EOL] [EOL] def test_invalid_keyframes_type ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] base64_images = [ [number] for keyframe in self . key_frames ] [EOL] json_data = { [string] : video_id , [string] : json . dumps ( base64_images ) } [EOL] result = self . __make_post_request ( json_data ) [EOL] self . assertEqual ( result , status . HTTP_406_NOT_ACCEPTABLE ) [EOL] self . video_collection . delete_video ( video_id ) [EOL] [EOL] def test_missing_form ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] base64_images = [ keyframe . base64_image . decode ( ) for keyframe in self . key_frames ] [EOL] json_data = { [string] : json . dumps ( base64_images ) } [EOL] result = self . __make_post_request ( json_data ) [EOL] self . assertEqual ( result , status . HTTP_400_BAD_REQUEST ) [EOL] self . video_collection . delete_video ( video_id ) [EOL] [EOL] def test_success ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] base64_images = [ keyframe . base64_image . decode ( ) for keyframe in self . key_frames ] [EOL] json_data = { [string] : video_id , [string] : json . dumps ( base64_images ) } [EOL] [EOL] result = self . __make_post_request ( json_data ) [EOL] [EOL] self . assertEqual ( result , status . HTTP_200_OK ) [EOL] self . assertEqual ( self . face_collection . get_number_of_records ( ) , [number] ) [EOL] self . assertEqual ( self . keyframe_collection . get_number_of_records ( ) , [number] ) [EOL] self . assertEqual ( self . video_collection . get_number_of_records ( ) , [number] ) [EOL] [EOL] self . face_collection . delete_all_faces ( ) [EOL] self . keyframe_collection . delete_all_keyframes ( ) [EOL] self . video_collection . delete_all_videos ( ) [EOL] [EOL] [EOL] def __make_post_request ( self , json_data ) : [EOL] try : [EOL] headers = { [string] : [string] , [string] : [string] } [EOL] response = requests . post ( url = self . current_host_IP + [string] , json = json_data , headers = headers ) [EOL] return response . status_code [EOL] except : [EOL] return None [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 $typing.List[numpy.ndarray]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[numpy.ndarray]$ 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] import unittest [EOL] import numpy as np [EOL] import json [EOL] [EOL] from . . utils import numpy_encoder [EOL] from . . data import CLIENT [EOL] from . . data . face_collection import FaceCollection [EOL] [EOL] class TestFaceCollection ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . face_collection = FaceCollection ( collection = CLIENT . vynd_db_test . face_collection ) [EOL] [EOL] def test_insert_face ( self ) : [EOL] features = np . random . uniform ( low = [number] , high = [number] , size = ( [number] , ) ) [EOL] face = np . random . uniform ( low = [number] , high = [number] , size = ( [number] , [number] ) ) [EOL] face_id = self . face_collection . insert_new_face ( keyframe_id = [string] , video_id = [string] , features = features , face_image = face , confidence = [number] ) [EOL] delete_face_result = self . face_collection . delete_face ( face_id ) [EOL] self . assertEqual ( delete_face_result . deleted_count , [number] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import vynd_api [EOL] import builtins [EOL] import facedetection [EOL] from typing import List , Tuple [EOL] from PIL import Image [EOL] [EOL] import requests [EOL] import unittest [EOL] [EOL] from . . facedetection . bounding_box import BoundingBox [EOL] from . . facedetection . faced import FacedDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] from . . facedetection . face_detection_status import FaceDetectionStatus [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . facedetection . video_face_detector import VideoFaceDetector [EOL] from . . entities . keyframe import KeyFrame [EOL] from . test_utils import url_to_base64 , get_img_from_filename , save_img [EOL] [EOL] class TestVideoFaceDetector ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] faced = FacedDetector ( minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) [EOL] self . video_faced = VideoFaceDetector ( faced ) [EOL] hosted_images = [ [string] ] [EOL] local_images = [ [string] ] [EOL] [EOL] self . epsilon = [number] [EOL] self . key_frames = [ ] [EOL] [EOL] self . dummy_video_id = [string] [EOL] self . dummy_keyframe_id = [string] [EOL] [EOL] for img_url in hosted_images : [EOL] key_frame = KeyFrame ( url_to_base64 ( img_url ) ) [EOL] key_frame . video_id = self . dummy_video_id [EOL] key_frame . keyframe_id = self . dummy_keyframe_id [EOL] self . key_frames . append ( key_frame ) [EOL] [EOL] for img_path in local_images : [EOL] key_frame = KeyFrame ( get_img_from_filename ( img_path ) ) [EOL] key_frame . video_id = self . dummy_video_id [EOL] key_frame . keyframe_id = self . dummy_keyframe_id [EOL] self . key_frames . append ( key_frame ) [EOL] [EOL] def test_video_face_detector ( self ) : [EOL] expected_bboxes = [ BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) ] [EOL] expected_results = [ FaceDetectionResults ( self . dummy_video_id , self . dummy_keyframe_id , FaceDetectionStatus . FAIL_NON_RGB_INPUT , None ) , FaceDetectionResults ( self . dummy_video_id , self . dummy_keyframe_id , FaceDetectionStatus . SUCCESS , expected_bboxes ) ] [EOL] [EOL] detection_results = self . video_faced . get_detected_results ( key_frames = self . key_frames ) [EOL] [EOL] self . assertEqual ( len ( detection_results ) , len ( expected_results ) ) [EOL] [EOL] for i in range ( len ( detection_results ) ) : [EOL] self . assertEqual ( detection_results [ i ] . status , expected_results [ i ] . status ) [EOL] [EOL] if detection_results [ i ] . detected_faces != None : [EOL] self . assertEqual ( len ( detection_results [ i ] . detected_faces ) , len ( expected_results [ i ] . detected_faces ) ) [EOL] [EOL] for j in range ( len ( detection_results [ i ] . detected_faces ) ) : [EOL] self . assertEqual ( detection_results [ i ] . detected_faces [ j ] . bbox . coordinates , expected_bboxes [ j ] . coordinates ) [EOL] self . assertAlmostEqual ( detection_results [ i ] . detected_faces [ j ] . bbox . confidence , expected_bboxes [ j ] . confidence , delta = self . epsilon ) [EOL] [EOL] else : [EOL] self . assertEqual ( detection_results [ i ] . detected_faces , None ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.video_face_detector.VideoFaceDetector$ 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import numpy [EOL] import facedetection [EOL] import typing [EOL] import builtins [EOL] import vynd_api [EOL] from typing import List , Tuple [EOL] import unittest [EOL] import numpy as np [EOL] [EOL] from . test_utils import get_img_from_filename , url_to_img [EOL] from . . facedetection . bounding_box import BoundingBox [EOL] from . . facedetection . faced import FacedDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] from . . facedetection . face_detection_status import FaceDetectionStatus [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] [EOL] class TestFacedDetector ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . non_rgb_input_url = [string] [EOL] self . valid_input_path = [string] [EOL] [EOL] self . valid_input_img = get_img_from_filename ( self . valid_input_path ) [EOL] self . non_rgb_input_img = url_to_img ( self . non_rgb_input_url ) [EOL] [EOL] self . dummy_video_id = [string] [EOL] self . dummy_keyframe_id = [string] [EOL] [EOL] self . epsilon = [number] [EOL] self . faced_detector = FacedDetector ( minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) [EOL] [EOL] def test_non_rgb_input_status ( self ) : [EOL] keyframe = KeyFrame ( self . non_rgb_input_img ) [EOL] keyframe . video_id = self . dummy_video_id [EOL] keyframe . keyframe_id = self . dummy_keyframe_id [EOL] detection_result = self . faced_detector . detect ( keyframe ) [EOL] expected_status = FaceDetectionStatus . FAIL_NON_RGB_INPUT [EOL] self . assertEqual ( detection_result . status , expected_status ) [EOL] [EOL] def test_non_rgb_input_bboxes ( self ) : [EOL] keyframe = KeyFrame ( self . non_rgb_input_img ) [EOL] keyframe . video_id = self . dummy_video_id [EOL] keyframe . keyframe_id = self . dummy_keyframe_id [EOL] detection_result = self . faced_detector . detect ( keyframe ) [EOL] expected_detected_faces = None [EOL] self . assertEqual ( detection_result . detected_faces , expected_detected_faces ) [EOL] [EOL] def test_valid_input_status ( self ) : [EOL] keyframe = KeyFrame ( self . valid_input_img ) [EOL] keyframe . video_id = self . dummy_video_id [EOL] keyframe . keyframe_id = self . dummy_keyframe_id [EOL] detection_result = self . faced_detector . detect ( keyframe ) [EOL] expected_status = FaceDetectionStatus . SUCCESS [EOL] self . assertEqual ( detection_result . status , expected_status ) [EOL] [EOL] def test_valid_input_bboxes ( self ) : [EOL] keyframe = KeyFrame ( self . valid_input_img ) [EOL] keyframe . video_id = self . dummy_video_id [EOL] keyframe . keyframe_id = self . dummy_keyframe_id [EOL] detection_result = self . faced_detector . detect ( keyframe ) [EOL] [EOL] expected_bboxes = [ BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) ] [EOL] [EOL] self . assertEqual ( len ( expected_bboxes ) , len ( detection_result . detected_faces ) ) [EOL] [EOL] for i in range ( len ( expected_bboxes ) ) : [EOL] self . assertEqual ( detection_result . detected_faces [ i ] . bbox . coordinates , expected_bboxes [ i ] . coordinates ) [EOL] [EOL] for i in range ( len ( expected_bboxes ) ) : [EOL] actual_conf = detection_result . detected_faces [ i ] . bbox . confidence [EOL] expected_conf = expected_bboxes [ i ] . confidence [EOL] self . assertAlmostEqual ( actual_conf , expected_conf , delta = self . epsilon ) [EOL] [EOL] [EOL] def test_valid_input_cropped_faces ( self ) : [EOL] keyframe = KeyFrame ( self . valid_input_img ) [EOL] keyframe . video_id = self . dummy_video_id [EOL] keyframe . keyframe_id = self . dummy_keyframe_id [EOL] detection_result = self . faced_detector . detect ( keyframe ) [EOL] [EOL] expected_bboxes = [ BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) , BoundingBox ( ( [number] , [number] , [number] , [number] ) , [number] ) ] [EOL] [EOL] def get_shape ( bbox ) : [EOL] ( x_upperleft , y_upperleft , x_lowerright , y_lowerright ) = bbox . coordinates [EOL] return ( y_lowerright - y_upperleft + [number] , x_lowerright - x_upperleft + [number] , [number] ) [EOL] expected_shapes = list ( map ( get_shape , expected_bboxes ) ) [EOL] [EOL] self . assertEqual ( len ( expected_shapes ) , len ( detection_result . detected_faces ) ) [EOL] [EOL] for i , _ in enumerate ( expected_shapes ) : [EOL] self . assertEqual ( detection_result . detected_faces [ i ] . image . shape , expected_shapes [ i ] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $numpy.array$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 $facedetection.face_detection_status.FaceDetectionStatus$ 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 $facedetection.face_detection_status.FaceDetectionStatus$ 0 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 $None$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 $facedetection.face_detection_status.FaceDetectionStatus$ 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 $facedetection.face_detection_status.FaceDetectionStatus$ 0 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[(int,int,int)]$ 0 $facedetection.bounding_box.BoundingBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.bounding_box.BoundingBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[(int,int,int)]]$ 0 0 0 0 0 0 0 $typing.List[facedetection.bounding_box.BoundingBox]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[(int,int,int)]]$ 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[(int,int,int)]]$ 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[(int,int,int)]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import vynd_api [EOL] import pymongo [EOL] from . . data import CLIENT [EOL] from . . data . video_collection import VideoCollection [EOL] from . . entities . video import Video [EOL] [EOL] from pymongo . results import DeleteResult [EOL] [EOL] import unittest [EOL] [EOL] class TestVideoCollection ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . video_collection = VideoCollection ( collection = CLIENT . vynd_db_test . video_collection ) [EOL] [EOL] def test_video_collection ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] [EOL] keyframes = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] for kf_id in keyframes : [EOL] result = self . video_collection . add_keyframe ( video_id , kf_id ) [EOL] self . assertTrue ( result ) [EOL] [EOL] faces = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for f_id in faces : [EOL] result = self . video_collection . add_face ( video_id , f_id ) [EOL] self . assertTrue ( result ) [EOL] [EOL] expected_number_of_keyframes = [number] [EOL] expected_number_of_faces = [number] [EOL] [EOL] video = self . video_collection . get_video_by_id ( video_id ) [EOL] self . assertEqual ( len ( video [ [string] ] ) , expected_number_of_keyframes ) [EOL] self . assertEqual ( len ( video [ [string] ] ) , expected_number_of_faces ) [EOL] [EOL] delete_result = self . video_collection . delete_video ( video_id = video_id ) [EOL] self . assertEqual ( delete_result . deleted_count , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import entities [EOL] import vynd_api [EOL] import unittest [EOL] from typing import List [EOL] [EOL] from . . videoprocessing . video_processor import VideoProcessor [EOL] from . . videoprocessing . video_processing_results import VideoProcessingResult [EOL] [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data . face_collection import FaceCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] [EOL] from . . data import CLIENT [EOL] [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] from . test_utils import get_img_from_filename [EOL] [EOL] class TestVideoProcessor ( unittest . TestCase ) : [EOL] [EOL] def __init__ ( self , * args , ** kwargs ) : [EOL] super ( TestVideoProcessor , self ) . __init__ ( * args , ** kwargs ) [EOL] self . video_collection = VideoCollection ( CLIENT . vynd_db_test . video_collection ) [EOL] self . face_collection = FaceCollection ( CLIENT . vynd_db_test . face_collection ) [EOL] self . keyframe_collection = KeyFrameCollection ( CLIENT . vynd_db_test . keyframe_collection ) [EOL] self . video_processor = VideoProcessor ( face_collection = CLIENT . vynd_db_test . face_collection , keyframe_collection = CLIENT . vynd_db_test . key_frame_collection , video_collection = CLIENT . vynd_db_test . video_collection ) [EOL] self . group_image_a = get_img_from_filename ( [string] ) [EOL] self . group_image_b = get_img_from_filename ( [string] ) [EOL] self . video_collection . delete_all_videos ( ) [EOL] self . face_collection . delete_all_faces ( ) [EOL] self . keyframe_collection . delete_all_keyframes ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] self . video_collection . delete_all_videos ( ) [EOL] self . face_collection . delete_all_faces ( ) [EOL] self . keyframe_collection . delete_all_keyframes ( ) [EOL] [EOL] def get_key_frames ( self , images ) : [EOL] return list ( map ( lambda img : KeyFrame ( img ) , images ) ) [EOL] [EOL] def test_new_faces_inserted ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] key_frames = self . get_key_frames ( [ self . group_image_a ] ) [EOL] processing_result = self . video_processor . process ( video_id , key_frames ) [EOL] self . assertEqual ( processing_result , VideoProcessingResult . SUCCESS ) [EOL] self . assertEqual ( self . face_collection . get_number_of_records ( ) , [number] ) [EOL] video = self . video_collection . get_video_by_id ( video_id = video_id ) [EOL] faces_ids = video [ [string] ] [EOL] self . assertEqual ( len ( set ( faces_ids ) ) , [number] ) [EOL] [EOL] def test_new_matches_found ( self ) : [EOL] [comment] [EOL] video_id_a = self . video_collection . insert_new_video ( ) [EOL] key_frames_a = self . get_key_frames ( [ self . group_image_a ] ) [EOL] self . video_processor . process ( video_id_a , key_frames_a ) [EOL] [EOL] [comment] [EOL] img_zuma = get_img_from_filename ( [string] ) [EOL] img_omar = get_img_from_filename ( [string] ) [EOL] [EOL] img_omar_zuma = get_img_from_filename ( [string] ) [EOL] img_omar_etch = get_img_from_filename ( [string] ) [EOL] img_grad_group = get_img_from_filename ( [string] ) [EOL] [EOL] video_id_b = self . video_collection . insert_new_video ( ) [EOL] key_frames_b = self . get_key_frames ( [ self . group_image_b , img_omar , img_zuma , img_omar_zuma , img_omar_etch , img_grad_group ] ) [EOL] [EOL] self . video_processor . process ( video_id_b , key_frames_b ) [EOL] self . assertEqual ( self . face_collection . get_number_of_records ( ) , [number] ) [EOL] [EOL] [comment] [EOL] video_b = self . video_collection . get_video_by_id ( video_id = video_id_b ) [EOL] faces_ids_in_video_b = video_b [ [string] ] [EOL] self . assertEqual ( len ( set ( faces_ids_in_video_b ) ) , [number] ) [EOL] [EOL] [comment] [EOL] faces_videos_ids = self . face_collection . get_all_faces_video_ids ( ) [EOL] faces_videos_ids_lengths = list ( map ( lambda elem : len ( elem [ [string] ] ) , faces_videos_ids ) ) [EOL] self . assertCountEqual ( [ [number] , [number] , [number] , [number] , [number] , [number] ] , faces_videos_ids_lengths ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 $vynd_api.videoprocessing.video_processor.VideoProcessor$ 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.videoprocessing.video_processing_results.VideoProcessingResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 $vynd_api.videoprocessing.video_processing_results.VideoProcessingResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[vynd_api.entities.keyframe.KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List [EOL] import typing [EOL] import vynd_api [EOL] import numpy [EOL] import facedetection [EOL] from typing import List [EOL] [EOL] import numpy as np [EOL] import unittest [EOL] [EOL] from . . facedetection . faced import FacedDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . facedetection . video_face_detector import VideoFaceDetector [EOL] from . . entities . keyframe import KeyFrame [EOL] from . test_utils import save_img , get_all_local_images [EOL] [EOL] class TestDetectAndCrop ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] [comment] [EOL] faced = FacedDetector ( minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) [EOL] self . video_faced = VideoFaceDetector ( faced ) [EOL] [comment] [EOL] self . key_frames = [ ] [EOL] local_images = get_all_local_images ( [string] ) [EOL] [EOL] dummy_keyframe_id = [string] [EOL] i = [number] [EOL] for img in local_images : [EOL] key_frame = KeyFrame ( img ) [EOL] key_frame . video_id = [string] [EOL] key_frame . keyframe_id = [string] + str ( i ) [EOL] i += [number] [EOL] self . key_frames . append ( key_frame ) [EOL] [EOL] def test_detect_and_crop_from_local ( self ) : [EOL] detection_results = self . video_faced . get_detected_results ( key_frames = self . key_frames ) [EOL] [EOL] for i in range ( len ( detection_results ) ) : [EOL] if detection_results [ i ] . detected_faces != None : [EOL] for j in range ( len ( detection_results [ i ] . detected_faces ) ) : [EOL] save_img ( [string] , detection_results [ i ] . detected_faces [ j ] . image , str ( i ) + str ( j ) + [string] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.video_face_detector.VideoFaceDetector$ 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 $typing.List[numpy.ndarray]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[numpy.ndarray]$ 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facedetection.face_detection_results.FaceDetectionResults]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import typing [EOL] import vynd_api [EOL] import pymongo [EOL] from typing import List [EOL] from pymongo . results import DeleteResult [EOL] [EOL] from . . data import CLIENT [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] from . . entities . video import Video [EOL] from . . entities . keyframe import KeyFrame [EOL] from . test_utils import get_img_from_filename [EOL] [EOL] import numpy as np [EOL] import unittest [EOL] [EOL] class TestKeyFrameCollection ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . video_collection = VideoCollection ( collection = CLIENT . vynd_db_test . video_collection ) [EOL] self . keyframe_collection = KeyFrameCollection ( collection = CLIENT . vynd_db_test . keyframe_collection ) [EOL] [EOL] def test_keyframe_collection ( self ) : [EOL] video_id = self . video_collection . insert_new_video ( ) [EOL] [EOL] keyframe_id = self . keyframe_collection . insert_new_keyframe ( video_id = video_id ) [EOL] [EOL] self . assertTrue ( self . video_collection . add_keyframe ( video_id , keyframe_id ) ) [EOL] [EOL] faces = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] for f_id in faces : [EOL] result = self . keyframe_collection . add_face ( keyframe_id = keyframe_id , face_id = f_id ) [EOL] self . assertTrue ( result ) [EOL] [EOL] expected_number_of_faces = [number] [EOL] [EOL] keyframe = self . keyframe_collection . get_keyframe_by_id ( keyframe_id = keyframe_id ) [EOL] [EOL] self . assertEqual ( len ( keyframe [ [string] ] ) , expected_number_of_faces ) [EOL] [EOL] keyframe_delete_result = self . keyframe_collection . delete_keyframe ( keyframe_id = keyframe_id ) [EOL] self . assertEqual ( keyframe_delete_result . deleted_count , [number] ) [EOL] [EOL] video_delete_result = self . video_collection . delete_video ( video_id = video_id ) [EOL] self . assertEqual ( video_delete_result . deleted_count , [number] ) [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import List , Any [EOL] import facedetection [EOL] import typing [EOL] import facerecognition [EOL] import builtins [EOL] import vynd_api [EOL] from typing import List [EOL] [EOL] import unittest [EOL] import numpy as np [EOL] [EOL] from . . data . face_collection import FaceCollection [EOL] from . . data import CLIENT [EOL] [EOL] [EOL] from . . facerecognition . facematching . face_match_status import FaceMatchStatus [EOL] from . . facerecognition . faceembedding . face_embedding_results import FaceEmbeddingResults [EOL] from . . facerecognition . faceembedding . image_faces_embedder import ImageFacesEmbedder [EOL] from . . facerecognition . faceembedding . vggface_embedder import VGGFaceEmbedder [EOL] from . . facerecognition . faceembedding . face_embedding import FaceEmbedding [EOL] from . . facerecognition . facematching . image_faces_matcher import ImageFacesMatcher , GroupMatch [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . facedetection . faced import FacedDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] from . . entities . keyframe import KeyFrame [EOL] from . . test . test_utils import get_img_from_filename [EOL] [EOL] class TestImageFaceMatcher ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . embedder = VGGFaceEmbedder ( ) [EOL] self . faced = FacedDetector ( minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) [EOL] self . matcher = ImageFacesMatcher ( face_collection = CLIENT . vynd_db_test . face_collection ) [EOL] [EOL] self . face_collection = FaceCollection ( CLIENT . vynd_db_test . face_collection ) [EOL] [EOL] img_path = [string] [comment] [EOL] self . keyframe = KeyFrame ( get_img_from_filename ( img_path ) ) [EOL] self . keyframe . video_id = [string] [EOL] self . keyframe . keyframe_id = [string] [EOL] [EOL] self . epsilon = [number] [EOL] [EOL] def tearDown ( self ) : [EOL] self . face_collection . delete_all_faces ( ) [EOL] [EOL] def insert_new_face_in_db ( self , img_path ) : [EOL] img = get_img_from_filename ( img_path ) [EOL] embedding = self . embedder . image_to_embedding ( img ) [EOL] return self . face_collection . insert_new_face ( video_id = [string] , features = embedding , face_image = None , ) [EOL] def test_image_face_matcher ( self ) : [EOL] [EOL] face_id_in_db_1 = self . insert_new_face_in_db ( [string] ) [EOL] self . insert_new_face_in_db ( [string] ) [EOL] [EOL] detection_result = self . faced . detect ( keyframe = self . keyframe ) [EOL] embedding_results = self . embedder . faces_to_embeddings ( detection_results = detection_result ) [EOL] group_matches = self . matcher . match_faces ( embedding_results ) [EOL] [EOL] self . assertEqual ( len ( group_matches ) , [number] ) [EOL] [EOL] match_found = [number] [EOL] for group_match in group_matches : [EOL] if group_match . match_status == FaceMatchStatus . MATCHED : [EOL] match_found += [number] [EOL] self . assertEqual ( face_id_in_db_1 , group_match . matched_id ) [EOL] self . assertEqual ( match_found , [number] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facerecognition.faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 0 0 0 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facerecognition.facematching.image_faces_matcher.ImageFacesMatcher$ 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[facerecognition.facematching.image_faces_matcher.GroupMatch]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import List , Any [EOL] import typing [EOL] import facerecognition [EOL] import vynd_api [EOL] import unittest [EOL] import os [EOL] import time [EOL] import shutil [EOL] from typing import List [EOL] from PIL import Image [EOL] import numpy as np [EOL] [EOL] from . test_utils import save_img [EOL] from . . utils . recognition_utils import cosine_similarity_distance [EOL] from . . facedetection . face_detection_results import FaceDetectionResults , DetectedFace [EOL] from . . facedetection . face_detection_status import FaceDetectionStatus [EOL] from . . facedetection . bounding_box import BoundingBox [EOL] from . . facerecognition . faceembedding . face_embedding import FaceEmbedding [EOL] from . . facerecognition . faceembedding . vggface_embedder import VGGFaceEmbedder [EOL] from . . facerecognition . facegrouping . face_grouping import group_faces [EOL] [EOL] def get_images ( ) : [EOL] dir_name = os . path . dirname ( os . path . realpath ( __file__ ) ) + [string] [EOL] dir_ = os . fsencode ( dir_name ) [EOL] images = [ ] [EOL] for file in os . listdir ( dir_ ) : [EOL] filename = os . fsdecode ( file ) [EOL] if filename . endswith ( [string] ) or filename . endswith ( [string] ) or filename . endswith ( [string] ) : [EOL] img = Image . open ( dir_name + filename ) [EOL] np_img = np . asarray ( img ) [EOL] images . append ( np_img ) [EOL] img . close ( ) [EOL] return images [EOL] [EOL] [EOL] def save_results ( groups ) : [EOL] dir_name = os . path . dirname ( os . path . realpath ( __file__ ) ) + [string] [EOL] if os . path . exists ( dir_name ) : [EOL] shutil . rmtree ( dir_name ) [EOL] os . makedirs ( dir_name ) [EOL] for i , g in enumerate ( groups ) : [EOL] for j , emb in enumerate ( g ) : [EOL] save_img ( dir_name , emb . face_image , f' [string] { i } [string] { j } [string] ' ) [EOL] [EOL] class TestFaceGrouping ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] images = get_images ( ) [EOL] bbox = BoundingBox ( coordinates = [ [number] , [number] , [number] , [number] ] , confidence = [number] ) [EOL] detected_faces = list ( map ( lambda img : DetectedFace ( image = img , bbox = bbox ) , images ) ) [EOL] detection_results = FaceDetectionResults ( [string] , [string] , FaceDetectionStatus . SUCCESS , detected_faces ) [EOL] face_embedder = VGGFaceEmbedder ( ) [EOL] self . face_embeddings = face_embedder . faces_to_embeddings ( detection_results ) [EOL] [EOL] def test_correct_grouping ( self ) : [EOL] start_time = time . time ( ) [EOL] grps = group_faces ( self . face_embeddings , lambda features_a , features_b : cosine_similarity_distance ( features_a , features_b ) < [number] ) [EOL] end_time = time . time ( ) [EOL] print ( end_time - start_time ) [EOL] grp_sizes = list ( map ( len , grps ) ) [EOL] [comment] [EOL] self . assertListEqual ( [ [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , grp_sizes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $vynd_api.facedetection.bounding_box.BoundingBox$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.DetectedFace]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.facedetection.bounding_box.BoundingBox$ 0 $vynd_api.facedetection.bounding_box.BoundingBox$ 0 0 $typing.Any$ 0 0 0 $vynd_api.facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[vynd_api.facedetection.face_detection_results.DetectedFace]$ 0 0 $vynd_api.facerecognition.faceembedding.vggface_embedder.VGGFaceEmbedder$ 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 $vynd_api.facerecognition.faceembedding.vggface_embedder.VGGFaceEmbedder$ 0 0 0 $vynd_api.facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.List[typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.List[typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0
[EOL] from typing import List [EOL] import facedetection [EOL] import typing [EOL] import facerecognition [EOL] import builtins [EOL] import vynd_api [EOL] from typing import List [EOL] [EOL] import unittest [EOL] [EOL] from . . facerecognition . faceembedding . vggface_embedder import VGGFaceEmbedder [EOL] from . . facerecognition . faceembedding . image_faces_embedder import ImageFacesEmbedder [EOL] from . . facerecognition . faceembedding . face_embedding import FaceEmbedding [EOL] from . . facedetection . image_face_detector import ImageFaceDetector [EOL] from . . facedetection . faced import FacedDetector [EOL] from . . facedetection . face_detection_results import FaceDetectionResults [EOL] from . . entities . keyframe import KeyFrame [EOL] from . . test . test_utils import get_img_from_filename [EOL] [EOL] class TestVGGFaceRecognizer ( unittest . TestCase ) : [EOL] [EOL] def setUp ( self ) : [EOL] self . vggface = VGGFaceEmbedder ( ) [EOL] self . faced = FacedDetector ( minimum_confidence = [number] , offset_value = [number] , pad_value = [number] ) [EOL] [EOL] img_path = [string] [EOL] self . keyframe = KeyFrame ( get_img_from_filename ( img_path ) ) [EOL] self . keyframe . video_id = [string] [EOL] self . keyframe . keyframe_id = [string] [EOL] [EOL] self . epsilon = [number] [EOL] [EOL] def test_vggface_recognizer ( self ) : [EOL] detection_result = self . faced . detect ( keyframe = self . keyframe ) [EOL] embedding_result = self . vggface . faces_to_embeddings ( detection_results = detection_result ) [EOL] [EOL] expected_number_of_faces = [number] [EOL] expected_number_of_features = [number] [EOL] expected_confidences = [ [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] self . assertEqual ( len ( embedding_result ) , expected_number_of_faces ) [EOL] [EOL] for i in range ( len ( embedding_result ) ) : [EOL] self . assertEqual ( embedding_result [ i ] . keyframe_id , self . keyframe . keyframe_id ) [EOL] self . assertEqual ( embedding_result [ i ] . video_id , self . keyframe . video_id ) [EOL] self . assertEqual ( len ( embedding_result [ i ] . features ) , expected_number_of_features ) [EOL] self . assertAlmostEqual ( embedding_result [ i ] . confidence , expected_confidences [ i ] , delta = self . epsilon ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $facerecognition.faceembedding.image_faces_embedder.ImageFacesEmbedder$ 0 0 0 0 0 0 0 $facedetection.image_face_detector.ImageFaceDetector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 $vynd_api.entities.keyframe.KeyFrame$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 $facedetection.face_detection_results.FaceDetectionResults$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.List[facerecognition.faceembedding.face_embedding.FaceEmbedding]$ 0 0 0 0 0 0 $typing.List[builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import io [EOL] from bson . binary import Binary [EOL] from PIL import Image [EOL] from io import BytesIO [EOL] [EOL] from . . utils . numpy_encoder import NumpyEncoder [EOL] [EOL] import base64 [EOL] import json [EOL] import pickle [EOL] [EOL] def np_to_binary ( nparray ) : [EOL] return Binary ( pickle . dumps ( nparray , protocol = [number] ) , subtype = [number] ) [EOL] [EOL] def np_to_json ( nparray ) : [EOL] return json . dumps ( nparray , cls = NumpyEncoder ) [EOL] [EOL] def binary_to_np ( binary ) : [EOL] return pickle . loads ( binary ) [EOL] [EOL] def binary_to_b64 ( binary ) : [EOL] pil_img = Image . fromarray ( binary_to_np ( binary ) , [string] ) [EOL] buffer = BytesIO ( ) [EOL] pil_img . save ( buffer , [string] ) [EOL] image = buffer . getvalue ( ) [EOL] b64 = base64 . b64encode ( image ) [EOL] pil_img . close ( ) [EOL] return b64 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pymongo [EOL] import os [EOL] from pymongo import MongoClient [EOL] from dotenv import load_dotenv [EOL] [EOL] load_dotenv ( ) [EOL] [EOL] PASSWORD = os . environ . get ( [string] ) [EOL] CLIENT = MongoClient ( f" [string] { PASSWORD } [string] " ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pymongo.MongoClient$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Optional , Any [EOL] import typing [EOL] import builtins [EOL] import pymongo [EOL] from typing import List , Union , Optional [EOL] from bson . objectid import ObjectId [EOL] from pymongo . results import DeleteResult [EOL] [EOL] from . import CLIENT [EOL] [EOL] class VideoCollection : [EOL] def __init__ ( self , collection = CLIENT . vynd_db . video_collection ) : [EOL] self . __collection = collection [EOL] [EOL] def insert_new_video ( self , video_extension = None ) : [EOL] [docstring] [EOL] return str ( self . __collection . insert_one ( { [string] : video_extension , [string] : False , [string] : [ ] , [string] : [ ] } ) . inserted_id ) [EOL] [EOL] def get_video_by_id ( self , video_id ) : [EOL] [docstring] [EOL] return self . __collection . find_one ( { [string] : ObjectId ( video_id ) } ) [EOL] [EOL] def get_faces ( self , video_id ) : [EOL] return list ( self . __collection . find ( filter = { [string] : ObjectId ( video_id ) } , projection = { [string] : True , [string] : False } ) ) [EOL] [EOL] def get_processed_videos ( self ) : [EOL] return list ( self . __collection . find ( filter = { [string] : True } , projection = { [string] : True , [string] : True } ) ) [EOL] [EOL] def get_videos_extensions ( self , videos_ids ) : [EOL] videos_ids = [ ObjectId ( _id ) for _id in videos_ids ] [EOL] return list ( self . __collection . find ( filter = { [string] : { [string] : videos_ids } } , projection = { [string] : False , [string] : True } ) ) [EOL] [EOL] def add_keyframe ( self , video_id , keyframe_id ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( video_id ) } , update = { [string] : { [string] : keyframe_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def add_face ( self , video_id , face_id ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( video_id ) } , update = { [string] : { [string] : face_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def add_faces ( self , video_id , face_ids ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( video_id ) } , update = { [string] : { [string] : { [string] : face_ids } } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def update_status ( self , video_id , new_status ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( video_id ) } , update = { [string] : { [string] : new_status } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def delete_video ( self , video_id ) : [EOL] [docstring] [EOL] return self . __collection . delete_one ( filter = { [string] : ObjectId ( video_id ) } ) [EOL] [EOL] def delete_all_videos ( self ) : [EOL] [docstring] [EOL] return self . __collection . delete_many ( { } ) [EOL] [EOL] def get_all_video ( self ) : [EOL] return list ( self . __collection . find ( filter = { } , projection = { [string] : True , [string] : True } ) ) [EOL] [EOL] def get_number_of_records ( self ) : [EOL] return self . __collection . count_documents ( { } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Union[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , Dict , List , Any [EOL] import typing [EOL] import numpy [EOL] import builtins [EOL] import pymongo [EOL] from bson . objectid import ObjectId [EOL] from pymongo . results import DeleteResult [EOL] [EOL] import pymongo [EOL] import numpy as np [EOL] [EOL] from . import CLIENT [EOL] from . db_utils import np_to_binary , binary_to_np , binary_to_b64 [EOL] [EOL] class FaceCollection : [EOL] def __init__ ( self , collection = CLIENT . vynd_db . face_collection ) : [EOL] self . __collection = collection [EOL] self . __create_name_index ( ) [EOL] [EOL] def __create_name_index ( self ) : [EOL] self . __collection . create_index ( [ ( [string] , pymongo . TEXT ) ] ) [EOL] [EOL] def insert_new_face ( self , video_id , features , face_image ) : [EOL] [docstring] [EOL] [comment] [EOL] return str ( self . __collection . insert_one ( { [string] : [ video_id ] , [string] : np_to_binary ( features ) , [string] : np_to_binary ( face_image ) , [string] : False , [string] : None } ) . inserted_id ) [EOL] [EOL] def insert_new_faces ( self , faces ) : [EOL] for face in faces : [EOL] face [ [string] ] = np_to_binary ( face [ [string] ] ) [EOL] face [ [string] ] = np_to_binary ( face [ [string] ] ) [EOL] face [ [string] ] = False [EOL] face [ [string] ] = None [EOL] if len ( faces ) : [EOL] inserted_ids = self . __collection . insert_many ( faces ) . inserted_ids [EOL] return list ( map ( str , inserted_ids ) ) [EOL] else : [EOL] return [ ] [EOL] [EOL] def get_face_by_id ( self , face_id ) : [EOL] [docstring] [EOL] return self . __collection . find_one ( { [string] : ObjectId ( face_id ) } ) [EOL] [EOL] def get_videos_by_id ( self , face_id ) : [EOL] return list ( self . __collection . find ( filter = { [string] : ObjectId ( face_id ) } , projection = { [string] : True , [string] : False } ) ) [EOL] [EOL] def get_videos_by_name ( self , name ) : [EOL] return list ( self . __collection . find ( filter = { [string] : { [string] : name } } , projection = { [string] : True , [string] : True } ) ) [EOL] [EOL] def get_faces_info ( self ) : [EOL] faces = list ( self . __collection . find ( projection = { [string] : True , [string] : True , [string] : True } ) ) [EOL] for face in faces : [EOL] face [ [string] ] = str ( face [ [string] ] ) [EOL] face [ [string] ] = binary_to_b64 ( face [ [string] ] ) . decode ( ) [EOL] return faces [EOL] [EOL] def get_faces_videos ( self , faces_ids ) : [EOL] faces_ids = [ ObjectId ( face_id ) for face_id in faces_ids ] [EOL] pipeline = [ { [string] : { [string] : { [string] : faces_ids } } } , { [string] : { [string] : [number] , [string] : { [string] : [string] } } } , { [string] : { [string] : { [string] : { [string] : [string] , [string] : [ ] , [string] : { [string] : [ [string] , [string] ] } } } } } ] [EOL] result = list ( self . __collection . aggregate ( pipeline ) ) [EOL] if not result : [EOL] return [ ] [EOL] return result [ [number] ] [ [string] ] [EOL] [EOL] def add_keyframe_id ( self , face_id , keyframe_id ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( face_id ) } , update = { [string] : { [string] : keyframe_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def add_video_id ( self , face_id , video_id ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( face_id ) } , update = { [string] : { [string] : video_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def add_video_id_to_faces ( self , face_ids , video_id ) : [EOL] [docstring] [EOL] ids = [ ObjectId ( face_id ) for face_id in face_ids ] [EOL] result = self . __collection . update_many ( filter = { [string] : { [string] : ids } } , update = { [string] : { [string] : video_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def update_name ( self , face_id , name ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( face_id ) } , update = { [string] : { [string] : name } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def update_features ( self , face_id , features ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( face_id ) } , update = { [string] : { [string] : np_to_binary ( features ) } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def update_face_image ( self , face_id , face_image ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( face_id ) } , update = { [string] : { [string] : np_to_binary ( face_image ) } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def delete_face ( self , face_id ) : [EOL] [docstring] [EOL] return self . __collection . delete_one ( filter = { [string] : ObjectId ( face_id ) } ) [EOL] [EOL] def get_all_faces_features ( self ) : [EOL] faces = list ( self . __collection . find ( projection = { [string] : True } ) ) [EOL] for face in faces : [EOL] face [ [string] ] = str ( face [ [string] ] ) [EOL] face [ [string] ] = binary_to_np ( face [ [string] ] ) [EOL] return faces [EOL] [EOL] def get_all_faces_video_ids ( self ) : [EOL] return list ( self . __collection . find ( projection = { [string] : True , [string] : False } ) ) [EOL] [EOL] def delete_all_faces ( self ) : [EOL] [docstring] [EOL] return self . __collection . delete_many ( { } ) [EOL] [EOL] def get_number_of_records ( self ) : [EOL] return self . __collection . count_documents ( { } )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $numpy.ndarray$ 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.List[typing.Any],builtins.str]]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int]]]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[builtins.str]],typing.List[typing.Any],builtins.str]]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[typing.Any]]]],typing.Dict[builtins.str,typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.int]]]]]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $numpy.ndarray$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $numpy.ndarray$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pymongo [EOL] import json [EOL] [EOL] from . import CLIENT [EOL] from . . entities . keyframe import KeyFrame [EOL] [EOL] from bson . objectid import ObjectId [EOL] from pymongo . results import DeleteResult [EOL] [EOL] class KeyFrameCollection : [EOL] def __init__ ( self , collection = CLIENT . vynd_db . keyframe_collection ) : [EOL] self . __collection = collection [EOL] [EOL] def insert_new_keyframe ( self , video_id , timestamp = [number] ) : [EOL] [docstring] [EOL] return str ( self . __collection . insert_one ( { [string] : video_id , [string] : timestamp , [string] : [ ] } ) . inserted_id ) [EOL] [EOL] def get_keyframe_by_id ( self , keyframe_id ) : [EOL] [docstring] [EOL] return self . __collection . find_one ( { [string] : ObjectId ( keyframe_id ) } ) [EOL] [EOL] def add_face ( self , keyframe_id , face_id ) : [EOL] [docstring] [EOL] result = self . __collection . update_one ( filter = { [string] : ObjectId ( keyframe_id ) } , update = { [string] : { [string] : face_id } } ) [EOL] return ( result . matched_count > [number] ) [EOL] [EOL] def delete_keyframe ( self , keyframe_id ) : [EOL] [docstring] [EOL] return self . __collection . delete_one ( filter = { [string] : ObjectId ( keyframe_id ) } ) [EOL] [EOL] def delete_all_keyframes ( self ) : [EOL] [docstring] [EOL] return self . __collection . delete_many ( { } ) [EOL] [EOL] def get_all_keyframes ( self ) : [EOL] return self . __collection . find ( { } ) [EOL] [EOL] def get_number_of_records ( self ) : [EOL] return self . __collection . count_documents ( { } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $pymongo.results.DeleteResult$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from . . data import CLIENT [EOL] from . . data . face_collection import FaceCollection [EOL] from . . data . video_collection import VideoCollection [EOL] from . . data . keyframe_collection import KeyFrameCollection [EOL] from . . utils . image_utils import base64_to_rgb [EOL] from . . videoprocessing . video_processor import VideoProcessor [EOL] from . . videoprocessing . video_processing_results import VideoProcessingResult [EOL] from . . entities . keyframe import KeyFrame	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import flask [EOL] from flask import Blueprint [EOL] from flask_restful import Api [EOL] [EOL] from . resources . face_updater import FaceUpdater [EOL] from . resources . get_face_info import GetFaces [EOL] from . resources . get_faces_in_video import GetFacesInVideo [EOL] from . resources . get_videos_of_face import GetVideosOfFace [EOL] from . resources . add_new_video import AddNewVideo [EOL] from . resources . get_processed_videos import GetProcessedVideos [EOL] from . resources . process_key_frames import ProcessKeyFrames [EOL] from . resources . reset_db import ResetDB [EOL] from . resources . get_faces_in_image import GetFacesInImage [EOL] [EOL] api_bp = Blueprint ( [string] , __name__ ) [EOL] api = Api ( api_bp ) [EOL] [EOL] api . add_resource ( FaceUpdater , [string] ) [EOL] api . add_resource ( GetFaces , [string] ) [EOL] api . add_resource ( GetFacesInVideo , [string] ) [EOL] api . add_resource ( GetFacesInImage , [string] ) [EOL] api . add_resource ( GetVideosOfFace , [string] ) [EOL] api . add_resource ( AddNewVideo , [string] ) [EOL] api . add_resource ( GetProcessedVideos , [string] ) [EOL] api . add_resource ( ProcessKeyFrames , [string] ) [EOL] api . add_resource ( ResetDB , [string] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $flask.blueprints.Blueprint$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[EOL] import vynd_api [EOL] from . . videoprocessing . video_processor import VideoProcessor [EOL] [EOL] def init_video_processor ( ) : [EOL] global video_processor [EOL] video_processor = VideoProcessor ( )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify , make_response [EOL] from flask_api import status [EOL] [EOL] from . . import CLIENT , VideoCollection [EOL] [EOL] class AddNewVideo ( Resource ) : [EOL] [EOL] video_collection = VideoCollection ( ) [EOL] [EOL] def post ( self ) : [EOL] if request . get_json ( ) and request . get_json ( ) . get ( [string] ) : [EOL] extension = request . get_json ( ) . get ( [string] ) [EOL] video_id = self . video_collection . insert_new_video ( video_extension = extension ) [EOL] request . stream . read ( ) [EOL] return make_response ( jsonify ( video_id = video_id ) , status . HTTP_200_OK ) [EOL] else : [EOL] return make_response ( jsonify ( error = [string] ) , status . HTTP_400_BAD_REQUEST ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify [EOL] [EOL] from . . import CLIENT , FaceCollection , VideoCollection [EOL] [EOL] import json [EOL] [EOL] class GetVideosOfFace ( Resource ) : [EOL] [EOL] face_collection = FaceCollection ( ) [EOL] video_collection = VideoCollection ( ) [EOL] [EOL] def get ( self ) : [EOL] args = request . args [EOL] if [string] in args : [EOL] face_id = args [ [string] ] [EOL] try : [EOL] result = self . face_collection . get_videos_by_id ( face_id ) [EOL] if len ( result ) == [number] : [EOL] return jsonify ( error = [string] ) [EOL] videos_ids = result [ [number] ] [ [string] ] [EOL] videos_extensions = self . video_collection . get_videos_extensions ( videos_ids ) [EOL] videos_results = [ { [string] : video_id , [string] : video_ext [ [string] ] } for ( video_id , video_ext ) in zip ( videos_ids , videos_extensions ) ] [EOL] return jsonify ( videos = videos_results ) [EOL] except : [EOL] return jsonify ( error = [string] ) [EOL] elif [string] in args : [EOL] name = args [ [string] ] [EOL] if ( len ( name ) == [number] ) : [EOL] videos = self . video_collection . get_all_video ( ) [EOL] for video in videos : [EOL] video [ [string] ] = str ( video [ [string] ] ) [EOL] return jsonify ( videos = videos ) [EOL] result = self . face_collection . get_videos_by_name ( name ) [EOL] [EOL] face_videos_ids = [ face [ [string] ] for face in result ] [EOL] unique_videos = set ( ) [EOL] for face_videos_list in face_videos_ids : [EOL] for video_id in face_videos_list : [EOL] unique_videos . add ( video_id ) [EOL] unique_videos = list ( unique_videos ) [EOL] videos_extensions = self . video_collection . get_videos_extensions ( unique_videos ) [EOL] videos_results = [ { [string] : video_id , [string] : video_ext [ [string] ] } for ( video_id , video_ext ) in zip ( unique_videos , videos_extensions ) ] [EOL] [EOL] return jsonify ( videos = videos_results ) [EOL] else : [EOL] return jsonify ( error = [string] ) [EOL] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Dict , List , Any [EOL] import typing [EOL] import vynd_api [EOL] from flask import jsonify [EOL] from flask_restful import Resource , request [EOL] [EOL] from . . import CLIENT , VideoCollection [EOL] [EOL] class GetProcessedVideos ( Resource ) : [EOL] [EOL] video_collection = VideoCollection ( ) [EOL] [EOL] def get ( self ) : [EOL] processed_videos = self . video_collection . get_processed_videos ( ) [EOL] for video in processed_videos : [EOL] video [ [string] ] = str ( video [ [string] ] ) [EOL] processed_videos_results = [ { [string] : video [ [string] ] , [string] : video [ [string] ] } for video in processed_videos ] [EOL] return jsonify ( processed_videos_results = processed_videos_results ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 $typing.List[typing.Dict[builtins.str,typing.Any]]$ 0 0
[EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify [EOL] [EOL] from . . import CLIENT , FaceCollection , VideoCollection , KeyFrameCollection [EOL] import numpy as np [EOL] import json [EOL] [EOL] class ResetDB ( Resource ) : [EOL] [EOL] face_collection = FaceCollection ( ) [EOL] video_collection = VideoCollection ( ) [EOL] keyframe_collection = KeyFrameCollection ( ) [EOL] [EOL] def post ( self ) : [EOL] self . face_collection . delete_all_faces ( ) [EOL] self . video_collection . delete_all_videos ( ) [EOL] self . keyframe_collection . delete_all_keyframes ( ) [EOL] return jsonify ( success = True )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 $vynd_api.data.keyframe_collection.KeyFrameCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] from typing import List [EOL] import json [EOL] [EOL] from flask_restful import Resource , request [EOL] from flask_api import status [EOL] from flask import jsonify , make_response [EOL] [EOL] from . . import KeyFrame [EOL] from . . import VideoProcessor , VideoProcessingResult [EOL] from . . import settings [EOL] [EOL] class ProcessKeyFrames ( Resource ) : [EOL] [EOL] def post ( self ) : [EOL] if request . get_json ( ) and request . get_json ( ) . get ( [string] ) and request . get_json ( ) . get ( [string] ) : [EOL] video_id = request . get_json ( ) [ [string] ] [EOL] key_frames = request . get_json ( ) [ [string] ] [EOL] [EOL] request . stream . read ( ) [EOL] [EOL] try : [EOL] key_frames = [ key_frame . encode ( ) for key_frame in key_frames ] [EOL] except : [EOL] return make_response ( jsonify ( error = [string] ) , status . HTTP_406_NOT_ACCEPTABLE ) [EOL] [EOL] key_frames = [ KeyFrame ( x ) for x in key_frames ] [EOL] result = settings . video_processor . process ( video_id , key_frames ) [EOL] [EOL] if result == VideoProcessingResult . SUCCESS : [EOL] return make_response ( jsonify ( result = str ( result . SUCCESS ) ) , status . HTTP_200_OK ) [EOL] return make_response ( jsonify ( result = str ( result . INVALID_VIDEO_ID ) ) , status . HTTP_400_BAD_REQUEST ) [EOL] else : [EOL] request . stream . read ( ) [EOL] return make_response ( jsonify ( error = [string] ) , status . HTTP_400_BAD_REQUEST ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[KeyFrame]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[KeyFrame]$ 0 0 0 0 0 0 0 0 0 $typing.List[KeyFrame]$ 0 0 $VideoProcessingResult$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.List[KeyFrame]$ 0 0 0 0 $VideoProcessingResult$ 0 0 0 0 0 0 0 0 0 0 0 $VideoProcessingResult$ 0 0 0 $VideoProcessingResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $VideoProcessingResult$ 0 0 0 $VideoProcessingResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify [EOL] [EOL] from . . import CLIENT , VideoCollection [EOL] [EOL] class GetFacesInVideo ( Resource ) : [EOL] [EOL] video_collection = VideoCollection ( ) [EOL] [EOL] def extractArgs ( self ) : [EOL] return request . args [EOL] [EOL] def get ( self ) : [EOL] video_id = self . extractArgs ( ) [ [string] ] [EOL] try : [EOL] result = self . video_collection . get_faces ( video_id ) [EOL] if len ( result ) == [number] : [EOL] return jsonify ( error = [string] ) [EOL] return jsonify ( faces_ids = result [ [number] ] [ [string] ] ) [EOL] except : [EOL] return jsonify ( error = [string] ) [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.video_collection.VideoCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify [EOL] from . . . search . image_search import search_by_image [EOL] [EOL] from . . import FaceCollection [EOL] [EOL] class GetFacesInImage ( Resource ) : [EOL] [EOL] face_collection = FaceCollection ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] def post ( self ) : [EOL] if request . get_json ( ) and request . get_json ( ) . get ( [string] ) : [EOL] image = request . get_json ( ) . get ( [string] ) [EOL] faces_ids = search_by_image ( image = image . encode ( ) ) [EOL] return jsonify ( faces_ids = faces_ids ) [EOL] else : [EOL] return jsonify ( error = [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify [EOL] [EOL] from . . import CLIENT , FaceCollection [EOL] import numpy as np [EOL] import json [EOL] [EOL] class GetFaces ( Resource ) : [EOL] [EOL] face_collection = FaceCollection ( ) [EOL] [EOL] def get ( self ) : [EOL] faces = self . face_collection . get_faces_info ( ) [EOL] return jsonify ( faces = faces )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0
[EOL] from typing import Any [EOL] import typing [EOL] import vynd_api [EOL] from flask_restful import Resource , request [EOL] from flask import jsonify , make_response [EOL] from flask_api import status [EOL] [EOL] from . . import CLIENT , FaceCollection [EOL] [EOL] import numpy as np [EOL] import json [EOL] [EOL] class FaceUpdater ( Resource ) : [EOL] [EOL] face_collection = FaceCollection ( ) [EOL] [EOL] def post ( self ) : [EOL] if request . get_json ( ) and request . get_json ( ) . get ( [string] ) and request . get_json ( ) . get ( [string] ) : [EOL] face_id = request . get_json ( ) . get ( [string] ) [EOL] name = request . get_json ( ) . get ( [string] ) [EOL] [EOL] update_result = self . face_collection . update_name ( face_id , name ) [EOL] [EOL] return jsonify ( success = update_result ) [EOL] else : [EOL] return make_response ( jsonify ( error = [string] ) , status . HTTP_400_BAD_REQUEST )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $vynd_api.data.face_collection.FaceCollection$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] class User : [EOL] __id = ... [EOL] [EOL] def __init__ ( self , id_ ) : [EOL] self . __id = id_ [EOL] [EOL] @ property def id ( self ) : [EOL] return self . __id [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional [EOL] import typing [EOL] import numpy [EOL] import builtins [EOL] [docstring] [EOL] [EOL] from typing import Optional [EOL] [EOL] import json [EOL] import numpy as np [EOL] [EOL] [EOL] from . . utils import image_utils , numpy_encoder [EOL] from . . data . db_utils import np_to_binary , binary_to_b64 [EOL] [EOL] class KeyFrame : [EOL] [EOL] def __init__ ( self , keyframe_image , timestamp = [number] ) : [EOL] [docstring] [EOL] self . __timestamp = timestamp [EOL] self . __set_image ( keyframe_image ) [EOL] self . __set_base64_image ( keyframe_image ) [EOL] [EOL] def __save_json_image ( self , keyframe_image ) : [EOL] if ( keyframe_image . all ( ) != None ) : [EOL] return json . dumps ( keyframe_image , cls = numpy_encoder . NumpyEncoder ) [EOL] else : [EOL] return None [EOL] [EOL] def __process_keyframe_image ( self , keyframe_image ) : [EOL] if isinstance ( keyframe_image , bytes ) : [comment] [EOL] return image_utils . base64_to_rgb ( keyframe_image ) [EOL] elif isinstance ( keyframe_image , np . ndarray ) : [comment] [EOL] return keyframe_image [EOL] else : [EOL] return None [EOL] [EOL] def __get_image ( self ) : [EOL] return self . __image [EOL] [EOL] def __set_image ( self , image ) : [EOL] self . __image = self . __process_keyframe_image ( image ) [EOL] [EOL] def __get_base64_image ( self ) : [EOL] return self . __base64_image [EOL] [EOL] def __set_base64_image ( self , image ) : [EOL] if isinstance ( image , bytes ) : [EOL] self . __base64_image = image [EOL] elif isinstance ( image , np . ndarray ) : [EOL] self . __base64_image = binary_to_b64 ( np_to_binary ( image ) ) [EOL] else : [EOL] self . __base64_image = None [EOL] [EOL] @ property def timestamp ( self ) : [EOL] return self . __timestamp [EOL] [EOL] image = property ( __get_image , __set_image ) [EOL] base64_image = property ( __get_base64_image , __set_base64_image ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.int]$ 0 $typing.Optional[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.property$ 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] import base64 [EOL] import cv2 [EOL] import numpy as np [EOL] [EOL] from PIL import Image [EOL] from io import BytesIO [EOL] [EOL] def base64_to_rgb ( base64_text ) : [EOL] [comment] [EOL] img = base64 . decodebytes ( base64_text ) [EOL] pil_img = Image . open ( BytesIO ( img ) ) [EOL] return np . asarray ( pil_img ) [EOL] [EOL] def rgb_to_base64 ( image ) : [EOL] return base64 . b64encode ( image ) [EOL] [EOL] def resize_image ( image , new_shape = ( [number] , [number] ) ) : [EOL] try : [EOL] return cv2 . resize ( image , new_shape ) [EOL] except Exception as e : [EOL] print ( str ( e ) ) [EOL] return np . array ( [ ] )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[EOL] from typing import Any [EOL] import numpy [EOL] import tensorflow [EOL] import builtins [EOL] import typing [EOL] import tensorflow as tf [EOL] import os [EOL] import numpy as np [EOL] [EOL] from pathlib import Path [EOL] [EOL] def load_model ( graph_path ) : [EOL] [docstring] [EOL] cur_dir = os . path . dirname ( __file__ ) [EOL] graph_path = str ( Path ( cur_dir , graph_path ) ) [EOL] sess = tf . Session ( ) [EOL] with tf . gfile . GFile ( graph_path , [string] ) as f : [EOL] graph_def = tf . GraphDef ( ) [EOL] graph_def . ParseFromString ( f . read ( ) ) [EOL] sess . graph . as_default ( ) [comment] [EOL] tf . import_graph_def ( graph_def ) [EOL] return sess [EOL] [EOL] def normalize_image ( image ) : [EOL] [docstring] [EOL] return ( image - [number] ) / [number] [EOL] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tensorflow.Session$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $numpy.ndarray$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] from typing import Any [EOL] import typing [EOL] import numpy as np [EOL] [EOL] def euclidian_distance ( embeddings1 , embeddings2 ) : [EOL] [docstring] [EOL] diff = np . subtract ( embeddings1 , embeddings2 ) [EOL] dist = np . sum ( np . square ( diff ) ) [EOL] return dist [EOL] [EOL] def cosine_similarity_distance ( embeddings1 , embeddings2 ) : [EOL] [docstring] [EOL] dot = np . sum ( np . multiply ( embeddings1 , embeddings2 ) ) [EOL] norm = np . linalg . norm ( embeddings1 ) * np . linalg . norm ( embeddings2 ) [EOL] similarity = min ( dot / norm , [number] ) [EOL] dist = np . arccos ( similarity ) / np . pi [comment] [EOL] return dist	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[EOL] import json [EOL] import numpy as np [EOL] [EOL] class NumpyEncoder ( json . JSONEncoder ) : [EOL] def default ( self , obj ) : [EOL] if isinstance ( obj , np . ndarray ) : [EOL] return obj . tolist ( ) [EOL] return json . JSONEncoder . default ( self , obj )	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0