	0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import io [EOL] import logging [EOL] from game import Game [EOL] import logging [EOL] import os [EOL] from constants import constants [EOL] [EOL] [EOL] def clear_log ( log_file ) : [EOL] f = open ( log_file , [string] ) [EOL] f . truncate ( [number] ) [EOL] [EOL] [EOL] def initialize_logging ( ) : [EOL] log_file = [string] [EOL] clear_log ( log_file ) [EOL] [EOL] fmt = [string] . format ( constants . VERSION ) [EOL] formatter = logging . Formatter ( fmt ) [EOL] logger = logging . getLogger ( ) [EOL] logger . setLevel ( [string] ) [EOL] [EOL] file_logger = logging . FileHandler ( log_file ) [EOL] file_logger . setFormatter ( formatter ) [EOL] logger . addHandler ( file_logger ) [EOL] [EOL] console_logger = logging . StreamHandler ( ) [EOL] console_logger . setFormatter ( formatter ) [EOL] logger . addHandler ( console_logger ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] initialize_logging ( ) [EOL] g = Game ( ) [EOL] g . run ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import event [EOL] import src [EOL] import pygame [EOL] import input [EOL] import controller [EOL] from event import EventManager , EventListener , Event [EOL] from controller import Controller , LaunchController , SettingsController [EOL] from input import Keyboard [EOL] import sys [EOL] from pygame . time import Clock [EOL] from constants import constants [EOL] import pygame [EOL] from enum import Enum [EOL] [EOL] [EOL] class GameState ( Enum ) : [EOL] SETTINGS = [number] [EOL] LOAD_SCREEN = [number] [EOL] [EOL] [EOL] class Game ( EventListener ) : [EOL] keyboard = None [EOL] event_manager = None [EOL] controller = None [EOL] state = None [EOL] [EOL] def __init__ ( self ) : [EOL] self . event_manager = EventManager ( ) [EOL] super ( Game , self ) . __init__ ( self . event_manager ) [EOL] self . inialize_pygame ( ) [EOL] [EOL] self . clock = Clock ( ) [EOL] self . screen = pygame . display . set_mode ( constants . SCREEN_SIZE ) [EOL] [EOL] self . keyboard = Keyboard ( self . event_manager ) [EOL] [EOL] self . state = GameState . LOAD_SCREEN [EOL] self . controller = LaunchController ( self . event_manager , self . screen ) [EOL] [EOL] def notify ( self , event ) : [EOL] if event == Event . QUIT : [EOL] pygame . quit ( ) [EOL] sys . exit ( ) [EOL] elif event == Event . TICK : [EOL] [comment] [EOL] self . clock . tick ( [number] ) [EOL] elif event == Event . OPEN_SETTINGS : [EOL] self . open_settings ( ) [EOL] elif event == Event . CLOSE_SETTINGS : [EOL] self . close_settings ( ) [EOL] [EOL] def run ( self ) : [EOL] while True : [EOL] self . event_manager . post ( Event . TICK ) [EOL] [EOL] def inialize_pygame ( self ) : [EOL] pygame . mixer . pre_init ( [number] , - [number] , [number] , [number] ) [EOL] pygame . init ( ) [EOL] pygame . font . init ( ) [EOL] [EOL] def open_settings ( self ) : [EOL] if self . state == GameState . SETTINGS : [EOL] return [EOL] self . state = GameState . SETTINGS [EOL] self . controller = SettingsController ( self . event_manager , self . screen ) [EOL] [EOL] def close_settings ( self ) : [EOL] if self . state == GameState . LOAD_SCREEN : [EOL] return [EOL] self . state = GameState . LOAD_SCREEN [EOL] self . controller = LaunchController ( self . event_manager , self . screen ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $src.game.GameState$ 0 0 0 0 0 0 0 0 0 0 $src.game.GameState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 $src.game.GameState$ 0 0 0 0 0 0 0 0 0 0 $src.game.GameState$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . keyboard import Keyboard [EOL] from . keybindings import Keybindings [EOL] [EOL] __all__ = [ [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0
from typing import List , Tuple [EOL] import event [EOL] import typing [EOL] import src [EOL] import builtins [EOL] import pygame [EOL] import pygame [EOL] from event import EventManager , Event , EventListener , InputEvent [EOL] from typing import Tuple , List [EOL] from . keybindings import Keybindings [EOL] [EOL] [EOL] class Keyboard ( EventListener ) : [EOL] def __init__ ( self , event_manager ) : [EOL] super ( Keyboard , self ) . __init__ ( event_manager ) [EOL] self . bindings = Keybindings ( ) [EOL] self . bindings . load ( ) [EOL] [EOL] def notify ( self , event ) : [EOL] if event == Event . TICK : [EOL] self . handle_inputs ( ) [EOL] [EOL] def handle_inputs ( self ) : [EOL] [comment] [EOL] for pg_event in self . get_pygame_events ( ) : [EOL] [comment] [EOL] if self . is_quit_event ( pg_event ) : [EOL] self . event_manager . post ( Event ( Event . QUIT ) ) [EOL] [comment] [EOL] elif pg_event . type == pygame . KEYDOWN : [EOL] self . handle_keypress ( pg_event . unicode ) [EOL] elif pg_event . type == pygame . KEYUP : [EOL] pass [EOL] elif pg_event . type == pygame . MOUSEBUTTONDOWN : [EOL] self . handle_mouse_click ( ) [EOL] [EOL] def handle_keypress ( self , key_name ) : [EOL] if self . get_binding ( key_name ) != Event . NONE : [EOL] self . post_bound_event ( key = key_name ) [EOL] [EOL] def handle_mouse_click ( self ) : [EOL] mouse_event = self . mouse_event ( ) [EOL] self . event_manager . post ( mouse_event ) [EOL] [EOL] def mouse_event ( self ) : [EOL] return InputEvent ( event = Event . MOUSE_CLICK , key = [string] , mouse = self . mouse_pos ( ) ) [EOL] [EOL] def mouse_pos ( self ) : [EOL] return pygame . mouse . get_pos ( ) [EOL] [EOL] def get_binding ( self , key ) : [EOL] return self . bindings . get_binding ( key ) [EOL] [EOL] def post_bound_event ( self , key ) : [EOL] binding = self . get_binding ( key ) [EOL] event = self . bindings . event_for_binding ( binding ) [EOL] return self . event_manager . post ( Event ( event ) ) [EOL] [EOL] def get_pygame_events ( self ) : [EOL] return pygame . event . get ( ) [EOL] [EOL] def is_quit_event ( self , pg_event ) : [EOL] if pg_event . type == pygame . QUIT : [EOL] return True [EOL] [EOL] return pg_event . type == pygame . KEYDOWN and pg_event . key == pygame . K_ESCAPE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.Event.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event.Manager$ 0 0 0 0 $src.input.keybindings.Keybindings$ 0 0 0 0 0 0 0 $src.input.keybindings.Keybindings$ 0 0 0 0 0 0 0 $None$ 0 0 0 $event.Event$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.InputEvent$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pygame.event.EventType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pygame.event.EventType$ 0 0 0 0 $pygame.event.EventType$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pygame.event.EventType$ 0 0 0 0 0 0 0 $pygame.event.EventType$ 0 0 0 0 0 0 0
from typing import Dict , List [EOL] import event [EOL] import typing [EOL] import builtins [EOL] import csv [EOL] from event import Event [EOL] from typing import Dict [EOL] import csv [EOL] import logging [EOL] [EOL] [EOL] class Keybindings ( object ) : [EOL] preference_file = [string] [EOL] binding_field = [string] [EOL] key_field = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] self . bindings = dict ( ) [EOL] [EOL] def load ( self ) : [EOL] bindings = dict ( ) [EOL] with open ( self . preference_file ) as bindings_file : [EOL] reader = csv . DictReader ( bindings_file ) [EOL] for row in reader : [EOL] key = row [ self . key_field ] [EOL] binding = row [ self . binding_field ] [EOL] bindings [ key ] = Event [ binding ] [EOL] [EOL] self . bindings = bindings [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( self ) ) [EOL] [EOL] def save ( self ) : [EOL] with open ( self . preference_file , [string] ) as bindings_file : [EOL] writer = csv . DictWriter ( bindings_file , fieldnames = [ self . binding_field , self . key_field ] ) [EOL] writer . writeheader ( ) [EOL] for key , binding in self . bindings . items ( ) : [EOL] writer . writerow ( { self . binding_field : binding , self . key_field : key } ) [EOL] [EOL] def update_binding ( self , key , event ) : [EOL] self . bindings [ key ] = event [EOL] [EOL] self . save ( ) [EOL] [EOL] logging . debug ( [string] ) [EOL] logging . debug ( str ( self ) ) [EOL] [EOL] def get_binding ( self , key ) : [EOL] return self . bindings . get ( key , Event . NONE ) [EOL] [EOL] def __str__ ( self ) : [EOL] keys = [ [string] , [string] ] [EOL] for key , value in self . bindings . items ( ) : [EOL] keys . append ( [string] . format ( key , value ) ) [EOL] keys . append ( [string] ) [EOL] return [string] . join ( keys ) [EOL] [EOL] @ classmethod def event_for_binding ( self , binding ) : [EOL] if binding == Event . CLOSE_SETTINGS : [EOL] return Event . CLOSE_SETTINGS [EOL] elif binding == Event . OPEN_SETTINGS : [EOL] return Event . OPEN_SETTINGS [EOL] return Event . NONE [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictReader$ 0 0 0 0 0 0 0 0 0 0 0 $csv.DictReader$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $event.Event$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $event.Event$ 0 0 0 $event.Event$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . abstract_model import Model [EOL] from . launch_model import LaunchModel [EOL] from . settings_model import SettingsModel [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
import event [EOL] from event import EventManager , EventListener , events [EOL] [EOL] [EOL] class Model ( EventListener ) : [EOL] def __init__ ( self , event_manager ) : [EOL] super ( Model , self ) . __init__ ( event_manager ) [EOL] [EOL] def notify ( self , event ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 0 $None$ 0 0 0 $event.events.Event$ 0 0 0 0 0
import event [EOL] from event import EventManager [EOL] from . abstract_model import Model [EOL] [EOL] [EOL] class SettingsModel ( Model ) : [EOL] def __init__ ( self , event_manager ) : [EOL] super ( SettingsModel , self ) . __init__ ( event_manager ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0
import event [EOL] from event import EventManager [EOL] from . abstract_model import Model [EOL] [EOL] [EOL] class LaunchModel ( Model ) : [EOL] def __init__ ( self , event_manager ) : [EOL] super ( LaunchModel , self ) . __init__ ( event_manager ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0
import event [EOL] import pygame [EOL] from controller import Controller [EOL] from event import EventManager , events [EOL] from model import LaunchModel [EOL] from view import LaunchView [EOL] from pygame import Surface [EOL] [EOL] [EOL] class LaunchController ( Controller ) : [EOL] [EOL] def __init__ ( self , event_manager , screen ) : [EOL] super ( LaunchController , self ) . __init__ ( event_manager , screen ) [EOL] self . model = LaunchModel ( self . event_manager ) [EOL] self . view = LaunchView ( self . event_manager , self . screen ) [EOL] [EOL] def handle_input ( self , event ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 $pygame.Surface$ 0 0 0 0 $None$ 0 0 0 $event.events.Event$ 0 0 0 0 0
import event [EOL] import view [EOL] import pygame [EOL] import model [EOL] from event import EventListener , EventManager , events [EOL] from model import Model [EOL] from view import View [EOL] from pygame import Surface [EOL] [EOL] [EOL] class Controller ( EventListener ) : [EOL] view = None [EOL] model = None [EOL] [EOL] def __init__ ( self , event_manager , screen ) : [EOL] super ( Controller , self ) . __init__ ( event_manager ) [EOL] self . screen = screen [EOL] [EOL] def notify ( self , event ) : [EOL] [comment] [EOL] if isinstance ( event , events . InputEvent ) : [EOL] self . handle_input ( event ) [EOL] [EOL] def handle_input ( self , event ) : [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Controller.view.View$ 0 0 0 $Controller.model.Model$ 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.events.Event$ 0 0 0 0 0 0 0 0 $event.events.Event$ 0 0 0 0 0 0 0 0 0 0 0 $event.events.Event$ 0 0 0 0 $None$ 0 0 0 $event.events.Event$ 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . controller import Controller [EOL] from . launch_controller import LaunchController [EOL] from . settings_controller import SettingsController [EOL] [EOL] __all__ = [ [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0
import event [EOL] import pygame [EOL] from controller import Controller [EOL] from event import EventManager , events [EOL] from model import SettingsModel [EOL] from view import SettingsView [EOL] from pygame import Surface [EOL] [EOL] [EOL] class SettingsController ( Controller ) : [EOL] [EOL] def __init__ ( self , event_manager , screen ) : [EOL] super ( SettingsController , self ) . __init__ ( event_manager , screen ) [EOL] self . model = SettingsModel ( self . event_manager ) [EOL] self . view = SettingsView ( self . event_manager , self . screen ) [EOL] [EOL] def handle_input ( self , event ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 0 0 $pygame.Surface$ 0 0 0 0 $None$ 0 0 0 $event.events.Event$ 0 0 0 0 0
from typing import List , Any , Literal , Tuple [EOL] import typing [EOL] import typing_extensions [EOL] from unittest . mock import patch , MagicMock [EOL] from unittest import TestCase [EOL] from input import Keyboard [EOL] from typing import Any [EOL] from event import Event , InputEvent [EOL] import pygame [EOL] [EOL] [EOL] class KeyboardTest ( TestCase ) : [EOL] [EOL] @ patch ( [string] ) def get_keyboard ( self , EventManager ) : [EOL] self . keyboard = Keyboard ( EventManager ( ) ) [EOL] [EOL] def setUp ( self ) : [EOL] self . get_keyboard ( ) [EOL] [EOL] def test_quit ( self ) : [EOL] quit_event = [ pygame . event . Event ( pygame . QUIT , { [string] : [string] } ) ] [EOL] self . keyboard . get_pygame_events = MagicMock ( return_value = quit_event ) [EOL] [EOL] self . keyboard . notify ( Event . TICK ) [EOL] [EOL] self . keyboard . event_manager . post . assert_called_once_with ( Event . QUIT ) [EOL] [EOL] def test_unbound_key_posts_no_events ( self ) : [EOL] quit_event = [ pygame . event . Event ( pygame . KEYDOWN , { [string] : [string] , [string] : [number] } ) ] [EOL] self . keyboard . get_pygame_events = MagicMock ( return_value = quit_event ) [EOL] [EOL] self . keyboard . notify ( Event . TICK ) [EOL] [EOL] self . keyboard . event_manager . post . never_called ( ) [EOL] [EOL] def test_bound_key_posts_bound_event ( self ) : [EOL] self . keyboard . get_binding = MagicMock ( return_value = Event . OPEN_SETTINGS ) [EOL] event = [ pygame . event . Event ( pygame . KEYDOWN , { [string] : [string] , [string] : [number] } ) ] [EOL] self . keyboard . get_pygame_events = MagicMock ( return_value = event ) [EOL] [EOL] self . keyboard . notify ( Event . TICK ) [EOL] [EOL] self . keyboard . event_manager . post . assert_called_once_with ( Event . OPEN_SETTINGS ) [EOL] [EOL] def test_mouse_click_posts_mouse_event ( self ) : [EOL] mouse = ( [number] , [number] ) [EOL] mouse_event = InputEvent ( Event . MOUSE_CLICK , mouse = mouse ) [EOL] event = [ pygame . event . Event ( pygame . MOUSEBUTTONDOWN , { [string] : [string] , [string] : [number] } ) ] [EOL] self . keyboard . get_pygame_events = MagicMock ( return_value = event ) [EOL] self . keyboard . mouse_event = MagicMock ( return_value = mouse_event ) [EOL] [EOL] self . keyboard . notify ( Event . TICK ) [EOL] [EOL] self . keyboard . event_manager . post . assert_called_once_with ( mouse_event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import IO , Dict [EOL] import builtins [EOL] import typing [EOL] import event [EOL] import csv [EOL] from unittest import TestCase [EOL] from input import Keybindings [EOL] import tempfile [EOL] from typing import Dict [EOL] from event import Event [EOL] import csv [EOL] [EOL] [EOL] class KeybindingsTest ( TestCase ) : [EOL] [EOL] def default_binding ( self ) : [EOL] return { [string] : Event . OPEN_SETTINGS } [EOL] [EOL] def load_bindings ( self , bindings ) : [EOL] self . preference_file = tempfile . NamedTemporaryFile ( mode = [string] ) [EOL] self . keybindings = Keybindings ( ) [EOL] self . keybindings . preference_file = self . preference_file . name [EOL] [EOL] BINDING = [string] [EOL] KEY = [string] [EOL] with open ( self . preference_file . name , [string] ) as fake_csv : [EOL] writer = csv . DictWriter ( fake_csv , fieldnames = [ BINDING , KEY ] ) [EOL] writer . writeheader ( ) [EOL] for key , binding in bindings . items ( ) : [EOL] writer . writerow ( { BINDING : binding , KEY : key } ) [EOL] [EOL] self . keybindings . load ( ) [EOL] [EOL] def test_load_settings ( self ) : [EOL] self . load_bindings ( self . default_binding ( ) ) [EOL] [EOL] self . assertEqual ( self . keybindings . get_binding ( [string] ) , Event . OPEN_SETTINGS ) [EOL] [EOL] def test_save_settings ( self ) : [EOL] self . load_bindings ( self . default_binding ( ) ) [EOL] new_prefs_file = tempfile . NamedTemporaryFile ( mode = [string] ) [EOL] self . keybindings . preference_file = new_prefs_file . name [EOL] [EOL] self . keybindings . save ( ) [EOL] [EOL] [comment] [EOL] self . keybindings = Keybindings ( ) [EOL] self . keybindings . preference_file = new_prefs_file . name [EOL] self . keybindings . load ( ) [EOL] self . assertEqual ( self . keybindings . get_binding ( [string] ) , Event . OPEN_SETTINGS ) [EOL] [EOL] def test_update_settings ( self ) : [EOL] self . load_bindings ( self . default_binding ( ) ) [EOL] self . keybindings . update_binding ( [string] , Event . CLOSE_SETTINGS ) [EOL] [EOL] self . assertEqual ( self . keybindings . get_binding ( [string] ) , Event . CLOSE_SETTINGS ) [EOL] [EOL] def test_update_settings_are_saved ( self ) : [EOL] self . load_bindings ( self . default_binding ( ) ) [EOL] self . keybindings . update_binding ( [string] , Event . CLOSE_SETTINGS ) [EOL] [EOL] [comment] [EOL] self . keybindings = Keybindings ( ) [EOL] self . keybindings . preference_file = self . preference_file . name [EOL] self . keybindings . load ( ) [EOL] self . assertEqual ( self . keybindings . get_binding ( [string] ) , Event . CLOSE_SETTINGS ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,event.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,event.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $csv.DictWriter$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,event.Event]$ 0 0 0 0 0 0 $csv.DictWriter$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.IO[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
import events [EOL] from . events import Event [EOL] [EOL] [EOL] class Listener ( object ) : [EOL] [EOL] def notify ( self , event ) : [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $events.Event$ 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import builtins [EOL] import typing [EOL] import src [EOL] from typing import Tuple [EOL] from enum import Enum [EOL] [EOL] [EOL] class Event ( Enum ) : [EOL] NONE = [string] [EOL] QUIT = [string] [EOL] TICK = [string] [EOL] KEYDOWN = [string] [EOL] KEYUP = [string] [EOL] MOUSE_CLICK = [string] [EOL] [EOL] [comment] [EOL] OPEN_SETTINGS = [string] [EOL] CLOSE_SETTINGS = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Enum ) : [EOL] return self . value == other . value [EOL] return False [EOL] [EOL] def __str__ ( self ) : [EOL] return self . value [EOL] [EOL] [EOL] class InputEvent ( object ) : [EOL] [EOL] def __init__ ( self , event , key = [string] , pressed = False , mouse = ( - [number] , - [number] ) ) : [EOL] self . event = event [EOL] self . key = key [EOL] self . mouse = mouse [EOL] self . pressed = pressed [EOL] [EOL] def __str__ ( self ) : [EOL] return [string] % ( self . event , self . key , self . mouse , self . pressed ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $src.event.events.Event$ 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.event.events.Event$ 0 $src.event.events.Event$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import events [EOL] import event_manager [EOL] import src [EOL] from . listener import Listener [EOL] from . event_manager import EventManager [EOL] from . events import Event [EOL] [EOL] [EOL] class EventListener ( Listener ) : [EOL] [EOL] def __init__ ( self , event_manager ) : [EOL] event_manager . register ( self ) [EOL] self . event_manager = event_manager [EOL] [EOL] def notify ( self , event ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $src.event.event_manager.EventManager$ 0 0 0 $src.event.event_manager.EventManager$ 0 0 0 0 0 0 0 0 $src.event.event_manager.EventManager$ 0 $src.event.event_manager.EventManager$ 0 0 0 $None$ 0 0 0 $events.Event$ 0 0 0 0 0
import weakref [EOL] import listener [EOL] import events [EOL] import logging [EOL] from . listener import Listener [EOL] from . events import Event [EOL] [EOL] [EOL] class EventManager ( object ) : [EOL] def __init__ ( self ) : [EOL] from weakref import WeakKeyDictionary [EOL] self . listeners = WeakKeyDictionary ( ) [EOL] [EOL] def register ( self , l ) : [EOL] self . listeners [ l ] = [number] [EOL] logging . debug ( [string] . format ( len ( self . listeners ) , l ) ) [EOL] [EOL] def unregister ( self , l ) : [EOL] if l in self . listeners . keys ( ) : [EOL] del self . listeners [ l ] [EOL] [EOL] def post ( self , event ) : [EOL] if not event == Event . TICK : [EOL] logging . debug ( [string] . format ( str ( event ) ) ) [EOL] [EOL] [comment] [EOL] for l in list ( self . listeners . keys ( ) ) : [EOL] l . notify ( event ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 $weakref.WeakKeyDictionary$ 0 0 0 0 0 0 0 $None$ 0 0 0 $listener.Listener$ 0 0 0 0 0 0 0 $listener.Listener$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $listener.Listener$ 0 0 0 0 0 $None$ 0 0 0 $listener.Listener$ 0 0 0 0 $listener.Listener$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $listener.Listener$ 0 0 0 0 $None$ 0 0 0 $events.Event$ 0 0 0 0 0 $events.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $events.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $events.Event$ 0 0
from typing import List [EOL] import typing [EOL] from . event_manager import EventManager [EOL] from . event_listener import EventListener [EOL] from . events import Event , InputEvent [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple [EOL] import typing [EOL] VERSION = [number] [EOL] SCREEN_SIZE = ( [number] , [number] ) [EOL]	0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $typing.Tuple[builtins.int,builtins.int]$ 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . abstract_view import View [EOL] from . pygame_view import PygameView [EOL] from . settings_view import SettingsView [EOL] from . launch_view import LaunchView [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from event import EventListener [EOL] [EOL] [EOL] class View ( EventListener ) : [EOL] def render ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import event [EOL] import typing [EOL] import pygame [EOL] import pygame [EOL] from event import EventManager [EOL] from view import PygameView [EOL] [EOL] [EOL] class LaunchView ( PygameView ) : [EOL] def __init__ ( self , event_manager , screen ) : [EOL] super ( LaunchView , self ) . __init__ ( event_manager , screen ) [EOL] [EOL] def render ( self ) : [EOL] self . screen . fill ( ( [number] , [number] , [number] ) ) [EOL] somewords = self . smallfont . render ( [string] , True , ( [number] , [number] , [number] ) ) [EOL] self . screen . blit ( somewords , ( [number] , [number] ) ) [EOL] pygame . display . flip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 0 0 0 0 0 0 0 0 $event.EventManager$ 0 $pygame.Surface$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import event [EOL] import pygame [EOL] import pygame [EOL] from event import EventManager , Event [EOL] from view import View [EOL] [EOL] [EOL] class PygameView ( View ) : [EOL] def __init__ ( self , event_manager , screen ) : [EOL] super ( View , self ) . __init__ ( event_manager ) [EOL] self . screen = screen [EOL] pygame . display . set_caption ( [string] ) [EOL] self . smallfont = pygame . font . Font ( None , [number] ) [EOL] [EOL] def notify ( self , event ) : [EOL] if event == Event . TICK : [EOL] self . render ( ) [EOL] [EOL] def render ( self ) : [EOL] raise NotImplementedError ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.Event.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $event.Event.Manager$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $event.Event$ 0 0 0 0 $event.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0