[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] import builtins [EOL] from typing import List , Callable [EOL] import markdown_svgbob [EOL] import typing [EOL] import src [EOL] [docstring] [EOL] [EOL] __version__ = [string] [EOL] [EOL] [EOL] from markdown_svgbob . wrapper import text2svg [EOL] from markdown_svgbob . wrapper import get_bin_path [EOL] from markdown_svgbob . extension import SvgbobExtension [EOL] [EOL] get_svgbob_bin_path = get_bin_path [EOL] [EOL] [EOL] def _make_extension ( ** kwargs ) : [EOL] return SvgbobExtension ( ** kwargs ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] makeExtension = _make_extension [EOL] [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $markdown_svgbob.extension.SvgbobExtension$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Any , Iterable , Type , List , Pattern , Dict [EOL] import src [EOL] import markdown_svgbob [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import re [EOL] import copy [EOL] import json [EOL] import base64 [EOL] import typing as typ [EOL] import hashlib [EOL] import logging [EOL] [EOL] from markdown . extensions import Extension [EOL] from markdown . preprocessors import Preprocessor [EOL] from markdown . postprocessors import Postprocessor [EOL] [EOL] import markdown_svgbob . wrapper as wrapper [EOL] [EOL] try : [EOL] from urllib . parse import quote [EOL] except ImportError : [EOL] from urllib import quote [comment] [EOL] [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def make_marker_id ( text ) : [EOL] data = text . encode ( [string] ) [EOL] return hashlib . md5 ( data ) . hexdigest ( ) [EOL] [EOL] [EOL] [comment] [EOL] TagType = str [EOL] [EOL] [EOL] def svg2html ( svg_data , tag_type = [string] ) : [EOL] svg_data = svg_data . replace ( [string] , [string] ) [EOL] if tag_type == [string] : [EOL] img_b64_data = base64 . standard_b64encode ( svg_data ) [EOL] img_text = img_b64_data . decode ( [string] ) [EOL] return f' [string] { img_text } [string] ' [EOL] elif tag_type == [string] : [EOL] img_text = svg_data . decode ( [string] ) [EOL] img_text = quote ( img_text ) [EOL] return f' [string] { img_text } [string] ' [EOL] elif tag_type == [string] : [EOL] return svg_data . decode ( [string] ) [EOL] else : [EOL] err_msg = f" [string] { tag_type } [string] " [EOL] raise NotImplementedError ( err_msg ) [EOL] [EOL] [EOL] def _clean_block_text ( block_text ) : [EOL] if block_text . startswith ( [string] ) : [EOL] block_text = block_text [ len ( [string] ) : ] [EOL] elif block_text . startswith ( [string] ) : [EOL] block_text = block_text [ len ( [string] ) : ] [EOL] [EOL] if block_text . endswith ( [string] ) : [EOL] block_text = block_text [ : - len ( [string] ) ] [EOL] elif block_text . endswith ( [string] ) : [EOL] block_text = block_text [ : - len ( [string] ) ] [EOL] return block_text [EOL] [EOL] [EOL] def _parse_min_char_width ( options ) : [EOL] min_char_width = options . pop ( [string] , [string] ) [EOL] try : [EOL] return int ( round ( float ( min_char_width ) ) ) [EOL] except ValueError : [EOL] log . warning ( f" [string] { min_char_width }" ) [EOL] return [number] [EOL] [EOL] [EOL] def _add_char_padding ( block_text , min_width ) : [EOL] lines = block_text . splitlines ( ) [EOL] block_width = max ( len ( line ) for line in lines ) [EOL] if block_width >= min_width : [EOL] return block_text [EOL] [EOL] lpad = [string] * ( ( min_width - block_width ) // [number] ) [EOL] new_lines = [ ( lpad + line ) . ljust ( min_width ) for line in lines ] [EOL] return [string] . join ( new_lines ) [EOL] [EOL] [EOL] [comment] [EOL] BG_STYLE_PATTERN = [string] [EOL] BG_STYLE_RE = re . compile ( BG_STYLE_PATTERN . encode ( [string] ) , flags = re . VERBOSE ) [EOL] [EOL] FG_STYLE_PATTERN = [string] [EOL] FG_STYLE_RE = re . compile ( FG_STYLE_PATTERN . encode ( [string] ) , flags = re . VERBOSE ) [EOL] [EOL] [EOL] def _postprocess_svg ( svg_data , bg_color = None , fg_color = None ) : [EOL] if bg_color : [EOL] pos = [number] [EOL] while True : [EOL] match = BG_STYLE_RE . search ( svg_data , pos ) [EOL] if match is None : [EOL] break [EOL] [EOL] repl = match . group ( [number] ) . replace ( [string] , bg_color . encode ( [string] ) ) [EOL] begin , end = match . span ( ) [EOL] pos = end [EOL] svg_data = svg_data [ : begin ] + repl + svg_data [ end : ] [EOL] [EOL] if fg_color : [EOL] pos = [number] [EOL] while True : [EOL] match = FG_STYLE_RE . search ( svg_data , pos ) [EOL] if match is None : [EOL] break [EOL] [EOL] repl = match . group ( [number] ) . replace ( [string] , fg_color . encode ( [string] ) ) [EOL] begin , end = match . span ( ) [EOL] pos = end [EOL] svg_data = svg_data [ : begin ] + repl + svg_data [ end : ] [EOL] [EOL] return svg_data [EOL] [EOL] [EOL] def draw_bob ( block_text , default_options = None ) : [EOL] options = { } [EOL] [EOL] if default_options : [EOL] options . update ( default_options ) [EOL] [EOL] block_text = _clean_block_text ( block_text ) [EOL] header , rest = block_text . split ( [string] , [number] ) [EOL] if [string] in header and [string] in header : [EOL] options . update ( json . loads ( header ) ) [EOL] block_text = rest [EOL] [EOL] min_char_width = _parse_min_char_width ( options ) [EOL] if min_char_width : [EOL] block_text = _add_char_padding ( block_text , min_char_width ) [EOL] [EOL] tag_type = typ . cast ( str , options . pop ( [string] , [string] ) ) [EOL] [EOL] bg_color = options . pop ( [string] , [string] ) [EOL] fg_color = options . pop ( [string] , [string] ) [EOL] if not isinstance ( bg_color , str ) : [EOL] bg_color = [string] [EOL] if not isinstance ( fg_color , str ) : [EOL] fg_color = [string] [EOL] [EOL] svg_data = wrapper . text2svg ( block_text , options ) [EOL] svg_data = _postprocess_svg ( svg_data , bg_color , fg_color ) [EOL] [EOL] return svg2html ( svg_data , tag_type = tag_type ) [EOL] [EOL] [EOL] DEFAULT_CONFIG = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] [EOL] class SvgbobExtension ( Extension ) : [EOL] def __init__ ( self , ** kwargs ) : [EOL] self . config = copy . deepcopy ( DEFAULT_CONFIG ) [EOL] for name , options_text in wrapper . parse_options ( ) . items ( ) : [EOL] self . config [ name ] = [ [string] , options_text ] [EOL] [EOL] self . images = { } [EOL] super ( ) . __init__ ( ** kwargs ) [EOL] [EOL] def reset ( self ) : [EOL] self . images . clear ( ) [EOL] [EOL] def extendMarkdown ( self , md ) : [EOL] preproc = SvgbobPreprocessor ( md , self ) [EOL] md . preprocessors . register ( preproc , name = [string] , priority = [number] ) [EOL] [EOL] postproc = SvgbobPostprocessor ( md , self ) [EOL] md . postprocessors . register ( postproc , name = [string] , priority = [number] ) [EOL] md . registerExtension ( self ) [EOL] [EOL] [EOL] BLOCK_RE = re . compile ( [string] ) [EOL] [EOL] [EOL] class SvgbobPreprocessor ( Preprocessor ) : [EOL] def __init__ ( self , md , ext ) : [EOL] super ( ) . __init__ ( md ) [EOL] self . ext = ext [EOL] [EOL] @ property def default_options ( self ) : [EOL] options = { [string] : self . ext . getConfig ( [string] , [string] ) , [string] : self . ext . getConfig ( [string] , [string] ) , } [EOL] for name in self . ext . config . keys ( ) : [EOL] val = self . ext . getConfig ( name , [string] ) [EOL] if val != [string] : [EOL] options [ name ] = val [EOL] return options [EOL] [EOL] def _make_tag_for_block ( self , block_lines ) : [EOL] block_text = [string] . join ( block_lines ) . rstrip ( ) [EOL] img_tag = draw_bob ( block_text , self . default_options ) [EOL] img_id = make_marker_id ( img_tag ) [EOL] marker_tag = f" [string] { img_id } [string] { img_id } [string] " [EOL] tag_text = f" [string] { img_tag } [string] " [EOL] [EOL] self . ext . images [ marker_tag ] = tag_text [EOL] return marker_tag [EOL] [EOL] def _iter_out_lines ( self , lines ) : [EOL] is_in_fence = False [EOL] expected_close_fence = [string] [EOL] [EOL] block_lines = [ ] [EOL] [EOL] for line in lines : [EOL] if is_in_fence : [EOL] block_lines . append ( line ) [EOL] is_ending_fence = line . strip ( ) == expected_close_fence [EOL] if not is_ending_fence : [EOL] continue [EOL] [EOL] is_in_fence = False [EOL] marker_tag = self . _make_tag_for_block ( block_lines ) [EOL] del block_lines [ : ] [EOL] yield marker_tag [EOL] else : [EOL] fence_match = BLOCK_RE . match ( line ) [EOL] if fence_match : [EOL] is_in_fence = True [EOL] expected_close_fence = fence_match . group ( [number] ) [EOL] block_lines . append ( line ) [EOL] else : [EOL] yield line [EOL] [EOL] def run ( self , lines ) : [EOL] return list ( self . _iter_out_lines ( lines ) ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class SvgbobPostprocessor ( Postprocessor ) : [EOL] def __init__ ( self , md , ext ) : [EOL] super ( ) . __init__ ( md ) [EOL] self . ext = ext [EOL] [EOL] def run ( self , text ) : [EOL] for marker_tag , img in self . ext . images . items ( ) : [EOL] wrapped_marker = [string] + marker_tag + [string] [EOL] if wrapped_marker in text : [EOL] text = text . replace ( wrapped_marker , img ) [EOL] elif marker_tag in text : [EOL] text = text . replace ( marker_tag , img ) [EOL] [EOL] return text [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $src.markdown_svgbob.extension.SvgbobPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.markdown_svgbob.extension.SvgbobPreprocessor$ 0 0 0 0 0 0 0 0 0 0 0 $src.markdown_svgbob.extension.SvgbobPostprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.markdown_svgbob.extension.SvgbobPostprocessor$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $SvgbobExtension$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SvgbobExtension$ 0 $SvgbobExtension$ 0 0 0 0 0 $markdown_svgbob.wrapper.Options$ 0 0 0 0 0 $markdown_svgbob.wrapper.Options$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $markdown_svgbob.wrapper.Options$ 0 0 0 0 $typing.Any$ 0 0 $markdown_svgbob.wrapper.Options$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $SvgbobExtension$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $SvgbobExtension$ 0 $SvgbobExtension$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Union , Iterable , IO , Type , List , Pattern , Dict [EOL] import pathlib2 [EOL] import typing [EOL] import builtins [EOL] import hashlib [EOL] import subprocess [EOL] import os [EOL] import re [EOL] import time [EOL] import signal [EOL] import typing as typ [EOL] import hashlib [EOL] import platform [EOL] import tempfile [EOL] import subprocess as sp [EOL] [EOL] import pathlib2 as pl [EOL] [EOL] SIG_NAME_BY_NUM = { k : v for v , k in sorted ( signal . __dict__ . items ( ) , reverse = True ) if v . startswith ( [string] ) and not v . startswith ( [string] ) } [EOL] [EOL] assert SIG_NAME_BY_NUM [ [number] ] == [string] [EOL] [EOL] [EOL] TMP_DIR = pl . Path ( tempfile . gettempdir ( ) ) / [string] [EOL] [EOL] LIBDIR = pl . Path ( __file__ ) . parent [EOL] PKG_BIN_DIR = LIBDIR / [string] [EOL] FALLBACK_BIN_DIR = pl . Path ( [string] ) / [string] / [string] [EOL] FALLBACK_BIN_DIR = FALLBACK_BIN_DIR . expanduser ( ) [EOL] [EOL] CMD_NAME = [string] [EOL] [EOL] [EOL] def _get_usr_bin_path ( ) : [EOL] env_path = os . environ . get ( [string] ) [EOL] env_paths = [ ] [EOL] [EOL] if env_path : [EOL] path_strs = env_path . split ( os . pathsep ) [EOL] env_paths . extend ( [ pl . Path ( p ) for p in path_strs ] ) [EOL] [EOL] [comment] [EOL] if FALLBACK_BIN_DIR not in env_paths : [EOL] env_paths . append ( FALLBACK_BIN_DIR ) [EOL] [EOL] for path in env_paths : [EOL] local_bin = path / CMD_NAME [EOL] if local_bin . exists ( ) : [EOL] return local_bin [EOL] [EOL] local_bin = path / f"{ CMD_NAME } [string] " [EOL] if local_bin . exists ( ) : [EOL] return local_bin [EOL] [EOL] return None [EOL] [EOL] [EOL] [comment] [EOL] OSNAME = platform . system ( ) [EOL] MACHINE = platform . machine ( ) [EOL] [EOL] [EOL] def _get_pkg_bin_path ( osname = OSNAME , machine = MACHINE ) : [EOL] if machine == [string] : [EOL] machine = [string] [EOL] glob_expr = f" [string] { machine } [string] { osname }" [EOL] bin_files = list ( PKG_BIN_DIR . glob ( glob_expr ) ) [EOL] if bin_files : [EOL] return max ( bin_files ) [EOL] [EOL] err_msg = ( [string] [string] [string] [string] ) [EOL] [EOL] raise NotImplementedError ( err_msg ) [EOL] [EOL] [EOL] def get_bin_path ( ) : [EOL] usr_bin_path = _get_usr_bin_path ( ) [EOL] if usr_bin_path : [EOL] return usr_bin_path [EOL] else : [EOL] return _get_pkg_bin_path ( ) [EOL] [EOL] [EOL] def _iter_output_lines ( buf ) : [EOL] while True : [EOL] output = buf . readline ( ) [EOL] if output : [EOL] yield output [EOL] else : [EOL] return [EOL] [EOL] [EOL] def read_output ( buf ) : [EOL] assert buf is not None [EOL] return [string] . join ( _iter_output_lines ( buf ) ) . decode ( [string] ) [EOL] [EOL] [EOL] ArgValue = typ . Union [ str , int , float , bool ] [EOL] Options = typ . Dict [ str , ArgValue ] [EOL] [EOL] [EOL] class SvgbobException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def text2svg ( image_text , options = None ) : [EOL] binpath = get_bin_path ( ) [EOL] cmd_parts = [ str ( binpath ) ] [EOL] [EOL] if options : [EOL] for option_name , option_value in options . items ( ) : [EOL] if option_name . startswith ( [string] ) : [EOL] arg_name = option_name [EOL] else : [EOL] arg_name = [string] + option_name [EOL] [EOL] if option_value is True : [EOL] cmd_parts . append ( arg_name ) [EOL] elif option_value is False : [EOL] continue [EOL] else : [EOL] arg_value = str ( option_value ) [EOL] cmd_parts . append ( arg_name ) [EOL] cmd_parts . append ( arg_value ) [EOL] [EOL] input_data = image_text . encode ( [string] ) [EOL] [EOL] hasher = hashlib . sha256 ( input_data ) [EOL] for cmd_part in cmd_parts : [EOL] hasher . update ( cmd_part . encode ( [string] ) ) [EOL] [EOL] digest = hasher . hexdigest ( ) [EOL] [EOL] tmp_output_file = TMP_DIR / ( digest + [string] ) [EOL] [EOL] if tmp_output_file . exists ( ) : [EOL] tmp_output_file . touch ( ) [EOL] else : [EOL] cmd_parts . extend ( [ [string] , str ( tmp_output_file ) ] ) [EOL] [EOL] TMP_DIR . mkdir ( parents = True , exist_ok = True ) [EOL] proc = sp . Popen ( cmd_parts , stdin = sp . PIPE , stdout = sp . PIPE ) [EOL] stdin = proc . stdin [EOL] assert stdin is not None [EOL] [EOL] stdin . write ( input_data ) [EOL] stdin . close ( ) [EOL] ret_code = proc . wait ( ) [EOL] [EOL] if ret_code < [number] : [EOL] signame = SIG_NAME_BY_NUM [ abs ( ret_code ) ] [EOL] err_msg = ( [string] + [string] + f" [string] { ret_code } [string] { signame } [string] " ) [EOL] raise SvgbobException ( err_msg ) [EOL] elif ret_code > [number] : [EOL] stdout = read_output ( proc . stdout ) [EOL] errout = read_output ( proc . stderr ) [EOL] output = ( stdout + [string] + errout ) . strip ( ) [EOL] err_msg = f" [string] { output }" [EOL] raise SvgbobException ( err_msg ) [EOL] [EOL] with tmp_output_file . open ( mode = [string] ) as fobj : [EOL] result = fobj . read ( ) [EOL] [EOL] _cleanup_tmp_dir ( ) [EOL] [EOL] return typ . cast ( bytes , result ) [EOL] [EOL] [EOL] def _cleanup_tmp_dir ( ) : [EOL] min_mtime = time . time ( ) - [number] * [number] * [number] [EOL] for fpath in TMP_DIR . iterdir ( ) : [EOL] if not fpath . is_file ( ) : [EOL] continue [EOL] mtime = fpath . stat ( ) . st_mtime [EOL] if mtime < min_mtime : [EOL] fpath . unlink ( ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] DEFAULT_HELP_TEXT = [string] [EOL] [EOL] DEFAULT_HELP_TEXT = DEFAULT_HELP_TEXT . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def _get_cmd_help_text ( ) : [EOL] binpath = get_bin_path ( ) [EOL] cmd_parts = [ str ( binpath ) , [string] ] [EOL] proc = sp . Popen ( cmd_parts , stdout = sp . PIPE ) [EOL] help_text = read_output ( proc . stdout ) [EOL] return help_text [EOL] [EOL] [EOL] OptionsHelp = typ . Dict [ str , str ] [EOL] [EOL] [comment] [EOL] OPTION_PATTERN = [string] [EOL] OPTION_REGEX = re . compile ( OPTION_PATTERN , flags = re . VERBOSE | re . DOTALL | re . MULTILINE ) [EOL] [EOL] [EOL] def _parse_options_help_text ( help_text ) : [EOL] options = { } [EOL] [EOL] options_text = help_text . split ( [string] , [number] ) [ - [number] ] [EOL] options_text = options_text . split ( [string] , [number] ) [ [number] ] [EOL] [EOL] for match in OPTION_REGEX . finditer ( options_text ) : [EOL] name = match . group ( [string] ) [EOL] text = match . group ( [string] ) [EOL] text = [string] . join ( line . strip ( ) for line in text . splitlines ( ) ) [EOL] options [ name ] = text . strip ( ) [EOL] [EOL] options . pop ( [string] , None ) [EOL] options . pop ( [string] , None ) [EOL] options . pop ( [string] , None ) [EOL] [EOL] return options [EOL] [EOL] [EOL] _PARSED_OPTIONS = { } [EOL] [EOL] [EOL] def parse_options ( ) : [EOL] if _PARSED_OPTIONS : [EOL] return _PARSED_OPTIONS [EOL] [EOL] options = _parse_options_help_text ( DEFAULT_HELP_TEXT ) [EOL] try : [EOL] help_text = _get_cmd_help_text ( ) [EOL] cmd_options = _parse_options_help_text ( help_text ) [EOL] options . update ( cmd_options ) [EOL] except NotImplementedError : [EOL] [comment] [EOL] pass [EOL] [EOL] _PARSED_OPTIONS . update ( options ) [EOL] return options [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pathlib2.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib2.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OptionsHelp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $OptionsHelp$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] from typing import Type , Any , Sequence [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import sys [EOL] import json [EOL] import typing as typ [EOL] import subprocess as sp [EOL] [EOL] import markdown_svgbob [EOL] [EOL] [comment] [EOL] [comment] [EOL] if os . environ . get ( [string] ) == [string] : [EOL] try : [EOL] import rich . traceback [EOL] [EOL] rich . traceback . install ( ) [EOL] except ImportError : [EOL] [comment] [EOL] pass [EOL] [EOL] [EOL] TEST_IMAGE = [string] [EOL] [EOL] [EOL] ExitCode = int [EOL] [EOL] [EOL] def _selftest ( ) : [EOL] [comment] [EOL] import markdown_svgbob . wrapper as wrp [EOL] [EOL] print ( [string] ) [EOL] print ( json . dumps ( wrp . parse_options ( ) , indent = [number] ) ) [EOL] print ( ) [EOL] [EOL] svg_data = wrp . text2svg ( TEST_IMAGE ) [EOL] if not svg_data : [EOL] return [number] [EOL] [EOL] with open ( [string] , mode = [string] ) as fobj : [EOL] fobj . write ( svg_data ) [EOL] [EOL] print ( [string] ) [EOL] return [number] [EOL] [EOL] [EOL] def main ( args = sys . argv [ [number] : ] ) : [EOL] [docstring] [EOL] [comment] [EOL] if [string] in args : [EOL] return _selftest ( ) [EOL] [EOL] if [string] in args or [string] in args : [EOL] version = markdown_svgbob . __version__ [EOL] print ( [string] , version ) [EOL] [EOL] binpath = markdown_svgbob . get_bin_path ( ) [EOL] return sp . check_call ( [ str ( binpath ) ] + list ( args ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ExitCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $ExitCode$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] from typing import Optional , Any , Match , List , Set , Dict [EOL] import typing [EOL] from __future__ import division [EOL] from __future__ import print_function [EOL] from __future__ import absolute_import [EOL] from __future__ import unicode_literals [EOL] [EOL] import re [EOL] import textwrap [EOL] [EOL] import markdown as md [EOL] [EOL] import markdown_svgbob [EOL] import markdown_svgbob . wrapper as wrp [EOL] import markdown_svgbob . extension as ext [EOL] [EOL] BASIC_FIG_TXT = [string] . strip ( [string] ) [EOL] [EOL] [EOL] BASIC_BLOCK_TXT = [string] + BASIC_FIG_TXT + [string] [EOL] [EOL] [EOL] OPTIONS_BLOCK_TXT = [string] + BASIC_FIG_TXT + [string] [EOL] [EOL] [EOL] DEFAULT_MKDOCS_EXTENSIONS = [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] EXTENDED_BLOCK_TXT = [string] [EOL] [EOL] EXTENDED_BLOCK_TXT = EXTENDED_BLOCK_TXT . format ( BASIC_FIG_TXT ) [EOL] [EOL] [EOL] EXTENDED_HTML_TEMPLATE = [string] [EOL] [EOL] [EOL] HTMLTEST_TXT = [string] [EOL] [EOL] HTMLTEST_TXT = HTMLTEST_TXT . replace ( [string] , BASIC_FIG_TXT ) [EOL] [EOL] [EOL] def test_regexp ( ) : [EOL] assert ext . BLOCK_RE . match ( BASIC_BLOCK_TXT ) [EOL] alt_block_text = BASIC_BLOCK_TXT . replace ( [string] , [string] ) [EOL] assert ext . BLOCK_RE . match ( alt_block_text ) [EOL] [EOL] [EOL] def test_determinism_svg ( ) : [EOL] fig_data1 = markdown_svgbob . text2svg ( BASIC_FIG_TXT ) [EOL] fig_data2 = markdown_svgbob . text2svg ( BASIC_FIG_TXT ) [EOL] assert fig_data1 == fig_data2 [EOL] [EOL] [EOL] def test_basic_svg ( ) : [EOL] fig_data = markdown_svgbob . text2svg ( BASIC_FIG_TXT ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] assert [string] in fig_data [EOL] assert [string] in fig_data [EOL] [EOL] inline_svg = ext . draw_bob ( BASIC_BLOCK_TXT , default_options = { [string] : [string] } ) [EOL] default_output = ext . draw_bob ( BASIC_BLOCK_TXT ) [EOL] assert inline_svg == default_output [EOL] assert inline_svg [EOL] assert inline_svg . startswith ( [string] ) [EOL] expected = [string] . format ( inline_svg ) [EOL] [EOL] assert [string] in inline_svg [EOL] [EOL] result = md . markdown ( BASIC_BLOCK_TXT , extensions = [ [string] ] ) [EOL] [EOL] assert inline_svg in result [EOL] [EOL] assert result == expected [EOL] [EOL] [EOL] def test_trailing_whitespace ( ) : [EOL] default_output = ext . draw_bob ( BASIC_BLOCK_TXT ) [EOL] [EOL] trailing_space_result = md . markdown ( BASIC_BLOCK_TXT + [string] , extensions = [ [string] ] ) [EOL] assert default_output in trailing_space_result [EOL] assert [string] not in trailing_space_result [EOL] [EOL] [EOL] def test_encoding ( ) : [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , default_options = { [string] : [string] } ) [EOL] assert [string] in html_tag [EOL] assert [string] in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] not in html_tag [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , default_options = { [string] : [string] } ) [EOL] assert [string] not in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] in html_tag [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , default_options = { [string] : [string] } ) [EOL] assert [string] in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] in html_tag [EOL] assert [string] not in html_tag [EOL] assert [string] in html_tag [EOL] assert [string] in html_tag [EOL] [EOL] [EOL] def test_svgbob_options ( ) : [EOL] fig_data_default = markdown_svgbob . text2svg ( BASIC_FIG_TXT ) [EOL] assert [string] in fig_data_default [EOL] assert [string] not in fig_data_default [EOL] [EOL] options = { [string] : [number] } [EOL] fig_data = markdown_svgbob . text2svg ( BASIC_FIG_TXT , options ) [EOL] assert [string] not in fig_data [EOL] assert [string] in fig_data [EOL] [EOL] assert [string] in fig_data [EOL] assert [string] in fig_data [EOL] [EOL] result = md . markdown ( OPTIONS_BLOCK_TXT , extensions = [ [string] ] ) [EOL] [EOL] html_tag = ext . draw_bob ( OPTIONS_BLOCK_TXT ) [EOL] expected = [string] . format ( html_tag ) [EOL] [EOL] assert result == expected [EOL] [EOL] [EOL] def test_svgbob_config ( ) : [EOL] result = md . markdown ( BASIC_BLOCK_TXT , extensions = [ [string] ] , extension_configs = { [string] : { [string] : [number] } } , ) [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT ) [EOL] unexpected = [string] . format ( html_tag ) [EOL] assert result != unexpected [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , { [string] : [number] } ) [EOL] expected = [string] . format ( html_tag ) [EOL] [EOL] assert result == expected [EOL] [EOL] [EOL] def test_extended_svgbob ( ) : [EOL] extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] [EOL] result = md . markdown ( EXTENDED_BLOCK_TXT , extensions = extensions ) [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT ) [EOL] expected = EXTENDED_HTML_TEMPLATE . format ( html_tag ) [EOL] expected = expected . replace ( [string] , [string] ) [EOL] result = result . replace ( [string] , [string] ) [EOL] [EOL] assert result == expected [EOL] [EOL] [EOL] def test_options_parsing ( ) : [EOL] default_options = wrp . _parse_options_help_text ( wrp . DEFAULT_HELP_TEXT ) [EOL] [EOL] expected_option_keys = { [string] , [string] , [string] , [string] } [EOL] assert set ( default_options . keys ( ) ) == expected_option_keys [EOL] [EOL] cmd_help_text = wrp . _get_cmd_help_text ( ) [EOL] cmd_options = wrp . _parse_options_help_text ( cmd_help_text ) [EOL] [EOL] assert set ( cmd_options . keys ( ) ) >= expected_option_keys [EOL] [EOL] options = wrp . parse_options ( ) [EOL] assert set ( options . keys ( ) ) >= expected_option_keys [EOL] [EOL] assert [string] not in options [EOL] [EOL] [EOL] def test_postproc ( ) : [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , { [string] : [string] } ) [EOL] assert [string] in html_tag [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT ) [EOL] [EOL] assert [string] in html_tag [EOL] assert re . search ( [string] , html_tag ) [EOL] [comment] [EOL] [comment] [EOL] backdrop_rect = re . search ( [string] , html_tag ) or ( re . search ( [string] , html_tag ) [EOL] and re . search ( [string] , html_tag ) ) [EOL] assert backdrop_rect [EOL] assert re . search ( [string] , html_tag ) [EOL] [EOL] html_tag = ext . draw_bob ( BASIC_BLOCK_TXT , { [string] : [string] , [string] : [string] } ) [EOL] [EOL] assert [string] in html_tag [EOL] assert re . search ( [string] , html_tag ) [EOL] backdrop_rect = re . search ( [string] , html_tag ) or ( re . search ( [string] , html_tag ) [EOL] and re . search ( [string] , html_tag ) ) [EOL] assert backdrop_rect [EOL] assert re . search ( [string] , html_tag ) [EOL] [EOL] [EOL] def test_bin_paths ( ) : [EOL] assert wrp . _get_pkg_bin_path ( ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] assert wrp . _get_pkg_bin_path ( machine = [string] , osname = [string] ) . exists ( ) [EOL] [EOL] [EOL] def test_html_output ( ) : [EOL] [comment] [EOL] [comment] [EOL] extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] [EOL] result = md . markdown ( HTMLTEST_TXT , extensions = extensions , extension_configs = { [string] : { [string] : [string] } } , ) [EOL] with open ( [string] , mode = [string] ) as fobj : [EOL] fobj . write ( result ) [EOL] [EOL] [EOL] def test_ignore_non_bob_blocks ( ) : [EOL] md_text = textwrap . dedent ( [string] ) [EOL] result_a = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS + [ [string] ] , ) [EOL] result_b = md . markdown ( md_text , extensions = DEFAULT_MKDOCS_EXTENSIONS , ) [EOL] assert [string] not in result_a [EOL] assert [string] not in result_b [EOL] [EOL] assert result_a == result_b [EOL] assert [string] in result_a [EOL] assert [string] in result_a [EOL] assert [string] in result_a [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [comment] [EOL] import sys [EOL] [EOL] data = open ( sys . argv [ [number] ] ) . read ( [number] ) [EOL] has_data = len ( data ) > [number] [EOL] [EOL] sys . exit ( has_data ) [EOL]	0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0