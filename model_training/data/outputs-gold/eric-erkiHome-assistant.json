[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import os [comment] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import homeassistant . scripts . check_config as check_config [EOL] from homeassistant . config import YAML_CONFIG_FILE [EOL] from tests . common import patch_yaml_files , get_test_config_dir [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] BASE_CONFIG = ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] BAD_CORE_CONFIG = ( [string] [string] [string] ) [EOL] [EOL] [EOL] def normalize_yaml_files ( check_dict ) : [EOL] [docstring] [EOL] root = get_test_config_dir ( ) [EOL] return [ key . replace ( root , [string] ) for key in sorted ( check_dict [ [string] ] . keys ( ) ) ] [EOL] [EOL] [EOL] [comment] [EOL] class TestCheckConfig ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] asyncio . get_event_loop ( ) [EOL] except RuntimeError : [EOL] asyncio . set_event_loop ( asyncio . new_event_loop ( ) ) [EOL] [EOL] [comment] [EOL] self . maxDiff = None [comment] [EOL] [EOL] [comment] [EOL] @ patch ( [string] , return_value = True ) def test_bad_core_config ( self , isfile_patch ) : [EOL] [docstring] [EOL] files = { YAML_CONFIG_FILE : BAD_CORE_CONFIG , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] [ [string] ] [ [number] ] == { [string] : [string] } [EOL] [EOL] @ patch ( [string] , return_value = True ) def test_config_platform_valid ( self , isfile_patch ) : [EOL] [docstring] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + [string] , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] , [string] } [EOL] assert res [ [string] ] [ [string] ] == [ { [string] : [string] } ] [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] @ patch ( [string] , return_value = True ) def test_config_component_platform_fail_validation ( self , isfile_patch ) : [EOL] [docstring] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + [string] , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] [ [string] ] [ [number] ] == { [string] : { [string] : [string] } } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] files = { YAML_CONFIG_FILE : ( BASE_CONFIG + [string] [string] ) , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] , [string] , [string] } [EOL] assert res [ [string] ] [ [string] ] == [ ] [EOL] assert res [ [string] ] [ [string] ] == { [string] : [number] , [string] : [number] , [string] : [string] , [string] : False , [string] : [string] , [string] : [string] , } [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] [ [string] ] [ [number] ] == { [string] : [string] } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] @ patch ( [string] , return_value = True ) def test_component_platform_not_found ( self , isfile_patch ) : [EOL] [docstring] [EOL] [comment] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + [string] , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] == { check_config . ERROR_STR : [ [string] ] } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + [string] , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] assert res [ [string] ] . keys ( ) == { [string] , [string] } [EOL] assert res [ [string] ] [ [string] ] == [ ] [EOL] assert res [ [string] ] == { check_config . ERROR_STR : [ [string] , ] } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] @ patch ( [string] , return_value = True ) def test_secrets ( self , isfile_patch ) : [EOL] [docstring] [EOL] secrets_path = get_test_config_dir ( [string] ) [EOL] [EOL] files = { get_test_config_dir ( YAML_CONFIG_FILE ) : BASE_CONFIG + ( [string] [string] ) , secrets_path : ( [string] [string] ) , } [EOL] [EOL] with patch_yaml_files ( files ) : [EOL] [EOL] res = check_config . check ( get_test_config_dir ( ) , True ) [EOL] [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] . keys ( ) == { [string] , [string] } [EOL] assert res [ [string] ] [ [string] ] == { [string] : [string] , [string] : [ ] , [string] : True , [string] : - [number] , [string] : [string] , [string] : [number] , [string] : [ ] , [string] : [string] , } [EOL] assert res [ [string] ] == { secrets_path : { [string] : [string] } } [EOL] assert res [ [string] ] == { [string] : [string] } [EOL] assert normalize_yaml_files ( res ) == [ [string] , [string] ] [EOL] [EOL] @ patch ( [string] , return_value = True ) def test_package_invalid ( self , isfile_patch ) : [EOL] [docstring] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + ( [string] [string] [string] ) , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( ) ) [EOL] [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert res [ [string] ] [ [string] ] [ [number] ] == { [string] : [ [string] ] } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] assert res [ [string] ] . keys ( ) == { [string] } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert len ( res [ [string] ] ) == [number] [EOL] [EOL] def test_bootstrap_error ( self ) : [EOL] [docstring] [EOL] files = { YAML_CONFIG_FILE : BASE_CONFIG + [string] , } [EOL] with patch_yaml_files ( files ) : [EOL] res = check_config . check ( get_test_config_dir ( YAML_CONFIG_FILE ) ) [EOL] err = res [ [string] ] . pop ( check_config . ERROR_STR ) [EOL] assert len ( err ) == [number] [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [comment] [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL] assert res [ [string] ] == { } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,builtins.str]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Union , Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] import unittest [EOL] import logging [EOL] [EOL] from homeassistant . core import CoreState , State , Context [EOL] from homeassistant . setup import setup_component , async_setup_component [EOL] from homeassistant . components . input_boolean import ( DOMAIN , is_on , toggle , turn_off , turn_on , CONF_INITIAL ) [EOL] from homeassistant . const import ( STATE_ON , STATE_OFF , ATTR_ICON , ATTR_FRIENDLY_NAME ) [EOL] [EOL] from tests . common import ( get_test_home_assistant , mock_component , mock_restore_cache ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TestInputBoolean ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] [comment] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_config ( self ) : [EOL] [docstring] [EOL] invalid_configs = [ None , [number] , { } , { [string] : None } , ] [EOL] [EOL] for cfg in invalid_configs : [EOL] self . assertFalse ( setup_component ( self . hass , DOMAIN , { DOMAIN : cfg } ) ) [EOL] [EOL] def test_methods ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { [string] : None , } } ) ) [EOL] entity_id = [string] [EOL] [EOL] self . assertFalse ( is_on ( self . hass , entity_id ) ) [EOL] [EOL] turn_on ( self . hass , entity_id ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertTrue ( is_on ( self . hass , entity_id ) ) [EOL] [EOL] turn_off ( self . hass , entity_id ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertFalse ( is_on ( self . hass , entity_id ) ) [EOL] [EOL] toggle ( self . hass , entity_id ) [EOL] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . assertTrue ( is_on ( self . hass , entity_id ) ) [EOL] [EOL] def test_config_options ( self ) : [EOL] [docstring] [EOL] count_start = len ( self . hass . states . entity_ids ( ) ) [EOL] [EOL] _LOGGER . debug ( [string] , self . hass . states . entity_ids ( ) ) [EOL] [EOL] self . assertTrue ( setup_component ( self . hass , DOMAIN , { DOMAIN : { [string] : None , [string] : { [string] : [string] , [string] : [string] , [string] : True , } , } } ) ) [EOL] [EOL] _LOGGER . debug ( [string] , self . hass . states . entity_ids ( ) ) [EOL] [EOL] self . assertEqual ( count_start + [number] , len ( self . hass . states . entity_ids ( ) ) ) [EOL] [EOL] state_1 = self . hass . states . get ( [string] ) [EOL] state_2 = self . hass . states . get ( [string] ) [EOL] [EOL] self . assertIsNotNone ( state_1 ) [EOL] self . assertIsNotNone ( state_2 ) [EOL] [EOL] self . assertEqual ( STATE_OFF , state_1 . state ) [EOL] self . assertNotIn ( ATTR_ICON , state_1 . attributes ) [EOL] self . assertNotIn ( ATTR_FRIENDLY_NAME , state_1 . attributes ) [EOL] [EOL] self . assertEqual ( STATE_ON , state_2 . state ) [EOL] self . assertEqual ( [string] , state_2 . attributes . get ( ATTR_FRIENDLY_NAME ) ) [EOL] self . assertEqual ( [string] , state_2 . attributes . get ( ATTR_ICON ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_restore_state ( hass ) : [EOL] [docstring] [EOL] mock_restore_cache ( hass , ( State ( [string] , [string] ) , State ( [string] , [string] ) , State ( [string] , [string] ) , ) ) [EOL] [EOL] hass . state = CoreState . starting [EOL] mock_component ( hass , [string] ) [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : None , [string] : None , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_state_overrules_restore_state ( hass ) : [EOL] [docstring] [EOL] mock_restore_cache ( hass , ( State ( [string] , [string] ) , State ( [string] , [string] ) , ) ) [EOL] [EOL] hass . state = CoreState . starting [EOL] [EOL] yield from async_setup_component ( hass , DOMAIN , { DOMAIN : { [string] : { CONF_INITIAL : False } , [string] : { CONF_INITIAL : True } , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == [string] [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == [string] [EOL] [EOL] [EOL] async def test_input_boolean_context ( hass ) : [EOL] [docstring] [EOL] assert await async_setup_component ( hass , [string] , { [string] : { [string] : { CONF_INITIAL : True } , } } ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] await hass . services . async_call ( [string] , [string] , { [string] : state . entity_id , } , True , Context ( user_id = [string] ) ) [EOL] [EOL] state2 = hass . states . get ( [string] ) [EOL] assert state2 is not None [EOL] assert state . state != state2 . state [EOL] assert state2 . context . user_id == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[None,typing.Dict[typing.Any,typing.Any],typing.Dict[builtins.str,None],builtins.int]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from ipaddress import ip_address [EOL] [EOL] from aiohttp import web [EOL] [EOL] from homeassistant . components . http . const import KEY_REAL_IP [EOL] [EOL] [EOL] def mock_real_ip ( app ) : [EOL] [docstring] [EOL] ip_to_mock = None [EOL] [EOL] def set_ip_to_mock ( value ) : [EOL] nonlocal ip_to_mock [EOL] ip_to_mock = value [EOL] [EOL] @ web . middleware async def mock_real_ip ( request , handler ) : [EOL] [docstring] [EOL] nonlocal ip_to_mock [EOL] [EOL] request [ KEY_REAL_IP ] = ip_address ( ip_to_mock ) [EOL] [EOL] return ( await handler ( request ) ) [EOL] [EOL] async def real_ip_startup ( app ) : [EOL] [docstring] [EOL] app . middlewares . insert ( [number] , mock_real_ip ) [EOL] [EOL] app . on_startup . append ( real_ip_startup ) [EOL] [EOL] return set_ip_to_mock [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import tests [EOL] [docstring] [EOL] import json [EOL] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components . weather import ( ATTR_WEATHER_HUMIDITY , ATTR_WEATHER_PRESSURE , ATTR_WEATHER_TEMPERATURE , ATTR_WEATHER_WIND_BEARING , ATTR_WEATHER_WIND_SPEED ) [EOL] from homeassistant . util . unit_system import METRIC_SYSTEM [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import ( get_test_home_assistant , load_fixture , MockDependency ) [EOL] [EOL] [EOL] def _yql_queryMock ( yql ) : [comment] [EOL] [docstring] [EOL] return ( [string] [string] ) [EOL] [EOL] [EOL] def get_woeidMock ( lat , lon ) : [comment] [EOL] [docstring] [EOL] return [string] [EOL] [EOL] [EOL] class YahooWeatherMock ( ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , woeid , temp_unit ) : [EOL] [docstring] [EOL] self . woeid = woeid [EOL] self . temp_unit = temp_unit [EOL] self . _data = json . loads ( load_fixture ( [string] ) ) [EOL] [EOL] [comment] [EOL] def updateWeather ( self ) : [comment] [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def RawData ( self ) : [comment] [EOL] [docstring] [EOL] if self . woeid == [string] : [EOL] return json . loads ( [string] ) [EOL] return self . _data [EOL] [EOL] @ property def Now ( self ) : [comment] [EOL] [docstring] [EOL] if self . woeid == [string] : [EOL] raise ValueError [EOL] return self . _data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] @ property def Atmosphere ( self ) : [comment] [EOL] [docstring] [EOL] return self . _data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] @ property def Wind ( self ) : [comment] [EOL] [docstring] [EOL] return self . _data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] @ property def Forecast ( self ) : [comment] [EOL] [docstring] [EOL] if self . woeid == [string] : [EOL] raise ValueError [EOL] return self . _data [ [string] ] [ [string] ] [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] class TestWeather ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] def add_entities ( self , devices ) : [EOL] [docstring] [EOL] for device in devices : [EOL] device . update ( ) [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . hass . config . units = METRIC_SYSTEM [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = _yql_queryMock ) @ patch ( [string] , new = get_woeidMock ) @ patch ( [string] , new = YahooWeatherMock ) def test_setup ( self , mock_yahooweather ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] assert state . state == [string] [EOL] [EOL] data = state . attributes [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_TEMPERATURE ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_HUMIDITY ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_PRESSURE ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_WIND_SPEED ) , [number] ) [EOL] self . assertEqual ( data . get ( ATTR_WEATHER_WIND_BEARING ) , [number] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = _yql_queryMock ) @ patch ( [string] , new = get_woeidMock ) @ patch ( [string] , new = YahooWeatherMock ) def test_setup_no_data ( self , mock_yahooweather ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = _yql_queryMock ) @ patch ( [string] , new = get_woeidMock ) @ patch ( [string] , new = YahooWeatherMock ) def test_setup_bad_data ( self , mock_yahooweather ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is None [EOL] [EOL] @ MockDependency ( [string] ) @ patch ( [string] , new = _yql_queryMock ) @ patch ( [string] , new = get_woeidMock ) @ patch ( [string] , new = YahooWeatherMock ) def test_setup_condition_error ( self , mock_yahooweather ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import forecastio [EOL] import requests_mock [EOL] [EOL] from homeassistant . components import weather [EOL] from homeassistant . util . unit_system import METRIC_SYSTEM [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import load_fixture , get_test_home_assistant [EOL] [EOL] [EOL] class TestDarkSky ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . hass . config . units = METRIC_SYSTEM [EOL] self . lat = self . hass . config . latitude = [number] [EOL] self . lon = self . hass . config . longitude = - [number] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ requests_mock . Mocker ( ) @ patch ( [string] , wraps = forecastio . api . get_forecast ) def test_setup ( self , mock_req , mock_get_forecast ) : [EOL] [docstring] [EOL] uri = ( [string] [string] ) [EOL] mock_req . get ( re . compile ( uri ) , text = load_fixture ( [string] ) ) [EOL] [EOL] self . assertTrue ( setup_component ( self . hass , weather . DOMAIN , { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } ) ) [EOL] [EOL] self . assertTrue ( mock_get_forecast . called ) [EOL] self . assertEqual ( mock_get_forecast . call_count , [number] ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( state . state , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Tuple , Union , Any , Dict [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] from unittest . mock import MagicMock [EOL] [EOL] import asynctest [EOL] [EOL] from homeassistant . components import light [EOL] from homeassistant . components . light import group [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] [EOL] async def test_default_state ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ ] , [string] : [string] } } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] [EOL] [EOL] async def test_state_reporting ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] hass . states . async_set ( [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] hass . states . async_set ( [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] hass . states . async_set ( [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] ) [EOL] hass . states . async_set ( [string] , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] [EOL] async def test_brightness ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] [EOL] async def test_color ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : ( [number] , [number] ) , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == ( [number] , [number] ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : ( [number] , [number] ) , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == ( [number] , [number] ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : ( [number] , [number] ) , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == ( [number] , [number] ) [EOL] [EOL] [EOL] async def test_white_value ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] [EOL] async def test_color_temp ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] [EOL] async def test_min_max_mireds ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] , [string] : [number] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] [EOL] async def test_effect_list ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [ [string] , [string] , [string] ] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert set ( state . attributes [ [string] ] ) == { [string] , [string] , [string] } [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [ [string] , [string] , [string] ] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert set ( state . attributes [ [string] ] ) == { [string] , [string] , [string] , [string] } [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [ [string] , [string] , [string] ] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert set ( state . attributes [ [string] ] ) == { [string] , [string] , [string] , [string] , [string] } [EOL] [EOL] [EOL] async def test_effect ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [string] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [string] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [string] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [string] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [string] , [string] : [number] } ) [EOL] hass . states . async_set ( [string] , [string] , { [string] : [string] , [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_supported_features ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } ) [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] hass . states . async_set ( [string] , [string] , { [string] : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( [string] ) [EOL] assert state . attributes [ [string] ] == [number] [EOL] [EOL] [EOL] async def test_service_calls ( hass ) : [EOL] [docstring] [EOL] await async_setup_component ( hass , [string] , { [string] : [ { [string] : [string] } , { [string] : [string] , [string] : [ [string] , [string] , [string] ] } ] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] light . async_toggle ( hass , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] light . async_turn_on ( hass , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] light . async_turn_off ( hass , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] light . async_turn_on ( hass , [string] , brightness = [number] , effect = [string] , rgb_color = ( [number] , [number] , [number] ) ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == ( [number] , [number] , [number] ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == ( [number] , [number] , [number] ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state . state == [string] [EOL] assert state . attributes [ [string] ] == [number] [EOL] assert state . attributes [ [string] ] == [string] [EOL] assert state . attributes [ [string] ] == ( [number] , [number] , [number] ) [EOL] [EOL] [EOL] async def test_invalid_service_calls ( hass ) : [EOL] [docstring] [EOL] add_entities = MagicMock ( ) [EOL] await group . async_setup_platform ( hass , { [string] : [ [string] , [string] ] } , add_entities ) [EOL] [EOL] assert add_entities . call_count == [number] [EOL] grouped_light = add_entities . call_args [ [number] ] [ [number] ] [ [number] ] [EOL] grouped_light . hass = hass [EOL] [EOL] with asynctest . patch . object ( hass . services , [string] ) as mock_call : [EOL] await grouped_light . async_turn_on ( brightness = [number] , four_oh_four = [string] ) [EOL] data = { [string] : [ [string] , [string] ] , [string] : [number] } [EOL] mock_call . assert_called_once_with ( [string] , [string] , data , blocking = True ) [EOL] mock_call . reset_mock ( ) [EOL] [EOL] await grouped_light . async_turn_off ( transition = [number] , four_oh_four = [string] ) [EOL] data = { [string] : [ [string] , [string] ] , [string] : [number] } [EOL] mock_call . assert_called_once_with ( [string] , [string] , data , blocking = True ) [EOL] mock_call . reset_mock ( ) [EOL] [EOL] data = { [string] : [number] , [string] : ( [number] , [number] ) , [string] : ( [number] , [number] , [number] ) , [string] : [number] , [string] : [number] , [string] : [string] , [string] : [number] , [string] : [string] } [EOL] await grouped_light . async_turn_on ( ** data ) [EOL] data [ [string] ] = [ [string] , [string] ] [EOL] data . pop ( [string] ) [EOL] data . pop ( [string] ) [EOL] mock_call . assert_called_once_with ( [string] , [string] , data , blocking = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] [EOL] from homeassistant . components . zone import config_flow [EOL] from homeassistant . components . zone . const import CONF_PASSIVE , DOMAIN , HOME_ZONE [EOL] from homeassistant . const import ( CONF_NAME , CONF_LATITUDE , CONF_LONGITUDE , CONF_ICON , CONF_RADIUS ) [EOL] [EOL] from tests . common import MockConfigEntry [EOL] [EOL] [EOL] async def test_flow_works ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . ZoneFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( user_input = { CONF_NAME : [string] , CONF_LATITUDE : [string] , CONF_LONGITUDE : [string] , CONF_RADIUS : [string] , CONF_ICON : [string] , CONF_PASSIVE : True } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { CONF_NAME : [string] , CONF_LATITUDE : [string] , CONF_LONGITUDE : [string] , CONF_RADIUS : [string] , CONF_ICON : [string] , CONF_PASSIVE : True } [EOL] [EOL] [EOL] async def test_flow_requires_unique_name ( hass ) : [EOL] [docstring] [EOL] MockConfigEntry ( domain = DOMAIN , data = { CONF_NAME : [string] } ) . add_to_hass ( hass ) [EOL] flow = config_flow . ZoneFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( user_input = { CONF_NAME : [string] } ) [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_flow_requires_name_different_from_home ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . ZoneFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( user_input = { CONF_NAME : HOME_ZONE } ) [EOL] assert result [ [string] ] == { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Union , Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] [EOL] from . . test_rflink import mock_rflink [EOL] from homeassistant . components . rflink import ( CONF_RECONNECT_INTERVAL ) [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG = { [string] : { [string] : [string] , [string] : [ [string] , [string] ] , } , DOMAIN : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , } , } , } , } [EOL] [EOL] [EOL] @ asyncio . coroutine def test_default_setup ( hass , monkeypatch ) : [EOL] [docstring] [EOL] [comment] [EOL] event_callback , create , _ , disconnect_callback = yield from mock_rflink ( hass , CONFIG , DOMAIN , monkeypatch ) [EOL] [EOL] [comment] [EOL] assert create . call_args_list [ [number] ] [ [number] ] [ [string] ] [EOL] [EOL] [comment] [EOL] config_sensor = hass . states . get ( [string] ) [EOL] assert config_sensor [EOL] assert config_sensor . state == [string] [EOL] assert config_sensor . attributes [ [string] ] == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] new_sensor = hass . states . get ( [string] ) [EOL] assert new_sensor [EOL] assert new_sensor . state == [string] [EOL] assert new_sensor . attributes [ [string] ] == [string] [EOL] assert new_sensor . attributes [ [string] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_disable_automatic_add ( hass , monkeypatch ) : [EOL] [docstring] [EOL] config = { [string] : { [string] : [string] , } , DOMAIN : { [string] : [string] , [string] : False , } , } [EOL] [EOL] [comment] [EOL] event_callback , _ , _ , _ = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch ) [EOL] [EOL] [comment] [EOL] event_callback ( { [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert not hass . states . get ( [string] ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_entity_availability ( hass , monkeypatch ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] config = CONFIG [EOL] failures = [ True , True ] [EOL] config [ CONF_RECONNECT_INTERVAL ] = [number] [EOL] [EOL] [comment] [EOL] event_callback , create , _ , disconnect_callback = yield from mock_rflink ( hass , config , DOMAIN , monkeypatch , failures = failures ) [EOL] [EOL] [comment] [EOL] assert hass . states . get ( [string] ) . state == STATE_UNKNOWN [EOL] [EOL] [comment] [EOL] disconnect_callback ( ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert hass . states . get ( [string] ) . state == [string] [EOL] [EOL] [comment] [EOL] disconnect_callback ( ) [EOL] [EOL] [comment] [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert hass . states . get ( [string] ) . state == STATE_UNKNOWN [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import Mock , patch [EOL] import json [EOL] [EOL] from asynctest import mock [EOL] [EOL] from homeassistant . components . climate import ( melissa , SUPPORT_TARGET_TEMPERATURE , SUPPORT_OPERATION_MODE , SUPPORT_ON_OFF , SUPPORT_FAN_MODE , STATE_HEAT , STATE_FAN_ONLY , STATE_DRY , STATE_COOL , STATE_AUTO ) [EOL] from homeassistant . components . fan import SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH [EOL] from homeassistant . components . melissa import DATA_MELISSA [EOL] from homeassistant . const import ( TEMP_CELSIUS , STATE_ON , ATTR_TEMPERATURE , STATE_OFF , STATE_IDLE ) [EOL] from tests . common import get_test_home_assistant , load_fixture [EOL] [EOL] [EOL] class TestMelissa ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [comment] [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . _serial = [string] [EOL] [EOL] self . api = Mock ( ) [EOL] self . api . fetch_devices . return_value = json . loads ( load_fixture ( [string] ) ) [EOL] self . api . cur_settings . return_value = json . loads ( load_fixture ( [string] ) ) [EOL] self . api . status . return_value = json . loads ( load_fixture ( [string] ) ) [EOL] self . api . STATE_OFF = [number] [EOL] self . api . STATE_ON = [number] [EOL] self . api . STATE_IDLE = [number] [EOL] [EOL] self . api . MODE_AUTO = [number] [EOL] self . api . MODE_FAN = [number] [EOL] self . api . MODE_HEAT = [number] [EOL] self . api . MODE_COOL = [number] [EOL] self . api . MODE_DRY = [number] [EOL] [EOL] self . api . FAN_AUTO = [number] [EOL] self . api . FAN_LOW = [number] [EOL] self . api . FAN_MEDIUM = [number] [EOL] self . api . FAN_HIGH = [number] [EOL] [EOL] self . api . STATE = [string] [EOL] self . api . MODE = [string] [EOL] self . api . FAN = [string] [EOL] self . api . TEMP = [string] [EOL] [EOL] device = self . api . fetch_devices ( ) [ self . _serial ] [EOL] self . thermostat = melissa . MelissaClimate ( self . api , device [ [string] ] , device ) [EOL] self . thermostat . update ( ) [EOL] [EOL] def tearDown ( self ) : [comment] [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ patch ( [string] ) def test_setup_platform ( self , mocked_thermostat ) : [EOL] [docstring] [EOL] device = self . api . fetch_devices ( ) [ self . _serial ] [EOL] thermostat = mocked_thermostat ( self . api , device [ [string] ] , device ) [EOL] thermostats = [ thermostat ] [EOL] [EOL] self . hass . data [ DATA_MELISSA ] = self . api [EOL] [EOL] config = { } [EOL] add_entities = Mock ( ) [EOL] discovery_info = { } [EOL] [EOL] melissa . setup_platform ( self . hass , config , add_entities , discovery_info ) [EOL] add_entities . assert_called_once_with ( thermostats ) [EOL] [EOL] def test_get_name ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [string] , self . thermostat . name ) [EOL] [EOL] def test_is_on ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( self . thermostat . is_on ) [EOL] self . thermostat . _cur_settings = None [EOL] self . assertFalse ( self . thermostat . is_on ) [EOL] [EOL] def test_current_fan_mode ( self ) : [EOL] [docstring] [EOL] self . thermostat . update ( ) [EOL] self . assertEqual ( SPEED_LOW , self . thermostat . current_fan_mode ) [EOL] self . thermostat . _cur_settings = None [EOL] self . assertEqual ( None , self . thermostat . current_fan_mode ) [EOL] [EOL] def test_current_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . current_temperature ) [EOL] [EOL] def test_current_temperature_no_data ( self ) : [EOL] [docstring] [EOL] self . thermostat . _data = None [EOL] self . assertIsNone ( self . thermostat . current_temperature ) [EOL] [EOL] def test_target_temperature_step ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . target_temperature_step ) [EOL] [EOL] def test_current_operation ( self ) : [EOL] [docstring] [EOL] self . thermostat . update ( ) [EOL] self . assertEqual ( self . thermostat . current_operation , STATE_HEAT ) [EOL] self . thermostat . _cur_settings = None [EOL] self . assertEqual ( None , self . thermostat . current_operation ) [EOL] [EOL] def test_operation_list ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [ STATE_COOL , STATE_DRY , STATE_FAN_ONLY , STATE_HEAT ] , self . thermostat . operation_list ) [EOL] [EOL] def test_fan_list ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [ STATE_AUTO , SPEED_HIGH , SPEED_LOW , SPEED_MEDIUM ] , self . thermostat . fan_list ) [EOL] [EOL] def test_target_temperature ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . target_temperature ) [EOL] self . thermostat . _cur_settings = None [EOL] self . assertEqual ( None , self . thermostat . target_temperature ) [EOL] [EOL] def test_state ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( STATE_ON , self . thermostat . state ) [EOL] self . thermostat . _cur_settings = None [EOL] self . assertEqual ( None , self . thermostat . state ) [EOL] [EOL] def test_temperature_unit ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( TEMP_CELSIUS , self . thermostat . temperature_unit ) [EOL] [EOL] def test_min_temp ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . min_temp ) [EOL] [EOL] def test_max_temp ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . max_temp ) [EOL] [EOL] def test_supported_features ( self ) : [EOL] [docstring] [EOL] features = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE | SUPPORT_ON_OFF | SUPPORT_FAN_MODE ) [EOL] self . assertEqual ( features , self . thermostat . supported_features ) [EOL] [EOL] def test_set_temperature ( self ) : [EOL] [docstring] [EOL] self . api . send . return_value = True [EOL] self . thermostat . update ( ) [EOL] self . thermostat . set_temperature ( ** { ATTR_TEMPERATURE : [number] } ) [EOL] self . assertEqual ( [number] , self . thermostat . target_temperature ) [EOL] [EOL] def test_fan_mode ( self ) : [EOL] [docstring] [EOL] self . api . send . return_value = True [EOL] self . thermostat . set_fan_mode ( SPEED_HIGH ) [EOL] self . assertEqual ( SPEED_HIGH , self . thermostat . current_fan_mode ) [EOL] [EOL] def test_set_operation_mode ( self ) : [EOL] [docstring] [EOL] self . api . send . return_value = True [EOL] self . thermostat . set_operation_mode ( STATE_COOL ) [EOL] self . assertEqual ( STATE_COOL , self . thermostat . current_operation ) [EOL] [EOL] def test_turn_on ( self ) : [EOL] [docstring] [EOL] self . thermostat . turn_on ( ) [EOL] self . assertTrue ( self . thermostat . state ) [EOL] [EOL] def test_turn_off ( self ) : [EOL] [docstring] [EOL] self . thermostat . turn_off ( ) [EOL] self . assertEqual ( STATE_OFF , self . thermostat . state ) [EOL] [EOL] def test_send ( self ) : [EOL] [docstring] [EOL] self . thermostat . update ( ) [EOL] self . assertTrue ( self . thermostat . send ( { [string] : self . api . FAN_MEDIUM } ) ) [EOL] self . assertEqual ( SPEED_MEDIUM , self . thermostat . current_fan_mode ) [EOL] self . api . send . return_value = False [EOL] self . thermostat . _cur_settings = None [EOL] self . assertFalse ( self . thermostat . send ( { [string] : self . api . FAN_LOW } ) ) [EOL] self . assertNotEqual ( SPEED_LOW , self . thermostat . current_fan_mode ) [EOL] self . assertIsNone ( self . thermostat . _cur_settings ) [EOL] [EOL] @ mock . patch ( [string] ) def test_update ( self , mocked_warning ) : [EOL] [docstring] [EOL] self . thermostat . update ( ) [EOL] self . assertEqual ( SPEED_LOW , self . thermostat . current_fan_mode ) [EOL] self . assertEqual ( STATE_HEAT , self . thermostat . current_operation ) [EOL] self . thermostat . _api . status . side_effect = KeyError ( [string] ) [EOL] self . thermostat . update ( ) [EOL] mocked_warning . assert_called_once_with ( [string] , self . thermostat . entity_id ) [EOL] [EOL] def test_melissa_state_to_hass ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( STATE_OFF , self . thermostat . melissa_state_to_hass ( [number] ) ) [EOL] self . assertEqual ( STATE_ON , self . thermostat . melissa_state_to_hass ( [number] ) ) [EOL] self . assertEqual ( STATE_IDLE , self . thermostat . melissa_state_to_hass ( [number] ) ) [EOL] self . assertEqual ( None , self . thermostat . melissa_state_to_hass ( [number] ) ) [EOL] [EOL] def test_melissa_op_to_hass ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( STATE_FAN_ONLY , self . thermostat . melissa_op_to_hass ( [number] ) ) [EOL] self . assertEqual ( STATE_HEAT , self . thermostat . melissa_op_to_hass ( [number] ) ) [EOL] self . assertEqual ( STATE_COOL , self . thermostat . melissa_op_to_hass ( [number] ) ) [EOL] self . assertEqual ( STATE_DRY , self . thermostat . melissa_op_to_hass ( [number] ) ) [EOL] self . assertEqual ( None , self . thermostat . melissa_op_to_hass ( [number] ) ) [EOL] [EOL] def test_melissa_fan_to_hass ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( STATE_AUTO , self . thermostat . melissa_fan_to_hass ( [number] ) ) [EOL] self . assertEqual ( SPEED_LOW , self . thermostat . melissa_fan_to_hass ( [number] ) ) [EOL] self . assertEqual ( SPEED_MEDIUM , self . thermostat . melissa_fan_to_hass ( [number] ) ) [EOL] self . assertEqual ( SPEED_HIGH , self . thermostat . melissa_fan_to_hass ( [number] ) ) [EOL] self . assertEqual ( None , self . thermostat . melissa_fan_to_hass ( [number] ) ) [EOL] [EOL] @ mock . patch ( [string] ) def test_hass_mode_to_melissa ( self , mocked_warning ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . hass_mode_to_melissa ( STATE_FAN_ONLY ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_mode_to_melissa ( STATE_HEAT ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_mode_to_melissa ( STATE_COOL ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_mode_to_melissa ( STATE_DRY ) ) [EOL] self . thermostat . hass_mode_to_melissa ( [string] ) [EOL] mocked_warning . assert_called_once_with ( [string] , [string] ) [EOL] [EOL] @ mock . patch ( [string] ) def test_hass_fan_to_melissa ( self , mocked_warning ) : [EOL] [docstring] [EOL] self . assertEqual ( [number] , self . thermostat . hass_fan_to_melissa ( STATE_AUTO ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_fan_to_melissa ( SPEED_LOW ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_fan_to_melissa ( SPEED_MEDIUM ) ) [EOL] self . assertEqual ( [number] , self . thermostat . hass_fan_to_melissa ( SPEED_HIGH ) ) [EOL] self . thermostat . hass_fan_to_melissa ( [string] ) [EOL] mocked_warning . assert_called_once_with ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $unittest.mock.Mock$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $unittest.mock.Mock$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $unittest.mock.Mock$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 $unittest.mock.Mock$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . components . spc import SpcRegistry [EOL] from homeassistant . components . binary_sensor import spc [EOL] from tests . common import async_test_home_assistant [EOL] [EOL] [EOL] @ pytest . fixture def hass ( loop ) : [EOL] [docstring] [EOL] hass = loop . run_until_complete ( async_test_home_assistant ( loop ) ) [EOL] hass . data [ [string] ] = SpcRegistry ( ) [EOL] yield hass [EOL] loop . run_until_complete ( hass . async_stop ( ) ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_setup_platform ( hass ) : [EOL] [docstring] [EOL] added_entities = [ ] [EOL] [EOL] zones = { [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } ] } [EOL] [EOL] def add_entities ( entities ) : [EOL] nonlocal added_entities [EOL] added_entities = list ( entities ) [EOL] [EOL] yield from spc . async_setup_platform ( hass = hass , config = { } , async_add_entities = add_entities , discovery_info = zones ) [EOL] [EOL] assert len ( added_entities ) == [number] [EOL] assert added_entities [ [number] ] . device_class == [string] [EOL] assert added_entities [ [number] ] . state == [string] [EOL] assert added_entities [ [number] ] . device_class == [string] [EOL] assert added_entities [ [number] ] . state == [string] [EOL] assert added_entities [ [number] ] . device_class == [string] [EOL] assert added_entities [ [number] ] . state == [string] [EOL] assert all ( d . hidden for d in added_entities ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import datetime [EOL] [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import sun [EOL] import homeassistant . components . automation as automation [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import ( fire_time_changed , get_test_home_assistant , mock_component ) [EOL] [EOL] [EOL] [comment] [EOL] class TestAutomationSun ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] mock_component ( self . hass , [string] ) [EOL] setup_component ( self . hass , sun . DOMAIN , { sun . DOMAIN : { sun . CONF_ELEVATION : [number] } } ) [EOL] [EOL] self . calls = [ ] [EOL] [EOL] @ callback def record_call ( service ) : [EOL] [docstring] [EOL] self . calls . append ( service ) [EOL] [EOL] self . hass . services . register ( [string] , [string] , record_call ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_sunset_trigger ( self ) : [EOL] [docstring] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] trigger_time = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] automation . turn_off ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] fire_time_changed ( self . hass , trigger_time ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] automation . turn_on ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] fire_time_changed ( self . hass , trigger_time ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_sunrise_trigger ( self ) : [EOL] [docstring] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] trigger_time = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] fire_time_changed ( self . hass , trigger_time ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_sunset_trigger_with_offset ( self ) : [EOL] [docstring] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] trigger_time = datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : { [string] : [string] % [string] . join ( ( [string] , [string] , [string] ) ) } , } } } ) [EOL] [EOL] fire_time_changed ( self . hass , trigger_time ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . assertEqual ( [string] , self . calls [ [number] ] . data [ [string] ] ) [EOL] [EOL] def test_sunrise_trigger_with_offset ( self ) : [EOL] [docstring] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] trigger_time = datetime ( [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] fire_time_changed ( self . hass , trigger_time ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action_before ( self ) : [EOL] [docstring] [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action_after ( self ) : [EOL] [docstring] [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } } } ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action_before_with_offset ( self ) : [EOL] [docstring] [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } } } ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action_after_with_offset ( self ) : [EOL] [docstring] [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } } } ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_if_action_before_and_after_during ( self ) : [EOL] [docstring] [EOL] setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } } } ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] now = datetime ( [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] with patch ( [string] , return_value = now ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . setup import async_setup_component [EOL] [EOL] from tests . common import ( async_mock_mqtt_component , async_fire_mqtt_message ) [EOL] [EOL] [EOL] @ asyncio . coroutine def test_run_camera_setup ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] topic = [string] [EOL] yield from async_mock_mqtt_component ( hass ) [EOL] yield from async_setup_component ( hass , [string] , { [string] : { [string] : [string] , [string] : topic , [string] : [string] , } } ) [EOL] [EOL] url = hass . states . get ( [string] ) . attributes [ [string] ] [EOL] [EOL] async_fire_mqtt_message ( hass , topic , [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] client = yield from aiohttp_client ( hass . http . app ) [EOL] resp = yield from client . get ( url ) [EOL] assert resp . status == [number] [EOL] body = yield from resp . text ( ) [EOL] assert body == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import urllib [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . helpers . discovery import load_platform [EOL] from homeassistant . helpers import config_validation as cv [EOL] from homeassistant . const import CONF_USERNAME , CONF_PASSWORD [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA_TADO = [string] [EOL] DOMAIN = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] TADO_COMPONENTS = [ [string] , [string] ] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] username = config [ DOMAIN ] [ CONF_USERNAME ] [EOL] password = config [ DOMAIN ] [ CONF_PASSWORD ] [EOL] [EOL] from PyTado . interface import Tado [EOL] [EOL] try : [EOL] tado = Tado ( username , password ) [EOL] tado . setDebugging ( True ) [EOL] except ( RuntimeError , urllib . error . HTTPError ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] hass . data [ DATA_TADO ] = TadoDataStore ( tado ) [EOL] [EOL] for component in TADO_COMPONENTS : [EOL] load_platform ( hass , component , DOMAIN , { } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class TadoDataStore : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , tado ) : [EOL] [docstring] [EOL] self . tado = tado [EOL] [EOL] self . sensors = { } [EOL] self . data = { } [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] for data_id , sensor in list ( self . sensors . items ( ) ) : [EOL] data = None [EOL] [EOL] try : [EOL] if [string] in sensor : [EOL] _LOGGER . info ( [string] , sensor [ [string] ] , sensor [ [string] ] ) [EOL] data = self . tado . getState ( sensor [ [string] ] ) [EOL] [EOL] if [string] in sensor : [EOL] _LOGGER . info ( [string] , sensor [ [string] ] , sensor [ [string] ] ) [EOL] data = self . tado . getDevices ( ) [ [number] ] [EOL] [EOL] except RuntimeError : [EOL] _LOGGER . error ( [string] , sensor [ [string] ] , sensor [ [string] ] ) [EOL] [EOL] self . data [ data_id ] = data [EOL] [EOL] def add_sensor ( self , data_id , sensor ) : [EOL] [docstring] [EOL] self . sensors [ data_id ] = sensor [EOL] self . data [ data_id ] = None [EOL] [EOL] def get_data ( self , data_id ) : [EOL] [docstring] [EOL] data = { [string] : [string] } [EOL] [EOL] if data_id in self . data : [EOL] data = self . data [ data_id ] [EOL] [EOL] return data [EOL] [EOL] def get_zones ( self ) : [EOL] [docstring] [EOL] return self . tado . getZones ( ) [EOL] [EOL] def get_capabilities ( self , tado_id ) : [EOL] [docstring] [EOL] return self . tado . getCapabilities ( tado_id ) [EOL] [EOL] def get_me ( self ) : [EOL] [docstring] [EOL] return self . tado . getMe ( ) [EOL] [EOL] def reset_zone_overlay ( self , zone_id ) : [EOL] [docstring] [EOL] self . tado . resetZoneOverlay ( zone_id ) [EOL] self . update ( no_throttle = True ) [comment] [EOL] [EOL] def set_zone_overlay ( self , zone_id , mode , temperature = None , duration = None ) : [EOL] [docstring] [EOL] self . tado . setZoneOverlay ( zone_id , mode , temperature , duration ) [EOL] self . update ( no_throttle = True ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import CONF_PLATFORM [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . helpers . event import track_point_in_utc_time [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_NUMBER = [string] [EOL] CONF_HELD_MORE_THAN = [string] [EOL] CONF_HELD_LESS_THAN = [string] [EOL] [EOL] TRIGGER_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : [string] , vol . Required ( CONF_NUMBER ) : cv . positive_int , vol . Optional ( CONF_HELD_MORE_THAN ) : vol . All ( cv . time_period , cv . positive_timedelta ) , vol . Optional ( CONF_HELD_LESS_THAN ) : vol . All ( cv . time_period , cv . positive_timedelta ) } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_trigger ( hass , config , action ) : [EOL] [docstring] [EOL] number = config . get ( CONF_NUMBER ) [EOL] held_more_than = config . get ( CONF_HELD_MORE_THAN ) [EOL] held_less_than = config . get ( CONF_HELD_LESS_THAN ) [EOL] pressed_time = None [EOL] cancel_pressed_more_than = None [EOL] [EOL] @ callback def call_action ( ) : [EOL] [docstring] [EOL] hass . async_run_job ( action , { [string] : { CONF_PLATFORM : [string] , CONF_NUMBER : number , CONF_HELD_MORE_THAN : held_more_than , CONF_HELD_LESS_THAN : held_less_than } , } ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] @ callback def pressed_more_than_satisfied ( now ) : [EOL] [docstring] [EOL] call_action ( ) [EOL] [EOL] def pressed ( ) : [EOL] [docstring] [EOL] nonlocal cancel_pressed_more_than , pressed_time [EOL] nonlocal held_less_than , held_more_than [EOL] pressed_time = dt_util . utcnow ( ) [EOL] if held_more_than is None and held_less_than is None : [EOL] hass . add_job ( call_action ) [EOL] if held_more_than is not None and held_less_than is None : [EOL] cancel_pressed_more_than = track_point_in_utc_time ( hass , pressed_more_than_satisfied , dt_util . utcnow ( ) + held_more_than ) [EOL] [EOL] def released ( ) : [EOL] [docstring] [EOL] nonlocal cancel_pressed_more_than , pressed_time [EOL] nonlocal held_less_than , held_more_than [EOL] [comment] [EOL] if cancel_pressed_more_than is not None : [EOL] cancel_pressed_more_than ( ) [EOL] cancel_pressed_more_than = None [EOL] held_time = dt_util . utcnow ( ) - pressed_time [EOL] if held_less_than is not None and held_time < held_less_than : [EOL] if held_more_than is None or held_time > held_more_than : [EOL] hass . add_job ( call_action ) [EOL] [EOL] hass . data [ [string] ] . on_switch_pressed ( number , pressed ) [EOL] hass . data [ [string] ] . on_switch_released ( number , released ) [EOL] [EOL] def async_remove ( ) : [EOL] [docstring] [EOL] return [EOL] [EOL] return async_remove [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_TRANSITION , Light , PLATFORM_SCHEMA , SUPPORT_BRIGHTNESS , SUPPORT_TRANSITION ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , EVENT_HOMEASSISTANT_STOP ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] [comment] [EOL] from decora_wifi import DecoraWiFiSession [EOL] from decora_wifi . models . person import Person [EOL] from decora_wifi . models . residential_account import ResidentialAccount [EOL] [EOL] email = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] session = DecoraWiFiSession ( ) [EOL] [EOL] try : [EOL] success = session . login ( email , password ) [EOL] [EOL] [comment] [EOL] if success is None : [EOL] msg = [string] [EOL] _LOGGER . error ( msg ) [EOL] hass . components . persistent_notification . create ( msg , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] [comment] [EOL] perms = session . user . get_residential_permissions ( ) [EOL] all_switches = [ ] [EOL] for permission in perms : [EOL] acct = ResidentialAccount ( session , permission . residentialAccountId ) [EOL] for residence in acct . get_residences ( ) : [EOL] for switch in residence . get_iot_switches ( ) : [EOL] all_switches . append ( switch ) [EOL] [EOL] add_entities ( DecoraWifiLight ( sw ) for sw in all_switches ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] [comment] [EOL] def logout ( event ) : [EOL] [docstring] [EOL] try : [EOL] if session is not None : [EOL] Person . logout ( session ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] hass . bus . listen ( EVENT_HOMEASSISTANT_STOP , logout ) [EOL] [EOL] [EOL] class DecoraWifiLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , switch ) : [EOL] [docstring] [EOL] self . _switch = switch [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . _switch . canSetLevel : [EOL] return SUPPORT_BRIGHTNESS | SUPPORT_TRANSITION [EOL] return [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _switch . name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return int ( self . _switch . brightness * [number] / [number] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _switch . power == [string] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] attribs = { [string] : [string] } [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] min_level = self . _switch . data . get ( [string] , [number] ) [EOL] max_level = self . _switch . data . get ( [string] , [number] ) [EOL] brightness = int ( kwargs [ ATTR_BRIGHTNESS ] * max_level / [number] ) [EOL] brightness = max ( brightness , min_level ) [EOL] attribs [ [string] ] = brightness [EOL] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition = int ( kwargs [ ATTR_TRANSITION ] ) [EOL] attribs [ [string] ] = attribs [ [string] ] = transition [EOL] [EOL] try : [EOL] self . _switch . update_attributes ( attribs ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] attribs = { [string] : [string] } [EOL] try : [EOL] self . _switch . update_attributes ( attribs ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _switch . refresh ( ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Callable , List , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from typing import Callable [EOL] [EOL] from homeassistant . components . light import ( Light , SUPPORT_BRIGHTNESS , DOMAIN ) [EOL] from homeassistant . components . isy994 import ISY994_NODES , ISYDevice [EOL] from homeassistant . helpers . typing import ConfigType [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for node in hass . data [ ISY994_NODES ] [ DOMAIN ] : [EOL] devices . append ( ISYLightDevice ( node ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class ISYLightDevice ( ISYDevice , Light ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . value > [number] [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . value [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . off ( ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] [comment] [EOL] def turn_on ( self , brightness = None , ** kwargs ) : [EOL] [docstring] [EOL] if not self . _node . on ( val = brightness ) : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Any [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME ) [EOL] from homeassistant . components . light import ( Light , ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_HS_COLOR , SUPPORT_BRIGHTNESS , SUPPORT_COLOR_TEMP , SUPPORT_COLOR , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . color import color_temperature_mired_to_kelvin as mired_to_kelvin [EOL] from homeassistant . util . color import ( color_temperature_kelvin_to_mired as kelvin_to_mired ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_CURRENT_POWER_W = [string] [EOL] ATTR_DAILY_ENERGY_KWH = [string] [EOL] ATTR_MONTHLY_ENERGY_KWH = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyHS100 import SmartBulb [EOL] host = config . get ( CONF_HOST ) [EOL] name = config . get ( CONF_NAME ) [EOL] add_entities ( [ TPLinkSmartBulb ( SmartBulb ( host ) , name ) ] , True ) [EOL] [EOL] [EOL] def brightness_to_percentage ( byt ) : [EOL] [docstring] [EOL] return int ( ( byt * [number] ) / [number] ) [EOL] [EOL] [EOL] def brightness_from_percentage ( percent ) : [EOL] [docstring] [EOL] return ( percent * [number] ) / [number] [EOL] [EOL] [EOL] class TPLinkSmartBulb ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , smartbulb , name ) : [EOL] [docstring] [EOL] self . smartbulb = smartbulb [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _available = True [EOL] self . _color_temp = None [EOL] self . _brightness = None [EOL] self . _hs = None [EOL] self . _supported_features = [number] [EOL] self . _min_mireds = None [EOL] self . _max_mireds = None [EOL] self . _emeter_params = { } [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _emeter_params [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartbulb . state = self . smartbulb . BULB_STATE_ON [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] self . smartbulb . color_temp = mired_to_kelvin ( kwargs [ ATTR_COLOR_TEMP ] ) [EOL] [EOL] brightness = brightness_to_percentage ( kwargs . get ( ATTR_BRIGHTNESS , self . brightness or [number] ) ) [EOL] if ATTR_HS_COLOR in kwargs : [EOL] hue , sat = kwargs . get ( ATTR_HS_COLOR ) [EOL] hsv = ( int ( hue ) , int ( sat ) , brightness ) [EOL] self . smartbulb . hsv = hsv [EOL] elif ATTR_BRIGHTNESS in kwargs : [EOL] self . smartbulb . brightness = brightness [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . smartbulb . state = self . smartbulb . BULB_STATE_OFF [EOL] [EOL] @ property def min_mireds ( self ) : [EOL] [docstring] [EOL] return self . _min_mireds [EOL] [EOL] @ property def max_mireds ( self ) : [EOL] [docstring] [EOL] return self . _max_mireds [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . _color_temp [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pyHS100 import SmartDeviceException [EOL] try : [EOL] if self . _supported_features == [number] : [EOL] self . get_features ( ) [EOL] [EOL] self . _state = ( self . smartbulb . state == self . smartbulb . BULB_STATE_ON ) [EOL] [EOL] [comment] [EOL] if self . _name == DEFAULT_NAME : [EOL] self . _name = self . smartbulb . alias [EOL] [EOL] if self . _supported_features & SUPPORT_BRIGHTNESS : [EOL] self . _brightness = brightness_from_percentage ( self . smartbulb . brightness ) [EOL] [EOL] if self . _supported_features & SUPPORT_COLOR_TEMP : [EOL] if ( self . smartbulb . color_temp is not None and self . smartbulb . color_temp != [number] ) : [EOL] self . _color_temp = kelvin_to_mired ( self . smartbulb . color_temp ) [EOL] [EOL] if self . _supported_features & SUPPORT_COLOR : [EOL] hue , sat , _ = self . smartbulb . hsv [EOL] self . _hs = ( hue , sat ) [EOL] [EOL] if self . smartbulb . has_emeter : [EOL] self . _emeter_params [ ATTR_CURRENT_POWER_W ] = [string] . format ( self . smartbulb . current_consumption ( ) ) [EOL] daily_statistics = self . smartbulb . get_emeter_daily ( ) [EOL] monthly_statistics = self . smartbulb . get_emeter_monthly ( ) [EOL] try : [EOL] self . _emeter_params [ ATTR_DAILY_ENERGY_KWH ] = [string] . format ( daily_statistics [ int ( time . strftime ( [string] ) ) ] ) [EOL] self . _emeter_params [ ATTR_MONTHLY_ENERGY_KWH ] = [string] . format ( monthly_statistics [ int ( time . strftime ( [string] ) ) ] ) [EOL] except KeyError : [EOL] [comment] [EOL] pass [EOL] [EOL] self . _available = True [EOL] [EOL] except ( SmartDeviceException , OSError ) as ex : [EOL] if self . _available : [EOL] _LOGGER . warning ( [string] , self . _name , ex ) [EOL] self . _available = False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return self . _supported_features [EOL] [EOL] def get_features ( self ) : [EOL] [docstring] [EOL] if self . smartbulb . is_dimmable : [EOL] self . _supported_features += SUPPORT_BRIGHTNESS [EOL] if self . smartbulb . is_variable_color_temp : [EOL] self . _supported_features += SUPPORT_COLOR_TEMP [EOL] self . _min_mireds = kelvin_to_mired ( self . smartbulb . valid_temperature_range [ [number] ] ) [EOL] self . _max_mireds = kelvin_to_mired ( self . smartbulb . valid_temperature_range [ [number] ] ) [EOL] if self . smartbulb . is_color : [EOL] self . _supported_features += SUPPORT_COLOR [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,typing.Any]$ 0 $typing.Tuple[builtins.int,builtins.int,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Any [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] import copy [EOL] [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . components . calendar import CalendarEventDevice , get_date [EOL] from homeassistant . components . google import CONF_DEVICE_ID , CONF_NAME [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] calendar_data_future = DemoGoogleCalendarDataFuture ( ) [EOL] calendar_data_current = DemoGoogleCalendarDataCurrent ( ) [EOL] add_entities ( [ DemoGoogleCalendar ( hass , calendar_data_future , { CONF_NAME : [string] , CONF_DEVICE_ID : [string] , } ) , DemoGoogleCalendar ( hass , calendar_data_current , { CONF_NAME : [string] , CONF_DEVICE_ID : [string] , } ) , ] ) [EOL] [EOL] [EOL] class DemoGoogleCalendarData : [EOL] [docstring] [EOL] [EOL] event = { } [EOL] [EOL] [comment] [EOL] def update ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] async def async_get_events ( self , hass , start_date , end_date ) : [EOL] [docstring] [EOL] event = copy . copy ( self . event ) [EOL] event [ [string] ] = event [ [string] ] [EOL] event [ [string] ] = get_date ( event [ [string] ] ) . isoformat ( ) [EOL] event [ [string] ] = get_date ( event [ [string] ] ) . isoformat ( ) [EOL] return [ event ] [EOL] [EOL] [EOL] class DemoGoogleCalendarDataFuture ( DemoGoogleCalendarData ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] one_hour_from_now = dt_util . now ( ) + dt_util . dt . timedelta ( minutes = [number] ) [EOL] self . event = { [string] : { [string] : one_hour_from_now . isoformat ( ) } , [string] : { [string] : ( one_hour_from_now + dt_util . dt . timedelta ( minutes = [number] ) ) . isoformat ( ) } , [string] : [string] , } [EOL] [EOL] [EOL] class DemoGoogleCalendarDataCurrent ( DemoGoogleCalendarData ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] middle_of_event = dt_util . now ( ) - dt_util . dt . timedelta ( minutes = [number] ) [EOL] self . event = { [string] : { [string] : middle_of_event . isoformat ( ) } , [string] : { [string] : ( middle_of_event + dt_util . dt . timedelta ( minutes = [number] ) ) . isoformat ( ) } , [string] : [string] , } [EOL] [EOL] [EOL] class DemoGoogleCalendar ( CalendarEventDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , calendar_data , data ) : [EOL] [docstring] [EOL] self . data = calendar_data [EOL] super ( ) . __init__ ( hass , data ) [EOL] [EOL] async def async_get_events ( self , hass , start_date , end_date ) : [EOL] [docstring] [EOL] return await self . data . async_get_events ( hass , start_date , end_date ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . envisalink import ( DATA_EVL , EnvisalinkDevice , PARTITION_SCHEMA , CONF_CODE , CONF_PANIC , CONF_PARTITIONNAME , SIGNAL_KEYPAD_UPDATE , SIGNAL_PARTITION_UPDATE ) [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_UNKNOWN , STATE_ALARM_TRIGGERED , STATE_ALARM_PENDING , ATTR_ENTITY_ID ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SERVICE_ALARM_KEYPRESS = [string] [EOL] ATTR_KEYPRESS = [string] [EOL] ALARM_KEYPRESS_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : cv . entity_ids , vol . Required ( ATTR_KEYPRESS ) : cv . string } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] configured_partitions = discovery_info [ [string] ] [EOL] code = discovery_info [ CONF_CODE ] [EOL] panic_type = discovery_info [ CONF_PANIC ] [EOL] [EOL] devices = [ ] [EOL] for part_num in configured_partitions : [EOL] device_config_data = PARTITION_SCHEMA ( configured_partitions [ part_num ] ) [EOL] device = EnvisalinkAlarm ( hass , part_num , device_config_data [ CONF_PARTITIONNAME ] , code , panic_type , hass . data [ DATA_EVL ] . alarm_state [ [string] ] [ part_num ] , hass . data [ DATA_EVL ] ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices ) [EOL] [EOL] @ callback def alarm_keypress_handler ( service ) : [EOL] [docstring] [EOL] entity_ids = service . data . get ( ATTR_ENTITY_ID ) [EOL] keypress = service . data . get ( ATTR_KEYPRESS ) [EOL] [EOL] target_devices = [ device for device in devices if device . entity_id in entity_ids ] [EOL] [EOL] for device in target_devices : [EOL] device . async_alarm_keypress ( keypress ) [EOL] [EOL] hass . services . async_register ( alarm . DOMAIN , SERVICE_ALARM_KEYPRESS , alarm_keypress_handler , schema = ALARM_KEYPRESS_SCHEMA ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class EnvisalinkAlarm ( EnvisalinkDevice , alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , partition_number , alarm_name , code , panic_type , info , controller ) : [EOL] [docstring] [EOL] self . _partition_number = partition_number [EOL] self . _code = code [EOL] self . _panic_type = panic_type [EOL] [EOL] _LOGGER . debug ( [string] , alarm_name ) [EOL] super ( ) . __init__ ( alarm_name , info , controller ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_KEYPAD_UPDATE , self . _update_callback ) [EOL] async_dispatcher_connect ( self . hass , SIGNAL_PARTITION_UPDATE , self . _update_callback ) [EOL] [EOL] @ callback def _update_callback ( self , partition ) : [EOL] [docstring] [EOL] if partition is None or int ( partition ) == self . _partition_number : [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] if self . _code : [EOL] return None [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] state = STATE_UNKNOWN [EOL] [EOL] if self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_TRIGGERED [EOL] elif self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_ARMED_AWAY [EOL] elif self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_ARMED_HOME [EOL] elif self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_PENDING [EOL] elif self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_PENDING [EOL] elif self . _info [ [string] ] [ [string] ] : [EOL] state = STATE_ALARM_DISARMED [EOL] return state [EOL] [EOL] @ asyncio . coroutine def async_alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_EVL ] . disarm_partition ( str ( code ) , self . _partition_number ) [EOL] else : [EOL] self . hass . data [ DATA_EVL ] . disarm_partition ( str ( self . _code ) , self . _partition_number ) [EOL] [EOL] @ asyncio . coroutine def async_alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_EVL ] . arm_stay_partition ( str ( code ) , self . _partition_number ) [EOL] else : [EOL] self . hass . data [ DATA_EVL ] . arm_stay_partition ( str ( self . _code ) , self . _partition_number ) [EOL] [EOL] @ asyncio . coroutine def async_alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_EVL ] . arm_away_partition ( str ( code ) , self . _partition_number ) [EOL] else : [EOL] self . hass . data [ DATA_EVL ] . arm_away_partition ( str ( self . _code ) , self . _partition_number ) [EOL] [EOL] @ asyncio . coroutine def async_alarm_trigger ( self , code = None ) : [EOL] [docstring] [EOL] self . hass . data [ DATA_EVL ] . panic_alarm ( self . _panic_type ) [EOL] [EOL] @ callback def async_alarm_keypress ( self , keypress = None ) : [EOL] [docstring] [EOL] if keypress : [EOL] self . hass . data [ DATA_EVL ] . keypresses_to_partition ( self . _partition_number , keypress ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] import datetime [EOL] from homeassistant . components . alarm_control_panel import manual [EOL] from homeassistant . const import ( STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_CUSTOM_BYPASS , STATE_ALARM_ARMED_HOME , STATE_ALARM_ARMED_NIGHT , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED , CONF_DELAY_TIME , CONF_PENDING_TIME , CONF_TRIGGER_TIME ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ manual . ManualAlarm ( hass , [string] , [string] , None , False , { STATE_ALARM_ARMED_AWAY : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_HOME : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_NIGHT : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_DISARMED : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_ARMED_CUSTOM_BYPASS : { CONF_DELAY_TIME : datetime . timedelta ( seconds = [number] ) , CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , CONF_TRIGGER_TIME : datetime . timedelta ( seconds = [number] ) , } , STATE_ALARM_TRIGGERED : { CONF_PENDING_TIME : datetime . timedelta ( seconds = [number] ) , } , } ) , ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] import requests [EOL] [docstring] [EOL] [EOL] import logging [EOL] import voluptuous as vol [EOL] import requests [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , MEDIA_TYPE_MUSIC , PLATFORM_SCHEMA , SUPPORT_PLAY , SUPPORT_PAUSE , SUPPORT_STOP , SUPPORT_PREVIOUS_TRACK , SUPPORT_NEXT_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_MUTE ) [EOL] from homeassistant . const import ( CONF_USERNAME , CONF_PASSWORD , STATE_OFF , STATE_IDLE , STATE_PLAYING , STATE_PAUSED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ICON = [string] [EOL] URL = [string] [EOL] [EOL] SUPPORT_UE_SMART_RADIO = SUPPORT_PLAY | SUPPORT_PAUSE | SUPPORT_STOP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE [EOL] [EOL] PLAYBACK_DICT = { [string] : STATE_PLAYING , [string] : STATE_PAUSED , [string] : STATE_IDLE } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] [EOL] def send_request ( payload , session ) : [EOL] [docstring] [EOL] try : [EOL] request = requests . post ( URL , cookies = { [string] : session } , json = payload , timeout = [number] ) [EOL] except requests . exceptions . Timeout : [EOL] _LOGGER . error ( [string] ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] else : [EOL] return request . json ( ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] email = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] session_request = requests . post ( [string] , data = { [string] : email , [string] : password } ) [EOL] session = session_request . cookies [ [string] ] [EOL] [EOL] player_request = send_request ( { [string] : [ [string] , [ [string] ] ] } , session ) [EOL] player_id = player_request [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] player_name = player_request [ [string] ] [ [string] ] [ [number] ] [ [string] ] [EOL] [EOL] add_entities ( [ UERadioDevice ( session , player_id , player_name ) ] ) [EOL] [EOL] [EOL] class UERadioDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , session , player_id , player_name ) : [EOL] [docstring] [EOL] self . _session = session [EOL] self . _player_id = player_id [EOL] self . _name = player_name [EOL] self . _state = None [EOL] self . _volume = [number] [EOL] self . _last_volume = [number] [EOL] self . _media_title = None [EOL] self . _media_artist = None [EOL] self . _media_artwork_url = None [EOL] [EOL] def send_command ( self , command ) : [EOL] [docstring] [EOL] send_request ( { [string] : [string] , [string] : [ self . _player_id , command ] } , self . _session ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] request = send_request ( { [string] : [string] , [string] : [ self . _player_id , [ [string] , [string] , [number] , [string] ] ] } , self . _session ) [EOL] [EOL] if request [ [string] ] is not None : [EOL] self . _state = None [EOL] return [EOL] [EOL] if request [ [string] ] [ [string] ] == [number] : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = PLAYBACK_DICT [ request [ [string] ] [ [string] ] ] [EOL] [EOL] media_info = request [ [string] ] [ [string] ] [ [number] ] [EOL] [EOL] self . _volume = request [ [string] ] [ [string] ] / [number] [EOL] self . _media_artwork_url = media_info [ [string] ] [EOL] self . _media_title = media_info [ [string] ] [EOL] if [string] in media_info : [EOL] self . _media_artist = media_info [ [string] ] [EOL] else : [EOL] self . _media_artist = media_info . get ( [string] ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return True if self . _volume <= [number] else False [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_UE_SMART_RADIO [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _media_artwork_url [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _media_artist [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _media_title [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [number] ] ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [number] ] ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_stop ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] ] ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] ] ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] ] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] if mute : [EOL] self . _last_volume = self . _volume [EOL] self . send_command ( [ [string] , [string] , [number] ] ) [EOL] else : [EOL] self . send_command ( [ [string] , [string] , self . _last_volume * [number] ] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . send_command ( [ [string] , [string] , volume * [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MEDIA_TYPE_TVSHOW , MEDIA_TYPE_MOVIE , MEDIA_TYPE_MUSIC , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_SEEK , SUPPORT_STOP , SUPPORT_PREVIOUS_TRACK , MediaPlayerDevice , SUPPORT_PLAY , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( STATE_IDLE , STATE_OFF , STATE_PAUSED , STATE_PLAYING , CONF_HOST , CONF_PORT , CONF_SSL , CONF_API_KEY , DEVICE_DEFAULT_NAME , EVENT_HOMEASSISTANT_START , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_AUTO_HIDE = [string] [EOL] [EOL] MEDIA_TYPE_TRAILER = [string] [EOL] MEDIA_TYPE_GENERIC_VIDEO = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_SSL_PORT = [number] [EOL] DEFAULT_SSL = False [EOL] DEFAULT_AUTO_HIDE = False [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_EMBY = SUPPORT_PAUSE | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_STOP | SUPPORT_SEEK | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_SSL , default = DEFAULT_SSL ) : cv . boolean , vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_PORT ) : cv . port , vol . Optional ( CONF_AUTO_HIDE , default = DEFAULT_AUTO_HIDE ) : cv . boolean , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyemby import EmbyServer [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] key = config . get ( CONF_API_KEY ) [EOL] port = config . get ( CONF_PORT ) [EOL] ssl = config . get ( CONF_SSL ) [EOL] auto_hide = config . get ( CONF_AUTO_HIDE ) [EOL] [EOL] if port is None : [EOL] port = DEFAULT_SSL_PORT if ssl else DEFAULT_PORT [EOL] [EOL] _LOGGER . debug ( [string] , host , port ) [EOL] [EOL] emby = EmbyServer ( host , key , port , ssl , hass . loop ) [EOL] [EOL] active_emby_devices = { } [EOL] inactive_emby_devices = { } [EOL] [EOL] @ callback def device_update_callback ( data ) : [EOL] [docstring] [EOL] new_devices = [ ] [EOL] active_devices = [ ] [EOL] for dev_id in emby . devices : [EOL] active_devices . append ( dev_id ) [EOL] if dev_id not in active_emby_devices and dev_id not in inactive_emby_devices : [EOL] new = EmbyDevice ( emby , dev_id ) [EOL] active_emby_devices [ dev_id ] = new [EOL] new_devices . append ( new ) [EOL] [EOL] elif dev_id in inactive_emby_devices : [EOL] if emby . devices [ dev_id ] . state != [string] : [EOL] add = inactive_emby_devices . pop ( dev_id ) [EOL] active_emby_devices [ dev_id ] = add [EOL] _LOGGER . debug ( [string] , dev_id , add ) [EOL] add . set_available ( True ) [EOL] add . set_hidden ( False ) [EOL] [EOL] if new_devices : [EOL] _LOGGER . debug ( [string] , new_devices ) [EOL] async_add_entities ( new_devices , update_before_add = True ) [EOL] [EOL] @ callback def device_removal_callback ( data ) : [EOL] [docstring] [EOL] if data in active_emby_devices : [EOL] rem = active_emby_devices . pop ( data ) [EOL] inactive_emby_devices [ data ] = rem [EOL] _LOGGER . debug ( [string] , data , rem ) [EOL] rem . set_available ( False ) [EOL] if auto_hide : [EOL] rem . set_hidden ( True ) [EOL] [EOL] @ callback def start_emby ( event ) : [EOL] [docstring] [EOL] emby . start ( ) [EOL] [EOL] @ asyncio . coroutine def stop_emby ( event ) : [EOL] [docstring] [EOL] yield from emby . stop ( ) [EOL] [EOL] emby . add_new_devices_callback ( device_update_callback ) [EOL] emby . add_stale_devices_callback ( device_removal_callback ) [EOL] [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , start_emby ) [EOL] hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_STOP , stop_emby ) [EOL] [EOL] [EOL] class EmbyDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , emby , device_id ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , device_id ) [EOL] self . emby = emby [EOL] self . device_id = device_id [EOL] self . device = self . emby . devices [ self . device_id ] [EOL] [EOL] self . _hidden = False [EOL] self . _available = True [EOL] [EOL] self . media_status_last_position = None [EOL] self . media_status_received = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . emby . add_update_callback ( self . async_update_callback , self . device_id ) [EOL] [EOL] @ callback def async_update_callback ( self , msg ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . device . media_position : [EOL] if self . device . media_position != self . media_status_last_position : [EOL] self . media_status_last_position = self . device . media_position [EOL] self . media_status_received = dt_util . utcnow ( ) [EOL] elif not self . device . is_nowplaying : [EOL] [comment] [EOL] self . media_status_last_position = None [EOL] self . media_status_received = None [EOL] [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def hidden ( self ) : [EOL] [docstring] [EOL] return self . _hidden [EOL] [EOL] def set_hidden ( self , value ) : [EOL] [docstring] [EOL] self . _hidden = value [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] def set_available ( self , value ) : [EOL] [docstring] [EOL] self . _available = value [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . device_id [EOL] [EOL] @ property def supports_remote_control ( self ) : [EOL] [docstring] [EOL] return self . device . supports_remote_control [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return ( [string] . format ( self . device . client , self . device . name ) or DEVICE_DEFAULT_NAME ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] state = self . device . state [EOL] if state == [string] : [EOL] return STATE_PAUSED [EOL] if state == [string] : [EOL] return STATE_PLAYING [EOL] if state == [string] : [EOL] return STATE_IDLE [EOL] if state == [string] : [EOL] return STATE_OFF [EOL] [EOL] @ property def app_name ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . device . username [EOL] [EOL] @ property def media_content_id ( self ) : [EOL] [docstring] [EOL] return self . device . media_id [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] media_type = self . device . media_type [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_TVSHOW [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_MOVIE [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_TRAILER [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_MUSIC [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_GENERIC_VIDEO [EOL] if media_type == [string] : [EOL] return MEDIA_TYPE_MUSIC [EOL] return None [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] return self . device . media_runtime [EOL] [EOL] @ property def media_position ( self ) : [EOL] [docstring] [EOL] return self . media_status_last_position [EOL] [EOL] @ property def media_position_updated_at ( self ) : [EOL] [docstring] [EOL] return self . media_status_received [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . device . media_image_url [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . device . media_title [EOL] [EOL] @ property def media_season ( self ) : [EOL] [docstring] [EOL] return self . device . media_season [EOL] [EOL] @ property def media_series_title ( self ) : [EOL] [docstring] [EOL] return self . device . media_series_title [EOL] [EOL] @ property def media_episode ( self ) : [EOL] [docstring] [EOL] return self . device . media_episode [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . device . media_album_name [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . device . media_artist [EOL] [EOL] @ property def media_album_artist ( self ) : [EOL] [docstring] [EOL] return self . device . media_album_artist [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] if self . supports_remote_control : [EOL] return SUPPORT_EMBY [EOL] return None [EOL] [EOL] def async_media_play ( self ) : [EOL] [docstring] [EOL] return self . device . media_play ( ) [EOL] [EOL] def async_media_pause ( self ) : [EOL] [docstring] [EOL] return self . device . media_pause ( ) [EOL] [EOL] def async_media_stop ( self ) : [EOL] [docstring] [EOL] return self . device . media_stop ( ) [EOL] [EOL] def async_media_next_track ( self ) : [EOL] [docstring] [EOL] return self . device . media_next ( ) [EOL] [EOL] def async_media_previous_track ( self ) : [EOL] [docstring] [EOL] return self . device . media_previous ( ) [EOL] [EOL] def async_media_seek ( self , position ) : [EOL] [docstring] [EOL] return self . device . media_seek ( position ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Any , Generator , List [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] import time [EOL] [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . remote import ( PLATFORM_SCHEMA , DOMAIN , ATTR_NUM_REPEATS , ATTR_DELAY_SECS , DEFAULT_DELAY_SECS , RemoteDevice ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_TOKEN , CONF_TIMEOUT , ATTR_ENTITY_ID , ATTR_HIDDEN , CONF_COMMAND ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . dt import utcnow [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SERVICE_LEARN = [string] [EOL] DATA_KEY = [string] [EOL] [EOL] CONF_SLOT = [string] [EOL] CONF_COMMANDS = [string] [EOL] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_SLOT = [number] [EOL] [EOL] LEARN_COMMAND_SCHEMA = vol . Schema ( { vol . Required ( ATTR_ENTITY_ID ) : vol . All ( str ) , vol . Optional ( CONF_TIMEOUT , default = [number] ) : vol . All ( int , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_SLOT , default = [number] ) : vol . All ( int , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] COMMAND_SCHEMA = vol . Schema ( { vol . Required ( CONF_COMMAND ) : vol . All ( cv . ensure_list , [ cv . string ] ) } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : vol . All ( int , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_SLOT , default = DEFAULT_SLOT ) : vol . All ( int , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( ATTR_HIDDEN , default = True ) : cv . boolean , vol . Required ( CONF_TOKEN ) : vol . All ( str , vol . Length ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_COMMANDS , default = { } ) : vol . Schema ( { cv . slug : COMMAND_SCHEMA } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from miio import ChuangmiIr , DeviceException [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] token = config . get ( CONF_TOKEN ) [EOL] [EOL] [comment] [EOL] _LOGGER . info ( [string] , host , token [ : [number] ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] device = ChuangmiIr ( host , token , lazy_discover = False ) [EOL] [EOL] [comment] [EOL] try : [EOL] device_info = device . info ( ) [EOL] model = device_info . model [EOL] unique_id = [string] . format ( model , device_info . mac_address ) [EOL] _LOGGER . info ( [string] , model , device_info . firmware_version , device_info . hardware_version ) [EOL] except DeviceException as ex : [EOL] _LOGGER . error ( [string] , ex ) [EOL] raise PlatformNotReady [EOL] [EOL] if DATA_KEY not in hass . data : [EOL] hass . data [ DATA_KEY ] = { } [EOL] [EOL] friendly_name = config . get ( CONF_NAME , [string] + host . replace ( [string] , [string] ) ) [EOL] slot = config . get ( CONF_SLOT ) [EOL] timeout = config . get ( CONF_TIMEOUT ) [EOL] [EOL] hidden = config . get ( ATTR_HIDDEN ) [EOL] [EOL] xiaomi_miio_remote = XiaomiMiioRemote ( friendly_name , device , unique_id , slot , timeout , hidden , config . get ( CONF_COMMANDS ) ) [EOL] [EOL] hass . data [ DATA_KEY ] [ host ] = xiaomi_miio_remote [EOL] [EOL] async_add_entities ( [ xiaomi_miio_remote ] ) [EOL] [EOL] @ asyncio . coroutine def async_service_handler ( service ) : [EOL] [docstring] [EOL] if service . service != SERVICE_LEARN : [EOL] _LOGGER . error ( [string] , service . service ) [EOL] return [EOL] [EOL] entity_id = service . data . get ( ATTR_ENTITY_ID ) [EOL] entity = None [EOL] for remote in hass . data [ DATA_KEY ] . values ( ) : [EOL] if remote . entity_id == entity_id : [EOL] entity = remote [EOL] [EOL] if not entity : [EOL] _LOGGER . error ( [string] , entity_id ) [EOL] return [EOL] [EOL] device = entity . device [EOL] [EOL] slot = service . data . get ( CONF_SLOT , entity . slot ) [EOL] [EOL] yield from hass . async_add_job ( device . learn , slot ) [EOL] [EOL] timeout = service . data . get ( CONF_TIMEOUT , entity . timeout ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] start_time = utcnow ( ) [EOL] while ( utcnow ( ) - start_time ) < timedelta ( seconds = timeout ) : [EOL] message = yield from hass . async_add_job ( device . read , slot ) [EOL] _LOGGER . debug ( [string] , message ) [EOL] [EOL] if [string] in message and message [ [string] ] : [EOL] log_msg = [string] . format ( message [ [string] ] ) [EOL] _LOGGER . info ( log_msg ) [EOL] hass . components . persistent_notification . async_create ( log_msg , title = [string] ) [EOL] return [EOL] [EOL] if ( [string] in message and message [ [string] ] [ [string] ] == [string] ) : [EOL] yield from hass . async_add_job ( device . learn , slot ) [EOL] [EOL] yield from asyncio . sleep ( [number] , loop = hass . loop ) [EOL] [EOL] _LOGGER . error ( [string] ) [EOL] hass . components . persistent_notification . async_create ( [string] , title = [string] ) [EOL] [EOL] hass . services . async_register ( DOMAIN , SERVICE_LEARN , async_service_handler , schema = LEARN_COMMAND_SCHEMA ) [EOL] [EOL] [EOL] class XiaomiMiioRemote ( RemoteDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , device , unique_id , slot , timeout , hidden , commands ) : [EOL] [docstring] [EOL] self . _name = friendly_name [EOL] self . _device = device [EOL] self . _unique_id = unique_id [EOL] self . _is_hidden = hidden [EOL] self . _slot = slot [EOL] self . _timeout = timeout [EOL] self . _state = False [EOL] self . _commands = commands [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device ( self ) : [EOL] [docstring] [EOL] return self . _device [EOL] [EOL] @ property def hidden ( self ) : [EOL] [docstring] [EOL] return self . _is_hidden [EOL] [EOL] @ property def slot ( self ) : [EOL] [docstring] [EOL] return self . _slot [EOL] [EOL] @ property def timeout ( self ) : [EOL] [docstring] [EOL] return self . _timeout [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] from miio import DeviceException [EOL] try : [EOL] self . device . info ( ) [EOL] return True [EOL] except DeviceException : [EOL] return False [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _is_hidden : [EOL] return { [string] : [string] } [EOL] return [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . error ( [string] [string] ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . error ( [string] [string] ) [EOL] [EOL] def _send_command ( self , payload ) : [EOL] [docstring] [EOL] from miio import DeviceException [EOL] [EOL] _LOGGER . debug ( [string] , payload ) [EOL] try : [EOL] self . device . play ( payload ) [EOL] except DeviceException as ex : [EOL] _LOGGER . error ( [string] , payload , ex ) [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] num_repeats = kwargs . get ( ATTR_NUM_REPEATS ) [EOL] [EOL] delay = kwargs . get ( ATTR_DELAY_SECS , DEFAULT_DELAY_SECS ) [EOL] [EOL] for _ in range ( num_repeats ) : [EOL] for payload in command : [EOL] if payload in self . _commands : [EOL] for local_payload in self . _commands [ payload ] [ CONF_COMMAND ] : [EOL] self . _send_command ( local_payload ) [EOL] else : [EOL] self . _send_command ( payload ) [EOL] time . sleep ( delay ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] [EOL] class IHCDevice ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ihc_controller , name , ihc_id , info , product = None ) : [EOL] [docstring] [EOL] self . ihc_controller = ihc_controller [EOL] self . _name = name [EOL] self . ihc_id = ihc_id [EOL] self . info = info [EOL] if product : [EOL] self . ihc_name = product [ [string] ] [EOL] self . ihc_note = product [ [string] ] [EOL] self . ihc_position = product [ [string] ] [EOL] else : [EOL] self . ihc_name = [string] [EOL] self . ihc_note = [string] [EOL] self . ihc_position = [string] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . ihc_controller . add_notify_event ( self . ihc_id , self . on_ihc_change , True ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if not self . info : [EOL] return { } [EOL] return { [string] : self . ihc_id , [string] : self . ihc_name , [string] : self . ihc_note , [string] : self . ihc_position } [EOL] [EOL] def on_ihc_change ( self , ihc_id , value ) : [EOL] [docstring] [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . climate import ( ClimateDevice , DOMAIN , SUPPORT_HOLD_MODE , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE , STATE_AUTO , STATE_HEAT , STATE_IDLE ) [EOL] from homeassistant . components . nuheat import DOMAIN as NUHEAT_DOMAIN [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_TEMPERATURE , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ICON = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [comment] [EOL] MODE_AUTO = STATE_AUTO [comment] [EOL] MODE_HOLD_TEMPERATURE = [string] [EOL] MODE_TEMPORARY_HOLD = [string] [EOL] [EOL] OPERATION_LIST = [ STATE_HEAT , STATE_IDLE ] [EOL] [EOL] SCHEDULE_HOLD = [number] [EOL] SCHEDULE_RUN = [number] [EOL] SCHEDULE_TEMPORARY_HOLD = [number] [EOL] [EOL] SERVICE_RESUME_PROGRAM = [string] [EOL] [EOL] RESUME_PROGRAM_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids } ) [EOL] [EOL] SUPPORT_FLAGS = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_HOLD_MODE | SUPPORT_OPERATION_MODE ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] temperature_unit = hass . config . units . temperature_unit [EOL] api , serial_numbers = hass . data [ NUHEAT_DOMAIN ] [EOL] thermostats = [ NuHeatThermostat ( api , serial_number , temperature_unit ) for serial_number in serial_numbers ] [EOL] add_entities ( thermostats , True ) [EOL] [EOL] def resume_program_set_service ( service ) : [EOL] [docstring] [EOL] entity_id = service . data . get ( ATTR_ENTITY_ID ) [EOL] if entity_id : [EOL] target_thermostats = [ device for device in thermostats if device . entity_id in entity_id ] [EOL] else : [EOL] target_thermostats = thermostats [EOL] [EOL] for thermostat in target_thermostats : [EOL] thermostat . resume_program ( ) [EOL] [EOL] thermostat . schedule_update_ha_state ( True ) [EOL] [EOL] hass . services . register ( DOMAIN , SERVICE_RESUME_PROGRAM , resume_program_set_service , schema = RESUME_PROGRAM_SCHEMA ) [EOL] [EOL] [EOL] class NuHeatThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , serial_number , temperature_unit ) : [EOL] [docstring] [EOL] self . _thermostat = api . get_thermostat ( serial_number ) [EOL] self . _temperature_unit = temperature_unit [EOL] self . _force_update = False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _thermostat . room [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return TEMP_CELSIUS [EOL] [EOL] return TEMP_FAHRENHEIT [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . celsius [EOL] [EOL] return self . _thermostat . fahrenheit [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if self . _thermostat . heating : [EOL] return STATE_HEAT [EOL] [EOL] return STATE_IDLE [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . min_celsius [EOL] [EOL] return self . _thermostat . min_fahrenheit [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . max_celsius [EOL] [EOL] return self . _thermostat . max_fahrenheit [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] if self . _temperature_unit == [string] : [EOL] return self . _thermostat . target_celsius [EOL] [EOL] return self . _thermostat . target_fahrenheit [EOL] [EOL] @ property def current_hold_mode ( self ) : [EOL] [docstring] [EOL] schedule_mode = self . _thermostat . schedule_mode [EOL] if schedule_mode == SCHEDULE_RUN : [EOL] return MODE_AUTO [EOL] [EOL] if schedule_mode == SCHEDULE_HOLD : [EOL] return MODE_HOLD_TEMPERATURE [EOL] [EOL] if schedule_mode == SCHEDULE_TEMPORARY_HOLD : [EOL] return MODE_TEMPORARY_HOLD [EOL] [EOL] return MODE_AUTO [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return OPERATION_LIST [EOL] [EOL] def resume_program ( self ) : [EOL] [docstring] [EOL] self . _thermostat . resume_schedule ( ) [EOL] self . _force_update = True [EOL] [EOL] def set_hold_mode ( self , hold_mode ) : [EOL] [docstring] [EOL] if hold_mode == MODE_AUTO : [EOL] schedule_mode = SCHEDULE_RUN [EOL] [EOL] if hold_mode == MODE_HOLD_TEMPERATURE : [EOL] schedule_mode = SCHEDULE_HOLD [EOL] [EOL] if hold_mode == MODE_TEMPORARY_HOLD : [EOL] schedule_mode = SCHEDULE_TEMPORARY_HOLD [EOL] [EOL] self . _thermostat . schedule_mode = schedule_mode [EOL] self . _force_update = True [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if self . _temperature_unit == [string] : [EOL] self . _thermostat . target_celsius = temperature [EOL] else : [EOL] self . _thermostat . target_fahrenheit = temperature [EOL] [EOL] _LOGGER . debug ( [string] , temperature , self . temperature_unit ) [EOL] [EOL] self . _force_update = True [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _force_update : [EOL] self . _throttled_update ( no_throttle = True ) [EOL] self . _force_update = False [EOL] else : [EOL] self . _throttled_update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def _throttled_update ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _thermostat . get_data ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . fritzbox import DOMAIN as FRITZBOX_DOMAIN [EOL] from homeassistant . components . fritzbox import ( ATTR_STATE_DEVICE_LOCKED , ATTR_STATE_BATTERY_LOW , ATTR_STATE_LOCKED ) [EOL] from homeassistant . components . climate import ( ATTR_OPERATION_MODE , ClimateDevice , STATE_ECO , STATE_HEAT , STATE_MANUAL , STATE_OFF , STATE_ON , SUPPORT_OPERATION_MODE , SUPPORT_TARGET_TEMPERATURE ) [EOL] from homeassistant . const import ( ATTR_TEMPERATURE , PRECISION_HALVES , TEMP_CELSIUS ) [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_FLAGS = ( SUPPORT_TARGET_TEMPERATURE | SUPPORT_OPERATION_MODE ) [EOL] [EOL] OPERATION_LIST = [ STATE_HEAT , STATE_ECO , STATE_OFF , STATE_ON ] [EOL] [EOL] MIN_TEMPERATURE = [number] [EOL] MAX_TEMPERATURE = [number] [EOL] [EOL] [comment] [EOL] ON_API_TEMPERATURE = [number] [EOL] OFF_API_TEMPERATURE = [number] [EOL] ON_REPORT_SET_TEMPERATURE = [number] [EOL] OFF_REPORT_SET_TEMPERATURE = [number] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] fritz_list = hass . data [ FRITZBOX_DOMAIN ] [EOL] [EOL] for fritz in fritz_list : [EOL] device_list = fritz . get_devices ( ) [EOL] for device in device_list : [EOL] if device . has_thermostat : [EOL] devices . append ( FritzboxThermostat ( device , fritz ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class FritzboxThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , fritz ) : [EOL] [docstring] [EOL] self . _device = device [EOL] self . _fritz = fritz [EOL] self . _current_temperature = self . _device . actual_temperature [EOL] self . _target_temperature = self . _device . target_temperature [EOL] self . _comfort_temperature = self . _device . comfort_temperature [EOL] self . _eco_temperature = self . _device . eco_temperature [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _device . present [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _device . name [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def precision ( self ) : [EOL] [docstring] [EOL] return PRECISION_HALVES [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] if self . _target_temperature in ( ON_API_TEMPERATURE , OFF_API_TEMPERATURE ) : [EOL] return None [EOL] return self . _target_temperature [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_OPERATION_MODE in kwargs : [EOL] operation_mode = kwargs . get ( ATTR_OPERATION_MODE ) [EOL] self . set_operation_mode ( operation_mode ) [EOL] elif ATTR_TEMPERATURE in kwargs : [EOL] temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] self . _device . set_target_temperature ( temperature ) [EOL] [EOL] @ property def current_operation ( self ) : [EOL] [docstring] [EOL] if self . _target_temperature == ON_API_TEMPERATURE : [EOL] return STATE_ON [EOL] if self . _target_temperature == OFF_API_TEMPERATURE : [EOL] return STATE_OFF [EOL] if self . _target_temperature == self . _comfort_temperature : [EOL] return STATE_HEAT [EOL] if self . _target_temperature == self . _eco_temperature : [EOL] return STATE_ECO [EOL] return STATE_MANUAL [EOL] [EOL] @ property def operation_list ( self ) : [EOL] [docstring] [EOL] return OPERATION_LIST [EOL] [EOL] def set_operation_mode ( self , operation_mode ) : [EOL] [docstring] [EOL] if operation_mode == STATE_HEAT : [EOL] self . set_temperature ( temperature = self . _comfort_temperature ) [EOL] elif operation_mode == STATE_ECO : [EOL] self . set_temperature ( temperature = self . _eco_temperature ) [EOL] elif operation_mode == STATE_OFF : [EOL] self . set_temperature ( temperature = OFF_REPORT_SET_TEMPERATURE ) [EOL] elif operation_mode == STATE_ON : [EOL] self . set_temperature ( temperature = ON_REPORT_SET_TEMPERATURE ) [EOL] [EOL] @ property def min_temp ( self ) : [EOL] [docstring] [EOL] return MIN_TEMPERATURE [EOL] [EOL] @ property def max_temp ( self ) : [EOL] [docstring] [EOL] return MAX_TEMPERATURE [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { ATTR_STATE_DEVICE_LOCKED : self . _device . device_lock , ATTR_STATE_LOCKED : self . _device . lock , ATTR_STATE_BATTERY_LOW : self . _device . battery_low , } [EOL] return attrs [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _device . update ( ) [EOL] self . _current_temperature = self . _device . actual_temperature [EOL] self . _target_temperature = self . _device . target_temperature [EOL] self . _comfort_temperature = self . _device . comfort_temperature [EOL] self . _eco_temperature = self . _device . eco_temperature [EOL] except requests . exceptions . HTTPError as ex : [EOL] _LOGGER . warning ( [string] , ex ) [EOL] self . _fritz . login ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . linode import ( CONF_NODES , ATTR_CREATED , ATTR_NODE_ID , ATTR_NODE_NAME , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_REGION , ATTR_VCPUS , DATA_LINODE ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NODES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] linode = hass . data . get ( DATA_LINODE ) [EOL] nodes = config . get ( CONF_NODES ) [EOL] [EOL] dev = [ ] [EOL] for node in nodes : [EOL] node_id = linode . get_node_id ( node ) [EOL] if node_id is None : [EOL] _LOGGER . error ( [string] , node ) [EOL] return [EOL] dev . append ( LinodeSwitch ( linode , node_id ) ) [EOL] [EOL] add_entities ( dev , True ) [EOL] [EOL] [EOL] class LinodeSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , li , node_id ) : [EOL] [docstring] [EOL] self . _linode = li [EOL] self . _node_id = node_id [EOL] self . data = None [EOL] self . _state = None [EOL] self . _attrs = { } [EOL] self . _name = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attrs [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status != [string] : [EOL] self . data . boot ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if self . data . status == [string] : [EOL] self . data . shutdown ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _linode . update ( ) [EOL] if self . _linode . data is not None : [EOL] for node in self . _linode . data : [EOL] if node . id == self . _node_id : [EOL] self . data = node [EOL] if self . data is not None : [EOL] self . _state = self . data . status == [string] [EOL] self . _attrs = { ATTR_CREATED : self . data . created , ATTR_NODE_ID : self . data . id , ATTR_NODE_NAME : self . data . label , ATTR_IPV4_ADDRESS : self . data . ipv4 , ATTR_IPV6_ADDRESS : self . data . ipv6 , ATTR_MEMORY : self . data . specs . memory , ATTR_REGION : self . data . region . country , ATTR_VCPUS : self . data . specs . vcpus , } [EOL] self . _name = self . data . label [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import homeassistant [EOL] [docstring] [EOL] from homeassistant . components . qwikswitch import ( QSToggleEntity , DOMAIN as QWIKSWITCH ) [EOL] from homeassistant . components . switch import SwitchDevice [EOL] [EOL] DEPENDENCIES = [ QWIKSWITCH ] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , _ , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] qsusb = hass . data [ QWIKSWITCH ] [EOL] devs = [ QSSwitch ( qsid , qsusb ) for qsid in discovery_info [ QWIKSWITCH ] ] [EOL] add_entities ( devs ) [EOL] [EOL] [EOL] class QSSwitch ( QSToggleEntity , SwitchDevice ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import builtins [EOL] import homeassistant [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . ihc import ( validate_name , IHC_DATA , IHC_CONTROLLER , IHC_INFO ) [EOL] from homeassistant . components . ihc . ihcdevice import IHCDevice [EOL] from homeassistant . components . switch import SwitchDevice , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_ID , CONF_NAME , CONF_SWITCHES [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SWITCHES , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . All ( { vol . Required ( CONF_ID ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , } , validate_name ) ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] ihc_controller = hass . data [ IHC_DATA ] [ IHC_CONTROLLER ] [EOL] info = hass . data [ IHC_DATA ] [ IHC_INFO ] [EOL] devices = [ ] [EOL] if discovery_info : [EOL] for name , device in discovery_info . items ( ) : [EOL] ihc_id = device [ [string] ] [EOL] product = device [ [string] ] [EOL] switch = IHCSwitch ( ihc_controller , name , ihc_id , info , product ) [EOL] devices . append ( switch ) [EOL] else : [EOL] switches = config [ CONF_SWITCHES ] [EOL] for switch in switches : [EOL] ihc_id = switch [ CONF_ID ] [EOL] name = switch [ CONF_NAME ] [EOL] sensor = IHCSwitch ( ihc_controller , name , ihc_id , info ) [EOL] devices . append ( sensor ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class IHCSwitch ( IHCDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ihc_controller , name , ihc_id , info , product = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ihc_controller , name , ihc_id , product ) [EOL] self . _state = False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . ihc_controller . set_runtime_value_bool ( self . ihc_id , True ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . ihc_controller . set_runtime_value_bool ( self . ihc_id , False ) [EOL] [EOL] def on_ihc_change ( self , ihc_id , value ) : [EOL] [docstring] [EOL] self . _state = value [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homematic import ATTR_DISCOVER_DEVICES , HMDevice [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] devices = [ ] [EOL] for conf in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] new_device = HMSwitch ( conf ) [EOL] devices . append ( new_device ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class HMSwitch ( HMDevice , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] try : [EOL] return self . _hm_get_state ( ) > [number] [EOL] except TypeError : [EOL] return False [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] if [string] in self . _data : [EOL] try : [EOL] return self . _data [ [string] ] / [number] [EOL] except ZeroDivisionError : [EOL] return [number] [EOL] [EOL] return None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . on ( self . _channel ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _hmdevice . off ( self . _channel ) [EOL] [EOL] def _init_data_struct ( self ) : [EOL] [docstring] [EOL] self . _state = [string] [EOL] self . _data . update ( { self . _state : STATE_UNKNOWN } ) [EOL] [EOL] [comment] [EOL] for node in self . _hmdevice . SENSORNODE : [EOL] self . _data . update ( { node : STATE_UNKNOWN } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import datetime , timedelta [EOL] import requests [EOL] [EOL] import async_timeout [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . util import convert [EOL] from homeassistant . const import ( STATE_OFF , STATE_ON , STATE_STANDBY , STATE_UNKNOWN ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_SENSOR_STATE = [string] [EOL] ATTR_SWITCH_MODE = [string] [EOL] ATTR_CURRENT_STATE_DETAIL = [string] [EOL] ATTR_COFFEMAKER_MODE = [string] [EOL] [EOL] MAKER_SWITCH_MOMENTARY = [string] [EOL] MAKER_SWITCH_TOGGLE = [string] [EOL] [EOL] WEMO_ON = [number] [EOL] WEMO_OFF = [number] [EOL] WEMO_STANDBY = [number] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities_callback , discovery_info = None ) : [EOL] [docstring] [EOL] from pywemo import discovery [EOL] [EOL] if discovery_info is not None : [EOL] location = discovery_info [ [string] ] [EOL] mac = discovery_info [ [string] ] [EOL] [EOL] try : [EOL] device = discovery . device_from_description ( location , mac ) [EOL] except ( requests . exceptions . ConnectionError , requests . exceptions . Timeout ) as err : [EOL] _LOGGER . error ( [string] , location , err ) [EOL] raise PlatformNotReady [EOL] [EOL] if device : [EOL] add_entities_callback ( [ WemoSwitch ( device ) ] ) [EOL] [EOL] [EOL] class WemoSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device ) : [EOL] [docstring] [EOL] self . wemo = device [EOL] self . insight_params = None [EOL] self . maker_params = None [EOL] self . coffeemaker_mode = None [EOL] self . _state = None [EOL] self . _available = True [EOL] self . _update_lock = None [EOL] [comment] [EOL] self . _model_name = self . wemo . model_name [EOL] [EOL] def _subscription_callback ( self , _device , _type , _params ) : [EOL] [docstring] [EOL] _LOGGER . info ( [string] , self . name ) [EOL] updated = self . wemo . subscription_update ( _type , _params ) [EOL] self . hass . add_job ( self . _async_locked_subscription_callback ( not updated ) ) [EOL] [EOL] async def _async_locked_subscription_callback ( self , force_update ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _update_lock . locked ( ) : [EOL] return [EOL] [EOL] await self . _async_locked_update ( force_update ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . wemo . serialnumber [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . wemo . name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] if self . maker_params : [EOL] [comment] [EOL] if self . maker_params [ [string] ] : [EOL] [comment] [EOL] if self . maker_params [ [string] ] : [EOL] attr [ ATTR_SENSOR_STATE ] = STATE_OFF [EOL] else : [EOL] attr [ ATTR_SENSOR_STATE ] = STATE_ON [EOL] [EOL] [comment] [EOL] if self . maker_params [ [string] ] : [EOL] attr [ ATTR_SWITCH_MODE ] = MAKER_SWITCH_MOMENTARY [EOL] else : [EOL] attr [ ATTR_SWITCH_MODE ] = MAKER_SWITCH_TOGGLE [EOL] [EOL] if self . insight_params or ( self . coffeemaker_mode is not None ) : [EOL] attr [ ATTR_CURRENT_STATE_DETAIL ] = self . detail_state [EOL] [EOL] if self . insight_params : [EOL] attr [ [string] ] = WemoSwitch . as_uptime ( self . insight_params [ [string] ] ) [EOL] attr [ [string] ] = WemoSwitch . as_uptime ( self . insight_params [ [string] ] ) [EOL] attr [ [string] ] = WemoSwitch . as_uptime ( self . insight_params [ [string] ] ) [EOL] attr [ [string] ] = convert ( self . insight_params [ [string] ] , float , [number] ) / [number] [EOL] [EOL] if self . coffeemaker_mode is not None : [EOL] attr [ ATTR_COFFEMAKER_MODE ] = self . coffeemaker_mode [EOL] [EOL] return attr [EOL] [EOL] @ staticmethod def as_uptime ( _seconds ) : [EOL] [docstring] [EOL] uptime = datetime ( [number] , [number] , [number] ) + timedelta ( seconds = _seconds ) [EOL] return [string] . format ( uptime . day - [number] , uptime . hour , uptime . minute , uptime . second ) [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] if self . insight_params : [EOL] return convert ( self . insight_params [ [string] ] , float , [number] ) / [number] [EOL] [EOL] @ property def today_energy_kwh ( self ) : [EOL] [docstring] [EOL] if self . insight_params : [EOL] miliwatts = convert ( self . insight_params [ [string] ] , float , [number] ) [EOL] return round ( miliwatts / ( [number] * [number] * [number] ) , [number] ) [EOL] [EOL] @ property def detail_state ( self ) : [EOL] [docstring] [EOL] if self . coffeemaker_mode is not None : [EOL] return self . wemo . mode_string [EOL] if self . insight_params : [EOL] standby_state = int ( self . insight_params [ [string] ] ) [EOL] if standby_state == WEMO_ON : [EOL] return STATE_ON [EOL] if standby_state == WEMO_OFF : [EOL] return STATE_OFF [EOL] if standby_state == WEMO_STANDBY : [EOL] return STATE_STANDBY [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _model_name == [string] : [EOL] return [string] [EOL] return None [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wemo . on ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . wemo . off ( ) [EOL] [EOL] async def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] self . _update_lock = asyncio . Lock ( ) [EOL] [EOL] registry = self . hass . components . wemo . SUBSCRIPTION_REGISTRY [EOL] await self . hass . async_add_job ( registry . register , self . wemo ) [EOL] registry . on ( self . wemo , None , self . _subscription_callback ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _update_lock . locked ( ) : [EOL] return [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] ) : [EOL] await asyncio . shield ( self . _async_locked_update ( True ) ) [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . warning ( [string] , self . name ) [EOL] self . _available = False [EOL] [EOL] async def _async_locked_update ( self , force_update ) : [EOL] [docstring] [EOL] async with self . _update_lock : [EOL] await self . hass . async_add_job ( self . _update , force_update ) [EOL] [EOL] def _update ( self , force_update ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . wemo . get_state ( force_update ) [EOL] if self . _model_name == [string] : [EOL] self . insight_params = self . wemo . insight_params [EOL] self . insight_params [ [string] ] = ( self . wemo . get_standby_state ) [EOL] elif self . _model_name == [string] : [EOL] self . maker_params = self . wemo . maker_params [EOL] elif self . _model_name == [string] : [EOL] self . coffeemaker_mode = self . wemo . mode [EOL] [EOL] if not self . _available : [EOL] _LOGGER . info ( [string] , self . name ) [EOL] self . _available = True [EOL] except AttributeError as err : [EOL] _LOGGER . warning ( [string] , self . name , err ) [EOL] self . _available = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 $datetime.datetime.datetime$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 $datetime.datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] from requests . exceptions import RequestException , HTTPError [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import TEMP_CELSIUS , ATTR_TEMPERATURE [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] DEFAULT_HOST = [string] [EOL] [EOL] ATTR_CURRENT_CONSUMPTION = [string] [EOL] ATTR_CURRENT_CONSUMPTION_UNIT = [string] [EOL] ATTR_CURRENT_CONSUMPTION_UNIT_VALUE = [string] [EOL] [EOL] ATTR_TOTAL_CONSUMPTION = [string] [EOL] ATTR_TOTAL_CONSUMPTION_UNIT = [string] [EOL] ATTR_TOTAL_CONSUMPTION_UNIT_VALUE = [string] [EOL] [EOL] ATTR_TEMPERATURE_UNIT = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from fritzhome . fritz import FritzBox [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] [comment] [EOL] fritz = FritzBox ( host , username , password ) [EOL] try : [EOL] fritz . login ( ) [EOL] except Exception : [comment] [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] [comment] [EOL] for actor in fritz . get_actors ( ) : [EOL] [comment] [EOL] if actor . has_switch : [EOL] data = FritzDectSwitchData ( fritz , actor . actor_id ) [EOL] data . is_online = True [EOL] add_entities ( [ FritzDectSwitch ( hass , data , actor . name ) ] , True ) [EOL] [EOL] [EOL] class FritzDectSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , name ) : [EOL] [docstring] [EOL] self . units = hass . config . units [EOL] self . data = data [EOL] self . _name = name [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { } [EOL] [EOL] if self . data . has_powermeter and self . data . current_consumption is not None and self . data . total_consumption is not None : [EOL] attrs [ ATTR_CURRENT_CONSUMPTION ] = [string] . format ( self . data . current_consumption ) [EOL] attrs [ ATTR_CURRENT_CONSUMPTION_UNIT ] = [string] . format ( ATTR_CURRENT_CONSUMPTION_UNIT_VALUE ) [EOL] attrs [ ATTR_TOTAL_CONSUMPTION ] = [string] . format ( self . data . total_consumption ) [EOL] attrs [ ATTR_TOTAL_CONSUMPTION_UNIT ] = [string] . format ( ATTR_TOTAL_CONSUMPTION_UNIT_VALUE ) [EOL] [EOL] if self . data . has_temperature and self . data . temperature is not None : [EOL] attrs [ ATTR_TEMPERATURE ] = [string] . format ( self . units . temperature ( self . data . temperature , TEMP_CELSIUS ) ) [EOL] attrs [ ATTR_TEMPERATURE_UNIT ] = [string] . format ( self . units . temperature_unit ) [EOL] return attrs [EOL] [EOL] @ property def current_power_w ( self ) : [EOL] [docstring] [EOL] try : [EOL] return float ( self . data . current_consumption ) [EOL] except ValueError : [EOL] return None [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . data . is_online : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] actor = self . data . fritz . get_actor_by_ain ( self . data . ain ) [EOL] actor . switch_on ( ) [EOL] except ( RequestException , HTTPError ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . data . is_online = False [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . data . is_online : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] actor = self . data . fritz . get_actor_by_ain ( self . data . ain ) [EOL] actor . switch_off ( ) [EOL] except ( RequestException , HTTPError ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . data . is_online = False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if not self . data . is_online : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] try : [EOL] self . data . fritz . login ( ) [EOL] except Exception : [comment] [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] self . data . is_online = True [EOL] [EOL] try : [EOL] self . data . update ( ) [EOL] except Exception : [comment] [EOL] _LOGGER . error ( [string] ) [EOL] self . data . is_online = False [EOL] [EOL] [EOL] class FritzDectSwitchData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , fritz , ain ) : [EOL] [docstring] [EOL] self . fritz = fritz [EOL] self . ain = ain [EOL] self . state = None [EOL] self . temperature = None [EOL] self . current_consumption = None [EOL] self . total_consumption = None [EOL] self . has_switch = False [EOL] self . has_temperature = False [EOL] self . has_powermeter = False [EOL] self . is_online = False [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if not self . is_online : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] try : [EOL] actor = self . fritz . get_actor_by_ain ( self . ain ) [EOL] except ( RequestException , HTTPError ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . state = None [EOL] self . temperature = None [EOL] self . current_consumption = None [EOL] self . total_consumption = None [EOL] raise Exception ( [string] ) [EOL] [EOL] if actor is None : [EOL] _LOGGER . error ( [string] ) [EOL] self . state = None [EOL] self . temperature = None [EOL] self . current_consumption = None [EOL] self . total_consumption = None [EOL] raise Exception ( [string] ) [EOL] [EOL] try : [EOL] self . state = actor . get_state ( ) [EOL] self . current_consumption = ( actor . get_power ( ) or [number] ) / [number] [EOL] self . total_consumption = ( actor . get_energy ( ) or [number] ) / [number] [EOL] except ( RequestException , HTTPError ) : [EOL] _LOGGER . error ( [string] ) [EOL] self . state = None [EOL] self . temperature = None [EOL] self . current_consumption = None [EOL] self . total_consumption = None [EOL] raise Exception ( [string] ) [EOL] [EOL] self . temperature = actor . temperature [EOL] self . has_switch = actor . has_switch [EOL] self . has_temperature = actor . has_temperature [EOL] self . has_powermeter = actor . has_powermeter [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 $builtins.bool$ 0
import builtins [EOL] from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . components . switch import ( ENTITY_ID_FORMAT , SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_FRIENDLY_NAME , CONF_VALUE_TEMPLATE , CONF_ICON_TEMPLATE , CONF_ENTITY_PICTURE_TEMPLATE , STATE_OFF , STATE_ON , ATTR_ENTITY_ID , CONF_SWITCHES , EVENT_HOMEASSISTANT_START ) [EOL] from homeassistant . exceptions import TemplateError [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import async_generate_entity_id [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] from homeassistant . helpers . script import Script [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _VALID_STATES = [ STATE_ON , STATE_OFF , [string] , [string] ] [EOL] [EOL] ON_ACTION = [string] [EOL] OFF_ACTION = [string] [EOL] [EOL] SWITCH_SCHEMA = vol . Schema ( { vol . Required ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_ICON_TEMPLATE ) : cv . template , vol . Optional ( CONF_ENTITY_PICTURE_TEMPLATE ) : cv . template , vol . Required ( ON_ACTION ) : cv . SCRIPT_SCHEMA , vol . Required ( OFF_ACTION ) : cv . SCRIPT_SCHEMA , vol . Optional ( ATTR_FRIENDLY_NAME ) : cv . string , vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SWITCHES ) : vol . Schema ( { cv . slug : SWITCH_SCHEMA } ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] switches = [ ] [EOL] [EOL] for device , device_config in config [ CONF_SWITCHES ] . items ( ) : [EOL] friendly_name = device_config . get ( ATTR_FRIENDLY_NAME , device ) [EOL] state_template = device_config [ CONF_VALUE_TEMPLATE ] [EOL] icon_template = device_config . get ( CONF_ICON_TEMPLATE ) [EOL] entity_picture_template = device_config . get ( CONF_ENTITY_PICTURE_TEMPLATE ) [EOL] on_action = device_config [ ON_ACTION ] [EOL] off_action = device_config [ OFF_ACTION ] [EOL] entity_ids = ( device_config . get ( ATTR_ENTITY_ID ) or state_template . extract_entities ( ) ) [EOL] [EOL] state_template . hass = hass [EOL] [EOL] if icon_template is not None : [EOL] icon_template . hass = hass [EOL] [EOL] if entity_picture_template is not None : [EOL] entity_picture_template . hass = hass [EOL] [EOL] switches . append ( SwitchTemplate ( hass , device , friendly_name , state_template , icon_template , entity_picture_template , on_action , off_action , entity_ids ) ) [EOL] if not switches : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] async_add_entities ( switches ) [EOL] return True [EOL] [EOL] [EOL] class SwitchTemplate ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_id , friendly_name , state_template , icon_template , entity_picture_template , on_action , off_action , entity_ids ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , device_id , hass = hass ) [EOL] self . _name = friendly_name [EOL] self . _template = state_template [EOL] self . _on_script = Script ( hass , on_action ) [EOL] self . _off_script = Script ( hass , off_action ) [EOL] self . _state = False [EOL] self . _icon_template = icon_template [EOL] self . _entity_picture_template = entity_picture_template [EOL] self . _icon = None [EOL] self . _entity_picture = None [EOL] self . _entities = entity_ids [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def template_switch_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] @ callback def template_switch_startup ( event ) : [EOL] [docstring] [EOL] async_track_state_change ( self . hass , self . _entities , template_switch_state_listener ) [EOL] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] self . hass . bus . async_listen_once ( EVENT_HOMEASSISTANT_START , template_switch_startup ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _state is not None [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _entity_picture [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] yield from self . _on_script . async_run ( ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] yield from self . _off_script . async_run ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] try : [EOL] state = self . _template . async_render ( ) . lower ( ) [EOL] [EOL] if state in _VALID_STATES : [EOL] self . _state = state in ( [string] , STATE_ON ) [EOL] else : [EOL] _LOGGER . error ( [string] , state , [string] . join ( _VALID_STATES ) ) [EOL] self . _state = None [EOL] [EOL] except TemplateError as ex : [EOL] _LOGGER . error ( ex ) [EOL] self . _state = None [EOL] [EOL] for property_name , template in ( ( [string] , self . _icon_template ) , ( [string] , self . _entity_picture_template ) ) : [EOL] if template is None : [EOL] continue [EOL] [EOL] try : [EOL] setattr ( self , property_name , template . async_render ( ) ) [EOL] except TemplateError as ex : [EOL] friendly_property_name = property_name [ [number] : ] . replace ( [string] , [string] ) [EOL] if ex . args and ex . args [ [number] ] . startswith ( [string] ) : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , friendly_property_name , self . _name ) [EOL] return [EOL] [EOL] try : [EOL] setattr ( self , property_name , getattr ( super ( ) , property_name ) ) [EOL] except AttributeError : [EOL] _LOGGER . error ( [string] , friendly_property_name , self . _name , ex ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . switch import SwitchDevice [EOL] from homeassistant . components . velbus import ( DOMAIN as VELBUS_DOMAIN , VelbusEntity ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] switches = [ ] [EOL] for switch in discovery_info : [EOL] module = hass . data [ VELBUS_DOMAIN ] . get_module ( switch [ [number] ] ) [EOL] channel = switch [ [number] ] [EOL] switches . append ( VelbusSwitch ( module , channel ) ) [EOL] async_add_entities ( switches ) [EOL] [EOL] [EOL] class VelbusSwitch ( VelbusEntity , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _module . is_on ( self . _channel ) [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _module . turn_on ( self . _channel ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _module . turn_off ( self . _channel ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . homekit_controller import ( HomeKitEntity , KNOWN_ACCESSORIES ) [EOL] from homeassistant . components . switch import SwitchDevice [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] accessory = hass . data [ KNOWN_ACCESSORIES ] [ discovery_info [ [string] ] ] [EOL] add_entities ( [ HomeKitSwitch ( accessory , discovery_info ) ] , True ) [EOL] [EOL] [EOL] class HomeKitSwitch ( HomeKitEntity , SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , * args ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( * args ) [EOL] self . _on = None [EOL] [EOL] def update_characteristics ( self , characteristics ) : [EOL] [docstring] [EOL] [comment] [EOL] import homekit [EOL] [EOL] for characteristic in characteristics : [EOL] ctype = characteristic [ [string] ] [EOL] ctype = homekit . CharacteristicsTypes . get_short ( ctype ) [EOL] if ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] self . _on = characteristic [ [string] ] [EOL] elif ctype == [string] : [EOL] self . _chars [ [string] ] = characteristic [ [string] ] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _on [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _on = True [EOL] characteristics = [ { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : True } ] [EOL] self . put_characteristics ( characteristics ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] characteristics = [ { [string] : self . _aid , [string] : self . _chars [ [string] ] , [string] : False } ] [EOL] self . put_characteristics ( characteristics ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,unknown]]$ 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import PLATFORM_SCHEMA , Camera [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PASSWORD , CONF_USERNAME ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_CAMERAS = [string] [EOL] CONF_HIDE = [string] [EOL] CONF_IMAGE_NAME = [string] [EOL] CONF_NEW_VERSION = [string] [EOL] CONF_VIEWER_PASSWORD = [string] [EOL] CONF_VIEWER_USERNAME = [string] [EOL] [EOL] CAMERAS_SCHEMA = vol . Schema ( { vol . Required ( CONF_IMAGE_NAME ) : cv . string , vol . Optional ( CONF_HIDE , default = False ) : cv . boolean , vol . Optional ( CONF_NAME ) : cv . string , } , required = False ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_CAMERAS ) : vol . Schema ( vol . All ( cv . ensure_list , [ CAMERAS_SCHEMA ] ) ) , vol . Optional ( CONF_NEW_VERSION , default = True ) : cv . boolean , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_USERNAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from pyxeoma . xeoma import Xeoma , XeomaError [EOL] [EOL] host = config [ CONF_HOST ] [EOL] login = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] xeoma = Xeoma ( host , login , password ) [EOL] [EOL] try : [EOL] await xeoma . async_test_connection ( ) [EOL] discovered_image_names = await xeoma . async_get_image_names ( ) [EOL] discovered_cameras = [ { CONF_IMAGE_NAME : image_name , CONF_HIDE : False , CONF_NAME : image_name , CONF_VIEWER_USERNAME : username , CONF_VIEWER_PASSWORD : pw } for image_name , username , pw in discovered_image_names ] [EOL] [EOL] for cam in config . get ( CONF_CAMERAS , [ ] ) : [EOL] camera = next ( ( dc for dc in discovered_cameras if dc [ CONF_IMAGE_NAME ] == cam [ CONF_IMAGE_NAME ] ) , None ) [EOL] [EOL] if camera is not None : [EOL] if CONF_NAME in cam : [EOL] camera [ CONF_NAME ] = cam [ CONF_NAME ] [EOL] if CONF_HIDE in cam : [EOL] camera [ CONF_HIDE ] = cam [ CONF_HIDE ] [EOL] [EOL] cameras = list ( filter ( lambda c : not c [ CONF_HIDE ] , discovered_cameras ) ) [EOL] async_add_entities ( [ XeomaCamera ( xeoma , camera [ CONF_IMAGE_NAME ] , camera [ CONF_NAME ] , camera [ CONF_VIEWER_USERNAME ] , camera [ CONF_VIEWER_PASSWORD ] ) for camera in cameras ] ) [EOL] except XeomaError as err : [EOL] _LOGGER . error ( [string] , err . message ) [EOL] return [EOL] [EOL] [EOL] class XeomaCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , xeoma , image , name , username , password ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] self . _xeoma = xeoma [EOL] self . _name = name [EOL] self . _image = image [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _last_image = None [EOL] [EOL] async def async_camera_image ( self ) : [EOL] [docstring] [EOL] from pyxeoma . xeoma import XeomaError [EOL] try : [EOL] image = await self . _xeoma . async_get_camera_image ( self . _image , self . _username , self . _password ) [EOL] self . _last_image = image [EOL] except XeomaError as err : [EOL] _LOGGER . error ( [string] , err . message ) [EOL] [EOL] return self . _last_image [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] [EOL] from homeassistant . components . camera import Camera [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] bloomsky = hass . components . bloomsky [EOL] for device in bloomsky . BLOOMSKY . devices . values ( ) : [EOL] add_entities ( [ BloomSkyCamera ( bloomsky . BLOOMSKY , device ) ] ) [EOL] [EOL] [EOL] class BloomSkyCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bs , device ) : [EOL] [docstring] [EOL] super ( BloomSkyCamera , self ) . __init__ ( ) [EOL] self . _name = device [ [string] ] [EOL] self . _id = device [ [string] ] [EOL] self . _bloomsky = bs [EOL] self . _url = [string] [EOL] self . _last_url = [string] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . _last_image = [string] [EOL] self . _logger = logging . getLogger ( __name__ ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _url = self . _bloomsky . devices [ self . _id ] [ [string] ] [ [string] ] [EOL] self . _bloomsky . refresh_devices ( ) [EOL] [comment] [EOL] if self . _url != self . _last_url : [EOL] response = requests . get ( self . _url , timeout = [number] ) [EOL] self . _last_url = self . _url [EOL] self . _last_image = response . content [EOL] except requests . exceptions . RequestException as error : [EOL] self . _logger . error ( [string] , error ) [EOL] return None [EOL] [EOL] return self . _last_image [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( ATTR_TITLE , ATTR_TITLE_DEFAULT , ATTR_TARGET , ATTR_DATA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_API_KEY [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] CONF_USER_KEY = [string] [EOL] [EOL] PLATFORM_SCHEMA = cv . PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USER_KEY ) : cv . string , vol . Required ( CONF_API_KEY ) : cv . string , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] from pushover import InitError [EOL] [EOL] try : [EOL] return PushoverNotificationService ( config [ CONF_USER_KEY ] , config [ CONF_API_KEY ] ) [EOL] except InitError : [EOL] _LOGGER . error ( [string] ) [EOL] return None [EOL] [EOL] [EOL] class PushoverNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , user_key , api_token ) : [EOL] [docstring] [EOL] from pushover import Client [EOL] self . _user_key = user_key [EOL] self . _api_token = api_token [EOL] self . pushover = Client ( self . _user_key , api_token = self . _api_token ) [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] from pushover import RequestError [EOL] [EOL] [comment] [EOL] data = dict ( kwargs . get ( ATTR_DATA ) or { } ) [EOL] [EOL] data [ [string] ] = kwargs . get ( ATTR_TITLE , ATTR_TITLE_DEFAULT ) [EOL] [EOL] targets = kwargs . get ( ATTR_TARGET ) [EOL] [EOL] if not isinstance ( targets , list ) : [EOL] targets = [ targets ] [EOL] [EOL] for target in targets : [EOL] if target is not None : [EOL] data [ [string] ] = target [EOL] [EOL] try : [EOL] self . pushover . send_message ( message , ** data ) [EOL] except ValueError as val_err : [EOL] _LOGGER . error ( str ( val_err ) ) [EOL] except RequestError : [EOL] _LOGGER . exception ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Optional , Dict , List , Any , Tuple [EOL] import typing [EOL] import logging [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import base64 [EOL] import mimetypes [EOL] [EOL] import requests [EOL] from requests . auth import HTTPBasicAuth [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( ATTR_TITLE , ATTR_TITLE_DEFAULT , ATTR_TARGET , ATTR_DATA , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _RESOURCE = [string] [EOL] _ALLOWED_IMAGES = [ [string] , [string] , [string] ] [EOL] [EOL] CONF_DEVICE_KEY = [string] [EOL] CONF_TIMEOUT = [number] [EOL] [EOL] [comment] [EOL] ATTR_SOUND = [string] [EOL] ATTR_VIBRATION = [string] [EOL] ATTR_ICON = [string] [EOL] ATTR_ICONCOLOR = [string] [EOL] ATTR_URL = [string] [EOL] ATTR_URLTITLE = [string] [EOL] ATTR_TIME2LIVE = [string] [EOL] ATTR_PRIORITY = [string] [EOL] ATTR_RETRY = [string] [EOL] ATTR_EXPIRE = [string] [EOL] ATTR_ANSWER = [string] [EOL] ATTR_PICTURE1 = [string] [EOL] [EOL] [comment] [EOL] ATTR_PICTURE1_URL = [string] [EOL] ATTR_PICTURE1_PATH = [string] [EOL] ATTR_PICTURE1_USERNAME = [string] [EOL] ATTR_PICTURE1_PASSWORD = [string] [EOL] ATTR_PICTURE1_AUTH = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICE_KEY ) : cv . string , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return PushsaferNotificationService ( config . get ( CONF_DEVICE_KEY ) , hass . config . is_allowed_path ) [EOL] [EOL] [EOL] class PushsaferNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , private_key , is_allowed_path ) : [EOL] [docstring] [EOL] self . _private_key = private_key [EOL] self . is_allowed_path = is_allowed_path [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] if kwargs . get ( ATTR_TARGET ) is None : [EOL] targets = [ [string] ] [EOL] _LOGGER . debug ( [string] ) [EOL] else : [EOL] targets = kwargs . get ( ATTR_TARGET ) [EOL] _LOGGER . debug ( [string] , len ( targets ) ) [EOL] [EOL] title = kwargs . get ( ATTR_TITLE , ATTR_TITLE_DEFAULT ) [EOL] data = kwargs . get ( ATTR_DATA , { } ) [EOL] [EOL] [comment] [EOL] picture1 = data . get ( ATTR_PICTURE1 ) [EOL] picture1_encoded = [string] [EOL] if picture1 is not None : [EOL] _LOGGER . debug ( [string] ) [EOL] url = picture1 . get ( ATTR_PICTURE1_URL , None ) [EOL] local_path = picture1 . get ( ATTR_PICTURE1_PATH , None ) [EOL] username = picture1 . get ( ATTR_PICTURE1_USERNAME ) [EOL] password = picture1 . get ( ATTR_PICTURE1_PASSWORD ) [EOL] auth = picture1 . get ( ATTR_PICTURE1_AUTH ) [EOL] [EOL] if url is not None : [EOL] _LOGGER . debug ( [string] , url ) [EOL] picture1_encoded = self . load_from_url ( url , username , password , auth ) [EOL] elif local_path is not None : [EOL] _LOGGER . debug ( [string] , local_path ) [EOL] picture1_encoded = self . load_from_file ( local_path ) [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL] [EOL] payload = { [string] : self . _private_key , [string] : title , [string] : message , [string] : data . get ( ATTR_SOUND , [string] ) , [string] : data . get ( ATTR_VIBRATION , [string] ) , [string] : data . get ( ATTR_ICON , [string] ) , [string] : data . get ( ATTR_ICONCOLOR , [string] ) , [string] : data . get ( ATTR_URL , [string] ) , [string] : data . get ( ATTR_URLTITLE , [string] ) , [string] : data . get ( ATTR_TIME2LIVE , [string] ) , [string] : data . get ( ATTR_PRIORITY , [string] ) , [string] : data . get ( ATTR_RETRY , [string] ) , [string] : data . get ( ATTR_EXPIRE , [string] ) , [string] : data . get ( ATTR_ANSWER , [string] ) , [string] : picture1_encoded } [EOL] [EOL] for target in targets : [EOL] payload [ [string] ] = target [EOL] response = requests . post ( _RESOURCE , data = payload , timeout = CONF_TIMEOUT ) [EOL] if response . status_code != [number] : [EOL] _LOGGER . error ( [string] , response . text ) [EOL] else : [EOL] _LOGGER . debug ( [string] , response . json ( ) ) [EOL] [EOL] @ classmethod def get_base64 ( cls , filebyte , mimetype ) : [EOL] [docstring] [EOL] if mimetype not in _ALLOWED_IMAGES : [EOL] _LOGGER . warning ( [string] , mimetype ) [EOL] return None [EOL] [EOL] base64_image = base64 . b64encode ( filebyte ) . decode ( [string] ) [EOL] return [string] . format ( mimetype , base64_image ) [EOL] [EOL] def load_from_url ( self , url = None , username = None , password = None , auth = None ) : [EOL] [docstring] [EOL] if url is not None : [EOL] _LOGGER . debug ( [string] , url ) [EOL] if username is not None and password is not None : [EOL] auth_ = HTTPBasicAuth ( username , password ) [EOL] response = requests . get ( url , auth = auth_ , timeout = CONF_TIMEOUT ) [EOL] else : [EOL] response = requests . get ( url , timeout = CONF_TIMEOUT ) [EOL] return self . get_base64 ( response . content , response . headers [ [string] ] ) [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] return None [EOL] [EOL] def load_from_file ( self , local_path = None ) : [EOL] [docstring] [EOL] try : [EOL] if local_path is not None : [EOL] _LOGGER . debug ( [string] ) [EOL] if self . is_allowed_path ( local_path ) : [EOL] file_mimetype = mimetypes . guess_type ( local_path ) [EOL] _LOGGER . debug ( [string] , file_mimetype ) [EOL] with open ( local_path , [string] ) as binary_file : [EOL] data = binary_file . read ( ) [EOL] return self . get_base64 ( data , file_mimetype [ [number] ] ) [EOL] else : [EOL] _LOGGER . warning ( [string] ) [EOL] except OSError as error : [EOL] _LOGGER . error ( [string] , error ) [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 $builtins.int$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $requests.auth.HTTPBasicAuth$ 0 0 0 $builtins.int$ 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 $typing.Tuple[typing.Optional[builtins.str],typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_USERNAME , CONF_PASSWORD , CONF_RECIPIENT [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_RECIPIENT ) : cv . string , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return YesssSMSNotificationService ( config [ CONF_USERNAME ] , config [ CONF_PASSWORD ] , config [ CONF_RECIPIENT ] ) [EOL] [EOL] [EOL] class YesssSMSNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , username , password , recipient ) : [EOL] [docstring] [EOL] from YesssSMS import YesssSMS [EOL] self . yesss = YesssSMS ( username , password ) [EOL] self . _recipient = recipient [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] try : [EOL] self . yesss . send ( self . _recipient , message ) [EOL] except ValueError as ex : [EOL] if str ( ex ) . startswith ( [string] ) : [EOL] _LOGGER . error ( str ( ex ) ) [EOL] except RuntimeError as ex : [EOL] if str ( ex ) . startswith ( [string] ) : [EOL] _LOGGER . error ( str ( ex ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . notify import ( PLATFORM_SCHEMA , BaseNotificationService ) [EOL] from homeassistant . const import CONF_ACCESS_TOKEN [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] _RESOURCE = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ACCESS_TOKEN ) : cv . string , } ) [EOL] [EOL] [EOL] async def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] access_token = config . get ( CONF_ACCESS_TOKEN ) [EOL] url = [string] . format ( _RESOURCE , access_token ) [EOL] session = async_get_clientsession ( hass ) [EOL] [EOL] return FlockNotificationService ( url , session , hass . loop ) [EOL] [EOL] [EOL] class FlockNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url , session , loop ) : [EOL] [docstring] [EOL] self . _loop = loop [EOL] self . _url = url [EOL] self . _session = session [EOL] [EOL] async def async_send_message ( self , message , ** kwargs ) : [EOL] [docstring] [EOL] payload = { [string] : message } [EOL] [EOL] _LOGGER . debug ( [string] , self . _url ) [EOL] [EOL] try : [EOL] with async_timeout . timeout ( [number] , loop = self . _loop ) : [EOL] response = await self . _session . post ( self . _url , json = payload ) [EOL] result = await response . json ( ) [EOL] [EOL] if response . status != [number] or [string] in result : [EOL] _LOGGER . error ( [string] , response . status , result ) [EOL] except asyncio . TimeoutError : [EOL] _LOGGER . error ( [string] , self . _url ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_URL , CONF_USERNAME , CONF_PASSWORD , CONF_ROOM ) [EOL] from homeassistant . components . notify import ( ATTR_DATA , PLATFORM_SCHEMA , BaseNotificationService ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_URL ) : vol . Url ( ) , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_ROOM ) : cv . string , } ) [EOL] [EOL] [EOL] def get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] from rocketchat_API . APIExceptions . RocketExceptions import ( RocketConnectionException , RocketAuthenticationException ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] url = config . get ( CONF_URL ) [EOL] room = config . get ( CONF_ROOM ) [EOL] [EOL] try : [EOL] return RocketChatNotificationService ( url , username , password , room ) [EOL] except RocketConnectionException : [EOL] _LOGGER . warning ( [string] , url ) [EOL] except RocketAuthenticationException : [EOL] _LOGGER . warning ( [string] , username ) [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] return None [EOL] [EOL] [EOL] class RocketChatNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , url , username , password , room ) : [EOL] [docstring] [EOL] from rocketchat_API . rocketchat import RocketChat [EOL] self . _room = room [EOL] self . _server = RocketChat ( username , password , server_url = url ) [EOL] [EOL] def send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] data = kwargs . get ( ATTR_DATA ) or { } [EOL] resp = self . _server . chat_post_message ( message , channel = self . _room , ** data ) [EOL] if resp . status_code == [number] : [EOL] success = resp . json ( ) [ [string] ] [EOL] if not success : [EOL] _LOGGER . error ( [string] ) [EOL] else : [EOL] _LOGGER . error ( [string] , resp . status_code ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . knx import DATA_KNX , ATTR_DISCOVER_DEVICES [EOL] from homeassistant . components . notify import PLATFORM_SCHEMA , BaseNotificationService [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] CONF_ADDRESS = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ADDRESS ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] async def async_get_service ( hass , config , discovery_info = None ) : [EOL] [docstring] [EOL] return async_get_service_discovery ( hass , discovery_info ) \ [EOL] if discovery_info is not None else \ [EOL] async_get_service_config ( hass , config ) [EOL] [EOL] [EOL] @ callback def async_get_service_discovery ( hass , discovery_info ) : [EOL] [docstring] [EOL] notification_devices = [ ] [EOL] for device_name in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] device = hass . data [ DATA_KNX ] . xknx . devices [ device_name ] [EOL] notification_devices . append ( device ) [EOL] return KNXNotificationService ( notification_devices ) \ [EOL] if notification_devices else \ [EOL] None [EOL] [EOL] [EOL] @ callback def async_get_service_config ( hass , config ) : [EOL] [docstring] [EOL] import xknx [EOL] notification = xknx . devices . Notification ( hass . data [ DATA_KNX ] . xknx , name = config . get ( CONF_NAME ) , group_address = config . get ( CONF_ADDRESS ) ) [EOL] hass . data [ DATA_KNX ] . xknx . devices . add ( notification ) [EOL] return KNXNotificationService ( [ notification , ] ) [EOL] [EOL] [EOL] class KNXNotificationService ( BaseNotificationService ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , devices ) : [EOL] [docstring] [EOL] self . devices = devices [EOL] [EOL] @ property def targets ( self ) : [EOL] [docstring] [EOL] ret = { } [EOL] for device in self . devices : [EOL] ret [ device . name ] = device . name [EOL] return ret [EOL] [EOL] async def async_send_message ( self , message = [string] , ** kwargs ) : [EOL] [docstring] [EOL] if [string] in kwargs : [EOL] await self . _async_send_to_device ( message , kwargs [ [string] ] ) [EOL] else : [EOL] await self . _async_send_to_all_devices ( message ) [EOL] [EOL] async def _async_send_to_all_devices ( self , message ) : [EOL] [docstring] [EOL] for device in self . devices : [EOL] await device . set ( message ) [EOL] [EOL] async def _async_send_to_device ( self , message , names ) : [EOL] [docstring] [EOL] for device in self . devices : [EOL] if device . name in names : [EOL] await device . set ( message ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] [docstring] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity_registry import async_get_registry [EOL] from homeassistant . components import websocket_api [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] WS_TYPE_GET = [string] [EOL] SCHEMA_WS_GET = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_GET , vol . Required ( [string] ) : cv . entity_id } ) [EOL] [EOL] WS_TYPE_UPDATE = [string] [EOL] SCHEMA_WS_UPDATE = websocket_api . BASE_COMMAND_MESSAGE_SCHEMA . extend ( { vol . Required ( [string] ) : WS_TYPE_UPDATE , vol . Required ( [string] ) : cv . entity_id , vol . Optional ( [string] ) : vol . Any ( str , None ) , vol . Optional ( [string] ) : str , } ) [EOL] [EOL] [EOL] async def async_setup ( hass ) : [EOL] [docstring] [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_GET , websocket_get_entity , SCHEMA_WS_GET ) [EOL] hass . components . websocket_api . async_register_command ( WS_TYPE_UPDATE , websocket_update_entity , SCHEMA_WS_UPDATE ) [EOL] return True [EOL] [EOL] [EOL] @ callback def websocket_get_entity ( hass , connection , msg ) : [EOL] [docstring] [EOL] async def retrieve_entity ( ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] entry = registry . entities . get ( msg [ [string] ] ) [EOL] [EOL] if entry is None : [EOL] connection . send_message_outside ( websocket_api . error_message ( msg [ [string] ] , websocket_api . ERR_NOT_FOUND , [string] ) ) [EOL] return [EOL] [EOL] connection . send_message_outside ( websocket_api . result_message ( msg [ [string] ] , _entry_dict ( entry ) ) ) [EOL] [EOL] hass . async_add_job ( retrieve_entity ( ) ) [EOL] [EOL] [EOL] @ callback def websocket_update_entity ( hass , connection , msg ) : [EOL] [docstring] [EOL] async def update_entity ( ) : [EOL] [docstring] [EOL] registry = await async_get_registry ( hass ) [EOL] [EOL] if msg [ [string] ] not in registry . entities : [EOL] connection . send_message_outside ( websocket_api . error_message ( msg [ [string] ] , websocket_api . ERR_NOT_FOUND , [string] ) ) [EOL] return [EOL] [EOL] changes = { } [EOL] [EOL] if [string] in msg : [EOL] changes [ [string] ] = msg [ [string] ] [EOL] [EOL] if [string] in msg : [EOL] changes [ [string] ] = msg [ [string] ] [EOL] [EOL] try : [EOL] if changes : [EOL] entry = registry . async_update_entity ( msg [ [string] ] , ** changes ) [EOL] except ValueError as err : [EOL] connection . send_message_outside ( websocket_api . error_message ( msg [ [string] ] , [string] , str ( err ) ) ) [EOL] else : [EOL] connection . send_message_outside ( websocket_api . result_message ( msg [ [string] ] , _entry_dict ( entry ) ) ) [EOL] [EOL] hass . async_create_task ( update_entity ( ) ) [EOL] [EOL] [EOL] @ callback def _entry_dict ( entry ) : [EOL] [docstring] [EOL] return { [string] : entry . entity_id , [string] : entry . name } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . weather import WeatherEntity , PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME , TEMP_CELSIUS , CONF_LATITUDE , CONF_LONGITUDE [EOL] from homeassistant . helpers import config_validation as cv [EOL] [comment] [EOL] from homeassistant . components . sensor . bom import BOMCurrentData , closest_station , CONF_STATION , validate_station [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_STATION ) : validate_station , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] station = config . get ( CONF_STATION ) or closest_station ( config . get ( CONF_LATITUDE ) , config . get ( CONF_LONGITUDE ) , hass . config . config_dir ) [EOL] if station is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] bom_data = BOMCurrentData ( hass , station ) [EOL] try : [EOL] bom_data . update ( ) [EOL] except ValueError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] return False [EOL] add_entities ( [ BOMWeather ( bom_data , config . get ( CONF_NAME ) ) ] , True ) [EOL] [EOL] [EOL] class BOMWeather ( WeatherEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , bom_data , stationname = None ) : [EOL] [docstring] [EOL] self . bom_data = bom_data [EOL] self . stationname = stationname or self . bom_data . latest_data . get ( [string] ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . bom_data . update ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . stationname or [string] ) [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] return self . bom_data . get_reading ( [string] ) [EOL] [EOL] [comment] [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] return self . bom_data . get_reading ( [string] ) [EOL] [EOL] @ property def temperature_unit ( self ) : [EOL] [docstring] [EOL] return TEMP_CELSIUS [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] return self . bom_data . get_reading ( [string] ) [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] return self . bom_data . get_reading ( [string] ) [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] return self . bom_data . get_reading ( [string] ) [EOL] [EOL] @ property def wind_bearing ( self ) : [EOL] [docstring] [EOL] directions = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] wind = { name : idx * [number] / [number] for idx , name in enumerate ( directions ) } [EOL] return wind . get ( self . bom_data . get_reading ( [string] ) ) [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Union , List , Dict [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . image_processing import ( ImageProcessingFaceEntity , ATTR_CONFIDENCE , ATTR_NAME , ATTR_AGE , ATTR_GENDER ) [EOL] from homeassistant . components . image_processing . openalpr_local import ( ImageProcessingAlprEntity ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] add_entities ( [ DemoImageProcessingAlpr ( [string] , [string] ) , DemoImageProcessingFace ( [string] , [string] ) ] ) [EOL] [EOL] [EOL] class DemoImageProcessingAlpr ( ImageProcessingAlprEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _name = name [EOL] self . _camera = camera_entity [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def confidence ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] demo_data = { [string] : [number] , [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] self . process_plates ( demo_data , [number] ) [EOL] [EOL] [EOL] class DemoImageProcessingFace ( ImageProcessingFaceEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , camera_entity , name ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _name = name [EOL] self . _camera = camera_entity [EOL] [EOL] @ property def camera_entity ( self ) : [EOL] [docstring] [EOL] return self . _camera [EOL] [EOL] @ property def confidence ( self ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_image ( self , image ) : [EOL] [docstring] [EOL] demo_data = [ { ATTR_CONFIDENCE : [number] , ATTR_NAME : [string] , ATTR_AGE : [number] , ATTR_GENDER : [string] , } , { ATTR_NAME : [string] , ATTR_AGE : [number] , ATTR_GENDER : [string] , } , { ATTR_CONFIDENCE : [number] , ATTR_NAME : [string] , } , ] [EOL] [EOL] self . process_faces ( demo_data , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Union[builtins.float,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[unknown,typing.Union[builtins.float,builtins.str]]]$ 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . upcloud import ( UpCloudServerEntity , CONF_SERVERS , DATA_UPCLOUD ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_SERVERS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] upcloud = hass . data [ DATA_UPCLOUD ] [EOL] [EOL] servers = config . get ( CONF_SERVERS ) [EOL] [EOL] devices = [ UpCloudBinarySensor ( upcloud , uuid ) for uuid in servers ] [EOL] [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class UpCloudBinarySensor ( UpCloudServerEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . satel_integra import ( CONF_ZONES , CONF_ZONE_NAME , CONF_ZONE_TYPE , SIGNAL_ZONES_UPDATED ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import async_dispatcher_connect [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if not discovery_info : [EOL] return [EOL] [EOL] configured_zones = discovery_info [ CONF_ZONES ] [EOL] [EOL] devices = [ ] [EOL] [EOL] for zone_num , device_config_data in configured_zones . items ( ) : [EOL] zone_type = device_config_data [ CONF_ZONE_TYPE ] [EOL] zone_name = device_config_data [ CONF_ZONE_NAME ] [EOL] device = SatelIntegraBinarySensor ( zone_num , zone_name , zone_type ) [EOL] devices . append ( device ) [EOL] [EOL] async_add_entities ( devices ) [EOL] [EOL] [EOL] class SatelIntegraBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , zone_number , zone_name , zone_type ) : [EOL] [docstring] [EOL] self . _zone_number = zone_number [EOL] self . _name = zone_name [EOL] self . _zone_type = zone_type [EOL] self . _state = [number] [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_ZONES_UPDATED , self . _zones_updated ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _zone_type == [string] : [EOL] return [string] [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == [number] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _zone_type [EOL] [EOL] @ callback def _zones_updated ( self , zones ) : [EOL] [docstring] [EOL] if self . _zone_number in zones \ [EOL] and self . _state != zones [ self . _zone_number ] : [EOL] self . _state = zones [ self . _zone_number ] [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import CONF_NAME , CONF_MONITORED_CONDITIONS [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] DOMAIN = [string] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] , [string] , None ] , [string] : [ [string] , [string] , [string] , None ] } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] octoprint_api = hass . data [ DOMAIN ] [ [string] ] [EOL] name = config . get ( CONF_NAME ) [EOL] monitored_conditions = config . get ( CONF_MONITORED_CONDITIONS , SENSOR_TYPES . keys ( ) ) [EOL] [EOL] devices = [ ] [EOL] for octo_type in monitored_conditions : [EOL] new_sensor = OctoPrintBinarySensor ( octoprint_api , octo_type , SENSOR_TYPES [ octo_type ] [ [number] ] , name , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] , SENSOR_TYPES [ octo_type ] [ [number] ] , [string] ) [EOL] devices . append ( new_sensor ) [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class OctoPrintBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , condition , sensor_type , sensor_name , unit , endpoint , group , tool = None ) : [EOL] [docstring] [EOL] self . sensor_name = sensor_name [EOL] if tool is None : [EOL] self . _name = [string] . format ( sensor_name , condition ) [EOL] else : [EOL] self . _name = [string] . format ( sensor_name , condition ) [EOL] self . sensor_type = sensor_type [EOL] self . api = api [EOL] self . _state = False [EOL] self . _unit_of_measurement = unit [EOL] self . api_endpoint = endpoint [EOL] self . api_group = group [EOL] self . api_tool = tool [EOL] _LOGGER . debug ( [string] , self ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . _state ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _state = self . api . update ( self . sensor_type , self . api_endpoint , self . api_group , self . api_tool ) [EOL] except requests . exceptions . ConnectionError : [EOL] [comment] [EOL] return [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . tellduslive import TelldusLiveEntity [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] add_entities ( TelldusLiveSensor ( hass , binary_sensor ) for binary_sensor in discovery_info ) [EOL] [EOL] [EOL] class TelldusLiveSensor ( TelldusLiveEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . device . is_on [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import PLATFORM_SCHEMA [EOL] from homeassistant . components . binary_sensor . ffmpeg_motion import ( FFmpegBinarySensor ) [EOL] from homeassistant . components . ffmpeg import ( DATA_FFMPEG , CONF_INPUT , CONF_OUTPUT , CONF_EXTRA_ARGUMENTS , CONF_INITIAL_STATE ) [EOL] from homeassistant . const import CONF_NAME [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_PEAK = [string] [EOL] CONF_DURATION = [string] [EOL] CONF_RESET = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_INIT_STATE = True [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_INPUT ) : cv . string , vol . Optional ( CONF_INITIAL_STATE , default = DEFAULT_INIT_STATE ) : cv . boolean , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_EXTRA_ARGUMENTS ) : cv . string , vol . Optional ( CONF_OUTPUT ) : cv . string , vol . Optional ( CONF_PEAK , default = - [number] ) : vol . Coerce ( int ) , vol . Optional ( CONF_DURATION , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , vol . Optional ( CONF_RESET , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] manager = hass . data [ DATA_FFMPEG ] [EOL] [EOL] if not manager . async_run_test ( config . get ( CONF_INPUT ) ) : [EOL] return [EOL] [EOL] entity = FFmpegNoise ( hass , manager , config ) [EOL] async_add_entities ( [ entity ] ) [EOL] [EOL] [EOL] class FFmpegNoise ( FFmpegBinarySensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , manager , config ) : [EOL] [docstring] [EOL] from haffmpeg import SensorNoise [EOL] [EOL] super ( ) . __init__ ( config ) [EOL] self . ffmpeg = SensorNoise ( manager . binary , hass . loop , self . _async_callback ) [EOL] [EOL] @ asyncio . coroutine def _async_start_ffmpeg ( self , entity_ids ) : [EOL] [docstring] [EOL] if entity_ids is not None and self . entity_id not in entity_ids : [EOL] return [EOL] [EOL] self . ffmpeg . set_options ( time_duration = self . _config . get ( CONF_DURATION ) , time_reset = self . _config . get ( CONF_RESET ) , peak = self . _config . get ( CONF_PEAK ) , ) [EOL] [EOL] yield from self . ffmpeg . open_sensor ( input_source = self . _config . get ( CONF_INPUT ) , output_dest = self . _config . get ( CONF_OUTPUT ) , extra_cmd = self . _config . get ( CONF_EXTRA_ARGUMENTS ) , ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Set , List [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from collections import OrderedDict [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_ABOVE , CONF_BELOW , CONF_DEVICE_CLASS , CONF_ENTITY_ID , CONF_NAME , CONF_PLATFORM , CONF_STATE , STATE_UNKNOWN ) [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers import condition [EOL] from homeassistant . helpers . event import async_track_state_change [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_OBSERVATIONS = [string] [EOL] ATTR_PROBABILITY = [string] [EOL] ATTR_PROBABILITY_THRESHOLD = [string] [EOL] [EOL] CONF_OBSERVATIONS = [string] [EOL] CONF_PRIOR = [string] [EOL] CONF_PROBABILITY_THRESHOLD = [string] [EOL] CONF_P_GIVEN_F = [string] [EOL] CONF_P_GIVEN_T = [string] [EOL] CONF_TO_STATE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PROBABILITY_THRESHOLD = [number] [EOL] [EOL] NUMERIC_STATE_SCHEMA = vol . Schema ( { CONF_PLATFORM : [string] , vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Optional ( CONF_ABOVE ) : vol . Coerce ( float ) , vol . Optional ( CONF_BELOW ) : vol . Coerce ( float ) , vol . Required ( CONF_P_GIVEN_T ) : vol . Coerce ( float ) , vol . Optional ( CONF_P_GIVEN_F ) : vol . Coerce ( float ) } , required = True ) [EOL] [EOL] STATE_SCHEMA = vol . Schema ( { CONF_PLATFORM : CONF_STATE , vol . Required ( CONF_ENTITY_ID ) : cv . entity_id , vol . Required ( CONF_TO_STATE ) : cv . string , vol . Required ( CONF_P_GIVEN_T ) : vol . Coerce ( float ) , vol . Optional ( CONF_P_GIVEN_F ) : vol . Coerce ( float ) } , required = True ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : cv . string , vol . Required ( CONF_OBSERVATIONS ) : vol . Schema ( vol . All ( cv . ensure_list , [ vol . Any ( NUMERIC_STATE_SCHEMA , STATE_SCHEMA ) ] ) ) , vol . Required ( CONF_PRIOR ) : vol . Coerce ( float ) , vol . Optional ( CONF_PROBABILITY_THRESHOLD , default = DEFAULT_PROBABILITY_THRESHOLD ) : vol . Coerce ( float ) , } ) [EOL] [EOL] [EOL] def update_probability ( prior , prob_true , prob_false ) : [EOL] [docstring] [EOL] numerator = prob_true * prior [EOL] denominator = numerator + prob_false * ( [number] - prior ) [EOL] [EOL] probability = numerator / denominator [EOL] return probability [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] observations = config . get ( CONF_OBSERVATIONS ) [EOL] prior = config . get ( CONF_PRIOR ) [EOL] probability_threshold = config . get ( CONF_PROBABILITY_THRESHOLD ) [EOL] device_class = config . get ( CONF_DEVICE_CLASS ) [EOL] [EOL] async_add_entities ( [ BayesianBinarySensor ( name , prior , observations , probability_threshold , device_class ) ] , True ) [EOL] [EOL] [EOL] class BayesianBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , prior , observations , probability_threshold , device_class ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _observations = observations [EOL] self . _probability_threshold = probability_threshold [EOL] self . _device_class = device_class [EOL] self . _deviation = False [EOL] self . prior = prior [EOL] self . probability = prior [EOL] [EOL] self . current_obs = OrderedDict ( { } ) [EOL] [EOL] to_observe = set ( obs [ [string] ] for obs in self . _observations ) [EOL] [EOL] self . entity_obs = dict . fromkeys ( to_observe , [ ] ) [EOL] [EOL] for ind , obs in enumerate ( self . _observations ) : [EOL] obs [ [string] ] = ind [EOL] self . entity_obs [ obs [ [string] ] ] . append ( obs ) [EOL] [EOL] self . watchers = { [string] : self . _process_numeric_state , [string] : self . _process_state } [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] @ callback def async_threshold_sensor_state_listener ( entity , old_state , new_state ) : [EOL] [docstring] [EOL] if new_state . state == STATE_UNKNOWN : [EOL] return [EOL] [EOL] entity_obs_list = self . entity_obs [ entity ] [EOL] [EOL] for entity_obs in entity_obs_list : [EOL] platform = entity_obs [ [string] ] [EOL] [EOL] self . watchers [ platform ] ( entity_obs ) [EOL] [EOL] prior = self . prior [EOL] for obs in self . current_obs . values ( ) : [EOL] prior = update_probability ( prior , obs [ [string] ] , obs [ [string] ] ) [EOL] self . probability = prior [EOL] [EOL] self . hass . async_add_job ( self . async_update_ha_state , True ) [EOL] [EOL] entities = [ obs [ [string] ] for obs in self . _observations ] [EOL] async_track_state_change ( self . hass , entities , async_threshold_sensor_state_listener ) [EOL] [EOL] def _update_current_obs ( self , entity_observation , should_trigger ) : [EOL] [docstring] [EOL] obs_id = entity_observation [ [string] ] [EOL] [EOL] if should_trigger : [EOL] prob_true = entity_observation [ [string] ] [EOL] prob_false = entity_observation . get ( [string] , [number] - prob_true ) [EOL] [EOL] self . current_obs [ obs_id ] = { [string] : prob_true , [string] : prob_false } [EOL] [EOL] else : [EOL] self . current_obs . pop ( obs_id , None ) [EOL] [EOL] def _process_numeric_state ( self , entity_observation ) : [EOL] [docstring] [EOL] entity = entity_observation [ [string] ] [EOL] [EOL] should_trigger = condition . async_numeric_state ( self . hass , entity , entity_observation . get ( [string] ) , entity_observation . get ( [string] ) , None , entity_observation ) [EOL] [EOL] self . _update_current_obs ( entity_observation , should_trigger ) [EOL] [EOL] def _process_state ( self , entity_observation ) : [EOL] [docstring] [EOL] entity = entity_observation [ [string] ] [EOL] [EOL] should_trigger = condition . state ( self . hass , entity , entity_observation . get ( [string] ) ) [EOL] [EOL] self . _update_current_obs ( entity_observation , should_trigger ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _deviation [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_OBSERVATIONS : [ val for val in self . current_obs . values ( ) ] , ATTR_PROBABILITY : round ( self . probability , [number] ) , ATTR_PROBABILITY_THRESHOLD : self . _probability_threshold , } [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] self . _deviation = bool ( self . probability >= self . _probability_threshold ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] from homeassistant . components . egardia import ( EGARDIA_DEVICE , ATTR_DISCOVER_DEVICES ) [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] DEPENDENCIES = [ [string] ] [EOL] EGARDIA_TYPE_TO_DEVICE_CLASS = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if ( discovery_info is None or discovery_info [ ATTR_DISCOVER_DEVICES ] is None ) : [EOL] return [EOL] [EOL] disc_info = discovery_info [ ATTR_DISCOVER_DEVICES ] [EOL] [comment] [EOL] async_add_entities ( ( EgardiaBinarySensor ( sensor_id = disc_info [ sensor ] [ [string] ] , name = disc_info [ sensor ] [ [string] ] , egardia_system = hass . data [ EGARDIA_DEVICE ] , device_class = EGARDIA_TYPE_TO_DEVICE_CLASS . get ( disc_info [ sensor ] [ [string] ] , None ) ) for sensor in disc_info ) , True ) [EOL] [EOL] [EOL] class EgardiaBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_id , name , egardia_system , device_class ) : [EOL] [docstring] [EOL] self . _id = sensor_id [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _device_class = device_class [EOL] self . _egardia_system = egardia_system [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] egardia_input = self . _egardia_system . getsensorstate ( self . _id ) [EOL] self . _state = STATE_ON if egardia_input else STATE_OFF [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == STATE_ON [EOL] [EOL] @ property def hidden ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return True [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_API_KEY , CONF_NAME , CONF_MONITORED_CONDITIONS , ATTR_ATTRIBUTION ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_HOURS = [string] [EOL] CONF_SPOT_ID = [string] [EOL] CONF_UNITS = [string] [EOL] CONF_UPDATE_INTERVAL = [string] [EOL] [EOL] DEFAULT_UNIT = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_ATTRIBUTION = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] HOURS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] ] , [string] : [ [string] ] , [string] : [ [string] ] , } [EOL] [EOL] UNITS = [ [string] , [string] , [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MONITORED_CONDITIONS ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_SPOT_ID ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_HOURS , default = None ) : vol . All ( cv . ensure_list , [ vol . In ( HOURS ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_UNITS ) : vol . In ( UNITS ) , } ) [EOL] [EOL] [comment] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] spot_id = config [ CONF_SPOT_ID ] [EOL] api_key = config [ CONF_API_KEY ] [EOL] hours = config . get ( CONF_HOURS ) [EOL] [EOL] if CONF_UNITS in config : [EOL] units = config . get ( CONF_UNITS ) [EOL] elif hass . config . units . is_metric : [EOL] units = UNITS [ [number] ] [EOL] else : [EOL] units = UNITS [ [number] ] [EOL] [EOL] forecast_data = MagicSeaweedData ( api_key = api_key , spot_id = spot_id , units = units ) [EOL] forecast_data . update ( ) [EOL] [EOL] [comment] [EOL] if forecast_data . currently is None or forecast_data . hourly is None : [EOL] return [EOL] [EOL] sensors = [ ] [EOL] for variable in config [ CONF_MONITORED_CONDITIONS ] : [EOL] sensors . append ( MagicSeaweedSensor ( forecast_data , variable , name , units ) ) [EOL] if [string] not in variable and hours is not None : [EOL] for hour in hours : [EOL] sensors . append ( MagicSeaweedSensor ( forecast_data , variable , name , units , hour ) ) [EOL] add_entities ( sensors , True ) [EOL] [EOL] [EOL] class MagicSeaweedSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , forecast_data , sensor_type , name , unit_system , hour = None ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . data = forecast_data [EOL] self . hour = hour [EOL] self . type = sensor_type [EOL] self . _attrs = { ATTR_ATTRIBUTION : DEFAULT_ATTRIBUTION } [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . _icon = None [EOL] self . _state = None [EOL] self . _unit_system = unit_system [EOL] self . _unit_of_measurement = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . hour is None and [string] in self . type : [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] if self . hour is None : [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] return [string] . format ( self . hour , self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_system ( self ) : [EOL] [docstring] [EOL] return self . _unit_system [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attrs [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] if self . hour is None : [EOL] forecast = self . data . currently [EOL] else : [EOL] forecast = self . data . hourly [ self . hour ] [EOL] [EOL] self . _unit_of_measurement = forecast . swell_unit [EOL] if self . type == [string] : [EOL] self . _state = forecast . swell_minBreakingHeight [EOL] elif self . type == [string] : [EOL] self . _state = forecast . swell_maxBreakingHeight [EOL] elif self . type == [string] : [EOL] summary = [string] . format ( forecast . swell_minBreakingHeight , forecast . swell_maxBreakingHeight ) [EOL] self . _state = summary [EOL] if self . hour is None : [EOL] for hour , data in self . data . hourly . items ( ) : [EOL] occurs = hour [EOL] hr_summary = [string] . format ( data . swell_minBreakingHeight , data . swell_maxBreakingHeight , data . swell_unit ) [EOL] self . _attrs [ occurs ] = hr_summary [EOL] [EOL] if self . type != [string] : [EOL] self . _attrs . update ( forecast . attrs ) [EOL] [EOL] [EOL] class MagicSeaweedData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_key , spot_id , units ) : [EOL] [docstring] [EOL] import magicseaweed [EOL] self . _msw = magicseaweed . MSW_Forecast ( api_key , spot_id , None , units ) [EOL] self . currently = None [EOL] self . hourly = { } [EOL] [EOL] [comment] [EOL] self . update = Throttle ( MIN_TIME_BETWEEN_UPDATES ) ( self . _update ) [EOL] [EOL] def _update ( self ) : [EOL] [docstring] [EOL] try : [EOL] forecasts = self . _msw . get_future ( ) [EOL] self . currently = forecasts . data [ [number] ] [EOL] for forecast in forecasts . data [ : [number] ] : [EOL] hour = dt_util . utc_from_timestamp ( forecast . localTimestamp ) . strftime ( [string] ) [EOL] self . hourly [ hour ] = forecast [EOL] except ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , CONF_USERNAME , CONF_PASSWORD , CONF_NAME , CONF_MONITORED_VARIABLES , CONF_VALUE_TEMPLATE , CONF_SENSOR_TYPE , CONF_UNIT_OF_MEASUREMENT ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_MONITORED_VARIABLES , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_SENSOR_TYPE ) : vol . All ( cv . string , vol . In ( SENSOR_TYPES ) ) , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template } ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] hostname = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] login = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] monitored_variables = config . get ( CONF_MONITORED_VARIABLES ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] hp_ilo_data = HpIloData ( hostname , port , login , password ) [EOL] except ValueError as error : [EOL] _LOGGER . error ( error ) [EOL] return False [EOL] [EOL] [comment] [EOL] devices = [ ] [EOL] for monitored_variable in monitored_variables : [EOL] new_device = HpIloSensor ( hass = hass , hp_ilo_data = hp_ilo_data , sensor_name = [string] . format ( config . get ( CONF_NAME ) , monitored_variable [ CONF_NAME ] ) , sensor_type = monitored_variable [ CONF_SENSOR_TYPE ] , sensor_value_template = monitored_variable . get ( CONF_VALUE_TEMPLATE ) , unit_of_measurement = monitored_variable . get ( CONF_UNIT_OF_MEASUREMENT ) ) [EOL] devices . append ( new_device ) [EOL] [EOL] add_entities ( devices , True ) [EOL] [EOL] [EOL] class HpIloSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , hp_ilo_data , sensor_type , sensor_name , sensor_value_template , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . _name = sensor_name [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _ilo_function = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . hp_ilo_data = hp_ilo_data [EOL] [EOL] if sensor_value_template is not None : [EOL] sensor_value_template . hass = hass [EOL] self . _sensor_value_template = sensor_value_template [EOL] [EOL] self . _state = None [EOL] self . _state_attributes = None [EOL] [EOL] _LOGGER . debug ( [string] , self ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _state_attributes [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . hp_ilo_data . update ( ) [EOL] ilo_data = getattr ( self . hp_ilo_data . data , self . _ilo_function ) ( ) [EOL] [EOL] if self . _sensor_value_template is not None : [EOL] ilo_data = self . _sensor_value_template . render ( ilo_data = ilo_data ) [EOL] [EOL] self . _state = ilo_data [EOL] [EOL] [EOL] class HpIloData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , login , password ) : [EOL] [docstring] [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _login = login [EOL] self . _password = password [EOL] [EOL] self . data = None [EOL] [EOL] self . update ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] import hpilo [EOL] [EOL] try : [EOL] self . data = hpilo . Ilo ( hostname = self . _host , login = self . _login , password = self . _password , port = self . _port ) [EOL] except ( hpilo . IloError , hpilo . IloCommunicationError , hpilo . IloLoginFailed ) as error : [EOL] raise ValueError ( [string] . format ( error ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . mychevy import ( EVSensorConfig , DOMAIN as MYCHEVY_DOMAIN , MYCHEVY_ERROR , MYCHEVY_SUCCESS , NOTIFICATION_ID , NOTIFICATION_TITLE , UPDATE_TOPIC , ERROR_TOPIC ) [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] from homeassistant . util import slugify [EOL] [EOL] BATTERY_SENSOR = [string] [EOL] [EOL] SENSORS = [ EVSensorConfig ( [string] , [string] , [string] , [string] ) , EVSensorConfig ( [string] , [string] , [string] , [string] ) , EVSensorConfig ( [string] , [string] ) , EVSensorConfig ( [string] , [string] ) , EVSensorConfig ( [string] , BATTERY_SENSOR , [string] , [string] ) ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] hub = hass . data [ MYCHEVY_DOMAIN ] [EOL] sensors = [ MyChevyStatus ( ) ] [EOL] for sconfig in SENSORS : [EOL] for car in hub . cars : [EOL] sensors . append ( EVSensor ( hub , sconfig , car . vid ) ) [EOL] [EOL] add_entities ( sensors ) [EOL] [EOL] [EOL] class MyChevyStatus ( Entity ) : [EOL] [docstring] [EOL] [EOL] _name = [string] [EOL] _icon = [string] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _state = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( UPDATE_TOPIC , self . success ) [EOL] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( ERROR_TOPIC , self . error ) [EOL] [EOL] @ callback def success ( self ) : [EOL] [docstring] [EOL] if self . _state != MYCHEVY_SUCCESS : [EOL] _LOGGER . debug ( [string] ) [EOL] self . _state = MYCHEVY_SUCCESS [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ callback def error ( self ) : [EOL] [docstring] [EOL] if self . _state != MYCHEVY_ERROR : [EOL] self . hass . components . persistent_notification . create ( [string] [string] , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] self . _state = MYCHEVY_ERROR [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] [EOL] class EVSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , connection , config , car_vid ) : [EOL] [docstring] [EOL] self . _conn = connection [EOL] self . _name = config . name [EOL] self . _attr = config . attr [EOL] self . _unit_of_measurement = config . unit_of_measurement [EOL] self . _icon = config . icon [EOL] self . _state = None [EOL] self . _car_vid = car_vid [EOL] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( [string] . format ( MYCHEVY_DOMAIN , slugify ( self . _car . name ) , slugify ( self . _name ) ) ) [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( UPDATE_TOPIC , self . async_update_callback ) [EOL] [EOL] @ property def _car ( self ) : [EOL] [docstring] [EOL] return self . _conn . get_car ( self . _car_vid ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _attr == BATTERY_SENSOR : [EOL] return icon_for_battery_level ( self . state ) [EOL] return self . _icon [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ callback def async_update_callback ( self ) : [EOL] [docstring] [EOL] if self . _car is not None : [EOL] self . _state = getattr ( self . _car , self . _attr , None ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import time [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_TOKEN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] TIME_STEP = [number] [comment] [EOL] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOKEN ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] token = config . get ( CONF_TOKEN ) [EOL] [EOL] async_add_entities ( [ TOTPSensor ( name , token ) ] , True ) [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] class TOTPSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , token ) : [EOL] [docstring] [EOL] import pyotp [EOL] self . _name = name [EOL] self . _otp = pyotp . TOTP ( token ) [EOL] self . _state = None [EOL] self . _next_expiration = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _call_loop ( ) [EOL] [EOL] @ callback def _call_loop ( self ) : [EOL] self . _state = self . _otp . now ( ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _next_expiration = TIME_STEP - ( time . time ( ) % TIME_STEP ) [EOL] self . hass . loop . call_later ( self . _next_expiration , self . _call_loop ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import List , Any [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] [EOL] import datetime [EOL] import logging [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_DEVICES , CONF_EMAIL , CONF_PASSWORD , STATE_UNKNOWN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SCAN_INTERVAL = datetime . timedelta ( hours = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_EMAIL ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_DEVICES ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) ) } ) [EOL] [EOL] SENSOR_TYPE = [string] [EOL] SENSOR_ROUNDING_PRECISION = [number] [EOL] SENSOR_UNIT_OF_MEASUREMENT = [string] [EOL] SENSOR_ATTRS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from tank_utility import auth [EOL] email = config . get ( CONF_EMAIL ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] devices = config . get ( CONF_DEVICES ) [EOL] [EOL] try : [EOL] token = auth . get_token ( email , password ) [EOL] except requests . exceptions . HTTPError as http_error : [EOL] if ( http_error . response . status_code == requests . codes . unauthorized ) : [comment] [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] all_sensors = [ ] [EOL] for device in devices : [EOL] sensor = TankUtilitySensor ( email , password , token , device ) [EOL] all_sensors . append ( sensor ) [EOL] add_entities ( all_sensors , True ) [EOL] [EOL] [EOL] class TankUtilitySensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , email , password , token , device ) : [EOL] [docstring] [EOL] self . _email = email [EOL] self . _password = password [EOL] self . _token = token [EOL] self . _device = device [EOL] self . _state = STATE_UNKNOWN [EOL] self . _name = [string] + self . device [EOL] self . _unit_of_measurement = SENSOR_UNIT_OF_MEASUREMENT [EOL] self . _attributes = { } [EOL] [EOL] @ property def device ( self ) : [EOL] [docstring] [EOL] return self . _device [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _attributes [EOL] [EOL] def get_data ( self ) : [EOL] [docstring] [EOL] from tank_utility import auth , device [EOL] data = { } [EOL] try : [EOL] data = device . get_device_data ( self . _token , self . device ) [EOL] except requests . exceptions . HTTPError as http_error : [EOL] if ( http_error . response . status_code == requests . codes . unauthorized ) : [comment] [EOL] _LOGGER . info ( [string] ) [EOL] self . _token = auth . get_token ( self . _email , self . _password , force = True ) [EOL] data = device . get_device_data ( self . _token , self . device ) [EOL] else : [EOL] raise http_error [EOL] data . update ( data . pop ( [string] , { } ) ) [EOL] data . update ( data . pop ( [string] , { } ) ) [EOL] return data [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] data = self . get_data ( ) [EOL] self . _state = round ( data [ SENSOR_TYPE ] , SENSOR_ROUNDING_PRECISION ) [EOL] self . _attributes = { k : v for k , v in data . items ( ) if k in SENSOR_ATTRS } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import datetime [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_TYPE [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant import util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] NORTHERN = [string] [EOL] SOUTHERN = [string] [EOL] EQUATOR = [string] [EOL] STATE_SPRING = [string] [EOL] STATE_SUMMER = [string] [EOL] STATE_AUTUMN = [string] [EOL] STATE_WINTER = [string] [EOL] TYPE_ASTRONOMICAL = [string] [EOL] TYPE_METEOROLOGICAL = [string] [EOL] VALID_TYPES = [ TYPE_ASTRONOMICAL , TYPE_METEOROLOGICAL ] [EOL] [EOL] HEMISPHERE_SEASON_SWAP = { STATE_WINTER : STATE_SUMMER , STATE_SPRING : STATE_AUTUMN , STATE_AUTUMN : STATE_SPRING , STATE_SUMMER : STATE_WINTER } [EOL] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_TYPE , default = TYPE_ASTRONOMICAL ) : vol . In ( VALID_TYPES ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] if None in ( hass . config . latitude , hass . config . longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] latitude = util . convert ( hass . config . latitude , float ) [EOL] _type = config . get ( CONF_TYPE ) [EOL] [EOL] if latitude < [number] : [EOL] hemisphere = SOUTHERN [EOL] elif latitude > [number] : [EOL] hemisphere = NORTHERN [EOL] else : [EOL] hemisphere = EQUATOR [EOL] [EOL] _LOGGER . debug ( _type ) [EOL] add_entities ( [ Season ( hass , hemisphere , _type ) ] ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def get_season ( date , hemisphere , season_tracking_type ) : [EOL] [docstring] [EOL] import ephem [EOL] [EOL] if hemisphere == [string] : [EOL] return None [EOL] [EOL] if season_tracking_type == TYPE_ASTRONOMICAL : [EOL] spring_start = ephem . next_equinox ( str ( date . year ) ) . datetime ( ) [EOL] summer_start = ephem . next_solstice ( str ( date . year ) ) . datetime ( ) [EOL] autumn_start = ephem . next_equinox ( spring_start ) . datetime ( ) [EOL] winter_start = ephem . next_solstice ( summer_start ) . datetime ( ) [EOL] else : [EOL] spring_start = datetime ( [number] , [number] , [number] ) . replace ( year = date . year ) [EOL] summer_start = spring_start . replace ( month = [number] ) [EOL] autumn_start = spring_start . replace ( month = [number] ) [EOL] winter_start = spring_start . replace ( month = [number] ) [EOL] [EOL] if spring_start <= date < summer_start : [EOL] season = STATE_SPRING [EOL] elif summer_start <= date < autumn_start : [EOL] season = STATE_SUMMER [EOL] elif autumn_start <= date < winter_start : [EOL] season = STATE_AUTUMN [EOL] elif winter_start <= date or spring_start > date : [EOL] season = STATE_WINTER [EOL] [EOL] [comment] [EOL] if hemisphere == NORTHERN : [EOL] return season [EOL] return HEMISPHERE_SEASON_SWAP . get ( season ) [EOL] [EOL] [EOL] class Season ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , hemisphere , season_tracking_type ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . hemisphere = hemisphere [EOL] self . datetime = datetime . now ( ) [EOL] self . type = season_tracking_type [EOL] self . season = get_season ( self . datetime , self . hemisphere , self . type ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . season [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . datetime = datetime . now ( ) [EOL] self . season = get_season ( self . datetime , self . hemisphere , self . type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Optional , Dict , Generator , List , Any [EOL] import typing [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import datetime , timedelta [EOL] import logging [EOL] [EOL] import async_timeout [EOL] import aiohttp [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_LATITUDE , CONF_LONGITUDE , CONF_MONITORED_CONDITIONS , CONF_NAME , TEMP_CELSIUS ) [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import ( async_track_point_in_utc_time ) [EOL] from homeassistant . util import dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] MEASURED_LABEL = [string] [EOL] TIMEFRAME_LABEL = [string] [EOL] SYMBOL = [string] [EOL] [EOL] [comment] [EOL] SCHEDULE_OK = [number] [EOL] [comment] [EOL] SCHEDULE_NOK = [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , None ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , TEMP_CELSIUS , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , [string] : [ [string] , None , None ] , } [EOL] [EOL] CONF_TIMEFRAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ [string] , [string] ] ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ vol . In ( SENSOR_TYPES . keys ( ) ) ] ) , vol . Inclusive ( CONF_LATITUDE , [string] , [string] ) : cv . latitude , vol . Inclusive ( CONF_LONGITUDE , [string] , [string] ) : cv . longitude , vol . Optional ( CONF_TIMEFRAME , default = [number] ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from homeassistant . components . weather . buienradar import DEFAULT_TIMEFRAME [EOL] [EOL] latitude = config . get ( CONF_LATITUDE , hass . config . latitude ) [EOL] longitude = config . get ( CONF_LONGITUDE , hass . config . longitude ) [EOL] timeframe = config . get ( CONF_TIMEFRAME , DEFAULT_TIMEFRAME ) [EOL] [EOL] if None in ( latitude , longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] coordinates = { CONF_LATITUDE : float ( latitude ) , CONF_LONGITUDE : float ( longitude ) } [EOL] [EOL] _LOGGER . debug ( [string] , coordinates , timeframe ) [EOL] [EOL] dev = [ ] [EOL] for sensor_type in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( BrSensor ( sensor_type , config . get ( CONF_NAME , [string] ) , coordinates ) ) [EOL] async_add_entities ( dev ) [EOL] [EOL] data = BrData ( hass , coordinates , timeframe , dev ) [EOL] [comment] [EOL] yield from data . schedule_update ( [number] ) [EOL] [EOL] [EOL] class BrSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensor_type , client_name , coordinates ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( PRECIPITATION_FORECAST , CONDITION ) [EOL] [EOL] self . client_name = client_name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ self . type ] [ [number] ] [EOL] self . _entity_picture = None [EOL] self . _attribution = None [EOL] self . _measured = None [EOL] self . _stationname = None [EOL] self . _unique_id = self . uid ( coordinates ) [EOL] [EOL] [comment] [EOL] self . _force_update = self . type != SYMBOL and not self . type . startswith ( CONDITION ) [EOL] [EOL] if self . type . startswith ( PRECIPITATION_FORECAST ) : [EOL] self . _timeframe = None [EOL] [EOL] def uid ( self , coordinates ) : [EOL] [docstring] [EOL] [comment] [EOL] return [string] % ( coordinates [ CONF_LATITUDE ] , coordinates [ CONF_LONGITUDE ] , self . type ) [EOL] [EOL] def load_data ( self , data ) : [EOL] [docstring] [EOL] [comment] [EOL] from buienradar . buienradar import ( ATTRIBUTION , CONDITION , CONDCODE , DETAILED , EXACT , EXACTNL , FORECAST , IMAGE , MEASURED , PRECIPITATION_FORECAST , STATIONNAME , TIMEFRAME ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] if self . _measured == data . get ( MEASURED ) : [EOL] return False [EOL] [EOL] self . _attribution = data . get ( ATTRIBUTION ) [EOL] self . _stationname = data . get ( STATIONNAME ) [EOL] self . _measured = data . get ( MEASURED ) [EOL] [EOL] if self . type . endswith ( [string] ) or self . type . endswith ( [string] ) or self . type . endswith ( [string] ) or self . type . endswith ( [string] ) or self . type . endswith ( [string] ) : [EOL] [EOL] fcday = [number] [EOL] if self . type . endswith ( [string] ) : [EOL] fcday = [number] [EOL] if self . type . endswith ( [string] ) : [EOL] fcday = [number] [EOL] if self . type . endswith ( [string] ) : [EOL] fcday = [number] [EOL] if self . type . endswith ( [string] ) : [EOL] fcday = [number] [EOL] [EOL] [comment] [EOL] if self . type . startswith ( SYMBOL ) or self . type . startswith ( CONDITION ) : [EOL] try : [EOL] condition = data . get ( FORECAST ) [ fcday ] . get ( CONDITION ) [EOL] except IndexError : [EOL] _LOGGER . warning ( [string] , fcday ) [EOL] return False [EOL] [EOL] if condition : [EOL] new_state = condition . get ( CONDITION , None ) [EOL] if self . type . startswith ( SYMBOL ) : [EOL] new_state = condition . get ( EXACTNL , None ) [EOL] if self . type . startswith ( [string] ) : [EOL] new_state = condition . get ( CONDCODE , None ) [EOL] if self . type . startswith ( [string] ) : [EOL] new_state = condition . get ( DETAILED , None ) [EOL] if self . type . startswith ( [string] ) : [EOL] new_state = condition . get ( EXACT , None ) [EOL] [EOL] img = condition . get ( IMAGE , None ) [EOL] [EOL] if new_state != self . _state or img != self . _entity_picture : [EOL] self . _state = new_state [EOL] self . _entity_picture = img [EOL] return True [EOL] return False [EOL] [EOL] try : [EOL] self . _state = data . get ( FORECAST ) [ fcday ] . get ( self . type [ : - [number] ] ) [EOL] return True [EOL] except IndexError : [EOL] _LOGGER . warning ( [string] , fcday ) [EOL] return False [EOL] [EOL] if self . type == SYMBOL or self . type . startswith ( CONDITION ) : [EOL] [comment] [EOL] condition = data . get ( CONDITION , None ) [EOL] if condition : [EOL] if self . type == SYMBOL : [EOL] new_state = condition . get ( EXACTNL , None ) [EOL] if self . type == CONDITION : [EOL] new_state = condition . get ( CONDITION , None ) [EOL] if self . type == [string] : [EOL] new_state = condition . get ( CONDCODE , None ) [EOL] if self . type == [string] : [EOL] new_state = condition . get ( DETAILED , None ) [EOL] if self . type == [string] : [EOL] new_state = condition . get ( EXACT , None ) [EOL] [EOL] img = condition . get ( IMAGE , None ) [EOL] [EOL] if new_state != self . _state or img != self . _entity_picture : [EOL] self . _state = new_state [EOL] self . _entity_picture = img [EOL] return True [EOL] [EOL] return False [EOL] [EOL] if self . type . startswith ( PRECIPITATION_FORECAST ) : [EOL] [comment] [EOL] nested = data . get ( PRECIPITATION_FORECAST ) [EOL] self . _timeframe = nested . get ( TIMEFRAME ) [EOL] self . _state = nested . get ( self . type [ len ( PRECIPITATION_FORECAST ) + [number] : ] ) [EOL] return True [EOL] [EOL] [comment] [EOL] self . _state = data . get ( self . type ) [EOL] return True [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] return self . _attribution [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def entity_picture ( self ) : [EOL] [docstring] [EOL] return self . _entity_picture [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( PRECIPITATION_FORECAST ) [EOL] [EOL] if self . type . startswith ( PRECIPITATION_FORECAST ) : [EOL] result = { ATTR_ATTRIBUTION : self . _attribution } [EOL] if self . _timeframe is not None : [EOL] result [ TIMEFRAME_LABEL ] = [string] % ( self . _timeframe ) [EOL] [EOL] return result [EOL] [EOL] result = { ATTR_ATTRIBUTION : self . _attribution , SENSOR_TYPES [ [string] ] [ [number] ] : self . _stationname , } [EOL] if self . _measured is not None : [EOL] [comment] [EOL] local_dt = dt_util . as_local ( self . _measured ) [EOL] result [ MEASURED_LABEL ] = local_dt . strftime ( [string] ) [EOL] [EOL] return result [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return SENSOR_TYPES [ self . type ] [ [number] ] [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return self . _force_update [EOL] [EOL] [EOL] class BrData : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , coordinates , timeframe , devices ) : [EOL] [docstring] [EOL] self . devices = devices [EOL] self . data = { } [EOL] self . hass = hass [EOL] self . coordinates = coordinates [EOL] self . timeframe = timeframe [EOL] [EOL] @ asyncio . coroutine def update_devices ( self ) : [EOL] [docstring] [EOL] if self . devices : [EOL] tasks = [ ] [EOL] [comment] [EOL] for dev in self . devices : [EOL] if dev . load_data ( self . data ) : [EOL] tasks . append ( dev . async_update_ha_state ( ) ) [EOL] [EOL] if tasks : [EOL] yield from asyncio . wait ( tasks , loop = self . hass . loop ) [EOL] [EOL] @ asyncio . coroutine def schedule_update ( self , minute = [number] ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , minute ) [EOL] nxt = dt_util . utcnow ( ) + timedelta ( minutes = minute ) [EOL] async_track_point_in_utc_time ( self . hass , self . async_update , nxt ) [EOL] [EOL] @ asyncio . coroutine def get_data ( self , url ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( CONTENT , MESSAGE , STATUS_CODE , SUCCESS ) [EOL] [EOL] _LOGGER . debug ( [string] , url ) [EOL] result = { SUCCESS : False , MESSAGE : None } [EOL] resp = None [EOL] try : [EOL] websession = async_get_clientsession ( self . hass ) [EOL] with async_timeout . timeout ( [number] , loop = self . hass . loop ) : [EOL] resp = yield from websession . get ( url ) [EOL] [EOL] result [ STATUS_CODE ] = resp . status [EOL] result [ CONTENT ] = yield from resp . text ( ) [EOL] if resp . status == [number] : [EOL] result [ SUCCESS ] = True [EOL] else : [EOL] result [ MESSAGE ] = [string] % ( resp . status ) [EOL] [EOL] return result [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) as err : [EOL] result [ MESSAGE ] = [string] % err [EOL] return result [EOL] finally : [EOL] if resp is not None : [EOL] yield from resp . release ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self , * _ ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ( parse_data , CONTENT , DATA , MESSAGE , STATUS_CODE , SUCCESS ) [EOL] [EOL] content = yield from self . get_data ( [string] ) [EOL] if not content . get ( SUCCESS , False ) : [EOL] content = yield from self . get_data ( [string] ) [EOL] [EOL] if content . get ( SUCCESS ) is not True : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , content . get ( MESSAGE ) , content . get ( STATUS_CODE ) , ) [EOL] [comment] [EOL] yield from self . schedule_update ( SCHEDULE_NOK ) [EOL] return [EOL] [EOL] [comment] [EOL] rainurl = [string] [EOL] rainurl = rainurl . format ( round ( self . coordinates [ CONF_LATITUDE ] , [number] ) , round ( self . coordinates [ CONF_LONGITUDE ] , [number] ) ) [EOL] raincontent = yield from self . get_data ( rainurl ) [EOL] [EOL] if raincontent . get ( SUCCESS ) is not True : [EOL] [comment] [EOL] _LOGGER . warning ( [string] [string] , raincontent . get ( MESSAGE ) , raincontent . get ( STATUS_CODE ) , ) [EOL] [comment] [EOL] yield from self . schedule_update ( SCHEDULE_NOK ) [EOL] return [EOL] [EOL] result = parse_data ( content . get ( CONTENT ) , raincontent . get ( CONTENT ) , self . coordinates [ CONF_LATITUDE ] , self . coordinates [ CONF_LONGITUDE ] , self . timeframe ) [EOL] [EOL] _LOGGER . debug ( [string] , result ) [EOL] if result . get ( SUCCESS ) is not True : [EOL] if int ( datetime . now ( ) . strftime ( [string] ) ) > [number] : [EOL] _LOGGER . warning ( [string] [string] , result . get ( MESSAGE ) , ) [EOL] yield from self . schedule_update ( SCHEDULE_NOK ) [EOL] return [EOL] [EOL] self . data = result . get ( DATA ) [EOL] yield from self . update_devices ( ) [EOL] yield from self . schedule_update ( SCHEDULE_OK ) [EOL] [EOL] @ property def attribution ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import ATTRIBUTION [EOL] return self . data . get ( ATTRIBUTION ) [EOL] [EOL] @ property def stationname ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import STATIONNAME [EOL] return self . data . get ( STATIONNAME ) [EOL] [EOL] @ property def condition ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import CONDITION [EOL] return self . data . get ( CONDITION ) [EOL] [EOL] @ property def temperature ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import TEMPERATURE [EOL] try : [EOL] return float ( self . data . get ( TEMPERATURE ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def pressure ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import PRESSURE [EOL] try : [EOL] return float ( self . data . get ( PRESSURE ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def humidity ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import HUMIDITY [EOL] try : [EOL] return int ( self . data . get ( HUMIDITY ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def visibility ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import VISIBILITY [EOL] try : [EOL] return int ( self . data . get ( VISIBILITY ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def wind_speed ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import WINDSPEED [EOL] try : [EOL] return float ( self . data . get ( WINDSPEED ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def wind_bearing ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import WINDAZIMUTH [EOL] try : [EOL] return int ( self . data . get ( WINDAZIMUTH ) ) [EOL] except ( ValueError , TypeError ) : [EOL] return None [EOL] [EOL] @ property def forecast ( self ) : [EOL] [docstring] [EOL] from buienradar . buienradar import FORECAST [EOL] return self . data . get ( FORECAST ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,typing.Optional[builtins.bool]]$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_FORCE_UPDATE , CONF_MONITORED_CONDITIONS , CONF_NAME , CONF_MAC ) [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ADAPTER = [string] [EOL] CONF_CACHE = [string] [EOL] CONF_MEDIAN = [string] [EOL] CONF_RETRIES = [string] [EOL] CONF_TIMEOUT = [string] [EOL] [EOL] DEFAULT_ADAPTER = [string] [EOL] DEFAULT_UPDATE_INTERVAL = [number] [EOL] DEFAULT_FORCE_UPDATE = False [EOL] DEFAULT_MEDIAN = [number] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_RETRIES = [number] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MEDIAN , default = DEFAULT_MEDIAN ) : cv . positive_int , vol . Optional ( CONF_FORCE_UPDATE , default = DEFAULT_FORCE_UPDATE ) : cv . boolean , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , vol . Optional ( CONF_RETRIES , default = DEFAULT_RETRIES ) : cv . positive_int , vol . Optional ( CONF_CACHE , default = DEFAULT_UPDATE_INTERVAL ) : cv . positive_int , vol . Optional ( CONF_ADAPTER , default = DEFAULT_ADAPTER ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from mitemp_bt import mitemp_bt_poller [EOL] try : [EOL] import bluepy . btle [comment] [EOL] from btlewrap import BluepyBackend [EOL] backend = BluepyBackend [EOL] except ImportError : [EOL] from btlewrap import GatttoolBackend [EOL] backend = GatttoolBackend [EOL] _LOGGER . debug ( [string] , backend . __name__ ) [EOL] [EOL] cache = config . get ( CONF_CACHE ) [EOL] poller = mitemp_bt_poller . MiTempBtPoller ( config . get ( CONF_MAC ) , cache_timeout = cache , adapter = config . get ( CONF_ADAPTER ) , backend = backend ) [EOL] force_update = config . get ( CONF_FORCE_UPDATE ) [EOL] median = config . get ( CONF_MEDIAN ) [EOL] poller . ble_timeout = config . get ( CONF_TIMEOUT ) [EOL] poller . retries = config . get ( CONF_RETRIES ) [EOL] [EOL] devs = [ ] [EOL] [EOL] for parameter in config [ CONF_MONITORED_CONDITIONS ] : [EOL] name = SENSOR_TYPES [ parameter ] [ [number] ] [EOL] unit = SENSOR_TYPES [ parameter ] [ [number] ] [EOL] [EOL] prefix = config . get ( CONF_NAME ) [EOL] if prefix : [EOL] name = [string] . format ( prefix , name ) [EOL] [EOL] devs . append ( MiTempBtSensor ( poller , parameter , name , unit , force_update , median ) ) [EOL] [EOL] add_entities ( devs ) [EOL] [EOL] [EOL] class MiTempBtSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , poller , parameter , name , unit , force_update , median ) : [EOL] [docstring] [EOL] self . poller = poller [EOL] self . parameter = parameter [EOL] self . _unit = unit [EOL] self . _name = name [EOL] self . _state = None [EOL] self . data = [ ] [EOL] self . _force_update = force_update [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . median_count = median [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return self . _force_update [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from btlewrap . base import BluetoothBackendException [EOL] try : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] data = self . poller . parameter_value ( self . parameter ) [EOL] except IOError as ioerr : [EOL] _LOGGER . warning ( [string] , ioerr ) [EOL] return [EOL] except BluetoothBackendException as bterror : [EOL] _LOGGER . warning ( [string] , bterror ) [EOL] return [EOL] [EOL] if data is not None : [EOL] _LOGGER . debug ( [string] , self . name , data ) [EOL] self . data . append ( data ) [EOL] else : [EOL] _LOGGER . warning ( [string] , self . name ) [EOL] [comment] [EOL] [comment] [EOL] if self . data : [EOL] self . data = self . data [ [number] : ] [EOL] else : [EOL] self . _state = None [EOL] return [EOL] [EOL] if len ( self . data ) > self . median_count : [EOL] self . data = self . data [ [number] : ] [EOL] [EOL] if len ( self . data ) == self . median_count : [EOL] median = sorted ( self . data ) [ int ( ( self . median_count - [number] ) / [number] ) ] [EOL] _LOGGER . debug ( [string] , median ) [EOL] self . _state = median [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . dyson import DYSON_DEVICES [EOL] from homeassistant . const import STATE_OFF , TEMP_CELSIUS [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SENSOR_UNITS = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] devices = [ ] [EOL] unit = hass . config . units . temperature_unit [EOL] [comment] [EOL] from libpurecoollink . dyson_pure_cool_link import DysonPureCoolLink [EOL] for device in [ d for d in hass . data [ DYSON_DEVICES ] if isinstance ( d , DysonPureCoolLink ) ] : [EOL] devices . append ( DysonFilterLifeSensor ( hass , device ) ) [EOL] devices . append ( DysonDustSensor ( hass , device ) ) [EOL] devices . append ( DysonHumiditySensor ( hass , device ) ) [EOL] devices . append ( DysonTemperatureSensor ( hass , device , unit ) ) [EOL] devices . append ( DysonAirQualitySensor ( hass , device ) ) [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class DysonSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . _device = device [EOL] self . _old_value = None [EOL] self . _name = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . async_add_job ( self . _device . add_message_listener , self . on_message ) [EOL] [EOL] def on_message ( self , message ) : [EOL] [docstring] [EOL] [comment] [EOL] if self . _old_value is None or self . _old_value != self . state : [EOL] _LOGGER . debug ( [string] , self . name , message ) [EOL] self . _old_value = self . state [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] [EOL] class DysonFilterLifeSensor ( DysonSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] DysonSensor . __init__ ( self , hass , device ) [EOL] self . _name = [string] . format ( self . _device . name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . state : [EOL] return int ( self . _device . state . filter_life ) [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_UNITS [ [string] ] [EOL] [EOL] [EOL] class DysonDustSensor ( DysonSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] DysonSensor . __init__ ( self , hass , device ) [EOL] self . _name = [string] . format ( self . _device . name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . environmental_state : [EOL] return self . _device . environmental_state . dust [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_UNITS [ [string] ] [EOL] [EOL] [EOL] class DysonHumiditySensor ( DysonSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] DysonSensor . __init__ ( self , hass , device ) [EOL] self . _name = [string] . format ( self . _device . name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . environmental_state : [EOL] if self . _device . environmental_state . humidity == [number] : [EOL] return STATE_OFF [EOL] return self . _device . environmental_state . humidity [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_UNITS [ [string] ] [EOL] [EOL] [EOL] class DysonTemperatureSensor ( DysonSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device , unit ) : [EOL] [docstring] [EOL] DysonSensor . __init__ ( self , hass , device ) [EOL] self . _name = [string] . format ( self . _device . name ) [EOL] self . _unit = unit [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . environmental_state : [EOL] temperature_kelvin = self . _device . environmental_state . temperature [EOL] if temperature_kelvin == [number] : [EOL] return STATE_OFF [EOL] if self . _unit == TEMP_CELSIUS : [EOL] return float ( [string] . format ( temperature_kelvin - [number] ) ) [EOL] return float ( [string] . format ( temperature_kelvin * [number] / [number] - [number] ) ) [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] [EOL] class DysonAirQualitySensor ( DysonSensor ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] DysonSensor . __init__ ( self , hass , device ) [EOL] self . _name = [string] . format ( self . _device . name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _device . environmental_state : [EOL] return self . _device . environmental_state . volatil_organic_compounds [EOL] return None [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return SENSOR_UNITS [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . raincloud import ( DATA_RAINCLOUD , ICON_MAP , RainCloudEntity , SENSORS ) [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_MONITORED_CONDITIONS [EOL] from homeassistant . helpers . icon import icon_for_battery_level [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSORS ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSORS ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] raincloud = hass . data [ DATA_RAINCLOUD ] . data [EOL] [EOL] sensors = [ ] [EOL] for sensor_type in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] if sensor_type == [string] : [EOL] sensors . append ( RainCloudSensor ( raincloud . controller . faucet , sensor_type ) ) [EOL] else : [EOL] [comment] [EOL] for zone in raincloud . controller . faucet . zones : [EOL] sensors . append ( RainCloudSensor ( zone , sensor_type ) ) [EOL] [EOL] add_entities ( sensors , True ) [EOL] return True [EOL] [EOL] [EOL] class RainCloudSensor ( RainCloudEntity ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , self . _name ) [EOL] if self . _sensor_type == [string] : [EOL] self . _state = self . data . battery [EOL] else : [EOL] self . _state = getattr ( self . data , self . _sensor_type ) [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _sensor_type == [string] and self . _state is not None : [EOL] return icon_for_battery_level ( battery_level = int ( self . _state ) , charging = False ) [EOL] return ICON_MAP . get ( self . _sensor_type ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List , Dict [EOL] import typing [EOL] import datetime [EOL] import logging [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_EMAIL , CONF_PASSWORD , CONF_MONITORED_CONDITIONS ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ACTIVE_NAME = [string] [EOL] PRODUCTION_NAME = [string] [EOL] CONSUMPTION_NAME = [string] [EOL] [EOL] ACTIVE_TYPE = [string] [EOL] [EOL] [EOL] class SensorConfig : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , sensor_type ) : [EOL] [docstring] [EOL] self . name = name [EOL] self . sensor_type = sensor_type [EOL] [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : SensorConfig ( ACTIVE_NAME , ACTIVE_TYPE ) , [string] : SensorConfig ( [string] , [string] ) , [string] : SensorConfig ( [string] , [string] ) , [string] : SensorConfig ( [string] , [string] ) , [string] : SensorConfig ( [string] , [string] ) } [EOL] [EOL] [comment] [EOL] SENSOR_VARIANTS = [ PRODUCTION_NAME . lower ( ) , CONSUMPTION_NAME . lower ( ) ] [EOL] [EOL] [comment] [EOL] VALID_SENSORS = [ [string] % ( typ , var ) for typ in SENSOR_TYPES for var in SENSOR_VARIANTS ] [EOL] [EOL] ICON = [string] [EOL] [EOL] MIN_TIME_BETWEEN_DAILY_UPDATES = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_ACTIVE_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_EMAIL ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Required ( CONF_MONITORED_CONDITIONS ) : vol . All ( cv . ensure_list , vol . Length ( min = [number] ) , [ vol . In ( VALID_SENSORS ) ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from sense_energy import Senseable [EOL] [EOL] username = config . get ( CONF_EMAIL ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] data = Senseable ( username , password ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_DAILY_UPDATES ) def update_trends ( ) : [EOL] [docstring] [EOL] data . update_trend_data ( ) [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_ACTIVE_UPDATES ) def update_active ( ) : [EOL] [docstring] [EOL] data . get_realtime ( ) [EOL] [EOL] devices = [ ] [EOL] for sensor in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] config_name , prod = sensor . rsplit ( [string] , [number] ) [EOL] name = SENSOR_TYPES [ config_name ] . name [EOL] sensor_type = SENSOR_TYPES [ config_name ] . sensor_type [EOL] is_production = prod == PRODUCTION_NAME . lower ( ) [EOL] if sensor_type == ACTIVE_TYPE : [EOL] update_call = update_active [EOL] else : [EOL] update_call = update_trends [EOL] devices . append ( Sense ( data , name , sensor_type , is_production , update_call ) ) [EOL] [EOL] add_entities ( devices ) [EOL] [EOL] [EOL] class Sense ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , sensor_type , is_production , update_call ) : [EOL] [docstring] [EOL] name_type = PRODUCTION_NAME if is_production else CONSUMPTION_NAME [EOL] self . _name = [string] % ( name , name_type ) [EOL] self . _data = data [EOL] self . _sensor_type = sensor_type [EOL] self . update_sensor = update_call [EOL] self . _is_production = is_production [EOL] self . _state = None [EOL] [EOL] if sensor_type == ACTIVE_TYPE : [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _unit_of_measurement = [string] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from sense_energy import SenseAPITimeoutException [EOL] try : [EOL] self . update_sensor ( ) [EOL] except SenseAPITimeoutException : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] if self . _sensor_type == ACTIVE_TYPE : [EOL] if self . _is_production : [EOL] self . _state = round ( self . _data . active_solar_power ) [EOL] else : [EOL] self . _state = round ( self . _data . active_power ) [EOL] else : [EOL] state = self . _data . get_trend ( self . _sensor_type , self . _is_production ) [EOL] self . _state = round ( state , [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,homeassistant.components.sensor.sense.SensorConfig]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,homeassistant.components.sensor.sense.SensorConfig]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,homeassistant.components.sensor.sense.SensorConfig]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,homeassistant.components.sensor.sense.SensorConfig]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0
from typing import List , Any [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ATTR_ATTRIBUTION , CONF_NAME [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_DEPARTURE_TIME1 = [string] [EOL] ATTR_DEPARTURE_TIME2 = [string] [EOL] ATTR_DURATION = [string] [EOL] ATTR_PLATFORM = [string] [EOL] ATTR_REMAINING_TIME = [string] [EOL] ATTR_START = [string] [EOL] ATTR_TARGET = [string] [EOL] ATTR_TRAIN_NUMBER = [string] [EOL] ATTR_TRANSFERS = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_DESTINATION = [string] [EOL] CONF_START = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] ICON = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DESTINATION ) : cv . string , vol . Required ( CONF_START ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_entities , discovery_info = None ) : [EOL] [docstring] [EOL] from opendata_transport import OpendataTransport , exceptions [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] start = config . get ( CONF_START ) [EOL] destination = config . get ( CONF_DESTINATION ) [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] opendata = OpendataTransport ( start , destination , hass . loop , session ) [EOL] [EOL] try : [EOL] await opendata . async_get_data ( ) [EOL] except exceptions . OpendataTransportError : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return [EOL] [EOL] async_add_entities ( [ SwissPublicTransportSensor ( opendata , start , destination , name ) ] ) [EOL] [EOL] [EOL] class SwissPublicTransportSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , opendata , start , destination , name ) : [EOL] [docstring] [EOL] self . _opendata = opendata [EOL] self . _name = name [EOL] self . _from = start [EOL] self . _to = destination [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _opendata . connections [ [number] ] [ [string] ] \ [EOL] if self . _opendata is not None else None [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _opendata is None : [EOL] return [EOL] [EOL] remaining_time = dt_util . parse_datetime ( self . _opendata . connections [ [number] ] [ [string] ] ) - dt_util . as_local ( dt_util . utcnow ( ) ) [EOL] [EOL] attr = { ATTR_TRAIN_NUMBER : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_PLATFORM : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_TRANSFERS : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_DURATION : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_DEPARTURE_TIME1 : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_DEPARTURE_TIME2 : self . _opendata . connections [ [number] ] [ [string] ] , ATTR_START : self . _opendata . from_name , ATTR_TARGET : self . _opendata . to_name , ATTR_REMAINING_TIME : [string] . format ( remaining_time ) , ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] return attr [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from opendata_transport . exceptions import OpendataTransportError [EOL] [EOL] try : [EOL] await self . _opendata . async_get_data ( ) [EOL] except OpendataTransportError : [EOL] _LOGGER . error ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Set , Any [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_NAME , CONF_LATITUDE , CONF_LONGITUDE , CONF_ICON , CONF_RADIUS ) [EOL] from homeassistant . helpers import config_per_platform [EOL] from homeassistant . helpers . entity import async_generate_entity_id [EOL] from homeassistant . util import slugify [EOL] [EOL] from . config_flow import configured_zones [EOL] from . const import CONF_PASSIVE , DOMAIN , HOME_ZONE [EOL] from . zone import Zone [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PASSIVE = False [EOL] DEFAULT_RADIUS = [number] [EOL] [EOL] ENTITY_ID_FORMAT = [string] [EOL] ENTITY_ID_HOME = ENTITY_ID_FORMAT . format ( HOME_ZONE ) [EOL] [EOL] ICON_HOME = [string] [EOL] ICON_IMPORT = [string] [EOL] [EOL] [comment] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Required ( CONF_LATITUDE ) : cv . latitude , vol . Required ( CONF_LONGITUDE ) : cv . longitude , vol . Optional ( CONF_RADIUS , default = DEFAULT_RADIUS ) : vol . Coerce ( float ) , vol . Optional ( CONF_PASSIVE , default = DEFAULT_PASSIVE ) : cv . boolean , vol . Optional ( CONF_ICON ) : cv . icon , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] hass . data [ DOMAIN ] = { } [EOL] entities = set ( ) [EOL] zone_entries = configured_zones ( hass ) [EOL] for _ , entry in config_per_platform ( config , DOMAIN ) : [EOL] if slugify ( entry [ CONF_NAME ] ) not in zone_entries : [EOL] zone = Zone ( hass , entry [ CONF_NAME ] , entry [ CONF_LATITUDE ] , entry [ CONF_LONGITUDE ] , entry . get ( CONF_RADIUS ) , entry . get ( CONF_ICON ) , entry . get ( CONF_PASSIVE ) ) [EOL] zone . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , entry [ CONF_NAME ] , entities ) [EOL] hass . async_add_job ( zone . async_update_ha_state ( ) ) [EOL] entities . add ( zone . entity_id ) [EOL] [EOL] if ENTITY_ID_HOME not in entities and HOME_ZONE not in zone_entries : [EOL] zone = Zone ( hass , hass . config . location_name , hass . config . latitude , hass . config . longitude , DEFAULT_RADIUS , ICON_HOME , False ) [EOL] zone . entity_id = ENTITY_ID_HOME [EOL] hass . async_add_job ( zone . async_update_ha_state ( ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , config_entry ) : [EOL] [docstring] [EOL] entry = config_entry . data [EOL] name = entry [ CONF_NAME ] [EOL] zone = Zone ( hass , name , entry [ CONF_LATITUDE ] , entry [ CONF_LONGITUDE ] , entry . get ( CONF_RADIUS , DEFAULT_RADIUS ) , entry . get ( CONF_ICON ) , entry . get ( CONF_PASSIVE , DEFAULT_PASSIVE ) ) [EOL] zone . entity_id = async_generate_entity_id ( ENTITY_ID_FORMAT , name , None , hass ) [EOL] hass . async_add_job ( zone . async_update_ha_state ( ) ) [EOL] hass . data [ DOMAIN ] [ slugify ( name ) ] = zone [EOL] return True [EOL] [EOL] [EOL] async def async_unload_entry ( hass , config_entry ) : [EOL] [docstring] [EOL] zones = hass . data [ DOMAIN ] [EOL] name = slugify ( config_entry . data [ CONF_NAME ] ) [EOL] zone = zones . pop ( name ) [EOL] await zone . async_remove ( ) [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type , Dict [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] [docstring] [EOL] import logging [EOL] import uuid [EOL] [EOL] import attr [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DATA_REGISTRY = [string] [EOL] [EOL] STORAGE_KEY = [string] [EOL] STORAGE_VERSION = [number] [EOL] SAVE_DELAY = [number] [EOL] [EOL] CONNECTION_NETWORK_MAC = [string] [EOL] CONNECTION_ZIGBEE = [string] [EOL] [EOL] [EOL] @ attr . s ( slots = True , frozen = True ) class DeviceEntry : [EOL] [docstring] [EOL] [EOL] config_entries = attr . ib ( type = set , converter = set ) [EOL] connections = attr . ib ( type = set , converter = set ) [EOL] identifiers = attr . ib ( type = set , converter = set ) [EOL] manufacturer = attr . ib ( type = str ) [EOL] model = attr . ib ( type = str ) [EOL] name = attr . ib ( type = str , default = None ) [EOL] sw_version = attr . ib ( type = str , default = None ) [EOL] id = attr . ib ( type = str , default = attr . Factory ( lambda : uuid . uuid4 ( ) . hex ) ) [EOL] [EOL] [EOL] class DeviceRegistry : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . devices = None [EOL] self . _store = hass . helpers . storage . Store ( STORAGE_VERSION , STORAGE_KEY ) [EOL] [EOL] @ callback def async_get_device ( self , identifiers , connections ) : [EOL] [docstring] [EOL] for device in self . devices : [EOL] if any ( iden in device . identifiers for iden in identifiers ) or any ( conn in device . connections for conn in connections ) : [EOL] return device [EOL] return None [EOL] [EOL] @ callback def async_get_or_create ( self , * , config_entry , connections , identifiers , manufacturer , model , name = None , sw_version = None ) : [EOL] [docstring] [EOL] if not identifiers and not connections : [EOL] return None [EOL] [EOL] device = self . async_get_device ( identifiers , connections ) [EOL] [EOL] if device is not None : [EOL] if config_entry not in device . config_entries : [EOL] device . config_entries . add ( config_entry ) [EOL] self . async_schedule_save ( ) [EOL] return device [EOL] [EOL] device = DeviceEntry ( config_entries = [ config_entry ] , connections = connections , identifiers = identifiers , manufacturer = manufacturer , model = model , name = name , sw_version = sw_version ) [EOL] self . devices . append ( device ) [EOL] [EOL] self . async_schedule_save ( ) [EOL] [EOL] return device [EOL] [EOL] async def async_load ( self ) : [EOL] [docstring] [EOL] devices = await self . _store . async_load ( ) [EOL] [EOL] if devices is None : [EOL] self . devices = [ ] [EOL] return [EOL] [EOL] self . devices = [ DeviceEntry ( config_entries = device [ [string] ] , connections = { tuple ( conn ) for conn in device [ [string] ] } , identifiers = { tuple ( iden ) for iden in device [ [string] ] } , manufacturer = device [ [string] ] , model = device [ [string] ] , name = device [ [string] ] , sw_version = device [ [string] ] , id = device [ [string] ] , ) for device in devices [ [string] ] ] [EOL] [EOL] @ callback def async_schedule_save ( self ) : [EOL] [docstring] [EOL] self . _store . async_delay_save ( self . _data_to_save , SAVE_DELAY ) [EOL] [EOL] @ callback def _data_to_save ( self ) : [EOL] [docstring] [EOL] data = { } [EOL] [EOL] data [ [string] ] = [ { [string] : list ( entry . config_entries ) , [string] : list ( entry . connections ) , [string] : list ( entry . identifiers ) , [string] : entry . manufacturer , [string] : entry . model , [string] : entry . name , [string] : entry . sw_version , [string] : entry . id , } for entry in self . devices ] [EOL] [EOL] return data [EOL] [EOL] [EOL] @ bind_hass async def async_get_registry ( hass ) : [EOL] [docstring] [EOL] task = hass . data . get ( DATA_REGISTRY ) [EOL] [EOL] if task is None : [EOL] async def _load_reg ( ) : [EOL] registry = DeviceRegistry ( hass ) [EOL] await registry . async_load ( ) [EOL] return registry [EOL] [EOL] task = hass . data [ DATA_REGISTRY ] = hass . async_create_task ( _load_reg ( ) ) [EOL] [EOL] return await task [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 0 0 $homeassistant.helpers.device_registry.DeviceEntry$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0