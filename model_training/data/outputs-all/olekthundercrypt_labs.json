	0
from typing import List , Counter , OrderedDict , Any , Tuple , Dict [EOL] import builtins [EOL] import labs [EOL] import collections [EOL] import typing [EOL] import operator [EOL] from collections import Counter [EOL] [EOL] from labs . utils import BiMap , frequencies , symbol_difference , without_newlines [EOL] [EOL] [EOL] def compliancy_index ( iterable ) : [EOL] [docstring] [EOL] text = [string] . join ( iterable ) [EOL] n = len ( text ) [EOL] counter = Counter ( text ) [EOL] return ( [number] / ( n * ( n - [number] ) ) ) * sum ( x * ( x - [number] ) for x in counter . values ( ) ) [EOL] [EOL] [EOL] def split_to_blocks ( string , distance ) : [EOL] [docstring] [EOL] return [ [ string [ i + offset ] for offset in range ( [number] , len ( string ) - i , distance ) ] for i in range ( distance ) ] [EOL] [EOL] [EOL] def get_index_for_file ( filename ) : [EOL] [docstring] [EOL] with open ( filename , encoding = [string] ) as f : [EOL] return compliancy_index ( without_newlines ( f ) ) [EOL] [EOL] [EOL] def equal_symbols_on_equal_distances ( iterable , from_ = [number] , to = [number] ) : [EOL] [docstring] [EOL] key_indices = { } [EOL] for key_len in range ( from_ , to ) : [EOL] key_indices [ key_len ] = [number] [EOL] for block in split_to_blocks ( iterable , key_len ) : [EOL] for i , _ in enumerate ( block [ : - [number] ] ) : [EOL] if block [ i ] == block [ i + [number] ] : [EOL] key_indices [ key_len ] += [number] [EOL] return key_indices [EOL] [EOL] [EOL] def guess_key_by_len ( iterable , key_len , true_frequencies , alphabet , desired_idx , possible_mistake = [number] , ) : [EOL] [docstring] [EOL] alphabet = BiMap ( enumerate ( alphabet ) ) [EOL] ciphertext = [string] . join ( iterable ) [EOL] blocks = split_to_blocks ( ciphertext , key_len ) [EOL] key = [ ] [EOL] for block in blocks : [EOL] block_frequencies = frequencies ( block ) [EOL] most_possible_keys = { } [EOL] [comment] [EOL] for c_cipher , c_true in zip ( block_frequencies . keys ( ) , true_frequencies . keys ( ) ) : [EOL] c_key = symbol_difference ( c_cipher , c_true , alphabet ) [EOL] if c_key in most_possible_keys : [EOL] most_possible_keys [ c_key ] += [number] [EOL] else : [EOL] most_possible_keys [ c_key ] = [number] [EOL] temp = sorted ( most_possible_keys . items ( ) , key = operator . itemgetter ( [number] ) , reverse = True , ) [EOL] [comment] [EOL] for char , _ in temp : [EOL] if ( abs ( desired_idx - compliancy_index ( block ) ) ) < ( desired_idx * possible_mistake ) : [EOL] key . append ( char ) [EOL] break [EOL] if len ( key ) != key_len : [EOL] print ( [string] ) [EOL] print ( len ( key ) , key_len ) [EOL] return guess_key_by_len ( ciphertext , key_len , true_frequencies , alphabet , desired_idx , possible_mistake = [number] , ) [EOL] return [string] . join ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , OrderedDict [EOL] import collections [EOL] import typing [EOL] from textwrap import wrap [EOL] from operator import itemgetter [EOL] [EOL] from labs . utils import ( ALPHABET , TEXTS , VARIANTS , filter_file , frequencies , spaced , without_newlines , print_line , ) [EOL] [EOL] from . config import FILE_NAME , KEYS , VARIANT_FILE_NAME [EOL] from . decode import ( get_index_for_file , guess_key_by_len , equal_symbols_on_equal_distances , ) [EOL] from . vigenere import decrypt , decrypt_file , encrypt , encrypt_file [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] text = [string] [EOL] for key in KEYS : [EOL] assert text == decrypt ( encrypt ( text , key , ALPHABET ) , key , ALPHABET ) [EOL] [EOL] [comment] [EOL] almighty = TEXTS / FILE_NAME [EOL] [comment] [EOL] cipherfile = VARIANTS / VARIANT_FILE_NAME [EOL] [EOL] [comment] [EOL] almighty = filter_file ( almighty , ALPHABET ) [EOL] [EOL] [comment] [EOL] desired_idx = get_index_for_file ( almighty ) [EOL] cipherfile_idx = get_index_for_file ( cipherfile ) [EOL] print ( f" [string] { desired_idx }" ) [EOL] print ( f" [string] { cipherfile_idx }" ) [EOL] [EOL] [comment] [EOL] print_line ( ) [EOL] print ( f" [string] { [string] : [string] } [string] { [string] : [string] } [string] " ) [EOL] print_line ( ) [EOL] [comment] [EOL] for key in KEYS : [EOL] encrypted = encrypt_file ( almighty , key , ALPHABET ) [EOL] [comment] [EOL] print ( f" [string] { key : [string] } [string] { get_index_for_file ( encrypted ) : [string] } [string] " ) [EOL] print_line ( ) [EOL] [EOL] with open ( almighty , encoding = [string] ) as af , open ( cipherfile , encoding = [string] ) as cf : [EOL] russian_frequencies = frequencies ( af . read ( ) ) [EOL] raw_ciphertext = cf . read ( ) [EOL] [EOL] key_indices = equal_symbols_on_equal_distances ( raw_ciphertext ) [EOL] print_line ( ) [EOL] print ( [string] ) [EOL] print_line ( ) [EOL] print ( [string] ) [EOL] for key , value in sorted ( key_indices . items ( ) , key = itemgetter ( [number] ) , reverse = True ) : [EOL] print ( f"{ key : [string] } [string] { value }" ) [EOL] print_line ( ) [EOL] guessed_key_len = max ( key_indices . items ( ) , key = itemgetter ( [number] ) ) [ [number] ] [EOL] print ( f" [string] { guessed_key_len }" ) [EOL] guessed_key = guess_key_by_len ( without_newlines ( raw_ciphertext ) , guessed_key_len , russian_frequencies , ALPHABET , desired_idx , ) [EOL] print ( [string] , guessed_key ) [EOL] try : [EOL] user_key = guessed_key [EOL] while user_key : [EOL] decrypted_text = decrypt_file ( cipherfile , user_key , ALPHABET ) [EOL] print ( f" [string] { spaced ( user_key ) } [string] " ) [EOL] print ( [string] . join ( map ( spaced , wrap ( decrypted_text [ : [number] ] , width = guessed_key_len ) , ) ) ) [EOL] user_key = input ( [string] ) [EOL] except ( KeyboardInterrupt , KeyError ) : [EOL] print ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.str$ 0 0 $builtins.float$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator [EOL] import builtins [EOL] import labs [EOL] import typing [EOL] import itertools [EOL] import os [EOL] [EOL] from labs . utils import BiMap , without_newlines [EOL] [EOL] from . config import ENCODED_FILENAME_MASK [EOL] [EOL] [EOL] def encrypt ( plaintext , key , alphabet ) : [EOL] [docstring] [EOL] positions = BiMap ( enumerate ( alphabet ) ) [EOL] plaintext = ( positions [ c ] for c in plaintext . lower ( ) ) [EOL] key = ( positions [ c ] for c in key . lower ( ) ) [EOL] return [string] . join ( positions [ ( c + k ) % len ( alphabet ) ] for c , k in zip ( plaintext , itertools . cycle ( key ) ) ) [EOL] [EOL] [EOL] def decrypt ( ciphertext , key , alphabet ) : [EOL] [docstring] [EOL] positions = BiMap ( enumerate ( alphabet ) ) [EOL] ciphertext = ( positions [ c ] for c in ciphertext . lower ( ) ) [EOL] key = ( positions [ c ] for c in key . lower ( ) ) [EOL] return [string] . join ( positions [ ( c - k ) % len ( alphabet ) ] for c , k in zip ( ciphertext , itertools . cycle ( key ) ) ) [EOL] [EOL] [EOL] def encrypt_file ( filename , key , alphabet ) : [EOL] [docstring] [EOL] destname = ENCODED_FILENAME_MASK . format ( filename = filename , key = key ) [EOL] try : [EOL] with open ( filename , encoding = [string] ) as source , open ( destname , [string] , encoding = [string] ) as dest : [EOL] plaintext = source . read ( ) [EOL] written = dest . write ( encrypt ( plaintext , key , alphabet ) ) [EOL] assert len ( plaintext ) == written [EOL] except KeyboardInterrupt : [EOL] os . remove ( destname ) [EOL] except AssertionError : [EOL] print ( [string] ) [EOL] return destname [EOL] [EOL] [EOL] def decrypt_file ( filename , key , alphabet ) : [EOL] with open ( filename ) as source : [EOL] text = [string] . join ( without_newlines ( source . read ( ) ) ) [EOL] return decrypt ( text , key , alphabet ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Tuple [EOL] import typing [EOL] KEYS = ( [string] , [string] , [string] , [string] , [string] , [string] , [string] ) [EOL] [EOL] ENCODED_FILENAME_MASK = [string] [EOL] [EOL] FILE_NAME = [string] [EOL] [EOL] VARIANT_FILE_NAME = [string] [EOL]	0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0
	0
from typing import Iterator , Any , OrderedDict [EOL] from collections import deque [EOL] import collections [EOL] import typing [EOL] from collections import deque [EOL] from math import log2 [EOL] [EOL] from labs . utils import ( ALPHABET , TEXTS , filter_file , frequencies , without_newlines , print_line , ) [EOL] [EOL] FILE_NAME = TEXTS / [string] [EOL] CLEANED_NAME = f"{ FILE_NAME } [string] " [EOL] [EOL] [EOL] def ngrams ( iterable , size ) : [EOL] iterable = iter ( iterable ) [EOL] stop = False [EOL] while not stop : [EOL] for _ in range ( size ) : [EOL] try : [EOL] yield tuple ( next ( iterable ) for __ in range ( size ) ) [EOL] except ( StopIteration , RuntimeError ) : [EOL] stop = True [EOL] [EOL] [EOL] def intersective_ngrams ( iterable , size ) : [EOL] iterable = iter ( iterable ) [EOL] try : [EOL] buffer = deque ( next ( iterable ) for _ in range ( size ) ) [EOL] except ( StopIteration , RuntimeError ) as exc : [EOL] raise ValueError ( [string] ) from exc [EOL] [EOL] while True : [EOL] yield tuple ( buffer ) [EOL] buffer . popleft ( ) [EOL] try : [EOL] buffer . append ( next ( iterable ) ) [EOL] except ( StopIteration , RuntimeError ) : [EOL] break [EOL] [EOL] [EOL] def entropy ( iterable , size_of_ngrams ) : [EOL] probabilities = frequencies ( ngrams ( iterable , size_of_ngrams ) ) [EOL] return - sum ( p * log2 ( p ) for p in probabilities . values ( ) ) [EOL] [EOL] [EOL] def read_by_symbols ( file ) : [EOL] while True : [EOL] c = file . read ( [number] ) [EOL] if not c : [EOL] break [EOL] yield c [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] [comment] [EOL] with open ( filter_file ( FILE_NAME , ALPHABET ) , encoding = [string] ) as f : [EOL] ru_frequencies = frequencies ( ngrams ( read_by_symbols ( f ) , [number] ) ) [EOL] print ( [string] ) [EOL] print_line ( ) [EOL] for key , value in ru_frequencies . items ( ) : [EOL] key = [string] . join ( key ) [EOL] print ( [string] . format ( key = key , value = value ) ) [EOL] print_line ( ) [EOL] f . seek ( [number] ) [EOL] ru_bi_frequencies = frequencies ( ngrams ( read_by_symbols ( f ) , [number] ) ) [EOL] print ( [string] ) [EOL] print_line ( ) [EOL] for ( key , value ) , _ in zip ( ru_bi_frequencies . items ( ) , range ( [number] ) ) : [EOL] key = [string] . join ( key ) [EOL] print ( [string] . format ( key = key , value = value ) ) [EOL] print_line ( ) [EOL] f . seek ( [number] ) [EOL] [EOL] [comment] [EOL] with open ( filter_file ( FILE_NAME , ALPHABET + [string] ) , encoding = [string] ) as f : [EOL] e1 = entropy ( without_newlines ( read_by_symbols ( f ) ) , [number] ) [EOL] print ( f" [string] { e1 }" ) [EOL] f . seek ( [number] ) [EOL] e2 = entropy ( without_newlines ( read_by_symbols ( f ) ) , [number] ) [EOL] print ( f" [string] { e2 }" ) [EOL] f . seek ( [number] ) [EOL] e1_no_spaces = entropy ( filter ( lambda x : x != [string] , without_newlines ( read_by_symbols ( f ) ) ) , [number] ) [EOL] print ( f" [string] { e1_no_spaces }" ) [EOL] f . seek ( [number] ) [EOL] e2_no_spaces = entropy ( filter ( lambda x : x != [string] , without_newlines ( read_by_symbols ( f ) ) ) , [number] ) [EOL] print ( f" [string] { e2_no_spaces }" ) [EOL] [EOL] entropy_inf = e2_no_spaces / [number] [EOL] entropy_zero = log2 ( len ( ALPHABET ) ) [EOL] redundancy = [number] - ( entropy_inf / entropy_zero ) [EOL] print_line ( ) [EOL] print ( f" [string] { redundancy }" ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $collections.OrderedDict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
import asyncio [EOL] [EOL] import aiofiles [EOL] import aiohttp [EOL] [EOL] from labs . utils import TEXTS [EOL] [EOL] URL = [string] [EOL] [EOL] [EOL] async def download ( url , file_id , session ) : [EOL] async with session . get ( url + str ( file_id ) ) as response : [EOL] async with aiofiles . open ( TEXTS / f"{ file_id } [string] " , [string] , encoding = [string] ) as f : [EOL] if response . status != [number] : [EOL] print ( f"{ file_id } [string] " ) [EOL] return [EOL] await f . write ( await response . text ( ) ) [EOL] print ( f"{ file_id } [string] " ) [EOL] [EOL] [EOL] async def main ( ) : [EOL] [comment] [EOL] async with aiohttp . ClientSession ( ) as session : [EOL] await asyncio . gather ( * ( download ( URL , i , session ) for i in range ( [number] , [number] ) ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] try : [EOL] asyncio . run ( main ( ) ) [EOL] except KeyboardInterrupt : [EOL] print ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0