[docstring] [EOL]	0 0
from typing import Sequence , Any , Dict , Pattern , List , Type , Iterable , Tuple [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] [EOL] from typing import Any , Iterable , Tuple , Sequence , Dict [EOL] [EOL] from homeassistant . const import CONF_PLATFORM [EOL] [EOL] [comment] [EOL] [comment] [EOL] if False : [EOL] from logging import Logger [comment] [EOL] [EOL] [comment] [EOL] ConfigType = Dict [ str , Any ] [EOL] [EOL] [EOL] def config_per_platform ( config , domain ) : [EOL] [docstring] [EOL] for config_key in extract_domain_configs ( config , domain ) : [EOL] platform_config = config [ config_key ] [EOL] [EOL] if not platform_config : [EOL] continue [EOL] elif not isinstance ( platform_config , list ) : [EOL] platform_config = [ platform_config ] [EOL] [EOL] for item in platform_config : [EOL] try : [EOL] platform = item . get ( CONF_PLATFORM ) [EOL] except AttributeError : [EOL] platform = None [EOL] [EOL] yield platform , item [EOL] [EOL] [EOL] def extract_domain_configs ( config , domain ) : [EOL] [docstring] [EOL] pattern = re . compile ( [string] . format ( domain ) ) [EOL] return [ key for key in config . keys ( ) if pattern . match ( key ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[typing.Any,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Sequence[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class Registry ( dict ) : [EOL] [docstring] [EOL] [EOL] def register ( self , name ) : [EOL] [docstring] [EOL] def decorator ( func ) : [EOL] [docstring] [EOL] self [ name ] = func [EOL] return func [EOL] [EOL] return decorator [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] [docstring] [EOL] import binascii [EOL] import os [EOL] [EOL] [EOL] def generate_secret ( entropy = [number] ) : [EOL] [docstring] [EOL] return binascii . hexlify ( os . urandom ( entropy ) ) . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] [EOL] ACCESS_TOKEN_EXPIRATION = timedelta ( minutes = [number] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] from distutils . version import StrictVersion [EOL] import json [EOL] import logging [EOL] import os [EOL] import platform [EOL] import uuid [EOL] [EOL] import aiohttp [EOL] import async_timeout [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ATTR_FRIENDLY_NAME [EOL] from homeassistant . const import __version__ as current_version [EOL] from homeassistant . helpers import event [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_RELEASE_NOTES = [string] [EOL] [EOL] CONF_REPORTING = [string] [EOL] CONF_COMPONENT_REPORTING = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] ENTITY_ID = [string] [EOL] [EOL] UPDATER_URL = [string] [EOL] UPDATER_UUID_FILE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : { vol . Optional ( CONF_REPORTING , default = True ) : cv . boolean , vol . Optional ( CONF_COMPONENT_REPORTING , default = False ) : cv . boolean , } } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] RESPONSE_SCHEMA = vol . Schema ( { vol . Required ( [string] ) : cv . string , vol . Required ( [string] ) : cv . url , } ) [EOL] [EOL] [EOL] def _create_uuid ( hass , filename = UPDATER_UUID_FILE ) : [EOL] [docstring] [EOL] with open ( hass . config . path ( filename ) , [string] ) as fptr : [EOL] _uuid = uuid . uuid4 ( ) . hex [EOL] fptr . write ( json . dumps ( { [string] : _uuid } ) ) [EOL] return _uuid [EOL] [EOL] [EOL] def _load_uuid ( hass , filename = UPDATER_UUID_FILE ) : [EOL] [docstring] [EOL] try : [EOL] with open ( hass . config . path ( filename ) ) as fptr : [EOL] jsonf = json . loads ( fptr . read ( ) ) [EOL] return uuid . UUID ( jsonf [ [string] ] , version = [number] ) . hex [EOL] except ( ValueError , AttributeError ) : [EOL] return None [EOL] except FileNotFoundError : [EOL] return _create_uuid ( hass , filename ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] if [string] in current_version : [EOL] [comment] [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] config = config . get ( DOMAIN , { } ) [EOL] if config . get ( CONF_REPORTING ) : [EOL] huuid = await hass . async_add_job ( _load_uuid , hass ) [EOL] else : [EOL] huuid = None [EOL] [EOL] include_components = config . get ( CONF_COMPONENT_REPORTING ) [EOL] [EOL] async def check_new_version ( now ) : [EOL] [docstring] [EOL] result = await get_newest_version ( hass , huuid , include_components ) [EOL] [EOL] if result is None : [EOL] return [EOL] [EOL] newest , releasenotes = result [EOL] [EOL] [comment] [EOL] if newest is None or [string] in current_version : [EOL] return [EOL] [EOL] [comment] [EOL] if hass . components . hassio . is_hassio ( ) : [EOL] newest = hass . components . hassio . get_homeassistant_version ( ) [EOL] [EOL] [comment] [EOL] if StrictVersion ( newest ) > StrictVersion ( current_version ) : [EOL] _LOGGER . info ( [string] , newest ) [EOL] hass . states . async_set ( ENTITY_ID , newest , { ATTR_FRIENDLY_NAME : [string] , ATTR_RELEASE_NOTES : releasenotes } ) [EOL] elif StrictVersion ( newest ) == StrictVersion ( current_version ) : [EOL] _LOGGER . info ( [string] , newest ) [EOL] [EOL] [comment] [EOL] _dt = dt_util . utcnow ( ) + timedelta ( hours = [number] ) [EOL] event . async_track_utc_time_change ( hass , check_new_version , hour = _dt . hour , minute = _dt . minute , second = _dt . second ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def get_system_info ( hass , include_components ) : [EOL] [docstring] [EOL] info_object = { [string] : platform . machine ( ) , [string] : [string] in current_version , [string] : False , [string] : platform . system ( ) , [string] : platform . python_version ( ) , [string] : dt_util . DEFAULT_TIME_ZONE . zone , [string] : current_version , [string] : os . environ . get ( [string] ) is not None , [string] : hass . components . hassio . is_hassio ( ) , } [EOL] [EOL] if include_components : [EOL] info_object [ [string] ] = list ( hass . config . components ) [EOL] [EOL] if platform . system ( ) == [string] : [EOL] info_object [ [string] ] = platform . win32_ver ( ) [ [number] ] [EOL] elif platform . system ( ) == [string] : [EOL] info_object [ [string] ] = platform . mac_ver ( ) [ [number] ] [EOL] elif platform . system ( ) == [string] : [EOL] info_object [ [string] ] = platform . release ( ) [EOL] elif platform . system ( ) == [string] : [EOL] import distro [EOL] linux_dist = await hass . async_add_job ( distro . linux_distribution , False ) [EOL] info_object [ [string] ] = linux_dist [ [number] ] [EOL] info_object [ [string] ] = linux_dist [ [number] ] [EOL] info_object [ [string] ] = os . path . isfile ( [string] ) [EOL] [EOL] return info_object [EOL] [EOL] [EOL] async def get_newest_version ( hass , huuid , include_components ) : [EOL] [docstring] [EOL] if huuid : [EOL] info_object = await get_system_info ( hass , include_components ) [EOL] info_object [ [string] ] = huuid [EOL] else : [EOL] info_object = { } [EOL] [EOL] session = async_get_clientsession ( hass ) [EOL] try : [EOL] with async_timeout . timeout ( [number] , loop = hass . loop ) : [EOL] req = await session . post ( UPDATER_URL , json = info_object ) [EOL] _LOGGER . info ( ( [string] [string] ) , info_object ) [EOL] except ( asyncio . TimeoutError , aiohttp . ClientError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] return None [EOL] [EOL] try : [EOL] res = await req . json ( ) [EOL] except ValueError : [EOL] _LOGGER . error ( [string] ) [EOL] return None [EOL] [EOL] try : [EOL] res = RESPONSE_SCHEMA ( res ) [EOL] return res [ [string] ] , res [ [string] ] [EOL] except vol . Invalid : [EOL] _LOGGER . error ( [string] , res ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import requests [EOL] [docstring] [EOL] import logging [EOL] import time [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] from aiohttp . hdrs import CONTENT_TYPE [EOL] [EOL] from homeassistant . const import CONF_API_KEY , CONF_HOST , CONTENT_TYPE_JSON [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DOMAIN = [string] [EOL] CONF_NUMBER_OF_TOOLS = [string] [EOL] CONF_BED = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NUMBER_OF_TOOLS , default = [number] ) : cv . positive_int , vol . Optional ( CONF_BED , default = False ) : cv . boolean } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] base_url = [string] . format ( config [ DOMAIN ] [ CONF_HOST ] ) [EOL] api_key = config [ DOMAIN ] [ CONF_API_KEY ] [EOL] number_of_tools = config [ DOMAIN ] [ CONF_NUMBER_OF_TOOLS ] [EOL] bed = config [ DOMAIN ] [ CONF_BED ] [EOL] [EOL] hass . data [ DOMAIN ] = { [string] : None } [EOL] [EOL] try : [EOL] octoprint_api = OctoPrintAPI ( base_url , api_key , bed , number_of_tools ) [EOL] hass . data [ DOMAIN ] [ [string] ] = octoprint_api [EOL] octoprint_api . get ( [string] ) [EOL] octoprint_api . get ( [string] ) [EOL] except requests . exceptions . RequestException as conn_err : [EOL] _LOGGER . error ( [string] , conn_err ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class OctoPrintAPI ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api_url , key , bed , number_of_tools ) : [EOL] [docstring] [EOL] self . api_url = api_url [EOL] self . headers = { CONTENT_TYPE : CONTENT_TYPE_JSON , [string] : key , } [EOL] self . printer_last_reading = [ { } , None ] [EOL] self . job_last_reading = [ { } , None ] [EOL] self . job_available = False [EOL] self . printer_available = False [EOL] self . available = False [EOL] self . printer_error_logged = False [EOL] self . job_error_logged = False [EOL] self . bed = bed [EOL] self . number_of_tools = number_of_tools [EOL] [EOL] def get_tools ( self ) : [EOL] [docstring] [EOL] tools = [ ] [EOL] if self . number_of_tools > [number] : [EOL] for tool_number in range ( [number] , self . number_of_tools ) : [EOL] tools . append ( [string] + str ( tool_number ) ) [EOL] if self . bed : [EOL] tools . append ( [string] ) [EOL] if not self . bed and self . number_of_tools == [number] : [EOL] temps = self . printer_last_reading [ [number] ] . get ( [string] ) [EOL] if temps is not None : [EOL] tools = temps . keys ( ) [EOL] return tools [EOL] [EOL] def get ( self , endpoint ) : [EOL] [docstring] [EOL] [comment] [EOL] now = time . time ( ) [EOL] if endpoint == [string] : [EOL] last_time = self . job_last_reading [ [number] ] [EOL] if last_time is not None : [EOL] if now - last_time < [number] : [EOL] return self . job_last_reading [ [number] ] [EOL] elif endpoint == [string] : [EOL] last_time = self . printer_last_reading [ [number] ] [EOL] if last_time is not None : [EOL] if now - last_time < [number] : [EOL] return self . printer_last_reading [ [number] ] [EOL] [EOL] url = self . api_url + endpoint [EOL] try : [EOL] response = requests . get ( url , headers = self . headers , timeout = [number] ) [EOL] response . raise_for_status ( ) [EOL] if endpoint == [string] : [EOL] self . job_last_reading [ [number] ] = response . json ( ) [EOL] self . job_last_reading [ [number] ] = time . time ( ) [EOL] self . job_available = True [EOL] elif endpoint == [string] : [EOL] self . printer_last_reading [ [number] ] = response . json ( ) [EOL] self . printer_last_reading [ [number] ] = time . time ( ) [EOL] self . printer_available = True [EOL] self . available = self . printer_available and self . job_available [EOL] if self . available : [EOL] self . job_error_logged = False [EOL] self . printer_error_logged = False [EOL] return response . json ( ) [EOL] except Exception as conn_exc : [comment] [EOL] log_string = [string] + [string] % (conn_exc) [EOL] [comment] [EOL] if endpoint == [string] : [EOL] log_string = [string] + log_string [EOL] if not self . job_error_logged : [EOL] _LOGGER . error ( log_string ) [EOL] self . job_error_logged = True [EOL] self . job_available = False [EOL] elif endpoint == [string] : [EOL] log_string = [string] + log_string [EOL] if not self . printer_error_logged : [EOL] _LOGGER . error ( log_string ) [EOL] self . printer_error_logged = True [EOL] self . printer_available = False [EOL] self . available = False [EOL] return None [EOL] [EOL] def update ( self , sensor_type , end_point , group , tool = None ) : [EOL] [docstring] [EOL] response = self . get ( end_point ) [EOL] if response is not None : [EOL] return get_value_from_json ( response , sensor_type , group , tool ) [EOL] return response [EOL] [EOL] [EOL] def get_value_from_json ( json_dict , sensor_type , group , tool ) : [EOL] [docstring] [EOL] if group not in json_dict : [EOL] return None [EOL] [EOL] if sensor_type in json_dict [ group ] : [EOL] if sensor_type == [string] and json_dict [ sensor_type ] is None : [EOL] return [number] [EOL] return json_dict [ group ] [ sensor_type ] [EOL] [EOL] elif tool is not None : [EOL] if sensor_type in json_dict [ group ] [ tool ] : [EOL] return json_dict [ group ] [ tool ] [ sensor_type ] [EOL] [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.float$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $requests.models.Response$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 $logging.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] from requests . exceptions import ConnectTimeout , HTTPError [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_ACCESS_TOKEN , CONF_SCAN_INTERVAL ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import ( async_dispatcher_connect , dispatcher_send ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . helpers . event import track_time_interval [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ALLOWED_WATERING_TIME = [ [number] , [number] , [number] , [number] , [number] , [number] ] [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_WATERING_TIME = [string] [EOL] [EOL] NOTIFICATION_ID = [string] [EOL] NOTIFICATION_TITLE = [string] [EOL] [EOL] DATA_HYDRAWISE = [string] [EOL] DOMAIN = [string] [EOL] DEFAULT_WATERING_TIME = [number] [EOL] [EOL] DEVICE_MAP_INDEX = [ [string] , [string] , [string] , [string] ] [EOL] DEVICE_MAP = { [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] , [string] ] } [EOL] [EOL] BINARY_SENSORS = [ [string] , [string] , [string] ] [EOL] [EOL] SENSORS = [ [string] , [string] ] [EOL] [EOL] SWITCHES = [ [string] , [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] SIGNAL_UPDATE_HYDRAWISE = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_ACCESS_TOKEN ) : cv . string , vol . Optional ( CONF_SCAN_INTERVAL , default = SCAN_INTERVAL ) : cv . time_period , } ) , } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config [ DOMAIN ] [EOL] access_token = conf [ CONF_ACCESS_TOKEN ] [EOL] scan_interval = conf . get ( CONF_SCAN_INTERVAL ) [EOL] [EOL] try : [EOL] from hydrawiser . core import Hydrawiser [EOL] [EOL] hydrawise = Hydrawiser ( user_token = access_token ) [EOL] hass . data [ DATA_HYDRAWISE ] = HydrawiseHub ( hydrawise ) [EOL] except ( ConnectTimeout , HTTPError ) as ex : [EOL] _LOGGER . error ( [string] , str ( ex ) ) [EOL] hass . components . persistent_notification . create ( [string] [string] [string] . format ( ex ) , title = NOTIFICATION_TITLE , notification_id = NOTIFICATION_ID ) [EOL] return False [EOL] [EOL] def hub_refresh ( event_time ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] ) [EOL] hass . data [ DATA_HYDRAWISE ] . data . update_controller_info ( ) [EOL] dispatcher_send ( hass , SIGNAL_UPDATE_HYDRAWISE ) [EOL] [EOL] [comment] [EOL] track_time_interval ( hass , hub_refresh , scan_interval ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class HydrawiseHub ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data ) : [EOL] [docstring] [EOL] self . data = data [EOL] [EOL] [EOL] class HydrawiseEntity ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , sensor_type ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _sensor_type = sensor_type [EOL] self . _name = [string] . format ( self . data [ [string] ] , DEVICE_MAP [ self . _sensor_type ] [ DEVICE_MAP_INDEX . index ( [string] ) ] ) [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] async_dispatcher_connect ( self . hass , SIGNAL_UPDATE_HYDRAWISE , self . _update_callback ) [EOL] [EOL] @ callback def _update_callback ( self ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( True ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return DEVICE_MAP [ self . _sensor_type ] [ DEVICE_MAP_INDEX . index ( [string] ) ] [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , [string] : self . data . get ( [string] ) , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers import discovery [EOL] from homeassistant . const import CONF_PORT [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_EXCLUDE_NAMES = [string] [EOL] CONF_INCLUDE_SWITCHES = [string] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] CONFIG_SCHEMA = vol . Schema ( { DOMAIN : vol . Schema ( { vol . Required ( CONF_PORT ) : cv . string , vol . Optional ( CONF_EXCLUDE_NAMES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_INCLUDE_SWITCHES , default = False ) : cv . boolean } ) } , extra = vol . ALLOW_EXTRA ) [EOL] [EOL] [EOL] def setup ( hass , config ) : [EOL] [docstring] [EOL] from pylitejet import LiteJet [EOL] [EOL] url = config [ DOMAIN ] . get ( CONF_PORT ) [EOL] [EOL] hass . data [ [string] ] = LiteJet ( url ) [EOL] hass . data [ [string] ] = config [ DOMAIN ] [EOL] [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] if config [ DOMAIN ] . get ( CONF_INCLUDE_SWITCHES ) : [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] discovery . load_platform ( hass , [string] , DOMAIN , { } , config ) [EOL] [EOL] return True [EOL] [EOL] [EOL] def is_ignored ( hass , name ) : [EOL] [docstring] [EOL] for prefix in hass . data [ [string] ] . get ( CONF_EXCLUDE_NAMES , [ ] ) : [EOL] if name . startswith ( prefix ) : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] await hass . components . frontend . async_register_built_in_panel ( [string] , [string] , [string] ) [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . alarm_control_panel as alarm [EOL] from homeassistant . components . alarmdecoder import DATA_AD , SIGNAL_PANEL_MESSAGE [EOL] from homeassistant . const import ( ATTR_CODE , STATE_ALARM_ARMED_AWAY , STATE_ALARM_ARMED_HOME , STATE_ALARM_DISARMED , STATE_ALARM_TRIGGERED ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SERVICE_ALARM_TOGGLE_CHIME = [string] [EOL] ALARM_TOGGLE_CHIME_SCHEMA = vol . Schema ( { vol . Required ( ATTR_CODE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] device = AlarmDecoderAlarmPanel ( ) [EOL] add_devices ( [ device ] ) [EOL] [EOL] def alarm_toggle_chime_handler ( service ) : [EOL] [docstring] [EOL] code = service . data . get ( ATTR_CODE ) [EOL] device . alarm_toggle_chime ( code ) [EOL] [EOL] hass . services . register ( alarm . DOMAIN , SERVICE_ALARM_TOGGLE_CHIME , alarm_toggle_chime_handler , schema = ALARM_TOGGLE_CHIME_SCHEMA ) [EOL] [EOL] [EOL] class AlarmDecoderAlarmPanel ( alarm . AlarmControlPanel ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _display = [string] [EOL] self . _name = [string] [EOL] self . _state = None [EOL] self . _ac_power = None [EOL] self . _backlight_on = None [EOL] self . _battery_low = None [EOL] self . _check_zone = None [EOL] self . _chime = None [EOL] self . _entry_delay_off = None [EOL] self . _programming_mode = None [EOL] self . _ready = None [EOL] self . _zone_bypassed = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_PANEL_MESSAGE , self . _message_callback ) [EOL] [EOL] def _message_callback ( self , message ) : [EOL] [docstring] [EOL] if message . alarm_sounding or message . fire_alarm : [EOL] self . _state = STATE_ALARM_TRIGGERED [EOL] elif message . armed_away : [EOL] self . _state = STATE_ALARM_ARMED_AWAY [EOL] elif message . armed_home : [EOL] self . _state = STATE_ALARM_ARMED_HOME [EOL] else : [EOL] self . _state = STATE_ALARM_DISARMED [EOL] [EOL] self . _ac_power = message . ac_power [EOL] self . _backlight_on = message . backlight_on [EOL] self . _battery_low = message . battery_low [EOL] self . _check_zone = message . check_zone [EOL] self . _chime = message . chime_on [EOL] self . _entry_delay_off = message . entry_delay_off [EOL] self . _programming_mode = message . programming_mode [EOL] self . _ready = message . ready [EOL] self . _zone_bypassed = message . zone_bypassed [EOL] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def code_format ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { [string] : self . _ac_power , [string] : self . _backlight_on , [string] : self . _battery_low , [string] : self . _check_zone , [string] : self . _chime , [string] : self . _entry_delay_off , [string] : self . _programming_mode , [string] : self . _ready , [string] : self . _zone_bypassed , } [EOL] [EOL] def alarm_disarm ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_arm_away ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_arm_home ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL] [EOL] def alarm_toggle_chime ( self , code = None ) : [EOL] [docstring] [EOL] if code : [EOL] self . hass . data [ DATA_AD ] . send ( [string] . format ( code ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . cover import ( ATTR_POSITION , ATTR_TILT_POSITION , PLATFORM_SCHEMA , SUPPORT_CLOSE , SUPPORT_OPEN , SUPPORT_SET_POSITION , SUPPORT_SET_TILT_POSITION , SUPPORT_STOP , CoverDevice ) [EOL] from homeassistant . components . knx import ATTR_DISCOVER_DEVICES , DATA_KNX [EOL] from homeassistant . const import CONF_NAME [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . event import async_track_utc_time_change [EOL] [EOL] CONF_MOVE_LONG_ADDRESS = [string] [EOL] CONF_MOVE_SHORT_ADDRESS = [string] [EOL] CONF_POSITION_ADDRESS = [string] [EOL] CONF_POSITION_STATE_ADDRESS = [string] [EOL] CONF_ANGLE_ADDRESS = [string] [EOL] CONF_ANGLE_STATE_ADDRESS = [string] [EOL] CONF_TRAVELLING_TIME_DOWN = [string] [EOL] CONF_TRAVELLING_TIME_UP = [string] [EOL] CONF_INVERT_POSITION = [string] [EOL] CONF_INVERT_ANGLE = [string] [EOL] [EOL] DEFAULT_TRAVEL_TIME = [number] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MOVE_LONG_ADDRESS ) : cv . string , vol . Optional ( CONF_MOVE_SHORT_ADDRESS ) : cv . string , vol . Optional ( CONF_POSITION_ADDRESS ) : cv . string , vol . Optional ( CONF_POSITION_STATE_ADDRESS ) : cv . string , vol . Optional ( CONF_ANGLE_ADDRESS ) : cv . string , vol . Optional ( CONF_ANGLE_STATE_ADDRESS ) : cv . string , vol . Optional ( CONF_TRAVELLING_TIME_DOWN , default = DEFAULT_TRAVEL_TIME ) : cv . positive_int , vol . Optional ( CONF_TRAVELLING_TIME_UP , default = DEFAULT_TRAVEL_TIME ) : cv . positive_int , vol . Optional ( CONF_INVERT_POSITION , default = False ) : cv . boolean , vol . Optional ( CONF_INVERT_ANGLE , default = False ) : cv . boolean , } ) [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is not None : [EOL] async_add_devices_discovery ( hass , discovery_info , async_add_devices ) [EOL] else : [EOL] async_add_devices_config ( hass , config , async_add_devices ) [EOL] [EOL] [EOL] @ callback def async_add_devices_discovery ( hass , discovery_info , async_add_devices ) : [EOL] [docstring] [EOL] entities = [ ] [EOL] for device_name in discovery_info [ ATTR_DISCOVER_DEVICES ] : [EOL] device = hass . data [ DATA_KNX ] . xknx . devices [ device_name ] [EOL] entities . append ( KNXCover ( hass , device ) ) [EOL] async_add_devices ( entities ) [EOL] [EOL] [EOL] @ callback def async_add_devices_config ( hass , config , async_add_devices ) : [EOL] [docstring] [EOL] import xknx [EOL] cover = xknx . devices . Cover ( hass . data [ DATA_KNX ] . xknx , name = config . get ( CONF_NAME ) , group_address_long = config . get ( CONF_MOVE_LONG_ADDRESS ) , group_address_short = config . get ( CONF_MOVE_SHORT_ADDRESS ) , group_address_position_state = config . get ( CONF_POSITION_STATE_ADDRESS ) , group_address_angle = config . get ( CONF_ANGLE_ADDRESS ) , group_address_angle_state = config . get ( CONF_ANGLE_STATE_ADDRESS ) , group_address_position = config . get ( CONF_POSITION_ADDRESS ) , travel_time_down = config . get ( CONF_TRAVELLING_TIME_DOWN ) , travel_time_up = config . get ( CONF_TRAVELLING_TIME_UP ) , invert_position = config . get ( CONF_INVERT_POSITION ) , invert_angle = config . get ( CONF_INVERT_ANGLE ) ) [EOL] [EOL] hass . data [ DATA_KNX ] . xknx . devices . add ( cover ) [EOL] async_add_devices ( [ KNXCover ( hass , cover ) ] ) [EOL] [EOL] [EOL] class KNXCover ( CoverDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device ) : [EOL] [docstring] [EOL] self . device = device [EOL] self . hass = hass [EOL] self . async_register_callbacks ( ) [EOL] [EOL] self . _unsubscribe_auto_updater = None [EOL] [EOL] @ callback def async_register_callbacks ( self ) : [EOL] [docstring] [EOL] async def after_update_callback ( device ) : [EOL] [docstring] [EOL] await self . async_update_ha_state ( ) [EOL] self . device . register_device_updated_cb ( after_update_callback ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . device . name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . hass . data [ DATA_KNX ] . connected [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] supported_features = SUPPORT_OPEN | SUPPORT_CLOSE | SUPPORT_SET_POSITION | SUPPORT_STOP [EOL] if self . device . supports_angle : [EOL] supported_features |= SUPPORT_SET_TILT_POSITION [EOL] return supported_features [EOL] [EOL] @ property def current_cover_position ( self ) : [EOL] [docstring] [EOL] return self . device . current_position ( ) [EOL] [EOL] @ property def is_closed ( self ) : [EOL] [docstring] [EOL] return self . device . is_closed ( ) [EOL] [EOL] async def async_close_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . device . is_closed ( ) : [EOL] await self . device . set_down ( ) [EOL] self . start_auto_updater ( ) [EOL] [EOL] async def async_open_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] if not self . device . is_open ( ) : [EOL] await self . device . set_up ( ) [EOL] self . start_auto_updater ( ) [EOL] [EOL] async def async_set_cover_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_POSITION in kwargs : [EOL] position = kwargs [ ATTR_POSITION ] [EOL] await self . device . set_position ( position ) [EOL] self . start_auto_updater ( ) [EOL] [EOL] async def async_stop_cover ( self , ** kwargs ) : [EOL] [docstring] [EOL] await self . device . stop ( ) [EOL] self . stop_auto_updater ( ) [EOL] [EOL] @ property def current_cover_tilt_position ( self ) : [EOL] [docstring] [EOL] if not self . device . supports_angle : [EOL] return None [EOL] return self . device . current_angle ( ) [EOL] [EOL] async def async_set_cover_tilt_position ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_TILT_POSITION in kwargs : [EOL] tilt_position = kwargs [ ATTR_TILT_POSITION ] [EOL] await self . device . set_angle ( tilt_position ) [EOL] [EOL] def start_auto_updater ( self ) : [EOL] [docstring] [EOL] if self . _unsubscribe_auto_updater is None : [EOL] self . _unsubscribe_auto_updater = async_track_utc_time_change ( self . hass , self . auto_updater_hook ) [EOL] [EOL] def stop_auto_updater ( self ) : [EOL] [docstring] [EOL] if self . _unsubscribe_auto_updater is not None : [EOL] self . _unsubscribe_auto_updater ( ) [EOL] self . _unsubscribe_auto_updater = None [EOL] [EOL] @ callback def auto_updater_hook ( self , now ) : [EOL] [docstring] [EOL] self . async_schedule_update_ha_state ( ) [EOL] if self . device . position_reached ( ) : [EOL] self . stop_auto_updater ( ) [EOL] [EOL] self . hass . add_job ( self . device . auto_stop_if_necessary ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant import data_entry_flow [EOL] from homeassistant . helpers import config_entry_flow [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] conf = config . get ( DOMAIN ) [EOL] [EOL] hass . data [ DOMAIN ] = conf or { } [EOL] [EOL] if conf is not None : [EOL] hass . async_create_task ( hass . config_entries . flow . async_init ( DOMAIN , source = data_entry_flow . SOURCE_IMPORT ) ) [EOL] [EOL] return True [EOL] [EOL] [EOL] async def async_setup_entry ( hass , entry ) : [EOL] [docstring] [EOL] hass . async_add_job ( hass . config_entries . async_forward_entry_setup ( entry , [string] ) ) [EOL] return True [EOL] [EOL] [EOL] async def _async_has_devices ( hass ) : [EOL] [docstring] [EOL] import soco [EOL] [EOL] return await hass . async_add_job ( soco . discover ) [EOL] [EOL] [EOL] config_entry_flow . register_discovery_flow ( DOMAIN , [string] , _async_has_devices ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . core import callback [EOL] from homeassistant . loader import bind_hass [EOL] [EOL] from . const import STEPS , STEP_USER , DOMAIN [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] STORAGE_KEY = DOMAIN [EOL] STORAGE_VERSION = [number] [EOL] [EOL] [EOL] @ bind_hass @ callback def async_is_onboarded ( hass ) : [EOL] [docstring] [EOL] [comment] [EOL] if not hass . auth . active : [EOL] return True [EOL] [EOL] return hass . data . get ( DOMAIN , True ) [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] store = hass . helpers . storage . Store ( STORAGE_VERSION , STORAGE_KEY ) [EOL] data = await store . async_load ( ) [EOL] [EOL] if data is None : [EOL] data = { [string] : [ ] } [EOL] [EOL] if STEP_USER not in data [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] has_owner = False [EOL] [EOL] for user in await hass . auth . async_get_users ( ) : [EOL] if user . is_owner : [EOL] has_owner = True [EOL] break [EOL] [EOL] if has_owner : [EOL] data [ [string] ] . append ( STEP_USER ) [EOL] await store . async_save ( data ) [EOL] [EOL] if set ( data [ [string] ] ) == set ( STEPS ) : [EOL] return True [EOL] [EOL] hass . data [ DOMAIN ] = False [EOL] [EOL] from . import views [EOL] [EOL] await views . async_setup ( hass , data , store ) [EOL] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] [docstring] [EOL] DOMAIN = [string] [EOL] STEP_USER = [string] [EOL] [EOL] STEPS = [ STEP_USER ] [EOL]	0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 0
from typing import Any , Tuple [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import functools as ft [EOL] import logging [EOL] [EOL] import homeassistant . components . remote as remote [EOL] from homeassistant . const import CONF_DEVICE , CONF_NAME [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_REMOTE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info : [EOL] name = discovery_info . get ( CONF_NAME ) [EOL] device = discovery_info . get ( CONF_DEVICE ) [EOL] [EOL] kira = hass . data [ DOMAIN ] [ CONF_REMOTE ] [ name ] [EOL] add_devices ( [ KiraRemote ( device , kira ) ] ) [EOL] return True [EOL] [EOL] [EOL] class KiraRemote ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , kira ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , name ) [EOL] self . _name = name [EOL] self . _kira = kira [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [EOL] def send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] for single_command in command : [EOL] code_tuple = ( single_command , kwargs . get ( remote . ATTR_DEVICE ) ) [EOL] _LOGGER . info ( [string] , * code_tuple ) [EOL] self . _kira . sendCode ( code_tuple ) [EOL] [EOL] def async_send_command ( self , command , ** kwargs ) : [EOL] [docstring] [EOL] return self . hass . async_add_job ( ft . partial ( self . send_command , command , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Tuple[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . comfoconnect import ( DOMAIN , ComfoConnectBridge , SIGNAL_COMFOCONNECT_UPDATE_RECEIVED ) [EOL] from homeassistant . components . fan import ( FanEntity , SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , SUPPORT_SET_SPEED ) [EOL] from homeassistant . const import STATE_UNKNOWN [EOL] from homeassistant . helpers . dispatcher import ( dispatcher_connect ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] SPEED_MAPPING = { [number] : SPEED_OFF , [number] : SPEED_LOW , [number] : SPEED_MEDIUM , [number] : SPEED_HIGH } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ccb = hass . data [ DOMAIN ] [EOL] [EOL] add_devices ( [ ComfoConnectFan ( hass , name = ccb . name , ccb = ccb ) ] , True ) [EOL] return [EOL] [EOL] [EOL] class ComfoConnectFan ( FanEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , ccb ) : [EOL] [docstring] [EOL] from pycomfoconnect import SENSOR_FAN_SPEED_MODE [EOL] [EOL] self . _ccb = ccb [EOL] self . _name = name [EOL] [EOL] [comment] [EOL] self . _ccb . comfoconnect . register_sensor ( SENSOR_FAN_SPEED_MODE ) [EOL] [EOL] def _handle_update ( var ) : [EOL] if var == SENSOR_FAN_SPEED_MODE : [EOL] _LOGGER . debug ( [string] , var ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] [comment] [EOL] dispatcher_connect ( hass , SIGNAL_COMFOCONNECT_UPDATE_RECEIVED , _handle_update ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return [string] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SET_SPEED [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] from pycomfoconnect import ( SENSOR_FAN_SPEED_MODE ) [EOL] [EOL] try : [EOL] speed = self . _ccb . data [ SENSOR_FAN_SPEED_MODE ] [EOL] return SPEED_MAPPING [ speed ] [EOL] except KeyError : [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return [ SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH ] [EOL] [EOL] def turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed is None : [EOL] speed = SPEED_LOW [EOL] self . set_speed ( speed ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . set_speed ( SPEED_OFF ) [EOL] [EOL] def set_speed ( self , speed ) : [EOL] [docstring] [EOL] _LOGGER . debug ( [string] , speed ) [EOL] [EOL] from pycomfoconnect import ( CMD_FAN_MODE_AWAY , CMD_FAN_MODE_LOW , CMD_FAN_MODE_MEDIUM , CMD_FAN_MODE_HIGH ) [EOL] [EOL] if speed == SPEED_OFF : [EOL] self . _ccb . comfoconnect . cmd_rmi_request ( CMD_FAN_MODE_AWAY ) [EOL] elif speed == SPEED_LOW : [EOL] self . _ccb . comfoconnect . cmd_rmi_request ( CMD_FAN_MODE_LOW ) [EOL] elif speed == SPEED_MEDIUM : [EOL] self . _ccb . comfoconnect . cmd_rmi_request ( CMD_FAN_MODE_MEDIUM ) [EOL] elif speed == SPEED_HIGH : [EOL] self . _ccb . comfoconnect . cmd_rmi_request ( CMD_FAN_MODE_HIGH ) [EOL] [EOL] [comment] [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List , Generator , Type [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from homeassistant . components import zha [EOL] from homeassistant . components . fan import ( DOMAIN , FanEntity , SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , SUPPORT_SET_SPEED ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] SPEED_ON = [string] [EOL] [comment] [EOL] SPEED_AUTO = [string] [EOL] [comment] [EOL] SPEED_SMART = [string] [EOL] [EOL] SPEED_LIST = [ SPEED_OFF , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , SPEED_ON , SPEED_AUTO , SPEED_SMART ] [EOL] [EOL] VALUE_TO_SPEED = { i : speed for i , speed in enumerate ( SPEED_LIST ) } [EOL] SPEED_TO_VALUE = { speed : i for i , speed in enumerate ( SPEED_LIST ) } [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] discovery_info = zha . get_discovery_info ( hass , discovery_info ) [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] async_add_devices ( [ ZhaFan ( ** discovery_info ) ] , update_before_add = True ) [EOL] [EOL] [EOL] class ZhaFan ( zha . Entity , FanEntity ) : [EOL] [docstring] [EOL] [EOL] _domain = DOMAIN [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SET_SPEED [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return SPEED_LIST [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] if self . _state is None : [EOL] return False [EOL] return self . _state != SPEED_OFF [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed is None : [EOL] speed = SPEED_MEDIUM [EOL] [EOL] yield from self . async_set_speed ( speed ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] yield from self . async_set_speed ( SPEED_OFF ) [EOL] [EOL] @ asyncio . coroutine def async_set_speed ( self , speed ) : [EOL] [docstring] [EOL] yield from self . _endpoint . fan . write_attributes ( { [string] : SPEED_TO_VALUE [ speed ] } ) [EOL] [EOL] self . _state = speed [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] result = yield from zha . safe_read ( self . _endpoint . fan , [ [string] ] ) [EOL] new_value = result . get ( [string] , None ) [EOL] self . _state = VALUE_TO_SPEED . get ( new_value , None ) [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import builtins [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from enum import Enum [EOL] from functools import partial [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . fan import ( FanEntity , PLATFORM_SCHEMA , SUPPORT_SET_SPEED , DOMAIN , ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_HOST , CONF_TOKEN , ATTR_ENTITY_ID , ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DATA_KEY = [string] [EOL] [EOL] CONF_MODEL = [string] [EOL] MODEL_AIRPURIFIER_PRO = [string] [EOL] MODEL_AIRPURIFIER_V3 = [string] [EOL] MODEL_AIRHUMIDIFIER_V1 = [string] [EOL] MODEL_AIRHUMIDIFIER_CA = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_TOKEN ) : vol . All ( cv . string , vol . Length ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MODEL ) : vol . In ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] ) , } ) [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] ATTR_MODEL = [string] [EOL] [EOL] [comment] [EOL] ATTR_TEMPERATURE = [string] [EOL] ATTR_HUMIDITY = [string] [EOL] ATTR_AIR_QUALITY_INDEX = [string] [EOL] ATTR_MODE = [string] [EOL] ATTR_FILTER_HOURS_USED = [string] [EOL] ATTR_FILTER_LIFE = [string] [EOL] ATTR_FAVORITE_LEVEL = [string] [EOL] ATTR_BUZZER = [string] [EOL] ATTR_CHILD_LOCK = [string] [EOL] ATTR_LED = [string] [EOL] ATTR_LED_BRIGHTNESS = [string] [EOL] ATTR_MOTOR_SPEED = [string] [EOL] ATTR_AVERAGE_AIR_QUALITY_INDEX = [string] [EOL] ATTR_PURIFY_VOLUME = [string] [EOL] ATTR_BRIGHTNESS = [string] [EOL] ATTR_LEVEL = [string] [EOL] ATTR_MOTOR2_SPEED = [string] [EOL] ATTR_ILLUMINANCE = [string] [EOL] ATTR_FILTER_RFID_PRODUCT_ID = [string] [EOL] ATTR_FILTER_RFID_TAG = [string] [EOL] ATTR_FILTER_TYPE = [string] [EOL] ATTR_LEARN_MODE = [string] [EOL] ATTR_SLEEP_TIME = [string] [EOL] ATTR_SLEEP_LEARN_COUNT = [string] [EOL] ATTR_EXTRA_FEATURES = [string] [EOL] ATTR_FEATURES = [string] [EOL] ATTR_TURBO_MODE_SUPPORTED = [string] [EOL] ATTR_AUTO_DETECT = [string] [EOL] ATTR_SLEEP_MODE = [string] [EOL] ATTR_VOLUME = [string] [EOL] ATTR_USE_TIME = [string] [EOL] ATTR_BUTTON_PRESSED = [string] [EOL] [EOL] [comment] [EOL] ATTR_TARGET_HUMIDITY = [string] [EOL] ATTR_TRANS_LEVEL = [string] [EOL] ATTR_HARDWARE_VERSION = [string] [EOL] [EOL] [comment] [EOL] ATTR_SPEED = [string] [EOL] ATTR_DEPTH = [string] [EOL] ATTR_DRY = [string] [EOL] [EOL] [comment] [EOL] AVAILABLE_ATTRIBUTES_AIRPURIFIER_COMMON = { ATTR_TEMPERATURE : [string] , ATTR_HUMIDITY : [string] , ATTR_AIR_QUALITY_INDEX : [string] , ATTR_MODE : [string] , ATTR_FILTER_HOURS_USED : [string] , ATTR_FILTER_LIFE : [string] , ATTR_FAVORITE_LEVEL : [string] , ATTR_CHILD_LOCK : [string] , ATTR_LED : [string] , ATTR_MOTOR_SPEED : [string] , ATTR_AVERAGE_AIR_QUALITY_INDEX : [string] , ATTR_PURIFY_VOLUME : [string] , ATTR_LEARN_MODE : [string] , ATTR_SLEEP_TIME : [string] , ATTR_SLEEP_LEARN_COUNT : [string] , ATTR_EXTRA_FEATURES : [string] , ATTR_TURBO_MODE_SUPPORTED : [string] , ATTR_AUTO_DETECT : [string] , ATTR_USE_TIME : [string] , ATTR_BUTTON_PRESSED : [string] , } [EOL] [EOL] AVAILABLE_ATTRIBUTES_AIRPURIFIER = { ** AVAILABLE_ATTRIBUTES_AIRPURIFIER_COMMON , ATTR_BUZZER : [string] , ATTR_LED_BRIGHTNESS : [string] , ATTR_SLEEP_MODE : [string] , } [EOL] [EOL] AVAILABLE_ATTRIBUTES_AIRPURIFIER_PRO = { ** AVAILABLE_ATTRIBUTES_AIRPURIFIER_COMMON , ATTR_FILTER_RFID_PRODUCT_ID : [string] , ATTR_FILTER_RFID_TAG : [string] , ATTR_FILTER_TYPE : [string] , ATTR_ILLUMINANCE : [string] , ATTR_MOTOR2_SPEED : [string] , ATTR_VOLUME : [string] , } [EOL] [EOL] AVAILABLE_ATTRIBUTES_AIRPURIFIER_V3 = { ATTR_AIR_QUALITY_INDEX : [string] , ATTR_MODE : [string] , ATTR_LED : [string] , ATTR_BUZZER : [string] , ATTR_CHILD_LOCK : [string] , ATTR_ILLUMINANCE : [string] , ATTR_FILTER_HOURS_USED : [string] , ATTR_FILTER_LIFE : [string] , ATTR_MOTOR_SPEED : [string] , ATTR_AVERAGE_AIR_QUALITY_INDEX : [string] , ATTR_VOLUME : [string] , ATTR_MOTOR2_SPEED : [string] , ATTR_FILTER_RFID_PRODUCT_ID : [string] , ATTR_FILTER_RFID_TAG : [string] , ATTR_FILTER_TYPE : [string] , ATTR_PURIFY_VOLUME : [string] , ATTR_LEARN_MODE : [string] , ATTR_SLEEP_TIME : [string] , ATTR_SLEEP_LEARN_COUNT : [string] , ATTR_EXTRA_FEATURES : [string] , ATTR_AUTO_DETECT : [string] , ATTR_USE_TIME : [string] , ATTR_BUTTON_PRESSED : [string] , } [EOL] [EOL] AVAILABLE_ATTRIBUTES_AIRHUMIDIFIER = { ATTR_TEMPERATURE : [string] , ATTR_HUMIDITY : [string] , ATTR_MODE : [string] , ATTR_BUZZER : [string] , ATTR_CHILD_LOCK : [string] , ATTR_TRANS_LEVEL : [string] , ATTR_TARGET_HUMIDITY : [string] , ATTR_LED_BRIGHTNESS : [string] , ATTR_BUTTON_PRESSED : [string] , ATTR_USE_TIME : [string] , ATTR_HARDWARE_VERSION : [string] , } [EOL] [EOL] AVAILABLE_ATTRIBUTES_AIRHUMIDIFIER_CA = { ** AVAILABLE_ATTRIBUTES_AIRHUMIDIFIER , ATTR_SPEED : [string] , ATTR_DEPTH : [string] , ATTR_DRY : [string] , } [EOL] [EOL] OPERATION_MODES_AIRPURIFIER = [ [string] , [string] , [string] , [string] ] [EOL] OPERATION_MODES_AIRPURIFIER_PRO = [ [string] , [string] , [string] ] [EOL] OPERATION_MODES_AIRPURIFIER_V3 = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] SUCCESS = [ [string] ] [EOL] [EOL] FEATURE_SET_BUZZER = [number] [EOL] FEATURE_SET_LED = [number] [EOL] FEATURE_SET_CHILD_LOCK = [number] [EOL] FEATURE_SET_LED_BRIGHTNESS = [number] [EOL] FEATURE_SET_FAVORITE_LEVEL = [number] [EOL] FEATURE_SET_AUTO_DETECT = [number] [EOL] FEATURE_SET_LEARN_MODE = [number] [EOL] FEATURE_SET_VOLUME = [number] [EOL] FEATURE_RESET_FILTER = [number] [EOL] FEATURE_SET_EXTRA_FEATURES = [number] [EOL] FEATURE_SET_TARGET_HUMIDITY = [number] [EOL] FEATURE_SET_DRY = [number] [EOL] [EOL] FEATURE_FLAGS_GENERIC = ( FEATURE_SET_BUZZER | FEATURE_SET_CHILD_LOCK ) [EOL] [EOL] FEATURE_FLAGS_AIRPURIFIER = ( FEATURE_FLAGS_GENERIC | FEATURE_SET_LED | FEATURE_SET_LED_BRIGHTNESS | FEATURE_SET_FAVORITE_LEVEL | FEATURE_SET_LEARN_MODE | FEATURE_RESET_FILTER | FEATURE_SET_EXTRA_FEATURES ) [EOL] [EOL] FEATURE_FLAGS_AIRPURIFIER_PRO = ( FEATURE_SET_CHILD_LOCK | FEATURE_SET_LED | FEATURE_SET_FAVORITE_LEVEL | FEATURE_SET_AUTO_DETECT | FEATURE_SET_VOLUME ) [EOL] [EOL] FEATURE_FLAGS_AIRPURIFIER_V3 = ( FEATURE_FLAGS_GENERIC | FEATURE_SET_LED ) [EOL] [EOL] FEATURE_FLAGS_AIRHUMIDIFIER = ( FEATURE_FLAGS_GENERIC | FEATURE_SET_LED_BRIGHTNESS | FEATURE_SET_TARGET_HUMIDITY ) [EOL] [EOL] FEATURE_FLAGS_AIRHUMIDIFIER_CA = ( FEATURE_FLAGS_AIRHUMIDIFIER | FEATURE_SET_DRY ) [EOL] [EOL] SERVICE_SET_BUZZER_ON = [string] [EOL] SERVICE_SET_BUZZER_OFF = [string] [EOL] SERVICE_SET_LED_ON = [string] [EOL] SERVICE_SET_LED_OFF = [string] [EOL] SERVICE_SET_CHILD_LOCK_ON = [string] [EOL] SERVICE_SET_CHILD_LOCK_OFF = [string] [EOL] SERVICE_SET_LED_BRIGHTNESS = [string] [EOL] SERVICE_SET_FAVORITE_LEVEL = [string] [EOL] SERVICE_SET_AUTO_DETECT_ON = [string] [EOL] SERVICE_SET_AUTO_DETECT_OFF = [string] [EOL] SERVICE_SET_LEARN_MODE_ON = [string] [EOL] SERVICE_SET_LEARN_MODE_OFF = [string] [EOL] SERVICE_SET_VOLUME = [string] [EOL] SERVICE_RESET_FILTER = [string] [EOL] SERVICE_SET_EXTRA_FEATURES = [string] [EOL] SERVICE_SET_TARGET_HUMIDITY = [string] [EOL] SERVICE_SET_DRY_ON = [string] [EOL] SERVICE_SET_DRY_OFF = [string] [EOL] [EOL] AIRPURIFIER_SERVICE_SCHEMA = vol . Schema ( { vol . Optional ( ATTR_ENTITY_ID ) : cv . entity_ids , } ) [EOL] [EOL] SERVICE_SCHEMA_LED_BRIGHTNESS = AIRPURIFIER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_BRIGHTNESS ) : vol . All ( vol . Coerce ( int ) , vol . Clamp ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] SERVICE_SCHEMA_FAVORITE_LEVEL = AIRPURIFIER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_LEVEL ) : vol . All ( vol . Coerce ( int ) , vol . Clamp ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] SERVICE_SCHEMA_VOLUME = AIRPURIFIER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_VOLUME ) : vol . All ( vol . Coerce ( int ) , vol . Clamp ( min = [number] , max = [number] ) ) } ) [EOL] [EOL] SERVICE_SCHEMA_EXTRA_FEATURES = AIRPURIFIER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_FEATURES ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] ) ) } ) [EOL] [EOL] SERVICE_SCHEMA_TARGET_HUMIDITY = AIRPURIFIER_SERVICE_SCHEMA . extend ( { vol . Required ( ATTR_HUMIDITY ) : vol . All ( vol . Coerce ( int ) , vol . In ( [ [number] , [number] , [number] , [number] , [number] , [number] ] ) ) } ) [EOL] [EOL] SERVICE_TO_METHOD = { SERVICE_SET_BUZZER_ON : { [string] : [string] } , SERVICE_SET_BUZZER_OFF : { [string] : [string] } , SERVICE_SET_LED_ON : { [string] : [string] } , SERVICE_SET_LED_OFF : { [string] : [string] } , SERVICE_SET_CHILD_LOCK_ON : { [string] : [string] } , SERVICE_SET_CHILD_LOCK_OFF : { [string] : [string] } , SERVICE_SET_AUTO_DETECT_ON : { [string] : [string] } , SERVICE_SET_AUTO_DETECT_OFF : { [string] : [string] } , SERVICE_SET_LEARN_MODE_ON : { [string] : [string] } , SERVICE_SET_LEARN_MODE_OFF : { [string] : [string] } , SERVICE_RESET_FILTER : { [string] : [string] } , SERVICE_SET_LED_BRIGHTNESS : { [string] : [string] , [string] : SERVICE_SCHEMA_LED_BRIGHTNESS } , SERVICE_SET_FAVORITE_LEVEL : { [string] : [string] , [string] : SERVICE_SCHEMA_FAVORITE_LEVEL } , SERVICE_SET_VOLUME : { [string] : [string] , [string] : SERVICE_SCHEMA_VOLUME } , SERVICE_SET_EXTRA_FEATURES : { [string] : [string] , [string] : SERVICE_SCHEMA_EXTRA_FEATURES } , SERVICE_SET_TARGET_HUMIDITY : { [string] : [string] , [string] : SERVICE_SCHEMA_TARGET_HUMIDITY } , SERVICE_SET_DRY_ON : { [string] : [string] } , SERVICE_SET_DRY_OFF : { [string] : [string] } , } [EOL] [EOL] [EOL] async def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from miio import Device , DeviceException [EOL] if DATA_KEY not in hass . data : [EOL] hass . data [ DATA_KEY ] = { } [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] name = config . get ( CONF_NAME ) [EOL] token = config . get ( CONF_TOKEN ) [EOL] model = config . get ( CONF_MODEL ) [EOL] [EOL] _LOGGER . info ( [string] , host , token [ : [number] ] ) [EOL] unique_id = None [EOL] [EOL] if model is None : [EOL] try : [EOL] miio_device = Device ( host , token ) [EOL] device_info = miio_device . info ( ) [EOL] model = device_info . model [EOL] unique_id = [string] . format ( model , device_info . mac_address ) [EOL] _LOGGER . info ( [string] , model , device_info . firmware_version , device_info . hardware_version ) [EOL] except DeviceException : [EOL] raise PlatformNotReady [EOL] [EOL] if model . startswith ( [string] ) : [EOL] from miio import AirPurifier [EOL] air_purifier = AirPurifier ( host , token ) [EOL] device = XiaomiAirPurifier ( name , air_purifier , model , unique_id ) [EOL] elif model . startswith ( [string] ) : [EOL] from miio import AirHumidifier [EOL] air_humidifier = AirHumidifier ( host , token ) [EOL] device = XiaomiAirHumidifier ( name , air_humidifier , model , unique_id ) [EOL] else : [EOL] _LOGGER . error ( [string] [string] [string] , model ) [EOL] return False [EOL] [EOL] hass . data [ DATA_KEY ] [ host ] = device [EOL] async_add_devices ( [ device ] , update_before_add = True ) [EOL] [EOL] async def async_service_handler ( service ) : [EOL] [docstring] [EOL] method = SERVICE_TO_METHOD . get ( service . service ) [EOL] params = { key : value for key , value in service . data . items ( ) if key != ATTR_ENTITY_ID } [EOL] entity_ids = service . data . get ( ATTR_ENTITY_ID ) [EOL] if entity_ids : [EOL] devices = [ device for device in hass . data [ DATA_KEY ] . values ( ) if device . entity_id in entity_ids ] [EOL] else : [EOL] devices = hass . data [ DATA_KEY ] . values ( ) [EOL] [EOL] update_tasks = [ ] [EOL] for device in devices : [EOL] if not hasattr ( device , method [ [string] ] ) : [EOL] continue [EOL] await getattr ( device , method [ [string] ] ) ( ** params ) [EOL] update_tasks . append ( device . async_update_ha_state ( True ) ) [EOL] [EOL] if update_tasks : [EOL] await asyncio . wait ( update_tasks , loop = hass . loop ) [EOL] [EOL] for air_purifier_service in SERVICE_TO_METHOD : [EOL] schema = SERVICE_TO_METHOD [ air_purifier_service ] . get ( [string] , AIRPURIFIER_SERVICE_SCHEMA ) [EOL] hass . services . async_register ( DOMAIN , air_purifier_service , async_service_handler , schema = schema ) [EOL] [EOL] [EOL] class XiaomiGenericDevice ( FanEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , device , model , unique_id ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _device = device [EOL] self . _model = model [EOL] self . _unique_id = unique_id [EOL] [EOL] self . _available = False [EOL] self . _state = None [EOL] self . _state_attrs = { ATTR_MODEL : self . _model , } [EOL] self . _device_features = FEATURE_FLAGS_GENERIC [EOL] self . _skip_update = False [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SET_SPEED [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _available [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return self . _state_attrs [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ staticmethod def _extract_value_from_attribute ( state , attribute ) : [EOL] value = getattr ( state , attribute ) [EOL] if isinstance ( value , Enum ) : [EOL] return value . value [EOL] [EOL] return value [EOL] [EOL] async def _try_command ( self , mask_error , func , * args , ** kwargs ) : [EOL] [docstring] [EOL] from miio import DeviceException [EOL] try : [EOL] result = await self . hass . async_add_job ( partial ( func , * args , ** kwargs ) ) [EOL] [EOL] _LOGGER . debug ( [string] , result ) [EOL] [EOL] return result == SUCCESS [EOL] except DeviceException as exc : [EOL] _LOGGER . error ( mask_error , exc ) [EOL] self . _available = False [EOL] return False [EOL] [EOL] async def async_turn_on ( self , speed = None , ** kwargs ) : [EOL] [docstring] [EOL] if speed : [EOL] [comment] [EOL] result = await self . async_set_speed ( speed ) [EOL] else : [EOL] result = await self . _try_command ( [string] , self . _device . on ) [EOL] [EOL] if result : [EOL] self . _state = True [EOL] self . _skip_update = True [EOL] [EOL] async def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] result = await self . _try_command ( [string] , self . _device . off ) [EOL] [EOL] if result : [EOL] self . _state = False [EOL] self . _skip_update = True [EOL] [EOL] async def async_set_buzzer_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_BUZZER == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_buzzer , True ) [EOL] [EOL] async def async_set_buzzer_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_BUZZER == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_buzzer , False ) [EOL] [EOL] async def async_set_child_lock_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_CHILD_LOCK == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_child_lock , True ) [EOL] [EOL] async def async_set_child_lock_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_CHILD_LOCK == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_child_lock , False ) [EOL] [EOL] [EOL] class XiaomiAirPurifier ( XiaomiGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , device , model , unique_id ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( name , device , model , unique_id ) [EOL] [EOL] if self . _model == MODEL_AIRPURIFIER_PRO : [EOL] self . _device_features = FEATURE_FLAGS_AIRPURIFIER_PRO [EOL] self . _available_attributes = AVAILABLE_ATTRIBUTES_AIRPURIFIER_PRO [EOL] self . _speed_list = OPERATION_MODES_AIRPURIFIER_PRO [EOL] elif self . _model == MODEL_AIRPURIFIER_V3 : [EOL] self . _device_features = FEATURE_FLAGS_AIRPURIFIER_V3 [EOL] self . _available_attributes = AVAILABLE_ATTRIBUTES_AIRPURIFIER_V3 [EOL] self . _speed_list = OPERATION_MODES_AIRPURIFIER_V3 [EOL] else : [EOL] self . _device_features = FEATURE_FLAGS_AIRPURIFIER [EOL] self . _available_attributes = AVAILABLE_ATTRIBUTES_AIRPURIFIER [EOL] self . _speed_list = OPERATION_MODES_AIRPURIFIER [EOL] [EOL] self . _state_attrs . update ( { attribute : None for attribute in self . _available_attributes } ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from miio import DeviceException [EOL] [EOL] [comment] [EOL] if self . _skip_update : [EOL] self . _skip_update = False [EOL] return [EOL] [EOL] try : [EOL] state = await self . hass . async_add_job ( self . _device . status ) [EOL] _LOGGER . debug ( [string] , state ) [EOL] [EOL] self . _available = True [EOL] self . _state = state . is_on [EOL] self . _state_attrs . update ( { key : self . _extract_value_from_attribute ( state , value ) for key , value in self . _available_attributes . items ( ) } ) [EOL] [EOL] except DeviceException as ex : [EOL] self . _available = False [EOL] _LOGGER . error ( [string] , ex ) [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return self . _speed_list [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] if self . _state : [EOL] from miio . airpurifier import OperationMode [EOL] [EOL] return OperationMode ( self . _state_attrs [ ATTR_MODE ] ) . name [EOL] [EOL] return None [EOL] [EOL] async def async_set_speed ( self , speed ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_SET_SPEED == [number] : [EOL] return [EOL] [EOL] from miio . airpurifier import OperationMode [EOL] [EOL] _LOGGER . debug ( [string] , speed ) [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_mode , OperationMode [ speed . title ( ) ] ) [EOL] [EOL] async def async_set_led_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LED == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_led , True ) [EOL] [EOL] async def async_set_led_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LED == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_led , False ) [EOL] [EOL] async def async_set_led_brightness ( self , brightness = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LED_BRIGHTNESS == [number] : [EOL] return [EOL] [EOL] from miio . airpurifier import LedBrightness [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_led_brightness , LedBrightness ( brightness ) ) [EOL] [EOL] async def async_set_favorite_level ( self , level = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_FAVORITE_LEVEL == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_favorite_level , level ) [EOL] [EOL] async def async_set_auto_detect_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_AUTO_DETECT == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_auto_detect , True ) [EOL] [EOL] async def async_set_auto_detect_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_AUTO_DETECT == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_auto_detect , False ) [EOL] [EOL] async def async_set_learn_mode_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LEARN_MODE == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_learn_mode , True ) [EOL] [EOL] async def async_set_learn_mode_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LEARN_MODE == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_learn_mode , False ) [EOL] [EOL] async def async_set_volume ( self , volume = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_VOLUME == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_volume , volume ) [EOL] [EOL] async def async_set_extra_features ( self , features = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_EXTRA_FEATURES == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_extra_features , features ) [EOL] [EOL] async def async_reset_filter ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_RESET_FILTER == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . reset_filter ) [EOL] [EOL] [EOL] class XiaomiAirHumidifier ( XiaomiGenericDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , device , model , unique_id ) : [EOL] [docstring] [EOL] from miio . airhumidifier import OperationMode [EOL] [EOL] super ( ) . __init__ ( name , device , model , unique_id ) [EOL] [EOL] if self . _model == MODEL_AIRHUMIDIFIER_CA : [EOL] self . _device_features = FEATURE_FLAGS_AIRHUMIDIFIER_CA [EOL] self . _available_attributes = AVAILABLE_ATTRIBUTES_AIRHUMIDIFIER_CA [EOL] self . _speed_list = [ mode . name for mode in OperationMode ] [EOL] else : [EOL] self . _device_features = FEATURE_FLAGS_AIRHUMIDIFIER [EOL] self . _available_attributes = AVAILABLE_ATTRIBUTES_AIRHUMIDIFIER [EOL] self . _speed_list = [ mode . name for mode in OperationMode if mode . name != [string] ] [EOL] [EOL] self . _state_attrs . update ( { attribute : None for attribute in self . _available_attributes } ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] from miio import DeviceException [EOL] [EOL] [comment] [EOL] if self . _skip_update : [EOL] self . _skip_update = False [EOL] return [EOL] [EOL] try : [EOL] state = await self . hass . async_add_job ( self . _device . status ) [EOL] _LOGGER . debug ( [string] , state ) [EOL] [EOL] self . _available = True [EOL] self . _state = state . is_on [EOL] self . _state_attrs . update ( { key : self . _extract_value_from_attribute ( state , value ) for key , value in self . _available_attributes . items ( ) } ) [EOL] [EOL] except DeviceException as ex : [EOL] self . _available = False [EOL] _LOGGER . error ( [string] , ex ) [EOL] [EOL] @ property def speed_list ( self ) : [EOL] [docstring] [EOL] return self . _speed_list [EOL] [EOL] @ property def speed ( self ) : [EOL] [docstring] [EOL] if self . _state : [EOL] from miio . airhumidifier import OperationMode [EOL] [EOL] return OperationMode ( self . _state_attrs [ ATTR_MODE ] ) . name [EOL] [EOL] return None [EOL] [EOL] async def async_set_speed ( self , speed ) : [EOL] [docstring] [EOL] if self . supported_features & SUPPORT_SET_SPEED == [number] : [EOL] return [EOL] [EOL] from miio . airhumidifier import OperationMode [EOL] [EOL] _LOGGER . debug ( [string] , speed ) [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_mode , OperationMode [ speed . title ( ) ] ) [EOL] [EOL] async def async_set_led_brightness ( self , brightness = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_LED_BRIGHTNESS == [number] : [EOL] return [EOL] [EOL] from miio . airhumidifier import LedBrightness [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_led_brightness , LedBrightness ( brightness ) ) [EOL] [EOL] async def async_set_target_humidity ( self , humidity = [number] ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_TARGET_HUMIDITY == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_target_humidity , humidity ) [EOL] [EOL] async def async_set_dry_on ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_DRY == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_dry , True ) [EOL] [EOL] async def async_set_dry_off ( self ) : [EOL] [docstring] [EOL] if self . _device_features & FEATURE_SET_DRY == [number] : [EOL] return [EOL] [EOL] await self . _try_command ( [string] , self . _device . set_dry , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] KEY_AUTHENTICATED = [string] [EOL] KEY_REAL_IP = [string] [EOL]	0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] DATA_INSTANCE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] DOMAIN = [string] [EOL]	0 0 $builtins.str$ 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant import config_entries [EOL] from homeassistant . helpers . aiohttp_client import async_get_clientsession [EOL] from homeassistant . core import callback [EOL] [EOL] from . const import ( HMIPC_HAPID , HMIPC_AUTHTOKEN , HMIPC_PIN , HMIPC_NAME , COMPONENTS ) [EOL] from . errors import HmipcConnectionError [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class HomematicipAuth ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . config = config [EOL] self . auth = None [EOL] [EOL] async def async_setup ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . auth = await self . get_auth ( self . hass , self . config . get ( HMIPC_HAPID ) , self . config . get ( HMIPC_PIN ) ) [EOL] return True [EOL] except HmipcConnectionError : [EOL] return False [EOL] [EOL] async def async_checkbutton ( self ) : [EOL] [docstring] [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] try : [EOL] await self . auth . isRequestAcknowledged ( ) [EOL] return True [EOL] except HmipConnectionError : [EOL] return False [EOL] [EOL] async def async_register ( self ) : [EOL] [docstring] [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] try : [EOL] authtoken = await self . auth . requestAuthToken ( ) [EOL] await self . auth . confirmAuthToken ( authtoken ) [EOL] return authtoken [EOL] except HmipConnectionError : [EOL] return False [EOL] [EOL] async def get_auth ( self , hass , hapid , pin ) : [EOL] [docstring] [EOL] from homematicip . aio . auth import AsyncAuth [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] auth = AsyncAuth ( hass . loop , async_get_clientsession ( hass ) ) [EOL] print ( auth ) [EOL] try : [EOL] await auth . init ( hapid ) [EOL] if pin : [EOL] auth . pin = pin [EOL] await auth . connectionRequest ( [string] ) [EOL] except HmipConnectionError : [EOL] return False [EOL] return auth [EOL] [EOL] [EOL] class HomematicipHAP ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , config_entry ) : [EOL] [docstring] [EOL] self . hass = hass [EOL] self . config_entry = config_entry [EOL] self . home = None [EOL] [EOL] self . _ws_close_requested = False [EOL] self . _retry_task = None [EOL] self . _tries = [number] [EOL] self . _accesspoint_connected = True [EOL] self . _retry_setup = None [EOL] [EOL] async def async_setup ( self , tries = [number] ) : [EOL] [docstring] [EOL] try : [EOL] self . home = await self . get_hap ( self . hass , self . config_entry . data . get ( HMIPC_HAPID ) , self . config_entry . data . get ( HMIPC_AUTHTOKEN ) , self . config_entry . data . get ( HMIPC_NAME ) ) [EOL] except HmipcConnectionError : [EOL] retry_delay = [number] ** min ( tries + [number] , [number] ) [EOL] _LOGGER . error ( [string] [string] , self . config_entry . data . get ( HMIPC_HAPID ) , retry_delay ) [EOL] [EOL] async def retry_setup ( _now ) : [EOL] [docstring] [EOL] if await self . async_setup ( tries + [number] ) : [EOL] self . config_entry . state = config_entries . ENTRY_STATE_LOADED [EOL] [EOL] self . _retry_setup = self . hass . helpers . event . async_call_later ( retry_delay , retry_setup ) [EOL] [EOL] return False [EOL] [EOL] _LOGGER . info ( [string] , self . config_entry . data . get ( HMIPC_HAPID ) ) [EOL] [EOL] for component in COMPONENTS : [EOL] self . hass . async_add_job ( self . hass . config_entries . async_forward_entry_setup ( self . config_entry , component ) ) [EOL] return True [EOL] [EOL] @ callback def async_update ( self , * args , ** kwargs ) : [EOL] [docstring] [EOL] if not self . home . connected : [EOL] _LOGGER . error ( [string] ) [EOL] self . _accesspoint_connected = False [EOL] self . set_all_to_unavailable ( ) [EOL] elif not self . _accesspoint_connected : [EOL] [comment] [EOL] [comment] [EOL] [EOL] job = self . hass . async_add_job ( self . get_state ( ) ) [EOL] job . add_done_callback ( self . get_state_finished ) [EOL] [EOL] async def get_state ( self ) : [EOL] [docstring] [EOL] await self . home . get_current_state ( ) [EOL] self . update_all ( ) [EOL] [EOL] def get_state_finished ( self , future ) : [EOL] [docstring] [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] try : [EOL] future . result ( ) [EOL] except HmipConnectionError : [EOL] [comment] [EOL] [comment] [EOL] _LOGGER . error ( [string] ) [EOL] self . hass . async_add_job ( self . home . disable_events ( ) ) [EOL] [EOL] def set_all_to_unavailable ( self ) : [EOL] [docstring] [EOL] for device in self . home . devices : [EOL] device . unreach = True [EOL] self . update_all ( ) [EOL] [EOL] def update_all ( self ) : [EOL] [docstring] [EOL] for device in self . home . devices : [EOL] device . fire_update_event ( ) [EOL] [EOL] async def _handle_connection ( self ) : [EOL] [docstring] [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] try : [EOL] await self . home . get_current_state ( ) [EOL] except HmipConnectionError : [EOL] return [EOL] hmip_events = await self . home . enable_events ( ) [EOL] try : [EOL] await hmip_events [EOL] except HmipConnectionError : [EOL] return [EOL] [EOL] async def async_connect ( self ) : [EOL] [docstring] [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] tries = [number] [EOL] while True : [EOL] try : [EOL] await self . home . get_current_state ( ) [EOL] hmip_events = await self . home . enable_events ( ) [EOL] tries = [number] [EOL] await hmip_events [EOL] except HmipConnectionError : [EOL] pass [EOL] [EOL] if self . _ws_close_requested : [EOL] break [EOL] self . _ws_close_requested = False [EOL] [EOL] tries += [number] [EOL] retry_delay = [number] ** min ( tries + [number] , [number] ) [EOL] _LOGGER . error ( [string] [string] , self . config_entry . data . get ( HMIPC_HAPID ) , retry_delay ) [EOL] try : [EOL] self . _retry_task = self . hass . async_add_job ( asyncio . sleep ( retry_delay , loop = self . hass . loop ) ) [EOL] await self . _retry_task [EOL] except asyncio . CancelledError : [EOL] break [EOL] [EOL] async def async_reset ( self ) : [EOL] [docstring] [EOL] self . _ws_close_requested = True [EOL] if self . _retry_setup is not None : [EOL] self . _retry_setup . cancel ( ) [EOL] if self . _retry_task is not None : [EOL] self . _retry_task . cancel ( ) [EOL] self . home . disable_events ( ) [EOL] _LOGGER . info ( [string] ) [EOL] for component in COMPONENTS : [EOL] await self . hass . config_entries . async_forward_entry_unload ( self . config_entry , component ) [EOL] return True [EOL] [EOL] async def get_hap ( self , hass , hapid , authtoken , name ) : [EOL] [docstring] [EOL] from homematicip . aio . home import AsyncHome [EOL] from homematicip . base . base_connection import HmipConnectionError [EOL] [EOL] home = AsyncHome ( hass . loop , async_get_clientsession ( hass ) ) [EOL] [EOL] home . name = name [EOL] home . label = [string] [EOL] home . modelType = [string] [EOL] [EOL] home . set_auth_token ( authtoken ) [EOL] try : [EOL] await home . init ( hapid ) [EOL] await home . get_current_state ( ) [EOL] except HmipConnectionError : [EOL] raise HmipcConnectionError [EOL] home . on_update ( self . async_update ) [EOL] hass . loop . create_task ( self . async_connect ( ) ) [EOL] [EOL] return home [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HmipcException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionError ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcConnectionWait ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcRegistrationFailed ( HmipcException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class HmipcPressButton ( HmipcException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import struct [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . const import ( CONF_NAME , CONF_SLAVE , ATTR_TEMPERATURE ) [EOL] from homeassistant . components . climate import ( ClimateDevice , PLATFORM_SCHEMA , SUPPORT_TARGET_TEMPERATURE ) [EOL] [EOL] import homeassistant . components . modbus as modbus [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [comment] [EOL] CONF_TARGET_TEMP = [string] [EOL] CONF_CURRENT_TEMP = [string] [EOL] CONF_DATA_TYPE = [string] [EOL] CONF_COUNT = [string] [EOL] CONF_PRECISION = [string] [EOL] [EOL] DATA_TYPE_INT = [string] [EOL] DATA_TYPE_UINT = [string] [EOL] DATA_TYPE_FLOAT = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_SLAVE ) : cv . positive_int , vol . Required ( CONF_TARGET_TEMP ) : cv . positive_int , vol . Required ( CONF_CURRENT_TEMP ) : cv . positive_int , vol . Optional ( CONF_DATA_TYPE , default = DATA_TYPE_FLOAT ) : vol . In ( [ DATA_TYPE_INT , DATA_TYPE_UINT , DATA_TYPE_FLOAT ] ) , vol . Optional ( CONF_COUNT , default = [number] ) : cv . positive_int , vol . Optional ( CONF_PRECISION , default = [number] ) : cv . positive_int } ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_FLAGS = SUPPORT_TARGET_TEMPERATURE [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] modbus_slave = config . get ( CONF_SLAVE ) [EOL] target_temp_register = config . get ( CONF_TARGET_TEMP ) [EOL] current_temp_register = config . get ( CONF_CURRENT_TEMP ) [EOL] data_type = config . get ( CONF_DATA_TYPE ) [EOL] count = config . get ( CONF_COUNT ) [EOL] precision = config . get ( CONF_PRECISION ) [EOL] [EOL] add_devices ( [ ModbusThermostat ( name , modbus_slave , target_temp_register , current_temp_register , data_type , count , precision ) ] , True ) [EOL] [EOL] [EOL] class ModbusThermostat ( ClimateDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , modbus_slave , target_temp_register , current_temp_register , data_type , count , precision ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _slave = modbus_slave [EOL] self . _target_temperature_register = target_temp_register [EOL] self . _current_temperature_register = current_temp_register [EOL] self . _target_temperature = None [EOL] self . _current_temperature = None [EOL] self . _data_type = data_type [EOL] self . _count = int ( count ) [EOL] self . _precision = precision [EOL] self . _structure = [string] [EOL] [EOL] data_types = { DATA_TYPE_INT : { [number] : [string] , [number] : [string] , [number] : [string] } , DATA_TYPE_UINT : { [number] : [string] , [number] : [string] , [number] : [string] } , DATA_TYPE_FLOAT : { [number] : [string] , [number] : [string] , [number] : [string] } } [EOL] [EOL] self . _structure = [string] . format ( data_types [ self . _data_type ] [ self . _count ] ) [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_FLAGS [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _target_temperature = self . read_register ( self . _target_temperature_register ) [EOL] self . _current_temperature = self . read_register ( self . _current_temperature_register ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def current_temperature ( self ) : [EOL] [docstring] [EOL] return self . _current_temperature [EOL] [EOL] @ property def target_temperature ( self ) : [EOL] [docstring] [EOL] return self . _target_temperature [EOL] [EOL] def set_temperature ( self , ** kwargs ) : [EOL] [docstring] [EOL] target_temperature = kwargs . get ( ATTR_TEMPERATURE ) [EOL] if target_temperature is None : [EOL] return [EOL] byte_string = struct . pack ( self . _structure , target_temperature ) [EOL] register_value = struct . unpack ( [string] , byte_string [ [number] : [number] ] ) [ [number] ] [EOL] [EOL] try : [EOL] self . write_register ( self . _target_temperature_register , register_value ) [EOL] except AttributeError as ex : [EOL] _LOGGER . error ( ex ) [EOL] [EOL] def read_register ( self , register ) : [EOL] [docstring] [EOL] try : [EOL] result = modbus . HUB . read_holding_registers ( self . _slave , register , self . _count ) [EOL] except AttributeError as ex : [EOL] _LOGGER . error ( ex ) [EOL] byte_string = [string] . join ( [ x . to_bytes ( [number] , byteorder = [string] ) for x in result . registers ] ) [EOL] val = struct . unpack ( self . _structure , byte_string ) [ [number] ] [EOL] register_value = format ( val , [string] . format ( self . _precision ) ) [EOL] return register_value [EOL] [EOL] def write_register ( self , register , value ) : [EOL] [docstring] [EOL] modbus . HUB . write_registers ( self . _slave , register , [ value , [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.int,builtins.str]]$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light , DOMAIN ) [EOL] from homeassistant . components . light . lutron import ( to_hass_level , to_lutron_level ) [EOL] from homeassistant . components . lutron_caseta import ( LUTRON_CASETA_SMARTBRIDGE , LutronCasetaDevice ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] devs = [ ] [EOL] bridge = hass . data [ LUTRON_CASETA_SMARTBRIDGE ] [EOL] light_devices = bridge . get_devices_by_domain ( DOMAIN ) [EOL] for light_device in light_devices : [EOL] dev = LutronCasetaLight ( light_device , bridge ) [EOL] devs . append ( dev ) [EOL] [EOL] async_add_devices ( devs , True ) [EOL] [EOL] [EOL] class LutronCasetaLight ( LutronCasetaDevice , Light ) : [EOL] [docstring] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return to_hass_level ( self . _state [ [string] ] ) [EOL] [EOL] @ asyncio . coroutine def async_turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] else : [EOL] brightness = [number] [EOL] self . _smartbridge . set_value ( self . _device_id , to_lutron_level ( brightness ) ) [EOL] [EOL] @ asyncio . coroutine def async_turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _smartbridge . set_value ( self . _device_id , [number] ) [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [ [string] ] > [number] [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] self . _state = self . _smartbridge . get_device_by_id ( self . _device_id ) [EOL] _LOGGER . debug ( self . _state ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , Light ) [EOL] from homeassistant . components . tellduslive import TelldusLiveEntity [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] add_devices ( TelldusLiveLight ( hass , light ) for light in discovery_info ) [EOL] [EOL] [EOL] class TelldusLiveLight ( TelldusLiveEntity , Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_id ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( hass , device_id ) [EOL] self . _last_brightness = self . brightness [EOL] [EOL] def changed ( self ) : [EOL] [docstring] [EOL] self . _last_brightness = self . brightness [EOL] super ( ) . changed ( ) [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . device . dim_level [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_BRIGHTNESS [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . device . is_on [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] brightness = kwargs . get ( ATTR_BRIGHTNESS , self . _last_brightness ) [EOL] self . device . dim ( level = brightness ) [EOL] self . changed ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . device . turn_off ( ) [EOL] self . changed ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , SUPPORT_BRIGHTNESS , ATTR_HS_COLOR , SUPPORT_COLOR , Light , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . util . color as color_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SUPPORT_SENSEHAT = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from sense_hat import SenseHat [EOL] sensehat = SenseHat ( ) [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] add_devices ( [ SenseHatLight ( sensehat , name ) ] ) [EOL] [EOL] [EOL] class SenseHatLight ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , sensehat , name ) : [EOL] [docstring] [EOL] self . _sensehat = sensehat [EOL] self . _name = name [EOL] self . _is_on = False [EOL] self . _brightness = [number] [EOL] self . _hs_color = [ [number] , [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs_color [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SENSEHAT [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _is_on [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def assumed_state ( self ) : [EOL] [docstring] [EOL] return True [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] self . _hs_color = kwargs [ ATTR_HS_COLOR ] [EOL] [EOL] rgb = color_util . color_hsv_to_RGB ( self . _hs_color [ [number] ] , self . _hs_color [ [number] ] , self . _brightness / [number] * [number] ) [EOL] self . _sensehat . clear ( * rgb ) [EOL] [EOL] self . _is_on = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _sensehat . clear ( ) [EOL] self . _is_on = False [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import random [EOL] import socket [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant import util [EOL] from homeassistant . components . light import ( ATTR_BRIGHTNESS , ATTR_COLOR_TEMP , ATTR_EFFECT , ATTR_HS_COLOR , ATTR_TRANSITION , EFFECT_RANDOM , PLATFORM_SCHEMA , SUPPORT_BRIGHTNESS , SUPPORT_COLOR , SUPPORT_COLOR_TEMP , SUPPORT_EFFECT , SUPPORT_TRANSITION , Light ) [EOL] from homeassistant . const import CONF_HOST [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util . color import ( color_temperature_kelvin_to_mired , color_temperature_mired_to_kelvin ) [EOL] import homeassistant . util . color as color_util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ALLOW_LIGHTIFY_NODES = [string] [EOL] CONF_ALLOW_LIGHTIFY_GROUPS = [string] [EOL] [EOL] DEFAULT_ALLOW_LIGHTIFY_NODES = True [EOL] DEFAULT_ALLOW_LIGHTIFY_GROUPS = True [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( milliseconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_OSRAMLIGHTIFY = ( SUPPORT_BRIGHTNESS | SUPPORT_COLOR_TEMP | SUPPORT_EFFECT | SUPPORT_COLOR | SUPPORT_TRANSITION ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_ALLOW_LIGHTIFY_NODES , default = DEFAULT_ALLOW_LIGHTIFY_NODES ) : cv . boolean , vol . Optional ( CONF_ALLOW_LIGHTIFY_GROUPS , default = DEFAULT_ALLOW_LIGHTIFY_GROUPS ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import lightify [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] add_nodes = config . get ( CONF_ALLOW_LIGHTIFY_NODES ) [EOL] add_groups = config . get ( CONF_ALLOW_LIGHTIFY_GROUPS ) [EOL] [EOL] try : [EOL] bridge = lightify . Lightify ( host ) [EOL] except socket . error as err : [EOL] msg = [string] . format ( host , str ( err ) ) [EOL] _LOGGER . exception ( msg ) [EOL] return [EOL] [EOL] setup_bridge ( bridge , add_devices , add_nodes , add_groups ) [EOL] [EOL] [EOL] def setup_bridge ( bridge , add_devices , add_nodes , add_groups ) : [EOL] [docstring] [EOL] lights = { } [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update_lights ( ) : [EOL] [docstring] [EOL] try : [EOL] bridge . update_all_light_status ( ) [EOL] bridge . update_group_list ( ) [EOL] except TimeoutError : [EOL] _LOGGER . error ( [string] ) [EOL] except OSError : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] new_lights = [ ] [EOL] [EOL] if add_nodes : [EOL] for ( light_id , light ) in bridge . lights ( ) . items ( ) : [EOL] if light_id not in lights : [EOL] osram_light = OsramLightifyLight ( light_id , light , update_lights ) [EOL] lights [ light_id ] = osram_light [EOL] new_lights . append ( osram_light ) [EOL] else : [EOL] lights [ light_id ] . light = light [EOL] [EOL] if add_groups : [EOL] for ( group_name , group ) in bridge . groups ( ) . items ( ) : [EOL] if group_name not in lights : [EOL] osram_group = OsramLightifyGroup ( group , bridge , update_lights ) [EOL] lights [ group_name ] = osram_group [EOL] new_lights . append ( osram_group ) [EOL] else : [EOL] lights [ group_name ] . group = group [EOL] [EOL] if new_lights : [EOL] add_devices ( new_lights ) [EOL] [EOL] update_lights ( ) [EOL] [EOL] [EOL] class Luminary ( Light ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , luminary , update_lights ) : [EOL] [docstring] [EOL] self . update_lights = update_lights [EOL] self . _luminary = luminary [EOL] self . _brightness = None [EOL] self . _hs = None [EOL] self . _name = None [EOL] self . _temperature = None [EOL] self . _state = False [EOL] self . update ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def hs_color ( self ) : [EOL] [docstring] [EOL] return self . _hs [EOL] [EOL] @ property def color_temp ( self ) : [EOL] [docstring] [EOL] return self . _temperature [EOL] [EOL] @ property def brightness ( self ) : [EOL] [docstring] [EOL] return self . _brightness [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_OSRAMLIGHTIFY [EOL] [EOL] @ property def effect_list ( self ) : [EOL] [docstring] [EOL] return [ EFFECT_RANDOM ] [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition = int ( kwargs [ ATTR_TRANSITION ] * [number] ) [EOL] else : [EOL] transition = [number] [EOL] [EOL] if ATTR_BRIGHTNESS in kwargs : [EOL] self . _brightness = kwargs [ ATTR_BRIGHTNESS ] [EOL] self . _luminary . set_luminance ( int ( self . _brightness / [number] ) , transition ) [EOL] else : [EOL] self . _luminary . set_onoff ( [number] ) [EOL] [EOL] if ATTR_HS_COLOR in kwargs : [EOL] red , green , blue = color_util . color_hs_to_RGB ( * kwargs [ ATTR_HS_COLOR ] ) [EOL] self . _luminary . set_rgb ( red , green , blue , transition ) [EOL] [EOL] if ATTR_COLOR_TEMP in kwargs : [EOL] color_t = kwargs [ ATTR_COLOR_TEMP ] [EOL] kelvin = int ( color_temperature_mired_to_kelvin ( color_t ) ) [EOL] self . _luminary . set_temperature ( kelvin , transition ) [EOL] [EOL] if ATTR_EFFECT in kwargs : [EOL] effect = kwargs . get ( ATTR_EFFECT ) [EOL] if effect == EFFECT_RANDOM : [EOL] self . _luminary . set_rgb ( random . randrange ( [number] , [number] ) , random . randrange ( [number] , [number] ) , random . randrange ( [number] , [number] ) , transition ) [EOL] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] if ATTR_TRANSITION in kwargs : [EOL] transition = int ( kwargs [ ATTR_TRANSITION ] * [number] ) [EOL] self . _luminary . set_luminance ( [number] , transition ) [EOL] else : [EOL] transition = [number] [EOL] self . _luminary . set_onoff ( [number] ) [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . update_lights ( no_throttle = True ) [EOL] self . _name = self . _luminary . name ( ) [EOL] [EOL] [EOL] class OsramLightifyLight ( Luminary ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , light_id , light , update_lights ) : [EOL] [docstring] [EOL] self . _light_id = light_id [EOL] super ( ) . __init__ ( light , update_lights ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] super ( ) . update ( ) [EOL] self . _state = self . _luminary . on ( ) [EOL] rgb = self . _luminary . rgb ( ) [EOL] self . _hs = color_util . color_RGB_to_hs ( * rgb ) [EOL] o_temp = self . _luminary . temp ( ) [EOL] if o_temp == [number] : [EOL] self . _temperature = None [EOL] else : [EOL] self . _temperature = color_temperature_kelvin_to_mired ( self . _luminary . temp ( ) ) [EOL] self . _brightness = int ( self . _luminary . lum ( ) * [number] ) [EOL] [EOL] [EOL] class OsramLightifyGroup ( Luminary ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , group , bridge , update_lights ) : [EOL] [docstring] [EOL] self . _bridge = bridge [EOL] self . _light_ids = [ ] [EOL] super ( ) . __init__ ( group , update_lights ) [EOL] [EOL] def _get_state ( self ) : [EOL] [docstring] [EOL] lights = self . _bridge . lights ( ) [EOL] return any ( lights [ light_id ] . on ( ) for light_id in self . _light_ids ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] super ( ) . update ( ) [EOL] self . _light_ids = self . _luminary . lights ( ) [EOL] light = self . _bridge . lights ( ) [ self . _light_ids [ [number] ] ] [EOL] self . _brightness = int ( light . lum ( ) * [number] ) [EOL] rgb = light . rgb ( ) [EOL] self . _hs = color_util . color_RGB_to_hs ( * rgb ) [EOL] o_temp = light . temp ( ) [EOL] if o_temp == [number] : [EOL] self . _temperature = None [EOL] else : [EOL] self . _temperature = color_temperature_kelvin_to_mired ( o_temp ) [EOL] self . _state = light . on ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . arduino as arduino [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_PINS = [string] [EOL] CONF_TYPE = [string] [EOL] CONF_NEGATE = [string] [EOL] CONF_INITIAL = [string] [EOL] [EOL] PIN_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , vol . Optional ( CONF_INITIAL , default = False ) : cv . boolean , vol . Optional ( CONF_NEGATE , default = False ) : cv . boolean , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PINS , default = { } ) : vol . Schema ( { cv . positive_int : PIN_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] [comment] [EOL] if arduino . BOARD is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] pins = config . get ( CONF_PINS ) [EOL] [EOL] switches = [ ] [EOL] for pinnum , pin in pins . items ( ) : [EOL] switches . append ( ArduinoSwitch ( pinnum , pin ) ) [EOL] add_devices ( switches ) [EOL] [EOL] [EOL] class ArduinoSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , pin , options ) : [EOL] [docstring] [EOL] self . _pin = pin [EOL] self . _name = options . get ( CONF_NAME ) [EOL] self . pin_type = CONF_TYPE [EOL] self . direction = [string] [EOL] [EOL] self . _state = options . get ( CONF_INITIAL ) [EOL] [EOL] if options . get ( CONF_NEGATE ) : [EOL] self . turn_on_handler = arduino . BOARD . set_digital_out_low [EOL] self . turn_off_handler = arduino . BOARD . set_digital_out_high [EOL] else : [EOL] self . turn_on_handler = arduino . BOARD . set_digital_out_high [EOL] self . turn_off_handler = arduino . BOARD . set_digital_out_low [EOL] [EOL] arduino . BOARD . set_mode ( self . _pin , self . direction , self . pin_type ) [EOL] ( self . turn_on_handler if self . _state else self . turn_off_handler ) ( pin ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = True [EOL] self . turn_on_handler ( self . _pin ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _state = False [EOL] self . turn_off_handler ( self . _pin ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . components . scsgate as scsgate [EOL] from homeassistant . components . switch import ( SwitchDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , ATTR_STATE , CONF_NAME , CONF_DEVICES ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] ATTR_SCENARIO_ID = [string] [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] CONF_TRADITIONAL = [string] [EOL] CONF_SCENARIO = [string] [EOL] [EOL] CONF_SCS_ID = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DEVICES ) : vol . Schema ( { cv . slug : scsgate . SCSGATE_SCHEMA } ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] _setup_traditional_switches ( logger = logger , config = config , add_devices_callback = add_devices ) [EOL] [EOL] _setup_scenario_switches ( logger = logger , config = config , hass = hass ) [EOL] [EOL] [EOL] def _setup_traditional_switches ( logger , config , add_devices_callback ) : [EOL] [docstring] [EOL] traditional = config . get ( CONF_TRADITIONAL ) [EOL] switches = [ ] [EOL] [EOL] if traditional : [EOL] for _ , entity_info in traditional . items ( ) : [EOL] if entity_info [ scsgate . CONF_SCS_ID ] in scsgate . SCSGATE . devices : [EOL] continue [EOL] [EOL] name = entity_info [ CONF_NAME ] [EOL] scs_id = entity_info [ scsgate . CONF_SCS_ID ] [EOL] [EOL] logger . info ( [string] , name ) [EOL] [EOL] switch = SCSGateSwitch ( name = name , scs_id = scs_id , logger = logger ) [EOL] switches . append ( switch ) [EOL] [EOL] add_devices_callback ( switches ) [EOL] scsgate . SCSGATE . add_devices_to_register ( switches ) [EOL] [EOL] [EOL] def _setup_scenario_switches ( logger , config , hass ) : [EOL] [docstring] [EOL] scenario = config . get ( CONF_SCENARIO ) [EOL] [EOL] if scenario : [EOL] for _ , entity_info in scenario . items ( ) : [EOL] if entity_info [ scsgate . CONF_SCS_ID ] in scsgate . SCSGATE . devices : [EOL] continue [EOL] [EOL] name = entity_info [ CONF_NAME ] [EOL] scs_id = entity_info [ scsgate . CONF_SCS_ID ] [EOL] [EOL] logger . info ( [string] , name ) [EOL] [EOL] switch = SCSGateScenarioSwitch ( name = name , scs_id = scs_id , logger = logger , hass = hass ) [EOL] scsgate . SCSGATE . add_device ( switch ) [EOL] [EOL] [EOL] class SCSGateSwitch ( SwitchDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , scs_id , name , logger ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _scs_id = scs_id [EOL] self . _toggled = False [EOL] self . _logger = logger [EOL] [EOL] @ property def scs_id ( self ) : [EOL] [docstring] [EOL] return self . _scs_id [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _toggled [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] from scsgate . tasks import ToggleStatusTask [EOL] [EOL] scsgate . SCSGATE . append_task ( ToggleStatusTask ( target = self . _scs_id , toggled = True ) ) [EOL] [EOL] self . _toggled = True [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] from scsgate . tasks import ToggleStatusTask [EOL] [EOL] scsgate . SCSGATE . append_task ( ToggleStatusTask ( target = self . _scs_id , toggled = False ) ) [EOL] [EOL] self . _toggled = False [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def process_event ( self , message ) : [EOL] [docstring] [EOL] if self . _toggled == message . toggled : [EOL] self . _logger . info ( [string] , self . _scs_id , message ) [EOL] [comment] [EOL] return [EOL] [EOL] self . _toggled = message . toggled [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] command = [string] [EOL] if self . _toggled : [EOL] command = [string] [EOL] [EOL] self . hass . bus . fire ( [string] , { ATTR_ENTITY_ID : self . _scs_id , ATTR_STATE : command } ) [EOL] [EOL] [EOL] class SCSGateScenarioSwitch ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , scs_id , name , logger , hass ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _scs_id = scs_id [EOL] self . _logger = logger [EOL] self . _hass = hass [EOL] [EOL] @ property def scs_id ( self ) : [EOL] [docstring] [EOL] return self . _scs_id [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] def process_event ( self , message ) : [EOL] [docstring] [EOL] from scsgate . messages import StateMessage , ScenarioTriggeredMessage [EOL] [EOL] if isinstance ( message , StateMessage ) : [EOL] scenario_id = message . bytes [ [number] ] [EOL] elif isinstance ( message , ScenarioTriggeredMessage ) : [EOL] scenario_id = message . scenario [EOL] else : [EOL] self . _logger . warn ( [string] , message ) [EOL] return [EOL] [EOL] self . _hass . bus . fire ( [string] , { ATTR_ENTITY_ID : int ( self . _scs_id ) , ATTR_SCENARIO_ID : int ( scenario_id , [number] ) } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.bool$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . switch import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_ID ) [EOL] from homeassistant . components import enocean [EOL] from homeassistant . helpers . entity import ToggleEntity [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] CONF_CHANNEL = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_ID ) : vol . All ( cv . ensure_list , [ vol . Coerce ( int ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_CHANNEL , default = [number] ) : cv . positive_int , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] dev_id = config . get ( CONF_ID ) [EOL] devname = config . get ( CONF_NAME ) [EOL] channel = config . get ( CONF_CHANNEL ) [EOL] [EOL] add_devices ( [ EnOceanSwitch ( dev_id , devname , channel ) ] ) [EOL] [EOL] [EOL] class EnOceanSwitch ( enocean . EnOceanDevice , ToggleEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , dev_id , devname , channel ) : [EOL] [docstring] [EOL] enocean . EnOceanDevice . __init__ ( self ) [EOL] self . dev_id = dev_id [EOL] self . _devname = devname [EOL] self . _light = None [EOL] self . _on_state = False [EOL] self . _on_state2 = False [EOL] self . channel = channel [EOL] self . stype = [string] [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _on_state [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _devname [EOL] [EOL] def turn_on ( self , ** kwargs ) : [EOL] [docstring] [EOL] optional = [ [number] , ] [EOL] optional . extend ( self . dev_id ) [EOL] optional . extend ( [ [number] , [number] ] ) [EOL] self . send_command ( data = [ [number] , [number] , self . channel & [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , optional = optional , packet_type = [number] ) [EOL] self . _on_state = True [EOL] [EOL] def turn_off ( self , ** kwargs ) : [EOL] [docstring] [EOL] optional = [ [number] , ] [EOL] optional . extend ( self . dev_id ) [EOL] optional . extend ( [ [number] , [number] ] ) [EOL] self . send_command ( data = [ [number] , [number] , self . channel & [number] , [number] , [number] , [number] , [number] , [number] , [number] ] , optional = optional , packet_type = [number] ) [EOL] self . _on_state = False [EOL] [EOL] def value_changed ( self , val ) : [EOL] [docstring] [EOL] self . _on_state = val [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . const import ATTR_BATTERY_LEVEL , ATTR_WAKEUP , ATTR_ENTITY_ID [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] from . const import ( ATTR_NODE_ID , COMMAND_CLASS_WAKE_UP , ATTR_SCENE_ID , ATTR_SCENE_DATA , ATTR_BASIC_LEVEL , EVENT_NODE_EVENT , EVENT_SCENE_ACTIVATED , COMMAND_CLASS_CENTRAL_SCENE ) [EOL] from . util import node_name , is_node_parsed [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_QUERY_STAGE = [string] [EOL] ATTR_AWAKE = [string] [EOL] ATTR_READY = [string] [EOL] ATTR_FAILED = [string] [EOL] ATTR_PRODUCT_NAME = [string] [EOL] ATTR_MANUFACTURER_NAME = [string] [EOL] ATTR_NODE_NAME = [string] [EOL] [EOL] STAGE_COMPLETE = [string] [EOL] [EOL] _REQUIRED_ATTRIBUTES = [ ATTR_QUERY_STAGE , ATTR_AWAKE , ATTR_READY , ATTR_FAILED , [string] , [string] , [string] ] [EOL] _OPTIONAL_ATTRIBUTES = [ [string] , [string] , [string] ] [EOL] _COMM_ATTRIBUTES = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] ATTRIBUTES = _REQUIRED_ATTRIBUTES + _OPTIONAL_ATTRIBUTES [EOL] [EOL] [EOL] class ZWaveBaseEntity ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] [docstring] [EOL] self . _update_scheduled = False [EOL] [EOL] def maybe_schedule_update ( self ) : [EOL] [docstring] [EOL] if self . hass and not self . _update_scheduled : [EOL] self . hass . add_job ( self . _schedule_update ) [EOL] [EOL] @ callback def _schedule_update ( self ) : [EOL] [docstring] [EOL] if self . _update_scheduled : [EOL] return [EOL] [EOL] @ callback def do_update ( ) : [EOL] [docstring] [EOL] self . hass . async_add_job ( self . async_update_ha_state ) [EOL] self . _update_scheduled = False [EOL] [EOL] self . _update_scheduled = True [EOL] self . hass . loop . call_later ( [number] , do_update ) [EOL] [EOL] def try_remove_and_add ( self ) : [EOL] [docstring] [EOL] async def _async_remove_and_add ( ) : [EOL] await self . async_remove ( ) [EOL] self . entity_id = None [EOL] await self . platform . async_add_entities ( [ self ] ) [EOL] if self . hass and self . platform : [EOL] self . hass . add_job ( _async_remove_and_add ) [EOL] [EOL] [EOL] class ZWaveNodeEntity ( ZWaveBaseEntity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , node , network ) : [EOL] [docstring] [EOL] [comment] [EOL] super ( ) . __init__ ( ) [EOL] from openzwave . network import ZWaveNetwork [EOL] from pydispatch import dispatcher [EOL] self . _network = network [EOL] self . node = node [EOL] self . node_id = self . node . node_id [EOL] self . _name = node_name ( self . node ) [EOL] self . _product_name = node . product_name [EOL] self . _manufacturer_name = node . manufacturer_name [EOL] self . _unique_id = self . _compute_unique_id ( ) [EOL] self . _attributes = { } [EOL] self . wakeup_interval = None [EOL] self . location = None [EOL] self . battery_level = None [EOL] dispatcher . connect ( self . network_node_changed , ZWaveNetwork . SIGNAL_VALUE_CHANGED ) [EOL] dispatcher . connect ( self . network_node_changed , ZWaveNetwork . SIGNAL_NODE ) [EOL] dispatcher . connect ( self . network_node_changed , ZWaveNetwork . SIGNAL_NOTIFICATION ) [EOL] dispatcher . connect ( self . network_node_event , ZWaveNetwork . SIGNAL_NODE_EVENT ) [EOL] dispatcher . connect ( self . network_scene_activated , ZWaveNetwork . SIGNAL_SCENE_EVENT ) [EOL] [EOL] @ property def unique_id ( self ) : [EOL] [docstring] [EOL] return self . _unique_id [EOL] [EOL] def network_node_changed ( self , node = None , value = None , args = None ) : [EOL] [docstring] [EOL] if node and node . node_id != self . node_id : [EOL] return [EOL] if args is not None and [string] in args and args [ [string] ] != self . node_id : [EOL] return [EOL] [EOL] [comment] [EOL] if ( value is not None and value . command_class == COMMAND_CLASS_CENTRAL_SCENE ) : [EOL] self . central_scene_activated ( value . index , value . data ) [EOL] [EOL] self . node_changed ( ) [EOL] [EOL] def get_node_statistics ( self ) : [EOL] [docstring] [EOL] return self . _network . manager . getNodeStatistics ( self . _network . home_id , self . node_id ) [EOL] [EOL] def node_changed ( self ) : [EOL] [docstring] [EOL] attributes = { } [EOL] stats = self . get_node_statistics ( ) [EOL] for attr in ATTRIBUTES : [EOL] value = getattr ( self . node , attr ) [EOL] if attr in _REQUIRED_ATTRIBUTES or value : [EOL] attributes [ attr ] = value [EOL] [EOL] for attr in _COMM_ATTRIBUTES : [EOL] attributes [ attr ] = stats [ attr ] [EOL] [EOL] if self . node . can_wake_up ( ) : [EOL] for value in self . node . get_values ( COMMAND_CLASS_WAKE_UP ) . values ( ) : [EOL] if value . index != [number] : [EOL] continue [EOL] [EOL] self . wakeup_interval = value . data [EOL] break [EOL] else : [EOL] self . wakeup_interval = None [EOL] [EOL] self . battery_level = self . node . get_battery_level ( ) [EOL] self . _product_name = self . node . product_name [EOL] self . _manufacturer_name = self . node . manufacturer_name [EOL] self . _name = node_name ( self . node ) [EOL] self . _attributes = attributes [EOL] [EOL] if not self . _unique_id : [EOL] self . _unique_id = self . _compute_unique_id ( ) [EOL] if self . _unique_id : [EOL] [comment] [EOL] self . try_remove_and_add ( ) [EOL] [EOL] self . maybe_schedule_update ( ) [EOL] [EOL] def network_node_event ( self , node , value ) : [EOL] [docstring] [EOL] if node . node_id == self . node . node_id : [EOL] self . node_event ( value ) [EOL] [EOL] def node_event ( self , value ) : [EOL] [docstring] [EOL] if self . hass is None : [EOL] return [EOL] [EOL] self . hass . bus . fire ( EVENT_NODE_EVENT , { ATTR_ENTITY_ID : self . entity_id , ATTR_NODE_ID : self . node . node_id , ATTR_BASIC_LEVEL : value } ) [EOL] [EOL] def network_scene_activated ( self , node , scene_id ) : [EOL] [docstring] [EOL] if node . node_id == self . node . node_id : [EOL] self . scene_activated ( scene_id ) [EOL] [EOL] def scene_activated ( self , scene_id ) : [EOL] [docstring] [EOL] if self . hass is None : [EOL] return [EOL] [EOL] self . hass . bus . fire ( EVENT_SCENE_ACTIVATED , { ATTR_ENTITY_ID : self . entity_id , ATTR_NODE_ID : self . node . node_id , ATTR_SCENE_ID : scene_id } ) [EOL] [EOL] def central_scene_activated ( self , scene_id , scene_data ) : [EOL] [docstring] [EOL] if self . hass is None : [EOL] return [EOL] [EOL] self . hass . bus . fire ( EVENT_SCENE_ACTIVATED , { ATTR_ENTITY_ID : self . entity_id , ATTR_NODE_ID : self . node_id , ATTR_SCENE_ID : scene_id , ATTR_SCENE_DATA : scene_data } ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if ATTR_READY not in self . _attributes : [EOL] return None [EOL] [EOL] if self . _attributes [ ATTR_FAILED ] : [EOL] return [string] [EOL] if self . _attributes [ ATTR_QUERY_STAGE ] != [string] : [EOL] return [string] [EOL] if not self . _attributes [ ATTR_AWAKE ] : [EOL] return [string] [EOL] if self . _attributes [ ATTR_READY ] : [EOL] return [string] [EOL] [EOL] return None [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attrs = { ATTR_NODE_ID : self . node_id , ATTR_NODE_NAME : self . _name , ATTR_MANUFACTURER_NAME : self . _manufacturer_name , ATTR_PRODUCT_NAME : self . _product_name , } [EOL] attrs . update ( self . _attributes ) [EOL] if self . battery_level is not None : [EOL] attrs [ ATTR_BATTERY_LEVEL ] = self . battery_level [EOL] if self . wakeup_interval is not None : [EOL] attrs [ ATTR_WAKEUP ] = self . wakeup_interval [EOL] [EOL] return attrs [EOL] [EOL] def _compute_unique_id ( self ) : [EOL] if is_node_parsed ( self . node ) or self . node . is_ready : [EOL] return [string] . format ( self . node_id ) [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import errno [EOL] import logging [EOL] import os [EOL] [EOL] from homeassistant . components . camera import Camera [EOL] from homeassistant . const import EVENT_HOMEASSISTANT_STOP [EOL] from homeassistant . components . verisure import HUB as hub [EOL] from homeassistant . components . verisure import CONF_SMARTCAM [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if not int ( hub . config . get ( CONF_SMARTCAM , [number] ) ) : [EOL] return False [EOL] directory_path = hass . config . config_dir [EOL] if not os . access ( directory_path , os . R_OK ) : [EOL] _LOGGER . error ( [string] , directory_path ) [EOL] return False [EOL] hub . update_overview ( ) [EOL] smartcams = [ ] [EOL] smartcams . extend ( [ VerisureSmartcam ( hass , device_label , directory_path ) for device_label in hub . get ( [string] ) ] ) [EOL] add_devices ( smartcams ) [EOL] [EOL] [EOL] class VerisureSmartcam ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , device_label , directory_path ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _device_label = device_label [EOL] self . _directory_path = directory_path [EOL] self . _image = None [EOL] self . _image_id = None [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , self . delete_image ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] self . check_imagelist ( ) [EOL] if not self . _image : [EOL] _LOGGER . debug ( [string] ) [EOL] return [EOL] _LOGGER . debug ( [string] , self . _image ) [EOL] with open ( self . _image , [string] ) as file : [EOL] return file . read ( ) [EOL] [EOL] def check_imagelist ( self ) : [EOL] [docstring] [EOL] hub . update_smartcam_imageseries ( ) [EOL] image_ids = hub . get_image_info ( [string] , self . _device_label ) [EOL] if not image_ids : [EOL] return [EOL] new_image_id = image_ids [ [number] ] [EOL] if ( new_image_id == [string] or self . _image_id == new_image_id ) : [EOL] _LOGGER . debug ( [string] ) [EOL] return [EOL] _LOGGER . debug ( [string] , new_image_id ) [EOL] new_image_path = os . path . join ( self . _directory_path , [string] . format ( new_image_id , [string] ) ) [EOL] hub . session . download_image ( self . _device_label , new_image_id , new_image_path ) [EOL] _LOGGER . debug ( [string] , self . _image_id ) [EOL] self . delete_image ( self ) [EOL] [EOL] self . _image_id = new_image_id [EOL] self . _image = new_image_path [EOL] [EOL] def delete_image ( self , event ) : [EOL] [docstring] [EOL] remove_image = os . path . join ( self . _directory_path , [string] . format ( self . _image_id , [string] ) ) [EOL] try : [EOL] os . remove ( remove_image ) [EOL] _LOGGER . debug ( [string] , remove_image ) [EOL] except OSError as error : [EOL] if error . errno != errno . ENOENT : [EOL] raise [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return hub . get_first ( [string] , self . _device_label ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $logging.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , IO , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import subprocess [EOL] import logging [EOL] import shutil [EOL] from tempfile import NamedTemporaryFile [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . camera import ( Camera , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_NAME , CONF_FILE_PATH , EVENT_HOMEASSISTANT_STOP ) [EOL] from homeassistant . helpers import config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_HORIZONTAL_FLIP = [string] [EOL] CONF_IMAGE_HEIGHT = [string] [EOL] CONF_IMAGE_QUALITY = [string] [EOL] CONF_IMAGE_ROTATION = [string] [EOL] CONF_IMAGE_WIDTH = [string] [EOL] CONF_TIMELAPSE = [string] [EOL] CONF_VERTICAL_FLIP = [string] [EOL] [EOL] DEFAULT_HORIZONTAL_FLIP = [number] [EOL] DEFAULT_IMAGE_HEIGHT = [number] [EOL] DEFAULT_IMAGE_QUALITY = [number] [EOL] DEFAULT_IMAGE_ROTATION = [number] [EOL] DEFAULT_IMAGE_WIDTH = [number] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_TIMELAPSE = [number] [EOL] DEFAULT_VERTICAL_FLIP = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_FILE_PATH ) : cv . isfile , vol . Optional ( CONF_HORIZONTAL_FLIP , default = DEFAULT_HORIZONTAL_FLIP ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_IMAGE_HEIGHT , default = DEFAULT_IMAGE_HEIGHT ) : vol . Coerce ( int ) , vol . Optional ( CONF_IMAGE_QUALITY , default = DEFAULT_IMAGE_QUALITY ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_IMAGE_ROTATION , default = DEFAULT_IMAGE_ROTATION ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , vol . Optional ( CONF_IMAGE_WIDTH , default = DEFAULT_IMAGE_WIDTH ) : vol . Coerce ( int ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_TIMELAPSE , default = [number] ) : vol . Coerce ( int ) , vol . Optional ( CONF_VERTICAL_FLIP , default = DEFAULT_VERTICAL_FLIP ) : vol . All ( vol . Coerce ( int ) , vol . Range ( min = [number] , max = [number] ) ) , } ) [EOL] [EOL] [EOL] def kill_raspistill ( * args ) : [EOL] [docstring] [EOL] subprocess . Popen ( [ [string] , [string] ] , stdout = subprocess . DEVNULL , stderr = subprocess . STDOUT ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if shutil . which ( [string] ) is None : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] setup_config = ( { CONF_NAME : config . get ( CONF_NAME ) , CONF_IMAGE_WIDTH : config . get ( CONF_IMAGE_WIDTH ) , CONF_IMAGE_HEIGHT : config . get ( CONF_IMAGE_HEIGHT ) , CONF_IMAGE_QUALITY : config . get ( CONF_IMAGE_QUALITY ) , CONF_IMAGE_ROTATION : config . get ( CONF_IMAGE_ROTATION ) , CONF_TIMELAPSE : config . get ( CONF_TIMELAPSE ) , CONF_HORIZONTAL_FLIP : config . get ( CONF_HORIZONTAL_FLIP ) , CONF_VERTICAL_FLIP : config . get ( CONF_VERTICAL_FLIP ) , CONF_FILE_PATH : config . get ( CONF_FILE_PATH ) } ) [EOL] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , kill_raspistill ) [EOL] [EOL] file_path = setup_config [ CONF_FILE_PATH ] [EOL] [EOL] def delete_temp_file ( * args ) : [EOL] [docstring] [EOL] os . remove ( file_path ) [EOL] [EOL] [comment] [EOL] if file_path is None : [EOL] temp_file = NamedTemporaryFile ( suffix = [string] , delete = False ) [EOL] temp_file . close ( ) [EOL] file_path = temp_file . name [EOL] setup_config [ CONF_FILE_PATH ] = file_path [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_STOP , delete_temp_file ) [EOL] [EOL] [comment] [EOL] elif not hass . config . is_allowed_path ( file_path ) : [EOL] _LOGGER . error ( [string] , file_path ) [EOL] return False [EOL] [EOL] add_devices ( [ RaspberryCamera ( setup_config ) ] ) [EOL] [EOL] [EOL] class RaspberryCamera ( Camera ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_info ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _name = device_info [ CONF_NAME ] [EOL] self . _config = device_info [EOL] [EOL] [comment] [EOL] kill_raspistill ( ) [EOL] [EOL] cmd_args = [ [string] , [string] , [string] , device_info [ CONF_FILE_PATH ] , [string] , [string] , [string] , str ( device_info [ CONF_IMAGE_WIDTH ] ) , [string] , str ( device_info [ CONF_IMAGE_HEIGHT ] ) , [string] , str ( device_info [ CONF_TIMELAPSE ] ) , [string] , str ( device_info [ CONF_IMAGE_QUALITY ] ) , [string] , str ( device_info [ CONF_IMAGE_ROTATION ] ) ] [EOL] if device_info [ CONF_HORIZONTAL_FLIP ] : [EOL] cmd_args . append ( [string] ) [EOL] [EOL] if device_info [ CONF_VERTICAL_FLIP ] : [EOL] cmd_args . append ( [string] ) [EOL] [EOL] subprocess . Popen ( cmd_args , stdout = subprocess . DEVNULL , stderr = subprocess . STDOUT ) [EOL] [EOL] def camera_image ( self ) : [EOL] [docstring] [EOL] with open ( self . _config [ CONF_FILE_PATH ] , [string] ) as file : [EOL] return file . read ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import logging [EOL] import time [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , PLATFORM_SCHEMA , SUPPORT_VOLUME_STEP , SUPPORT_SELECT_SOURCE , SUPPORT_PLAY , MEDIA_TYPE_MUSIC , SUPPORT_VOLUME_SET , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_ACCESS_TOKEN , STATE_OFF , STATE_PLAYING , STATE_PAUSED , STATE_UNKNOWN ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SUPPORT_CLEMENTINE = SUPPORT_PAUSE | SUPPORT_VOLUME_STEP | SUPPORT_PREVIOUS_TRACK | SUPPORT_VOLUME_SET | SUPPORT_NEXT_TRACK | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_ACCESS_TOKEN ) : cv . positive_int , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from clementineremote import ClementineRemote [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] token = config . get ( CONF_ACCESS_TOKEN ) [EOL] [EOL] client = ClementineRemote ( host , port , token , reconnect = True ) [EOL] [EOL] add_devices ( [ ClementineDevice ( client , config [ CONF_NAME ] ) ] ) [EOL] [EOL] [EOL] class ClementineDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , name ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _name = name [EOL] self . _muted = False [EOL] self . _volume = [number] [EOL] self . _track_id = [number] [EOL] self . _last_track_id = [number] [EOL] self . _track_name = [string] [EOL] self . _track_artist = [string] [EOL] self . _track_album_name = [string] [EOL] self . _state = STATE_UNKNOWN [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] client = self . _client [EOL] [EOL] if client . state == [string] : [EOL] self . _state = STATE_PLAYING [EOL] elif client . state == [string] : [EOL] self . _state = STATE_PAUSED [EOL] elif client . state == [string] : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = STATE_PAUSED [EOL] [EOL] if client . last_update and ( time . time ( ) - client . last_update > [number] ) : [EOL] self . _state = STATE_OFF [EOL] [EOL] self . _volume = float ( client . volume ) if client . volume else [number] [EOL] [EOL] if client . current_track : [EOL] self . _track_id = client . current_track [ [string] ] [EOL] self . _track_name = client . current_track [ [string] ] [EOL] self . _track_artist = client . current_track [ [string] ] [EOL] self . _track_album_name = client . current_track [ [string] ] [EOL] [EOL] except Exception : [EOL] self . _state = STATE_OFF [EOL] raise [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume / [number] [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] source_name = [string] [EOL] client = self . _client [EOL] if client . active_playlist_id in client . playlists : [EOL] source_name = client . playlists [ client . active_playlist_id ] [ [string] ] [EOL] return source_name [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] source_names = [ s [ [string] ] for s in self . _client . playlists . values ( ) ] [EOL] return source_names [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] client = self . _client [EOL] sources = [ s for s in client . playlists . values ( ) if s [ [string] ] == source ] [EOL] if len ( sources ) == [number] : [EOL] client . change_song ( sources [ [number] ] [ [string] ] , [number] ) [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _track_name [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _track_artist [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _track_album_name [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_CLEMENTINE [EOL] [EOL] @ property def media_image_hash ( self ) : [EOL] [docstring] [EOL] if self . _client . current_track : [EOL] return self . _client . current_track [ [string] ] [EOL] [EOL] return None [EOL] [EOL] @ asyncio . coroutine def async_get_media_image ( self ) : [EOL] [docstring] [EOL] if self . _client . current_track : [EOL] image = bytes ( self . _client . current_track [ [string] ] ) [EOL] return ( image , [string] ) [EOL] [EOL] return None , None [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] newvolume = min ( self . _client . volume + [number] , [number] ) [EOL] self . _client . set_volume ( newvolume ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] newvolume = max ( self . _client . volume - [number] , [number] ) [EOL] self . _client . set_volume ( newvolume ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _client . set_volume ( [number] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _client . set_volume ( int ( [number] * volume ) ) [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] if self . _state == STATE_PLAYING : [EOL] self . media_pause ( ) [EOL] else : [EOL] self . media_play ( ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PLAYING [EOL] self . _client . play ( ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PAUSED [EOL] self . _client . pause ( ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _client . next ( ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _client . previous ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bytes$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Generator , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_PLAY , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_VOLUME_STEP , SUPPORT_VOLUME_MUTE , SUPPORT_SELECT_SOURCE , MEDIA_TYPE_CHANNEL , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , STATE_ON , STATE_OFF , STATE_PLAYING , STATE_PAUSED , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] SUPPORT_LIVEBOXPLAYTV = SUPPORT_TURN_OFF | SUPPORT_TURN_ON | SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PREVIOUS_TRACK | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_MUTE | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] livebox_devices = [ ] [EOL] [EOL] try : [EOL] device = LiveboxPlayTvDevice ( host , port , name ) [EOL] livebox_devices . append ( device ) [EOL] except IOError : [EOL] _LOGGER . error ( [string] [string] , host , port ) [EOL] async_add_devices ( livebox_devices , True ) [EOL] [EOL] [EOL] class LiveboxPlayTvDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , name ) : [EOL] [docstring] [EOL] from liveboxplaytv import LiveboxPlayTv [EOL] self . _client = LiveboxPlayTv ( host , port ) [EOL] [comment] [EOL] self . _muted = False [EOL] self . _name = name [EOL] self . _current_source = None [EOL] self . _state = None [EOL] self . _channel_list = { } [EOL] self . _current_channel = None [EOL] self . _current_program = None [EOL] self . _media_duration = None [EOL] self . _media_remaining_time = None [EOL] self . _media_image_url = None [EOL] self . _media_last_updated = None [EOL] [EOL] @ asyncio . coroutine def async_update ( self ) : [EOL] [docstring] [EOL] import pyteleloisirs [EOL] try : [EOL] self . _state = self . refresh_state ( ) [EOL] [comment] [EOL] self . refresh_channel_list ( ) [EOL] [comment] [EOL] channel = self . _client . channel [EOL] if channel is not None : [EOL] self . _current_channel = channel [EOL] program = yield from \ [EOL] self . _client . async_get_current_program ( ) [EOL] if program and self . _current_program != program . get ( [string] ) : [EOL] self . _current_program = program . get ( [string] ) [EOL] [comment] [EOL] self . _media_duration = pyteleloisirs . get_program_duration ( program ) [EOL] rtime = pyteleloisirs . get_remaining_time ( program ) [EOL] if rtime != self . _media_remaining_time : [EOL] self . _media_remaining_time = rtime [EOL] self . _media_last_updated = dt_util . utcnow ( ) [EOL] [comment] [EOL] [comment] [EOL] img_size = [number] [EOL] prg_img_url = yield from \ [EOL] self . _client . async_get_current_program_image ( img_size ) [EOL] if prg_img_url : [EOL] self . _media_image_url = prg_img_url [EOL] else : [EOL] chan_img_url = self . _client . get_current_channel_image ( img_size ) [EOL] self . _media_image_url = chan_img_url [EOL] except requests . ConnectionError : [EOL] self . _state = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _current_channel [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return [ self . _channel_list [ c ] for c in sorted ( self . _channel_list . keys ( ) ) ] [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return MEDIA_TYPE_CHANNEL [EOL] [EOL] @ property def media_image_url ( self ) : [EOL] [docstring] [EOL] return self . _media_image_url [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] if self . _current_channel : [EOL] if self . _current_program : [EOL] return [string] . format ( self . _current_channel , self . _current_program ) [EOL] return self . _current_channel [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] return self . _media_duration [EOL] [EOL] @ property def media_position ( self ) : [EOL] [docstring] [EOL] return self . _media_remaining_time [EOL] [EOL] @ property def media_position_updated_at ( self ) : [EOL] [docstring] [EOL] return self . _media_last_updated [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_LIVEBOXPLAYTV [EOL] [EOL] def refresh_channel_list ( self ) : [EOL] [docstring] [EOL] new_channel_list = { } [EOL] [comment] [EOL] for channel in self . _client . get_channels ( ) : [EOL] new_channel_list [ int ( channel [ [string] ] ) ] = channel [ [string] ] [EOL] self . _channel_list = new_channel_list [EOL] [EOL] def refresh_state ( self ) : [EOL] [docstring] [EOL] state = self . _client . media_state [EOL] if state == [string] : [EOL] return STATE_PLAYING [EOL] elif state == [string] : [EOL] return STATE_PAUSED [EOL] [EOL] return STATE_ON if self . _client . is_on else STATE_OFF [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_OFF [EOL] self . _client . turn_off ( ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_ON [EOL] self . _client . turn_on ( ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . _client . volume_up ( ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . _client . volume_down ( ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _muted = mute [EOL] self . _client . mute ( ) [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _client . play_pause ( ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . _current_source = source [EOL] self . _client . set_channel ( source ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PLAYING [EOL] self . _client . play ( ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _state = STATE_PAUSED [EOL] self . _client . pause ( ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _client . channel_up ( ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _client . channel_down ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] import os [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MEDIA_TYPE_MUSIC , MEDIA_TYPE_PLAYLIST , PLATFORM_SCHEMA , SUPPORT_CLEAR_PLAYLIST , SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PLAY , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK , SUPPORT_SEEK , SUPPORT_SELECT_SOURCE , SUPPORT_SHUFFLE_SET , SUPPORT_STOP , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_VOLUME_STEP , MediaPlayerDevice ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PASSWORD , CONF_PORT , STATE_OFF , STATE_PAUSED , STATE_PLAYING ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] PLAYLIST_UPDATE_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_MPD = SUPPORT_PAUSE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_STEP | SUPPORT_PREVIOUS_TRACK | SUPPORT_NEXT_TRACK | SUPPORT_VOLUME_MUTE | SUPPORT_PLAY_MEDIA | SUPPORT_PLAY | SUPPORT_SELECT_SOURCE | SUPPORT_CLEAR_PLAYLIST | SUPPORT_SHUFFLE_SET | SUPPORT_SEEK | SUPPORT_STOP | SUPPORT_TURN_OFF | SUPPORT_TURN_ON [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] name = config . get ( CONF_NAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] [EOL] device = MpdDevice ( host , port , password , name ) [EOL] add_devices ( [ device ] , True ) [EOL] [EOL] [EOL] class MpdDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def __init__ ( self , server , port , password , name ) : [EOL] [docstring] [EOL] import mpd [EOL] [EOL] self . server = server [EOL] self . port = port [EOL] self . _name = name [EOL] self . password = password [EOL] [EOL] self . _status = None [EOL] self . _currentsong = None [EOL] self . _playlists = [ ] [EOL] self . _currentplaylist = None [EOL] self . _is_connected = False [EOL] self . _muted = False [EOL] self . _muted_volume = [number] [EOL] [EOL] [comment] [EOL] self . _client = mpd . MPDClient ( ) [EOL] self . _client . timeout = [number] [EOL] self . _client . idletimeout = None [EOL] [EOL] def _connect ( self ) : [EOL] [docstring] [EOL] import mpd [EOL] try : [EOL] self . _client . connect ( self . server , self . port ) [EOL] [EOL] if self . password is not None : [EOL] self . _client . password ( self . password ) [EOL] except mpd . ConnectionError : [EOL] return [EOL] [EOL] self . _is_connected = True [EOL] [EOL] def _disconnect ( self ) : [EOL] [docstring] [EOL] import mpd [EOL] try : [EOL] self . _client . disconnect ( ) [EOL] except mpd . ConnectionError : [EOL] pass [EOL] self . _is_connected = False [EOL] self . _status = None [EOL] [EOL] def _fetch_status ( self ) : [EOL] [docstring] [EOL] self . _status = self . _client . status ( ) [EOL] self . _currentsong = self . _client . currentsong ( ) [EOL] [EOL] self . _update_playlists ( ) [EOL] [EOL] @ property def available ( self ) : [EOL] [docstring] [EOL] return self . _is_connected [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] import mpd [EOL] [EOL] try : [EOL] if not self . _is_connected : [EOL] self . _connect ( ) [EOL] [EOL] self . _fetch_status ( ) [EOL] except ( mpd . ConnectionError , OSError , BrokenPipeError , ValueError ) : [EOL] [comment] [EOL] self . _disconnect ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _status is None : [EOL] return STATE_OFF [EOL] elif self . _status [ [string] ] == [string] : [EOL] return STATE_PLAYING [EOL] elif self . _status [ [string] ] == [string] : [EOL] return STATE_PAUSED [EOL] elif self . _status [ [string] ] == [string] : [EOL] return STATE_OFF [EOL] [EOL] return STATE_OFF [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def media_content_id ( self ) : [EOL] [docstring] [EOL] return self . _currentsong . get ( [string] ) [EOL] [EOL] @ property def media_content_type ( self ) : [EOL] [docstring] [EOL] return MEDIA_TYPE_MUSIC [EOL] [EOL] @ property def media_duration ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] return self . _currentsong . get ( [string] ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] name = self . _currentsong . get ( [string] , None ) [EOL] title = self . _currentsong . get ( [string] , None ) [EOL] file_name = self . _currentsong . get ( [string] , None ) [EOL] [EOL] if name is None and title is None : [EOL] if file_name is None : [EOL] return [string] [EOL] return os . path . basename ( file_name ) [EOL] elif name is None : [EOL] return title [EOL] elif title is None : [EOL] return name [EOL] [EOL] return [string] . format ( name , title ) [EOL] [EOL] @ property def media_artist ( self ) : [EOL] [docstring] [EOL] return self . _currentsong . get ( [string] ) [EOL] [EOL] @ property def media_album_name ( self ) : [EOL] [docstring] [EOL] return self . _currentsong . get ( [string] ) [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return int ( self . _status [ [string] ] ) / [number] [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_MPD [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _currentplaylist [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _playlists [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . play_media ( MEDIA_TYPE_PLAYLIST , source ) [EOL] [EOL] @ Throttle ( PLAYLIST_UPDATE_INTERVAL ) def _update_playlists ( self , ** kwargs ) : [EOL] [docstring] [EOL] self . _playlists = [ ] [EOL] for playlist_data in self . _client . listplaylists ( ) : [EOL] self . _playlists . append ( playlist_data [ [string] ] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _client . setvol ( int ( volume * [number] ) ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] current_volume = int ( self . _status [ [string] ] ) [EOL] [EOL] if current_volume <= [number] : [EOL] self . _client . setvol ( current_volume + [number] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] current_volume = int ( self . _status [ [string] ] ) [EOL] [EOL] if current_volume >= [number] : [EOL] self . _client . setvol ( current_volume - [number] ) [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _client . pause ( [number] ) [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _client . pause ( [number] ) [EOL] [EOL] def media_stop ( self ) : [EOL] [docstring] [EOL] self . _client . stop ( ) [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _client . next ( ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _client . previous ( ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] if mute is True : [EOL] self . _muted_volume = self . volume_level [EOL] self . set_volume_level ( [number] ) [EOL] elif mute is False : [EOL] self . set_volume_level ( self . _muted_volume ) [EOL] self . _muted = mute [EOL] [EOL] def play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] _LOGGER . debug ( str . format ( [string] , media_id ) ) [EOL] if media_type == MEDIA_TYPE_PLAYLIST : [EOL] if media_id in self . _playlists : [EOL] self . _currentplaylist = media_id [EOL] else : [EOL] self . _currentplaylist = None [EOL] _LOGGER . warning ( str . format ( [string] , media_id ) ) [EOL] self . _client . clear ( ) [EOL] self . _client . load ( media_id ) [EOL] self . _client . play ( ) [EOL] else : [EOL] self . _client . clear ( ) [EOL] self . _client . add ( media_id ) [EOL] self . _client . play ( ) [EOL] [EOL] @ property def shuffle ( self ) : [EOL] [docstring] [EOL] return bool ( self . _status [ [string] ] ) [EOL] [EOL] def set_shuffle ( self , shuffle ) : [EOL] [docstring] [EOL] self . _client . random ( int ( shuffle ) ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _client . stop ( ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _client . play ( ) [EOL] self . _update_playlists ( no_throttle = True ) [EOL] [EOL] def clear_playlist ( self ) : [EOL] [docstring] [EOL] self . _client . clear ( ) [EOL] [EOL] def media_seek ( self , position ) : [EOL] [docstring] [EOL] self . _client . seekcur ( position ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PORT , STATE_OFF , STATE_ON , CONF_NAME ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ZONES = [string] [EOL] CONF_SOURCES = [string] [EOL] [EOL] SUPPORT_RUSSOUND = SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_SET | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE [EOL] [EOL] ZONE_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] SOURCE_SCHEMA = vol . Schema ( { vol . Required ( CONF_NAME ) : cv . string , } ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_NAME ) : cv . string , vol . Required ( CONF_PORT ) : cv . port , vol . Required ( CONF_ZONES ) : vol . Schema ( { cv . positive_int : ZONE_SCHEMA } ) , vol . Required ( CONF_SOURCES ) : vol . All ( cv . ensure_list , [ SOURCE_SCHEMA ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] [EOL] if host is None or port is None : [EOL] _LOGGER . error ( [string] , CONF_HOST , CONF_PORT ) [EOL] return False [EOL] [EOL] from russound import russound [EOL] [EOL] russ = russound . Russound ( host , port ) [EOL] russ . connect ( ) [EOL] [EOL] sources = [ ] [EOL] for source in config [ CONF_SOURCES ] : [EOL] sources . append ( source [ [string] ] ) [EOL] [EOL] if russ . is_connected ( ) : [EOL] for zone_id , extra in config [ CONF_ZONES ] . items ( ) : [EOL] add_devices ( [ RussoundRNETDevice ( hass , russ , sources , zone_id , extra ) ] , True ) [EOL] else : [EOL] _LOGGER . error ( [string] , host , port ) [EOL] [EOL] [EOL] class RussoundRNETDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , russ , sources , zone_id , extra ) : [EOL] [docstring] [EOL] self . _name = extra [ [string] ] [EOL] self . _russ = russ [EOL] self . _sources = sources [EOL] self . _zone_id = zone_id [EOL] [EOL] self . _state = None [EOL] self . _volume = None [EOL] self . _source = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] ret = self . _russ . get_zone_info ( [string] , self . _zone_id , [number] ) [EOL] _LOGGER . debug ( [string] , ret ) [EOL] if ret is not None : [EOL] _LOGGER . debug ( [string] , self . _zone_id ) [EOL] if ret [ [number] ] == [number] : [EOL] self . _state = STATE_OFF [EOL] else : [EOL] self . _state = STATE_ON [EOL] self . _volume = ret [ [number] ] * [number] / [number] [EOL] [comment] [EOL] index = ret [ [number] ] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] self . _source = self . _sources [ index ] [EOL] except IndexError : [EOL] self . _source = None [EOL] else : [EOL] _LOGGER . error ( [string] , self . _zone_id ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_RUSSOUND [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _russ . set_volume ( [string] , self . _zone_id , volume * [number] ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . _russ . set_power ( [string] , self . _zone_id , [string] ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . _russ . set_power ( [string] , self . _zone_id , [string] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _russ . toggle_mute ( [string] , self . _zone_id ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] if source in self . _sources : [EOL] index = self . _sources . index ( source ) [EOL] [comment] [EOL] self . _russ . set_source ( [string] , self . _zone_id , index ) [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _sources [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_NEXT_TRACK , SUPPORT_PAUSE , SUPPORT_PREVIOUS_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_SELECT_SOURCE , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_STEP , SUPPORT_PLAY , SUPPORT_VOLUME_SET , MediaPlayerDevice , PLATFORM_SCHEMA ) [EOL] [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , STATE_OFF , STATE_ON , STATE_UNKNOWN , CONF_PORT , CONF_USERNAME , CONF_PASSWORD , CONF_TIMEOUT ) [EOL] [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] DEFAULT_USERNAME = [string] [EOL] DEFAULT_PASSWORD = [string] [EOL] DEFAULT_TIMEOUT = [number] [EOL] DEFAULT_RETRIES = [number] [EOL] [EOL] SUPPORT_SHARPTV = SUPPORT_TURN_OFF | SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PREVIOUS_TRACK | SUPPORT_SELECT_SOURCE | SUPPORT_VOLUME_MUTE | SUPPORT_VOLUME_STEP | SUPPORT_VOLUME_SET | SUPPORT_PLAY [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_USERNAME , default = DEFAULT_USERNAME ) : cv . string , vol . Optional ( CONF_PASSWORD , default = DEFAULT_PASSWORD ) : cv . string , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . string , vol . Optional ( [string] , default = DEFAULT_RETRIES ) : cv . string , vol . Optional ( [string] , default = False ) : cv . boolean , } ) [EOL] [EOL] SOURCES = { [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] , [number] : [string] } [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] import sharp_aquos_rc [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] port = config . get ( CONF_PORT ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] power_on_enabled = config . get ( [string] ) [EOL] [EOL] if discovery_info : [EOL] _LOGGER . debug ( [string] , discovery_info ) [EOL] vals = discovery_info . split ( [string] ) [EOL] if len ( vals ) > [number] : [EOL] port = vals [ [number] ] [EOL] [EOL] host = vals [ [number] ] [EOL] remote = sharp_aquos_rc . TV ( host , port , username , password , timeout = [number] ) [EOL] add_devices ( [ SharpAquosTVDevice ( name , remote , power_on_enabled ) ] ) [EOL] return True [EOL] [EOL] host = config . get ( CONF_HOST ) [EOL] remote = sharp_aquos_rc . TV ( host , port , username , password , [number] , [number] ) [EOL] [EOL] add_devices ( [ SharpAquosTVDevice ( name , remote , power_on_enabled ) ] ) [EOL] return True [EOL] [EOL] [EOL] def _retry ( func ) : [EOL] [docstring] [EOL] def wrapper ( obj , * args , ** kwargs ) : [EOL] [docstring] [EOL] update_retries = [number] [EOL] while update_retries > [number] : [EOL] try : [EOL] func ( obj , * args , ** kwargs ) [EOL] break [EOL] except ( OSError , TypeError , ValueError ) : [EOL] update_retries -= [number] [EOL] if update_retries == [number] : [EOL] obj . set_state ( STATE_OFF ) [EOL] return wrapper [EOL] [EOL] [EOL] class SharpAquosTVDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , remote , power_on_enabled = False ) : [EOL] [docstring] [EOL] global SUPPORT_SHARPTV [EOL] self . _power_on_enabled = power_on_enabled [EOL] if self . _power_on_enabled : [EOL] SUPPORT_SHARPTV = SUPPORT_SHARPTV | SUPPORT_TURN_ON [EOL] [comment] [EOL] self . _name = name [EOL] [comment] [EOL] self . _muted = False [EOL] self . _state = STATE_UNKNOWN [EOL] self . _remote = remote [EOL] self . _volume = [number] [EOL] self . _source = None [EOL] self . _source_list = list ( SOURCES . values ( ) ) [EOL] [EOL] def set_state ( self , state ) : [EOL] [docstring] [EOL] self . _state = state [EOL] [EOL] @ _retry def update ( self ) : [EOL] [docstring] [EOL] if self . _remote . power ( ) == [number] : [EOL] self . _state = STATE_ON [EOL] else : [EOL] self . _state = STATE_OFF [EOL] [comment] [EOL] if self . _power_on_enabled : [EOL] self . _remote . power_on_command_settings ( [number] ) [EOL] else : [EOL] self . _remote . power_on_command_settings ( [number] ) [EOL] [comment] [EOL] if self . _remote . mute ( ) == [number] : [EOL] self . _muted = False [EOL] else : [EOL] self . _muted = True [EOL] [comment] [EOL] self . _source = SOURCES . get ( self . _remote . input ( ) ) [EOL] [comment] [EOL] self . _volume = self . _remote . volume ( ) / [number] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _source [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return self . _source_list [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_SHARPTV [EOL] [EOL] @ _retry def turn_off ( self ) : [EOL] [docstring] [EOL] self . _remote . power ( [number] ) [EOL] [EOL] @ _retry def volume_up ( self ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( self . _volume * [number] ) + [number] ) [EOL] [EOL] @ _retry def volume_down ( self ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( self . _volume * [number] ) - [number] ) [EOL] [EOL] @ _retry def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] self . _remote . volume ( int ( volume * [number] ) ) [EOL] [EOL] @ _retry def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . _remote . mute ( [number] ) [EOL] [EOL] @ _retry def turn_on ( self ) : [EOL] [docstring] [EOL] self . _remote . power ( [number] ) [EOL] [EOL] @ _retry def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_play ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_pause ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] @ _retry def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _remote . remote_button ( [number] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] for key , value in SOURCES . items ( ) : [EOL] if source == value : [EOL] self . _remote . input ( key ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.float$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import telnetlib [EOL] [docstring] [EOL] import logging [EOL] import telnetlib [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( SUPPORT_PAUSE , SUPPORT_SELECT_SOURCE , MediaPlayerDevice , PLATFORM_SCHEMA , SUPPORT_TURN_OFF , SUPPORT_TURN_ON , SUPPORT_VOLUME_MUTE , SUPPORT_VOLUME_SET , SUPPORT_PLAY ) [EOL] from homeassistant . const import ( CONF_HOST , STATE_OFF , STATE_ON , STATE_UNKNOWN , CONF_NAME , CONF_PORT , CONF_TIMEOUT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [comment] [EOL] DEFAULT_TIMEOUT = None [EOL] [EOL] SUPPORT_PIONEER = SUPPORT_PAUSE | SUPPORT_VOLUME_SET | SUPPORT_VOLUME_MUTE | SUPPORT_TURN_ON | SUPPORT_TURN_OFF | SUPPORT_SELECT_SOURCE | SUPPORT_PLAY [EOL] [EOL] MAX_VOLUME = [number] [EOL] MAX_SOURCE_NUMBERS = [number] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . socket_timeout , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] pioneer = PioneerDevice ( config . get ( CONF_NAME ) , config . get ( CONF_HOST ) , config . get ( CONF_PORT ) , config . get ( CONF_TIMEOUT ) ) [EOL] [EOL] if pioneer . update ( ) : [EOL] add_devices ( [ pioneer ] ) [EOL] [EOL] [EOL] class PioneerDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , host , port , timeout ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _timeout = timeout [EOL] self . _pwstate = [string] [EOL] self . _volume = [number] [EOL] self . _muted = False [EOL] self . _selected_source = [string] [EOL] self . _source_name_to_number = { } [EOL] self . _source_number_to_name = { } [EOL] [EOL] @ classmethod def telnet_request ( cls , telnet , command , expected_prefix ) : [EOL] [docstring] [EOL] try : [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] except telnetlib . socket . timeout : [EOL] _LOGGER . debug ( [string] , command ) [EOL] return None [EOL] [EOL] [comment] [EOL] [comment] [EOL] for _ in range ( [number] ) : [EOL] result = telnet . read_until ( [string] , timeout = [number] ) . decode ( [string] ) . strip ( ) [EOL] if result . startswith ( expected_prefix ) : [EOL] return result [EOL] [EOL] return None [EOL] [EOL] def telnet_command ( self , command ) : [EOL] [docstring] [EOL] try : [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _host , self . _port , self . _timeout ) [EOL] except ( ConnectionRefusedError , OSError ) : [EOL] _LOGGER . warning ( [string] , self . _name ) [EOL] return [EOL] telnet . write ( command . encode ( [string] ) + [string] ) [EOL] telnet . read_very_eager ( ) [comment] [EOL] telnet . close ( ) [EOL] except telnetlib . socket . timeout : [EOL] _LOGGER . debug ( [string] , self . _name , command ) [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] try : [EOL] telnet = telnetlib . Telnet ( self . _host , self . _port , self . _timeout ) [EOL] except ( ConnectionRefusedError , OSError ) : [EOL] _LOGGER . warning ( [string] , self . _name ) [EOL] return False [EOL] [EOL] pwstate = self . telnet_request ( telnet , [string] , [string] ) [EOL] if pwstate : [EOL] self . _pwstate = pwstate [EOL] [EOL] volume_str = self . telnet_request ( telnet , [string] , [string] ) [EOL] self . _volume = int ( volume_str [ [number] : ] ) / MAX_VOLUME if volume_str else None [EOL] [EOL] muted_value = self . telnet_request ( telnet , [string] , [string] ) [EOL] self . _muted = ( muted_value == [string] ) if muted_value else None [EOL] [EOL] [comment] [EOL] if not self . _source_name_to_number : [EOL] for i in range ( MAX_SOURCE_NUMBERS ) : [EOL] result = self . telnet_request ( telnet , [string] + str ( i ) . zfill ( [number] ) , [string] ) [EOL] [EOL] if not result : [EOL] continue [EOL] [EOL] source_name = result [ [number] : ] [EOL] source_number = str ( i ) . zfill ( [number] ) [EOL] [EOL] self . _source_name_to_number [ source_name ] = source_number [EOL] self . _source_number_to_name [ source_number ] = source_name [EOL] [EOL] source_number = self . telnet_request ( telnet , [string] , [string] ) [EOL] [EOL] if source_number : [EOL] self . _selected_source = self . _source_number_to_name . get ( source_number [ [number] : ] ) [EOL] else : [EOL] self . _selected_source = None [EOL] [EOL] telnet . close ( ) [EOL] return True [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _pwstate == [string] : [EOL] return STATE_OFF [EOL] if self . _pwstate == [string] : [EOL] return STATE_ON [EOL] [EOL] return STATE_UNKNOWN [EOL] [EOL] @ property def volume_level ( self ) : [EOL] [docstring] [EOL] return self . _volume [EOL] [EOL] @ property def is_volume_muted ( self ) : [EOL] [docstring] [EOL] return self . _muted [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_PIONEER [EOL] [EOL] @ property def source ( self ) : [EOL] [docstring] [EOL] return self . _selected_source [EOL] [EOL] @ property def source_list ( self ) : [EOL] [docstring] [EOL] return list ( self . _source_name_to_number . keys ( ) ) [EOL] [EOL] @ property def media_title ( self ) : [EOL] [docstring] [EOL] return self . _selected_source [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_up ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def volume_down ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def set_volume_level ( self , volume ) : [EOL] [docstring] [EOL] [comment] [EOL] self . telnet_command ( str ( round ( volume * MAX_VOLUME ) ) . zfill ( [number] ) + [string] ) [EOL] [EOL] def mute_volume ( self , mute ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] if mute else [string] ) [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] self . telnet_command ( [string] ) [EOL] [EOL] def select_source ( self , source ) : [EOL] [docstring] [EOL] self . telnet_command ( self . _source_name_to_number . get ( source ) + [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $None$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $telnetlib.Telnet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . media_player import ( MediaPlayerDevice , PLATFORM_SCHEMA , MEDIA_TYPE_CHANNEL , SUPPORT_NEXT_TRACK , SUPPORT_TURN_ON , SUPPORT_TURN_OFF , SUPPORT_PAUSE , SUPPORT_PLAY , SUPPORT_PLAY_MEDIA , SUPPORT_PREVIOUS_TRACK ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , STATE_OFF , STATE_PAUSED , STATE_PLAYING ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] import homeassistant . helpers . config_validation as cv [EOL] import homeassistant . util as util [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] MIN_TIME_BETWEEN_FORCED_SCANS = timedelta ( seconds = [number] ) [EOL] MIN_TIME_BETWEEN_SCANS = timedelta ( seconds = [number] ) [EOL] [EOL] SUPPORT_HORIZON = SUPPORT_NEXT_TRACK | SUPPORT_PAUSE | SUPPORT_PLAY | SUPPORT_PLAY_MEDIA | SUPPORT_PREVIOUS_TRACK | SUPPORT_TURN_ON | SUPPORT_TURN_OFF [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from einder import Client , keys [EOL] from einder . exceptions import AuthenticationError [EOL] [EOL] host = config [ CONF_HOST ] [EOL] name = config [ CONF_NAME ] [EOL] port = config [ CONF_PORT ] [EOL] [EOL] try : [EOL] client = Client ( host , port = port ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , name , host , msg ) [EOL] raise PlatformNotReady [EOL] [EOL] _LOGGER . info ( [string] , name , host ) [EOL] [EOL] add_devices ( [ HorizonDevice ( client , name , keys ) ] , True ) [EOL] [EOL] [EOL] class HorizonDevice ( MediaPlayerDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , name , keys ) : [EOL] [docstring] [EOL] self . _client = client [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _keys = keys [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def supported_features ( self ) : [EOL] [docstring] [EOL] return SUPPORT_HORIZON [EOL] [EOL] @ util . Throttle ( MIN_TIME_BETWEEN_SCANS , MIN_TIME_BETWEEN_FORCED_SCANS ) def update ( self ) : [EOL] [docstring] [EOL] if self . _client . is_powered_on ( ) : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_OFF [EOL] [EOL] def turn_on ( self ) : [EOL] [docstring] [EOL] if self . _state is STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def turn_off ( self ) : [EOL] [docstring] [EOL] if self . _state is not STATE_OFF : [EOL] self . _send_key ( self . _keys . POWER ) [EOL] [EOL] def media_previous_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_DOWN ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_next_track ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . CHAN_UP ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_play ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PLAYING [EOL] [EOL] def media_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def media_play_pause ( self ) : [EOL] [docstring] [EOL] self . _send_key ( self . _keys . PAUSE ) [EOL] if self . _state == STATE_PAUSED : [EOL] self . _state = STATE_PLAYING [EOL] else : [EOL] self . _state = STATE_PAUSED [EOL] [EOL] def play_media ( self , media_type , media_id , ** kwargs ) : [EOL] [docstring] [EOL] if MEDIA_TYPE_CHANNEL == media_type : [EOL] try : [EOL] self . _select_channel ( int ( media_id ) ) [EOL] self . _state = STATE_PLAYING [EOL] except ValueError : [EOL] _LOGGER . error ( [string] , media_id ) [EOL] else : [EOL] _LOGGER . error ( [string] , media_type , MEDIA_TYPE_CHANNEL ) [EOL] [EOL] def _select_channel ( self , channel ) : [EOL] [docstring] [EOL] self . _send ( channel = channel ) [EOL] [EOL] def _send_key ( self , key ) : [EOL] [docstring] [EOL] self . _send ( key = key ) [EOL] [EOL] def _send ( self , key = None , channel = None ) : [EOL] [docstring] [EOL] from einder . exceptions import AuthenticationError [EOL] [EOL] try : [EOL] if key : [EOL] self . _client . send_key ( key ) [EOL] elif channel : [EOL] self . _client . select_channel ( channel ) [EOL] except OSError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] [EOL] [comment] [EOL] self . _client . disconnect ( ) [EOL] [EOL] try : [EOL] self . _client . connect ( ) [EOL] self . _client . authorize ( ) [EOL] except AuthenticationError as msg : [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] except OSError as msg : [EOL] [comment] [EOL] _LOGGER . error ( [string] , self . _name , msg ) [EOL] return [EOL] [EOL] self . _send ( key = key , channel = channel ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $datetime.timedelta$ 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . insteon_plm import InsteonPLMEntity [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_TYPES = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] plm = hass . data [ [string] ] . get ( [string] ) [EOL] [EOL] address = discovery_info [ [string] ] [EOL] device = plm . devices [ address ] [EOL] state_key = discovery_info [ [string] ] [EOL] name = device . states [ state_key ] . name [EOL] if name != [string] : [EOL] _LOGGER . debug ( [string] , device . address . hex , device . states [ state_key ] . name ) [EOL] [EOL] new_entity = InsteonPLMBinarySensor ( device , state_key ) [EOL] [EOL] async_add_devices ( [ new_entity ] ) [EOL] [EOL] [EOL] class InsteonPLMBinarySensor ( InsteonPLMEntity , BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device , state_key ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( device , state_key ) [EOL] self . _sensor_type = SENSOR_TYPES . get ( self . _insteon_device_state . name ) [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _sensor_type [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return bool ( self . _insteon_device_state . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import logging [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , DEVICE_CLASSES_SCHEMA , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . sensor . command_line import CommandSensorData [EOL] from homeassistant . const import ( CONF_PAYLOAD_OFF , CONF_PAYLOAD_ON , CONF_NAME , CONF_VALUE_TEMPLATE , CONF_COMMAND , CONF_DEVICE_CLASS ) [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PAYLOAD_ON = [string] [EOL] DEFAULT_PAYLOAD_OFF = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_COMMAND ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PAYLOAD_OFF , default = DEFAULT_PAYLOAD_OFF ) : cv . string , vol . Optional ( CONF_PAYLOAD_ON , default = DEFAULT_PAYLOAD_ON ) : cv . string , vol . Optional ( CONF_DEVICE_CLASS ) : DEVICE_CLASSES_SCHEMA , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] command = config . get ( CONF_COMMAND ) [EOL] payload_off = config . get ( CONF_PAYLOAD_OFF ) [EOL] payload_on = config . get ( CONF_PAYLOAD_ON ) [EOL] device_class = config . get ( CONF_DEVICE_CLASS ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] data = CommandSensorData ( hass , command ) [EOL] [EOL] add_devices ( [ CommandBinarySensor ( hass , data , name , device_class , payload_on , payload_off , value_template ) ] , True ) [EOL] [EOL] [EOL] class CommandBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , data , name , device_class , payload_on , payload_off , value_template ) : [EOL] [docstring] [EOL] self . _hass = hass [EOL] self . data = data [EOL] self . _name = name [EOL] self . _device_class = device_class [EOL] self . _state = False [EOL] self . _payload_on = payload_on [EOL] self . _payload_off = payload_off [EOL] self . _value_template = value_template [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _device_class [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] value = self . data . value [EOL] [EOL] if self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , False ) [EOL] if value == self . _payload_on : [EOL] self . _state = True [EOL] elif value == self . _payload_off : [EOL] self . _state = False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import logging [EOL] [EOL] from homeassistant . components . binary_sensor import BinarySensorDevice [EOL] from homeassistant . components . alarmdecoder import ( ZONE_SCHEMA , CONF_ZONES , CONF_ZONE_NAME , CONF_ZONE_TYPE , CONF_ZONE_RFID , SIGNAL_ZONE_FAULT , SIGNAL_ZONE_RESTORE , SIGNAL_RFX_MESSAGE ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_RF_BIT0 = [string] [EOL] ATTR_RF_LOW_BAT = [string] [EOL] ATTR_RF_SUPERVISED = [string] [EOL] ATTR_RF_BIT3 = [string] [EOL] ATTR_RF_LOOP3 = [string] [EOL] ATTR_RF_LOOP2 = [string] [EOL] ATTR_RF_LOOP4 = [string] [EOL] ATTR_RF_LOOP1 = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] configured_zones = discovery_info [ CONF_ZONES ] [EOL] [EOL] devices = [ ] [EOL] for zone_num in configured_zones : [EOL] device_config_data = ZONE_SCHEMA ( configured_zones [ zone_num ] ) [EOL] zone_type = device_config_data [ CONF_ZONE_TYPE ] [EOL] zone_name = device_config_data [ CONF_ZONE_NAME ] [EOL] zone_rfid = device_config_data . get ( CONF_ZONE_RFID ) [EOL] device = AlarmDecoderBinarySensor ( zone_num , zone_name , zone_type , zone_rfid ) [EOL] devices . append ( device ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] return True [EOL] [EOL] [EOL] class AlarmDecoderBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , zone_number , zone_name , zone_type , zone_rfid ) : [EOL] [docstring] [EOL] self . _zone_number = zone_number [EOL] self . _zone_type = zone_type [EOL] self . _state = None [EOL] self . _name = zone_name [EOL] self . _rfid = zone_rfid [EOL] self . _rfstate = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_ZONE_FAULT , self . _fault_callback ) [EOL] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_ZONE_RESTORE , self . _restore_callback ) [EOL] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( SIGNAL_RFX_MESSAGE , self . _rfx_message_callback ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { } [EOL] if self . _rfid and self . _rfstate is not None : [EOL] attr [ ATTR_RF_BIT0 ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_LOW_BAT ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_SUPERVISED ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_BIT3 ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_LOOP3 ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_LOOP2 ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_LOOP4 ] = True if self . _rfstate & [number] else False [EOL] attr [ ATTR_RF_LOOP1 ] = True if self . _rfstate & [number] else False [EOL] return attr [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . _state == [number] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return self . _zone_type [EOL] [EOL] def _fault_callback ( self , zone ) : [EOL] [docstring] [EOL] if zone is None or int ( zone ) == self . _zone_number : [EOL] self . _state = [number] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _restore_callback ( self , zone ) : [EOL] [docstring] [EOL] if zone is None or int ( zone ) == self . _zone_number : [EOL] self . _state = [number] [EOL] self . schedule_update_ha_state ( ) [EOL] [EOL] def _rfx_message_callback ( self , message ) : [EOL] [docstring] [EOL] if self . _rfid and message and message . serial_number == self . _rfid : [EOL] self . _rfstate = message . value [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . binary_sensor import ( BinarySensorDevice , PLATFORM_SCHEMA ) [EOL] from homeassistant . components . digital_ocean import ( CONF_DROPLETS , ATTR_CREATED_AT , ATTR_DROPLET_ID , ATTR_DROPLET_NAME , ATTR_FEATURES , ATTR_IPV4_ADDRESS , ATTR_IPV6_ADDRESS , ATTR_MEMORY , ATTR_REGION , ATTR_VCPUS , CONF_ATTRIBUTION , DATA_DIGITAL_OCEAN ) [EOL] from homeassistant . const import ATTR_ATTRIBUTION [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_DEVICE_CLASS = [string] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_DROPLETS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] digital = hass . data . get ( DATA_DIGITAL_OCEAN ) [EOL] if not digital : [EOL] return False [EOL] [EOL] droplets = config . get ( CONF_DROPLETS ) [EOL] [EOL] dev = [ ] [EOL] for droplet in droplets : [EOL] droplet_id = digital . get_droplet_id ( droplet ) [EOL] if droplet_id is None : [EOL] _LOGGER . error ( [string] , droplet ) [EOL] return False [EOL] dev . append ( DigitalOceanBinarySensor ( digital , droplet_id ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class DigitalOceanBinarySensor ( BinarySensorDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , do , droplet_id ) : [EOL] [docstring] [EOL] self . _digital_ocean = do [EOL] self . _droplet_id = droplet_id [EOL] self . _state = None [EOL] self . data = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . data . name [EOL] [EOL] @ property def is_on ( self ) : [EOL] [docstring] [EOL] return self . data . status == [string] [EOL] [EOL] @ property def device_class ( self ) : [EOL] [docstring] [EOL] return DEFAULT_DEVICE_CLASS [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , ATTR_CREATED_AT : self . data . created_at , ATTR_DROPLET_ID : self . data . id , ATTR_DROPLET_NAME : self . data . name , ATTR_FEATURES : self . data . features , ATTR_IPV4_ADDRESS : self . data . ip_address , ATTR_IPV6_ADDRESS : self . data . ip_v6_address , ATTR_MEMORY : self . data . memory , ATTR_REGION : self . data . region [ [string] ] , ATTR_VCPUS : self . data . vcpus , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . _digital_ocean . update ( ) [EOL] [EOL] for droplet in self . _digital_ocean . data : [EOL] if droplet . id == self . _droplet_id : [EOL] self . data = droplet [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] [EOL] [EOL] class HueException ( HomeAssistantError ) : [EOL] [docstring] [EOL] [EOL] [EOL] class CannotConnect ( HueException ) : [EOL] [docstring] [EOL] [EOL] [EOL] class AuthenticationRequired ( HueException ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import logging [EOL] [docstring] [EOL] import logging [EOL] [EOL] LOGGER = logging . getLogger ( [string] ) [EOL] DOMAIN = [string] [EOL] API_NUPNP = [string] [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL] [EOL] CONF_PASSIVE = [string] [EOL] DOMAIN = [string] [EOL] HOME_ZONE = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import functools [EOL] [docstring] [EOL] import asyncio [EOL] from functools import partial [EOL] import logging [EOL] [EOL] from homeassistant . components . rflink import ( CONF_ALIASES , CONF_ALIASSES , CONF_AUTOMATIC_ADD , CONF_DEVICES , DATA_DEVICE_REGISTER , DATA_ENTITY_LOOKUP , DOMAIN , EVENT_KEY_ID , EVENT_KEY_SENSOR , EVENT_KEY_UNIT , RflinkDevice , cv , remove_deprecated , vol ) [EOL] from homeassistant . const import ( ATTR_UNIT_OF_MEASUREMENT , CONF_NAME , CONF_PLATFORM , CONF_UNIT_OF_MEASUREMENT ) [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] SENSOR_ICONS = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] CONF_SENSOR_TYPE = [string] [EOL] [EOL] PLATFORM_SCHEMA = vol . Schema ( { vol . Required ( CONF_PLATFORM ) : DOMAIN , vol . Optional ( CONF_AUTOMATIC_ADD , default = True ) : cv . boolean , vol . Optional ( CONF_DEVICES , default = { } ) : vol . Schema ( { cv . string : { vol . Optional ( CONF_NAME ) : cv . string , vol . Required ( CONF_SENSOR_TYPE ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_ALIASES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_ALIASSES ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } , } ) , } ) [EOL] [EOL] [EOL] def lookup_unit_for_sensor_type ( sensor_type ) : [EOL] [docstring] [EOL] from rflink . parser import UNITS , PACKET_FIELDS [EOL] field_abbrev = { v : k for k , v in PACKET_FIELDS . items ( ) } [EOL] [EOL] return UNITS . get ( field_abbrev . get ( sensor_type ) ) [EOL] [EOL] [EOL] def devices_from_config ( domain_config , hass = None ) : [EOL] [docstring] [EOL] devices = [ ] [EOL] for device_id , config in domain_config [ CONF_DEVICES ] . items ( ) : [EOL] if ATTR_UNIT_OF_MEASUREMENT not in config : [EOL] config [ ATTR_UNIT_OF_MEASUREMENT ] = lookup_unit_for_sensor_type ( config [ CONF_SENSOR_TYPE ] ) [EOL] remove_deprecated ( config ) [EOL] device = RflinkSensor ( device_id , hass , ** config ) [EOL] devices . append ( device ) [EOL] [EOL] [comment] [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_SENSOR ] [ device_id ] . append ( device ) [EOL] return devices [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] async_add_devices ( devices_from_config ( config , hass ) ) [EOL] [EOL] @ asyncio . coroutine def add_new_device ( event ) : [EOL] [docstring] [EOL] device_id = event [ EVENT_KEY_ID ] [EOL] [EOL] rflinksensor = partial ( RflinkSensor , device_id , hass ) [EOL] device = rflinksensor ( event [ EVENT_KEY_SENSOR ] , event [ EVENT_KEY_UNIT ] ) [EOL] [comment] [EOL] async_add_devices ( [ device ] ) [EOL] [EOL] [comment] [EOL] hass . data [ DATA_ENTITY_LOOKUP ] [ EVENT_KEY_SENSOR ] [ device_id ] . append ( device ) [EOL] [EOL] [comment] [EOL] hass . async_add_job ( device . handle_event , event ) [EOL] [EOL] if config [ CONF_AUTOMATIC_ADD ] : [EOL] hass . data [ DATA_DEVICE_REGISTER ] [ EVENT_KEY_SENSOR ] = add_new_device [EOL] [EOL] [EOL] class RflinkSensor ( RflinkDevice ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , device_id , hass , sensor_type , unit_of_measurement , ** kwargs ) : [EOL] [docstring] [EOL] self . _sensor_type = sensor_type [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] super ( ) . __init__ ( device_id , hass , ** kwargs ) [EOL] [EOL] def _handle_event ( self , event ) : [EOL] [docstring] [EOL] self . _state = event [ [string] ] [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] if self . _sensor_type in SENSOR_ICONS : [EOL] return SENSOR_ICONS [ self . _sensor_type ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import datetime as datetime [EOL] [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . components . toon as toon_main [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] STATE_ATTR_DEVICE_TYPE = [string] [EOL] STATE_ATTR_LAST_CONNECTED_CHANGE = [string] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] _toon_main = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] sensor_items = [ ] [EOL] sensor_items . extend ( [ ToonSensor ( hass , [string] , [string] , [string] ) , ToonSensor ( hass , [string] , [string] , [string] ) , ] ) [EOL] [EOL] if _toon_main . gas : [EOL] sensor_items . extend ( [ ToonSensor ( hass , [string] , [string] , [string] ) , ToonSensor ( hass , [string] , [string] , [string] ) , ] ) [EOL] [EOL] for plug in _toon_main . toon . smartplugs : [EOL] sensor_items . extend ( [ FibaroSensor ( hass , [string] . format ( plug . name ) , plug . name , [string] , [string] ) , FibaroSensor ( hass , [string] . format ( plug . name ) , plug . name , [string] , [string] ) , ] ) [EOL] [EOL] if _toon_main . toon . solar . produced or _toon_main . solar : [EOL] sensor_items . extend ( [ SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , SolarSensor ( hass , [string] , [string] ) , ] ) [EOL] [EOL] for smokedetector in _toon_main . toon . smokedetectors : [EOL] sensor_items . append ( FibaroSmokeDetector ( hass , [string] . format ( smokedetector . name ) , smokedetector . device_uuid , [string] , [string] ) ) [EOL] [EOL] add_devices ( sensor_items ) [EOL] [EOL] [EOL] class ToonSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . thermos = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . thermos . get_data ( self . name . lower ( ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . thermos . update ( ) [EOL] [EOL] [EOL] class FibaroSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , plug_name , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _plug_name = plug_name [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] value = [string] . join ( self . name . lower ( ) . split ( [string] ) [ [number] : ] ) [EOL] return self . toon . get_data ( value , self . _plug_name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL] [EOL] [EOL] class SolarSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _icon = [string] [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . toon . get_data ( self . name . lower ( ) ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL] [EOL] [EOL] class FibaroSmokeDetector ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , hass , name , uid , icon , unit_of_measurement ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _uid = uid [EOL] self . _state = None [EOL] self . _icon = [string] . format ( icon ) [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . toon = hass . data [ toon_main . TOON_HANDLE ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def state_attributes ( self ) : [EOL] [docstring] [EOL] value = datetime . datetime . fromtimestamp ( int ( self . toon . get_data ( [string] , self . name ) ) ) . strftime ( [string] ) [EOL] [EOL] return { STATE_ATTR_DEVICE_TYPE : self . toon . get_data ( [string] , self . name ) , STATE_ATTR_LAST_CONNECTED_CHANGE : value , } [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] value = self . name . lower ( ) . split ( [string] , [number] ) [ [number] ] [EOL] return self . toon . get_data ( value , self . name ) [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . toon . update ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] import xml [EOL] [docstring] [EOL] from xml . etree . ElementTree import Element [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . ihc import ( validate_name , IHC_DATA , IHC_CONTROLLER , IHC_INFO ) [EOL] from homeassistant . components . ihc . ihcdevice import IHCDevice [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_ID , CONF_NAME , CONF_UNIT_OF_MEASUREMENT , CONF_SENSORS , TEMP_CELSIUS ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] DEPENDENCIES = [ [string] ] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_SENSORS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . All ( { vol . Required ( CONF_ID ) : cv . positive_int , vol . Optional ( CONF_NAME ) : cv . string , vol . Optional ( CONF_UNIT_OF_MEASUREMENT , default = TEMP_CELSIUS ) : cv . string } , validate_name ) ] ) } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] ihc_controller = hass . data [ IHC_DATA ] [ IHC_CONTROLLER ] [EOL] info = hass . data [ IHC_DATA ] [ IHC_INFO ] [EOL] devices = [ ] [EOL] if discovery_info : [EOL] for name , device in discovery_info . items ( ) : [EOL] ihc_id = device [ [string] ] [EOL] product_cfg = device [ [string] ] [EOL] product = device [ [string] ] [EOL] sensor = IHCSensor ( ihc_controller , name , ihc_id , info , product_cfg [ CONF_UNIT_OF_MEASUREMENT ] , product ) [EOL] devices . append ( sensor ) [EOL] else : [EOL] sensors = config [ CONF_SENSORS ] [EOL] for sensor_cfg in sensors : [EOL] ihc_id = sensor_cfg [ CONF_ID ] [EOL] name = sensor_cfg [ CONF_NAME ] [EOL] unit = sensor_cfg [ CONF_UNIT_OF_MEASUREMENT ] [EOL] sensor = IHCSensor ( ihc_controller , name , ihc_id , info , unit ) [EOL] devices . append ( sensor ) [EOL] [EOL] add_devices ( devices ) [EOL] [EOL] [EOL] class IHCSensor ( IHCDevice , Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ihc_controller , name , ihc_id , info , unit , product = None ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ihc_controller , name , ihc_id , info , product ) [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def on_ihc_change ( self , ihc_id , value ) : [EOL] [docstring] [EOL] self . _state = value [EOL] self . schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 0 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.bool$ 0 $xml.etree.ElementTree.Element$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import logging [EOL] import homeassistant [EOL] import random [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import math [EOL] from random import Random [EOL] from datetime import datetime [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_NAME [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_AMP = [string] [EOL] CONF_FWHM = [string] [EOL] CONF_MEAN = [string] [EOL] CONF_PERIOD = [string] [EOL] CONF_PHASE = [string] [EOL] CONF_SEED = [string] [EOL] CONF_UNIT = [string] [EOL] CONF_RELATIVE_TO_EPOCH = [string] [EOL] [EOL] DEFAULT_AMP = [number] [EOL] DEFAULT_FWHM = [number] [EOL] DEFAULT_MEAN = [number] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PERIOD = [number] [EOL] DEFAULT_PHASE = [number] [EOL] DEFAULT_SEED = [number] [EOL] DEFAULT_UNIT = [string] [EOL] DEFAULT_RELATIVE_TO_EPOCH = True [EOL] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_AMP , default = DEFAULT_AMP ) : vol . Coerce ( float ) , vol . Optional ( CONF_FWHM , default = DEFAULT_FWHM ) : vol . Coerce ( float ) , vol . Optional ( CONF_MEAN , default = DEFAULT_MEAN ) : vol . Coerce ( float ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PERIOD , default = DEFAULT_PERIOD ) : cv . positive_int , vol . Optional ( CONF_PHASE , default = DEFAULT_PHASE ) : vol . Coerce ( float ) , vol . Optional ( CONF_SEED , default = DEFAULT_SEED ) : cv . positive_int , vol . Optional ( CONF_UNIT , default = DEFAULT_UNIT ) : cv . string , vol . Optional ( CONF_RELATIVE_TO_EPOCH , default = DEFAULT_RELATIVE_TO_EPOCH ) : cv . boolean , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] unit = config . get ( CONF_UNIT ) [EOL] amp = config . get ( CONF_AMP ) [EOL] mean = config . get ( CONF_MEAN ) [EOL] period = config . get ( CONF_PERIOD ) [EOL] phase = config . get ( CONF_PHASE ) [EOL] fwhm = config . get ( CONF_FWHM ) [EOL] seed = config . get ( CONF_SEED ) [EOL] relative_to_epoch = config . get ( CONF_RELATIVE_TO_EPOCH ) [EOL] [EOL] sensor = SimulatedSensor ( name , unit , amp , mean , period , phase , fwhm , seed , relative_to_epoch ) [EOL] add_devices ( [ sensor ] , True ) [EOL] [EOL] [EOL] class SimulatedSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , unit , amp , mean , period , phase , fwhm , seed , relative_to_epoch ) : [EOL] [docstring] [EOL] self . _name = name [EOL] self . _unit = unit [EOL] self . _amp = amp [EOL] self . _mean = mean [EOL] self . _period = period [EOL] self . _phase = phase [comment] [EOL] self . _fwhm = fwhm [EOL] self . _seed = seed [EOL] self . _random = Random ( seed ) [comment] [EOL] self . _start_time = ( datetime ( [number] , [number] , [number] , tzinfo = dt_util . UTC ) if relative_to_epoch [EOL] else dt_util . utcnow ( ) ) [EOL] self . _relative_to_epoch = relative_to_epoch [EOL] self . _state = None [EOL] [EOL] def time_delta ( self ) : [EOL] [docstring] [EOL] dt0 = self . _start_time [EOL] dt1 = dt_util . utcnow ( ) [EOL] return dt1 - dt0 [EOL] [EOL] def signal_calc ( self ) : [EOL] [docstring] [EOL] mean = self . _mean [EOL] amp = self . _amp [EOL] time_delta = self . time_delta ( ) . total_seconds ( ) * [number] [comment] [EOL] period = self . _period * [number] [comment] [EOL] fwhm = self . _fwhm / [number] [EOL] phase = math . radians ( self . _phase ) [EOL] if period == [number] : [EOL] periodic = [number] [EOL] else : [EOL] periodic = amp * ( math . sin ( ( [number] * math . pi * time_delta / period ) + phase ) ) [EOL] noise = self . _random . gauss ( mu = [number] , sigma = fwhm ) [EOL] return round ( mean + periodic + noise , [number] ) [EOL] [EOL] async def async_update ( self ) : [EOL] [docstring] [EOL] self . _state = self . signal_calc ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] attr = { [string] : self . _amp , [string] : self . _mean , [string] : self . _period , [string] : self . _phase , [string] : self . _fwhm , [string] : self . _seed , [string] : self . _relative_to_epoch , } [EOL] return attr [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $random.Random$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $builtins.float$ 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 $builtins.float$ 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,unknown]$ 0
from typing import Optional , Any , Dict , List , Union [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_HOST , CONF_USERNAME , CONF_PASSWORD , CONF_PORT , CONF_SSL , ATTR_ATTRIBUTION , TEMP_CELSIUS , CONF_MONITORED_CONDITIONS , EVENT_HOMEASSISTANT_START , CONF_DISKS ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_VOLUMES = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] _UTILISATION_MON_COND = { [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , [string] , [string] ] , } [EOL] _STORAGE_VOL_MON_COND = { [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , [string] , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , } [EOL] _STORAGE_DSK_MON_COND = { [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , [string] : [ [string] , None , [string] ] , } [EOL] [EOL] _MONITORED_CONDITIONS = list ( _UTILISATION_MON_COND . keys ( ) ) + list ( _STORAGE_VOL_MON_COND . keys ( ) ) + list ( _STORAGE_DSK_MON_COND . keys ( ) ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_SSL , default = True ) : cv . boolean , vol . Required ( CONF_USERNAME ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS ) : vol . All ( cv . ensure_list , [ vol . In ( _MONITORED_CONDITIONS ) ] ) , vol . Optional ( CONF_DISKS ) : cv . ensure_list , vol . Optional ( CONF_VOLUMES ) : cv . ensure_list , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] def run_setup ( event ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] username = config . get ( CONF_USERNAME ) [EOL] password = config . get ( CONF_PASSWORD ) [EOL] use_ssl = config . get ( CONF_SSL ) [EOL] unit = hass . config . units . temperature_unit [EOL] monitored_conditions = config . get ( CONF_MONITORED_CONDITIONS ) [EOL] [EOL] api = SynoApi ( host , port , username , password , unit , use_ssl ) [EOL] [EOL] sensors = [ SynoNasUtilSensor ( api , variable , _UTILISATION_MON_COND [ variable ] ) for variable in monitored_conditions if variable in _UTILISATION_MON_COND ] [EOL] [EOL] [comment] [EOL] for volume in config . get ( CONF_VOLUMES , api . storage . volumes ) : [EOL] sensors += [ SynoNasStorageSensor ( api , variable , _STORAGE_VOL_MON_COND [ variable ] , volume ) for variable in monitored_conditions if variable in _STORAGE_VOL_MON_COND ] [EOL] [EOL] [comment] [EOL] for disk in config . get ( CONF_DISKS , api . storage . disks ) : [EOL] sensors += [ SynoNasStorageSensor ( api , variable , _STORAGE_DSK_MON_COND [ variable ] , disk ) for variable in monitored_conditions if variable in _STORAGE_DSK_MON_COND ] [EOL] [EOL] add_devices ( sensors , True ) [EOL] [EOL] [comment] [EOL] hass . bus . listen_once ( EVENT_HOMEASSISTANT_START , run_setup ) [EOL] [EOL] [EOL] class SynoApi ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , username , password , temp_unit , use_ssl ) : [EOL] [docstring] [EOL] from SynologyDSM import SynologyDSM [EOL] self . temp_unit = temp_unit [EOL] [EOL] try : [EOL] self . _api = SynologyDSM ( host , port , username , password , use_https = use_ssl ) [EOL] except : [comment] [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] [comment] [EOL] self . utilisation = self . _api . utilisation [EOL] self . storage = self . _api . storage [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] self . _api . update ( ) [EOL] [EOL] [EOL] class SynoNasSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , api , variable , variable_info , monitor_device = None ) : [EOL] [docstring] [EOL] self . var_id = variable [EOL] self . var_name = variable_info [ [number] ] [EOL] self . var_units = variable_info [ [number] ] [EOL] self . var_icon = variable_info [ [number] ] [EOL] self . monitor_device = monitor_device [EOL] self . _api = api [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] if self . monitor_device is not None : [EOL] return [string] . format ( self . var_name , self . monitor_device ) [EOL] return self . var_name [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . var_icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] if self . var_id in [ [string] , [string] , [string] ] : [EOL] return self . _api . temp_unit [EOL] return self . var_units [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] if self . _api is not None : [EOL] self . _api . update ( ) [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] [EOL] class SynoNasUtilSensor ( SynoNasSensor ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] network_sensors = [ [string] , [string] ] [EOL] memory_sensors = [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] if self . var_id in network_sensors or self . var_id in memory_sensors : [EOL] attr = getattr ( self . _api . utilisation , self . var_id ) ( False ) [EOL] [EOL] if self . var_id in network_sensors : [EOL] return round ( attr / [number] , [number] ) [EOL] elif self . var_id in memory_sensors : [EOL] return round ( attr / [number] / [number] , [number] ) [EOL] else : [EOL] return getattr ( self . _api . utilisation , self . var_id ) [EOL] [EOL] [EOL] class SynoNasStorageSensor ( SynoNasSensor ) : [EOL] [docstring] [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] temp_sensors = [ [string] , [string] , [string] ] [EOL] [EOL] if self . monitor_device is not None : [EOL] if self . var_id in temp_sensors : [EOL] attr = getattr ( self . _api . storage , self . var_id ) ( self . monitor_device ) [EOL] [EOL] if self . _api . temp_unit == TEMP_CELSIUS : [EOL] return attr [EOL] [EOL] return round ( attr * [number] + [number] , [number] ) [EOL] [EOL] return getattr ( self . _api . storage , self . var_id ) ( self . monitor_device ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Optional[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . components . sensor import ENTITY_ID_FORMAT [EOL] from homeassistant . components . waterfurnace import ( DOMAIN as WF_DOMAIN , UPDATE_TOPIC ) [EOL] from homeassistant . const import TEMP_FAHRENHEIT [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import slugify [EOL] [EOL] [EOL] class WFSensorConfig ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , friendly_name , field , icon = [string] , unit_of_measurement = None ) : [EOL] [docstring] [EOL] self . friendly_name = friendly_name [EOL] self . field = field [EOL] self . icon = icon [EOL] self . unit_of_measurement = unit_of_measurement [EOL] [EOL] [EOL] SENSORS = [ WFSensorConfig ( [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , TEMP_FAHRENHEIT ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , WFSensorConfig ( [string] , [string] , [string] , [string] ) , ] [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] if discovery_info is None : [EOL] return [EOL] [EOL] sensors = [ ] [EOL] client = hass . data [ WF_DOMAIN ] [EOL] for sconfig in SENSORS : [EOL] sensors . append ( WaterFurnaceSensor ( client , sconfig ) ) [EOL] [EOL] add_devices ( sensors ) [EOL] [EOL] [EOL] class WaterFurnaceSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , client , config ) : [EOL] [docstring] [EOL] self . client = client [EOL] self . _name = config . friendly_name [EOL] self . _attr = config . field [EOL] self . _state = None [EOL] self . _icon = config . icon [EOL] self . _unit_of_measurement = config . unit_of_measurement [EOL] [EOL] [comment] [EOL] self . entity_id = ENTITY_ID_FORMAT . format ( [string] . format ( slugify ( self . client . unit ) , slugify ( self . _attr ) ) ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return self . _icon [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . hass . helpers . dispatcher . async_dispatcher_connect ( UPDATE_TOPIC , self . async_update_callback ) [EOL] [EOL] @ callback def async_update_callback ( self ) : [EOL] [docstring] [EOL] if self . client . data is not None : [EOL] self . _state = getattr ( self . client . data , self . _attr , None ) [EOL] self . async_schedule_update_ha_state ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.sensor.waterfurnace.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[homeassistant.components.sensor.waterfurnace.WFSensorConfig]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import time [EOL] import asyncio [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . core import callback [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( CONF_NAME , CONF_TOKEN ) [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] TIME_STEP = [number] [comment] [EOL] [EOL] ICON = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_TOKEN ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] @ asyncio . coroutine def async_setup_platform ( hass , config , async_add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] token = config . get ( CONF_TOKEN ) [EOL] [EOL] async_add_devices ( [ TOTPSensor ( name , token ) ] , True ) [EOL] return True [EOL] [EOL] [EOL] [comment] [EOL] class TOTPSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , token ) : [EOL] [docstring] [EOL] import pyotp [EOL] self . _name = name [EOL] self . _otp = pyotp . TOTP ( token ) [EOL] self . _state = None [EOL] self . _next_expiration = None [EOL] [EOL] @ asyncio . coroutine def async_added_to_hass ( self ) : [EOL] [docstring] [EOL] self . _call_loop ( ) [EOL] [EOL] @ callback def _call_loop ( self ) : [EOL] self . _state = self . _otp . now ( ) [EOL] self . async_schedule_update_ha_state ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . _next_expiration = TIME_STEP - ( time . time ( ) % TIME_STEP ) [EOL] self . hass . loop . call_later ( self . _next_expiration , self . _call_loop ) [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def should_poll ( self ) : [EOL] [docstring] [EOL] return False [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0
from typing import Optional , Any , Dict , List , Union [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] from datetime import timedelta [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( ATTR_ATTRIBUTION , CONF_API_KEY , CONF_MONITORED_CONDITIONS , CONF_NAME , TEMP_CELSIUS , TEMP_FAHRENHEIT ) [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ATTRIBUTION = [string] [EOL] CONF_FORECAST = [string] [EOL] CONF_LANGUAGE = [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( seconds = [number] ) [EOL] [EOL] SENSOR_TYPES = { [string] : [ [string] , None ] , [string] : [ [string] , None ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_API_KEY ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_FORECAST , default = False ) : cv . boolean , vol . Optional ( CONF_LANGUAGE ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pyowm import OWM [EOL] [EOL] if None in ( hass . config . latitude , hass . config . longitude ) : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] SENSOR_TYPES [ [string] ] [ [number] ] = hass . config . units . temperature_unit [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] forecast = config . get ( CONF_FORECAST ) [EOL] language = config . get ( CONF_LANGUAGE ) [EOL] if isinstance ( language , str ) : [EOL] language = language . lower ( ) [ : [number] ] [EOL] [EOL] owm = OWM ( API_key = config . get ( CONF_API_KEY ) , language = language ) [EOL] [EOL] if not owm : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] [EOL] data = WeatherData ( owm , forecast , hass . config . latitude , hass . config . longitude ) [EOL] dev = [ ] [EOL] for variable in config [ CONF_MONITORED_CONDITIONS ] : [EOL] dev . append ( OpenWeatherMapSensor ( name , data , variable , SENSOR_TYPES [ variable ] [ [number] ] ) ) [EOL] [EOL] if forecast : [EOL] SENSOR_TYPES [ [string] ] = [ [string] , None ] [EOL] dev . append ( OpenWeatherMapSensor ( name , data , [string] , SENSOR_TYPES [ [string] ] [ [number] ] ) ) [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class OpenWeatherMapSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , name , weather_data , sensor_type , temp_unit ) : [EOL] [docstring] [EOL] self . client_name = name [EOL] self . _name = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] self . owa_client = weather_data [EOL] self . temp_unit = temp_unit [EOL] self . type = sensor_type [EOL] self . _state = None [EOL] self . _unit_of_measurement = SENSOR_TYPES [ sensor_type ] [ [number] ] [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . client_name , self . _name ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] self . owa_client . update ( ) [EOL] except APICallError : [EOL] _LOGGER . error ( [string] ) [EOL] return [EOL] [EOL] data = self . owa_client . data [EOL] fc_data = self . owa_client . fc_data [EOL] [EOL] if data is None : [EOL] return [EOL] [EOL] if self . type == [string] : [EOL] self . _state = data . get_detailed_status ( ) [EOL] elif self . type == [string] : [EOL] if self . temp_unit == TEMP_CELSIUS : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] elif self . temp_unit == TEMP_FAHRENHEIT : [EOL] self . _state = round ( data . get_temperature ( [string] ) [ [string] ] , [number] ) [EOL] else : [EOL] self . _state = round ( data . get_temperature ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_wind ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_humidity ( ) , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = round ( data . get_pressure ( ) [ [string] ] , [number] ) [EOL] elif self . type == [string] : [EOL] self . _state = data . get_clouds ( ) [EOL] elif self . type == [string] : [EOL] if data . get_rain ( ) : [EOL] self . _state = round ( data . get_rain ( ) [ [string] ] , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if data . get_snow ( ) : [EOL] self . _state = round ( data . get_snow ( ) , [number] ) [EOL] self . _unit_of_measurement = [string] [EOL] else : [EOL] self . _state = [string] [EOL] self . _unit_of_measurement = [string] [EOL] elif self . type == [string] : [EOL] if fc_data is None : [EOL] return [EOL] self . _state = fc_data . get_weathers ( ) [ [number] ] . get_detailed_status ( ) [EOL] [EOL] [EOL] class WeatherData ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , owm , forecast , latitude , longitude ) : [EOL] [docstring] [EOL] self . owm = owm [EOL] self . forecast = forecast [EOL] self . latitude = latitude [EOL] self . longitude = longitude [EOL] self . data = None [EOL] self . fc_data = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from pyowm . exceptions . api_call_error import APICallError [EOL] [EOL] try : [EOL] obs = self . owm . weather_at_coords ( self . latitude , self . longitude ) [EOL] except ( APICallError , TypeError ) : [EOL] _LOGGER . error ( [string] [string] ) [EOL] obs = None [EOL] [EOL] if obs is None : [EOL] _LOGGER . warning ( [string] ) [EOL] return [EOL] [EOL] self . data = obs . get_weather ( ) [EOL] [EOL] if self . forecast == [number] : [EOL] try : [EOL] obs = self . owm . three_hours_forecast_at_coords ( self . latitude , self . longitude ) [EOL] self . fc_data = obs . get_forecast ( ) [EOL] except ( ConnectionResetError , TypeError ) : [EOL] _LOGGER . warning ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.List[builtins.str],typing.List[typing.Optional[builtins.str]]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] from datetime import timedelta [EOL] [EOL] import requests [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import ( LENGTH_KILOMETERS , CONF_MONITORED_CONDITIONS , CONF_NAME , ATTR_ATTRIBUTION ) [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . util import Throttle [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] URL = [string] [EOL] [EOL] CONF_ATTRIBUTION = [string] [string] [EOL] [EOL] DEFAULT_NAME = [string] [EOL] REGEX = [string] [EOL] [EOL] OPTION_TRAFFIC_JAM = [string] [EOL] OPTION_MEAN_VELOCITY = [string] [EOL] OPTION_CONGESTION = [string] [EOL] [EOL] SENSOR_TYPES = { OPTION_TRAFFIC_JAM : [ [string] , LENGTH_KILOMETERS ] , OPTION_MEAN_VELOCITY : [ [string] , LENGTH_KILOMETERS + [string] ] , OPTION_CONGESTION : [ [string] , [string] ] , } [EOL] [EOL] MIN_TIME_BETWEEN_UPDATES = timedelta ( minutes = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_MONITORED_CONDITIONS , default = [ OPTION_TRAFFIC_JAM ] ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] name = config . get ( CONF_NAME ) [EOL] [EOL] sytadin = SytadinData ( URL ) [EOL] [EOL] dev = [ ] [EOL] for option in config . get ( CONF_MONITORED_CONDITIONS ) : [EOL] _LOGGER . debug ( [string] , option ) [EOL] dev . append ( SytadinSensor ( sytadin , name , option , SENSOR_TYPES [ option ] [ [number] ] , SENSOR_TYPES [ option ] [ [number] ] ) ) [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class SytadinSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , sensor_type , option , unit ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _state = None [EOL] self . _name = name [EOL] self . _option = option [EOL] self . _type = sensor_type [EOL] self . _unit = unit [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return [string] . format ( self . _name , self . _option ) [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] return { ATTR_ATTRIBUTION : CONF_ATTRIBUTION , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] [EOL] if self . data is None : [EOL] return [EOL] [EOL] if self . _type == OPTION_TRAFFIC_JAM : [EOL] self . _state = self . data . traffic_jam [EOL] elif self . _type == OPTION_MEAN_VELOCITY : [EOL] self . _state = self . data . mean_velocity [EOL] elif self . _type == OPTION_CONGESTION : [EOL] self . _state = self . data . congestion [EOL] [EOL] [EOL] class SytadinData ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , resource ) : [EOL] [docstring] [EOL] self . _resource = resource [EOL] self . data = None [EOL] self . traffic_jam = self . mean_velocity = self . congestion = None [EOL] [EOL] @ Throttle ( MIN_TIME_BETWEEN_UPDATES ) def update ( self ) : [EOL] [docstring] [EOL] from bs4 import BeautifulSoup [EOL] [EOL] try : [EOL] raw_html = requests . get ( self . _resource , timeout = [number] ) . text [EOL] data = BeautifulSoup ( raw_html , [string] ) [EOL] [EOL] values = data . select ( [string] ) [EOL] self . traffic_jam = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] self . mean_velocity = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] self . congestion = re . search ( REGEX , values [ [number] ] . text ) . group ( ) [EOL] except requests . exceptions . ConnectionError : [EOL] _LOGGER . error ( [string] ) [EOL] self . data = None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . const import CONF_HOST , CONF_PORT [EOL] from homeassistant . helpers . entity import Entity [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] ATTR_DEVICE_URI = [string] [EOL] ATTR_PRINTER_INFO = [string] [EOL] ATTR_PRINTER_IS_SHARED = [string] [EOL] ATTR_PRINTER_LOCATION = [string] [EOL] ATTR_PRINTER_MODEL = [string] [EOL] ATTR_PRINTER_STATE_MESSAGE = [string] [EOL] ATTR_PRINTER_STATE_REASON = [string] [EOL] ATTR_PRINTER_TYPE = [string] [EOL] ATTR_PRINTER_URI_SUPPORTED = [string] [EOL] [EOL] CONF_PRINTERS = [string] [EOL] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_PORT = [number] [EOL] [EOL] ICON = [string] [EOL] [EOL] SCAN_INTERVAL = timedelta ( minutes = [number] ) [EOL] [EOL] PRINTER_STATES = { [number] : [string] , [number] : [string] , [number] : [string] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_PRINTERS ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] printers = config . get ( CONF_PRINTERS ) [EOL] [EOL] try : [EOL] data = CupsData ( host , port ) [EOL] data . update ( ) [EOL] except RuntimeError : [EOL] _LOGGER . error ( [string] , host , port ) [EOL] return False [EOL] [EOL] dev = [ ] [EOL] for printer in printers : [EOL] if printer in data . printers : [EOL] dev . append ( CupsSensor ( data , printer ) ) [EOL] else : [EOL] _LOGGER . error ( [string] , printer ) [EOL] continue [EOL] [EOL] add_devices ( dev , True ) [EOL] [EOL] [EOL] class CupsSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , printer ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = printer [EOL] self . _printer = None [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] if self . _printer is not None : [EOL] try : [EOL] return next ( v for k , v in PRINTER_STATES . items ( ) if self . _printer [ [string] ] == k ) [EOL] except StopIteration : [EOL] return self . _printer [ [string] ] [EOL] [EOL] @ property def icon ( self ) : [EOL] [docstring] [EOL] return ICON [EOL] [EOL] @ property def device_state_attributes ( self ) : [EOL] [docstring] [EOL] if self . _printer is not None : [EOL] return { ATTR_DEVICE_URI : self . _printer [ [string] ] , ATTR_PRINTER_INFO : self . _printer [ [string] ] , ATTR_PRINTER_IS_SHARED : self . _printer [ [string] ] , ATTR_PRINTER_LOCATION : self . _printer [ [string] ] , ATTR_PRINTER_MODEL : self . _printer [ [string] ] , ATTR_PRINTER_STATE_MESSAGE : self . _printer [ [string] ] , ATTR_PRINTER_STATE_REASON : self . _printer [ [string] ] , ATTR_PRINTER_TYPE : self . _printer [ [string] ] , ATTR_PRINTER_URI_SUPPORTED : self . _printer [ [string] ] , } [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] self . _printer = self . data . printers . get ( self . _name ) [EOL] [EOL] [EOL] [comment] [EOL] class CupsData ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port ) : [EOL] [docstring] [EOL] self . _host = host [EOL] self . _port = port [EOL] self . printers = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from cups import Connection [EOL] [EOL] conn = Connection ( host = self . _host , port = self . _port ) [EOL] self . printers = conn . getPrinters ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 $builtins.str$ 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.int,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . const import ( CONF_FORCE_UPDATE , CONF_MONITORED_CONDITIONS , CONF_NAME , CONF_MAC ) [EOL] [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_ADAPTER = [string] [EOL] CONF_CACHE = [string] [EOL] CONF_MEDIAN = [string] [EOL] CONF_RETRIES = [string] [EOL] CONF_TIMEOUT = [string] [EOL] [EOL] DEFAULT_ADAPTER = [string] [EOL] DEFAULT_UPDATE_INTERVAL = [number] [EOL] DEFAULT_FORCE_UPDATE = False [EOL] DEFAULT_MEDIAN = [number] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_RETRIES = [number] [EOL] DEFAULT_TIMEOUT = [number] [EOL] [EOL] [EOL] [comment] [EOL] SENSOR_TYPES = { [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , } [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_MAC ) : cv . string , vol . Optional ( CONF_MONITORED_CONDITIONS , default = list ( SENSOR_TYPES ) ) : vol . All ( cv . ensure_list , [ vol . In ( SENSOR_TYPES ) ] ) , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_MEDIAN , default = DEFAULT_MEDIAN ) : cv . positive_int , vol . Optional ( CONF_FORCE_UPDATE , default = DEFAULT_FORCE_UPDATE ) : cv . boolean , vol . Optional ( CONF_TIMEOUT , default = DEFAULT_TIMEOUT ) : cv . positive_int , vol . Optional ( CONF_RETRIES , default = DEFAULT_RETRIES ) : cv . positive_int , vol . Optional ( CONF_CACHE , default = DEFAULT_UPDATE_INTERVAL ) : cv . positive_int , vol . Optional ( CONF_ADAPTER , default = DEFAULT_ADAPTER ) : cv . string , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from mitemp_bt import mitemp_bt_poller [EOL] try : [EOL] import bluepy . btle [comment] [EOL] from btlewrap import BluepyBackend [EOL] backend = BluepyBackend [EOL] except ImportError : [EOL] from btlewrap import GatttoolBackend [EOL] backend = GatttoolBackend [EOL] _LOGGER . debug ( [string] , backend . __name__ ) [EOL] [EOL] cache = config . get ( CONF_CACHE ) [EOL] poller = mitemp_bt_poller . MiTempBtPoller ( config . get ( CONF_MAC ) , cache_timeout = cache , adapter = config . get ( CONF_ADAPTER ) , backend = backend ) [EOL] force_update = config . get ( CONF_FORCE_UPDATE ) [EOL] median = config . get ( CONF_MEDIAN ) [EOL] poller . ble_timeout = config . get ( CONF_TIMEOUT ) [EOL] poller . retries = config . get ( CONF_RETRIES ) [EOL] [EOL] devs = [ ] [EOL] [EOL] for parameter in config [ CONF_MONITORED_CONDITIONS ] : [EOL] name = SENSOR_TYPES [ parameter ] [ [number] ] [EOL] unit = SENSOR_TYPES [ parameter ] [ [number] ] [EOL] [EOL] prefix = config . get ( CONF_NAME ) [EOL] if prefix : [EOL] name = [string] . format ( prefix , name ) [EOL] [EOL] devs . append ( MiTempBtSensor ( poller , parameter , name , unit , force_update , median ) ) [EOL] [EOL] add_devices ( devs ) [EOL] [EOL] [EOL] class MiTempBtSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , poller , parameter , name , unit , force_update , median ) : [EOL] [docstring] [EOL] self . poller = poller [EOL] self . parameter = parameter [EOL] self . _unit = unit [EOL] self . _name = name [EOL] self . _state = None [EOL] self . data = [ ] [EOL] self . _force_update = force_update [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] self . median_count = median [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit [EOL] [EOL] @ property def force_update ( self ) : [EOL] [docstring] [EOL] return self . _force_update [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from btlewrap . base import BluetoothBackendException [EOL] try : [EOL] _LOGGER . debug ( [string] , self . name ) [EOL] data = self . poller . parameter_value ( self . parameter ) [EOL] except IOError as ioerr : [EOL] _LOGGER . warning ( [string] , ioerr ) [EOL] return [EOL] except BluetoothBackendException as bterror : [EOL] _LOGGER . warning ( [string] , bterror ) [EOL] return [EOL] [EOL] if data is not None : [EOL] _LOGGER . debug ( [string] , self . name , data ) [EOL] self . data . append ( data ) [EOL] else : [EOL] _LOGGER . warning ( [string] , self . name ) [EOL] [comment] [EOL] [comment] [EOL] if self . data : [EOL] self . data = self . data [ [number] : ] [EOL] else : [EOL] self . _state = None [EOL] return [EOL] [EOL] if len ( self . data ) > self . median_count : [EOL] self . data = self . data [ [number] : ] [EOL] [EOL] if len ( self . data ) == self . median_count : [EOL] median = sorted ( self . data ) [ int ( ( self . median_count - [number] ) / [number] ) ] [EOL] _LOGGER . debug ( [string] , median ) [EOL] self . _state = median [EOL] else : [EOL] _LOGGER . debug ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] import logging [EOL] from datetime import timedelta [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . sensor import PLATFORM_SCHEMA [EOL] from homeassistant . helpers . entity import Entity [EOL] from homeassistant . const import ( CONF_HOST , CONF_NAME , CONF_PORT , CONF_UNIT_OF_MEASUREMENT , STATE_UNKNOWN , CONF_VALUE_TEMPLATE ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_BASEOID = [string] [EOL] CONF_COMMUNITY = [string] [EOL] CONF_VERSION = [string] [EOL] CONF_ACCEPT_ERRORS = [string] [EOL] CONF_DEFAULT_VALUE = [string] [EOL] [EOL] DEFAULT_COMMUNITY = [string] [EOL] DEFAULT_HOST = [string] [EOL] DEFAULT_NAME = [string] [EOL] DEFAULT_PORT = [string] [EOL] DEFAULT_VERSION = [string] [EOL] [EOL] SNMP_VERSIONS = { [string] : [number] , [string] : [number] } [EOL] [EOL] SCAN_INTERVAL = timedelta ( seconds = [number] ) [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_BASEOID ) : cv . string , vol . Optional ( CONF_ACCEPT_ERRORS , default = False ) : cv . boolean , vol . Optional ( CONF_COMMUNITY , default = DEFAULT_COMMUNITY ) : cv . string , vol . Optional ( CONF_DEFAULT_VALUE ) : cv . string , vol . Optional ( CONF_HOST , default = DEFAULT_HOST ) : cv . string , vol . Optional ( CONF_NAME , default = DEFAULT_NAME ) : cv . string , vol . Optional ( CONF_PORT , default = DEFAULT_PORT ) : cv . port , vol . Optional ( CONF_UNIT_OF_MEASUREMENT ) : cv . string , vol . Optional ( CONF_VALUE_TEMPLATE ) : cv . template , vol . Optional ( CONF_VERSION , default = DEFAULT_VERSION ) : vol . In ( SNMP_VERSIONS ) , } ) [EOL] [EOL] [EOL] def setup_platform ( hass , config , add_devices , discovery_info = None ) : [EOL] [docstring] [EOL] from pysnmp . hlapi import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] [EOL] name = config . get ( CONF_NAME ) [EOL] host = config . get ( CONF_HOST ) [EOL] port = config . get ( CONF_PORT ) [EOL] community = config . get ( CONF_COMMUNITY ) [EOL] baseoid = config . get ( CONF_BASEOID ) [EOL] unit = config . get ( CONF_UNIT_OF_MEASUREMENT ) [EOL] version = config . get ( CONF_VERSION ) [EOL] accept_errors = config . get ( CONF_ACCEPT_ERRORS ) [EOL] default_value = config . get ( CONF_DEFAULT_VALUE ) [EOL] value_template = config . get ( CONF_VALUE_TEMPLATE ) [EOL] [EOL] if value_template is not None : [EOL] value_template . hass = hass [EOL] [EOL] errindication , _ , _ , _ = next ( getCmd ( SnmpEngine ( ) , CommunityData ( community , mpModel = SNMP_VERSIONS [ version ] ) , UdpTransportTarget ( ( host , port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( baseoid ) ) ) ) [EOL] [EOL] if errindication and not accept_errors : [EOL] _LOGGER . error ( [string] ) [EOL] return False [EOL] else : [EOL] data = SnmpData ( host , port , community , baseoid , version , accept_errors , default_value ) [EOL] add_devices ( [ SnmpSensor ( data , name , unit , value_template ) ] , True ) [EOL] [EOL] [EOL] class SnmpSensor ( Entity ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , data , name , unit_of_measurement , value_template ) : [EOL] [docstring] [EOL] self . data = data [EOL] self . _name = name [EOL] self . _state = None [EOL] self . _unit_of_measurement = unit_of_measurement [EOL] self . _value_template = value_template [EOL] [EOL] @ property def name ( self ) : [EOL] [docstring] [EOL] return self . _name [EOL] [EOL] @ property def state ( self ) : [EOL] [docstring] [EOL] return self . _state [EOL] [EOL] @ property def unit_of_measurement ( self ) : [EOL] [docstring] [EOL] return self . _unit_of_measurement [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] self . data . update ( ) [EOL] value = self . data . value [EOL] [EOL] if value is None : [EOL] value = STATE_UNKNOWN [EOL] elif self . _value_template is not None : [EOL] value = self . _value_template . render_with_possible_json_value ( value , STATE_UNKNOWN ) [EOL] [EOL] self . _state = value [EOL] [EOL] [EOL] class SnmpData ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , community , baseoid , version , accept_errors , default_value ) : [EOL] [docstring] [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _community = community [EOL] self . _baseoid = baseoid [EOL] self . _version = SNMP_VERSIONS [ version ] [EOL] self . _accept_errors = accept_errors [EOL] self . _default_value = default_value [EOL] self . value = None [EOL] [EOL] def update ( self ) : [EOL] [docstring] [EOL] from pysnmp . hlapi import ( getCmd , CommunityData , SnmpEngine , UdpTransportTarget , ContextData , ObjectType , ObjectIdentity ) [EOL] errindication , errstatus , errindex , restable = next ( getCmd ( SnmpEngine ( ) , CommunityData ( self . _community , mpModel = self . _version ) , UdpTransportTarget ( ( self . _host , self . _port ) ) , ContextData ( ) , ObjectType ( ObjectIdentity ( self . _baseoid ) ) ) ) [EOL] [EOL] if errindication and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errindication ) [EOL] elif errstatus and not self . _accept_errors : [EOL] _LOGGER . error ( [string] , errstatus . prettyPrint ( ) , errindex and restable [ - [number] ] [ int ( errindex ) - [number] ] or [string] ) [EOL] elif ( errindication or errstatus ) and self . _accept_errors : [EOL] self . value = self . _default_value [EOL] else : [EOL] for resrow in restable : [EOL] self . value = str ( resrow [ - [number] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Pattern , List , Type [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] import re [EOL] import socket [EOL] import telnetlib [EOL] from collections import namedtuple [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , CONF_PORT , CONF_MODE , CONF_PROTOCOL ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_PUB_KEY = [string] [EOL] CONF_SSH_KEY = [string] [EOL] CONF_REQUIRE_IP = [string] [EOL] DEFAULT_SSH_PORT = [number] [EOL] SECRET_GROUP = [string] [EOL] [EOL] PLATFORM_SCHEMA = vol . All ( cv . has_at_least_one_key ( CONF_PASSWORD , CONF_PUB_KEY , CONF_SSH_KEY ) , PLATFORM_SCHEMA . extend ( { vol . Required ( CONF_HOST ) : cv . string , vol . Required ( CONF_USERNAME ) : cv . string , vol . Optional ( CONF_PROTOCOL , default = [string] ) : vol . In ( [ [string] , [string] ] ) , vol . Optional ( CONF_MODE , default = [string] ) : vol . In ( [ [string] , [string] ] ) , vol . Optional ( CONF_PORT , default = DEFAULT_SSH_PORT ) : cv . port , vol . Optional ( CONF_REQUIRE_IP , default = True ) : cv . boolean , vol . Exclusive ( CONF_PASSWORD , SECRET_GROUP ) : cv . string , vol . Exclusive ( CONF_SSH_KEY , SECRET_GROUP ) : cv . isfile , vol . Exclusive ( CONF_PUB_KEY , SECRET_GROUP ) : cv . isfile } ) ) [EOL] [EOL] [EOL] _LEASES_CMD = [string] [EOL] _LEASES_REGEX = re . compile ( [string] + [string] + [string] + [string] ) [EOL] [EOL] [comment] [EOL] _WL_CMD = [string] [EOL] _WL_REGEX = re . compile ( [string] + [string] ) [EOL] [EOL] _IP_NEIGH_CMD = [string] [EOL] _IP_NEIGH_REGEX = re . compile ( [string] [string] [string] [string] [string] [string] [string] [string] ) [EOL] [EOL] _ARP_CMD = [string] [EOL] _ARP_REGEX = re . compile ( [string] + [string] + [string] + [string] + [string] + [string] ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] scanner = AsusWrtDeviceScanner ( config [ DOMAIN ] ) [EOL] [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] def _parse_lines ( lines , regex ) : [EOL] [docstring] [EOL] results = [ ] [EOL] for line in lines : [EOL] match = regex . search ( line ) [EOL] if not match : [EOL] _LOGGER . debug ( [string] , line ) [EOL] continue [EOL] results . append ( match . groupdict ( ) ) [EOL] return results [EOL] [EOL] [EOL] Device = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] [EOL] class AsusWrtDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] def __init__ ( self , config ) : [EOL] [docstring] [EOL] self . host = config [ CONF_HOST ] [EOL] self . username = config [ CONF_USERNAME ] [EOL] self . password = config . get ( CONF_PASSWORD , [string] ) [EOL] self . ssh_key = config . get ( [string] , config . get ( [string] , [string] ) ) [EOL] self . protocol = config [ CONF_PROTOCOL ] [EOL] self . mode = config [ CONF_MODE ] [EOL] self . port = config [ CONF_PORT ] [EOL] self . require_ip = config [ CONF_REQUIRE_IP ] [EOL] [EOL] if self . protocol == [string] : [EOL] self . connection = SshConnection ( self . host , self . port , self . username , self . password , self . ssh_key ) [EOL] else : [EOL] self . connection = TelnetConnection ( self . host , self . port , self . username , self . password ) [EOL] [EOL] self . last_results = { } [EOL] [EOL] [comment] [EOL] data = self . get_asuswrt_data ( ) [EOL] self . success_init = data is not None [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] return list ( self . last_results . keys ( ) ) [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] if device not in self . last_results : [EOL] return None [EOL] return self . last_results [ device ] . name [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if not self . success_init : [EOL] return False [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] data = self . get_asuswrt_data ( ) [EOL] if not data : [EOL] return False [EOL] [EOL] self . last_results = data [EOL] return True [EOL] [EOL] def get_asuswrt_data ( self ) : [EOL] [docstring] [EOL] devices = { } [EOL] devices . update ( self . _get_wl ( ) ) [EOL] devices . update ( self . _get_arp ( ) ) [EOL] devices . update ( self . _get_neigh ( devices ) ) [EOL] if not self . mode == [string] : [EOL] devices . update ( self . _get_leases ( devices ) ) [EOL] [EOL] ret_devices = { } [EOL] for key in devices : [EOL] if not self . require_ip or devices [ key ] . ip is not None : [EOL] ret_devices [ key ] = devices [ key ] [EOL] return ret_devices [EOL] [EOL] def _get_wl ( self ) : [EOL] lines = self . connection . run_command ( _WL_CMD ) [EOL] if not lines : [EOL] return { } [EOL] result = _parse_lines ( lines , _WL_REGEX ) [EOL] devices = { } [EOL] for device in result : [EOL] mac = device [ [string] ] . upper ( ) [EOL] devices [ mac ] = Device ( mac , None , None ) [EOL] return devices [EOL] [EOL] def _get_leases ( self , cur_devices ) : [EOL] lines = self . connection . run_command ( _LEASES_CMD ) [EOL] if not lines : [EOL] return { } [EOL] lines = [ line for line in lines if not line . startswith ( [string] ) ] [EOL] result = _parse_lines ( lines , _LEASES_REGEX ) [EOL] devices = { } [EOL] for device in result : [EOL] [comment] [EOL] [comment] [EOL] host = device [ [string] ] [EOL] if host == [string] : [EOL] host = [string] [EOL] mac = device [ [string] ] . upper ( ) [EOL] if mac in cur_devices : [EOL] devices [ mac ] = Device ( mac , device [ [string] ] , host ) [EOL] return devices [EOL] [EOL] def _get_neigh ( self , cur_devices ) : [EOL] lines = self . connection . run_command ( _IP_NEIGH_CMD ) [EOL] if not lines : [EOL] return { } [EOL] result = _parse_lines ( lines , _IP_NEIGH_REGEX ) [EOL] devices = { } [EOL] for device in result : [EOL] status = device [ [string] ] [EOL] if status is None or status . upper ( ) != [string] : [EOL] continue [EOL] if device [ [string] ] is not None : [EOL] mac = device [ [string] ] . upper ( ) [EOL] old_device = cur_devices . get ( mac ) [EOL] old_ip = old_device . ip if old_device else None [EOL] devices [ mac ] = Device ( mac , device . get ( [string] , old_ip ) , None ) [EOL] return devices [EOL] [EOL] def _get_arp ( self ) : [EOL] lines = self . connection . run_command ( _ARP_CMD ) [EOL] if not lines : [EOL] return { } [EOL] result = _parse_lines ( lines , _ARP_REGEX ) [EOL] devices = { } [EOL] for device in result : [EOL] if device [ [string] ] is not None : [EOL] mac = device [ [string] ] . upper ( ) [EOL] devices [ mac ] = Device ( mac , device [ [string] ] , None ) [EOL] return devices [EOL] [EOL] [EOL] class _Connection : [EOL] def __init__ ( self ) : [EOL] self . _connected = False [EOL] [EOL] @ property def connected ( self ) : [EOL] [docstring] [EOL] return self . _connected [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] self . _connected = True [EOL] [EOL] def disconnect ( self ) : [EOL] [docstring] [EOL] self . _connected = False [EOL] [EOL] [EOL] class SshConnection ( _Connection ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , username , password , ssh_key ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _ssh = None [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _ssh_key = ssh_key [EOL] [EOL] def run_command ( self , command ) : [EOL] [docstring] [EOL] from pexpect import pxssh , exceptions [EOL] [EOL] try : [EOL] if not self . connected : [EOL] self . connect ( ) [EOL] self . _ssh . sendline ( command ) [EOL] self . _ssh . prompt ( ) [EOL] lines = self . _ssh . before . split ( [string] ) [ [number] : - [number] ] [EOL] return [ line . decode ( [string] ) for line in lines ] [EOL] except exceptions . EOF as err : [EOL] _LOGGER . error ( [string] , self . _ssh . before ) [EOL] self . disconnect ( ) [EOL] return None [EOL] except pxssh . ExceptionPxssh as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] self . disconnect ( ) [EOL] return None [EOL] except AssertionError as err : [EOL] _LOGGER . error ( [string] , err ) [EOL] self . disconnect ( ) [EOL] return None [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] from pexpect import pxssh [EOL] [EOL] self . _ssh = pxssh . pxssh ( ) [EOL] if self . _ssh_key : [EOL] self . _ssh . login ( self . _host , self . _username , quiet = False , ssh_key = self . _ssh_key , port = self . _port ) [EOL] else : [EOL] self . _ssh . login ( self . _host , self . _username , quiet = False , password = self . _password , port = self . _port ) [EOL] [EOL] super ( ) . connect ( ) [EOL] [EOL] def disconnect ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _ssh . logout ( ) [EOL] except Exception : [comment] [EOL] pass [EOL] finally : [EOL] self . _ssh = None [EOL] [EOL] super ( ) . disconnect ( ) [EOL] [EOL] [EOL] class TelnetConnection ( _Connection ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , port , username , password ) : [EOL] [docstring] [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . _telnet = None [EOL] self . _host = host [EOL] self . _port = port [EOL] self . _username = username [EOL] self . _password = password [EOL] self . _prompt_string = None [EOL] [EOL] def run_command ( self , command ) : [EOL] [docstring] [EOL] try : [EOL] if not self . connected : [EOL] self . connect ( ) [EOL] self . _telnet . write ( [string] . format ( command ) . encode ( [string] ) ) [EOL] data = ( self . _telnet . read_until ( self . _prompt_string ) . split ( [string] ) [ [number] : - [number] ] ) [EOL] return [ line . decode ( [string] ) for line in data ] [EOL] except EOFError : [EOL] _LOGGER . error ( [string] ) [EOL] self . disconnect ( ) [EOL] return None [EOL] except ConnectionRefusedError : [EOL] _LOGGER . error ( [string] ) [EOL] self . disconnect ( ) [EOL] return None [EOL] except socket . gaierror as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] self . disconnect ( ) [EOL] return None [EOL] except OSError as exc : [EOL] _LOGGER . error ( [string] , exc ) [EOL] self . disconnect ( ) [EOL] return None [EOL] [EOL] def connect ( self ) : [EOL] [docstring] [EOL] self . _telnet = telnetlib . Telnet ( self . _host ) [EOL] self . _telnet . read_until ( [string] ) [EOL] self . _telnet . write ( ( self . _username + [string] ) . encode ( [string] ) ) [EOL] self . _telnet . read_until ( [string] ) [EOL] self . _telnet . write ( ( self . _password + [string] ) . encode ( [string] ) ) [EOL] self . _prompt_string = self . _telnet . read_until ( [string] ) . split ( [string] ) [ - [number] ] [EOL] [EOL] super ( ) . connect ( ) [EOL] [EOL] def disconnect ( self ) : [EOL] [docstring] [EOL] try : [EOL] self . _telnet . write ( [string] . encode ( [string] ) ) [EOL] except Exception : [comment] [EOL] pass [EOL] [EOL] super ( ) . disconnect ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Pattern[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[homeassistant.components.device_tracker.asuswrt.Device]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Type[homeassistant.components.device_tracker.asuswrt.Device]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.Pattern[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Type[homeassistant.components.device_tracker.asuswrt.Device]$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Type[homeassistant.components.device_tracker.asuswrt.Device]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Pattern[builtins.str]$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Any$ 0 0 $typing.Type[homeassistant.components.device_tracker.asuswrt.Device]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import logging [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] import logging [EOL] [EOL] import voluptuous as vol [EOL] [EOL] import homeassistant . helpers . config_validation as cv [EOL] from homeassistant . components . device_tracker import ( DOMAIN , PLATFORM_SCHEMA , DeviceScanner ) [EOL] from homeassistant . const import ( CONF_HOST , CONF_PASSWORD , CONF_USERNAME , CONF_PORT , CONF_SSL , CONF_DEVICES , CONF_EXCLUDE ) [EOL] [EOL] REQUIREMENTS = [ [string] ] [EOL] [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] CONF_APS = [string] [EOL] [EOL] PLATFORM_SCHEMA = PLATFORM_SCHEMA . extend ( { vol . Optional ( CONF_HOST , default = [string] ) : cv . string , vol . Optional ( CONF_SSL , default = False ) : cv . boolean , vol . Optional ( CONF_USERNAME , default = [string] ) : cv . string , vol . Required ( CONF_PASSWORD ) : cv . string , vol . Optional ( CONF_PORT , default = None ) : vol . Any ( None , cv . port ) , vol . Optional ( CONF_DEVICES , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_EXCLUDE , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , vol . Optional ( CONF_APS , default = [ ] ) : vol . All ( cv . ensure_list , [ cv . string ] ) , } ) [EOL] [EOL] [EOL] def get_scanner ( hass , config ) : [EOL] [docstring] [EOL] info = config [ DOMAIN ] [EOL] host = info . get ( CONF_HOST ) [EOL] ssl = info . get ( CONF_SSL ) [EOL] username = info . get ( CONF_USERNAME ) [EOL] password = info . get ( CONF_PASSWORD ) [EOL] port = info . get ( CONF_PORT ) [EOL] devices = info . get ( CONF_DEVICES ) [EOL] excluded_devices = info . get ( CONF_EXCLUDE ) [EOL] accesspoints = info . get ( CONF_APS ) [EOL] [EOL] scanner = NetgearDeviceScanner ( host , ssl , username , password , port , devices , excluded_devices , accesspoints ) [EOL] [EOL] return scanner if scanner . success_init else None [EOL] [EOL] [EOL] class NetgearDeviceScanner ( DeviceScanner ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , host , ssl , username , password , port , devices , excluded_devices , accesspoints ) : [EOL] [docstring] [EOL] import pynetgear [EOL] [EOL] self . tracked_devices = devices [EOL] self . excluded_devices = excluded_devices [EOL] self . tracked_accesspoints = accesspoints [EOL] [EOL] self . last_results = [ ] [EOL] self . _api = pynetgear . Netgear ( password , host , username , port , ssl ) [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] results = self . get_attached_devices ( ) [EOL] [EOL] self . success_init = results is not None [EOL] [EOL] if self . success_init : [EOL] self . last_results = results [EOL] else : [EOL] _LOGGER . error ( [string] ) [EOL] [EOL] def scan_devices ( self ) : [EOL] [docstring] [EOL] self . _update_info ( ) [EOL] [EOL] devices = [ ] [EOL] [EOL] for dev in self . last_results : [EOL] tracked = ( not self . tracked_devices or dev . mac in self . tracked_devices or dev . name in self . tracked_devices ) [EOL] tracked = tracked and ( not self . excluded_devices or not ( dev . mac in self . excluded_devices or dev . name in self . excluded_devices ) ) [EOL] if tracked : [EOL] devices . append ( dev . mac ) [EOL] if ( self . tracked_accesspoints and dev . conn_ap_mac in self . tracked_accesspoints ) : [EOL] devices . append ( dev . mac + [string] + dev . conn_ap_mac ) [EOL] [EOL] return devices [EOL] [EOL] def get_device_name ( self , device ) : [EOL] [docstring] [EOL] parts = device . split ( [string] ) [EOL] mac = parts [ [number] ] [EOL] ap_mac = None [EOL] if len ( parts ) > [number] : [EOL] ap_mac = parts [ [number] ] [EOL] [EOL] name = None [EOL] for dev in self . last_results : [EOL] if dev . mac == mac : [EOL] name = dev . name [EOL] break [EOL] [EOL] if not name or name == [string] : [EOL] name = mac [EOL] [EOL] if ap_mac : [EOL] ap_name = [string] [EOL] for dev in self . last_results : [EOL] if dev . mac == ap_mac : [EOL] ap_name = dev . name [EOL] break [EOL] [EOL] return name + [string] + ap_name [EOL] [EOL] return name [EOL] [EOL] def _update_info ( self ) : [EOL] [docstring] [EOL] if not self . success_init : [EOL] return [EOL] [EOL] _LOGGER . info ( [string] ) [EOL] [EOL] results = self . get_attached_devices ( ) [EOL] [EOL] if results is None : [EOL] _LOGGER . warning ( [string] ) [EOL] [EOL] self . last_results = results or [ ] [EOL] [EOL] def get_attached_devices ( self ) : [EOL] [docstring] [EOL] if self . tracked_accesspoints : [EOL] return self . _api . get_attached_devices_2 ( ) [EOL] [EOL] return self . _api . get_attached_devices ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import argparse [EOL] import getpass [EOL] import os [EOL] [EOL] from homeassistant . util . yaml import _SECRET_NAMESPACE [EOL] [EOL] REQUIREMENTS = [ [string] , [string] ] [EOL] [EOL] [EOL] def run ( args ) : [EOL] [docstring] [EOL] parser = argparse . ArgumentParser ( description = ( [string] [string] [string] ) ) [EOL] parser . add_argument ( [string] , choices = [ [string] ] ) [EOL] parser . add_argument ( [string] , choices = [ [string] , [string] , [string] , [string] ] , help = [string] ) [EOL] parser . add_argument ( [string] , help = [string] , nargs = [string] , default = None ) [EOL] [EOL] import keyring [EOL] from keyring . util import platform_ as platform [EOL] [EOL] args = parser . parse_args ( args ) [EOL] [EOL] if args . action == [string] : [EOL] keyr = keyring . get_keyring ( ) [EOL] print ( [string] . format ( REQUIREMENTS [ [number] ] . split ( [string] ) [ [number] ] ) ) [EOL] print ( [string] . format ( keyr . __module__ ) ) [EOL] config_name = os . path . join ( platform . config_root ( ) , [string] ) [EOL] print ( [string] . format ( config_name ) ) [EOL] print ( [string] . format ( platform . data_root ( ) ) ) [EOL] elif args . name is None : [EOL] parser . print_help ( ) [EOL] return [number] [EOL] [EOL] if args . action == [string] : [EOL] the_secret = getpass . getpass ( [string] . format ( args . name ) ) [EOL] keyring . set_password ( _SECRET_NAMESPACE , args . name , the_secret ) [EOL] print ( [string] . format ( args . name ) ) [EOL] elif args . action == [string] : [EOL] the_secret = keyring . get_password ( _SECRET_NAMESPACE , args . name ) [EOL] if the_secret is None : [EOL] print ( [string] . format ( args . name ) ) [EOL] else : [EOL] print ( [string] . format ( args . name , the_secret ) ) [EOL] elif args . action == [string] : [EOL] try : [EOL] keyring . delete_password ( _SECRET_NAMESPACE , args . name ) [EOL] print ( [string] . format ( args . name ) ) [EOL] except keyring . errors . PasswordDeleteError : [EOL] print ( [string] . format ( args . name ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from . const import TEST [comment] [EOL] [EOL] [EOL] DOMAIN = [string] [EOL] [EOL] [EOL] async def async_setup ( hass , config ) : [EOL] [docstring] [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] TEST = [number] [EOL]	0 0 $builtins.int$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components import weblink [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestComponentWeblink ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_bad_config ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { } ] , } } ) ) [EOL] [EOL] def test_bad_config_relative_url ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_bad_config_relative_file ( self ) : [EOL] [docstring] [EOL] self . assertFalse ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_good_config_absolute_path ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_good_config_path_short ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_good_config_path_directory ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_good_config_ftp_link ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , [string] , { [string] : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] , } } ) ) [EOL] [EOL] def test_entities_get_created ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , weblink . DOMAIN , { weblink . DOMAIN : { [string] : [ { weblink . CONF_NAME : [string] , weblink . CONF_URL : [string] } , ] } } ) ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert state is not None [EOL] assert state . state == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] from unittest . mock import ANY , patch [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . mqtt_eventstream as eventstream [EOL] from homeassistant . const import EVENT_STATE_CHANGED [EOL] from homeassistant . core import State , callback [EOL] from homeassistant . remote import JSONEncoder [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import ( get_test_home_assistant , mock_mqtt_component , fire_mqtt_message , mock_state_change_event , fire_time_changed ) [EOL] [EOL] [EOL] class TestMqttEventStream ( object ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . mock_mqtt = mock_mqtt_component ( self . hass ) [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def add_eventstream ( self , sub_topic = None , pub_topic = None , ignore_event = None ) : [EOL] [docstring] [EOL] config = { } [EOL] if sub_topic : [EOL] config [ [string] ] = sub_topic [EOL] if pub_topic : [EOL] config [ [string] ] = pub_topic [EOL] if ignore_event : [EOL] config [ [string] ] = ignore_event [EOL] return setup_component ( self . hass , eventstream . DOMAIN , { eventstream . DOMAIN : config } ) [EOL] [EOL] def test_setup_succeeds ( self ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( ) [EOL] [EOL] def test_setup_with_pub ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] assert self . hass . bus . listeners . get ( [string] ) is None [EOL] [EOL] assert self . add_eventstream ( pub_topic = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . bus . listeners . get ( [string] ) == [number] [EOL] [EOL] @ patch ( [string] ) def test_subscribe ( self , mock_sub ) : [EOL] [docstring] [EOL] sub_topic = [string] [EOL] assert self . add_eventstream ( sub_topic = sub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] mock_sub . assert_called_with ( self . hass , sub_topic , ANY ) [EOL] [EOL] @ patch ( [string] ) @ patch ( [string] ) def test_state_changed_event_sends_message ( self , mock_utcnow , mock_pub ) : [EOL] [docstring] [EOL] now = dt_util . as_utc ( dt_util . now ( ) ) [EOL] e_id = [string] [EOL] pub_topic = [string] [EOL] mock_utcnow . return_value = now [EOL] [EOL] [comment] [EOL] assert self . add_eventstream ( pub_topic = pub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . assert_called_with ( self . hass , pub_topic , ANY ) [EOL] assert mock_pub . called [EOL] [EOL] [comment] [EOL] [comment] [EOL] msg = mock_pub . call_args [ [number] ] [ [number] ] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : now . isoformat ( ) , [string] : [string] , [string] : e_id , [string] : { } , [string] : now . isoformat ( ) } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] assert json . loads ( msg ) == event [EOL] [EOL] @ patch ( [string] ) def test_time_event_does_not_send_message ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] fire_time_changed ( self . hass , dt_util . utcnow ( ) ) [EOL] assert not mock_pub . called [EOL] [EOL] def test_receiving_remote_event_fires_hass_event ( self ) : [EOL] [docstring] [EOL] sub_topic = [string] [EOL] assert self . add_eventstream ( sub_topic = sub_topic ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] calls = [ ] [EOL] [EOL] @ callback def listener ( _ ) : [EOL] calls . append ( [number] ) [EOL] [EOL] self . hass . bus . listen_once ( [string] , listener ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] payload = json . dumps ( { [string] : [string] , [string] : { } } , cls = JSONEncoder ) [EOL] fire_mqtt_message ( self . hass , sub_topic , payload ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert [number] == len ( calls ) [EOL] [EOL] @ patch ( [string] ) def test_ignored_event_doesnt_send_over_stream ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] , ignore_event = [ [string] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] e_id = [string] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : [string] , [string] : e_id , [string] : { } , } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert not mock_pub . called [EOL] [EOL] @ patch ( [string] ) def test_wrong_ignored_event_sends_over_stream ( self , mock_pub ) : [EOL] [docstring] [EOL] assert self . add_eventstream ( pub_topic = [string] , ignore_event = [ [string] ] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] e_id = [string] [EOL] event = { } [EOL] event [ [string] ] = EVENT_STATE_CHANGED [EOL] new_state = { [string] : [string] , [string] : e_id , [string] : { } , } [EOL] event [ [string] ] = { [string] : new_state , [string] : e_id } [EOL] [EOL] [comment] [EOL] [comment] [EOL] mock_pub . reset_mock ( ) [EOL] [EOL] [comment] [EOL] mock_state_change_event ( self . hass , State ( e_id , [string] ) ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert mock_pub . called [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[typing.Any,typing.Any],builtins.str]]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from homeassistant . components . auth import indieauth [EOL] [EOL] import pytest [EOL] [EOL] [EOL] def test_client_id_scheme ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_path ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] assert indieauth . _parse_client_id ( [string] ) . path == [string] [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_fragment ( ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_user_pass ( ) : [EOL] [docstring] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_client_id_hostname ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] with pytest . raises ( ValueError ) : [EOL] assert indieauth . _parse_client_id ( [string] ) [EOL] [EOL] [EOL] def test_parse_url_lowercase_host ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_url ( [string] ) . path == [string] [EOL] assert indieauth . _parse_url ( [string] ) . hostname == [string] [EOL] [EOL] parts = indieauth . _parse_url ( [string] ) [EOL] assert parts . netloc == [string] [EOL] assert parts . path == [string] [EOL] [EOL] [EOL] def test_parse_url_path ( ) : [EOL] [docstring] [EOL] assert indieauth . _parse_url ( [string] ) . path == [string] [EOL] [EOL] [EOL] def test_verify_redirect_uri ( ) : [EOL] [docstring] [EOL] assert indieauth . verify_redirect_uri ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] assert not indieauth . verify_redirect_uri ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] assert not indieauth . verify_redirect_uri ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] assert not indieauth . verify_redirect_uri ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Type , Any , Union [EOL] import tests [EOL] import typing [EOL] import datetime [EOL] [docstring] [EOL] [comment] [EOL] import unittest [EOL] from datetime import datetime [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . sensor . season as season [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] HEMISPHERE_NORTHERN = { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] HEMISPHERE_SOUTHERN = { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] HEMISPHERE_EQUATOR = { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] HEMISPHERE_EMPTY = { [string] : { } , [string] : { [string] : [string] , [string] : [string] , } } [EOL] [EOL] [EOL] [comment] [EOL] class TestSeason ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICE = None [EOL] CONFIG_ASTRONOMICAL = { [string] : [string] } [EOL] CONFIG_METEOROLOGICAL = { [string] : [string] } [EOL] [EOL] def add_devices ( self , devices ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICE = device [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_season_should_be_summer_northern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] summer_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( summer_day , season . NORTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_SUMMER , current_season ) [EOL] [EOL] def test_season_should_be_summer_northern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] summer_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( summer_day , season . NORTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_SUMMER , current_season ) [EOL] [EOL] def test_season_should_be_autumn_northern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] autumn_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( autumn_day , season . NORTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_AUTUMN , current_season ) [EOL] [EOL] def test_season_should_be_autumn_northern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] autumn_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( autumn_day , season . NORTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_AUTUMN , current_season ) [EOL] [EOL] def test_season_should_be_winter_northern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] winter_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( winter_day , season . NORTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_WINTER , current_season ) [EOL] [EOL] def test_season_should_be_winter_northern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] winter_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( winter_day , season . NORTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_WINTER , current_season ) [EOL] [EOL] def test_season_should_be_spring_northern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] spring_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( spring_day , season . NORTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_SPRING , current_season ) [EOL] [EOL] def test_season_should_be_spring_northern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] spring_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( spring_day , season . NORTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_SPRING , current_season ) [EOL] [EOL] def test_season_should_be_winter_southern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] winter_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( winter_day , season . SOUTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_WINTER , current_season ) [EOL] [EOL] def test_season_should_be_winter_southern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] winter_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( winter_day , season . SOUTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_WINTER , current_season ) [EOL] [EOL] def test_season_should_be_spring_southern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] spring_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( spring_day , season . SOUTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_SPRING , current_season ) [EOL] [EOL] def test_season_should_be_spring_southern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] spring_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( spring_day , season . SOUTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_SPRING , current_season ) [EOL] [EOL] def test_season_should_be_summer_southern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] summer_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( summer_day , season . SOUTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_SUMMER , current_season ) [EOL] [EOL] def test_season_should_be_summer_southern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] summer_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( summer_day , season . SOUTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_SUMMER , current_season ) [EOL] [EOL] def test_season_should_be_autumn_southern_astronomical ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] autumn_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( autumn_day , season . SOUTHERN , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( season . STATE_AUTUMN , current_season ) [EOL] [EOL] def test_season_should_be_autumn_southern_meteorological ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] autumn_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( autumn_day , season . SOUTHERN , season . TYPE_METEOROLOGICAL ) [EOL] self . assertEqual ( season . STATE_AUTUMN , current_season ) [EOL] [EOL] def test_on_equator_results_in_none ( self ) : [EOL] [docstring] [EOL] [comment] [EOL] summer_day = datetime ( [number] , [number] , [number] , [number] , [number] ) [EOL] current_season = season . get_season ( summer_day , season . EQUATOR , season . TYPE_ASTRONOMICAL ) [EOL] self . assertEqual ( None , current_season ) [EOL] [EOL] def test_setup_hemisphere_northern ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = HEMISPHERE_NORTHERN [ [string] ] [ [string] ] [EOL] assert setup_component ( self . hass , [string] , HEMISPHERE_NORTHERN ) [EOL] self . assertEqual ( self . hass . config . as_dict ( ) [ [string] ] , HEMISPHERE_NORTHERN [ [string] ] [ [string] ] ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL] [EOL] def test_setup_hemisphere_southern ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = HEMISPHERE_SOUTHERN [ [string] ] [ [string] ] [EOL] assert setup_component ( self . hass , [string] , HEMISPHERE_SOUTHERN ) [EOL] self . assertEqual ( self . hass . config . as_dict ( ) [ [string] ] , HEMISPHERE_SOUTHERN [ [string] ] [ [string] ] ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL] [EOL] def test_setup_hemisphere_equator ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = HEMISPHERE_EQUATOR [ [string] ] [ [string] ] [EOL] assert setup_component ( self . hass , [string] , HEMISPHERE_EQUATOR ) [EOL] self . assertEqual ( self . hass . config . as_dict ( ) [ [string] ] , HEMISPHERE_EQUATOR [ [string] ] [ [string] ] ) [EOL] state = self . hass . states . get ( [string] ) [EOL] self . assertEqual ( state . attributes . get ( [string] ) , [string] ) [EOL] [EOL] def test_setup_hemisphere_empty ( self ) : [EOL] [docstring] [EOL] self . hass . config . latitude = None [EOL] assert setup_component ( self . hass , [string] , HEMISPHERE_EMPTY ) [EOL] self . assertEqual ( self . hass . config . as_dict ( ) [ [string] ] , None ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $datetime.datetime$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import typing [EOL] import unittest [EOL] [docstring] [EOL] [EOL] import re [EOL] import asyncio [EOL] from unittest . mock import MagicMock [EOL] import pytest [EOL] [EOL] [EOL] import homeassistant . components . sensor as sensor [EOL] from homeassistant . components . sensor import foobot [EOL] from homeassistant . const import ( TEMP_CELSIUS ) [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . setup import async_setup_component [EOL] from tests . common import load_fixture [EOL] [EOL] VALID_CONFIG = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] [EOL] async def test_default_setup ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( re . compile ( [string] ) , text = load_fixture ( [string] ) ) [EOL] aioclient_mock . get ( re . compile ( [string] ) , text = load_fixture ( [string] ) ) [EOL] assert await async_setup_component ( hass , sensor . DOMAIN , { [string] : VALID_CONFIG } ) [EOL] [EOL] metrics = { [string] : [ [string] , [string] ] , [string] : [ [string] , TEMP_CELSIUS ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] , [string] : [ [string] , [string] ] } [EOL] [EOL] for name , value in metrics . items ( ) : [EOL] state = hass . states . get ( [string] % name ) [EOL] assert state . state == value [ [number] ] [EOL] assert state . attributes . get ( [string] ) == value [ [number] ] [EOL] [EOL] [EOL] async def test_setup_timeout_error ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] fake_async_add_devices = MagicMock ( ) [EOL] [EOL] aioclient_mock . get ( re . compile ( [string] ) , exc = asyncio . TimeoutError ( ) ) [EOL] with pytest . raises ( PlatformNotReady ) : [EOL] await foobot . async_setup_platform ( hass , { [string] : VALID_CONFIG } , fake_async_add_devices ) [EOL] [EOL] [EOL] async def test_setup_permanent_error ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] fake_async_add_devices = MagicMock ( ) [EOL] [EOL] errors = [ [number] , [number] , [number] ] [EOL] for error in errors : [EOL] aioclient_mock . get ( re . compile ( [string] ) , status = error ) [EOL] result = await foobot . async_setup_platform ( hass , { [string] : VALID_CONFIG } , fake_async_add_devices ) [EOL] assert result is None [EOL] [EOL] [EOL] async def test_setup_temporary_error ( hass , aioclient_mock ) : [EOL] [docstring] [EOL] fake_async_add_devices = MagicMock ( ) [EOL] [EOL] errors = [ [number] , [number] ] [EOL] for error in errors : [EOL] aioclient_mock . get ( re . compile ( [string] ) , status = error ) [EOL] with pytest . raises ( PlatformNotReady ) : [EOL] await foobot . async_setup_platform ( hass , { [string] : VALID_CONFIG } , fake_async_add_devices ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0
[docstring] [EOL]	0 0
import builtins [EOL] from typing import Dict , Type , Any , Union [EOL] import logging [EOL] import typing [EOL] import tests [EOL] [docstring] [EOL] import logging [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant import setup [EOL] import homeassistant . components as components [EOL] from homeassistant . const import STATE_ON , STATE_OFF [EOL] from homeassistant . components . fan import ( ATTR_SPEED , ATTR_OSCILLATING , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , ATTR_DIRECTION , DIRECTION_FORWARD , DIRECTION_REVERSE ) [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] _TEST_FAN = [string] [EOL] [comment] [EOL] _STATE_INPUT_BOOLEAN = [string] [EOL] [comment] [EOL] _SPEED_INPUT_SELECT = [string] [EOL] [comment] [EOL] _OSC_INPUT = [string] [EOL] [comment] [EOL] _DIRECTION_INPUT_SELECT = [string] [EOL] [EOL] [EOL] class TestTemplateFan : [EOL] [docstring] [EOL] [EOL] hass = None [EOL] calls = None [EOL] [comment] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] self . calls = [ ] [EOL] [EOL] @ callback def record_call ( service ) : [EOL] [docstring] [EOL] self . calls . append ( service ) [EOL] [EOL] self . hass . services . register ( [string] , [string] , record_call ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] [comment] [EOL] def test_missing_optional_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . _verify ( STATE_ON , None , None , None ) [EOL] [EOL] def test_missing_value_template_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_missing_turn_on_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_missing_turn_off_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_invalid_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def test_templates_with_entities ( self ) : [EOL] [docstring] [EOL] value_template = [string] [EOL] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : value_template , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . _verify ( STATE_OFF , None , None , None ) [EOL] [EOL] self . hass . states . set ( _STATE_INPUT_BOOLEAN , True ) [EOL] self . hass . states . set ( _SPEED_INPUT_SELECT , SPEED_MEDIUM ) [EOL] self . hass . states . set ( _OSC_INPUT , [string] ) [EOL] self . hass . states . set ( _DIRECTION_INPUT_SELECT , DIRECTION_FORWARD ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . _verify ( STATE_ON , SPEED_MEDIUM , True , DIRECTION_FORWARD ) [EOL] [EOL] def test_templates_with_valid_values ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . _verify ( STATE_ON , SPEED_MEDIUM , True , DIRECTION_FORWARD ) [EOL] [EOL] def test_templates_invalid_values ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , [string] : { [string] : [string] } } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] self . _verify ( STATE_OFF , None , None , None ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] def test_on_off ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _STATE_INPUT_BOOLEAN ) . state == STATE_ON [EOL] self . _verify ( STATE_ON , None , None , None ) [EOL] [EOL] [comment] [EOL] components . fan . turn_off ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _STATE_INPUT_BOOLEAN ) . state == STATE_OFF [EOL] self . _verify ( STATE_OFF , None , None , None ) [EOL] [EOL] def test_on_with_speed ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN , SPEED_HIGH ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _STATE_INPUT_BOOLEAN ) . state == STATE_ON [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == SPEED_HIGH [EOL] self . _verify ( STATE_ON , SPEED_HIGH , None , None ) [EOL] [EOL] def test_set_speed ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , SPEED_HIGH ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == SPEED_HIGH [EOL] self . _verify ( STATE_ON , SPEED_HIGH , None , None ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , SPEED_MEDIUM ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == SPEED_MEDIUM [EOL] self . _verify ( STATE_ON , SPEED_MEDIUM , None , None ) [EOL] [EOL] def test_set_invalid_speed_from_initial_stage ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , None , None ) [EOL] [EOL] def test_set_invalid_speed ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , SPEED_HIGH ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == SPEED_HIGH [EOL] self . _verify ( STATE_ON , SPEED_HIGH , None , None ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == SPEED_HIGH [EOL] self . _verify ( STATE_ON , SPEED_HIGH , None , None ) [EOL] [EOL] def test_custom_speed_list ( self ) : [EOL] [docstring] [EOL] self . _register_components ( [ [string] , [string] , [string] ] ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == [string] [EOL] self . _verify ( STATE_ON , [string] , None , None ) [EOL] [EOL] [comment] [EOL] components . fan . set_speed ( self . hass , _TEST_FAN , SPEED_MEDIUM ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _SPEED_INPUT_SELECT ) . state == [string] [EOL] self . _verify ( STATE_ON , [string] , None , None ) [EOL] [EOL] def test_set_osc ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . oscillate ( self . hass , _TEST_FAN , True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _OSC_INPUT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , True , None ) [EOL] [EOL] [comment] [EOL] components . fan . oscillate ( self . hass , _TEST_FAN , False ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _OSC_INPUT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , False , None ) [EOL] [EOL] def test_set_invalid_osc_from_initial_state ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . oscillate ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _OSC_INPUT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , None , None ) [EOL] [EOL] def test_set_invalid_osc ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . oscillate ( self . hass , _TEST_FAN , True ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _OSC_INPUT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , True , None ) [EOL] [EOL] [comment] [EOL] components . fan . oscillate ( self . hass , _TEST_FAN , None ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _OSC_INPUT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , True , None ) [EOL] [EOL] def test_set_direction ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_direction ( self . hass , _TEST_FAN , DIRECTION_FORWARD ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _DIRECTION_INPUT_SELECT ) . state == DIRECTION_FORWARD [EOL] self . _verify ( STATE_ON , None , None , DIRECTION_FORWARD ) [EOL] [EOL] [comment] [EOL] components . fan . set_direction ( self . hass , _TEST_FAN , DIRECTION_REVERSE ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _DIRECTION_INPUT_SELECT ) . state == DIRECTION_REVERSE [EOL] self . _verify ( STATE_ON , None , None , DIRECTION_REVERSE ) [EOL] [EOL] def test_set_invalid_direction_from_initial_stage ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_direction ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _DIRECTION_INPUT_SELECT ) . state == [string] [EOL] self . _verify ( STATE_ON , None , None , None ) [EOL] [EOL] def test_set_invalid_direction ( self ) : [EOL] [docstring] [EOL] self . _register_components ( ) [EOL] [EOL] [comment] [EOL] components . fan . turn_on ( self . hass , _TEST_FAN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] components . fan . set_direction ( self . hass , _TEST_FAN , DIRECTION_FORWARD ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _DIRECTION_INPUT_SELECT ) . state == DIRECTION_FORWARD [EOL] self . _verify ( STATE_ON , None , None , DIRECTION_FORWARD ) [EOL] [EOL] [comment] [EOL] components . fan . set_direction ( self . hass , _TEST_FAN , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] [comment] [EOL] assert self . hass . states . get ( _DIRECTION_INPUT_SELECT ) . state == DIRECTION_FORWARD [EOL] self . _verify ( STATE_ON , None , None , DIRECTION_FORWARD ) [EOL] [EOL] def _verify ( self , expected_state , expected_speed , expected_oscillating , expected_direction ) : [EOL] [docstring] [EOL] state = self . hass . states . get ( _TEST_FAN ) [EOL] attributes = state . attributes [EOL] assert state . state == expected_state [EOL] assert attributes . get ( ATTR_SPEED , None ) == expected_speed [EOL] assert attributes . get ( ATTR_OSCILLATING , None ) == expected_oscillating [EOL] assert attributes . get ( ATTR_DIRECTION , None ) == expected_direction [EOL] [EOL] def _register_components ( self , speed_list = None ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : None } } ) [EOL] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : { [string] : [string] , [string] : [ [string] , SPEED_LOW , SPEED_MEDIUM , SPEED_HIGH , [string] , [string] , [string] ] } , [string] : { [string] : [string] , [string] : [ [string] , [string] , [string] ] } , [string] : { [string] : [string] , [string] : [ [string] , DIRECTION_FORWARD , DIRECTION_REVERSE ] } , } } ) [EOL] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] value_template = [string] [EOL] [EOL] test_fan_config = { [string] : value_template , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : _STATE_INPUT_BOOLEAN } , [string] : { [string] : [string] , [string] : _STATE_INPUT_BOOLEAN } , [string] : { [string] : [string] , [string] : { [string] : _SPEED_INPUT_SELECT , [string] : [string] } } , [string] : { [string] : [string] , [string] : { [string] : _OSC_INPUT , [string] : [string] } } , [string] : { [string] : [string] , [string] : { [string] : _DIRECTION_INPUT_SELECT , [string] : [string] } } } [EOL] [EOL] if speed_list : [EOL] test_fan_config [ [string] ] = speed_list [EOL] [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : test_fan_config } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],builtins.str]],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import unittest [EOL] from unittest . mock import patch , MagicMock [EOL] [EOL] from homeassistant . setup import setup_component [EOL] import homeassistant . components . media_player as mp [EOL] from homeassistant . components . media_player import yamaha [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] def _create_zone_mock ( name , url ) : [EOL] zone = MagicMock ( ) [EOL] zone . ctrl_url = url [EOL] zone . zone = name [EOL] return zone [EOL] [EOL] [EOL] class FakeYamahaDevice ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , ctrl_url , name , zones = None ) : [EOL] [docstring] [EOL] self . ctrl_url = ctrl_url [EOL] self . name = name [EOL] self . zones = zones or [ ] [EOL] [EOL] def zone_controllers ( self ) : [EOL] [docstring] [EOL] return self . zones [EOL] [EOL] [EOL] class TestYamahaMediaPlayer ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . main_zone = _create_zone_mock ( [string] , [string] ) [EOL] self . device = FakeYamahaDevice ( [string] , [string] , zones = [ self . main_zone ] ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def enable_output ( self , port , enabled ) : [EOL] [docstring] [EOL] data = { [string] : [string] , [string] : port , [string] : enabled } [EOL] [EOL] self . hass . services . call ( yamaha . DOMAIN , yamaha . SERVICE_ENABLE_OUTPUT , data , True ) [EOL] [EOL] def create_receiver ( self , mock_rxv ) : [EOL] [docstring] [EOL] mock_rxv . return_value = self . device [EOL] [EOL] config = { [string] : { [string] : [string] , [string] : [string] } } [EOL] [EOL] self . assertTrue ( setup_component ( self . hass , mp . DOMAIN , config ) ) [EOL] [EOL] @ patch ( [string] ) def test_enable_output ( self , mock_rxv ) : [EOL] [docstring] [EOL] self . create_receiver ( mock_rxv ) [EOL] [EOL] self . enable_output ( [string] , True ) [EOL] self . main_zone . enable_output . assert_called_with ( [string] , True ) [EOL] [EOL] self . enable_output ( [string] , False ) [EOL] self . main_zone . enable_output . assert_called_with ( [string] , False ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $tests.components.media_player.test_yamaha.FakeYamahaDevice$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any , List , Union [EOL] import typing [EOL] [docstring] [EOL] import socket [EOL] import unittest [EOL] from unittest import mock [EOL] [EOL] import requests [EOL] from uvcclient import camera [EOL] from uvcclient import nvr [EOL] [EOL] from homeassistant . exceptions import PlatformNotReady [EOL] from homeassistant . setup import setup_component [EOL] from homeassistant . components . camera import uvc [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestUVCSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_full_config ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [number] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] [EOL] def mock_get_camera ( uuid ) : [EOL] [docstring] [EOL] if uuid == [string] : [EOL] return { [string] : [string] } [EOL] else : [EOL] return { [string] : [string] } [EOL] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . side_effect = mock_get_camera [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] self . assertEqual ( mock_remote . call_count , [number] ) [EOL] self . assertEqual ( mock_remote . call_args , mock . call ( [string] , [number] , [string] ) ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_partial_config ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . return_value = { [string] : [string] } [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] self . assertEqual ( mock_remote . call_count , [number] ) [EOL] self . assertEqual ( mock_remote . call_args , mock . call ( [string] , [number] , [string] ) ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch . object ( uvc , [string] ) def test_setup_partial_config_v31x ( self , mock_uvc , mock_remote ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_cameras = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] [EOL] mock_remote . return_value . index . return_value = mock_cameras [EOL] mock_remote . return_value . get_camera . return_value = { [string] : [string] } [EOL] mock_remote . return_value . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] [EOL] self . assertEqual ( mock_remote . call_count , [number] ) [EOL] self . assertEqual ( mock_remote . call_args , mock . call ( [string] , [number] , [string] ) ) [EOL] mock_uvc . assert_has_calls ( [ mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , mock . call ( mock_remote . return_value , [string] , [string] , [string] ) , ] ) [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) def test_setup_incomplete_config ( self , mock_uvc ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] assert setup_component ( self . hass , [string] , { [string] : [string] , [string] : [string] } ) [EOL] assert not mock_uvc . called [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) @ mock . patch ( [string] ) def setup_nvr_errors_during_indexing ( self , error , mock_remote , mock_uvc ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_remote . return_value . index . side_effect = error [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] assert not mock_uvc . called [EOL] [EOL] def test_setup_nvr_error_during_indexing_notauthorized ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( nvr . NotAuthorized ) [EOL] [EOL] def test_setup_nvr_error_during_indexing_nvrerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( nvr . NvrError ) [EOL] self . assertRaises ( PlatformNotReady ) [EOL] [EOL] def test_setup_nvr_error_during_indexing_connectionerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_indexing ( requests . exceptions . ConnectionError ) [EOL] self . assertRaises ( PlatformNotReady ) [EOL] [EOL] @ mock . patch . object ( uvc , [string] ) @ mock . patch ( [string] ) def setup_nvr_errors_during_initialization ( self , error , mock_remote , mock_uvc ) : [EOL] [docstring] [EOL] config = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] mock_remote . return_value = None [EOL] mock_remote . side_effect = error [EOL] assert setup_component ( self . hass , [string] , { [string] : config } ) [EOL] assert not mock_remote . index . called [EOL] assert not mock_uvc . called [EOL] [EOL] def test_setup_nvr_error_during_initialization_notauthorized ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( nvr . NotAuthorized ) [EOL] [EOL] def test_setup_nvr_error_during_initialization_nvrerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( nvr . NvrError ) [EOL] self . assertRaises ( PlatformNotReady ) [EOL] [EOL] def test_setup_nvr_error_during_initialization_connectionerror ( self ) : [EOL] [docstring] [EOL] self . setup_nvr_errors_during_initialization ( requests . exceptions . ConnectionError ) [EOL] self . assertRaises ( PlatformNotReady ) [EOL] [EOL] [EOL] class TestUVC ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . nvr = mock . MagicMock ( ) [EOL] self . uuid = [string] [EOL] self . name = [string] [EOL] self . password = [string] [EOL] self . uvc = uvc . UnifiVideoCamera ( self . nvr , self . uuid , self . name , self . password ) [EOL] self . nvr . get_camera . return_value = { [string] : [string] , [string] : { [string] : True , } , [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] self . nvr . server_version = ( [number] , [number] , [number] ) [EOL] [EOL] def test_properties ( self ) : [EOL] [docstring] [EOL] self . assertEqual ( self . name , self . uvc . name ) [EOL] self . assertTrue ( self . uvc . is_recording ) [EOL] self . assertEqual ( [string] , self . uvc . brand ) [EOL] self . assertEqual ( [string] , self . uvc . model ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] self . uvc . _login ( ) [EOL] self . assertEqual ( mock_camera . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . call_args , mock . call ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_args , mock . call ( ) ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_v31x ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] self . nvr . server_version = ( [number] , [number] , [number] ) [EOL] self . uvc . _login ( ) [EOL] self . assertEqual ( mock_camera . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . call_args , mock . call ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_args , mock . call ( ) ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_tries_both_addrs_and_caches ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] responses = [ [number] ] [EOL] [EOL] def mock_login ( * a ) : [EOL] [docstring] [EOL] try : [EOL] responses . pop ( [number] ) [EOL] raise socket . error [EOL] except IndexError : [EOL] pass [EOL] [EOL] mock_store . return_value . get_camera_password . return_value = None [EOL] mock_camera . return_value . login . side_effect = mock_login [EOL] self . uvc . _login ( ) [EOL] self . assertEqual ( [number] , mock_camera . call_count ) [EOL] self . assertEqual ( [string] , self . uvc . _connect_addr ) [EOL] [EOL] mock_camera . reset_mock ( ) [EOL] self . uvc . _login ( ) [EOL] self . assertEqual ( mock_camera . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . call_args , mock . call ( [string] , [string] , [string] ) ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_count , [number] ) [EOL] self . assertEqual ( mock_camera . return_value . login . call_args , mock . call ( ) ) [EOL] [EOL] @ mock . patch ( [string] ) @ mock . patch ( [string] ) def test_login_fails_both_properly ( self , mock_camera , mock_store ) : [EOL] [docstring] [EOL] mock_camera . return_value . login . side_effect = socket . error [EOL] self . assertEqual ( None , self . uvc . _login ( ) ) [EOL] self . assertEqual ( None , self . uvc . _connect_addr ) [EOL] [EOL] def test_camera_image_tries_login_bails_on_failure ( self ) : [EOL] [docstring] [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] mock_login . return_value = False [EOL] self . assertEqual ( None , self . uvc . camera_image ( ) ) [EOL] self . assertEqual ( mock_login . call_count , [number] ) [EOL] self . assertEqual ( mock_login . call_args , mock . call ( ) ) [EOL] [EOL] def test_camera_image_logged_in ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . assertEqual ( self . uvc . _camera . get_snapshot . return_value , self . uvc . camera_image ( ) ) [EOL] [EOL] def test_camera_image_error ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = camera . CameraConnectError [EOL] self . assertEqual ( None , self . uvc . camera_image ( ) ) [EOL] [EOL] def test_camera_image_reauths ( self ) : [EOL] [docstring] [EOL] responses = [ [number] ] [EOL] [EOL] def mock_snapshot ( ) : [EOL] [docstring] [EOL] try : [EOL] responses . pop ( ) [EOL] raise camera . CameraAuthError ( ) [EOL] except IndexError : [EOL] pass [EOL] return [string] [EOL] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = mock_snapshot [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] self . assertEqual ( [string] , self . uvc . camera_image ( ) ) [EOL] self . assertEqual ( mock_login . call_count , [number] ) [EOL] self . assertEqual ( mock_login . call_args , mock . call ( ) ) [EOL] self . assertEqual ( [ ] , responses ) [EOL] [EOL] def test_camera_image_reauths_only_once ( self ) : [EOL] [docstring] [EOL] self . uvc . _camera = mock . MagicMock ( ) [EOL] self . uvc . _camera . get_snapshot . side_effect = camera . CameraAuthError [EOL] with mock . patch . object ( self . uvc , [string] ) as mock_login : [EOL] self . assertRaises ( camera . CameraAuthError , self . uvc . camera_image ) [EOL] self . assertEqual ( mock_login . call_count , [number] ) [EOL] self . assertEqual ( mock_login . call_args , mock . call ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[builtins.int,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL] [EOL] from homeassistant . components import onboarding [EOL] [EOL] [EOL] def mock_storage ( hass_storage , data ) : [EOL] [docstring] [EOL] hass_storage [ onboarding . STORAGE_KEY ] = { [string] : onboarding . STORAGE_VERSION , [string] : data } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] import datetime [EOL] [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components . zwave import const [EOL] from homeassistant . components . binary_sensor import zwave [EOL] [EOL] from tests . mock . zwave import ( MockNode , MockValue , MockEntityValues , value_changed ) [EOL] [EOL] [EOL] def test_get_device_detects_none ( mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node ) [EOL] values = MockEntityValues ( primary = value ) [EOL] [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] assert device is None [EOL] [EOL] [EOL] def test_get_device_detects_trigger_sensor ( mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( manufacturer_id = [string] , product_type = [string] , product_id = [string] ) [EOL] value = MockValue ( data = False , node = node ) [EOL] values = MockEntityValues ( primary = value ) [EOL] [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZWaveTriggerSensor ) [EOL] assert device . device_class == [string] [EOL] [EOL] [EOL] def test_get_device_detects_workaround_sensor ( mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( manufacturer_id = [string] , product_type = [string] ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SENSOR_ALARM ) [EOL] values = MockEntityValues ( primary = value ) [EOL] [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZWaveBinarySensor ) [EOL] [EOL] [EOL] def test_get_device_detects_sensor ( mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SENSOR_BINARY ) [EOL] values = MockEntityValues ( primary = value ) [EOL] [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] assert isinstance ( device , zwave . ZWaveBinarySensor ) [EOL] [EOL] [EOL] def test_binary_sensor_value_changed ( mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( ) [EOL] value = MockValue ( data = False , node = node , command_class = const . COMMAND_CLASS_SENSOR_BINARY ) [EOL] values = MockEntityValues ( primary = value ) [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] [EOL] assert not device . is_on [EOL] [EOL] value . data = True [EOL] value_changed ( value ) [EOL] [EOL] assert device . is_on [EOL] [EOL] [EOL] @ asyncio . coroutine def test_trigger_sensor_value_changed ( hass , mock_openzwave ) : [EOL] [docstring] [EOL] node = MockNode ( manufacturer_id = [string] , product_type = [string] , product_id = [string] ) [EOL] value = MockValue ( data = False , node = node ) [EOL] value_off_delay = MockValue ( data = [number] , node = node ) [EOL] values = MockEntityValues ( primary = value , off_delay = value_off_delay ) [EOL] device = zwave . get_device ( node = node , values = values , node_config = { } ) [EOL] [EOL] assert not device . is_on [EOL] [EOL] value . data = True [EOL] yield from hass . async_add_job ( value_changed , value ) [EOL] assert device . invalidate_after is None [EOL] [EOL] device . hass = hass [EOL] [EOL] value . data = True [EOL] yield from hass . async_add_job ( value_changed , value ) [EOL] assert device . is_on [EOL] [EOL] test_time = device . invalidate_after - datetime . timedelta ( seconds = [number] ) [EOL] with patch ( [string] , return_value = test_time ) : [EOL] assert device . is_on [EOL] [EOL] test_time = device . invalidate_after [EOL] with patch ( [string] , return_value = test_time ) : [EOL] assert not device . is_on [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Dict , Type , Any [EOL] import tests [EOL] import typing [EOL] [docstring] [EOL] import json [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] import requests_mock [EOL] import pytest [EOL] import voluptuous as vol [EOL] [EOL] from homeassistant . components . binary_sensor import vultr [EOL] from homeassistant . components import vultr as base_vultr [EOL] from homeassistant . components . vultr import ( ATTR_ALLOWED_BANDWIDTH , ATTR_AUTO_BACKUPS , ATTR_IPV4_ADDRESS , ATTR_COST_PER_MONTH , ATTR_CREATED_AT , ATTR_SUBSCRIPTION_ID , CONF_SUBSCRIPTION ) [EOL] from homeassistant . const import ( CONF_PLATFORM , CONF_NAME ) [EOL] [EOL] from tests . components . test_vultr import VALID_CONFIG [EOL] from tests . common import ( get_test_home_assistant , load_fixture ) [EOL] [EOL] [EOL] class TestVultrBinarySensorSetup ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] DEVICES = [ ] [EOL] [EOL] def add_devices ( self , devices , action ) : [EOL] [docstring] [EOL] for device in devices : [EOL] self . DEVICES . append ( device ) [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . configs = [ { CONF_SUBSCRIPTION : [string] , CONF_NAME : [string] } , { CONF_SUBSCRIPTION : [string] , CONF_NAME : [string] } , { CONF_SUBSCRIPTION : [string] , CONF_NAME : vultr . DEFAULT_NAME } ] [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] @ requests_mock . Mocker ( ) def test_binary_sensor ( self , mock ) : [EOL] [docstring] [EOL] mock . get ( [string] , text = load_fixture ( [string] ) ) [EOL] [EOL] with patch ( [string] , return_value = json . loads ( load_fixture ( [string] ) ) ) : [EOL] [comment] [EOL] base_vultr . setup ( self . hass , VALID_CONFIG ) [EOL] [EOL] [comment] [EOL] for config in self . configs : [EOL] vultr . setup_platform ( self . hass , config , self . add_devices , None ) [EOL] [EOL] self . assertEqual ( len ( self . DEVICES ) , [number] ) [EOL] [EOL] for device in self . DEVICES : [EOL] [EOL] [comment] [EOL] if device . subscription == [string] : [EOL] self . assertEqual ( [string] , device . name ) [EOL] [EOL] device . update ( ) [EOL] device_attrs = device . device_state_attributes [EOL] [EOL] if device . subscription == [string] : [EOL] self . assertEqual ( [string] , device . name ) [EOL] [EOL] if device . name == [string] : [EOL] self . assertEqual ( True , device . is_on ) [EOL] self . assertEqual ( [string] , device . device_class ) [EOL] self . assertEqual ( [string] , device . state ) [EOL] self . assertEqual ( [string] , device . icon ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_ALLOWED_BANDWIDTH ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_AUTO_BACKUPS ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_IPV4_ADDRESS ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_COST_PER_MONTH ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_CREATED_AT ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_SUBSCRIPTION_ID ] ) [EOL] elif device . name == [string] : [EOL] self . assertEqual ( False , device . is_on ) [EOL] self . assertEqual ( [string] , device . state ) [EOL] self . assertEqual ( [string] , device . icon ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_ALLOWED_BANDWIDTH ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_AUTO_BACKUPS ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_IPV4_ADDRESS ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_COST_PER_MONTH ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_CREATED_AT ] ) [EOL] self . assertEqual ( [string] , device_attrs [ ATTR_SUBSCRIPTION_ID ] ) [EOL] [EOL] def test_invalid_sensor_config ( self ) : [EOL] [docstring] [EOL] with pytest . raises ( vol . Invalid ) : [comment] [EOL] vultr . PLATFORM_SCHEMA ( { CONF_PLATFORM : base_vultr . DOMAIN , } ) [EOL] [EOL] @ requests_mock . Mocker ( ) def test_invalid_sensors ( self , mock ) : [EOL] [docstring] [EOL] mock . get ( [string] , text = load_fixture ( [string] ) ) [EOL] [EOL] with patch ( [string] , return_value = json . loads ( load_fixture ( [string] ) ) ) : [EOL] [comment] [EOL] base_vultr . setup ( self . hass , VALID_CONFIG ) [EOL] [EOL] bad_conf = { } [comment] [EOL] [EOL] no_subs_setup = vultr . setup_platform ( self . hass , bad_conf , self . add_devices , None ) [EOL] [EOL] self . assertFalse ( no_subs_setup ) [EOL] [EOL] bad_conf = { CONF_NAME : [string] , CONF_SUBSCRIPTION : [string] } [comment] [EOL] [EOL] wrong_subs_setup = vultr . setup_platform ( self . hass , bad_conf , self . add_devices , None ) [EOL] [EOL] self . assertFalse ( wrong_subs_setup ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Dict[unknown,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from datetime import date [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components . binary_sensor . workday import day_to_string [EOL] from homeassistant . setup import setup_component [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] [EOL] [EOL] FUNCTION_PATH = [string] [EOL] [EOL] [EOL] class TestWorkdaySetup ( object ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] [comment] [EOL] self . config_province = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } [EOL] [EOL] self . config_noprovince = { [string] : { [string] : [string] , [string] : [string] , } , } [EOL] [EOL] self . config_invalidprovince = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } [EOL] [EOL] self . config_state = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , } [EOL] [EOL] self . config_nostate = { [string] : { [string] : [string] , [string] : [string] , } , } [EOL] [EOL] self . config_includeholiday = { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] ] , [string] : [ [string] , [string] ] } , } [EOL] [EOL] self . config_tomorrow = { [string] : { [string] : [string] , [string] : [string] , [string] : [number] } , } [EOL] [EOL] self . config_day_after_tomorrow = { [string] : { [string] : [string] , [string] : [string] , [string] : [number] } , } [EOL] [EOL] self . config_yesterday = { [string] : { [string] : [string] , [string] : [string] , [string] : - [number] } , } [EOL] [EOL] def teardown_method ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_setup_component_province ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_province ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity is not None [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_workday_province ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_province ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_weekend_province ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_province ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_public_holiday_province ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_province ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] def test_setup_component_noprovince ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_noprovince ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity is not None [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_public_holiday_noprovince ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_noprovince ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_public_holiday_state ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_state ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_public_holiday_nostate ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_nostate ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] def test_setup_component_invalidprovince ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_invalidprovince ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity is None [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_public_holiday_includeholiday ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_includeholiday ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_tomorrow ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_tomorrow ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_day_after_tomorrow ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_day_after_tomorrow ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] [comment] [EOL] @ patch ( FUNCTION_PATH , return_value = date ( [number] , [number] , [number] ) ) def test_yesterday ( self , mock_date ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] setup_component ( self . hass , [string] , self . config_yesterday ) [EOL] [EOL] self . hass . start ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] assert entity . state == [string] [EOL] [EOL] def test_day_to_string ( self ) : [EOL] [docstring] [EOL] assert day_to_string ( [number] ) == [string] [EOL] assert day_to_string ( [number] ) == [string] [EOL] assert day_to_string ( [number] ) == [string] [EOL] assert day_to_string ( [number] ) is None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Any [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import PropertyMock , patch [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . auth import models as auth_models [EOL] from homeassistant . components . config import auth as auth_config [EOL] [EOL] from tests . common import MockUser , CLIENT_ID [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def auth_active ( hass ) : [EOL] [docstring] [EOL] with patch ( [string] , PropertyMock ( return_value = True ) ) : [EOL] yield [EOL] [EOL] [EOL] @ pytest . fixture ( autouse = True ) def setup_config ( hass , aiohttp_client ) : [EOL] [docstring] [EOL] hass . loop . run_until_complete ( auth_config . async_setup ( hass ) ) [EOL] [EOL] [EOL] async def test_list_requires_owner ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_LIST , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert not result [ [string] ] , result [EOL] assert result [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_list ( hass , hass_ws_client ) : [EOL] [docstring] [EOL] owner = MockUser ( id = [string] , name = [string] , is_owner = True , ) . add_to_hass ( hass ) [EOL] [EOL] owner . credentials . append ( auth_models . Credentials ( auth_provider_type = [string] , auth_provider_id = None , data = { } , ) ) [EOL] [EOL] system = MockUser ( id = [string] , name = [string] , system_generated = True ) . add_to_hass ( hass ) [EOL] [EOL] inactive = MockUser ( id = [string] , name = [string] , is_active = False , ) . add_to_hass ( hass ) [EOL] [EOL] refresh_token = await hass . auth . async_create_refresh_token ( owner , CLIENT_ID ) [EOL] access_token = hass . auth . async_create_access_token ( refresh_token ) [EOL] [EOL] client = await hass_ws_client ( hass , access_token ) [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_LIST , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert result [ [string] ] , result [EOL] data = result [ [string] ] [EOL] assert len ( data ) == [number] [EOL] assert data [ [number] ] == { [string] : owner . id , [string] : [string] , [string] : True , [string] : True , [string] : False , [string] : [ { [string] : [string] } ] } [EOL] assert data [ [number] ] == { [string] : system . id , [string] : [string] , [string] : False , [string] : True , [string] : True , [string] : [ ] , } [EOL] assert data [ [number] ] == { [string] : inactive . id , [string] : [string] , [string] : False , [string] : False , [string] : False , [string] : [ ] , } [EOL] [EOL] [EOL] async def test_delete_requires_owner ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_DELETE , [string] : [string] , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert not result [ [string] ] , result [EOL] assert result [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_delete_unable_self_account ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_DELETE , [string] : hass_access_token . refresh_token . user . id , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert not result [ [string] ] , result [EOL] assert result [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_delete_unknown_user ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] hass_access_token . refresh_token . user . is_owner = True [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_DELETE , [string] : [string] , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert not result [ [string] ] , result [EOL] assert result [ [string] ] [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_delete ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] hass_access_token . refresh_token . user . is_owner = True [EOL] test_user = MockUser ( id = [string] , ) . add_to_hass ( hass ) [EOL] [EOL] assert len ( await hass . auth . async_get_users ( ) ) == [number] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_DELETE , [string] : test_user . id , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert result [ [string] ] , result [EOL] assert len ( await hass . auth . async_get_users ( ) ) == [number] [EOL] [EOL] [EOL] async def test_create ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] hass_access_token . refresh_token . user . is_owner = True [EOL] [EOL] assert len ( await hass . auth . async_get_users ( ) ) == [number] [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_CREATE , [string] : [string] , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert result [ [string] ] , result [EOL] assert len ( await hass . auth . async_get_users ( ) ) == [number] [EOL] data_user = result [ [string] ] [ [string] ] [EOL] user = await hass . auth . async_get_user ( data_user [ [string] ] ) [EOL] assert user is not None [EOL] assert user . name == data_user [ [string] ] [EOL] assert user . is_active [EOL] assert not user . is_owner [EOL] assert not user . system_generated [EOL] [EOL] [EOL] async def test_create_requires_owner ( hass , hass_ws_client , hass_access_token ) : [EOL] [docstring] [EOL] client = await hass_ws_client ( hass , hass_access_token ) [EOL] [EOL] await client . send_json ( { [string] : [number] , [string] : auth_config . WS_TYPE_CREATE , [string] : [string] , } ) [EOL] [EOL] result = await client . receive_json ( ) [EOL] assert not result [ [string] ] , result [EOL] assert result [ [string] ] [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , List , Union , Generator [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] from datetime import timedelta [EOL] import unittest [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . core import State , CoreState [EOL] from homeassistant . setup import setup_component , async_setup_component [EOL] import homeassistant . components . automation as automation [EOL] from homeassistant . const import ( ATTR_ENTITY_ID , STATE_ON , STATE_OFF , EVENT_HOMEASSISTANT_START ) [EOL] from homeassistant . exceptions import HomeAssistantError [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] from tests . common import ( assert_setup_component , get_test_home_assistant , fire_time_changed , mock_service , async_mock_service , mock_restore_cache ) [EOL] [EOL] [EOL] [comment] [EOL] class TestAutomation ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . calls = mock_service ( self . hass , [string] , [string] ) [EOL] [EOL] def tearDown ( self ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_service_data_not_a_dict ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , automation . DOMAIN ) : [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [number] , } } } ) [EOL] [EOL] def test_service_specify_data ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : [string] [string] } , } } } ) [EOL] [EOL] time = dt_util . utcnow ( ) [EOL] [EOL] with patch ( [string] , return_value = time ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data [ [string] ] == [string] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . attributes . get ( [string] ) == time [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . attributes . get ( [string] ) == ( [string] , ) [EOL] [EOL] def test_action_delay ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : [ { [string] : [string] , [string] : { [string] : [string] [string] } } , { [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] [string] } } , ] } } ) [EOL] [EOL] time = dt_util . utcnow ( ) [EOL] [EOL] with patch ( [string] , return_value = time ) : [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] future = dt_util . utcnow ( ) + timedelta ( minutes = [number] ) [EOL] fire_time_changed ( self . hass , future ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . attributes . get ( [string] ) == time [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state is not None [EOL] assert state . attributes . get ( [string] ) == ( [string] , ) [EOL] [EOL] def test_service_specify_entity_id ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . assertEqual ( [ [string] ] , self . calls [ [number] ] . data . get ( ATTR_ENTITY_ID ) ) [EOL] [EOL] def test_service_specify_entity_id_list ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . assertEqual ( [ [string] , [string] ] , self . calls [ [number] ] . data . get ( ATTR_ENTITY_ID ) ) [EOL] [EOL] def test_two_triggers ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [ { [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , } ] , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] self . hass . states . set ( [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_trigger_service_ignoring_condition ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : [ { [string] : [string] , [string] : [string] , } , ] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] self . hass . services . call ( [string] , [string] , { [string] : [string] } , blocking = True ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_two_conditions_with_and ( self ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [ { [string] : [string] , [string] : [string] , } , ] , [string] : [ { [string] : [string] , [string] : entity_id , [string] : [string] } , { [string] : [string] , [string] : entity_id , [string] : [number] } ] , [string] : { [string] : [string] , } } } ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . states . set ( entity_id , [number] ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_automation_list_setting ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : [ { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } , { [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } ] } ) ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] self . assertEqual ( [number] , len ( self . calls ) ) [EOL] [EOL] def test_automation_calling_two_actions ( self ) : [EOL] [docstring] [EOL] self . assertTrue ( setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : { [string] : [string] , [string] : [string] , } , [string] : [ { [string] : [string] , [string] : { [string] : [number] } , } , { [string] : [string] , [string] : { [string] : [number] } , } ] , } } ) ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data [ [string] ] == [number] [EOL] assert self . calls [ [number] ] . data [ [string] ] == [number] [EOL] [EOL] def test_services ( self ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] [EOL] assert self . hass . states . get ( entity_id ) is None [EOL] assert not automation . is_on ( self . hass , entity_id ) [EOL] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , } } } ) [EOL] [EOL] assert self . hass . states . get ( entity_id ) is not None [EOL] assert automation . is_on ( self . hass , entity_id ) [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] automation . turn_off ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert not automation . is_on ( self . hass , entity_id ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] automation . toggle ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert automation . is_on ( self . hass , entity_id ) [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] automation . trigger ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] automation . turn_off ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] automation . trigger ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] automation . turn_on ( self . hass , entity_id ) [EOL] self . hass . block_till_done ( ) [EOL] assert automation . is_on ( self . hass , entity_id ) [EOL] [EOL] def test_reload_config_service ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : [string] } } } } ) [EOL] assert self . hass . states . get ( [string] ) is not None [EOL] assert self . hass . states . get ( [string] ) is None [EOL] listeners = self . hass . bus . listeners [EOL] assert listeners . get ( [string] ) == [number] [EOL] assert listeners . get ( [string] ) is None [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data . get ( [string] ) == [string] [EOL] [EOL] with patch ( [string] , autospec = True , return_value = { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : [string] } } } } ) : [EOL] automation . reload ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [comment] [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . get ( [string] ) is None [EOL] assert self . hass . states . get ( [string] ) is not None [EOL] listeners = self . hass . bus . listeners [EOL] assert listeners . get ( [string] ) is None [EOL] assert listeners . get ( [string] ) == [number] [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data . get ( [string] ) == [string] [EOL] [EOL] def test_reload_config_when_invalid_config ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , automation . DOMAIN ) : [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : [string] } } } } ) [EOL] assert self . hass . states . get ( [string] ) is not None [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data . get ( [string] ) == [string] [EOL] [EOL] with patch ( [string] , autospec = True , return_value = { automation . DOMAIN : [string] } ) : [EOL] automation . reload ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . get ( [string] ) is None [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_reload_config_handles_load_fails ( self ) : [EOL] [docstring] [EOL] assert setup_component ( self . hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : { [string] : [string] } } } } ) [EOL] assert self . hass . states . get ( [string] ) is not None [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] assert self . calls [ [number] ] . data . get ( [string] ) == [string] [EOL] [EOL] with patch ( [string] , side_effect = HomeAssistantError ( [string] ) ) : [EOL] automation . reload ( self . hass ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . get ( [string] ) is not None [EOL] [EOL] self . hass . bus . fire ( [string] ) [EOL] self . hass . block_till_done ( ) [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_automation_restore_state ( hass ) : [EOL] [docstring] [EOL] time = dt_util . utcnow ( ) [EOL] [EOL] mock_restore_cache ( hass , ( State ( [string] , STATE_ON ) , State ( [string] , STATE_OFF , { [string] : time } ) , ) ) [EOL] [EOL] config = { automation . DOMAIN : [ { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } } , { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] } } ] } [EOL] [EOL] assert ( yield from async_setup_component ( hass , automation . DOMAIN , config ) ) [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == STATE_ON [EOL] [EOL] state = hass . states . get ( [string] ) [EOL] assert state [EOL] assert state . state == STATE_OFF [EOL] assert state . attributes . get ( [string] ) == time [EOL] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] [EOL] assert automation . is_on ( hass , [string] ) is False [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] assert automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_value_off ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert not automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_value_on ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [ [string] , [string] ] } } } ) [EOL] assert res [EOL] assert automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_value_off_but_restore_on ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] mock_restore_cache ( hass , ( State ( [string] , STATE_ON ) , ) ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert not automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_initial_value_on_but_restore_off ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] mock_restore_cache ( hass , ( State ( [string] , STATE_OFF ) , ) ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_no_initial_value_and_restore_off ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] mock_restore_cache ( hass , ( State ( [string] , STATE_OFF ) , ) ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert not automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_automation_is_on_if_no_initial_state_or_restore ( hass ) : [EOL] [docstring] [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_automation_not_trigger_on_bootstrap ( hass ) : [EOL] [docstring] [EOL] hass . state = CoreState . not_running [EOL] calls = async_mock_service ( hass , [string] , [string] ) [EOL] [EOL] res = yield from async_setup_component ( hass , automation . DOMAIN , { automation . DOMAIN : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } } } ) [EOL] assert res [EOL] assert not automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert len ( calls ) == [number] [EOL] [EOL] hass . bus . async_fire ( EVENT_HOMEASSISTANT_START ) [EOL] yield from hass . async_block_till_done ( ) [EOL] assert automation . is_on ( hass , [string] ) [EOL] [EOL] hass . bus . async_fire ( [string] ) [EOL] yield from hass . async_block_till_done ( ) [EOL] [EOL] assert len ( calls ) == [number] [EOL] assert [ [string] ] == calls [ [number] ] . data . get ( ATTR_ENTITY_ID ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , Tuple [EOL] import typing [EOL] import unittest [EOL] import datetime [EOL] [docstring] [EOL] from datetime import datetime , timedelta [EOL] from unittest . mock import patch , Mock [EOL] [EOL] import pytest [EOL] [EOL] from homeassistant . components . homekit . accessories import ( debounce , HomeAccessory , HomeBridge , HomeDriver ) [EOL] from homeassistant . components . homekit . const import ( BRIDGE_MODEL , BRIDGE_NAME , BRIDGE_SERIAL_NUMBER , CHAR_FIRMWARE_REVISION , CHAR_MANUFACTURER , CHAR_MODEL , CHAR_NAME , CHAR_SERIAL_NUMBER , MANUFACTURER , SERV_ACCESSORY_INFO ) [EOL] from homeassistant . const import ( __version__ , ATTR_BATTERY_CHARGING , ATTR_BATTERY_LEVEL , ATTR_NOW , EVENT_TIME_CHANGED ) [EOL] import homeassistant . util . dt as dt_util [EOL] [EOL] [EOL] async def test_debounce ( hass ) : [EOL] [docstring] [EOL] def demo_func ( * args ) : [EOL] nonlocal arguments , counter [EOL] counter += [number] [EOL] arguments = args [EOL] [EOL] arguments = None [EOL] counter = [number] [EOL] mock = Mock ( hass = hass , debounce = { } ) [EOL] [EOL] debounce_demo = debounce ( demo_func ) [EOL] assert debounce_demo . __name__ == [string] [EOL] now = datetime ( [number] , [number] , [number] , [number] , [number] , [number] , tzinfo = dt_util . UTC ) [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] await hass . async_add_job ( debounce_demo , mock , [string] ) [EOL] hass . bus . async_fire ( EVENT_TIME_CHANGED , { ATTR_NOW : now + timedelta ( seconds = [number] ) } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert counter == [number] [EOL] assert len ( arguments ) == [number] [EOL] [EOL] with patch ( [string] , return_value = now ) : [EOL] await hass . async_add_job ( debounce_demo , mock , [string] ) [EOL] await hass . async_add_job ( debounce_demo , mock , [string] ) [EOL] [EOL] hass . bus . async_fire ( EVENT_TIME_CHANGED , { ATTR_NOW : now + timedelta ( seconds = [number] ) } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert counter == [number] [EOL] [EOL] [EOL] async def test_home_accessory ( hass , hk_driver ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] hass . states . async_set ( entity_id , None ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] acc = HomeAccessory ( hass , hk_driver , [string] , entity_id , [number] , None ) [EOL] assert acc . hass == hass [EOL] assert acc . display_name == [string] [EOL] assert acc . aid == [number] [EOL] assert acc . category == [number] [comment] [EOL] assert len ( acc . services ) == [number] [EOL] serv = acc . services [ [number] ] [comment] [EOL] assert serv . display_name == SERV_ACCESSORY_INFO [EOL] assert serv . get_characteristic ( CHAR_NAME ) . value == [string] [EOL] assert serv . get_characteristic ( CHAR_MANUFACTURER ) . value == MANUFACTURER [EOL] assert serv . get_characteristic ( CHAR_MODEL ) . value == [string] [EOL] assert serv . get_characteristic ( CHAR_SERIAL_NUMBER ) . value == [string] [EOL] [EOL] hass . states . async_set ( entity_id , [string] ) [EOL] await hass . async_block_till_done ( ) [EOL] with patch ( [string] [string] ) as mock_update_state : [EOL] await hass . async_add_job ( acc . run ) [EOL] await hass . async_block_till_done ( ) [EOL] state = hass . states . get ( entity_id ) [EOL] mock_update_state . assert_called_with ( state ) [EOL] [EOL] hass . states . async_remove ( entity_id ) [EOL] await hass . async_block_till_done ( ) [EOL] assert mock_update_state . call_count == [number] [EOL] [EOL] with pytest . raises ( NotImplementedError ) : [EOL] acc . update_state ( [string] ) [EOL] [EOL] [comment] [EOL] entity_id = [string] [EOL] hass . states . async_set ( entity_id , None ) [EOL] await hass . async_block_till_done ( ) [EOL] acc = HomeAccessory ( hass , hk_driver , [string] , entity_id , [number] , None ) [EOL] serv = acc . services [ [number] ] [comment] [EOL] assert serv . get_characteristic ( CHAR_MODEL ) . value == [string] [EOL] [EOL] [EOL] async def test_battery_service ( hass , hk_driver ) : [EOL] [docstring] [EOL] entity_id = [string] [EOL] hass . states . async_set ( entity_id , None , { ATTR_BATTERY_LEVEL : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] acc = HomeAccessory ( hass , hk_driver , [string] , entity_id , [number] , None ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] await hass . async_add_job ( acc . run ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] hass . states . async_set ( entity_id , None , { ATTR_BATTERY_LEVEL : [number] } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] [comment] [EOL] hass . states . async_set ( entity_id , None , { ATTR_BATTERY_LEVEL : [number] , ATTR_BATTERY_CHARGING : True } ) [EOL] await hass . async_block_till_done ( ) [EOL] [EOL] acc = HomeAccessory ( hass , hk_driver , [string] , entity_id , [number] , None ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] await hass . async_add_job ( acc . run ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] hass . states . async_set ( entity_id , None , { ATTR_BATTERY_LEVEL : [number] , ATTR_BATTERY_CHARGING : False } ) [EOL] await hass . async_block_till_done ( ) [EOL] assert acc . _char_battery . value == [number] [EOL] assert acc . _char_low_battery . value == [number] [EOL] assert acc . _char_charging . value == [number] [EOL] [EOL] [EOL] def test_home_bridge ( hk_driver ) : [EOL] [docstring] [EOL] bridge = HomeBridge ( [string] , hk_driver , BRIDGE_NAME ) [EOL] assert bridge . hass == [string] [EOL] assert bridge . display_name == BRIDGE_NAME [EOL] assert bridge . category == [number] [comment] [EOL] assert len ( bridge . services ) == [number] [EOL] serv = bridge . services [ [number] ] [comment] [EOL] assert serv . display_name == SERV_ACCESSORY_INFO [EOL] assert serv . get_characteristic ( CHAR_NAME ) . value == BRIDGE_NAME [EOL] assert serv . get_characteristic ( CHAR_FIRMWARE_REVISION ) . value == __version__ [EOL] assert serv . get_characteristic ( CHAR_MANUFACTURER ) . value == MANUFACTURER [EOL] assert serv . get_characteristic ( CHAR_MODEL ) . value == BRIDGE_MODEL [EOL] assert serv . get_characteristic ( CHAR_SERIAL_NUMBER ) . value == BRIDGE_SERIAL_NUMBER [EOL] [EOL] bridge = HomeBridge ( [string] , hk_driver , [string] ) [EOL] assert bridge . display_name == [string] [EOL] assert len ( bridge . services ) == [number] [EOL] serv = bridge . services [ [number] ] [comment] [EOL] [EOL] [comment] [EOL] bridge . setup_message ( ) [EOL] [EOL] [EOL] def test_home_driver ( ) : [EOL] [docstring] [EOL] ip_address = [string] [EOL] port = [number] [EOL] path = [string] [EOL] pin = [string] [EOL] [EOL] with patch ( [string] ) as mock_driver : [EOL] driver = HomeDriver ( [string] , address = ip_address , port = port , persist_file = path ) [EOL] [EOL] mock_driver . assert_called_with ( address = ip_address , port = port , persist_file = path ) [EOL] driver . state = Mock ( pincode = pin ) [EOL] [EOL] [comment] [EOL] with patch ( [string] ) as mock_pair , patch ( [string] [string] ) as mock_dissmiss_msg : [EOL] driver . pair ( [string] , [string] ) [EOL] [EOL] mock_pair . assert_called_with ( [string] , [string] ) [EOL] mock_dissmiss_msg . assert_called_with ( [string] ) [EOL] [EOL] [comment] [EOL] with patch ( [string] ) as mock_unpair , patch ( [string] [string] ) as mock_show_msg : [EOL] driver . unpair ( [string] ) [EOL] [EOL] mock_unpair . assert_called_with ( [string] ) [EOL] mock_show_msg . assert_called_with ( [string] , pin ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] from unittest . mock import patch [EOL] [EOL] [EOL] def patch_debounce ( ) : [EOL] [docstring] [EOL] return patch ( [string] , lambda f : lambda * args , ** kwargs : f ( * args , ** kwargs ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Type , Any [EOL] import tests [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] [EOL] import logging [EOL] import unittest [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant import setup [EOL] import homeassistant . components . cover as cover [EOL] from homeassistant . const import STATE_OPEN , STATE_CLOSED [EOL] [EOL] from tests . common import ( get_test_home_assistant , assert_setup_component ) [EOL] _LOGGER = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class TestTemplateCover ( unittest . TestCase ) : [EOL] [docstring] [EOL] [EOL] hass = None [EOL] calls = None [EOL] [comment] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] self . calls = [ ] [EOL] [EOL] @ callback def record_call ( service ) : [EOL] [docstring] [EOL] self . calls . append ( service ) [EOL] [EOL] self . hass . services . register ( [string] , [string] , record_call ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_template_state_text ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_OPEN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OPEN [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_CLOSED ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_CLOSED [EOL] [EOL] def test_template_state_boolean ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OPEN [EOL] [EOL] def test_template_position ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_CLOSED ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] entity = self . hass . states . get ( [string] ) [EOL] attrs = dict ( ) [EOL] attrs [ [string] ] = [number] [EOL] self . hass . states . set ( entity . entity_id , entity . state , attributes = attrs ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] assert state . state == STATE_OPEN [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_OPEN ) [EOL] self . hass . block_till_done ( ) [EOL] entity = self . hass . states . get ( [string] ) [EOL] attrs [ [string] ] = [number] [EOL] self . hass . states . set ( entity . entity_id , entity . state , attributes = attrs ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] assert state . state == STATE_CLOSED [EOL] [EOL] def test_template_tilt ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] def test_template_out_of_bounds ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] [EOL] def test_template_mutex ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] [string] [string] } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_template_open_or_position ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_template_open_and_close ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } , } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert self . hass . states . all ( ) == [ ] [EOL] [EOL] def test_template_non_numeric ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : [string] [string] [string] [string] [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) is None [EOL] assert state . attributes . get ( [string] ) is None [EOL] [EOL] def test_open_action ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , [string] : [string] } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_CLOSED [EOL] [EOL] cover . open_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_close_stop_action ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OPEN [EOL] [EOL] cover . close_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] cover . stop_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_set_position ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : { [string] : [string] , [string] : [string] , [string] : [string] , } } } ) [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : { [string] : [string] } , } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . set ( [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OPEN [EOL] [EOL] cover . open_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] cover . close_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] cover . set_cover_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] def test_set_tilt_position ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] cover . set_cover_tilt_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_open_tilt_action ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] cover . open_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_close_tilt_action ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , } , } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] cover . close_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert len ( self . calls ) == [number] [EOL] [EOL] def test_set_position_optimistic ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : { [string] : [string] , } , } } } } ) [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) is None [EOL] [EOL] cover . set_cover_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] cover . close_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_CLOSED [EOL] [EOL] cover . open_cover ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . state == STATE_OPEN [EOL] [EOL] def test_set_tilt_position_optimistic ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , } , [string] : { [string] : [string] , } , } } } } ) [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) is None [EOL] [EOL] cover . set_cover_tilt_position ( self . hass , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] cover . close_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] cover . open_cover_tilt ( self . hass , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [number] [EOL] [EOL] def test_icon_template ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] [string] [string] } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_OPEN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert state . attributes [ [string] ] == [string] [EOL] [EOL] def test_entity_picture_template ( self ) : [EOL] [docstring] [EOL] with assert_setup_component ( [number] , [string] ) : [EOL] assert setup . setup_component ( self . hass , [string] , { [string] : { [string] : [string] , [string] : { [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : [string] [string] [string] } } } } ) [EOL] [EOL] self . hass . start ( ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] assert state . attributes . get ( [string] ) == [string] [EOL] [EOL] state = self . hass . states . set ( [string] , STATE_OPEN ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] state = self . hass . states . get ( [string] ) [EOL] [EOL] assert state . attributes [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
from typing import Generator , Any [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] import aiohttp [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_ping ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert ( yield from hassio_handler . is_connected ( ) ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_ping_error ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert not ( yield from hassio_handler . is_connected ( ) ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_ping_exeption ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , exc = aiohttp . ClientError ( ) ) [EOL] [EOL] assert not ( yield from hassio_handler . is_connected ( ) ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_homeassistant_info ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } } ) [EOL] [EOL] data = yield from hassio_handler . get_homeassistant_info ( ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert data [ [string] ] == [string] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_homeassistant_info_error ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . get ( [string] , json = { [string] : [string] , [string] : None } ) [EOL] [EOL] data = yield from hassio_handler . get_homeassistant_info ( ) [EOL] assert aioclient_mock . call_count == [number] [EOL] assert data is None [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_homeassistant_stop ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert ( yield from hassio_handler . stop_homeassistant ( ) ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_homeassistant_restart ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( [string] , json = { [string] : [string] } ) [EOL] [EOL] assert ( yield from hassio_handler . restart_homeassistant ( ) ) [EOL] assert aioclient_mock . call_count == [number] [EOL] [EOL] [EOL] @ asyncio . coroutine def test_api_homeassistant_config ( hassio_handler , aioclient_mock ) : [EOL] [docstring] [EOL] aioclient_mock . post ( [string] , json = { [string] : [string] , [string] : { [string] : [string] } } ) [EOL] [EOL] data = yield from hassio_handler . check_homeassistant_config ( ) [EOL] assert data [ [string] ] [ [string] ] == [string] [EOL] assert aioclient_mock . call_count == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] API_PASSWORD = [string] [EOL] HASSIO_TOKEN = [string] [EOL]	0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Dict , Any [EOL] import homeassistant [EOL] import typing [EOL] [docstring] [EOL] from unittest . mock import patch [EOL] [EOL] from homeassistant . components . homematicip_cloud import hap as hmipc [EOL] from homeassistant . components . homematicip_cloud import config_flow , const [EOL] [EOL] from tests . common import MockConfigEntry , mock_coro [EOL] [EOL] [EOL] async def test_flow_works ( hass ) : [EOL] [docstring] [EOL] config = { const . HMIPC_HAPID : [string] , const . HMIPC_PIN : [string] , const . HMIPC_NAME : [string] , } [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] hap = hmipc . HomematicipAuth ( hass , config ) [EOL] with patch . object ( hap , [string] , return_value = mock_coro ( ) ) , patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( True ) ) , patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( True ) ) : [EOL] hap . authtoken = [string] [EOL] result = await flow . async_step_init ( user_input = config ) [EOL] [EOL] assert hap . authtoken == [string] [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_init_connection_error ( hass ) : [EOL] [docstring] [EOL] config = { const . HMIPC_HAPID : [string] , const . HMIPC_PIN : [string] , const . HMIPC_NAME : [string] , } [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( False ) ) : [EOL] result = await flow . async_step_init ( user_input = config ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_link_connection_error ( hass ) : [EOL] [docstring] [EOL] config = { const . HMIPC_HAPID : [string] , const . HMIPC_PIN : [string] , const . HMIPC_NAME : [string] , } [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( True ) ) , patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( True ) ) , patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( False ) ) : [EOL] result = await flow . async_step_init ( user_input = config ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_flow_link_press_button ( hass ) : [EOL] [docstring] [EOL] config = { const . HMIPC_HAPID : [string] , const . HMIPC_PIN : [string] , const . HMIPC_NAME : [string] , } [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] with patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( True ) ) , patch . object ( hmipc . HomematicipAuth , [string] , return_value = mock_coro ( False ) ) : [EOL] result = await flow . async_step_init ( user_input = config ) [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { [string] : [string] } [EOL] [EOL] [EOL] async def test_init_flow_show_form ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( user_input = None ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_init_already_configured ( hass ) : [EOL] [docstring] [EOL] MockConfigEntry ( domain = const . DOMAIN , data = { const . HMIPC_HAPID : [string] , } ) . add_to_hass ( hass ) [EOL] config = { const . HMIPC_HAPID : [string] , const . HMIPC_PIN : [string] , const . HMIPC_NAME : [string] , } [EOL] [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_init ( user_input = config ) [EOL] assert result [ [string] ] == [string] [EOL] [EOL] [EOL] async def test_import_config ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] result = await flow . async_step_import ( { hmipc . HMIPC_HAPID : [string] , hmipc . HMIPC_AUTHTOKEN : [string] , hmipc . HMIPC_NAME : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == [string] [EOL] assert result [ [string] ] == { hmipc . HMIPC_HAPID : [string] , hmipc . HMIPC_AUTHTOKEN : [string] , hmipc . HMIPC_NAME : [string] } [EOL] [EOL] [EOL] async def test_import_existing_config ( hass ) : [EOL] [docstring] [EOL] flow = config_flow . HomematicipCloudFlowHandler ( ) [EOL] flow . hass = hass [EOL] [EOL] MockConfigEntry ( domain = const . DOMAIN , data = { hmipc . HMIPC_HAPID : [string] , } ) . add_to_hass ( hass ) [EOL] [EOL] result = await flow . async_step_import ( { hmipc . HMIPC_HAPID : [string] , hmipc . HMIPC_AUTHTOKEN : [string] , hmipc . HMIPC_NAME : [string] } ) [EOL] [EOL] assert result [ [string] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
[docstring] [EOL]	0 0
from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] import asyncio [EOL] [EOL] from homeassistant . core import callback [EOL] from homeassistant . helpers . dispatcher import ( dispatcher_send , dispatcher_connect ) [EOL] [EOL] from tests . common import get_test_home_assistant [EOL] [EOL] [EOL] class TestHelpersDispatcher ( object ) : [EOL] [docstring] [EOL] [EOL] def setup_method ( self , method ) : [EOL] [docstring] [EOL] self . hass = get_test_home_assistant ( ) [EOL] [EOL] def teardown_method ( self , method ) : [EOL] [docstring] [EOL] self . hass . stop ( ) [EOL] [EOL] def test_simple_function ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_function_unsub ( self ) : [EOL] [docstring] [EOL] calls1 = [ ] [EOL] calls2 = [ ] [EOL] [EOL] def test_funct1 ( data ) : [EOL] [docstring] [EOL] calls1 . append ( data ) [EOL] [EOL] def test_funct2 ( data ) : [EOL] [docstring] [EOL] calls2 . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct1 ) [EOL] unsub = dispatcher_connect ( self . hass , [string] , test_funct2 ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] unsub ( ) [EOL] [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] , [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] [comment] [EOL] unsub ( ) [EOL] [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls1 == [ [number] , [number] , [number] ] [EOL] assert calls2 == [ [number] ] [EOL] [EOL] def test_simple_callback ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] @ callback def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_coro ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] @ asyncio . coroutine def test_funct ( data ) : [EOL] [docstring] [EOL] calls . append ( data ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] ] [EOL] [EOL] dispatcher_send ( self . hass , [string] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [string] ] [EOL] [EOL] def test_simple_function_multiargs ( self ) : [EOL] [docstring] [EOL] calls = [ ] [EOL] [EOL] def test_funct ( data1 , data2 , data3 ) : [EOL] [docstring] [EOL] calls . append ( data1 ) [EOL] calls . append ( data2 ) [EOL] calls . append ( data3 ) [EOL] [EOL] dispatcher_connect ( self . hass , [string] , test_funct ) [EOL] dispatcher_send ( self . hass , [string] , [number] , [number] , [string] ) [EOL] self . hass . block_till_done ( ) [EOL] [EOL] assert calls == [ [number] , [number] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0