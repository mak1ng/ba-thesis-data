from typing import Any , Union , List , Dict [EOL] import typing [EOL] import pathlib [EOL] import pathlib [EOL] import re [EOL] import sys [EOL] [EOL] from setuptools import setup [EOL] [EOL] if sys . version_info < ( [number] , [number] ) : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] [EOL] here = pathlib . Path ( __file__ ) . parent [EOL] [EOL] [EOL] txt = ( here / [string] / [string] ) . read_text ( [string] ) [EOL] try : [EOL] version = re . findall ( [string] , txt , re . M ) [ [number] ] [EOL] except IndexError : [EOL] raise RuntimeError ( [string] ) [EOL] [EOL] install_requires = [ [string] , ] [EOL] [EOL] [EOL] def read ( f ) : [EOL] return ( here / f ) . read_text ( [string] ) . strip ( ) [EOL] [EOL] [EOL] args = dict ( name = [string] , version = version , description = [string] , long_description = [string] . join ( ( read ( [string] ) , read ( [string] ) ) ) , long_description_content_type = [string] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , author = [string] , author_email = [string] , maintainer = [string] , maintainer_email = [string] , url = [string] , project_urls = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , license = [string] , packages = [ [string] ] , python_requires = [string] , install_requires = install_requires , include_package_data = True , ) [EOL] [EOL] setup ( ** args ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,builtins.str],typing.List[builtins.str],builtins.bool,builtins.str]]$ 0 0
from typing import Any , Set , Dict [EOL] import unittest [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from unittest import mock [EOL] [EOL] import pytest [EOL] [EOL] from aiosignal import Signal [EOL] [EOL] [EOL] class Owner : [EOL] def __repr__ ( self ) : [EOL] return [string] [EOL] [EOL] [EOL] @ pytest . fixture def owner ( ) : [EOL] return Owner ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_add_signal_handler_not_a_callable ( owner ) : [EOL] callback = True [EOL] signal = Signal ( owner ) [EOL] signal . append ( callback ) [EOL] signal . freeze ( ) [EOL] with pytest . raises ( TypeError ) : [EOL] await signal . send ( ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_function_signal_dispatch_kwargs ( owner ) : [EOL] signal = Signal ( owner ) [EOL] kwargs = { [string] : [number] , [string] : [number] } [EOL] [EOL] callback_mock = mock . Mock ( ) [EOL] [EOL] async def callback ( ** kwargs ) : [EOL] callback_mock ( ** kwargs ) [EOL] [EOL] signal . append ( callback ) [EOL] signal . freeze ( ) [EOL] [EOL] await signal . send ( ** kwargs ) [EOL] callback_mock . assert_called_once_with ( ** kwargs ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_function_signal_dispatch_args_kwargs ( owner ) : [EOL] signal = Signal ( owner ) [EOL] args = { [string] , [string] } [EOL] kwargs = { [string] : [number] , [string] : [number] } [EOL] [EOL] callback_mock = mock . Mock ( ) [EOL] [EOL] async def callback ( * args , ** kwargs ) : [EOL] callback_mock ( * args , ** kwargs ) [EOL] [EOL] signal . append ( callback ) [EOL] signal . freeze ( ) [EOL] [EOL] await signal . send ( * args , ** kwargs ) [EOL] callback_mock . assert_called_once_with ( * args , ** kwargs ) [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_non_coroutine ( owner ) : [EOL] signal = Signal ( owner ) [EOL] kwargs = { [string] : [number] , [string] : [number] } [EOL] [EOL] callback = mock . Mock ( ) [EOL] [EOL] signal . append ( callback ) [EOL] signal . freeze ( ) [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] await signal . send ( ** kwargs ) [EOL] [EOL] [EOL] def test_setitem ( owner ) : [EOL] signal = Signal ( owner ) [EOL] m1 = mock . Mock ( ) [EOL] signal . append ( m1 ) [EOL] assert signal [ [number] ] is m1 [EOL] m2 = mock . Mock ( ) [EOL] signal [ [number] ] = m2 [EOL] assert signal [ [number] ] is m2 [EOL] [EOL] [EOL] def test_delitem ( owner ) : [EOL] signal = Signal ( owner ) [EOL] m1 = mock . Mock ( ) [EOL] signal . append ( m1 ) [EOL] assert len ( signal ) == [number] [EOL] del signal [ [number] ] [EOL] assert len ( signal ) == [number] [EOL] [EOL] [EOL] def test_cannot_append_to_frozen_signal ( owner ) : [EOL] signal = Signal ( owner ) [EOL] m1 = mock . Mock ( ) [EOL] m2 = mock . Mock ( ) [EOL] signal . append ( m1 ) [EOL] signal . freeze ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] signal . append ( m2 ) [EOL] [EOL] assert list ( signal ) == [ m1 ] [EOL] [EOL] [EOL] def test_cannot_setitem_in_frozen_signal ( owner ) : [EOL] signal = Signal ( owner ) [EOL] m1 = mock . Mock ( ) [EOL] m2 = mock . Mock ( ) [EOL] signal . append ( m1 ) [EOL] signal . freeze ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] signal [ [number] ] = m2 [EOL] [EOL] assert list ( signal ) == [ m1 ] [EOL] [EOL] [EOL] def test_cannot_delitem_in_frozen_signal ( owner ) : [EOL] signal = Signal ( owner ) [EOL] m1 = mock . Mock ( ) [EOL] signal . append ( m1 ) [EOL] signal . freeze ( ) [EOL] with pytest . raises ( RuntimeError ) : [EOL] del signal [ [number] ] [EOL] [EOL] assert list ( signal ) == [ m1 ] [EOL] [EOL] [EOL] @ pytest . mark . asyncio async def test_cannot_send_non_frozen_signal ( owner ) : [EOL] signal = Signal ( owner ) [EOL] [EOL] callback_mock = mock . Mock ( ) [EOL] [EOL] async def callback ( ** kwargs ) : [EOL] callback_mock ( ** kwargs ) [EOL] [EOL] signal . append ( callback ) [EOL] [EOL] with pytest . raises ( RuntimeError ) : [EOL] await signal . send ( ) [EOL] [EOL] assert not callback_mock . called [EOL] [EOL] [EOL] def test_repr ( owner ) : [EOL] signal = Signal ( owner ) [EOL] [EOL] signal . append ( mock . Mock ( __repr__ = lambda * a : [string] ) ) [EOL] [EOL] assert re . match ( [string] [string] , repr ( signal ) ) is not None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Owner$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import pathlib [EOL] import sys [EOL] from pathlib import Path [EOL] [EOL] [EOL] ALLOWED_SUFFIXES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def get_root ( script_path ) : [EOL] folder = script_path . resolve ( ) . parent [EOL] while not ( folder / [string] ) . exists ( ) : [EOL] folder = folder . parent [EOL] if folder == folder . anchor : [EOL] raise RuntimeError ( [string] ) [EOL] return folder [EOL] [EOL] [EOL] def main ( argv ) : [EOL] print ( [string] , end = [string] , flush = True ) [EOL] here = Path ( argv [ [number] ] ) [EOL] root = get_root ( here ) [EOL] changes = root / [string] [EOL] failed = False [EOL] for fname in changes . iterdir ( ) : [EOL] if fname . name in ( [string] , [string] ) : [EOL] continue [EOL] if fname . suffix not in ALLOWED_SUFFIXES : [EOL] if not failed : [EOL] print ( [string] ) [EOL] print ( fname , [string] , file = sys . stderr ) [EOL] failed = True [EOL] [EOL] if failed : [EOL] print ( [string] , file = sys . stderr ) [EOL] print ( [string] , ALLOWED_SUFFIXES , file = sys . stderr ) [EOL] print ( [string] , file = sys . stderr ) [EOL] else : [EOL] print ( [string] ) [EOL] [EOL] return int ( failed ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] sys . exit ( main ( sys . argv ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0