from typing import Type , List , Union , Literal , Callable , Any , Optional , Iterator [EOL] import types [EOL] import typing_extensions [EOL] import typing [EOL] import logging [EOL] import builtins [EOL] import os [EOL] import sys [EOL] import logging [EOL] from typing import Optional , List [EOL] from datetime import datetime [EOL] [EOL] from pythonjsonlogger import jsonlogger [EOL] [EOL] from . import dirs [EOL] from . decorators import deprecated [EOL] [EOL] [comment] [EOL] [comment] [EOL] log_file_path = None [EOL] [EOL] [EOL] @ deprecated def get_log_file_path ( ) : [comment] [EOL] [docstring] [EOL] return log_file_path [EOL] [EOL] [EOL] def setup_logging ( name , testing = False , verbose = False , log_stderr = True , log_file = False , log_file_json = False , ) : [comment] [EOL] root_logger = logging . getLogger ( ) [EOL] root_logger . setLevel ( logging . DEBUG if verbose else logging . INFO ) [EOL] root_logger . handlers = [ ] [EOL] [EOL] if log_stderr : [EOL] root_logger . addHandler ( _create_stderr_handler ( ) ) [EOL] if log_file : [EOL] root_logger . addHandler ( _create_file_handler ( name , testing = testing , log_json = log_file_json ) ) [EOL] [EOL] def excepthook ( type_ , value , traceback ) : [EOL] root_logger . exception ( [string] , exc_info = ( type_ , value , traceback ) ) [EOL] [comment] [EOL] if not log_stderr : [EOL] sys . __excepthook__ ( type_ , value , traceback ) [EOL] [EOL] sys . excepthook = excepthook [EOL] [EOL] [EOL] def _get_latest_log_files ( name , testing = False ) : [comment] [EOL] [docstring] [EOL] log_dir = dirs . get_log_dir ( name ) [EOL] files = filter ( lambda filename : name in filename , os . listdir ( log_dir ) ) [EOL] files = filter ( lambda filename : [string] in filename [EOL] if testing [EOL] else [string] not in filename , files , ) [EOL] return [ os . path . join ( log_dir , filename ) for filename in sorted ( files , reverse = True ) ] [EOL] [EOL] [EOL] def get_latest_log_file ( name , testing = False ) : [comment] [EOL] [docstring] [EOL] last_logs = _get_latest_log_files ( name , testing = testing ) [EOL] return last_logs [ [number] ] if last_logs else None [EOL] [EOL] [EOL] def _create_stderr_handler ( ) : [comment] [EOL] stderr_handler = logging . StreamHandler ( stream = sys . stderr ) [EOL] stderr_handler . setFormatter ( _create_human_formatter ( ) ) [EOL] [EOL] return stderr_handler [EOL] [EOL] [EOL] def _create_file_handler ( name , testing = False , log_json = False ) : [comment] [EOL] log_dir = dirs . get_log_dir ( name ) [EOL] [EOL] [comment] [EOL] global log_file_path [EOL] [EOL] [comment] [EOL] [comment] [EOL] file_ext = [string] if log_json else [string] [EOL] now_str = str ( datetime . now ( ) . replace ( microsecond = [number] ) . isoformat ( ) ) . replace ( [string] , [string] ) [EOL] log_name = name + [string] + ( [string] if testing else [string] ) + now_str + file_ext [EOL] log_file_path = os . path . join ( log_dir , log_name ) [EOL] [EOL] fh = logging . FileHandler ( log_file_path , mode = [string] ) [EOL] if log_json : [EOL] fh . setFormatter ( _create_json_formatter ( ) ) [EOL] else : [EOL] fh . setFormatter ( _create_human_formatter ( ) ) [EOL] [EOL] return fh [EOL] [EOL] [EOL] def _create_human_formatter ( ) : [comment] [EOL] return logging . Formatter ( [string] , [string] , ) [EOL] [EOL] [EOL] def _create_json_formatter ( ) : [comment] [EOL] supported_keys = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] [EOL] def log_format ( x ) : [EOL] [docstring] [EOL] return [ [string] . format ( i ) for i in x ] [EOL] [EOL] custom_format = [string] . join ( log_format ( supported_keys ) ) [EOL] [EOL] return jsonlogger . JsonFormatter ( custom_format ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Handler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Formatter$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import json [EOL] [EOL] [EOL] def _this_dir ( ) : [EOL] return os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] [EOL] [EOL] def _schema_dir ( ) : [EOL] return os . path . join ( os . path . dirname ( _this_dir ( ) ) , [string] , [string] ) [EOL] [EOL] [EOL] def get_json_schema ( name ) : [EOL] with open ( os . path . join ( _schema_dir ( ) , name + [string] ) ) as f : [EOL] data = json . load ( f ) [EOL] return data [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] print ( get_json_schema ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import logging [EOL] import os [EOL] import logging [EOL] from configparser import ConfigParser [EOL] [EOL] from aw_core import dirs [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def load_config ( appname , default_config ) : [EOL] [docstring] [EOL] config = default_config [EOL] [EOL] config_dir = dirs . get_config_dir ( appname ) [EOL] config_file_path = os . path . join ( config_dir , [string] . format ( appname ) ) [EOL] [EOL] [comment] [EOL] if os . path . isfile ( config_file_path ) : [EOL] with open ( config_file_path , [string] ) as f : [EOL] config . read_file ( f ) [EOL] [EOL] [comment] [EOL] save_config ( appname , config ) [EOL] [EOL] return config [EOL] [EOL] [EOL] def save_config ( appname , config ) : [EOL] config_dir = dirs . get_config_dir ( appname ) [EOL] config_file_path = os . path . join ( config_dir , [string] . format ( appname ) ) [EOL] with open ( config_file_path , [string] ) as f : [EOL] config . write ( f ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import warnings [EOL] import functools [EOL] import logging [EOL] import time [EOL] [EOL] [EOL] def deprecated ( f ) : [comment] [EOL] [docstring] [EOL] [comment] [EOL] warned_for = False [EOL] [EOL] @ functools . wraps ( f ) def g ( * args , ** kwargs ) : [EOL] [comment] [EOL] nonlocal warned_for [EOL] if not warned_for : [EOL] warnings . simplefilter ( [string] , DeprecationWarning ) [comment] [EOL] warnings . warn ( [string] . format ( f . __name__ ) , category = DeprecationWarning , stacklevel = [number] , ) [EOL] warnings . simplefilter ( [string] , DeprecationWarning ) [comment] [EOL] warned_for = True [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return g [EOL] [EOL] [EOL] def restart_on_exception ( f , delay = [number] , exception = Exception ) : [comment] [EOL] @ functools . wraps ( f ) def g ( * args , ** kwargs ) : [EOL] while True : [EOL] try : [EOL] f ( * args , ** kwargs ) [EOL] except exception as e : [EOL] [comment] [EOL] logging . error ( [string] . format ( f . __name__ ) ) [EOL] logging . error ( e ) [EOL] time . sleep ( delay ) [comment] [EOL] [EOL] return g [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , Optional , Callable , Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] from functools import wraps [EOL] from typing import Optional , Callable [EOL] [EOL] import appdirs [EOL] [EOL] GetDirFunc = Callable [ [ Optional [ str ] ] , str ] [EOL] [EOL] [EOL] def ensure_path_exists ( path ) : [EOL] if not os . path . exists ( path ) : [EOL] os . makedirs ( path ) [EOL] [EOL] [EOL] def _ensure_returned_path_exists ( f ) : [EOL] @ wraps ( f ) def wrapper ( subpath ) : [EOL] path = f ( subpath ) [EOL] ensure_path_exists ( path ) [EOL] return path [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ _ensure_returned_path_exists def get_data_dir ( module_name ) : [EOL] data_dir = appdirs . user_data_dir ( [string] ) [EOL] return os . path . join ( data_dir , module_name ) if module_name else data_dir [EOL] [EOL] [EOL] @ _ensure_returned_path_exists def get_cache_dir ( module_name ) : [EOL] cache_dir = appdirs . user_cache_dir ( [string] ) [EOL] return os . path . join ( cache_dir , module_name ) if module_name else cache_dir [EOL] [EOL] [EOL] @ _ensure_returned_path_exists def get_config_dir ( module_name ) : [EOL] config_dir = appdirs . user_config_dir ( [string] ) [EOL] return os . path . join ( config_dir , module_name ) if module_name else config_dir [EOL] [EOL] [EOL] @ _ensure_returned_path_exists def get_log_dir ( module_name ) : [comment] [EOL] log_dir = appdirs . user_log_dir ( [string] ) [EOL] return os . path . join ( log_dir , module_name ) if module_name else log_dir [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $GetDirFunc$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import sys [EOL] from typing import Tuple [EOL] import logging [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class VersionException ( Exception ) : [EOL] ... [EOL] [EOL] [EOL] def _version_info_tuple ( ) : [comment] [EOL] return ( sys . version_info . major , sys . version_info . minor , sys . version_info . micro ) [EOL] [EOL] [EOL] def assert_version ( required_version = ( [number] , [number] ) ) : [comment] [EOL] actual_version = _version_info_tuple ( ) [EOL] if actual_version <= required_version : [EOL] raise VersionException ( ( [string] + [string] ) . format ( required_version ) ) [EOL] logger . debug ( [string] . format ( _version_info_tuple ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.int,builtins.int,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Tuple , List , Any [EOL] import typing [EOL] import aw_core [EOL] import logging [EOL] import logging [EOL] from typing import List , Dict , Tuple [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def merge_events_by_keys ( events , keys ) : [EOL] [comment] [EOL] [comment] [EOL] if len ( keys ) < [number] : [EOL] return events [EOL] merged_events = { } [EOL] for event in events : [EOL] composite_key = ( ) [EOL] for key in keys : [EOL] if key in event . data : [EOL] val = event [ [string] ] [ key ] [EOL] [comment] [EOL] if isinstance ( val , list ) : [EOL] val = tuple ( val ) [EOL] composite_key = composite_key + ( val , ) [EOL] if composite_key not in merged_events : [EOL] merged_events [ composite_key ] = Event ( timestamp = event . timestamp , duration = event . duration , data = { } ) [EOL] for key in keys : [EOL] if key in event . data : [EOL] merged_events [ composite_key ] . data [ key ] = event . data [ key ] [EOL] else : [EOL] merged_events [ composite_key ] . duration += event . duration [EOL] result = [ ] [EOL] for key in merged_events : [EOL] result . append ( Event ( ** merged_events [ key ] ) ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] from typing import Union , List , Iterable , Any , Tuple , Optional [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] import aw_core [EOL] import logging [EOL] from typing import List , Iterable , Tuple [EOL] from copy import deepcopy [EOL] [EOL] from aw_core import Event [EOL] from aw_core import TimePeriod [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def _get_event_period ( event ) : [EOL] start = event . timestamp [EOL] end = start + event . duration [EOL] return TimePeriod ( start , end ) [EOL] [EOL] [EOL] def _replace_event_period ( event , period ) : [EOL] e = deepcopy ( event ) [EOL] e . timestamp = period . start [EOL] e . duration = period . duration [EOL] return e [EOL] [EOL] [EOL] def _intersecting_eventpairs ( events1 , events2 ) : [EOL] [docstring] [EOL] events1 . sort ( key = lambda e : e . timestamp ) [EOL] events2 . sort ( key = lambda e : e . timestamp ) [EOL] e1_i = [number] [EOL] e2_i = [number] [EOL] while e1_i < len ( events1 ) and e2_i < len ( events2 ) : [EOL] e1 = events1 [ e1_i ] [EOL] e2 = events2 [ e2_i ] [EOL] e1_p = _get_event_period ( e1 ) [EOL] e2_p = _get_event_period ( e2 ) [EOL] [EOL] ip = e1_p . intersection ( e2_p ) [EOL] if ip : [EOL] [comment] [EOL] yield ( e1 , e2 , ip ) [EOL] if e1_p . end <= e2_p . end : [EOL] e1_i += [number] [EOL] else : [EOL] e2_i += [number] [EOL] else : [EOL] [comment] [EOL] if e1_p . end <= e2_p . start : [EOL] [comment] [EOL] e1_i += [number] [EOL] elif e2_p . end <= e1_p . start : [EOL] [comment] [EOL] e2_i += [number] [EOL] else : [EOL] logger . error ( [string] ) [EOL] e1_i += [number] [EOL] e2_i += [number] [EOL] [EOL] [EOL] def filter_period_intersect ( events , filterevents ) : [EOL] [docstring] [EOL] [EOL] events = sorted ( events ) [EOL] filterevents = sorted ( filterevents ) [EOL] [EOL] return [ _replace_event_period ( e1 , ip ) for ( e1 , _ , ip ) in _intersecting_eventpairs ( events , filterevents ) ] [EOL] [EOL] [EOL] def period_union ( events1 , events2 ) : [EOL] [docstring] [EOL] events = sorted ( events1 + events2 ) [EOL] merged_events = [ ] [EOL] if events : [EOL] merged_events . append ( events . pop ( [number] ) ) [EOL] for e in events : [EOL] last_event = merged_events [ - [number] ] [EOL] [EOL] e_p = _get_event_period ( e ) [EOL] le_p = _get_event_period ( last_event ) [EOL] [EOL] if not e_p . gap ( le_p ) : [EOL] new_period = e_p . union ( le_p ) [EOL] merged_events [ - [number] ] = _replace_event_period ( last_event , new_period ) [EOL] else : [EOL] merged_events . append ( e ) [EOL] for event in merged_events : [EOL] [comment] [EOL] event . data = { } [EOL] return merged_events [EOL] [EOL] [EOL] def union ( events1 , events2 ) : [EOL] [docstring] [EOL] [EOL] events1 = sorted ( events1 , key = lambda e : ( e . timestamp , e . duration ) ) [EOL] events2 = sorted ( events2 , key = lambda e : ( e . timestamp , e . duration ) ) [EOL] events_union = [ ] [EOL] [EOL] e1_i = [number] [EOL] e2_i = [number] [EOL] while e1_i < len ( events1 ) and e2_i < len ( events2 ) : [EOL] e1 = events1 [ e1_i ] [EOL] e2 = events2 [ e2_i ] [EOL] [EOL] if e1 == e2 : [EOL] events_union . append ( e1 ) [EOL] e1_i += [number] [EOL] e2_i += [number] [EOL] else : [EOL] if e1 . timestamp < e2 . timestamp : [EOL] events_union . append ( e1 ) [EOL] e1_i += [number] [EOL] elif e1 . timestamp > e2 . timestamp : [EOL] events_union . append ( e2 ) [EOL] e2_i += [number] [EOL] elif e1 . duration < e2 . duration : [EOL] events_union . append ( e1 ) [EOL] e1_i += [number] [EOL] else : [EOL] events_union . append ( e2 ) [EOL] e2_i += [number] [EOL] [EOL] if e1_i < len ( events1 ) : [EOL] events_union . extend ( events1 [ e1_i : ] ) [EOL] [EOL] if e2_i < len ( events2 ) : [EOL] events_union . extend ( events2 [ e2_i : ] ) [EOL] [EOL] return events_union [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_core.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Tuple[aw_core.Event,aw_core.Event,aw_core.TimePeriod]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import builtins [EOL] import aw_core [EOL] import logging [EOL] from typing import List , Dict [EOL] from datetime import timedelta [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def chunk_events_by_key ( events , key , pulsetime = [number] ) : [EOL] chunked_events = [ ] [EOL] for event in events : [EOL] if key not in event . data : [EOL] break [EOL] timediff = timedelta ( seconds = [number] ) [comment] [EOL] if len ( chunked_events ) > [number] : [EOL] timediff = event . timestamp - ( events [ - [number] ] . timestamp + events [ - [number] ] . duration ) [EOL] if ( len ( chunked_events ) > [number] [EOL] and chunked_events [ - [number] ] . data [ key ] == event . data [ key ] [EOL] and timediff < timedelta ( seconds = pulsetime ) ) : [EOL] chunked_event = chunked_events [ - [number] ] [EOL] chunked_event . duration += event . duration [EOL] chunked_event . data [ [string] ] . append ( event ) [EOL] else : [EOL] data = { key : event . data [ key ] , [string] : [ event ] } [EOL] chunked_event = Event ( timestamp = event . timestamp , duration = event . duration , data = data ) [EOL] chunked_events . append ( chunked_event ) [EOL] [EOL] return chunked_events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import datetime [EOL] import logging [EOL] import typing [EOL] import aw_core [EOL] import logging [EOL] from datetime import datetime , timedelta [EOL] from typing import List [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def sort_by_timestamp ( events ) : [EOL] [docstring] [EOL] return sorted ( events , key = lambda e : e . timestamp ) [EOL] [EOL] [EOL] def sort_by_duration ( events ) : [EOL] [docstring] [EOL] return sorted ( events , key = lambda e : e . duration , reverse = True ) [EOL] [EOL] [EOL] def limit_events ( events , count ) : [EOL] [docstring] [EOL] return events [ : count ] [EOL] [EOL] [EOL] def sum_durations ( events ) : [EOL] [docstring] [EOL] return timedelta ( seconds = ( sum ( event . duration . total_seconds ( ) for event in events ) ) ) [EOL] [EOL] [EOL] def concat ( events1 , events2 ) : [EOL] [docstring] [EOL] events = events1 + events2 [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . filter_keyvals import filter_keyvals , filter_keyvals_regex [EOL] from . filter_period_intersect import filter_period_intersect , period_union , union [EOL] from . heartbeats import heartbeat_merge , heartbeat_reduce [EOL] from . merge_events_by_keys import merge_events_by_keys [EOL] from . chunk_events_by_key import chunk_events_by_key [EOL] from . sort_by import ( sort_by_timestamp , sort_by_duration , sum_durations , concat , limit_events , ) [EOL] from . split_url_events import split_url_events [EOL] from . simplify import simplify_string [EOL] from . flood import flood [EOL] from . classify import categorize , tag , Rule [EOL] [EOL] __all__ = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , List [EOL] import typing [EOL] import builtins [EOL] import aw_core [EOL] import re [EOL] from copy import deepcopy [EOL] from typing import List [EOL] [EOL] from aw_core import Event [EOL] [EOL] [EOL] def simplify_string ( events , key = [string] ) : [EOL] events = deepcopy ( events ) [EOL] [EOL] re_leadingdot = re . compile ( [string] ) [EOL] re_parensprefix = re . compile ( [string] ) [EOL] re_fps = re . compile ( [string] ) [EOL] [EOL] for e in events : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] e . data [ key ] = re_parensprefix . sub ( [string] , e . data [ key ] ) [EOL] [EOL] [comment] [EOL] if key == [string] and [string] in e [ [string] ] : [EOL] [comment] [EOL] [comment] [EOL] e . data [ key ] = re_fps . sub ( [string] , e . data [ key ] ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] e . data [ key ] = re_leadingdot . sub ( [string] , e . data [ key ] ) [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Iterable , Pattern , Any , Tuple , Dict , Optional [EOL] import typing [EOL] import builtins [EOL] import aw_core [EOL] from typing import Pattern , List , Iterable , Tuple , Dict , Optional , Any [EOL] from functools import reduce [EOL] import re [EOL] [EOL] from aw_core import Event [EOL] [EOL] [EOL] Tag = str [EOL] Category = List [ str ] [EOL] [EOL] [EOL] class Rule : [EOL] regex = ... [EOL] select_keys = ... [EOL] ignore_case = ... [EOL] [EOL] def __init__ ( self , rules ) : [EOL] self . select_keys = rules . get ( [string] , None ) [EOL] self . ignore_case = rules . get ( [string] , False ) [EOL] [EOL] [comment] [EOL] regex_str = rules . get ( [string] , None ) [EOL] self . regex = ( re . compile ( regex_str , ( re . IGNORECASE if self . ignore_case else [number] ) | re . UNICODE ) [EOL] if regex_str [EOL] else None ) [EOL] [EOL] def match ( self , e ) : [EOL] if self . select_keys : [EOL] values = [ e . data . get ( key , None ) for key in self . select_keys ] [EOL] else : [EOL] values = list ( e . data . values ( ) ) [EOL] if self . regex : [EOL] for val in values : [EOL] if isinstance ( val , str ) and self . regex . search ( val ) : [EOL] return True [EOL] return False [EOL] [EOL] [EOL] def categorize ( events , classes ) : [EOL] return [ _categorize_one ( e , classes ) for e in events ] [EOL] [EOL] [EOL] def _categorize_one ( e , classes ) : [EOL] e . data [ [string] ] = _pick_category ( [ _cls for _cls , rule in classes if rule . match ( e ) ] ) [EOL] return e [EOL] [EOL] [EOL] def tag ( events , classes ) : [EOL] return [ _tag_one ( e , classes ) for e in events ] [EOL] [EOL] [EOL] def _tag_one ( e , classes ) : [EOL] e . data [ [string] ] = [ _cls for _cls , rule in classes if rule . match ( e ) ] [EOL] return e [EOL] [EOL] [EOL] def _pick_category ( tags ) : [EOL] return reduce ( _pick_deepest_cat , tags , [ [string] ] ) [EOL] [EOL] [EOL] def _pick_deepest_cat ( t1 , t2 ) : [EOL] [comment] [EOL] [comment] [EOL] return t2 if len ( t2 ) >= len ( t1 ) else t1 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Pattern]$ 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Optional[typing.List[builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Pattern[typing.Any]]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $aw_core.Event$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $aw_core.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $aw_core.Event$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_core.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_core.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Category$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Union [EOL] import typing [EOL] import logging [EOL] import datetime [EOL] import builtins [EOL] import aw_core [EOL] import logging [EOL] from datetime import timedelta [EOL] from copy import deepcopy [EOL] from typing import List [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def flood ( events , pulsetime = [number] ) : [EOL] [docstring] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] events = deepcopy ( events ) [EOL] events = sorted ( events , key = lambda e : e . timestamp ) [EOL] [EOL] [comment] [EOL] negative_gap_trim_thres = timedelta ( seconds = [number] ) [EOL] [EOL] warned_about_negative_gap_safe = False [EOL] warned_about_negative_gap_unsafe = False [EOL] [EOL] for e1 , e2 in zip ( events [ : - [number] ] , events [ [number] : ] ) : [EOL] gap = e2 . timestamp - ( e1 . timestamp + e1 . duration ) [EOL] [EOL] if not gap : [EOL] continue [EOL] [EOL] [comment] [EOL] if gap < timedelta ( [number] ) and e1 . data == e2 . data : [EOL] [comment] [EOL] start = min ( e1 . timestamp , e2 . timestamp ) [EOL] end = max ( e1 . timestamp + e1 . duration , e2 . timestamp + e2 . duration ) [EOL] e1 . timestamp , e1 . duration = start , ( end - start ) [EOL] e2 . timestamp , e2 . duration = end , timedelta ( [number] ) [EOL] if not warned_about_negative_gap_safe : [EOL] logger . warning ( [string] . format ( gap . total_seconds ( ) ) ) [EOL] warned_about_negative_gap_safe = True [EOL] elif gap < - negative_gap_trim_thres and not warned_about_negative_gap_unsafe : [EOL] [comment] [EOL] logger . warning ( [string] . format ( gap . total_seconds ( ) ) ) [EOL] warned_about_negative_gap_unsafe = True [EOL] [comment] [EOL] [comment] [EOL] elif - negative_gap_trim_thres < gap <= timedelta ( seconds = pulsetime ) : [EOL] e2_end = e2 . timestamp + e2 . duration [EOL] [EOL] [comment] [EOL] if e1 . duration >= e2 . duration : [EOL] if e1 . data == e2 . data : [EOL] [comment] [EOL] [comment] [EOL] e1 . duration = e2_end - e1 . timestamp [EOL] e2 . timestamp = e2_end [EOL] e2 . duration = timedelta ( [number] ) [EOL] else : [EOL] [comment] [EOL] e1 . duration = e2 . timestamp - e1 . timestamp [EOL] else : [EOL] if e1 . data == e2 . data : [EOL] [comment] [EOL] e2 . timestamp = e1 . timestamp [EOL] e2 . duration = e2_end - e2 . timestamp [EOL] e1 . duration = timedelta ( [number] ) [EOL] else : [EOL] [comment] [EOL] e2 . timestamp = e1 . timestamp + e1 . duration [EOL] e2 . duration = e2_end - e2 . timestamp [EOL] [EOL] [comment] [EOL] events = [ e for e in events if e . duration > timedelta ( [number] ) ] [EOL] [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Pattern , List [EOL] import aw_core [EOL] import typing [EOL] import builtins [EOL] import logging [EOL] import logging [EOL] from typing import List [EOL] import re [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def filter_keyvals ( events , key , vals , exclude = False ) : [EOL] def predicate ( event ) : [EOL] return key in event . data and event . data [ key ] in vals [EOL] [EOL] if exclude : [EOL] return [ e for e in events if not predicate ( e ) ] [EOL] else : [EOL] return [ e for e in events if predicate ( e ) ] [EOL] [EOL] [EOL] def filter_keyvals_regex ( events , key , regex ) : [EOL] r = re . compile ( regex ) [EOL] [EOL] def predicate ( event ) : [EOL] return bool ( r . findall ( event . data [ key ] ) ) [EOL] [EOL] return [ e for e in events if predicate ( e ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Any [EOL] import urllib [EOL] import logging [EOL] import typing [EOL] import aw_core [EOL] import logging [EOL] from typing import List [EOL] [EOL] from urllib . parse import urlparse [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def split_url_events ( events ) : [EOL] for event in events : [EOL] if [string] in event . data : [EOL] url = event . data [ [string] ] [EOL] parsed_url = urlparse ( url ) [EOL] event . data [ [string] ] = parsed_url . scheme [EOL] event . data [ [string] ] = ( parsed_url . netloc [ [number] : ] [EOL] if parsed_url . netloc [ : [number] ] == [string] [EOL] else parsed_url . netloc ) [EOL] event . data [ [string] ] = parsed_url . path [EOL] event . data [ [string] ] = parsed_url . params [EOL] event . data [ [string] ] = parsed_url . query [EOL] event . data [ [string] ] = parsed_url . fragment [EOL] [comment] [EOL] return events [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Callable , Any , Tuple , Dict [EOL] import typing [EOL] import inspect [EOL] import datetime [EOL] import aw_datastore [EOL] import builtins [EOL] import aw_core [EOL] import re [EOL] import iso8601 [EOL] from typing import Callable , Dict , Any , List [EOL] from inspect import signature [EOL] from functools import wraps [EOL] from datetime import timedelta [EOL] [EOL] from aw_core . models import Event [EOL] from aw_datastore import Datastore [EOL] [EOL] from aw_transform import ( filter_period_intersect , filter_keyvals , filter_keyvals_regex , period_union , categorize , tag , Rule , merge_events_by_keys , chunk_events_by_key , sort_by_timestamp , sort_by_duration , sum_durations , concat , split_url_events , simplify_string , flood , limit_events , ) [EOL] [EOL] from . exceptions import QueryFunctionException [EOL] [EOL] [EOL] def _verify_bucket_exists ( datastore , bucketname ) : [EOL] if bucketname in datastore . buckets ( ) : [EOL] return [EOL] else : [EOL] raise QueryFunctionException ( [string] . format ( bucketname ) ) [EOL] [EOL] [EOL] def _verify_variable_is_type ( variable , t ) : [EOL] if not isinstance ( variable , t ) : [EOL] raise QueryFunctionException ( [string] . format ( variable , t , type ( variable ) ) ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] TNamespace = Dict [ str , Any ] [EOL] TQueryFunction = Callable [ ... , Any ] [EOL] [EOL] [EOL] [docstring] [EOL] functions = { } [EOL] [EOL] [EOL] def q2_function ( transform_func = None ) : [EOL] [docstring] [EOL] [EOL] def h ( f ) : [EOL] sig = signature ( f ) [EOL] [comment] [EOL] if transform_func and transform_func . __doc__ and not f . __doc__ : [EOL] f . __doc__ = [string] . format ( func_name = transform_func . __name__ , func_doc = transform_func . __doc__ ) [EOL] [EOL] @ wraps ( f ) def g ( datastore , namespace , * args , ** kwargs ) : [EOL] [comment] [EOL] args = ( datastore , namespace , * args ) [EOL] if TNamespace not in ( sig . parameters [ p ] . annotation for p in sig . parameters ) : [EOL] args = ( args [ [number] ] , * args [ [number] : ] ) [EOL] if Datastore not in ( sig . parameters [ p ] . annotation for p in sig . parameters ) : [EOL] args = args [ [number] : ] [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] fname = f . __name__ [EOL] if fname [ : [number] ] == [string] : [EOL] fname = fname [ [number] : ] [EOL] functions [ fname ] = g [EOL] return g [EOL] [EOL] return h [EOL] [EOL] [EOL] def q2_typecheck ( f ) : [EOL] [docstring] [EOL] sig = signature ( f ) [EOL] [EOL] @ wraps ( f ) def g ( * args , ** kwargs ) : [EOL] [comment] [EOL] for i , p in enumerate ( sig . parameters ) : [EOL] param = sig . parameters [ p ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] if ( param . annotation in [ list , str , int , float ] [EOL] and param . default == param . empty ) : [EOL] _verify_variable_is_type ( args [ i ] , param . annotation ) [EOL] [EOL] return f ( * args , ** kwargs ) [EOL] [EOL] return g [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( ) @ q2_typecheck def q2_find_bucket ( datastore , filter_str , hostname = None ) : [EOL] [docstring] [EOL] for bucket in datastore . buckets ( ) : [EOL] if filter_str in bucket : [EOL] bucket_metadata = datastore [ bucket ] . metadata ( ) [EOL] if hostname : [EOL] if bucket_metadata [ [string] ] == hostname : [EOL] return bucket [EOL] else : [EOL] return bucket [EOL] raise QueryFunctionException ( [string] . format ( filter_str , hostname ) ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( ) @ q2_typecheck def q2_query_bucket ( datastore , namespace , bucketname ) : [EOL] _verify_bucket_exists ( datastore , bucketname ) [EOL] try : [EOL] starttime = iso8601 . parse_date ( namespace [ [string] ] ) [EOL] endtime = iso8601 . parse_date ( namespace [ [string] ] ) [EOL] except iso8601 . ParseError : [EOL] raise QueryFunctionException ( [string] ) [EOL] return datastore [ bucketname ] . get ( starttime = starttime , endtime = endtime ) [EOL] [EOL] [EOL] @ q2_function ( ) @ q2_typecheck def q2_query_bucket_eventcount ( datastore , namespace , bucketname ) : [EOL] _verify_bucket_exists ( datastore , bucketname ) [EOL] starttime = iso8601 . parse_date ( namespace [ [string] ] ) [EOL] endtime = iso8601 . parse_date ( namespace [ [string] ] ) [EOL] return datastore [ bucketname ] . get_eventcount ( starttime = starttime , endtime = endtime ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( filter_keyvals ) @ q2_typecheck def q2_filter_keyvals ( events , key , vals ) : [EOL] return filter_keyvals ( events , key , vals , False ) [EOL] [EOL] [EOL] @ q2_function ( filter_keyvals ) @ q2_typecheck def q2_exclude_keyvals ( events , key , vals ) : [EOL] return filter_keyvals ( events , key , vals , True ) [EOL] [EOL] [EOL] @ q2_function ( filter_keyvals_regex ) @ q2_typecheck def q2_filter_keyvals_regex ( events , key , regex ) : [EOL] return filter_keyvals_regex ( events , key , regex ) [EOL] [EOL] [EOL] @ q2_function ( filter_period_intersect ) @ q2_typecheck def q2_filter_period_intersect ( events , filterevents ) : [EOL] return filter_period_intersect ( events , filterevents ) [EOL] [EOL] [EOL] @ q2_function ( period_union ) @ q2_typecheck def q2_period_union ( events1 , events2 ) : [EOL] return period_union ( events1 , events2 ) [EOL] [EOL] [EOL] @ q2_function ( limit_events ) @ q2_typecheck def q2_limit_events ( events , count ) : [EOL] return limit_events ( events , count ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( merge_events_by_keys ) @ q2_typecheck def q2_merge_events_by_keys ( events , keys ) : [EOL] return merge_events_by_keys ( events , keys ) [EOL] [EOL] [EOL] @ q2_function ( chunk_events_by_key ) @ q2_typecheck def q2_chunk_events_by_key ( events , key ) : [EOL] return chunk_events_by_key ( events , key ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( sort_by_timestamp ) @ q2_typecheck def q2_sort_by_timestamp ( events ) : [EOL] return sort_by_timestamp ( events ) [EOL] [EOL] [EOL] @ q2_function ( sort_by_duration ) @ q2_typecheck def q2_sort_by_duration ( events ) : [EOL] return sort_by_duration ( events ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( sum_durations ) @ q2_typecheck def q2_sum_durations ( events ) : [EOL] return sum_durations ( events ) [EOL] [EOL] [EOL] @ q2_function ( concat ) @ q2_typecheck def q2_concat ( events1 , events2 ) : [EOL] return concat ( events1 , events2 ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( flood ) @ q2_typecheck def q2_flood ( events ) : [EOL] return flood ( events ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( split_url_events ) @ q2_typecheck def q2_split_url_events ( events ) : [EOL] return split_url_events ( events ) [EOL] [EOL] [EOL] @ q2_function ( simplify_string ) @ q2_typecheck def q2_simplify_window_titles ( events , key ) : [EOL] return simplify_string ( events , key = key ) [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( ) @ q2_typecheck def q2_nop ( ) : [EOL] [docstring] [EOL] return [number] [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] @ q2_function ( categorize ) @ q2_typecheck def q2_categorize ( events , classes ) : [EOL] classes = [ ( _cls , Rule ( rule_dict ) ) for _cls , rule_dict in classes ] [EOL] return categorize ( events , classes ) [EOL] [EOL] [EOL] @ q2_function ( tag ) @ q2_typecheck def q2_tag ( events , classes ) : [EOL] classes = [ ( _cls , Rule ( rule_dict ) ) for _cls , rule_dict in classes ] [EOL] return tag ( events , classes ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,TQueryFunction]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,TQueryFunction]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $datetime.timedelta$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class QueryException ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class QueryFunctionException ( QueryException ) : [EOL] pass [EOL] [EOL] [EOL] class QueryParseException ( QueryException ) : [EOL] pass [EOL] [EOL] [EOL] class QueryInterpretException ( QueryException ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import exceptions [EOL] from . import query2 [EOL] [EOL] from . query2 import query [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Type , List , Union , Any , Sequence , Tuple , Dict [EOL] import typing [EOL] import aw_query [EOL] import datetime [EOL] import logging [EOL] import aw_datastore [EOL] import builtins [EOL] import logging [EOL] from typing import Union , List , Dict , Sequence , Callable , Type , Any , Tuple [EOL] from datetime import datetime [EOL] [EOL] from aw_core . models import Event [EOL] from aw_datastore import Datastore [EOL] [EOL] from . exceptions import QueryException , QueryParseException , QueryInterpretException [EOL] from . functions import functions [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] class QToken : [EOL] def interpret ( self , datastore , namespace ) : [EOL] raise NotImplementedError [EOL] [EOL] @ staticmethod def parse ( string , namespace ) : [EOL] raise NotImplementedError [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] raise NotImplementedError [EOL] [EOL] [EOL] class QInteger ( QToken ) : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] return self . value [EOL] [EOL] @ staticmethod def parse ( string , namespace = { } ) : [EOL] return QInteger ( int ( string ) ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] token = [string] [EOL] for char in string : [EOL] if char . isdigit ( ) : [EOL] token += char [EOL] else : [EOL] break [EOL] return token , string [ len ( token ) : ] [EOL] [EOL] [EOL] class QVariable ( QToken ) : [EOL] def __init__ ( self , name , value ) : [EOL] self . name = name [EOL] self . value = value [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] if self . name not in namespace : [EOL] raise QueryInterpretException ( [string] . format ( self . name ) ) [EOL] namespace [ self . name ] = self . value [EOL] return self . value [EOL] [EOL] @ staticmethod def parse ( string , namespace ) : [EOL] val = None [EOL] if string in namespace : [EOL] val = namespace [ string ] [EOL] return QVariable ( string , val ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] token = [string] [EOL] for i , char in enumerate ( string ) : [EOL] if char . isalpha ( ) or char == [string] : [EOL] token += char [EOL] elif i != [number] and char . isdigit ( ) : [EOL] token += char [EOL] else : [EOL] break [EOL] return token , string [ len ( token ) : ] [EOL] [EOL] [EOL] class QString ( QToken ) : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] return self . value [EOL] [EOL] @ staticmethod def parse ( string , namespace = { } ) : [EOL] quotes_type = string [ [number] ] [EOL] string = string . replace ( [string] + quotes_type , quotes_type ) [EOL] string = string [ [number] : - [number] ] [EOL] return QString ( string ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] token = [string] [EOL] quotes_type = string [ [number] ] [EOL] if quotes_type != [string] and quotes_type != [string] : [EOL] return token , string [EOL] token += quotes_type [EOL] prev_char = None [EOL] for char in string [ [number] : ] : [EOL] token += char [EOL] if ( char == quotes_type and prev_char != [string] ) : [comment] [EOL] break [EOL] prev_char = char [EOL] if token [ - [number] ] != quotes_type or len ( token ) < [number] : [EOL] [comment] [EOL] raise QueryParseException ( [string] ) [EOL] return token , string [ len ( token ) : ] [EOL] [EOL] [EOL] class QFunction ( QToken ) : [EOL] def __init__ ( self , name , args ) : [EOL] self . name = name [EOL] self . args = args [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] if self . name not in functions : [EOL] raise QueryInterpretException ( [string] . format ( self . name ) ) [EOL] call_args = [ datastore , namespace ] [EOL] for arg in self . args : [EOL] call_args . append ( arg . interpret ( datastore , namespace ) ) [EOL] [comment] [EOL] try : [EOL] result = functions [ self . name ] ( * call_args ) [comment] [EOL] except TypeError : [EOL] raise QueryInterpretException ( [string] . format ( self . name ) ) [EOL] return result [EOL] [EOL] @ staticmethod def parse ( string , namespace ) : [EOL] arg_start = [number] [EOL] arg_end = len ( string ) - [number] [EOL] [comment] [EOL] for char in string : [EOL] if char == [string] : [EOL] break [EOL] arg_start = arg_start + [number] [EOL] [comment] [EOL] name = string [ : arg_start ] [EOL] [comment] [EOL] args = [ ] [EOL] args_str = string [ arg_start + [number] : arg_end ] [EOL] while args_str : [EOL] ( arg_t , arg ) , args_str = _parse_token ( args_str , namespace ) [EOL] comma = args_str . find ( [string] ) [EOL] if comma != - [number] : [EOL] args_str = args_str [ comma + [number] : ] [EOL] args . append ( arg_t . parse ( arg , namespace ) ) [EOL] return QFunction ( name , args ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] i = [number] [EOL] [comment] [EOL] found = False [EOL] for char in string : [EOL] if char . isalpha ( ) or char == [string] : [EOL] i = i + [number] [EOL] elif i != [number] and char . isdigit ( ) : [EOL] i = i + [number] [EOL] elif char == [string] : [EOL] i = i + [number] [EOL] found = True [EOL] break [EOL] else : [EOL] break [EOL] if not found : [EOL] return None , string [EOL] to_consume = [number] [EOL] single_quote = False [EOL] double_quote = False [EOL] prev_char = None [EOL] for char in string [ i : ] : [EOL] i = i + [number] [EOL] if char == [string] and prev_char != [string] and not double_quote : [EOL] single_quote = not single_quote [EOL] elif char == [string] and prev_char != [string] and not single_quote : [EOL] double_quote = not double_quote [EOL] elif single_quote or double_quote : [EOL] pass [EOL] elif i != [number] and char . isdigit ( ) : [EOL] pass [EOL] elif char == [string] : [EOL] to_consume += [number] [EOL] elif char == [string] : [EOL] to_consume -= [number] [EOL] if to_consume == [number] : [EOL] break [EOL] prev_char = char [EOL] if to_consume != [number] : [EOL] return None , string [EOL] return string [ : i ] , string [ i + [number] : ] [EOL] [EOL] [EOL] class QDict ( QToken ) : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] expanded_dict = { } [EOL] for key , value in self . value . items ( ) : [EOL] expanded_dict [ key ] = value . interpret ( datastore , namespace ) [EOL] return expanded_dict [EOL] [EOL] @ staticmethod def parse ( string , namespace ) : [EOL] entries_str = string [ [number] : - [number] ] [EOL] d = { } [EOL] while len ( entries_str ) > [number] : [EOL] entries_str = entries_str . strip ( ) [EOL] if len ( d ) > [number] and entries_str [ [number] ] == [string] : [EOL] entries_str = entries_str [ [number] : ] [EOL] [comment] [EOL] ( key_t , key_str ) , entries_str = _parse_token ( entries_str , namespace ) [EOL] if key_t != QString : [EOL] raise QueryParseException ( [string] ) [EOL] key = QString . parse ( key_str ) . value [comment] [EOL] entries_str = entries_str . strip ( ) [EOL] [comment] [EOL] if entries_str [ [number] ] != [string] : [EOL] raise QueryParseException ( [string] ) [EOL] entries_str = entries_str [ [number] : ] [EOL] [comment] [EOL] ( val_t , val_str ) , entries_str = _parse_token ( entries_str , namespace ) [EOL] if not val_t : [EOL] raise QueryParseException ( [string] ) [EOL] val = val_t . parse ( val_str , namespace ) [EOL] [comment] [EOL] d [ key ] = val [EOL] return QDict ( d ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] if string [ [number] ] != [string] : [EOL] return None , string [EOL] [comment] [EOL] i = [number] [EOL] to_consume = [number] [EOL] single_quote = False [EOL] double_quote = False [EOL] prev_char = None [EOL] for char in string [ i : ] : [EOL] i += [number] [EOL] if char == [string] and prev_char != [string] and not double_quote : [EOL] single_quote = not single_quote [EOL] elif char == [string] and prev_char != [string] and not single_quote : [EOL] double_quote = not double_quote [EOL] elif single_quote or double_quote : [EOL] pass [EOL] elif char == [string] : [EOL] to_consume = to_consume - [number] [EOL] elif char == [string] : [EOL] to_consume = to_consume + [number] [EOL] if to_consume == [number] : [EOL] break [EOL] prev_char = char [EOL] return string [ : i ] , string [ i + [number] : ] [EOL] [EOL] [EOL] class QList ( QToken ) : [EOL] def __init__ ( self , value ) : [EOL] self . value = value [EOL] [EOL] def interpret ( self , datastore , namespace ) : [EOL] expanded_list = [ ] [EOL] for value in self . value : [EOL] expanded_list . append ( value . interpret ( datastore , namespace ) ) [EOL] return expanded_list [EOL] [EOL] @ staticmethod def parse ( string , namespace ) : [EOL] entries_str = string [ [number] : - [number] ] [EOL] l = [ ] [EOL] while len ( entries_str ) > [number] : [EOL] entries_str = entries_str . strip ( ) [EOL] if len ( l ) > [number] and entries_str [ [number] ] == [string] : [EOL] entries_str = entries_str [ [number] : ] [EOL] [comment] [EOL] ( val_t , val_str ) , entries_str = _parse_token ( entries_str , namespace ) [EOL] if not val_t : [EOL] raise QueryParseException ( [string] ) [EOL] val = val_t . parse ( val_str , namespace ) [EOL] [comment] [EOL] l . append ( val ) [EOL] return QList ( l ) [EOL] [EOL] @ staticmethod def check ( string ) : [EOL] if string [ [number] ] != [string] : [EOL] return None , string [EOL] [comment] [EOL] i = [number] [EOL] to_consume = [number] [EOL] single_quote = False [EOL] double_quote = False [EOL] prev_char = None [EOL] for char in string [ i : ] : [EOL] i += [number] [EOL] if char == [string] and prev_char != [string] and not double_quote : [EOL] single_quote = not single_quote [EOL] elif char == [string] and prev_char != [string] and not single_quote : [EOL] double_quote = not double_quote [EOL] elif double_quote or single_quote : [EOL] pass [EOL] elif char == [string] : [EOL] to_consume = to_consume - [number] [EOL] elif char == [string] : [EOL] to_consume = to_consume + [number] [EOL] if to_consume == [number] : [EOL] break [EOL] prev_char = char [EOL] return string [ : i ] , string [ i + [number] : ] [EOL] [EOL] [EOL] qtypes = [ QString , QInteger , QFunction , QDict , QList , QVariable ] [EOL] [EOL] [EOL] def _parse_token ( string , namespace ) : [EOL] [comment] [EOL] if not isinstance ( string , str ) : [EOL] raise QueryParseException ( [string] ) [EOL] if len ( string ) == [number] : [EOL] return ( None , [string] ) , string [EOL] string = string . strip ( ) [EOL] token = None [EOL] t = None [comment] [EOL] for t in qtypes : [EOL] token , string = t . check ( string ) [EOL] if token : [EOL] break [EOL] if not token : [EOL] raise QueryParseException ( [string] . format ( string ) ) [EOL] return ( t , token ) , string [EOL] [EOL] [EOL] def create_namespace ( ) : [EOL] namespace = { [string] : True , [string] : False , [string] : True , [string] : False , } [EOL] return namespace [EOL] [EOL] [EOL] def parse ( line , namespace ) : [EOL] separator_i = line . find ( [string] ) [EOL] var_str = line [ : separator_i ] [EOL] val_str = line [ separator_i + [number] : ] [EOL] if not val_str : [EOL] [comment] [EOL] raise QueryParseException ( [string] ) [EOL] ( var_t , var ) , var_str = _parse_token ( var_str , namespace ) [EOL] var_str = var_str . strip ( ) [EOL] if var_str : [comment] [EOL] raise QueryParseException ( [string] ) [EOL] if var_t is not QVariable : [EOL] raise QueryParseException ( [string] ) [EOL] ( val_t , val ) , var_str = _parse_token ( val_str , namespace ) [EOL] if var_str : [comment] [EOL] raise QueryParseException ( [string] ) [EOL] [comment] [EOL] var = var_t . parse ( var , namespace ) [EOL] val = val_t . parse ( val , namespace ) [EOL] return var , val [EOL] [EOL] [EOL] def interpret ( var , val , namespace , datastore ) : [EOL] namespace [ var . name ] = val . interpret ( datastore , namespace ) [EOL] [comment] [EOL] [EOL] [EOL] def get_return ( namespace ) : [EOL] if [string] not in namespace : [EOL] raise QueryParseException ( [string] ) [EOL] return namespace [ [string] ] [EOL] [EOL] [EOL] def query ( name , query , starttime , endtime , datastore ) : [EOL] namespace = create_namespace ( ) [EOL] namespace [ [string] ] = name [EOL] namespace [ [string] ] = starttime . isoformat ( ) [EOL] namespace [ [string] ] = endtime . isoformat ( ) [EOL] [EOL] query_stmts = query . split ( [string] ) [EOL] for statement in query_stmts : [EOL] statement = statement . strip ( ) [EOL] if statement : [EOL] logger . debug ( [string] + statement ) [EOL] var , val = parse ( statement , namespace ) [EOL] interpret ( var , val , namespace , datastore ) [EOL] [EOL] result = get_return ( namespace ) [EOL] return result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 $typing.Any$ 0 $builtins.dict$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],aw_datastore.datastore.Datastore]]$ 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],aw_datastore.datastore.Datastore]]$ 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Union[typing.Dict[typing.Any,typing.Any],aw_datastore.datastore.Datastore]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.dict$ 0 0 $builtins.int$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,QToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,QToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $typing.Dict[builtins.str,QToken]$ 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Dict[builtins.str,QToken]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $aw_datastore.Datastore$ 0 $builtins.dict$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $QToken$ 0 $builtins.str$ 0 $builtins.dict$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[QToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[QToken]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 $typing.List[QToken]$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.List[QToken]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $builtins.int$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.int$ 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import configparser [EOL] import typing [EOL] import unittest [EOL] import shutil [EOL] from configparser import ConfigParser [EOL] [EOL] from aw_core import dirs [EOL] from aw_core . config import load_config , save_config [EOL] [EOL] [EOL] def test_create ( ) : [EOL] appname = [string] [EOL] section = [string] [EOL] config_dir = dirs . get_config_dir ( appname ) [EOL] [EOL] [comment] [EOL] shutil . rmtree ( config_dir ) [EOL] [EOL] [comment] [EOL] default_config = ConfigParser ( ) [EOL] default_config [ section ] = { [string] : [string] , [string] : [number] } [EOL] [EOL] [comment] [EOL] config = load_config ( appname , default_config ) [EOL] [EOL] [comment] [EOL] assert config [ section ] [ [string] ] == default_config [ section ] [ [string] ] [EOL] assert config [ section ] . getfloat ( [string] ) == default_config [ section ] . getfloat ( [string] ) [EOL] [EOL] [comment] [EOL] config [ section ] [ [string] ] = [string] [EOL] save_config ( appname , config ) [EOL] [EOL] [comment] [EOL] new_config = load_config ( appname , default_config ) [EOL] assert new_config [ section ] [ [string] ] == config [ section ] [ [string] ] [EOL] assert new_config [ section ] . getfloat ( [string] ) == config [ section ] . getfloat ( [string] ) [EOL] [EOL] [comment] [EOL] shutil . rmtree ( config_dir ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import datetime [EOL] import typing [EOL] import aw_core [EOL] from datetime import datetime , timedelta , timezone [EOL] import json [EOL] import logging [EOL] [EOL] from aw_core . models import Event [EOL] from aw_transform import heartbeat_merge , heartbeat_reduce [EOL] [EOL] import unittest [EOL] [EOL] [EOL] def test_heartbeat_merge ( ) : [EOL] [docstring] [EOL] now = datetime . now ( ) [EOL] td_1s = timedelta ( seconds = [number] ) [EOL] [EOL] last_event , heartbeat = Event ( timestamp = now ) , Event ( timestamp = now + td_1s ) [EOL] merged = heartbeat_merge ( last_event , heartbeat , pulsetime = [number] ) [EOL] assert merged is not None [EOL] [EOL] [EOL] def test_heartbeat_merge_fail ( ) : [EOL] [docstring] [EOL] now = datetime . now ( ) [EOL] td_1s = timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] last_event , heartbeat = ( Event ( timestamp = now , data = { [string] : [string] } ) , Event ( timestamp = now + [number] * td_1s , data = { [string] : [string] } ) , ) [EOL] merged = heartbeat_merge ( last_event , heartbeat , pulsetime = [number] ) [EOL] assert merged is None [EOL] [EOL] [comment] [EOL] last_event , heartbeat = ( Event ( timestamp = now , data = { [string] : [string] } ) , Event ( timestamp = now + td_1s , data = { [string] : [string] } ) , ) [EOL] merged = heartbeat_merge ( last_event , heartbeat , pulsetime = [number] ) [EOL] assert merged is None [EOL] [EOL] [EOL] def test_heartbeat_reduce ( ) : [EOL] [docstring] [EOL] now = datetime . now ( ) [EOL] td_1s = timedelta ( seconds = [number] ) [EOL] [EOL] [comment] [EOL] assert not heartbeat_reduce ( [ ] , pulsetime = [number] ) [EOL] [EOL] events = [ Event ( timestamp = now , data = { [string] : [string] } ) , Event ( timestamp = now + td_1s , data = { [string] : [string] } ) , ] [EOL] reduced_events = heartbeat_reduce ( events , pulsetime = [number] ) [EOL] assert len ( reduced_events ) == [number] [EOL] [EOL] [EOL] def test_heartbeat_same_timestamp ( ) : [EOL] now = datetime . now ( ) [EOL] td_1s = timedelta ( seconds = [number] ) [EOL] td_0s = timedelta ( seconds = [number] ) [EOL] [EOL] e1 = Event ( timestamp = now , duration = td_1s , data = { [string] : [string] } ) [EOL] e2 = Event ( timestamp = now , duration = td_0s , data = { [string] : [string] } ) [EOL] [EOL] [comment] [EOL] res = heartbeat_reduce ( list ( [ e1 , e2 ] ) , pulsetime = [number] ) [EOL] assert len ( res ) == [number] [EOL] assert res [ [number] ] . duration == td_1s [EOL] [EOL] [comment] [EOL] res = heartbeat_reduce ( [ e2 , e1 ] , pulsetime = [number] ) [EOL] assert len ( res ) == [number] [EOL] assert res [ [number] ] . duration == td_1s [EOL] [EOL] [EOL] def test_heartbeat_reduce_fail ( ) : [EOL] [docstring] [EOL] now = datetime . now ( ) [EOL] td_1s = timedelta ( seconds = [number] ) [EOL] [EOL] events = [ Event ( timestamp = now , data = { [string] : [string] } ) , Event ( timestamp = now + [number] * td_1s , data = { [string] : [string] } ) , ] [EOL] reduced_events = heartbeat_reduce ( events , pulsetime = [number] ) [EOL] assert len ( reduced_events ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import typing [EOL] import aw_core [EOL] import unittest [EOL] [EOL] from jsonschema import validate as _validate , FormatChecker [EOL] from jsonschema . exceptions import ValidationError [EOL] [EOL] from aw_core import schema [EOL] from aw_core . models import Event [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] fc = FormatChecker ( [ [string] ] ) [EOL] [EOL] valid_timestamp = [string] [EOL] [EOL] [EOL] event_schema = schema . get_json_schema ( [string] ) [EOL] [EOL] [EOL] class EventSchemaTest ( unittest . TestCase ) : [EOL] def setUp ( self ) : [EOL] self . schema = event_schema [EOL] [EOL] def validate ( self , obj ) : [EOL] _validate ( obj , self . schema , format_checker = fc ) [EOL] [EOL] def test_event ( self ) : [EOL] event = Event ( timestamp = valid_timestamp , data = { [string] : [string] } ) [EOL] self . validate ( event . to_json_dict ( ) ) [EOL] [EOL] def test_data ( self ) : [EOL] self . validate ( { [string] : valid_timestamp , [string] : { [string] : [string] , [string] : [number] } } ) [EOL] [EOL] def test_timestamp ( self ) : [EOL] self . validate ( { [string] : valid_timestamp } ) [EOL] [EOL] def test_timestamp_invalid_string ( self ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( { [string] : [string] } ) [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( { [string] : [string] } ) [EOL] [EOL] def test_timestamp_invalid_number ( self ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( { [string] : [number] } ) [EOL] [EOL] def test_duration ( self ) : [EOL] self . validate ( { [string] : valid_timestamp , [string] : [number] } ) [EOL] self . validate ( { [string] : valid_timestamp , [string] : [number] } ) [EOL] [EOL] def test_duration_invalid_string ( self ) : [EOL] with self . assertRaises ( ValidationError ) : [EOL] self . validate ( { [string] : valid_timestamp , [string] : [string] } ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] unittest . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $aw_core.models.Event$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_core.models.Event$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import datetime [EOL] import aw_core [EOL] from datetime import datetime , timedelta [EOL] [EOL] import pytest [EOL] [EOL] from aw_core import TimePeriod [EOL] [EOL] [EOL] def test_intersection_start ( ) : [EOL] now = datetime . now ( ) [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now - timedelta ( minutes = [number] ) , now + timedelta ( minutes = [number] ) ) [EOL] assert tp1 . intersection ( tp2 ) . duration == timedelta ( minutes = [number] ) [EOL] assert tp2 . intersection ( tp1 ) . duration == timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def test_intersection_end ( ) : [EOL] now = datetime . now ( ) [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now + timedelta ( minutes = [number] ) , now + timedelta ( hours = [number] ) ) [EOL] assert tp1 . intersection ( tp2 ) . duration == timedelta ( minutes = [number] ) [EOL] assert tp2 . intersection ( tp1 ) . duration == timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def test_intersection_entire ( ) : [EOL] now = datetime . now ( ) [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now - timedelta ( minutes = [number] ) , now + timedelta ( minutes = [number] ) ) [EOL] assert tp1 . intersection ( tp2 ) . duration == timedelta ( minutes = [number] ) [EOL] assert tp2 . intersection ( tp1 ) . duration == timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def test_intersection_none ( ) : [EOL] now = datetime . now ( ) [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now - timedelta ( hours = [number] ) , now ) [EOL] assert tp1 . intersection ( tp2 ) is None [EOL] assert tp2 . intersection ( tp1 ) is None [EOL] [EOL] [EOL] def test_contains ( ) : [EOL] now = datetime . now ( ) [EOL] [EOL] tp1 = TimePeriod ( now - timedelta ( hours = [number] ) , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] assert tp1 . contains ( tp2 ) [EOL] assert not tp2 . contains ( tp1 ) [EOL] [EOL] [comment] [EOL] assert now in tp1 [EOL] assert now in tp2 [EOL] [EOL] [comment] [EOL] assert tp2 in tp1 [EOL] assert tp1 not in tp2 [EOL] [EOL] with pytest . raises ( TypeError ) : [EOL] assert [number] in tp1 [EOL] [EOL] [EOL] def test_overlaps ( ) : [EOL] now = datetime . now ( ) [EOL] [comment] [EOL] tp1 = TimePeriod ( now - timedelta ( hours = [number] ) , now ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] assert not tp1 . overlaps ( tp2 ) [EOL] assert not tp2 . overlaps ( tp1 ) [EOL] [EOL] [comment] [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now - timedelta ( hours = [number] ) , now + timedelta ( hours = [number] ) ) [EOL] assert tp1 . overlaps ( tp2 ) [EOL] assert tp2 . overlaps ( tp1 ) [EOL] [EOL] [comment] [EOL] tp1 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp2 = TimePeriod ( now - timedelta ( hours = [number] ) , now + timedelta ( hours = [number] ) ) [EOL] assert tp1 . overlaps ( tp2 ) [EOL] assert tp2 . overlaps ( tp1 ) [EOL] [EOL] [EOL] def test_adjacent ( ) : [EOL] now = datetime . now ( ) [EOL] tp1 = TimePeriod ( now - timedelta ( hours = [number] ) , now ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] assert tp1 . adjacent ( tp2 ) [EOL] assert tp2 . adjacent ( tp1 ) [EOL] [EOL] [EOL] def test_union ( ) : [EOL] now = datetime . now ( ) [EOL] [EOL] [comment] [EOL] tp1 = TimePeriod ( now - timedelta ( hours = [number] ) , now ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp_union = tp1 . union ( tp2 ) [EOL] assert tp1 in tp_union [EOL] assert tp2 in tp_union [EOL] [EOL] [comment] [EOL] tp_union = tp1 . union ( tp1 ) [EOL] assert tp1 == tp_union [EOL] [EOL] [comment] [EOL] tp1 = TimePeriod ( now - timedelta ( hours = [number] ) , now + timedelta ( minutes = [number] ) ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( hours = [number] ) ) [EOL] tp_union = tp1 . union ( tp2 ) [EOL] assert tp1 in tp_union [EOL] assert tp2 in tp_union [EOL] [EOL] [comment] [EOL] tp1 = TimePeriod ( now - timedelta ( minutes = [number] ) , now + timedelta ( minutes = [number] ) ) [EOL] tp2 = TimePeriod ( now , now + timedelta ( minutes = [number] ) ) [EOL] tp_union = tp1 . union ( tp2 ) [EOL] assert tp1 in tp_union [EOL] assert tp2 in tp_union [EOL] assert tp1 == tp_union [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . import context [EOL]	0 0 0 0 0
from typing import Dict , List , Union , Any [EOL] import datetime [EOL] import aw_query [EOL] import typing [EOL] import aw_core [EOL] from datetime import datetime , timedelta , timezone [EOL] import iso8601 [EOL] [EOL] import pytest [EOL] [EOL] from . utils import param_datastore_objects [EOL] [EOL] from aw_core . models import Event [EOL] from aw_query import query [EOL] from aw_query . query2 import ( QInteger , QVariable , QString , QFunction , QList , QDict , _parse_token , ) [EOL] from aw_query . exceptions import ( QueryFunctionException , QueryParseException , QueryInterpretException , ) [EOL] [EOL] [EOL] def test_query2_test_token_parsing ( ) : [EOL] ns = { } [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QInteger [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QString [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QString [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QString [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QString [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QVariable [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QFunction [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QFunction [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QList [EOL] ( t , token ) , trash = _parse_token ( [string] , ns ) [EOL] assert token == [string] [EOL] assert t == QDict [EOL] [EOL] assert _parse_token ( [string] , ns ) == ( ( None , [string] ) , [string] ) [EOL] [EOL] with pytest . raises ( QueryParseException ) : [EOL] _parse_token ( None , ns ) [EOL] [EOL] with pytest . raises ( QueryParseException ) : [EOL] _parse_token ( [string] , ns ) [EOL] [EOL] with pytest . raises ( QueryParseException ) : [EOL] _parse_token ( [string] , ns ) [EOL] [EOL] [EOL] def test_dict ( ) : [EOL] ds = None [EOL] ns = { } [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] expected_res = { [string] : { [string] : { [string] : [number] } } , [string] : { [string] : [string] } } [EOL] assert expected_res == d . interpret ( ds , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] d_str = [string] [EOL] d = QDict . parse ( d_str , ns ) [EOL] [EOL] [EOL] def test_list ( ) : [EOL] ds = None [EOL] ns = { } [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] expected_res = [ [number] , [number] , [ [ [number] ] , [number] ] , [number] ] [EOL] assert expected_res == l . interpret ( ds , ns ) [EOL] [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] expected_res = [ [string] , [string] ] [EOL] assert expected_res == l . interpret ( ds , ns ) [EOL] [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] expected_res = [ ] [EOL] assert expected_res == l . interpret ( ds , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] l_str = [string] [EOL] l = QList . parse ( l_str , ns ) [EOL] [EOL] [EOL] def test_query2_bogus_query ( ) : [EOL] qname = [string] [EOL] qstartdate = datetime . now ( tz = timezone . utc ) [EOL] qenddate = qstartdate [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , qstartdate , qenddate , None ) [EOL] [EOL] [EOL] def test_query2_query_function_calling ( ) : [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryInterpretException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryInterpretException ) : [EOL] example_query = [string] [EOL] query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [comment] [EOL] example_query = [string] [EOL] query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [EOL] def test_query2_return_value ( ) : [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] example_query = [string] [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] assert result == [number] [EOL] [EOL] example_query = [string] [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] assert result == [string] [EOL] [EOL] example_query = [string] [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] assert result == { [string] : [number] } [EOL] [EOL] [comment] [EOL] with pytest . raises ( QueryParseException ) : [EOL] example_query = [string] [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [EOL] def test_query2_multiline ( ) : [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] example_query = [string] [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] assert result == [string] [EOL] [EOL] [EOL] def test_query2_function_invalid_types ( ) : [EOL] [docstring] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] [EOL] [comment] [EOL] example_query = [string] [EOL] with pytest . raises ( QueryFunctionException ) : [EOL] query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [comment] [EOL] example_query = [string] [EOL] with pytest . raises ( QueryFunctionException ) : [EOL] query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [comment] [EOL] [docstring] [EOL] [EOL] [EOL] def test_query2_function_invalid_argument_count ( ) : [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] example_query = [string] [EOL] with pytest . raises ( QueryInterpretException ) : [EOL] result = query ( qname , example_query , starttime , endtime , None ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_function_in_function ( datastore ) : [EOL] qname = [string] [EOL] bid = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = iso8601 . parse_date ( [string] ) [EOL] example_query = [string] . format ( bid = bid ) [EOL] try : [EOL] [comment] [EOL] bucket1 = datastore . create_bucket ( bucket_id = bid , type = [string] , client = [string] , hostname = [string] , name = [string] ) [EOL] [comment] [EOL] e1 = Event ( data = { } , timestamp = starttime , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( data = { } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) [EOL] bucket1 . insert ( e1 ) [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] assert [number] == len ( result ) [EOL] finally : [EOL] datastore . delete_bucket ( bid ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_query_functions ( datastore ) : [EOL] [docstring] [EOL] bid = [string] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = starttime + timedelta ( hours = [number] ) [EOL] [EOL] example_query = [string] . format ( bid = bid , bid_escaped = bid . replace ( [string] , [string] ) ) [EOL] try : [EOL] bucket = datastore . create_bucket ( bucket_id = bid , type = [string] , client = [string] , hostname = [string] , name = [string] ) [EOL] bucket . insert ( Event ( data = { [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) , ) ) [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] assert result [ [string] ] == [number] [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [ [string] , [string] ] [EOL] finally : [EOL] datastore . delete_bucket ( bid ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_basic_query ( datastore ) : [EOL] name = [string] [EOL] bid1 = [string] [EOL] bid2 = [string] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = starttime + timedelta ( hours = [number] ) [EOL] [EOL] example_query = [string] . format ( bid1 = bid1 , bid2 = bid2 ) [EOL] [EOL] try : [EOL] [comment] [EOL] bucket1 = datastore . create_bucket ( bucket_id = bid1 , type = [string] , client = [string] , hostname = [string] , name = name ) [EOL] bucket2 = datastore . create_bucket ( bucket_id = bid2 , type = [string] , client = [string] , hostname = [string] , name = name ) [EOL] [comment] [EOL] e1 = Event ( data = { [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( data = { [string] : [string] } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) [EOL] et = Event ( data = { [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) , ) [EOL] bucket1 . insert ( e1 ) [EOL] bucket1 . insert ( e2 ) [EOL] bucket2 . insert ( et ) [EOL] [comment] [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] [comment] [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] finally : [EOL] datastore . delete_bucket ( bid1 ) [EOL] datastore . delete_bucket ( bid2 ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_test_merged_keys ( datastore ) : [EOL] name = [string] [EOL] bid = [string] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = starttime + timedelta ( hours = [number] ) [EOL] [EOL] example_query = [string] . format ( bid = bid ) [EOL] try : [EOL] [comment] [EOL] bucket1 = datastore . create_bucket ( bucket_id = bid , type = [string] , client = [string] , hostname = [string] , name = name ) [EOL] [comment] [EOL] e1 = Event ( data = { [string] : [string] , [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) , ) [EOL] e2 = Event ( data = { [string] : [string] , [string] : [string] } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) [EOL] e3 = Event ( data = { [string] : [string] , [string] : [string] } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) [EOL] bucket1 . insert ( e3 ) [EOL] bucket1 . insert ( e1 ) [EOL] bucket1 . insert ( e2 ) [EOL] [comment] [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] [comment] [EOL] print ( result ) [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] == [number] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == timedelta ( seconds = [number] ) [EOL] assert result [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] [ [string] ] == timedelta ( seconds = [number] ) [EOL] finally : [EOL] datastore . delete_bucket ( bid ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_fancy_query ( datastore ) : [EOL] [docstring] [EOL] name = [string] [EOL] bid1 = [string] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = starttime + timedelta ( hours = [number] ) [EOL] [EOL] example_query = [string] . format ( bid1 [ : [number] ] ) [EOL] [EOL] try : [EOL] [comment] [EOL] bucket_main = datastore . create_bucket ( bucket_id = bid1 , type = [string] , client = [string] , hostname = [string] , name = name ) [EOL] [comment] [EOL] e1 = Event ( data = { [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) , ) [EOL] bucket_main . insert ( e1 ) [EOL] [comment] [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] [comment] [EOL] assert result [ [number] ] [ [string] ] [ [string] ] == [string] [EOL] finally : [EOL] datastore . delete_bucket ( bid1 ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , param_datastore_objects ( ) ) def test_query2_query_categorize ( datastore ) : [EOL] bid = [string] [EOL] qname = [string] [EOL] starttime = iso8601 . parse_date ( [string] ) [EOL] endtime = starttime + timedelta ( hours = [number] ) [EOL] [EOL] example_query = [string] . format ( bid = bid ) [EOL] try : [EOL] bucket = datastore . create_bucket ( bucket_id = bid , type = [string] , client = [string] , hostname = [string] , name = [string] ) [EOL] events = [ Event ( data = { [string] : [string] } , timestamp = starttime , duration = timedelta ( seconds = [number] ) , ) , Event ( data = { [string] : [string] } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) , Event ( data = { [string] : [string] } , timestamp = starttime + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) , ) , ] [EOL] bucket . insert ( events ) [EOL] result = query ( qname , example_query , starttime , endtime , datastore ) [EOL] print ( result ) [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [ [string] ] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [ [string] , [string] ] [EOL] [EOL] assert len ( result [ [string] ] ) == [number] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [ [string] ] [EOL] assert result [ [string] ] [ [number] ] . data [ [string] ] == [ [string] , [string] ] [EOL] assert result [ [string] ] [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] finally : [EOL] datastore . delete_bucket ( bid ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Tuple , Any [EOL] import datetime [EOL] import aw_transform [EOL] import typing [EOL] import aw_core [EOL] from pprint import pprint [EOL] from datetime import datetime , timedelta , timezone [EOL] [EOL] from aw_core . models import Event [EOL] from aw_transform import ( filter_period_intersect , filter_keyvals_regex , filter_keyvals , period_union , sort_by_timestamp , sort_by_duration , sum_durations , merge_events_by_keys , chunk_events_by_key , split_url_events , simplify_string , union , categorize , tag , Rule , ) [EOL] from aw_transform . filter_period_intersect import _intersecting_eventpairs [EOL] [EOL] [EOL] def test_simplify_string ( ) : [EOL] events = [ Event ( data = { [string] : [string] } ) , Event ( data = { [string] : [string] } ) , ] [EOL] assert simplify_string ( events , [string] ) [ [number] ] . data [ [string] ] == [string] [EOL] assert simplify_string ( events , [string] ) [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] events = [ Event ( data = { [string] : [string] , [string] : [string] } ) ] [EOL] assert simplify_string ( events , [string] ) [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] events = [ Event ( data = { [string] : [string] , [string] : [string] } ) ] [EOL] assert ( simplify_string ( events , [string] ) [ [number] ] . data [ [string] ] == [string] ) [EOL] [EOL] events = [ Event ( data = { [string] : [string] , [string] : [string] } ) ] [EOL] assert simplify_string ( events , [string] ) [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] [EOL] def test_filter_keyval ( ) : [EOL] labels = [ [string] , [string] ] [EOL] events = [ Event ( data = { [string] : [string] } ) , Event ( data = { [string] : [string] } ) , Event ( data = { [string] : [string] } ) , ] [EOL] included_events = filter_keyvals ( events , [string] , labels ) [EOL] excluded_events = filter_keyvals ( events , [string] , labels , exclude = True ) [EOL] assert len ( included_events ) == [number] [EOL] assert len ( excluded_events ) == [number] [EOL] [EOL] [EOL] def test_filter_keyval_regex ( ) : [EOL] events = [ Event ( data = { [string] : [string] } ) , Event ( data = { [string] : [string] } ) , Event ( data = { [string] : [string] } ) , ] [EOL] events_re = filter_keyvals_regex ( events , [string] , [string] ) [EOL] assert len ( events_re ) == [number] [EOL] [EOL] [EOL] def test_intersecting_eventpairs ( ) : [EOL] td1h = timedelta ( hours = [number] ) [EOL] now = datetime . now ( ) [EOL] [EOL] [comment] [EOL] e1 = [ Event ( timestamp = now , duration = td1h ) , Event ( timestamp = now + td1h , duration = td1h ) , ] [EOL] e2 = [ Event ( timestamp = now , duration = td1h ) , Event ( timestamp = now + td1h , duration = td1h ) , ] [EOL] intersecting = list ( _intersecting_eventpairs ( e1 , e2 ) ) [EOL] assert len ( intersecting ) == [number] [EOL] [EOL] [comment] [EOL] e1 = [ Event ( timestamp = now + td1h , duration = td1h ) , ] [EOL] e2 = [ Event ( timestamp = now , duration = td1h ) , Event ( timestamp = now + [number] * td1h , duration = td1h ) , ] [EOL] intersecting = list ( _intersecting_eventpairs ( e1 , e2 ) ) [EOL] assert not intersecting [EOL] [EOL] [comment] [EOL] e1 = [ Event ( timestamp = now + td1h , duration = td1h ) , ] [EOL] e2 = [ Event ( timestamp = now , duration = td1h ) , Event ( timestamp = now + [number] * td1h , duration = td1h ) , Event ( timestamp = now + [number] * td1h , duration = td1h ) , ] [EOL] intersecting = list ( _intersecting_eventpairs ( e1 , e2 ) ) [EOL] assert len ( intersecting ) == [number] [EOL] [EOL] [comment] [EOL] e1 = list ( reversed ( e1 ) ) [EOL] e2 = list ( reversed ( e2 ) ) [EOL] intersecting = list ( _intersecting_eventpairs ( e1 , e2 ) ) [EOL] assert len ( intersecting ) == [number] [EOL] [EOL] [EOL] def test_filter_period_intersect ( ) : [EOL] td1h = timedelta ( hours = [number] ) [EOL] td30min = timedelta ( minutes = [number] ) [EOL] now = datetime . now ( ) [EOL] [EOL] [comment] [EOL] to_filter = [ Event ( timestamp = now , duration = td1h ) ] [EOL] filter_with = [ Event ( timestamp = now + td30min , duration = td1h ) ] [EOL] filtered_events = filter_period_intersect ( to_filter , filter_with ) [EOL] assert filtered_events [ [number] ] . duration == td30min [EOL] [EOL] [comment] [EOL] to_filter = [ Event ( timestamp = now , duration = td30min ) , Event ( timestamp = now + timedelta ( minutes = [number] ) , duration = td30min ) , ] [EOL] filter_with = [ Event ( timestamp = now + timedelta ( minutes = [number] ) , duration = timedelta ( minutes = [number] ) ) ] [EOL] filtered_events = filter_period_intersect ( to_filter , filter_with ) [EOL] assert len ( filtered_events ) == [number] [EOL] assert filtered_events [ [number] ] . duration == timedelta ( minutes = [number] ) [EOL] assert filtered_events [ [number] ] . duration == timedelta ( minutes = [number] ) [EOL] [EOL] [comment] [EOL] to_filter = [ Event ( timestamp = now + timedelta ( minutes = [number] ) , duration = timedelta ( minutes = [number] ) ) ] [EOL] filter_with = [ Event ( timestamp = now , duration = td30min ) , Event ( timestamp = now + timedelta ( minutes = [number] ) , duration = td30min ) , ] [EOL] filtered_events = filter_period_intersect ( to_filter , filter_with ) [EOL] assert len ( filtered_events ) == [number] [EOL] assert filtered_events [ [number] ] . duration == timedelta ( minutes = [number] ) [EOL] assert filtered_events [ [number] ] . duration == timedelta ( minutes = [number] ) [EOL] [EOL] [EOL] def test_period_union ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] [EOL] [comment] [EOL] events1 = [ Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) ] [EOL] events2 = [ Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ] [EOL] unioned_events = period_union ( events1 , events2 ) [EOL] assert len ( unioned_events ) == [number] [EOL] [EOL] [comment] [EOL] events1 = [ Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) ] [EOL] events2 = [ Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ] [EOL] unioned_events = period_union ( events1 , events2 ) [EOL] assert len ( unioned_events ) == [number] [EOL] [EOL] [comment] [EOL] events1 = [ Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) ] [EOL] events2 = [ Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ] [EOL] unioned_events = period_union ( events1 , events2 ) [EOL] assert len ( unioned_events ) == [number] [EOL] [EOL] [EOL] def test_sort_by_timestamp ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] events . append ( Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ) [EOL] events . append ( Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ) [EOL] events_sorted = sort_by_timestamp ( events ) [EOL] assert events_sorted == events [ : : - [number] ] [EOL] [EOL] [EOL] def test_sort_by_duration ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] events . append ( Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ) [EOL] events . append ( Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) ) [EOL] events_sorted = sort_by_duration ( events ) [EOL] assert events_sorted == events [ : : - [number] ] [EOL] [EOL] [EOL] def test_sum_durations ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] for i in range ( [number] ) : [EOL] events . append ( Event ( timestamp = now + timedelta ( seconds = i ) , duration = timedelta ( seconds = [number] ) ) ) [EOL] result = sum_durations ( events ) [EOL] assert result == timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def test_merge_events_by_keys_1 ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] e1_data = { [string] : [string] } [EOL] e2_data = { [string] : [string] } [EOL] e1 = Event ( data = e1_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( data = e2_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] events = events + [ e1 ] * [number] [EOL] events = events + [ e2 ] * [number] [EOL] [EOL] [comment] [EOL] assert merge_events_by_keys ( events , [ ] ) == events [EOL] [EOL] [comment] [EOL] assert len ( merge_events_by_keys ( events , [ [string] ] ) ) == [number] [EOL] [EOL] result = merge_events_by_keys ( events , [ [string] ] ) [EOL] result = sort_by_duration ( result ) [EOL] print ( result ) [EOL] print ( len ( result ) ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] assert result [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def test_merge_events_by_keys_2 ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] e1_data = { [string] : [string] , [string] : [string] } [EOL] e2_data = { [string] : [string] , [string] : [string] } [EOL] e3_data = { [string] : [string] , [string] : [string] } [EOL] e1 = Event ( data = e1_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( data = e2_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e3 = Event ( data = e3_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] events = events + [ e1 ] * [number] [EOL] events = events + [ e2 ] * [number] [EOL] events = events + [ e3 ] * [number] [EOL] result = merge_events_by_keys ( events , [ [string] , [string] ] ) [EOL] result = sort_by_duration ( result ) [EOL] print ( result ) [EOL] print ( len ( result ) ) [EOL] assert len ( result ) == [number] [EOL] assert result [ [number] ] . data == e1_data [EOL] assert result [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] assert result [ [number] ] . data == e2_data [EOL] assert result [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] assert result [ [number] ] . data == e3_data [EOL] assert result [ [number] ] . duration == timedelta ( seconds = [number] ) [EOL] [EOL] [EOL] def test_chunk_events_by_key ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] events = [ ] [EOL] e1_data = { [string] : [string] , [string] : [string] } [EOL] e2_data = { [string] : [string] , [string] : [string] } [EOL] e3_data = { [string] : [string] , [string] : [string] } [EOL] e1 = Event ( data = e1_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( data = e2_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e3 = Event ( data = e3_data , timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] events = [ e1 , e2 , e3 ] [EOL] result = chunk_events_by_key ( events , [string] ) [EOL] print ( len ( result ) ) [EOL] pprint ( result ) [EOL] assert len ( result ) == [number] [EOL] [comment] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] [comment] [EOL] assert result [ [number] ] . timestamp == e1 . timestamp [EOL] assert result [ [number] ] . timestamp == e3 . timestamp [EOL] [comment] [EOL] assert result [ [number] ] . duration == e1 . duration + e2 . duration [EOL] assert result [ [number] ] . duration == e3 . duration [EOL] [comment] [EOL] assert result [ [number] ] . data [ [string] ] [ [number] ] == e1 [EOL] assert result [ [number] ] . data [ [string] ] [ [number] ] == e2 [EOL] assert result [ [number] ] . data [ [string] ] [ [number] ] == e3 [EOL] [EOL] [EOL] def test_url_parse_event ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] e = Event ( data = { [string] : [string] } , timestamp = now , duration = timedelta ( seconds = [number] ) , ) [EOL] result = split_url_events ( [ e ] ) [EOL] print ( result ) [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] e2 = Event ( data = { [string] : [string] } , timestamp = now , duration = timedelta ( seconds = [number] ) , ) [EOL] result = split_url_events ( [ e2 ] ) [EOL] print ( result ) [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] e3 = Event ( data = { [string] : [string] } , timestamp = now , duration = timedelta ( seconds = [number] ) , ) [EOL] result = split_url_events ( [ e3 ] ) [EOL] print ( result ) [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] assert result [ [number] ] . data [ [string] ] == [string] [EOL] [EOL] [EOL] def test_union ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] [EOL] e1 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e3 = Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e4 = Event ( timestamp = now + timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] [EOL] [comment] [EOL] events_union = union ( [ e1 , e2 , e4 ] , [ e2 , e3 ] ) [EOL] assert events_union == [ e1 , e2 , e3 , e4 ] [EOL] [EOL] e1 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e3 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e4 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e5 = Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] [EOL] [comment] [EOL] events_union = union ( [ e3 , e2 , e5 ] , [ e1 , e3 , e4 , e5 ] ) [EOL] assert events_union == [ e1 , e2 , e3 , e4 , e5 ] [EOL] [EOL] e1 = Event ( timestamp = now - timedelta ( seconds = [number] ) , duration = timedelta ( seconds = [number] ) ) [EOL] e2 = Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e3 = Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] e4 = Event ( timestamp = now , duration = timedelta ( seconds = [number] ) ) [EOL] [EOL] [comment] [EOL] events_union = union ( [ e1 , e2 , e4 ] , [ e3 , e2 , e1 ] ) [EOL] assert events_union == [ e1 , e2 , e3 , e4 ] [EOL] [EOL] [EOL] def test_categorize ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] [EOL] classes = [ ( [ [string] ] , Rule ( { [string] : [string] } ) ) , ( [ [string] , [string] ] , Rule ( { [string] : [string] } ) ) , ( [ [string] , [string] ] , Rule ( { [string] : [string] , [string] : True } ) ) , ] [EOL] events = [ Event ( timestamp = now , duration = [number] , data = { [string] : [string] } ) , Event ( timestamp = now , duration = [number] , data = { [string] : [string] } ) , Event ( timestamp = now , duration = [number] , data = { [string] : [string] } ) , Event ( timestamp = now , duration = [number] , data = { } ) , ] [EOL] events = categorize ( events , classes ) [EOL] [EOL] assert events [ [number] ] . data [ [string] ] == [ [string] ] [EOL] assert events [ [number] ] . data [ [string] ] == [ [string] , [string] ] [EOL] assert events [ [number] ] . data [ [string] ] == [ [string] , [string] ] [EOL] assert events [ [number] ] . data [ [string] ] == [ [string] ] [EOL] [EOL] [EOL] def test_tags ( ) : [EOL] now = datetime . now ( timezone . utc ) [EOL] [EOL] classes = [ ( [string] , Rule ( { [string] : [string] } ) ) , ( [string] , Rule ( { [string] : [string] } ) ) , ] [EOL] events = [ Event ( timestamp = now , duration = [number] , data = { [string] : [string] } ) , Event ( timestamp = now , duration = [number] , data = { } ) , ] [EOL] events = tag ( events , classes ) [EOL] [EOL] assert len ( events [ [number] ] . data [ [string] ] ) == [number] [EOL] assert len ( events [ [number] ] . data [ [string] ] ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os [EOL] import sys [EOL] [EOL] [comment] [EOL] [comment] [EOL] sys . path . insert ( [number] , os . path . abspath ( [string] ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Any [EOL] import typing [EOL] import logging [EOL] import storages [EOL] import aw_datastore [EOL] import builtins [EOL] from typing import Optional , List [EOL] import os [EOL] import re [EOL] import logging [EOL] [EOL] from aw_core . dirs import get_data_dir [EOL] from . storages import AbstractStorage [EOL] [EOL] logger = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def detect_db_files ( data_dir , datastore_name = None , version = None ) : [EOL] db_files = [ filename for filename in os . listdir ( data_dir ) ] [EOL] if datastore_name : [EOL] db_files = [ filename for filename in db_files if filename . split ( [string] ) [ [number] ] == datastore_name ] [EOL] if version : [EOL] db_files = [ filename for filename in db_files if filename . split ( [string] ) [ [number] ] == [string] . format ( version ) ] [EOL] return db_files [EOL] [EOL] [EOL] def check_for_migration ( datastore ) : [EOL] data_dir = get_data_dir ( [string] ) [EOL] [EOL] if datastore . sid == [string] : [EOL] peewee_type = [string] [EOL] peewee_name = peewee_type + ( [string] if datastore . testing else [string] ) [EOL] [comment] [EOL] peewee_db_v2 = detect_db_files ( data_dir , peewee_name , [number] ) [EOL] if len ( peewee_db_v2 ) > [number] : [EOL] peewee_v2_to_sqlite_v1 ( datastore ) [EOL] [EOL] [EOL] def peewee_v2_to_sqlite_v1 ( datastore ) : [EOL] logger . info ( [string] ) [EOL] from . storages import PeeweeStorage [EOL] [EOL] pw_db = PeeweeStorage ( datastore . testing ) [EOL] [comment] [EOL] buckets = pw_db . buckets ( ) [EOL] [comment] [EOL] for bucket_id in buckets : [EOL] logger . info ( [string] . format ( bucket_id ) ) [EOL] bucket = buckets [ bucket_id ] [EOL] datastore . create_bucket ( bucket [ [string] ] , bucket [ [string] ] , bucket [ [string] ] , bucket [ [string] ] , bucket [ [string] ] , bucket [ [string] ] , ) [EOL] bucket_events = pw_db . get_events ( bucket_id , - [number] ) [EOL] datastore . insert_many ( bucket_id , bucket_events ) [EOL] logger . info ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Any [EOL] import typing [EOL] import builtins [EOL] import storages [EOL] from typing import Dict , Callable , Any [EOL] import platform as _platform [EOL] [EOL] from . migration import check_for_migration [EOL] [EOL] from . import storages [EOL] from . datastore import Datastore [EOL] [EOL] [comment] [EOL] [comment] [EOL] def get_storage_methods ( ) : [EOL] from . storages import MemoryStorage , MongoDBStorage , PeeweeStorage , SqliteStorage [EOL] [EOL] methods = { PeeweeStorage . sid : PeeweeStorage , MemoryStorage . sid : MemoryStorage , SqliteStorage . sid : SqliteStorage , } [EOL] [EOL] [comment] [EOL] if _platform . system ( ) == [string] : [comment] [EOL] try : [EOL] import pymongo [EOL] [EOL] methods [ MongoDBStorage . sid ] = MongoDBStorage [EOL] except ImportError : [comment] [EOL] pass [EOL] [EOL] return methods [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Callable[[typing.Any],storages.AbstractStorage]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Callable , Any [EOL] import aw_datastore [EOL] import typing [EOL] import datetime [EOL] import sys [EOL] from typing import Callable [EOL] from datetime import datetime , timedelta , timezone [EOL] from contextlib import contextmanager [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] from takethetime import ttt [EOL] [EOL] from aw_datastore import get_storage_methods , Datastore [EOL] from aw_datastore . storages import AbstractStorage [EOL] [EOL] [EOL] def create_test_events ( n ) : [EOL] now = datetime . now ( timezone . utc ) - timedelta ( days = [number] ) [EOL] [EOL] events = [ ] [EOL] for i in range ( n ) : [EOL] events . append ( Event ( timestamp = now + i * timedelta ( seconds = [number] ) , data = { [string] : [string] } ) ) [EOL] [EOL] return events [EOL] [EOL] [EOL] def create_tmpbucket ( ds , num ) : [EOL] bucket_id = [string] . format ( str ( num ) ) [EOL] try : [EOL] ds . delete_bucket ( bucket_id ) [EOL] except KeyError : [EOL] pass [EOL] ds . create_bucket ( bucket_id , [string] , [string] , [string] ) [EOL] return bucket_id [EOL] [EOL] [EOL] @ contextmanager def temporary_bucket ( ds ) : [EOL] bucket_id = [string] [EOL] try : [EOL] ds . delete_bucket ( bucket_id ) [EOL] except KeyError : [EOL] pass [EOL] bucket = ds . create_bucket ( bucket_id , [string] , [string] , [string] ) [EOL] yield bucket [EOL] ds . delete_bucket ( bucket_id ) [EOL] [EOL] [EOL] def benchmark ( storage ) : [EOL] ds = Datastore ( storage , testing = True ) [EOL] [EOL] num_single_events = [number] [EOL] num_replace_events = [number] [EOL] num_bulk_events = [number] * [number] ** [number] [EOL] num_events = num_single_events + num_replace_events + num_bulk_events + [number] [EOL] num_final_events = num_single_events + num_bulk_events + [number] [EOL] [EOL] events = create_test_events ( num_events ) [EOL] single_events = events [ : num_single_events ] [EOL] replace_events = events [ num_single_events : num_single_events + num_replace_events ] [EOL] bulk_events = events [ num_single_events + num_replace_events : - [number] ] [EOL] [EOL] print ( storage . __name__ ) [EOL] [EOL] with temporary_bucket ( ds ) as bucket : [EOL] with ttt ( [string] ) : [EOL] with ttt ( [string] . format ( num_single_events ) ) : [EOL] for event in single_events : [EOL] bucket . insert ( event ) [EOL] [EOL] with ttt ( [string] . format ( num_bulk_events ) ) : [EOL] bucket . insert ( bulk_events ) [EOL] [EOL] with ttt ( [string] . format ( num_replace_events ) ) : [EOL] for e in replace_events : [EOL] bucket . replace_last ( e ) [EOL] [EOL] with ttt ( [string] ) : [EOL] bucket . insert ( events [ - [number] ] ) [EOL] [EOL] with ttt ( [string] ) : [EOL] events_tmp = bucket . get ( limit = [number] ) [EOL] [EOL] with ttt ( [string] ) : [EOL] events_tmp = bucket . get ( ) [EOL] assert len ( events_tmp ) == num_final_events [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for storage in get_storage_methods ( ) . values ( ) : [EOL] if len ( sys . argv ) <= [number] or storage . __name__ in sys . argv : [EOL] benchmark ( storage ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Optional , List [EOL] import datetime [EOL] import typing [EOL] import builtins [EOL] import aw_core [EOL] import logging [EOL] from typing import List , Dict , Optional [EOL] from datetime import datetime [EOL] from abc import ABCMeta , abstractmethod , abstractproperty [EOL] [EOL] from aw_core . models import Event [EOL] [EOL] [EOL] class AbstractStorage ( metaclass = ABCMeta ) : [EOL] [docstring] [EOL] [EOL] sid = [string] [EOL] [EOL] @ abstractmethod def __init__ ( self , testing ) : [EOL] self . testing = True [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def buckets ( self ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def create_bucket ( self , bucket_id , type_id , client , hostname , created , name = None , ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def delete_bucket ( self , bucket_id ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def get_metadata ( self , bucket_id ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def get_events ( self , bucket_id , limit , starttime = None , endtime = None , ) : [EOL] raise NotImplementedError [EOL] [EOL] def get_eventcount ( self , bucket_id , starttime = None , endtime = None , ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def insert_one ( self , bucket_id , event ) : [EOL] raise NotImplementedError [EOL] [EOL] def insert_many ( self , bucket_id , events ) : [EOL] for event in events : [EOL] self . insert_one ( bucket_id , event ) [EOL] [EOL] @ abstractmethod def delete ( self , bucket_id , event_id ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def replace ( self , bucket_id , event_id , event ) : [EOL] raise NotImplementedError [EOL] [EOL] @ abstractmethod def replace_last ( self , bucket_id , event ) : [EOL] raise NotImplementedError [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.dict]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 $typing.Optional[datetime.datetime.datetime]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $aw_core.models.Event$ 0 0 0 $builtins.str$ 0 $aw_core.models.Event$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 $typing.List[aw_core.models.Event]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $aw_core.models.Event$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $aw_core.models.Event$ 0 0 0 0 0 0
import logging [EOL] import logging as _logging [EOL] [EOL] logger = _logging . getLogger ( __name__ ) [EOL] [EOL] from . abstract import AbstractStorage [EOL] [EOL] from . memory import MemoryStorage [EOL] from . mongodb import MongoDBStorage [EOL] from . peewee import PeeweeStorage [EOL] from . sqlite import SqliteStorage [EOL]	0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0