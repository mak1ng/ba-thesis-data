import safe_example [EOL] from statemachine import StateMachine , State , Transition [EOL] [EOL] [EOL] class Safe ( StateMachine ) : [EOL] def __init__ ( self , pin_code ) : [EOL] super ( ) . __init__ ( ) [EOL] [EOL] self . pin_code = pin_code [EOL] [EOL] self . add ( State ( [string] , is_starting_state = True ) ) [EOL] self . add ( State ( [string] ) ) [EOL] self . add ( State ( [string] ) ) [EOL] [EOL] self . add ( Transition ( [string] , [ [string] , [string] ] ) ) [EOL] self . add ( Transition ( [string] , [ [string] , [string] ] ) ) [EOL] [EOL] def try_combination ( self , combination ) : [EOL] if self . pin_code == combination and self . can_transition_to ( [string] ) : [EOL] self . transition_to ( [string] ) [EOL] [EOL] def lock ( self ) : [EOL] if self . can_transition_to ( [string] ) : [EOL] self . transition_to ( [string] ) [EOL] [EOL] def force_lock ( self ) : [EOL] if self . can_transition_to ( [string] ) : [EOL] self . transition_to ( [string] ) [EOL] [EOL] [EOL] safe = Safe ( pin_code = [number] ) [EOL] print ( safe . current_state ) [comment] [EOL] [EOL] safe . try_combination ( [number] ) [EOL] print ( safe . current_state ) [comment] [EOL] [EOL] safe . try_combination ( [number] ) [EOL] print ( safe . current_state ) [comment] [EOL] [EOL] safe . lock ( ) [EOL] print ( safe . current_state ) [comment] [EOL] [EOL] safe . force_lock ( ) [EOL] print ( safe . current_state ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0 0 0 $safe_example.Safe$ 0 0 0 0 0
import statemachine [EOL] from statemachine import Transition [EOL] [EOL] class TestContains ( ) : [EOL] def test_value_is_contained ( self ) : [EOL] assert [string] in Transition ( [string] , [ [string] , [string] , [string] ] ) [EOL] assert [string] in Transition ( [string] , [ [string] , [string] , [string] ] ) [EOL] assert [string] in Transition ( [string] , [ [string] , [string] , [string] ] ) [EOL] [EOL] def test_from_state_check ( self ) : [EOL] assert [string] not in Transition ( [string] , [ [string] ] ) [EOL] [EOL] def test_value_not_contained ( self ) : [EOL] assert [string] not in Transition ( [string] , [ [string] ] ) [EOL] [EOL] class TestHooks ( ) : [EOL] def test_empty_hooks ( self ) : [EOL] t = Transition ( [string] , [ [string] ] ) [EOL] assert t . before ( ) == None [EOL] assert t . after ( ) == None [EOL] [EOL] def sample_hook ( self , n ) : [EOL] def h ( ) : [EOL] return n [EOL] return h [EOL] [EOL] def test_before ( self ) : [EOL] t = Transition ( [string] , [ [string] ] , before = self . sample_hook ( [number] ) ) [EOL] assert t . before ( ) == [number] [EOL] assert t . after ( ) == None [EOL] [EOL] def test_after ( self ) : [EOL] t = Transition ( [string] , [ [string] ] , after = self . sample_hook ( [number] ) ) [EOL] assert t . after ( ) == [number] [EOL] assert t . before ( ) == None [EOL] [EOL] def test_both_hooks ( self ) : [EOL] t = Transition ( [string] , [ [string] ] , before = self . sample_hook ( [number] ) , after = self . sample_hook ( [number] ) ) [EOL] assert t . before ( ) == [number] [EOL] assert t . after ( ) == [number] [EOL] [EOL] class TestConstruction ( ) : [EOL] def test_standard_construction ( self ) : [EOL] t = Transition ( [string] , [ [string] , [string] ] ) [EOL] assert t . from_state_name == [string] [EOL] assert t . to_states_names == [ [string] , [string] ] [EOL] [EOL] class Test_String ( ) : [EOL] def test_string_representation ( self ) : [EOL] t = Transition ( [string] , [ [string] , [string] ] ) [EOL] assert str ( t ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0
	0
from typing import List , Any [EOL] import typing [EOL] import statemachine [EOL] import pytest [EOL] [EOL] from statemachine import StateMachine , State , Transition [EOL] [EOL] def test_creation ( ) : [EOL] sm = StateMachine ( ) [EOL] assert sm . states == { } [EOL] assert sm . current_state == None [EOL] assert sm . transitions == { } [EOL] [EOL] class TestAdd ( ) : [EOL] def test_add_state ( self ) : [EOL] sm = StateMachine ( ) [EOL] [EOL] s = State ( [string] ) [EOL] sm . add ( s ) [EOL] assert sm . states == { [string] : s } [EOL] [EOL] def test_add_Transition ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] t = Transition ( [string] , [ [string] ] ) [EOL] sm . add ( t ) [EOL] assert sm . transitions == { [string] : t } [EOL] [EOL] def test_new_transition_needs_existing_from_state ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] t = Transition ( [string] , [ [string] ] ) [EOL] sm . add ( t ) [EOL] [EOL] def test_new_transition_needs_existing_to_state ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] with pytest . raises ( AssertionError ) : [EOL] t = Transition ( [string] , [ [string] ] ) [EOL] sm . add ( t ) [EOL] [EOL] def test_adding_invalid_type ( self ) : [EOL] sm = StateMachine ( ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] sm . add ( [string] ) [EOL] [EOL] class TestCanTransitonTo ( ) : [EOL] def test_can_transition ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] , is_starting_state = True ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] , [string] ] ) ) [EOL] [EOL] assert sm . can_transition_to ( [string] ) [EOL] assert sm . can_transition_to ( [string] ) [EOL] [EOL] def test_cant_transition_without_starting_state ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] , [string] ] ) ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] sm . can_transition_to ( [string] ) [EOL] sm . can_transition_to ( [string] ) [EOL] [EOL] def test_transitions_arent_two_way ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] , is_starting_state = True ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] ] ) ) [EOL] [EOL] assert not sm . can_transition_to ( [string] ) [EOL] [EOL] def test_cant_transition_to_undefined_state ( self ) : [EOL] sm = StateMachine ( ) [EOL] [EOL] with pytest . raises ( Exception ) : [EOL] sm . can_transition_to ( [string] ) [EOL] [EOL] class TestTransition ( ) : [EOL] def test_cant_transition_where_cant_transition_to ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] , is_starting_state = True ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] ] ) ) [EOL] [EOL] assert not sm . can_transition_to ( [string] ) [EOL] with pytest . raises ( Exception ) : [EOL] sm . transition_to ( [string] ) [EOL] [EOL] def test_hooks_order ( self ) : [EOL] result = [ ] [EOL] def hook ( s ) : [EOL] def h ( ) : [EOL] result . append ( s ) [EOL] return h [EOL] [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] , is_starting_state = True , will_exit = hook ( [string] ) , exited = hook ( [string] ) ) ) [EOL] sm . add ( State ( [string] , will_enter = hook ( [string] ) , entered = hook ( [string] ) ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] ] , before = hook ( [string] ) , after = hook ( [string] ) ) ) [EOL] sm . transition_to ( [string] ) [EOL] [EOL] assert result == [ [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] def test_transition ( self ) : [EOL] sm = StateMachine ( ) [EOL] sm . add ( State ( [string] , is_starting_state = True ) ) [EOL] sm . add ( State ( [string] ) ) [EOL] [EOL] sm . add ( Transition ( [string] , [ [string] ] ) ) [EOL] sm . transition_to ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 $statemachine.state.State$ 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 $statemachine.transition.Transition$ 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 $statemachine.transition.Transition$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.StateMachine$ 0 0 0 0 0 0
import statemachine [EOL] from statemachine import State [EOL] [EOL] def test_string ( ) : [EOL] s = State ( [string] ) [EOL] assert str ( s ) == [string] [EOL] [EOL] class TestHooks : [EOL] def test_empty ( self ) : [EOL] s = State ( [string] ) [EOL] assert s . will_enter ( ) == None [EOL] assert s . will_exit ( ) == None [EOL] assert s . entered ( ) == None [EOL] assert s . exited ( ) == None [EOL] [EOL] def sample_hook ( self , n ) : [EOL] def h ( ) : [EOL] return n [EOL] return h [EOL] [EOL] def test_hooks ( self ) : [EOL] s = State ( [string] , will_enter = self . sample_hook ( [string] ) , will_exit = self . sample_hook ( [string] ) , entered = self . sample_hook ( [string] ) , exited = self . sample_hook ( [string] ) ) [EOL] [EOL] assert s . will_enter ( ) == [string] [EOL] assert s . will_exit ( ) == [string] [EOL] assert s . entered ( ) == [string] [EOL] assert s . exited ( ) == [string] [EOL] [EOL] class TestStartingState ( ) : [EOL] def test_is_not ( self ) : [EOL] s = State ( [string] ) [EOL] assert not s . is_starting_state [EOL] [EOL] def test_is ( self ) : [EOL] s = State ( [string] , is_starting_state = True ) [EOL] assert s . is_starting_state [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0 0 0 0 0 0 0 0 0 $statemachine.state.State$ 0 0 0
from typing import List , Optional , Callable [EOL] import builtins [EOL] import typing [EOL] from typing import List , Optional , Callable [EOL] [EOL] class Transition ( ) : [EOL] def __init__ ( self , from_state_name , to_states_names , before = None , after = None ) : [EOL] [EOL] self . from_state_name = from_state_name [EOL] self . to_states_names = to_states_names [EOL] [EOL] self . before = before if before else lambda : None [EOL] self . after = after if after else lambda : None [EOL] [EOL] def __str__ ( self ) : [EOL] return self . from_state_name + [string] + [string] . join ( self . to_states_names ) [EOL] [EOL] def __contains__ ( self , state_name ) : [EOL] return state_name in self . to_states_names [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Callable , Optional [EOL] import builtins [EOL] import typing [EOL] from typing import Optional , Callable [EOL] [EOL] class State : [EOL] def __init__ ( self , name , is_starting_state = False , will_enter = None , entered = None , will_exit = None , exited = None ) : [EOL] [EOL] self . is_starting_state = is_starting_state [EOL] self . name = name [EOL] [EOL] self . will_enter = will_enter if will_enter else lambda : None [EOL] self . entered = entered if entered else lambda : None [EOL] self . will_exit = will_exit if will_exit else lambda : None [EOL] self . exited = exited if exited else lambda : None [EOL] [EOL] def __str__ ( self ) : [EOL] return self . name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Callable , Union , Optional [EOL] import builtins [EOL] import typing [EOL] import statemachine [EOL] name = [string] [EOL] [EOL] from typing import Dict , Union , Optional , Callable [EOL] [EOL] from statemachine . state import State [EOL] from statemachine . transition import Transition [EOL] [EOL] class StateMachine : [EOL] def __init__ ( self ) : [EOL] self . states = { } [EOL] self . current_state = None [EOL] self . transitions = { } [EOL] self . add_overloads = { [string] : self . _add_state , [string] : self . _add_transition } [EOL] [EOL] def add ( self , new ) : [EOL] self . add_overloads [ type ( new ) . __name__ ] ( new ) [EOL] [EOL] def _add_state ( self , new_state ) : [EOL] self . states [ new_state . name ] = new_state [EOL] if new_state . is_starting_state : [EOL] self . current_state = new_state [EOL] [EOL] def _add_transition ( self , t ) : [EOL] is_declared = lambda k : k in self . states [EOL] assert is_declared ( t . from_state_name ) , [string] [EOL] assert all ( t for t in map ( is_declared , t . to_states_names ) ) , [string] [EOL] self . transitions [ t . from_state_name ] = t [EOL] [EOL] def can_transition_to ( self , state_name ) : [EOL] assert ( state_name in self . states . keys ( ) ) , [string] + state_name [EOL] [EOL] if self . current_state is None : [EOL] raise Exception [EOL] return ( self . current_state . name in self . transitions . keys ( ) ) and ( state_name in self . transitions [ self . current_state . name ] ) [EOL] [EOL] def transition_to ( self , state_name ) : [EOL] if self . can_transition_to ( state_name ) : [EOL] transition = self . transitions [ self . current_state . name ] [EOL] old_state = self . current_state [EOL] new_state = self . states [ state_name ] [EOL] [EOL] transition . before ( ) [EOL] self . current_state . will_exit ( ) [EOL] new_state . will_enter ( ) [EOL] [EOL] self . current_state = new_state [EOL] [EOL] old_state . exited ( ) [EOL] self . current_state . entered ( ) [EOL] transition . after ( ) [EOL] else : [EOL] raise Exception [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[statemachine.state.State]$ 0 0 0 0 0 0 0 0 $typing.Optional[statemachine.state.State]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[statemachine.state.State]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[statemachine.state.State]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[statemachine.state.State]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0