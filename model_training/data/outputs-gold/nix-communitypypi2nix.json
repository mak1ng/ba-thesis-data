[comment] [EOL] [EOL] from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , List [EOL] import pathlib [EOL] import pypi2nix [EOL] import unittests [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import os . path [EOL] import pathlib [EOL] import venv [EOL] from io import StringIO [EOL] from typing import Any [EOL] from typing import Generator [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . archive import Archive [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . pip import VirtualenvPip [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import Requirement [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import PlatformGenerator [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . wheel import Wheel [EOL] from pypi2nix . wheel_builder import WheelBuilder [EOL] from unittests . package_generator import PackageGenerator [EOL] [EOL] [EOL] class MyInt ( int ) : [EOL] def tolles_feature ( self ) : [EOL] print ( [string] ) [EOL] [EOL] [EOL] DATA_DIRECTORY = os . path . join ( os . path . dirname ( __file__ ) , [string] , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def nix ( logger ) : [EOL] return Nix ( logger ) [EOL] [EOL] [EOL] @ pytest . fixture def project_dir ( tmpdir_factory ) : [EOL] path = tmpdir_factory . mktemp ( [string] ) [EOL] return str ( path ) [EOL] [EOL] [EOL] @ pytest . fixture def download_dir ( project_dir ) : [EOL] path = os . path . join ( project_dir , [string] ) [EOL] os . makedirs ( path ) [EOL] return Path ( path ) [EOL] [EOL] [EOL] @ pytest . fixture def wheels_dir ( project_dir ) : [EOL] path = os . path . join ( project_dir , [string] ) [EOL] os . makedirs ( path ) [EOL] return Path ( path ) [EOL] [EOL] [EOL] @ pytest . fixture def wheel_builder ( pip , project_dir , logger , requirement_parser , current_platform , base_dependency_graph , ) : [EOL] base_dir = Path ( project_dir ) [EOL] return WheelBuilder ( pip = pip , download_directory = base_dir / [string] , lib_directory = base_dir / [string] , wheel_directory = base_dir / [string] , extracted_wheel_directory = base_dir / [string] , logger = logger , requirement_parser = requirement_parser , target_platform = current_platform , base_dependency_graph = base_dependency_graph , ) [EOL] [EOL] [EOL] @ pytest . fixture def base_dependency_graph ( ) : [EOL] return DependencyGraph ( ) [EOL] [EOL] [EOL] @ pytest . fixture def extracted_six_package ( six_requirements , wheel_builder , current_platform , logger , requirement_parser , ) : [EOL] wheels = wheel_builder . build ( six_requirements ) [EOL] for wheel_directory in wheels : [EOL] wheel = Wheel . from_wheel_directory_path ( wheel_directory , current_platform , logger , requirement_parser ) [EOL] if wheel . name == [string] : [EOL] return wheel_directory [EOL] raise Exception ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def six_requirements ( current_platform , requirement_parser ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] return requirements [EOL] [EOL] [EOL] @ pytest . fixture def six_source_distribution_archive ( data_directory ) : [EOL] return Archive ( path = os . path . join ( data_directory , [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture def distribution_archive_for_jsonschema ( data_directory ) : [EOL] return Archive ( path = os . path . join ( data_directory , [string] ) ) [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] ) ) def requirement ( request , requirement_parser ) : [EOL] return requirement_parser . parse ( request . param ) [EOL] [EOL] [EOL] @ pytest . fixture def setupcfg_package_wheel_path ( data_directory ) : [EOL] return os . path . join ( data_directory , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def setupcfg_package_wheel ( setupcfg_package_wheel_path , logger , requirement_parser , current_platform , ) : [EOL] archive = Archive ( path = setupcfg_package_wheel_path ) [EOL] with archive . extracted_files ( ) as directory : [EOL] return Wheel . from_wheel_directory_path ( os . path . join ( directory , [string] ) , current_platform , logger , requirement_parser , ) [EOL] [EOL] [EOL] @ pytest . fixture def pip ( logger , current_platform , project_dir , wheel_distribution_archive_path , data_directory , requirement_parser , package_source_directory , ) : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = os . path . join ( project_dir , [string] ) , env_builder = venv . EnvBuilder ( with_pip = True ) , no_index = True , wheel_distribution_path = wheel_distribution_archive_path , find_links = [ data_directory , str ( package_source_directory ) ] , requirement_parser = requirement_parser , ) [EOL] pip . prepare_virtualenv ( ) [EOL] return pip [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] ) ) def source_distribution_archive ( request , data_directory ) : [EOL] return Archive ( path = os . path . join ( data_directory , request . param ) ) [EOL] [EOL] [EOL] @ pytest . fixture def platform_generator ( nix , logger ) : [EOL] return PlatformGenerator ( nix , logger ) [EOL] [EOL] [EOL] @ pytest . fixture def current_platform ( platform_generator ) : [EOL] platform = platform_generator . current_platform ( ) [EOL] if platform is None : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] return platform [EOL] [EOL] [EOL] @ pytest . fixture def test_txt_content ( ) : [EOL] path = os . path . join ( DATA_DIRECTORY , [string] ) [EOL] with open ( path ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] @ pytest . fixture def test_tar_gz_path ( ) : [EOL] return os . path . join ( DATA_DIRECTORY , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def test_zip_path ( ) : [EOL] return os . path . join ( DATA_DIRECTORY , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def test_tar_bz2_path ( ) : [EOL] return os . path . join ( DATA_DIRECTORY , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def data_directory ( ) : [EOL] return DATA_DIRECTORY [EOL] [EOL] [EOL] @ pytest . fixture def logger ( ) : [EOL] with StringIO ( ) as f : [EOL] yield StreamLogger ( output = f ) [EOL] [EOL] [EOL] @ pytest . fixture def requirement_parser ( logger ) : [EOL] return RequirementParser ( logger = logger ) [EOL] [EOL] [EOL] @ pytest . fixture def wheel_distribution_archive_path ( data_directory ) : [EOL] return os . path . join ( data_directory , [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def sources_for_test_packages ( data_directory ) : [EOL] sources = Sources ( ) [EOL] package_names = [ [string] , [string] , [string] , [string] , [string] ] [EOL] for package_name in package_names : [EOL] sources . add ( package_name , PathSource ( os . path . join ( data_directory , f"{ package_name } [string] " ) ) , ) [EOL] return sources [EOL] [EOL] [EOL] @ pytest . fixture def pypi ( logger ) : [EOL] return Pypi ( logger = logger ) [EOL] [EOL] [EOL] @ pytest . fixture def flit_wheel ( data_directory , current_platform , logger , requirement_parser ) : [EOL] path = os . path . join ( data_directory , [string] ) [EOL] with Archive ( path = path ) . extracted_files ( ) as wheel_directory : [EOL] return Wheel . from_wheel_directory_path ( os . path . join ( wheel_directory , [string] ) , current_platform , logger , requirement_parser , ) [EOL] [EOL] [EOL] @ pytest . fixture def package_source_directory ( tmpdir_factory ) : [EOL] path_as_str = str ( tmpdir_factory . mktemp ( [string] ) ) [EOL] return Path ( path_as_str ) [EOL] [EOL] [EOL] @ pytest . fixture def package_generator ( package_source_directory , logger , requirement_parser , ) : [EOL] return PackageGenerator ( target_directory = pathlib . Path ( str ( package_source_directory ) ) , requirement_parser = requirement_parser , logger = logger , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.nix.Nix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.wheel_builder.WheelBuilder$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pip.VirtualenvPip$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.PlatformGenerator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Generator[pypi2nix.logger.Logger,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pypi.Pypi$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $unittests.package_generator.PackageGenerator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] from typing import Any [EOL] [EOL] [EOL] def setup ( * args , ** kwargs ) : [comment] [EOL] ... [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . environment_marker import EnvironmentMarker [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , [string] , [string] ) ) def test_that_version_comparisons_do_not_throw ( operator , current_platform ) : [EOL] marker = EnvironmentMarker ( f" [string] { operator } [string] " ) [EOL] marker . applies_to_platform ( current_platform ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pytest [EOL] [EOL] nix = pytest . mark . nix [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pypi2nix [EOL] import os . path [EOL] import tempfile [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . network_file import DiskTextFile [EOL] from pypi2nix . network_file import GitTextFile [EOL] from pypi2nix . network_file import NetworkFile [EOL] from pypi2nix . network_file import UrlTextFile [EOL] from pypi2nix . nix import Nix [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ nix def test_calculate_sha256_for_text_file ( logger ) : [EOL] test_file = UrlTextFile ( url = [string] , logger = logger , name = [string] , ) [EOL] assert [string] in test_file . fetch ( ) [EOL] assert [string] == test_file . sha256 [EOL] [EOL] [EOL] @ nix def test_can_evaluate_expression_of_fetched_file ( logger , nix ) : [EOL] test_file = UrlTextFile ( url = [string] , logger = logger , name = [string] , ) [EOL] nix . build_expression ( expression = f" [string] { test_file . nix_expression ( ) }" ) [EOL] [EOL] [EOL] @ nix def test_can_calculate_hash_for_git_files ( logger ) : [EOL] repository_url = [string] [EOL] path = [string] [EOL] revision_name = [string] [EOL] network_file = GitTextFile ( repository_url = repository_url , revision_name = revision_name , path = path , logger = logger , ) [EOL] [EOL] assert network_file . sha256 == [string] [EOL] assert [string] in network_file . fetch ( ) [EOL] [EOL] [EOL] @ nix def test_can_evaluate_nix_expression ( network_file , nix ) : [EOL] expression = f" [string] { network_file . nix_expression ( ) }" [EOL] nix . evaluate_expression ( expression ) [EOL] [EOL] [EOL] @ nix def test_fetch_content_equals_file_content_from_nix_expression ( network_file , nix ) : [EOL] fetch_content = network_file . fetch ( ) [EOL] [EOL] nix_expression = [string] [EOL] nix_expression += [string] [EOL] nix_expression += f" [string] { network_file . nix_expression ( ) } [string] " [EOL] nix_expression += [string] [EOL] nix_expression += [string] [EOL] with tempfile . TemporaryDirectory ( ) as target_directory : [EOL] target_file = os . path . join ( target_directory , [string] ) [EOL] nix . build_expression ( nix_expression , out_link = target_file ) [EOL] with open ( target_file ) as f : [EOL] nix_content = f . read ( ) [EOL] assert nix_content == fetch_content [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] , [string] ] ) def network_file ( logger , request , data_directory ) : [EOL] if request . param == [string] : [EOL] return UrlTextFile ( url = [string] , logger = logger , name = [string] , ) [EOL] elif request . param == [string] : [EOL] return DiskTextFile ( path = os . path . join ( data_directory , [string] ) , ) [EOL] else : [EOL] repository_url = [string] [EOL] path = [string] [EOL] revision_name = [string] [EOL] return GitTextFile ( repository_url = repository_url , revision_name = revision_name , path = path , logger = logger , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import pytest [EOL] from parsley import ParseError [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements import PathRequirement [EOL] [EOL] from . logger import get_logger_output [EOL] [EOL] [EOL] def test_parses_pip_style_url ( requirement_parser ) : [EOL] requirement_parser . compiled_grammar ( ) ( [string] ) . URI_pip_style ( ) [EOL] [EOL] [EOL] def test_parse_pip_style_requirement ( requirement_parser ) : [EOL] requirement_parser . compiled_grammar ( ) ( [string] ) . url_req_pip_style ( ) [EOL] [EOL] [EOL] def test_that_python_implemntation_marker_can_be_parsed ( requirement_parser ) : [EOL] requirement_parser . compiled_grammar ( ) ( [string] ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] ) ) def test_that_file_path_with_leading_slash_can_be_parsed ( path , requirement_parser ) : [EOL] assert requirement_parser . compiled_grammar ( ) ( path ) . file_path ( ) == path [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , [string] ) ) def test_that_path_with_hashpound_is_not_recognized ( path , requirement_parser ) : [EOL] with pytest . raises ( ParseError ) : [EOL] requirement_parser . compiled_grammar ( ) ( path ) . file_path ( ) [EOL] [EOL] [EOL] def test_that_we_can_parse_pip_style_requirement_with_file_path ( requirement_parser ) : [EOL] requirement = requirement_parser . compiled_grammar ( ) ( [string] ) . path_req_pip_style ( ) [EOL] assert requirement . name ( ) == [string] [EOL] assert requirement . path ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , ) , ) def test_regressions_with_cryptography ( requirement_parser , line , logger ) : [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert requirement . name ( ) == [string] [EOL] assert [string] in get_logger_output ( logger ) [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_that_path_is_parsed_to_path_requirement ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , PathRequirement ) [EOL] [EOL] [EOL] def test_that_requirement_parser_does_not_choke_on_sys_dot_platform ( requirement_parser , logger ) : [EOL] line = [string] [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert requirement . name ( ) == [string] [EOL] assert [string] in get_logger_output ( logger ) [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_that_comment_is_parsed_correctly ( requirement_parser ) : [EOL] comment_string = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( comment_string ) . comment ( ) [EOL] assert result == [string] [EOL] [EOL] [EOL] def test_that_comment_without_string_after_it_is_parsed_correctly ( requirement_parser , ) : [EOL] comment_string = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( comment_string ) . comment ( ) [EOL] assert result == [string] [EOL] [EOL] [EOL] def test_that_name_requirements_can_have_comments ( requirement_parser , ) : [EOL] line = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( line ) . name_req ( ) [EOL] assert result . name ( ) == [string] [EOL] [EOL] [EOL] def test_that_url_req_can_have_comments ( requirement_parser ) : [EOL] line = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( line ) . url_req ( ) [EOL] assert result . name ( ) == [string] [EOL] [EOL] [EOL] def test_that_url_req_pip_style_can_have_comments ( requirement_parser , ) : [EOL] line = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( line ) . url_req_pip_style ( ) [EOL] assert result . name ( ) == [string] [EOL] [EOL] [EOL] def test_that_path_req_pip_style_can_have_comments ( requirement_parser , ) : [EOL] line = [string] [EOL] result = requirement_parser . compiled_grammar ( ) ( line ) . path_req_pip_style ( ) [EOL] assert result . name ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import shutil [EOL] import subprocess [EOL] from tempfile import TemporaryDirectory [EOL] from typing import List [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] from pypi2nix . archive import Archive [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . source_distribution import SourceDistribution [EOL] [EOL] from . templates import render_template [EOL] [EOL] [EOL] @ attrs class PackageGenerator : [EOL] [docstring] [EOL] [EOL] _target_directory = attrib ( ) [EOL] _requirement_parser = attrib ( ) [EOL] _logger = attrib ( ) [EOL] [EOL] def generate_setuptools_package ( self , name , version = [string] , install_requires = [ ] ) : [EOL] with TemporaryDirectory ( ) as directory_path_string : [EOL] build_directory = Path ( directory_path_string ) [EOL] self . _generate_setup_py ( build_directory , name = name , version = version ) [EOL] self . _generate_setup_cfg ( build_directory , name = name , version = version , install_requires = install_requires , ) [EOL] built_distribution_archive = self . _build_package ( build_directory = build_directory , name = name , version = version ) [EOL] source_distribution = SourceDistribution . from_archive ( built_distribution_archive , logger = self . _logger , requirement_parser = self . _requirement_parser , ) [EOL] self . _move_package_target_directory ( built_distribution_archive ) [EOL] return source_distribution [EOL] [EOL] def _generate_setup_py ( self , target_directory , name , version ) : [EOL] content = render_template ( Path ( [string] ) , context = { } , ) [EOL] ( target_directory / [string] ) . write_text ( content ) [EOL] [EOL] def _generate_setup_cfg ( self , target_directory , name , version , install_requires , ) : [EOL] content = render_template ( Path ( [string] ) , context = { [string] : name , [string] : version , [string] : install_requires , } , ) [EOL] ( target_directory / [string] ) . write_text ( content ) [EOL] [EOL] def _build_package ( self , build_directory , name , version ) : [EOL] subprocess . run ( [ [string] , [string] , [string] ] , cwd = str ( build_directory ) , check = True ) [EOL] tar_gz_path = build_directory / [string] / f"{ name } [string] { version } [string] " [EOL] return Archive ( path = str ( tar_gz_path ) ) [EOL] [EOL] def _move_package_target_directory ( self , distribution_archive ) : [EOL] shutil . copy ( distribution_archive . path , str ( self . _target_directory ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 $pypi2nix.source_distribution.SourceDistribution$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 $pypi2nix.path.Path$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 $typing.Any$ 0 $pypi2nix.path.Path$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import typing [EOL] import json [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ pytest . fixture def wheel ( current_platform ) : [EOL] build_dependencies = RequirementSet ( current_platform ) [EOL] dependencies = RequirementSet ( current_platform ) [EOL] return Wheel ( name = [string] , version = [string] , deps = dependencies , homepage = [string] , license = [string] , description = [string] , build_dependencies = build_dependencies , target_platform = current_platform , ) [EOL] [EOL] [EOL] @ nix def test_can_create_wheel_from_valid_directory ( extracted_six_package , current_platform , logger , requirement_parser , ) : [EOL] Wheel . from_wheel_directory_path ( extracted_six_package , current_platform , logger , requirement_parser ) [EOL] [EOL] [EOL] @ nix def test_can_add_build_dependencies_to_wheel ( wheel , current_platform , requirement_parser , ) : [EOL] build_dependencies = RequirementSet ( current_platform ) [EOL] build_dependencies . add ( requirement_parser . parse ( [string] ) ) [EOL] build_dependencies . add ( requirement_parser . parse ( [string] ) ) [EOL] wheel . add_build_dependencies ( build_dependencies ) [EOL] assert [string] in wheel . build_dependencies ( current_platform ) [EOL] assert [string] in wheel . build_dependencies ( current_platform ) [EOL] [EOL] [EOL] def test_that_to_dict_is_json_serializable ( wheel ) : [EOL] json . dumps ( wheel . to_dict ( ) ) [EOL] [EOL] [EOL] def test_that_setupcfg_package_wheel_contains_requests_as_dependency ( setupcfg_package_wheel , ) : [EOL] assert [string] in setupcfg_package_wheel . dependencies ( ) [EOL] [EOL] [EOL] def test_that_setupcfg_package_wheel_contains_pytest_as_testing_dependency ( setupcfg_package_wheel , ) : [EOL] assert [string] in setupcfg_package_wheel . dependencies ( extras = [ [string] ] ) [EOL] [EOL] [EOL] def test_that_setupcfg_package_wheel_does_not_contain_pytest_as_non_testing_dependency ( setupcfg_package_wheel , ) : [EOL] assert [string] not in setupcfg_package_wheel . dependencies ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pypi2nix [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . pypi import Pypi [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ pytest . fixture def pypi ( logger ) : [EOL] return Pypi ( logger ) [EOL] [EOL] [EOL] @ nix def test_pypi_get_package_returns_package_with_correct_name ( pypi ) : [EOL] assert pypi . get_package ( [string] ) . name == [string] [EOL] [EOL] [EOL] @ nix def test_pypi_get_package_returns_package_with_releases ( pypi ) : [EOL] assert pypi . get_package ( [string] ) . releases [EOL] [EOL] [EOL] @ nix def test_pypi_gets_correct_source_release_for_package_version_with_only_source_release ( pypi , ) : [EOL] release = pypi . get_source_release ( [string] , [string] ) [EOL] assert ( release . sha256_digest == [string] ) [EOL] [EOL] [EOL] @ nix def test_pypi_gets_correct_source_release_for_package_with_multiple_release_types ( pypi ) : [EOL] release = pypi . get_source_release ( [string] , [string] ) [EOL] assert ( release . sha256_digest == [string] ) [EOL] [EOL] [EOL] @ nix def test_pypi_gets_correct_source_release_for_radiotherm_1_2 ( pypi ) : [EOL] release = pypi . get_source_release ( [string] , [string] ) [EOL] assert ( release . sha256_digest == [string] ) [EOL] [EOL] [EOL] @ nix def test_pypi_gets_correct_source_release_for_setuptools_1_6_0 ( pypi ) : [EOL] release = pypi . get_source_release ( [string] , [string] ) [EOL] assert ( release . sha256_digest == [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import typing [EOL] import os [EOL] import os . path [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . archive import Archive [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package . exceptions import DistributionNotDetected [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . source_distribution import SourceDistribution [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . logger import get_logger_output [EOL] from . switches import nix [EOL] [EOL] [EOL] @ pytest . fixture def source_distribution ( six_source_distribution_archive , logger , requirement_parser , ) : [EOL] return SourceDistribution . from_archive ( six_source_distribution_archive , logger , requirement_parser = requirement_parser ) [EOL] [EOL] [EOL] @ pytest . fixture def flit_distribution ( data_directory , logger , requirement_parser ) : [EOL] archive = Archive ( os . path . join ( data_directory , [string] ) ) [EOL] return SourceDistribution . from_archive ( archive , logger , requirement_parser = requirement_parser ) [EOL] [EOL] [EOL] @ nix def test_from_archive_picks_up_on_name ( source_distribution ) : [EOL] assert source_distribution . name == [string] [EOL] [EOL] [EOL] @ nix def test_that_a_source_distributions_name_is_canonicalized ( logger , requirement_parser ) : [EOL] distribution = SourceDistribution ( name = [string] , logger = logger , requirement_parser = requirement_parser ) [EOL] assert distribution . name == [string] [EOL] [EOL] [EOL] @ nix def test_six_package_has_no_pyproject_toml ( source_distribution ) : [EOL] assert source_distribution . pyproject_toml is None [EOL] [EOL] [EOL] @ nix def test_that_flit_pyproject_toml_is_recognized ( flit_distribution ) : [EOL] assert flit_distribution . pyproject_toml is not None [EOL] [EOL] [EOL] @ nix def test_that_flit_build_dependencies_contains_requests ( flit_distribution , current_platform ) : [EOL] assert [string] in flit_distribution . build_dependencies ( current_platform ) [EOL] [EOL] [EOL] @ nix def test_that_we_can_generate_objects_from_source_archives ( source_distribution_archive , logger , requirement_parser , ) : [EOL] SourceDistribution . from_archive ( source_distribution_archive , logger , requirement_parser = requirement_parser ) [EOL] [EOL] [EOL] @ nix def test_that_we_can_detect_setup_requirements_for_setup_cfg_projects ( distribution_archive_for_jsonschema , current_platform , logger , requirement_parser , ) : [EOL] distribution = SourceDistribution . from_archive ( distribution_archive_for_jsonschema , logger , requirement_parser = requirement_parser , ) [EOL] assert [string] in distribution . build_dependencies ( current_platform ) [EOL] [EOL] [EOL] def test_that_trying_to_create_source_distribution_from_random_zip_throws ( test_zip_path , logger , requirement_parser ) : [EOL] archive = Archive ( path = test_zip_path ) [EOL] with pytest . raises ( DistributionNotDetected ) : [EOL] SourceDistribution . from_archive ( archive , logger , requirement_parser = requirement_parser , ) [EOL] [EOL] [EOL] def test_build_dependencies_for_invalid_deps_logs_warning ( data_directory , current_platform , logger , requirement_parser , ) : [EOL] spacy_distribution_path = os . path . join ( data_directory , [string] ) [EOL] archive = Archive ( spacy_distribution_path ) [EOL] [EOL] dist = SourceDistribution . from_archive ( archive , logger , requirement_parser = requirement_parser ) [EOL] [EOL] assert [string] not in get_logger_output ( logger ) [EOL] dist . build_dependencies ( current_platform ) [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_invalid_build_dependencies_for_setupcfg_package_logs_warning ( data_directory , current_platform , logger , requirement_parser , ) : [EOL] distribution_path = os . path . join ( data_directory , [string] , [string] ) [EOL] archive = Archive ( distribution_path ) [EOL] [EOL] dist = SourceDistribution . from_archive ( archive , logger , requirement_parser = requirement_parser ) [EOL] [EOL] assert [string] not in get_logger_output ( logger ) [EOL] dist . build_dependencies ( current_platform ) [EOL] assert [string] in get_logger_output ( logger ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pypi2nix [EOL] from pypi2nix . license import license_from_string [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] from . logger import get_logger_output [EOL] [EOL] [EOL] def test_license_from_string_detects_apache_2_0 ( ) : [EOL] assert license_from_string ( [string] ) == [string] [EOL] [EOL] [EOL] def test_license_from_string_detects_bsd_dash_licenses ( ) : [EOL] assert license_from_string ( [string] ) == [string] [EOL] [EOL] [EOL] def test_that_license_of_flit_is_detected ( flit_wheel , logger ) : [EOL] assert flit_wheel . license [EOL] assert [string] not in get_logger_output ( logger ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements_file import RequirementsFile [EOL] [EOL] [EOL] @ pytest . fixture def requirements_file_from_lines ( project_dir , tmpdir_factory , requirement_parser , logger ) : [EOL] def factory ( lines ) : [EOL] requirements_file = tmpdir_factory . mktemp ( [string] ) . join ( [string] ) [EOL] requirements_file . write ( [string] . join ( lines ) ) [EOL] return RequirementsFile ( str ( requirements_file ) , project_dir , requirement_parser , logger ) [EOL] [EOL] return factory [EOL] [EOL] [EOL] def test_requirements_file_handles_comments ( requirements_file_from_lines ) : [EOL] requirements_file = requirements_file_from_lines ( [ [string] ] ) [EOL] requirements_file . process ( ) [EOL] [EOL] [EOL] def test_requirements_file_handles_empty_lines ( requirements_file_from_lines ) : [EOL] requirements_file = requirements_file_from_lines ( [ [string] ] ) [EOL] requirements_file . process ( ) [EOL] [EOL] [EOL] def test_requirements_file_can_be_created_from_requirements_lines ( project_dir , requirement_parser , logger ) : [EOL] RequirementsFile . from_lines ( [ [string] ] , requirement_parser = requirement_parser , project_dir = project_dir , logger = logger , ) [EOL] [EOL] [EOL] def test_regular_requirements_stay_in_processed_file ( project_dir , requirement_parser , logger ) : [EOL] requirement_file = RequirementsFile . from_lines ( [ [string] ] , requirement_parser = requirement_parser , project_dir = project_dir , logger = logger , ) [EOL] processed_file = requirement_file . processed_requirements_file_path ( ) [EOL] with open ( processed_file ) as f : [EOL] assert [string] in f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import package_generator [EOL] import venv [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . pip . virtualenv import VirtualenvPip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . package_generator import PackageGenerator [EOL] [EOL] [EOL] def test_can_generate_two_packages ( package_generator ) : [EOL] package_generator . generate_setuptools_package ( name = [string] , ) [EOL] package_generator . generate_setuptools_package ( name = [string] , ) [EOL] [EOL] [EOL] def test_can_gerate_source_distribution_with_correct_name ( package_generator , ) : [EOL] distribution = package_generator . generate_setuptools_package ( name = [string] ) [EOL] assert distribution . name == [string] [EOL] [EOL] [EOL] def test_can_install_generated_packages ( pip , current_platform , requirement_parser , target_directory , install_target , package_generator , ) : [EOL] package_generator . generate_setuptools_package ( name = [string] ) [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . install ( requirements , source_directories = [ target_directory ] , target_directory = install_target , ) [EOL] assert [string] in pip . freeze ( python_path = [ install_target ] ) [EOL] [EOL] [EOL] def test_can_generate_packages_with_requirements ( package_generator , requirement_parser , pip , target_directory , install_target , current_platform , ) : [EOL] package_generator . generate_setuptools_package ( name = [string] , install_requires = [ [string] ] ) [EOL] package_generator . generate_setuptools_package ( name = [string] ) [EOL] requirements = RequirementSet ( target_platform = current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . install ( requirements , source_directories = [ target_directory ] , target_directory = install_target , ) [EOL] assert [string] in pip . freeze ( [ install_target ] ) [EOL] [EOL] [EOL] def test_can_generate_valid_packages_with_two_runtime_dependencies ( package_generator , requirement_parser , pip , target_directory , install_target , current_platform , ) : [EOL] package_generator . generate_setuptools_package ( name = [string] , install_requires = [ [string] , [string] ] ) [EOL] package_generator . generate_setuptools_package ( name = [string] ) [EOL] package_generator . generate_setuptools_package ( name = [string] ) [EOL] requirements = RequirementSet ( target_platform = current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . install ( requirements , source_directories = [ target_directory ] , target_directory = install_target , ) [EOL] installed_packages = pip . freeze ( [ install_target ] ) [EOL] assert [string] in installed_packages [EOL] assert [string] in installed_packages [EOL] [EOL] [EOL] @ pytest . fixture def pip ( logger , current_platform , target_directory , wheel_distribution_archive_path , requirement_parser , install_target , ) : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = str ( install_target ) , env_builder = venv . EnvBuilder ( with_pip = True ) , no_index = True , wheel_distribution_path = wheel_distribution_archive_path , find_links = [ str ( target_directory ) ] , requirement_parser = requirement_parser , ) [EOL] pip . prepare_virtualenv ( ) [EOL] return pip [EOL] [EOL] [EOL] @ pytest . fixture def target_directory ( tmpdir_factory ) : [EOL] return Path ( str ( tmpdir_factory . mktemp ( [string] ) ) ) [EOL] [EOL] [EOL] @ pytest . fixture def install_target ( tmpdir_factory ) : [EOL] return Path ( str ( tmpdir_factory . mktemp ( [string] ) ) ) [EOL] [EOL] [EOL] @ pytest . fixture def package_generator ( logger , target_directory , requirement_parser ) : [EOL] return PackageGenerator ( target_directory = target_directory , logger = logger , requirement_parser = requirement_parser , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pip.virtualenv.VirtualenvPip$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $package_generator.PackageGenerator$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pypi2nix [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . external_dependency_collector import RequirementDependencyRetriever [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] [EOL] [EOL] def test_no_external_dependency_for_empty_dependency_graph ( requirement_parser , ) : [EOL] dependency_graph = DependencyGraph ( ) [EOL] retriever = RequirementDependencyRetriever ( dependency_graph ) [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert not retriever . get_external_dependency_for_requirement ( requirement ) [EOL] [EOL] [EOL] def test_external_dependencies_from_graph_are_retrieved ( requirement_parser , ) : [EOL] dependency_graph = DependencyGraph ( ) [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] external_dependency = ExternalDependency ( [string] ) [EOL] dependency_graph . set_external_dependency ( dependent = requirement , dependency = external_dependency ) [EOL] retriever = RequirementDependencyRetriever ( dependency_graph ) [EOL] assert external_dependency in retriever . get_external_dependency_for_requirement ( requirement ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Tuple [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import os . path [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . archive import Archive [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] , [string] ) ) def archive ( request , test_zip_path , test_tar_gz_path , test_tar_bz2_path ) : [EOL] if request . param == [string] : [EOL] return Archive ( path = test_tar_gz_path ) [EOL] elif request . param == [string] : [EOL] return Archive ( path = test_tar_bz2_path ) [EOL] else : [EOL] return Archive ( path = test_zip_path ) [EOL] [EOL] [EOL] def test_that_we_can_inspect_the_content_of_an_archive ( archive ) : [EOL] with archive . extracted_files ( ) as directory : [EOL] files = tuple ( os . listdir ( directory ) ) [EOL] assert files == ( [string] , ) [EOL] [EOL] [EOL] def test_that_we_can_inspect_the_content_of_a_wheel ( setupcfg_package_wheel_path ) : [EOL] archive = Archive ( path = setupcfg_package_wheel_path ) [EOL] with archive . extracted_files ( ) as directory : [EOL] assert [string] in os . listdir ( directory ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . nix import EvaluationFailed [EOL] from pypi2nix . nix import ExecutableNotFound [EOL] from pypi2nix . nix import Nix [EOL] [EOL] from . switches import nix [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] @ pytest . fixture def nix_instance ( tmpdir , logger ) : [EOL] nix_path_addition = tmpdir . mkdir ( [string] ) [EOL] yield Nix ( nix_path = [ [string] . format ( str ( nix_path_addition ) ) ] , logger = logger ) [EOL] [EOL] [EOL] @ pytest . fixture def dummy_derivation ( ) : [EOL] return os . path . join ( HERE , [string] ) [EOL] [EOL] [EOL] @ nix def test_evaluate_nix_expression_works ( nix_instance ) : [EOL] assert nix_instance . evaluate_expression ( [string] ) == [string] [EOL] [EOL] [EOL] @ nix def test_evalulate_nix_expression_respects_additions_to_nix_path ( nix_instance ) : [EOL] assert [string] in nix_instance . evaluate_expression ( [string] ) [EOL] [EOL] [EOL] @ nix def test_evaluate_nix_expression_raises_exception_when_executable_not_found ( logger ) : [EOL] nix = Nix ( executable_directory = [string] , logger = logger ) [EOL] with pytest . raises ( ExecutableNotFound ) : [EOL] nix . evaluate_expression ( [string] ) [EOL] [EOL] [EOL] @ nix def test_shell_accepts_file_path_to_run_shell_script ( nix_instance , dummy_derivation ) : [EOL] output = nix_instance . shell ( [string] , derivation_path = dummy_derivation ) [EOL] assert [string] in output [EOL] [EOL] [EOL] @ nix def test_shell_accepts_nix_arguments ( nix_instance , dummy_derivation ) : [EOL] output = nix_instance . shell ( [string] , derivation_path = dummy_derivation , nix_arguments = { [string] : [string] } , ) [EOL] assert [string] in output [EOL] [EOL] [EOL] @ nix def test_evaluate_expression_throws_on_erroneous_expression ( nix_instance ) : [EOL] with pytest . raises ( EvaluationFailed ) : [EOL] nix_instance . evaluate_expression ( [string] ) [EOL] [EOL] [EOL] @ nix def test_build_expression_throws_on_syntax_error ( nix_instance ) : [EOL] with pytest . raises ( EvaluationFailed ) : [EOL] nix_instance . build_expression ( [string] ) [EOL] [EOL] [EOL] @ nix def test_build_expression_creates_proper_out_link ( nix_instance , tmpdir ) : [EOL] output_path = tmpdir . join ( [string] ) [EOL] nix_instance . build_expression ( [string] , out_link = str ( output_path ) ) [EOL] assert output_path . exists ( ) [EOL] [EOL] [EOL] @ nix def test_build_respects_boolean_arguments ( nix_instance , tmpdir ) : [EOL] source_path = tmpdir . join ( [string] ) [EOL] with open ( source_path , [string] ) as f : [EOL] f . write ( [string] . join ( [ [string] , [string] [string] , ] ) ) [EOL] nix_instance . build ( source_file = str ( source_path ) , arguments = { [string] : True } ) [EOL] [EOL] [EOL] @ nix def test_build_expression_respects_boolean_arguments ( nix_instance ) : [EOL] expression = [string] . join ( [ [string] , [string] [string] , ] ) [EOL] nix_instance . build_expression ( expression , arguments = { [string] : True } ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import unittests [EOL] from pypi2nix . memoize import memoize [EOL] [EOL] [EOL] def test_memoized_method_returns_correct_result ( ) : [EOL] class A : [EOL] @ memoize def x ( self ) : [EOL] return [number] [EOL] [EOL] assert A ( ) . x ( ) == [number] [EOL] [EOL] [EOL] def test_memoized_method_gets_called_only_once ( ) : [EOL] class A : [EOL] def __init__ ( self ) : [EOL] self . times_called = [number] [EOL] [EOL] @ memoize def x ( self ) : [EOL] self . times_called += [number] [EOL] return [EOL] [EOL] a = A ( ) [EOL] a . x ( ) [EOL] a . x ( ) [EOL] assert a . times_called == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pypi2nix [EOL] import os [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . package_source import GitSource [EOL] from pypi2nix . package_source import HgSource [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . requirement_parser import ParsingFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements import IncompatibleRequirements [EOL] from pypi2nix . requirements import PathRequirement [EOL] from pypi2nix . requirements import UrlRequirement [EOL] from pypi2nix . requirements import VersionRequirement [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] def test_requirement_cannot_be_constructed_from_line_containing_newline ( requirement_parser , ) : [EOL] with pytest . raises ( ParsingFailed ) : [EOL] requirement_parser . parse ( [string] ) [EOL] [EOL] [EOL] def test_requirement_finds_name_of_pypi_packages ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_requirement_detects_source_of_pypi_package_as_none ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . source ( ) is None [EOL] [EOL] [EOL] def test_requirement_finds_name_of_git_package ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_requirement_finds_name_of_hg_package ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_requirement_finds_name_of_url_package ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_requirement_can_handle_environment_marker ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] % os . name ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_applies_to_target_works_properly_with_positiv_marker ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] % os . name ) [EOL] assert requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] def test_applies_to_target_works_properly_with_negative_marker ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] % os . name ) [EOL] assert not requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ( [string] , [string] ) , ] , ) def test_names_of_requirements_are_canonicalized ( line , expected , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert requirement . name ( ) == expected [EOL] [EOL] [EOL] def test_to_line_reproduces_canonicalized_name ( requirement_parser ) : [EOL] name = [string] [EOL] requirement = requirement_parser . parse ( name ) [EOL] assert name in requirement . to_line ( ) [EOL] [EOL] [EOL] def test_to_line_reproduces_version_specifier ( requirement_parser ) : [EOL] line = [string] [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert [string] in requirement . to_line ( ) [EOL] assert [string] in requirement . to_line ( ) [EOL] [EOL] [EOL] def test_from_line_recognizes_git_sources ( requirement_parser ) : [EOL] line = [string] [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert requirement . name ( ) == [string] [EOL] assert isinstance ( requirement . source ( ) , GitSource ) [EOL] [EOL] [EOL] def test_from_line_accepts_requirement_with_marker_including_in_operator ( requirement_parser , ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_that_applies_to_target_works_with_in_keyword ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] . format ( current_platform . python_version ) ) [EOL] assert requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] def test_that_mercurial_source_url_gets_detected ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , UrlRequirement ) [EOL] assert requirement . url ( ) == [string] [EOL] [EOL] [EOL] @ nix def test_that_mercurial_source_extracted_is_valid ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] source = requirement . source ( ) [EOL] assert isinstance ( source , HgSource ) [EOL] source . nix_expression ( ) [EOL] [EOL] [EOL] @ nix def test_that_git_source_extracted_is_valid ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] source = requirement . source ( ) [EOL] assert isinstance ( source , GitSource ) [EOL] source . nix_expression ( ) [EOL] [EOL] [EOL] def test_that_from_line_to_line_preserves_urls ( requirement_parser ) : [EOL] line = [string] [EOL] requirement = requirement_parser . parse ( line ) [EOL] assert requirement . to_line ( ) == line [EOL] [EOL] [EOL] def test_that_to_line_reproduces_path_correctly ( requirement_parser ) : [EOL] line = [string] [EOL] requirement = requirement_parser . parse ( line ) [EOL] requirement = requirement_parser . parse ( requirement . to_line ( ) ) [EOL] assert isinstance ( requirement , UrlRequirement ) [EOL] assert requirement . url ( ) == [string] [EOL] [EOL] [EOL] def test_that_requirements_can_be_added_together_adding_version_constraints ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( req1 , VersionRequirement ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( req2 , VersionRequirement ) [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] assert isinstance ( sum_requirement , VersionRequirement ) [EOL] assert len ( sum_requirement . version ( ) ) == len ( req1 . version ( ) ) + len ( req2 . version ( ) ) [EOL] [EOL] [EOL] def test_that_adding_requirements_with_different_names_throws ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] [EOL] def test_that_adding_requirements_with_a_version_and_a_url_results_in_url_requirement ( current_platform , requirement_parser ) : [EOL] for direction in [ [string] , [string] ] : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] if direction == [string] : [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] else : [EOL] sum_requirement = req2 . add ( req1 , current_platform ) [EOL] [EOL] assert isinstance ( sum_requirement , UrlRequirement ) [EOL] assert sum_requirement . url ( ) == [string] [EOL] [EOL] [EOL] def test_that_adding_requirements_with_different_urls_raises ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] [EOL] def test_that_adding_requirements_with_the_same_url_works ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] [EOL] assert isinstance ( sum_requirement , UrlRequirement ) [EOL] assert sum_requirement . url ( ) == [string] [EOL] [EOL] [EOL] def test_that_adding_requirements_where_one_does_not_apply_to_system_yields_the_other ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [comment] [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] assert isinstance ( sum_requirement , VersionRequirement ) [EOL] assert not sum_requirement . version ( ) [EOL] [EOL] [EOL] def test_that_we_parse_requirements_with_file_paths ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , PathRequirement ) [EOL] assert requirement . name ( ) == [string] [EOL] assert requirement . path ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ [string] , [string] , [string] , [string] ] , ) @ pytest . mark . parametrize ( [string] , [ [string] , [string] ] ) def test_that_we_can_add_two ( req_line_1 , req_line_2 , current_platform , requirement_parser ) : [EOL] requirement1 = requirement_parser . parse ( req_line_1 ) [EOL] requirement2 = requirement_parser . parse ( req_line_2 ) [EOL] requirement1 . add ( requirement2 , current_platform ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , ) , ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) , ) def test_that_we_can_add_version_with_path_requirement_result_is_path_requirement ( version_requirement_line , path_requirement_line , current_platform , requirement_parser , ) : [EOL] req1 = requirement_parser . parse ( version_requirement_line ) [EOL] req2 = requirement_parser . parse ( path_requirement_line ) [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] assert isinstance ( sum_requirement , PathRequirement ) [EOL] [EOL] sum_requirement = req2 . add ( req1 , current_platform ) [EOL] assert isinstance ( sum_requirement , PathRequirement ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] , [string] , [string] , ) , ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) , ) def test_can_add_version_requirement_with_url_requirement ( version_requirement_line , url_requirement_line , current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( version_requirement_line ) [EOL] req2 = requirement_parser . parse ( url_requirement_line ) [EOL] sum_requirement = req1 . add ( req2 , current_platform ) [EOL] assert isinstance ( sum_requirement , UrlRequirement ) [EOL] [EOL] sum_requirement = req2 . add ( req1 , current_platform ) [EOL] assert isinstance ( sum_requirement , UrlRequirement ) [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) , ) @ pytest . mark . parametrize ( [string] , ( [string] , [string] ) , ) def test_cannot_add_path_and_url_requirement ( path_requirement_line , url_requirement_line , current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( path_requirement_line ) [EOL] req2 = requirement_parser . parse ( url_requirement_line ) [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req2 . add ( req1 , current_platform ) [EOL] [EOL] [EOL] def test_cannot_add_requirements_with_different_paths ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] [EOL] def test_that_we_cannot_add_path_requirements_with_different_names ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] [EOL] def test_adding_path_requirements_where_one_requirement_does_not_apply ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] [EOL] assert req1 . add ( req2 , current_platform ) == req1 [EOL] assert req2 . add ( req1 , current_platform ) == req1 [EOL] [EOL] [EOL] def test_that_we_can_add_path_requirements_with_same_path ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] [EOL] assert req1 . add ( req2 , current_platform ) == req1 [EOL] [EOL] [EOL] def test_that_we_can_change_path_of_path_requirements ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , PathRequirement ) [EOL] requirement = requirement . change_path ( lambda p : os . path . join ( [string] , p ) ) [EOL] assert requirement . path ( ) == [string] [EOL] [EOL] [EOL] def test_that_we_can_add_url_requirements_where_one_does_not_apply ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] assert req1 . add ( req2 , current_platform ) == req1 [EOL] assert req2 . add ( req1 , current_platform ) == req1 [EOL] [EOL] [EOL] def test_cannot_add_url_requirements_with_different_names ( current_platform , requirement_parser ) : [EOL] req1 = requirement_parser . parse ( [string] ) [EOL] req2 = requirement_parser . parse ( [string] ) [EOL] with pytest . raises ( IncompatibleRequirements ) : [EOL] req1 . add ( req2 , current_platform ) [EOL] [EOL] [EOL] def test_can_handle_requirements_with_python_full_version_marker ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] . format ( current_platform . python_full_version ) ) [EOL] assert requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] def test_rejects_requirements_with_wrong_python_full_version_for_platform ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] . format ( [string] ) ) [EOL] assert not requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] def test_that_requirements_with_proper_os_name_applies_to_target ( current_platform , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] . format ( current_platform . os_name ) ) [EOL] assert requirement . applies_to_target ( current_platform ) [EOL] [EOL] [EOL] def test_that_extras_of_path_requirements_are_preserved ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , PathRequirement ) [EOL] assert requirement . extras ( ) == { [string] , [string] } [EOL] requirement = requirement_parser . parse ( requirement . to_line ( ) ) [EOL] assert requirement . extras ( ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_that_extras_of_url_requirements_are_preserved ( requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement , UrlRequirement ) [EOL] assert requirement . extras ( ) == { [string] , [string] } [EOL] requirement = requirement_parser . parse ( requirement . to_line ( ) ) [EOL] assert requirement . extras ( ) == { [string] , [string] } [EOL] [EOL] [EOL] def test_that_source_of_url_requirement_with_file_scheme_is_path_source ( requirement_parser , ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert isinstance ( requirement . source ( ) , PathSource ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import os . path [EOL] import tempfile [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . project_directory import PersistentProjectDirectory [EOL] from pypi2nix . project_directory import TemporaryProjectDirectory [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] ) ) def project_directory ( request , ) : [EOL] if request . param == [string] : [EOL] yield TemporaryProjectDirectory ( ) [EOL] elif request . param == [string] : [EOL] with TemporaryProjectDirectory ( ) as directory : [EOL] yield PersistentProjectDirectory ( path = directory ) [EOL] [EOL] [EOL] def test_can_write_to_project_directory ( project_directory ) : [EOL] with project_directory as directory : [EOL] file_path = os . path . join ( directory , [string] ) [EOL] with open ( file_path , [string] ) as f : [EOL] f . write ( [string] ) [EOL] [EOL] [EOL] def test_tempfile_project_directory_is_deleted_after_exception ( ) : [EOL] with pytest . raises ( Exception ) , TemporaryProjectDirectory ( ) as directory : [EOL] path = directory [EOL] raise Exception ( ) [EOL] assert not os . path . exists ( path ) [EOL] [EOL] [EOL] def test_persistent_project_directory_is_not_deleted_on_exception ( ) : [EOL] with tempfile . TemporaryDirectory ( ) as directory : [EOL] with pytest . raises ( Exception ) , PersistentProjectDirectory ( path = directory ) as _project_dir : [EOL] project_directory = _project_dir [EOL] raise Exception ( ) [EOL] assert os . path . exists ( project_directory ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pypi2nix [EOL] from io import StringIO [EOL] [EOL] from hypothesis import given [EOL] from hypothesis . strategies import booleans [EOL] from hypothesis . strategies import composite [EOL] from hypothesis . strategies import integers [EOL] from hypothesis . strategies import lists [EOL] from hypothesis . strategies import text [EOL] [EOL] from pypi2nix . dependency_graph import CyclicDependencyOccured [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . requirements import VersionRequirement [EOL] [EOL] logger = StreamLogger ( output = StringIO ( ) ) [EOL] [EOL] [EOL] @ composite def requirement ( draw , name = text ( min_size = [number] ) ) : [EOL] return VersionRequirement ( name = draw ( name ) , logger = logger , versions = [ ] , extras = set ( ) , environment_markers = None , ) [EOL] [EOL] [EOL] @ composite def external_dependency ( draw , attribute_name = text ( min_size = [number] ) ) : [EOL] return ExternalDependency ( attribute_name = draw ( attribute_name ) ) [EOL] [EOL] [EOL] @ composite def dependency_graph ( draw , python_packages = lists ( requirement ( ) , unique_by = lambda x : x . name ( ) ) , external_dependencies = lists ( external_dependency ( ) ) , is_runtime_dependency = booleans ( ) , selections = integers ( ) , ) : [EOL] graph = DependencyGraph ( ) [EOL] packages = draw ( python_packages ) [EOL] if not packages : [EOL] return graph [EOL] for package in packages : [EOL] index = draw ( selections ) % len ( packages ) [EOL] try : [EOL] if draw ( is_runtime_dependency ) : [EOL] graph . set_runtime_dependency ( dependent = package , dependency = packages [ index ] ) [EOL] else : [EOL] graph . set_buildtime_dependency ( dependent = package , dependency = packages [ index ] ) [EOL] except CyclicDependencyOccured : [EOL] continue [EOL] for dependency in draw ( external_dependencies ) : [EOL] graph . set_external_dependency ( dependent = packages [ draw ( selections ) % len ( packages ) ] , dependency = dependency ) [EOL] return graph [EOL] [EOL] [EOL] @ given ( dependency_graph = dependency_graph ( ) ) def test_equality_to_self ( dependency_graph ) : [EOL] assert dependency_graph == dependency_graph [EOL] [EOL] [EOL] def test_equality_of_empty_graphs ( ) : [EOL] assert DependencyGraph ( ) == DependencyGraph ( ) [EOL] [EOL] [EOL] @ given ( dependency_graph = dependency_graph ( ) ) def test_serialization_and_deserialization_leads_to_identity ( dependency_graph , ) : [EOL] assert DependencyGraph . deserialize ( dependency_graph . serialize ( ) ) == dependency_graph [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import io [EOL] import typing [EOL] from io import StringIO [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import LoggerNotConnected [EOL] from pypi2nix . logger import ProxyLogger [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . logger import Verbosity [EOL] from pypi2nix . logger import verbosity_from_int [EOL] [EOL] from . logger import get_logger_output [EOL] [EOL] [EOL] @ pytest . fixture ( params = [ [string] , [string] ] ) def logger ( request ) : [EOL] stream = StringIO ( [string] ) [EOL] stream_logger = StreamLogger ( output = stream ) [EOL] if request . param == [string] : [EOL] return stream_logger [EOL] elif request . param == [string] : [EOL] proxy_logger = ProxyLogger ( ) [EOL] proxy_logger . set_target_logger ( stream_logger ) [EOL] return proxy_logger [EOL] [EOL] [EOL] @ pytest . fixture def unconnected_proxy_logger ( ) : [EOL] return ProxyLogger ( ) [EOL] [EOL] [EOL] def test_can_log_warning ( logger ) : [EOL] logger . warning ( [string] ) [EOL] [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_every_line_of_warning_is_prefixed ( logger ) : [EOL] logger . warning ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] assert [string] in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . ERROR , ) ) def test_that_logger_with_low_verbosity_level_does_not_emit_warning_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . warning ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] not in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . WARNING , Verbosity . INFO , Verbosity . DEBUG ) ) def test_that_logger_with_high_verbosity_level_does_emit_warning_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . warning ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] [EOL] [EOL] def test_can_log_error ( logger ) : [EOL] logger . error ( [string] ) [EOL] [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_every_line_of_error_is_prefixed ( logger ) : [EOL] logger . error ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] assert [string] in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . ERROR , Verbosity . WARNING , Verbosity . INFO , Verbosity . DEBUG ) ) def test_that_logger_always_emits_errors ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . error ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] [EOL] [EOL] def test_can_log_info ( logger ) : [EOL] logger . info ( [string] ) [EOL] [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_every_info_line_is_prefixed ( logger ) : [EOL] logger . info ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] assert [string] in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . WARNING , Verbosity . ERROR ) ) def test_that_logger_with_low_verbosity_level_does_not_emit_info_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . info ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] not in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . INFO , Verbosity . DEBUG ) ) def test_that_logger_with_high_verbosity_level_does_emit_info_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . info ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] [EOL] [EOL] def test_can_log_debug ( logger ) : [EOL] logger . debug ( [string] ) [EOL] [EOL] assert [string] in get_logger_output ( logger ) [EOL] [EOL] [EOL] def test_every_debug_line_is_prefixed ( logger ) : [EOL] logger . debug ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] assert [string] in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . WARNING , Verbosity . ERROR , Verbosity . INFO ) ) def test_that_logger_with_low_verbosity_level_does_not_emit_debug_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . debug ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] not in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , ( Verbosity . DEBUG , ) ) def test_that_logger_with_high_verbosity_level_does_emit_debug_logs ( logger , level ) : [EOL] logger . set_verbosity ( level ) [EOL] logger . debug ( [string] ) [EOL] [EOL] output = get_logger_output ( logger ) [EOL] assert [string] in output [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , list ( Verbosity ) ) def test_that_verbosity_level_can_be_retrieved_from_assigned_integer ( level ) : [EOL] assert verbosity_from_int ( level . value ) == level [EOL] [EOL] [EOL] def test_that_high_number_gets_translated_into_debug_verbosity ( ) : [EOL] assert verbosity_from_int ( [number] ) == Verbosity . DEBUG [EOL] [EOL] [EOL] def test_that_low_number_gets_translated_into_error_verbosity ( ) : [EOL] assert verbosity_from_int ( - [number] ) == Verbosity . ERROR [EOL] [EOL] [EOL] def test_that_unconnect_proxy_logger_raises_proper_exception_on_logging ( unconnected_proxy_logger , ) : [EOL] with pytest . raises ( LoggerNotConnected ) : [EOL] unconnected_proxy_logger . debug ( [string] ) [EOL] with pytest . raises ( LoggerNotConnected ) : [EOL] unconnected_proxy_logger . info ( [string] ) [EOL] with pytest . raises ( LoggerNotConnected ) : [EOL] unconnected_proxy_logger . warning ( [string] ) [EOL] with pytest . raises ( LoggerNotConnected ) : [EOL] unconnected_proxy_logger . error ( [string] ) [EOL] with pytest . raises ( LoggerNotConnected ) : [EOL] unconnected_proxy_logger . set_verbosity ( Verbosity . DEBUG ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . package_source import GitSource [EOL] from pypi2nix . package_source import HgSource [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . package_source import UrlSource [EOL] [EOL] from . switches import nix [EOL] [EOL] URL_SOURCE_URL = [string] [EOL] URL_SOURCE_HASH = [string] [EOL] [EOL] [EOL] @ pytest . fixture def git_source ( ) : [EOL] return GitSource ( url = [string] , revision = [string] , ) [EOL] [EOL] [EOL] @ pytest . fixture def hg_source ( logger ) : [EOL] return HgSource ( url = [string] , revision = [string] , logger = logger ) [EOL] [EOL] [EOL] @ pytest . fixture def url_source ( logger ) : [EOL] return UrlSource ( url = URL_SOURCE_URL , logger = logger ) [EOL] [EOL] [EOL] @ pytest . fixture def path_source ( ) : [EOL] return PathSource ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def expression_evaluater ( logger ) : [EOL] nix_instance = Nix ( logger = logger ) [EOL] return lambda expression : nix_instance . evaluate_expression ( [string] + expression ) [EOL] [EOL] [EOL] @ nix def test_git_source_gives_correct_hash_value ( git_source ) : [EOL] assert ( git_source . hash_value ( ) == [string] ) [EOL] [EOL] [EOL] @ nix def test_git_source_produces_valid_nix_expression ( git_source , expression_evaluater ) : [EOL] expression_evaluater ( git_source . nix_expression ( ) ) [EOL] [EOL] [EOL] @ nix def test_hg_source_gives_correct_hash_value ( hg_source ) : [EOL] assert ( hg_source . hash_value ( ) == [string] ) [EOL] [EOL] [EOL] @ nix def test_hg_source_produces_valid_nix_expression ( hg_source , expression_evaluater ) : [EOL] expression_evaluater ( hg_source . nix_expression ( ) ) [EOL] [EOL] [EOL] @ nix def test_url_source_gives_correct_hash_value ( url_source ) : [EOL] assert url_source . hash_value ( ) == URL_SOURCE_HASH [EOL] [EOL] [EOL] @ nix def test_url_source_gives_valid_nix_expression ( url_source , expression_evaluater ) : [EOL] expression_evaluater ( url_source . nix_expression ( ) ) [EOL] [EOL] [EOL] def test_url_source_nix_expression_contains_specified_hash_when_given ( logger ) : [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] url_source = UrlSource ( URL_SOURCE_URL , hash_value = URL_SOURCE_HASH + [string] , logger = logger ) [EOL] assert URL_SOURCE_HASH + [string] in url_source . nix_expression ( ) [EOL] [EOL] [EOL] @ nix def test_path_source_gives_valid_nix_expression ( path_source , expression_evaluater ) : [EOL] expression_evaluater ( path_source . nix_expression ( ) ) [EOL] [EOL] [EOL] def test_path_source_paths_with_one_segement_get_dot_appended_for_nix ( ) : [EOL] source = PathSource ( [string] ) [EOL] assert source . nix_expression ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . python_version import PythonVersion [EOL] from pypi2nix . python_version import python_version_from_version_string [EOL] from pypi2nix . target_platform import PlatformGenerator [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , PythonVersion ) @ nix def test_available_python_versions_exist_in_nixpkgs ( python_version , platform_generator ) : [EOL] target_platform = platform_generator . from_python_version ( python_version ) [EOL] assert target_platform is not None [EOL] [EOL] [EOL] @ pytest . mark . parametrize ( [string] , [ ( [string] , PythonVersion . python35 ) , ( [string] , PythonVersion . python36 ) , ( [string] , PythonVersion . python37 ) , ( [string] , PythonVersion . python38 ) , ] , ) def test_can_get_python_version_from_version_string ( version_string , expected_python_version ) : [EOL] assert python_version_from_version_string ( version_string ) == expected_python_version [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from typing import List [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . metadata_fetcher import MetadataFetcher [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . wheel import Wheel [EOL] from pypi2nix . wheel_builder import WheelBuilder [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ pytest . fixture def build_wheels ( wheel_builder , current_platform , requirement_parser , logger , sources_for_test_packages , pypi , ) : [EOL] def wrapper ( requirement_lines ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] for line in requirement_lines : [EOL] requirements . add ( requirement_parser . parse ( line ) ) [EOL] wheel_paths = wheel_builder . build ( requirements ) [EOL] metadata_fetcher = MetadataFetcher ( sources_for_test_packages , logger , requirement_parser , pypi ) [EOL] return metadata_fetcher . main ( wheel_paths , current_platform , wheel_builder . source_distributions ) [EOL] [EOL] return wrapper [EOL] [EOL] [EOL] @ nix def test_extracts_myextra_dependencies_from_package3 ( build_wheels , ) : [EOL] wheels = build_wheels ( [ [string] ] ) [EOL] assert [ wheel for wheel in wheels if wheel . name == [string] ] [EOL] [EOL] [EOL] @ nix def test_does_not_package_myextra_dependencies_if_no_extras_specified ( build_wheels , ) : [EOL] wheels = build_wheels ( [ [string] ] ) [EOL] assert not [ wheel for wheel in wheels if wheel . name == [string] ] [EOL] [EOL] [EOL] @ nix def test_does_detect_extra_requirements_from_requirements ( build_wheels ) : [EOL] wheels = build_wheels ( [ [string] ] ) [EOL] assert [ wheel for wheel in wheels if wheel . name == [string] ] [EOL] [EOL] [EOL] @ nix def test_that_we_filter_extra_requirements_that_do_not_apply_to_target_platform ( build_wheels , ) : [EOL] wheels = build_wheels ( [ [string] ] ) [EOL] assert not [ wheel for wheel in wheels if wheel . name == [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.wheel.Wheel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Generator , Any , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import pathlib [EOL] import os [EOL] import os . path [EOL] import pathlib [EOL] from contextlib import contextmanager [EOL] from typing import Any [EOL] from typing import Generator [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements import PathRequirement [EOL] from pypi2nix . requirements_collector import RequirementsCollector [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] @ contextmanager def current_working_directory ( dir ) : [EOL] current = os . getcwd ( ) [EOL] try : [EOL] os . chdir ( dir ) [EOL] yield [EOL] finally : [EOL] os . chdir ( current ) [EOL] [EOL] [EOL] @ pytest . fixture def collector ( current_platform , requirement_parser , logger , project_dir , ) : [EOL] return RequirementsCollector ( current_platform , requirement_parser , logger , project_dir , DependencyGraph ( ) ) [EOL] [EOL] [EOL] def test_that_we_can_generate_an_empty_requirement_set_from_freshly_constructed_collector ( current_platform , requirement_parser , logger , project_dir , ) : [EOL] collector = RequirementsCollector ( current_platform , requirement_parser , logger , project_dir , DependencyGraph ( ) ) [EOL] requirements = collector . requirements ( ) [EOL] assert len ( requirements ) == [number] [EOL] [EOL] [EOL] def test_that_we_can_add_command_line_requirements_by_name ( collector , ) : [EOL] collector . add_line ( [string] ) [EOL] requirements = collector . requirements ( ) [EOL] assert [string] in requirements [EOL] [EOL] [EOL] def test_that_we_can_add_a_requirements_file_path ( collector , tmpdir ) : [EOL] requirements_txt = tmpdir / [string] [EOL] requirements_lines = [ [string] , [string] ] [EOL] with open ( requirements_txt , [string] ) as f : [EOL] for requirement in requirements_lines : [EOL] print ( requirement , file = f ) [EOL] collector . add_file ( str ( requirements_txt ) ) [EOL] assert [string] in collector . requirements ( ) [EOL] assert [string] in collector . requirements ( ) [EOL] [EOL] [EOL] def test_that_requirements_with_relative_paths_are_absolute_paths_after_adding ( collector , ) : [EOL] collector . add_line ( [string] ) [EOL] requirement = collector . requirements ( ) . get ( [string] ) [EOL] assert isinstance ( requirement , PathRequirement ) [EOL] assert os . path . isabs ( requirement . path ( ) ) [EOL] [EOL] [EOL] def test_that_sources_can_be_extracted_from_a_collector ( collector , ) : [EOL] collector . add_line ( [string] ) [EOL] assert [string] in collector . sources ( ) [EOL] [EOL] [EOL] def test_that_relative_paths_are_preserved_in_sources ( collector , ) : [EOL] collector . add_line ( [string] ) [EOL] testegg_source = collector . sources ( ) [ [string] ] [EOL] assert isinstance ( testegg_source , PathSource ) [EOL] assert testegg_source . path == [string] [EOL] [EOL] [EOL] def test_that_path_paths_from_requirement_files_are_preserved_in_sources ( collector , tmpdir ) : [EOL] with current_working_directory ( str ( tmpdir ) ) : [EOL] requirements_file_path = tmpdir . join ( [string] ) [EOL] with open ( requirements_file_path , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] collector . add_file ( str ( requirements_file_path ) ) [EOL] testegg_source = collector . sources ( ) [ [string] ] [EOL] assert isinstance ( testegg_source , PathSource ) [EOL] assert testegg_source . path == [string] [EOL] [EOL] [EOL] def test_that_path_sources_from_requirement_files_are_preserved_in_sources_relative_to_file ( collector , tmpdir ) : [EOL] with current_working_directory ( str ( tmpdir ) ) : [EOL] requirements_directory = tmpdir . join ( [string] ) [EOL] requirements_directory . mkdir ( ) [EOL] requirements_file_path = requirements_directory . join ( [string] ) [EOL] with open ( requirements_file_path , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] collector . add_file ( str ( requirements_file_path ) ) [EOL] testegg_source = collector . sources ( ) [ [string] ] [EOL] assert isinstance ( testegg_source , PathSource ) [EOL] assert testegg_source . path == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[None,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements_collector.RequirementsCollector$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import jinja2 [EOL] import os [EOL] from typing import Dict [EOL] [EOL] import jinja2 [EOL] [EOL] from pypi2nix . path import Path [EOL] [EOL] HERE = Path ( os . path . dirname ( __file__ ) ) [EOL] [EOL] _templates = jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( str ( HERE / [string] ) ) ) [EOL] [EOL] [EOL] def render_template ( template_path , context = Dict [ str , str ] ) : [EOL] template = _templates . get_template ( str ( template_path ) ) [EOL] return template . render ( ** context ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pypi2nix [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . utils import cmd [EOL] [EOL] [EOL] def test_consistent_output ( logger ) : [EOL] exit_code , output = cmd ( [ [string] , [string] ] , logger = logger ) [EOL] assert output == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . utils import prefetch_url [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] @ nix def test_prefetch_url_returns_correct_hash ( logger ) : [EOL] url = [string] [EOL] expected_hash = [string] [EOL] assert prefetch_url ( url , logger ) == expected_hash [EOL] [EOL] [EOL] @ nix def test_prefetch_url_raises_on_invalid_name ( logger ) : [EOL] [docstring] [EOL] url = [string] [EOL] with pytest . raises ( ValueError ) : [EOL] prefetch_url ( url , logger ) [EOL] [EOL] [EOL] @ nix def test_can_provide_name_so_prefetch_does_not_fail ( logger ) : [EOL] url = [string] [EOL] sha256 = prefetch_url ( url , logger , name = [string] ) [EOL] assert sha256 == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import typing [EOL] from copy import copy [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . dependency_graph import CyclicDependencyOccured [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import Requirement [EOL] from pypi2nix . requirements import VersionRequirement [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] [EOL] def test_can_set_runtime_dependencies ( package_a , package_b , dependency_graph ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] assert dependency_graph . is_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] [EOL] [EOL] def test_can_detect_indirect_runtime_dependencies ( package_a , package_b , package_c , dependency_graph , ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] dependency_graph . set_runtime_dependency ( dependent = package_b , dependency = package_c ) [EOL] assert dependency_graph . is_runtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] [EOL] [EOL] def test_cyclic_runtime_dependencies_not_allowed ( package_a , package_b , dependency_graph ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] with pytest . raises ( CyclicDependencyOccured ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_b , dependency = package_a ) [EOL] [EOL] [EOL] def test_can_retriev_all_runtime_dependency_names ( package_a , package_b , package_c , dependency_graph , ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] dependency_graph . set_runtime_dependency ( dependent = package_b , dependency = package_c ) [EOL] assert dependency_graph . get_all_runtime_dependency_names ( package_a ) == { package_a . name ( ) , package_b . name ( ) , package_c . name ( ) , } [EOL] [EOL] [EOL] def test_can_set_buildtime_dependency ( package_a , package_b , dependency_graph ) : [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] assert dependency_graph . is_buildtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] [EOL] [EOL] def test_build_time_dependencies_dont_show_up_as_runtime_dependencies ( package_a , package_b , package_c , dependency_graph , ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_b , dependency = package_c ) [EOL] assert not dependency_graph . is_runtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] [EOL] [EOL] def test_cannot_add_circular_buildtime_dependencies ( package_a , package_b , dependency_graph , ) : [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] with pytest . raises ( CyclicDependencyOccured ) : [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_b , dependency = package_a ) [EOL] [EOL] [EOL] def test_cannot_add_circular_builtime_dependency_to_runtime_dependency ( package_a , package_b , dependency_graph , ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] with pytest . raises ( CyclicDependencyOccured ) : [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_b , dependency = package_a ) [EOL] [EOL] [EOL] def test_cannot_add_circular_runtime_dependency_to_buildtime_dependency ( package_a , package_b , dependency_graph , ) : [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] with pytest . raises ( CyclicDependencyOccured ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_b , dependency = package_a ) [EOL] [EOL] [EOL] def test_can_add_two_dependencies_graphs_and_runtime_dependencies_are_also_added ( package_a , package_b , package_c , dependency_graph , ) : [EOL] other_dependency_graph = copy ( dependency_graph ) [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] other_dependency_graph . set_runtime_dependency ( dependent = package_b , dependency = package_c ) [EOL] sum_graph = dependency_graph + other_dependency_graph [EOL] assert not dependency_graph . is_runtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] assert not other_dependency_graph . is_runtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] assert sum_graph . is_runtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] [EOL] [EOL] def test_can_add_two_dependencies_graphs_and_buildtime_dependencies_are_also_added ( package_a , package_b , package_c , dependency_graph , ) : [EOL] other_dependency_graph = copy ( dependency_graph ) [EOL] dependency_graph . set_buildtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] other_dependency_graph . set_buildtime_dependency ( dependent = package_b , dependency = package_c ) [EOL] sum_graph = dependency_graph + other_dependency_graph [EOL] assert not dependency_graph . is_buildtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] assert not other_dependency_graph . is_buildtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] assert sum_graph . is_buildtime_dependency ( dependent = package_a , dependency = package_c ) [EOL] [EOL] [EOL] def test_can_detect_external_dependencies_for_packages ( package_a , external_dependency_a , dependency_graph , ) : [EOL] dependency_graph . set_external_dependency ( dependent = package_a , dependency = external_dependency_a ) [EOL] assert dependency_graph . get_all_external_dependencies ( package_a ) == { external_dependency_a , } [EOL] [EOL] [EOL] def test_can_retrieve_external_dependencies_from_runtime_dependencies ( package_a , package_b , external_dependency_a , dependency_graph , ) : [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] dependency_graph . set_external_dependency ( dependent = package_b , dependency = external_dependency_a ) [EOL] assert dependency_graph . get_all_external_dependencies ( package = package_a ) == { external_dependency_a , } [EOL] [EOL] [EOL] def test_can_retrieve_external_dependencies_after_adding_graphs ( package_a , package_b , external_dependency_a , external_dependency_b , dependency_graph , ) : [EOL] other_dependency_graph = copy ( dependency_graph ) [EOL] dependency_graph . set_external_dependency ( dependent = package_a , dependency = external_dependency_a ) [EOL] dependency_graph . set_runtime_dependency ( dependent = package_a , dependency = package_b ) [EOL] other_dependency_graph . set_external_dependency ( dependent = package_b , dependency = external_dependency_b ) [EOL] sum_graph = dependency_graph + other_dependency_graph [EOL] assert sum_graph . get_all_external_dependencies ( package = package_a ) == { external_dependency_a , external_dependency_b , } [EOL] [EOL] [EOL] def test_can_understand_wheel_dependecies ( current_platform , requirement_parser ) : [EOL] runtime_dependencies = RequirementSet ( current_platform ) [EOL] runtime_dependency = requirement_parser . parse ( [string] ) [EOL] runtime_dependencies . add ( runtime_dependency ) [EOL] build_dependencies = RequirementSet ( current_platform ) [EOL] build_dependency = requirement_parser . parse ( [string] ) [EOL] build_dependencies . add ( build_dependency ) [EOL] wheel = Wheel ( name = [string] , version = [string] , deps = runtime_dependencies , target_platform = current_platform , license = [string] , homepage = [string] , description = [string] , build_dependencies = build_dependencies , ) [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] dependency_graph = DependencyGraph ( ) [EOL] dependency_graph . import_wheel ( wheel , requirement_parser ) [EOL] [EOL] assert dependency_graph . is_buildtime_dependency ( requirement , build_dependency ) [EOL] assert dependency_graph . is_runtime_dependency ( requirement , runtime_dependency ) [EOL] [EOL] [EOL] @ pytest . fixture def package_a ( logger ) : [EOL] return VersionRequirement ( name = [string] , versions = [ ] , extras = set ( ) , environment_markers = None , logger = logger , ) [EOL] [EOL] [EOL] @ pytest . fixture def package_b ( logger ) : [EOL] return VersionRequirement ( name = [string] , versions = [ ] , extras = set ( ) , environment_markers = None , logger = logger , ) [EOL] [EOL] [EOL] @ pytest . fixture def package_c ( logger ) : [EOL] return VersionRequirement ( name = [string] , versions = [ ] , extras = set ( ) , environment_markers = None , logger = logger , ) [EOL] [EOL] [EOL] @ pytest . fixture def dependency_graph ( ) : [EOL] return DependencyGraph ( ) [EOL] [EOL] [EOL] @ pytest . fixture def external_dependency_a ( ) : [EOL] return ExternalDependency ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture def external_dependency_b ( ) : [EOL] return ExternalDependency ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.external_dependencies.ExternalDependency$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.external_dependencies.ExternalDependency$ 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . sources import Sources [EOL] [EOL] [EOL] @ pytest . fixture def sources ( ) : [EOL] return Sources ( ) [EOL] [EOL] [EOL] @ pytest . fixture def other_sources ( ) : [EOL] return Sources ( ) [EOL] [EOL] [EOL] def test_sources_can_be_added_to ( sources ) : [EOL] sources . add ( [string] , PathSource ( [string] ) ) [EOL] [EOL] assert [string] in sources [EOL] [EOL] [EOL] def test_sources_can_be_queried_by_name ( sources ) : [EOL] source = PathSource ( [string] ) [EOL] sources . add ( [string] , source ) [EOL] [EOL] assert sources [ [string] ] is source [EOL] [EOL] [EOL] def test_sources_can_be_merged ( sources , other_sources ) : [EOL] assert [string] not in sources [EOL] other_sources . add ( [string] , PathSource ( [string] ) ) [EOL] sources . update ( other_sources ) [EOL] assert [string] in sources [EOL] [EOL] [EOL] def test_items_returns_length_on_tuple_for_one_entry ( sources ) : [EOL] sources . add ( [string] , PathSource ( [string] ) ) [EOL] assert len ( sources . items ( ) ) == [number] [EOL] [EOL] [EOL] def test_empty_sources_has_length_0 ( sources ) : [EOL] assert len ( sources ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import VersionRequirement [EOL] from pypi2nix . requirements_file import RequirementsFile [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] @ pytest . fixture def requirement_set ( current_platform ) : [EOL] return RequirementSet ( current_platform ) [EOL] [EOL] [EOL] def test_length_of_empty_requirement_set_is_0 ( current_platform ) : [EOL] assert len ( RequirementSet ( current_platform ) ) == [number] [EOL] [EOL] [EOL] def test_length_is_one_after_adding_one_requirement ( current_platform , requirement_parser ) : [EOL] requirement_set = RequirementSet ( current_platform ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] assert len ( requirement_set ) == [number] [EOL] [EOL] [EOL] def test_length_is_one_after_adding_same_requirement_twice ( current_platform , requirement_parser ) : [EOL] requirement_set = RequirementSet ( current_platform ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] assert len ( requirement_set ) == [number] [EOL] [EOL] [EOL] def test_to_file_outputs_a_requirements_file_object ( project_dir , current_platform , requirement_parser , logger ) : [EOL] assert isinstance ( RequirementSet ( current_platform ) . to_file ( project_dir , current_platform , requirement_parser , logger ) , RequirementsFile , ) [EOL] [EOL] [EOL] def test_sources_contains_a_source_per_git_requirement ( current_platform , requirement_parser ) : [EOL] requirement_set = RequirementSet ( current_platform ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] assert len ( requirement_set . sources ( ) ) == [number] [EOL] [EOL] [EOL] def test_versions_add_if_same_requirement_is_added_twice ( current_platform , requirement_parser ) : [EOL] requirement_set = RequirementSet ( current_platform ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] requirement = requirement_set . requirements [ [string] ] [EOL] assert isinstance ( requirement , VersionRequirement ) [EOL] assert len ( requirement . version ( ) ) == [number] [EOL] [EOL] [EOL] def test_from_file_handles_empty_lines ( project_dir , current_platform , requirement_parser , logger ) : [EOL] requirements_file = RequirementsFile . from_lines ( [ [string] , [string] ] , project_dir , requirement_parser , logger ) [EOL] requirements_set = RequirementSet . from_file ( requirements_file , current_platform , requirement_parser , logger ) [EOL] assert len ( requirements_set ) == [number] [EOL] [EOL] [EOL] def test_from_file_handles_comment_lines ( project_dir , current_platform , requirement_parser , logger ) : [EOL] requirements_file = RequirementsFile . from_lines ( [ [string] , [string] ] , project_dir , requirement_parser , logger ) [EOL] requirements_set = RequirementSet . from_file ( requirements_file , current_platform , requirement_parser , logger ) [EOL] assert len ( requirements_set ) == [number] [EOL] [EOL] [EOL] def test_sources_has_sources_type ( current_platform ) : [EOL] requirement_set = RequirementSet ( current_platform ) [EOL] assert isinstance ( requirement_set . sources ( ) , Sources ) [EOL] [EOL] [EOL] def test_adding_two_empty_sets_results_in_an_empty_set ( current_platform ) : [EOL] requirements = RequirementSet ( current_platform ) + RequirementSet ( current_platform ) [EOL] assert len ( requirements ) == [number] [EOL] [EOL] [EOL] def test_can_find_requirement_in_requirement_set ( current_platform , requirement_parser ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] assert [string] in requirements [EOL] [EOL] [EOL] def test_cannot_find_name_in_empty_requirement_set ( current_platform ) : [EOL] assert [string] not in RequirementSet ( current_platform ) [EOL] [EOL] [EOL] def test_elements_from_both_sets_can_be_found_in_sum_of_sets ( current_platform , requirement_parser ) : [EOL] left = RequirementSet ( current_platform ) [EOL] left . add ( requirement_parser . parse ( [string] ) ) [EOL] right = RequirementSet ( current_platform ) [EOL] right . add ( requirement_parser . parse ( [string] ) ) [EOL] sum = left + right [EOL] assert [string] in sum [EOL] assert [string] in sum [EOL] [EOL] [EOL] def test_requirement_set_respects_constraints_when_reading_from_requirement_file ( tmpdir , project_dir , current_platform , requirement_parser , logger ) : [EOL] requirements_txt = tmpdir . join ( [string] ) [EOL] constraints_txt = tmpdir . join ( [string] ) [EOL] with open ( requirements_txt , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] print ( [string] + str ( constraints_txt ) , file = f ) [EOL] with open ( constraints_txt , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] [EOL] original_requirements_file = RequirementsFile ( str ( requirements_txt ) , project_dir , requirement_parser , logger ) [EOL] original_requirements_file . process ( ) [EOL] [EOL] requirement_set = RequirementSet . from_file ( original_requirements_file , current_platform , requirement_parser , logger ) [EOL] [EOL] new_requirements_file = requirement_set . to_file ( project_dir , current_platform , requirement_parser , logger ) [EOL] [EOL] assert [string] in new_requirements_file . read ( ) [EOL] [EOL] [EOL] def test_constraints_without_requirement_will_not_show_up_in_generated_requirement_file ( tmpdir , project_dir , current_platform , requirement_parser , logger ) : [EOL] requirements_txt = tmpdir . join ( [string] ) [EOL] constraints_txt = tmpdir . join ( [string] ) [EOL] [EOL] with open ( requirements_txt , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] print ( [string] + str ( constraints_txt ) , file = f ) [EOL] with open ( constraints_txt , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] [EOL] original_requirements_file = RequirementsFile ( str ( requirements_txt ) , project_dir , requirement_parser , logger ) [EOL] original_requirements_file . process ( ) [EOL] [EOL] requirement_set = RequirementSet . from_file ( original_requirements_file , current_platform , requirement_parser , logger ) [EOL] [EOL] new_requirements_file = requirement_set . to_file ( project_dir , current_platform , requirement_parser , logger ) [EOL] [EOL] assert [string] not in new_requirements_file . read ( ) [EOL] [EOL] [EOL] def test_include_lines_are_respected_when_generating_from_file ( tmpdir , project_dir , current_platform , requirement_parser , logger ) : [EOL] requirements_txt = tmpdir . join ( [string] ) [EOL] included_requirements_txt = tmpdir . join ( [string] ) [EOL] [EOL] with open ( requirements_txt , [string] ) as f : [EOL] print ( [string] + str ( included_requirements_txt ) , file = f ) [EOL] with open ( included_requirements_txt , [string] ) as f : [EOL] print ( [string] , file = f ) [EOL] requirements_file = RequirementsFile ( str ( requirements_txt ) , project_dir , requirement_parser , logger ) [EOL] requirements_file . process ( ) [EOL] requirement_set = RequirementSet . from_file ( requirements_file , current_platform , requirement_parser , logger ) [EOL] [EOL] assert [string] in requirement_set [EOL] [EOL] [EOL] def test_that_we_can_query_for_added_requirements ( requirement_set , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] requirement_set . add ( requirement ) [EOL] assert requirement_set [ requirement . name ( ) ] == requirement [EOL] [EOL] [EOL] def test_that_querying_for_non_existing_requirement_raises_key_error ( requirement_set ) : [EOL] with pytest . raises ( KeyError ) : [EOL] requirement_set [ [string] ] [EOL] [EOL] [EOL] def test_that_queries_into_set_are_canonicalized ( requirement_set , requirement_parser ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] requirement_set . add ( requirement ) [EOL] assert requirement_set [ [string] ] == requirement [EOL] [EOL] [EOL] def test_that_get_method_returns_none_if_key_not_found ( requirement_set ) : [EOL] assert requirement_set . get ( [string] ) is None [EOL] [EOL] [EOL] def test_that_get_method_returns_specified_default_value_when_not_found ( requirement_set , ) : [EOL] assert requirement_set . get ( [string] , [number] ) == [number] [EOL] [EOL] [EOL] def test_that_filter_works_by_name ( requirement_parser , requirement_set ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] requirement_set . add ( requirement ) [EOL] [EOL] assert len ( requirement_set ) == [number] [EOL] [EOL] filtered_requirement_set = requirement_set . filter ( lambda req : req . name ( ) != [string] ) [EOL] [EOL] assert len ( filtered_requirement_set ) == [number] [EOL] [EOL] [EOL] def test_that_extras_are_preserved_when_converting_to_and_from_a_file ( requirement_parser , requirement_set , current_platform , project_dir , logger , ) : [EOL] requirement_set . add ( requirement_parser . parse ( [string] ) ) [EOL] requirements_file = requirement_set . to_file ( project_dir , current_platform , requirement_parser , logger ) [EOL] new_requirements_set = RequirementSet . from_file ( requirements_file , current_platform , requirement_parser , logger ) [EOL] requirement = new_requirements_set [ [string] ] [EOL] assert requirement . extras ( ) == { [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import ProxyLogger [EOL] from pypi2nix . logger import StreamLogger [EOL] [EOL] [EOL] def get_logger_output ( logger ) : [EOL] def get_inner_logger ( logger ) : [EOL] if isinstance ( logger , StreamLogger ) : [EOL] return logger [EOL] elif isinstance ( logger , ProxyLogger ) : [EOL] inner_logger = logger . get_target_logger ( ) [EOL] if inner_logger is None : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] return get_inner_logger ( inner_logger ) [EOL] else : [EOL] raise Exception ( [string] , type ( logger ) ) [EOL] [EOL] logger = get_inner_logger ( logger ) [EOL] logger . output . seek ( [number] ) [EOL] output = logger . output . read ( ) [EOL] logger . output . seek ( [number] , [number] ) [EOL] return output [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $pypi2nix.logger.StreamLogger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Type [EOL] import typing [EOL] import pypi2nix [EOL] import unittests [EOL] import json [EOL] import os [EOL] import os . path [EOL] import platform [EOL] import sys [EOL] from collections import namedtuple [EOL] [EOL] import pytest [EOL] from packaging . markers import default_environment [EOL] [EOL] from pypi2nix . environment_marker import EnvironmentMarker [EOL] from pypi2nix . python_version import PythonVersion [EOL] from pypi2nix . target_platform import PlatformGenerator [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . switches import nix [EOL] [EOL] [EOL] def format_full_version ( info ) : [EOL] version = [string] . format ( info ) [EOL] kind = info . releaselevel [EOL] if kind != [string] : [EOL] version += kind [ [number] ] + str ( info . serial ) [EOL] return version [EOL] [EOL] [EOL] @ pytest . fixture def python_3_environment_nix ( tmp_path_factory ) : [EOL] directory = str ( tmp_path_factory . mktemp ( [string] ) ) [EOL] path = os . path . join ( directory , [string] ) [EOL] with open ( path , [string] ) as f : [EOL] f . write ( [string] . join ( [ [string] , [string] , ] ) ) [EOL] return path [EOL] [EOL] [EOL] @ pytest . fixture def python_3_6_environment_nix ( tmp_path_factory ) : [EOL] directory = str ( tmp_path_factory . mktemp ( [string] ) ) [EOL] path = os . path . join ( directory , [string] ) [EOL] with open ( path , [string] ) as f : [EOL] f . write ( [string] . join ( [ [string] , [string] , ] ) ) [EOL] return path [EOL] [EOL] [EOL] MarkerDefinition = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( MarkerDefinition ( [string] , os . name ) , MarkerDefinition ( [string] , sys . platform ) , MarkerDefinition ( [string] , platform . machine ( ) ) , MarkerDefinition ( [string] , platform . python_implementation ( ) ) , MarkerDefinition ( [string] , platform . release ( ) ) , MarkerDefinition ( [string] , platform . system ( ) ) , MarkerDefinition ( [string] , platform . version ( ) ) , MarkerDefinition ( [string] , [string] . join ( platform . python_version_tuple ( ) [ : [number] ] ) ) , MarkerDefinition ( [string] , platform . python_version ( ) ) , MarkerDefinition ( [string] , sys . implementation . name ) , MarkerDefinition ( [string] , format_full_version ( sys . implementation . version ) [EOL] if hasattr ( sys , [string] ) [EOL] else [string] , ) , ) ) def environment_marker_definition ( request ) : [EOL] [docstring] [EOL] return request . param [EOL] [EOL] [EOL] @ nix def test_that_target_platform_can_be_constructed_from_python_version ( platform_generator , nix , python_3_environment_nix ) : [EOL] platform = platform_generator . from_python_version ( PythonVersion . python3 ) [EOL] assert isinstance ( platform , TargetPlatform ) [EOL] [EOL] python_3_version = nix . shell ( command = [string] , derivation_path = python_3_environment_nix , ) . splitlines ( ) [ [number] ] [EOL] assert platform . python_version == python_3_version [EOL] [EOL] [EOL] @ nix def test_that_current_platform_to_environment_dict_equals_default_environment ( current_platform , ) : [EOL] assert current_platform . environment_dictionary ( ) == default_environment ( ) [EOL] [EOL] [EOL] @ nix def test_that_generated_platform_environment_dictionary_respects_python_version ( platform_generator , python_3_6_environment_nix , nix ) : [EOL] platform = platform_generator . from_python_version ( PythonVersion . python36 ) [EOL] assert isinstance ( platform , TargetPlatform ) [EOL] output_string = nix . shell ( command = [string] . join ( [ [string] , [string] , [string] , ] ) , derivation_path = python_3_6_environment_nix , ) [EOL] output_json = json . loads ( output_string ) [EOL] assert platform . environment_dictionary ( ) == output_json [EOL] [EOL] [EOL] def test_that_environment_marker_with_unknown_os_name_do_not_apply_to_current_platform ( current_platform , ) : [EOL] marker = EnvironmentMarker ( [string] ) [EOL] assert not marker . applies_to_platform ( current_platform ) [EOL] [EOL] [EOL] def test_that_environment_markers_from_pep_are_correct_for_current_platform ( environment_marker_definition , current_platform ) : [EOL] assert ( getattr ( current_platform , environment_marker_definition . name ) == environment_marker_definition . value ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 $typing.Type[unittests.test_target_platform.MarkerDefinition]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import typing [EOL] [docstring] [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] [EOL] [EOL] def test_can_parse_enum_requirement_from_issue_363 ( requirement_parser , ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL] [EOL] [EOL] def test_can_parse_pyinotify_requirement_from_issue_363 ( requirement_parser , ) : [EOL] requirement = requirement_parser . parse ( [string] ) [EOL] assert requirement . name ( ) == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . . switches import nix [EOL] [EOL] [EOL] @ nix def test_pip_can_install_wheels_previously_downloaded ( pip , project_dir , current_platform , requirement_parser , download_dir , wheels_dir , ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . download_sources ( requirements , download_dir ) [EOL] pip . build_wheels ( requirements = requirements , source_directories = [ download_dir ] , target_directory = wheels_dir , ) [EOL] assert wheels_dir . list_files ( ) [EOL] assert any ( map ( lambda x : x . endswith ( [string] ) , wheels_dir . list_files ( ) ) ) [EOL] [EOL] [EOL] @ nix def test_pip_wheel_does_not_build_wheels_if_requirements_are_empty ( pip , wheels_dir , download_dir , current_platform ) : [EOL] pip . build_wheels ( requirements = RequirementSet ( current_platform ) , target_directory = wheels_dir , source_directories = [ download_dir ] , ) [EOL] assert not wheels_dir . list_files ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os [EOL] import os . path [EOL] [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . . switches import nix [EOL] [EOL] [EOL] @ nix def test_install_six_yields_non_empty_freeze_output ( pip , project_dir , download_dir , current_platform , requirement_parser , ) : [EOL] lib_dir = Path ( os . path . join ( project_dir , [string] ) ) [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . download_sources ( requirements , download_dir ) [EOL] pip . install ( requirements , source_directories = [ download_dir ] , target_directory = lib_dir ) [EOL] assert pip . freeze ( [ lib_dir ] ) [EOL] [EOL] [EOL] @ nix def test_install_to_target_directory_does_not_install_to_default_directory ( pip , project_dir , download_dir , current_platform , requirement_parser , ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] target_directory = Path ( project_dir ) / [string] [EOL] target_directory . ensure_directory ( ) [EOL] pip . download_sources ( requirements , download_dir ) [EOL] [EOL] assert not target_directory . list_files ( ) [EOL] [EOL] pip . install ( requirements , source_directories = [ download_dir ] , target_directory = target_directory , ) [EOL] [EOL] assert target_directory . list_files ( ) [EOL] [EOL] [EOL] @ nix def test_install_does_not_install_anything_with_empty_requirements ( pip , project_dir , current_platform ) : [EOL] target_directory = Path ( project_dir ) / [string] [EOL] target_directory . ensure_directory ( ) [EOL] pip . install ( RequirementSet ( current_platform ) , [ ] , target_directory ) [EOL] assert not target_directory . list_files ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , List [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import os . path [EOL] from typing import List [EOL] [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . . switches import nix [EOL] [EOL] [EOL] def list_files ( dirname ) : [EOL] return [ candidate for candidate in os . listdir ( dirname ) if os . path . isfile ( os . path . join ( dirname , candidate ) ) ] [EOL] [EOL] [EOL] @ nix def test_pip_downloads_sources_to_target_directory ( pip , project_dir , current_platform , requirement_parser , ) : [EOL] download_path = Path ( project_dir ) / [string] [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . download_sources ( requirements = requirements , target_directory = download_path ) [EOL] assert download_path . list_files ( ) [EOL] [EOL] [EOL] @ nix def test_pip_downloads_nothing_when_no_requirements_are_given ( pip , download_dir , current_platform ) : [EOL] pip . download_sources ( requirements = RequirementSet ( current_platform ) , target_directory = download_dir ) [EOL] assert not download_dir . list_files ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import os . path [EOL] import venv [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import NixPip [EOL] from pypi2nix . pip import VirtualenvPip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] @ pytest . fixture ( params = ( [string] , [string] ) ) def pip ( request , nix , project_dir , current_platform , logger , requirement_parser , ) : [EOL] if request . param == [string] : [EOL] return NixPip ( nix = nix , project_directory = Path ( project_dir ) , extra_build_inputs = [ ] , extra_env = [string] , wheels_cache = [ ] , target_platform = current_platform , logger = logger , requirement_parser = requirement_parser , ) [EOL] else : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = os . path . join ( project_dir , [string] ) , env_builder = venv . EnvBuilder ( with_pip = True ) , requirement_parser = requirement_parser , ) [EOL] pip . prepare_virtualenv ( ) [EOL] return pip [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . . switches import nix [EOL] [EOL] [EOL] @ nix def test_freeze_on_empty_environment_yields_empty_file ( pip ) : [EOL] frozen_requirements = pip . freeze ( [ ] ) [EOL] assert not frozen_requirements . strip ( ) [EOL] [EOL] [EOL] @ nix def test_freeze_respects_additional_python_path ( pip , project_dir , current_platform , requirement_parser , download_dir , ) : [EOL] prefix = Path ( project_dir ) / [string] [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip . download_sources ( requirements , download_dir ) [EOL] pip . install ( requirements , target_directory = prefix , source_directories = [ download_dir ] ) [EOL] freeze_without_six = pip . freeze ( [ ] ) [EOL] freeze_with_six = pip . freeze ( python_path = [ prefix ] ) [EOL] assert len ( freeze_without_six ) < len ( freeze_with_six ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import os [EOL] import os . path [EOL] import venv [EOL] [EOL] import pytest [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import PipFailed [EOL] from pypi2nix . pip import VirtualenvPip [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] @ pytest . fixture def pip_without_index ( logger , current_platform , project_dir , wheel_distribution_archive_path , requirement_parser , ) : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = os . path . join ( project_dir , [string] ) , env_builder = venv . EnvBuilder ( with_pip = True ) , no_index = True , wheel_distribution_path = wheel_distribution_archive_path , requirement_parser = requirement_parser , ) [EOL] pip . prepare_virtualenv ( ) [EOL] return pip [EOL] [EOL] [EOL] @ pytest . fixture def pip_from_data_directory ( logger , current_platform , project_dir , wheel_distribution_archive_path , data_directory , requirement_parser , ) : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = os . path . join ( project_dir , [string] ) , env_builder = venv . EnvBuilder ( with_pip = True ) , no_index = True , wheel_distribution_path = wheel_distribution_archive_path , find_links = [ data_directory ] , requirement_parser = requirement_parser , ) [EOL] pip . prepare_virtualenv ( ) [EOL] return pip [EOL] [EOL] [EOL] def test_pip_without_index_cannot_download_six ( pip_without_index , download_dir , requirement_parser , current_platform , ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] with pytest . raises ( PipFailed ) : [EOL] pip_without_index . download_sources ( requirements , download_dir ) [EOL] [EOL] [EOL] def test_pip_without_index_cannot_be_prepared_without_wheel_supplied ( logger , current_platform , project_dir , requirement_parser , ) : [EOL] pip = VirtualenvPip ( logger = logger , target_platform = current_platform , target_directory = os . path . join ( project_dir , [string] ) , env_builder = venv . EnvBuilder ( with_pip = True ) , no_index = True , requirement_parser = requirement_parser , ) [EOL] with pytest . raises ( PipFailed ) : [EOL] pip . prepare_virtualenv ( ) [EOL] [EOL] [EOL] def test_pip_with_data_directory_index_can_download_six ( pip_from_data_directory , download_dir , requirement_parser , current_platform , ) : [EOL] requirements = RequirementSet ( current_platform ) [EOL] requirements . add ( requirement_parser . parse ( [string] ) ) [EOL] pip_from_data_directory . download_sources ( requirements , download_dir ) [EOL] [EOL] [EOL] def test_that_set_environment_variable_undoes_changes_when_exiting ( pip_without_index , ) : [EOL] old_environment = dict ( os . environ ) [EOL] with pip_without_index . _set_environment_variable ( { [string] : [string] } ) : [EOL] pass [EOL] assert dict ( os . environ ) == old_environment [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pip.VirtualenvPip$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pip.VirtualenvPip$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Optional , Set , Callable [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import urllib [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from typing import Callable [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Set [EOL] from typing import Tuple [EOL] from urllib . parse import urlparse [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from attr import evolve [EOL] from packaging . utils import canonicalize_name [EOL] [EOL] from pypi2nix . environment_marker import EnvironmentMarker [EOL] from pypi2nix . environment_marker import MarkerEvaluationFailed [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package_source import GitSource [EOL] from pypi2nix . package_source import HgSource [EOL] from pypi2nix . package_source import PackageSource [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . package_source import UrlSource [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class IncompatibleRequirements ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Requirement ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def name ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def extras ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def add ( self , other , target_platform ) : [EOL] pass [EOL] [EOL] @ abstractmethod def source ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def environment_markers ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def logger ( self ) : [EOL] pass [EOL] [EOL] def applies_to_target ( self , target_platform , extras = [ ] ) : [EOL] environment_markers = self . environment_markers ( ) [EOL] try : [EOL] return ( True [EOL] if environment_markers is None [EOL] else environment_markers . applies_to_platform ( target_platform , extras ) ) [EOL] except MarkerEvaluationFailed as e : [EOL] self . logger ( ) . warning ( [string] . format ( marker = environment_markers , message = e . args ) ) [EOL] return False [EOL] [EOL] @ abstractmethod def to_line ( self ) : [EOL] pass [EOL] [EOL] [EOL] @ attrs class UrlRequirement ( Requirement ) : [EOL] _name = attrib ( ) [EOL] _url = attrib ( ) [EOL] _extras = attrib ( ) [EOL] _environment_markers = attrib ( ) [EOL] _logger = attrib ( ) [EOL] [EOL] def name ( self ) : [EOL] return canonicalize_name ( self . _name ) [EOL] [EOL] def extras ( self ) : [EOL] return self . _extras [EOL] [EOL] def logger ( self ) : [EOL] return self . _logger [EOL] [EOL] def add ( self , other , target_platform ) : [EOL] if not self . applies_to_target ( target_platform ) : [EOL] return other [EOL] elif not other . applies_to_target ( target_platform ) : [EOL] return self [EOL] elif self . name ( ) != other . name ( ) : [EOL] raise IncompatibleRequirements ( [string] . format ( name1 = self . name ( ) , name2 = other . name ( ) ) ) [EOL] else : [EOL] if isinstance ( other , VersionRequirement ) : [EOL] return self [EOL] elif isinstance ( other , PathRequirement ) : [EOL] raise IncompatibleRequirements ( [string] . format ( url = self . url , path = other . path ) ) [EOL] elif isinstance ( other , UrlRequirement ) : [EOL] if self . url != other . url : [EOL] raise IncompatibleRequirements ( [string] . format ( url1 = self . url , url2 = other . url ) ) [EOL] else : [EOL] return self [EOL] else : [EOL] raise IncompatibleRequirements ( [string] . format ( other ) ) [EOL] [EOL] def source ( self ) : [EOL] if self . _url . startswith ( [string] ) : [EOL] return self . _handle_git_source ( self . _url [ [number] : ] ) [EOL] elif self . _url . startswith ( [string] ) : [EOL] return self . _handle_git_source ( self . _url ) [EOL] elif self . _url . startswith ( [string] ) : [EOL] return self . _handle_hg_source ( self . _url [ [number] : ] ) [EOL] elif self . url_scheme ( ) == [string] : [EOL] return PathSource ( path = self . url_path ( ) ) [EOL] else : [EOL] return UrlSource ( url = self . _url , logger = self . _logger ) [EOL] [EOL] def environment_markers ( self ) : [EOL] return self . _environment_markers [EOL] [EOL] def _handle_hg_source ( self , url ) : [EOL] try : [EOL] url , rev = url . split ( [string] ) [EOL] except ValueError : [EOL] return HgSource ( url = url , logger = self . _logger ) [EOL] else : [EOL] return HgSource ( url = url , revision = rev , logger = self . _logger ) [EOL] [EOL] def _handle_git_source ( self , url ) : [EOL] try : [EOL] url , rev = url . split ( [string] ) [EOL] except ValueError : [EOL] return GitSource ( url = url ) [EOL] else : [EOL] return GitSource ( url = url , revision = rev ) [EOL] [EOL] def to_line ( self ) : [EOL] extras = [string] + [string] . join ( self . extras ( ) ) + [string] if self . extras ( ) else [string] [EOL] return [string] . format ( url = self . _url , name = self . name ( ) , extras = extras ) [EOL] [EOL] def url ( self ) : [EOL] return self . _url [EOL] [EOL] def url_scheme ( self ) : [EOL] url = urlparse ( self . url ( ) ) [EOL] return url . scheme [EOL] [EOL] def url_path ( self ) : [EOL] url = urlparse ( self . url ( ) ) [EOL] return url . path [EOL] [EOL] [EOL] @ attrs class PathRequirement ( Requirement ) : [EOL] _name = attrib ( ) [EOL] _path = attrib ( ) [EOL] _extras = attrib ( ) [EOL] _environment_markers = attrib ( ) [EOL] _logger = attrib ( ) [EOL] [EOL] def name ( self ) : [EOL] return canonicalize_name ( self . _name ) [EOL] [EOL] def extras ( self ) : [EOL] return self . _extras [EOL] [EOL] def logger ( self ) : [EOL] return self . _logger [EOL] [EOL] def add ( self , other , target_platform ) : [EOL] if not self . applies_to_target ( target_platform ) : [EOL] return other [EOL] elif not other . applies_to_target ( target_platform ) : [EOL] return self [EOL] elif self . name ( ) != other . name ( ) : [EOL] raise IncompatibleRequirements ( [string] . format ( name1 = self . name ( ) , name2 = other . name ( ) ) ) [EOL] else : [EOL] if isinstance ( other , VersionRequirement ) : [EOL] return self [EOL] elif isinstance ( other , UrlRequirement ) : [EOL] raise IncompatibleRequirements ( [string] . format ( path = self . path , url = other . url ) ) [EOL] elif isinstance ( other , PathRequirement ) : [EOL] if self . path != other . path : [EOL] raise IncompatibleRequirements ( [string] . format ( path1 = self . path , path2 = other . path ) ) [EOL] else : [EOL] return self [EOL] else : [EOL] raise IncompatibleRequirements ( [string] . format ( other ) ) [EOL] [EOL] def source ( self ) : [EOL] return PathSource ( path = self . _path ) [EOL] [EOL] def environment_markers ( self ) : [EOL] return self . _environment_markers [EOL] [EOL] def to_line ( self ) : [EOL] extras = [string] + [string] . join ( self . extras ( ) ) + [string] if self . extras ( ) else [string] [EOL] return [string] . format ( path = self . _path , extras = extras , name = self . name ( ) ) [EOL] [EOL] def path ( self ) : [EOL] return self . _path [EOL] [EOL] def change_path ( self , mapping ) : [EOL] return evolve ( self , path = mapping ( self . _path ) ) [EOL] [EOL] [EOL] @ attrs class VersionRequirement ( Requirement ) : [EOL] _name = attrib ( ) [EOL] _versions = attrib ( ) [EOL] _extras = attrib ( ) [EOL] _environment_markers = attrib ( ) [EOL] _logger = attrib ( ) [EOL] [EOL] def name ( self ) : [EOL] return canonicalize_name ( self . _name ) [EOL] [EOL] def extras ( self ) : [EOL] return self . _extras [EOL] [EOL] def logger ( self ) : [EOL] return self . _logger [EOL] [EOL] def add ( self , other , target_platform ) : [EOL] if not self . applies_to_target ( target_platform ) : [EOL] return other [EOL] elif not other . applies_to_target ( target_platform ) : [EOL] return self [EOL] elif self . name ( ) != other . name ( ) : [EOL] raise IncompatibleRequirements ( [string] . format ( name1 = self . name ( ) , name2 = other . name ( ) ) ) [EOL] else : [EOL] if isinstance ( other , PathRequirement ) : [EOL] return other [EOL] elif isinstance ( other , UrlRequirement ) : [EOL] return other [EOL] elif isinstance ( other , VersionRequirement ) : [EOL] return VersionRequirement ( name = self . name ( ) , extras = self . _extras . union ( other . _extras ) , versions = self . version ( ) + other . version ( ) , environment_markers = None , logger = self . logger ( ) , ) [EOL] else : [EOL] raise IncompatibleRequirements ( [string] . format ( other ) ) [EOL] [EOL] def source ( self ) : [EOL] return None [EOL] [EOL] def environment_markers ( self ) : [EOL] return self . _environment_markers [EOL] [EOL] def version ( self ) : [EOL] return self . _versions [EOL] [EOL] def to_line ( self ) : [EOL] version = [string] . join ( [ [string] . format ( operator = operator , specifier = specifier ) for operator , specifier in self . _versions ] ) [EOL] extras = ( [string] . format ( extras = [string] . join ( self . extras ( ) ) ) if self . extras ( ) else [string] ) [EOL] return [string] . format ( name = self . _name , version = version , extras = extras ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $"Requirement"$ 0 0 0 $"Requirement"$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package_source.PackageSource]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 $pypi2nix.package_source.PackageSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.package_source.HgSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.package_source.GitSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 $pypi2nix.package_source.PathSource$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $"PathRequirement"$ 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Callable[[builtins.str],builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 $Requirement$ 0 0 0 $Requirement$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 $Requirement$ 0 0 0 0 $Requirement$ 0 0 0 0 0 0 $Requirement$ 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Requirement$ 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.environment_marker.EnvironmentMarker]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0
from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] from typing import List [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from packaging . markers import InvalidMarker [EOL] from packaging . markers import Marker [EOL] from packaging . markers import UndefinedComparison [EOL] from packaging . markers import UndefinedEnvironmentName [EOL] [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class MarkerEvaluationFailed ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] @ attrs class EnvironmentMarker : [EOL] _marker_string = attrib ( ) [EOL] [EOL] def applies_to_platform ( self , target_platform , extras = [ ] ) : [EOL] def _applies_to_platform_with_extra ( extra ) : [EOL] environment = target_platform . environment_dictionary ( ) [EOL] environment [ [string] ] = extra [EOL] try : [EOL] return Marker ( self . _marker_string ) . evaluate ( environment ) [EOL] except ( InvalidMarker , UndefinedComparison , UndefinedEnvironmentName ) : [EOL] raise MarkerEvaluationFailed ( f" [string] { self . _marker_string }" ) [EOL] [EOL] if not extras : [EOL] extras = [ [string] ] [EOL] for extra in extras : [EOL] if _applies_to_platform_with_extra ( extra ) : [EOL] return True [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Iterable , Any , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os [EOL] import os . path [EOL] from typing import Iterable [EOL] from typing import Optional [EOL] [EOL] from packaging . utils import canonicalize_name [EOL] [EOL] from pypi2nix . archive import Archive [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package import DistributionNotDetected [EOL] from pypi2nix . package import HasBuildDependencies [EOL] from pypi2nix . package import PackageMetadata [EOL] from pypi2nix . package import PyprojectToml [EOL] from pypi2nix . package import SetupCfg [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import Requirement [EOL] from pypi2nix . requirements import VersionRequirement [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class SourceDistribution ( HasBuildDependencies ) : [EOL] def __init__ ( self , name , logger , requirement_parser , pyproject_toml = None , setup_cfg = None , ) : [EOL] self . name = canonicalize_name ( name ) [EOL] self . pyproject_toml = pyproject_toml [EOL] self . setup_cfg = setup_cfg [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] [EOL] @ property def package_format ( self ) : [EOL] if self . pyproject_toml : [EOL] return [string] [EOL] else : [EOL] return [string] [EOL] [EOL] @ classmethod def from_archive ( source_distribution , archive , logger , requirement_parser , ) : [EOL] with archive . extracted_files ( ) as extraction_directory : [EOL] first_level_paths = os . listdir ( extraction_directory ) [EOL] if len ( first_level_paths ) != [number] : [EOL] raise DistributionNotDetected ( f" [string] { archive }" ) [EOL] package_dir = os . path . join ( extraction_directory , first_level_paths [ [number] ] ) [EOL] if not os . path . isdir ( package_dir ) : [EOL] raise DistributionNotDetected ( f" [string] { archive }" ) [EOL] extracted_files = [ os . path . join ( package_dir , file_name ) for file_name in os . listdir ( package_dir ) if os . path . isfile ( os . path . join ( package_dir , file_name ) ) ] [EOL] setup_cfg = source_distribution . get_setup_cfg ( extracted_files , logger , requirement_parser ) [EOL] metadata = source_distribution . _get_package_metadata ( package_dir ) [EOL] name = source_distribution . _get_name ( setup_cfg , metadata , archive ) [EOL] pyproject_toml = source_distribution . get_pyproject_toml ( name , extracted_files , logger , requirement_parser ) [EOL] return source_distribution ( name = name , pyproject_toml = pyproject_toml , setup_cfg = setup_cfg , logger = logger , requirement_parser = requirement_parser , ) [EOL] [EOL] @ classmethod def get_pyproject_toml ( _ , name , extracted_files , logger , requirement_parser , ) : [EOL] pyproject_toml_candidates = [ filepath for filepath in extracted_files if os . path . basename ( filepath ) == [string] ] [EOL] if pyproject_toml_candidates : [EOL] with open ( pyproject_toml_candidates [ [number] ] ) as f : [EOL] content = f . read ( ) [EOL] return PyprojectToml ( name = name , file_content = content , requirement_parser = requirement_parser , logger = logger , ) [EOL] else : [EOL] return None [EOL] [EOL] @ classmethod def get_setup_cfg ( _ , extracted_files , logger , requirement_parser , ) : [EOL] setup_cfg_candidates = [ filepath for filepath in extracted_files if os . path . basename ( filepath ) == [string] ] [EOL] if setup_cfg_candidates : [EOL] return SetupCfg ( setup_cfg_path = setup_cfg_candidates [ [number] ] , logger = logger , requirement_parser = requirement_parser , ) [EOL] else : [EOL] return None [EOL] [EOL] @ classmethod def _get_package_metadata ( self , path ) : [EOL] try : [EOL] return PackageMetadata . from_package_directory ( path = path ) [EOL] except DistributionNotDetected : [EOL] return None [EOL] [EOL] @ classmethod def _get_name ( self , setup_cfg , metadata , archive , ) : [EOL] if setup_cfg and metadata : [EOL] if setup_cfg . name != metadata . name and setup_cfg . name is not None : [EOL] raise DistributionNotDetected ( f" [string] { setup_cfg . name } [string] { metadata . name } [string] { archive }" ) [EOL] else : [EOL] return metadata . name [EOL] elif setup_cfg and setup_cfg . name is not None : [EOL] return setup_cfg . name [EOL] elif metadata is not None : [EOL] return metadata . name [EOL] else : [EOL] raise DistributionNotDetected ( f" [string] { archive }" ) [EOL] [EOL] def to_loose_requirement ( self ) : [EOL] return VersionRequirement ( name = self . name , versions = [ ] , extras = set ( ) , environment_markers = None , logger = self . logger , ) [EOL] [EOL] def build_dependencies ( self , target_platform ) : [EOL] build_dependencies = RequirementSet ( target_platform ) [EOL] if self . pyproject_toml is not None : [EOL] build_dependencies += self . pyproject_toml . build_dependencies ( target_platform ) [EOL] if self . setup_cfg is not None : [EOL] build_dependencies += self . setup_cfg . build_dependencies ( target_platform ) [EOL] return build_dependencies . filter ( lambda requirement : requirement . name != self . name ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . name } [string] " [EOL] [EOL] def __repr__ ( self ) : [EOL] return f" [string] { self . name } [string] { self . logger } [string] { self . requirement_parser } [string] { self . pyproject_toml } [string] { self . setup_cfg } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"SourceDistribution"$ 0 0 0 $pypi2nix.archive.Archive$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.PyprojectToml]$ 0 0 0 $builtins.str$ 0 $typing.Iterable[builtins.str]$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 $typing.Iterable[builtins.str]$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.SetupCfg]$ 0 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 0 0 0 $typing.Optional[pypi2nix.package.PackageMetadata]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.archive.Archive$ 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Any , List , Dict [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [comment] [EOL] [EOL] import email [EOL] import hashlib [EOL] import json [EOL] import os . path [EOL] import tempfile [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Iterable [EOL] from typing import List [EOL] from urllib . request import urlopen [EOL] [EOL] import click [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package_source import UrlSource [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import Requirement [EOL] from pypi2nix . source_distribution import SourceDistribution [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . utils import cmd [EOL] from pypi2nix . utils import prefetch_git [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] [EOL] class MetadataFetcher : [EOL] def __init__ ( self , sources , logger , requirement_parser , pypi , ) : [EOL] self . sources = sources [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] self . pypi = pypi [EOL] [EOL] def main ( self , wheel_paths , target_platform , source_distributions , ) : [EOL] [docstring] [EOL] output = [string] [EOL] metadata = [ ] [EOL] [EOL] self . logger . info ( [string] ) [EOL] for name , source in self . sources . items ( ) : [EOL] self . logger . info ( [string] . format ( name = name , source = name ) ) [EOL] self . logger . info ( [string] ) [EOL] [EOL] wheels = [ ] [EOL] for wheel_path in wheel_paths : [EOL] [EOL] self . logger . debug ( [string] % os . path . basename ( wheel_path ) ) [EOL] [EOL] wheel_metadata = Wheel . from_wheel_directory_path ( wheel_path , target_platform , self . logger , self . requirement_parser ) [EOL] if not wheel_metadata : [EOL] continue [EOL] [EOL] if wheel_metadata . name in source_distributions : [EOL] source_distribution = source_distributions [ wheel_metadata . name ] [EOL] wheel_metadata . add_build_dependencies ( source_distribution . build_dependencies ( target_platform ) ) [EOL] wheel_metadata . package_format = source_distribution . package_format [EOL] [EOL] wheels . append ( wheel_metadata ) [EOL] [EOL] self . logger . debug ( [string] ) [EOL] self . logger . debug ( json . dumps ( wheel_metadata . to_dict ( ) , sort_keys = True , indent = [number] ) ) [EOL] self . logger . debug ( [string] ) [EOL] [EOL] self . process_wheel ( wheel_metadata ) [EOL] return wheels [EOL] [EOL] def process_wheel ( self , wheel ) : [EOL] if wheel . name not in self . sources : [EOL] release = self . pypi . get_source_release ( wheel . name , wheel . version ) [EOL] if release : [EOL] source = UrlSource ( url = release . url , logger = self . logger , hash_value = release . sha256_digest , ) [EOL] self . sources . add ( wheel . name , source ) [EOL] else : [EOL] self . logger . error ( f" [string] { wheel . name } [string] { wheel . version } [string] " ) [EOL] raise MetadataFetchingFailed ( ) [EOL] [EOL] [EOL] class MetadataFetchingFailed ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.wheel.Wheel]$ 0 0 0 $typing.Iterable[builtins.str]$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 $typing.Dict[builtins.str,pypi2nix.source_distribution.SourceDistribution]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[pypi2nix.wheel.Wheel]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.Iterable[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,pypi2nix.source_distribution.SourceDistribution]$ 0 0 $typing.Any$ 0 $typing.Dict[builtins.str,pypi2nix.source_distribution.SourceDistribution]$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 $None$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Dict [EOL] import pypi2nix [EOL] import src [EOL] import email [EOL] import typing [EOL] import builtins [EOL] import email . parser [EOL] import os . path [EOL] from email . header import Header [EOL] from email . message import Message [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] import click [EOL] from packaging . utils import canonicalize_name [EOL] [EOL] from pypi2nix . license import find_license [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . nix_language import escape_string [EOL] from pypi2nix . package import HasBuildDependencies [EOL] from pypi2nix . package import HasRuntimeDependencies [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class Wheel ( HasRuntimeDependencies , HasBuildDependencies ) : [EOL] def __init__ ( self , name , version , deps , homepage , license , description , build_dependencies , target_platform , ) : [EOL] self . name = canonicalize_name ( name ) [EOL] self . version = version [EOL] self . _deps = deps [EOL] self . homepage = homepage [EOL] self . license = license [EOL] self . description = description [EOL] self . _build_dependencies = build_dependencies [EOL] self . _target_platform = target_platform [EOL] self . package_format = [string] [EOL] [EOL] def to_dict ( self ) : [EOL] return { [string] : self . name , [string] : self . version , [string] : [ requirement . name ( ) for requirement in self . _deps ] , [string] : self . homepage , [string] : self . license , [string] : self . description , [string] : [ requirement . name ( ) for requirement in self . _build_dependencies ] , } [EOL] [EOL] def build_dependencies ( self , target_platform ) : [EOL] if target_platform != self . _target_platform : [EOL] return RequirementSet ( target_platform ) [EOL] else : [EOL] return self . _build_dependencies [EOL] [EOL] def runtime_dependencies ( self , target_platform ) : [EOL] if target_platform != self . _target_platform : [EOL] return RequirementSet ( target_platform ) [EOL] else : [EOL] return self . dependencies ( [ ] ) [EOL] [EOL] def dependencies ( self , extras = [ ] ) : [EOL] return self . _deps . filter ( lambda requirement : requirement . applies_to_target ( self . _target_platform , extras = extras ) ) [EOL] [EOL] def add_build_dependencies ( self , dependencies ) : [EOL] self . _build_dependencies += dependencies [EOL] [EOL] @ classmethod def from_wheel_directory_path ( wheel_class , wheel_directory_path , target_platform , logger , requirement_parser , ) : [EOL] builder = Builder ( target_platform , wheel_directory_path , logger , requirement_parser ) [EOL] return builder . build ( ) [EOL] [EOL] def target_platform ( self ) : [EOL] return self . _target_platform [EOL] [EOL] [EOL] class Builder : [EOL] def __init__ ( self , target_platform , wheel_directory_path , logger , requirement_parser , ) : [EOL] self . name = None [EOL] self . version = None [EOL] self . target_platform = target_platform [EOL] self . runtime_dependencies = RequirementSet ( target_platform ) [EOL] self . homepage = None [EOL] self . license = None [EOL] self . description = None [EOL] self . build_dependencies = RequirementSet ( target_platform ) [EOL] self . wheel_directory_path = wheel_directory_path [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] self . pkg_info = self . _parse_pkg_info ( ) [EOL] [EOL] def build ( self ) : [EOL] self . _get_name ( ) [EOL] self . _get_version ( ) [EOL] self . _get_runtime_dependencies ( ) [EOL] self . _get_homepage ( ) [EOL] self . _get_license ( ) [EOL] self . _get_description ( ) [EOL] return self . _verify_integrity ( ) [EOL] [EOL] def _verify_integrity ( self ) : [EOL] if self . version is None : [EOL] raise Exception ( f" [string] { self . name } [string] " ) [EOL] if self . name is None : [EOL] raise Exception ( f" [string] { self . wheel_directory_path } [string] " ) [EOL] if self . homepage is None : [EOL] raise Exception ( f" [string] { self . name } [string] " ) [EOL] if self . license is None : [EOL] raise Exception ( f" [string] { self . name } [string] " ) [EOL] if self . description is None : [EOL] raise Exception ( f" [string] { self . name } [string] " ) [EOL] return Wheel ( name = self . name , version = self . version , target_platform = self . target_platform , deps = self . runtime_dependencies , build_dependencies = self . build_dependencies , homepage = self . homepage , license = self . license , description = self . description , ) [EOL] [EOL] def _parse_pkg_info ( self ) : [EOL] metadata_file = os . path . join ( self . wheel_directory_path , [string] ) [EOL] if os . path . exists ( metadata_file ) : [EOL] with open ( metadata_file , [string] , encoding = [string] , errors = [string] ) as headers : [EOL] return email . parser . Parser ( ) . parse ( headers ) [EOL] else : [EOL] raise click . ClickException ( f" [string] { self . wheel_directory_path } [string] " ) [EOL] [EOL] def _get_name ( self ) : [EOL] self . name = str_from_message ( self . pkg_info , [string] ) [EOL] if self . name is None : [EOL] raise Exception ( f" [string] { self . wheel_directory_path }" ) [EOL] self . name = canonicalize_name ( self . name ) [EOL] [EOL] def _get_version ( self ) : [EOL] self . version = str_from_message ( self . pkg_info , [string] ) [EOL] [EOL] def _get_license ( self ) : [EOL] license_string = str_from_message ( self . pkg_info , [string] ) [EOL] if license_string is None : [EOL] license_string = [string] [EOL] classifiers = list_from_message ( self . pkg_info , [string] ) [EOL] if classifiers is None : [EOL] classifiers = [ ] [EOL] self . license = find_license ( classifiers = classifiers , license_string = license_string ) [EOL] [EOL] if self . license is None : [EOL] self . license = [string] + escape_string ( license_string ) + [string] [EOL] self . logger . warning ( f" [string] { license_string } [string] { self . name } [string] " ) [EOL] [EOL] def _get_description ( self ) : [EOL] self . description = str_from_message ( self . pkg_info , [string] ) [EOL] if self . description is None : [EOL] self . description = [string] [EOL] [EOL] def _get_runtime_dependencies ( self ) : [EOL] dependencies = list_from_message ( self . pkg_info , [string] ) [EOL] if dependencies is None : [EOL] dependencies = [ ] [EOL] for dep_string in dependencies : [EOL] dependency = self . requirement_parser . parse ( dep_string ) [EOL] if not self . _is_valid_dependency ( dependency . name ( ) ) : [EOL] continue [EOL] self . runtime_dependencies . add ( dependency ) [EOL] [EOL] def _is_valid_dependency ( self , dependency_name ) : [EOL] canonicalized_dependency = canonicalize_name ( dependency_name ) [EOL] return canonicalized_dependency != self . name [EOL] [EOL] def _get_homepage ( self ) : [EOL] self . homepage = str_from_message ( self . pkg_info , [string] ) [EOL] if not self . homepage : [EOL] self . homepage = [string] [EOL] [EOL] [EOL] def str_from_message ( metadata , key ) : [EOL] maybe_value = metadata . get ( key ) [EOL] if isinstance ( maybe_value , str ) : [EOL] return maybe_value [EOL] else : [EOL] return None [EOL] [EOL] [EOL] def list_from_message ( metadata , key ) : [EOL] maybe_value = metadata . get_all ( key ) [EOL] if isinstance ( maybe_value , list ) : [EOL] return [ str ( item ) if isinstance ( item , Header ) else item for item in maybe_value ] [EOL] else : [EOL] return None [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pypi2nix.requirement_set.RequirementSet$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 $"Wheel"$ 0 0 0 $builtins.str$ 0 $pypi2nix.target_platform.TargetPlatform$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 $src.pypi2nix.wheel.Builder$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 $builtins.str$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 $src.pypi2nix.wheel.Builder$ 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.message.Message$ 0 0 0 0 0 0 0 0 0 $"Wheel"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Wheel"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $email.message.Message$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Dict [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os . path [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . utils import NixOption [EOL] from pypi2nix . utils import cmd [EOL] from pypi2nix . utils import create_command_options [EOL] [EOL] [EOL] class ExecutableNotFound ( FileNotFoundError ) : [EOL] pass [EOL] [EOL] [EOL] class EvaluationFailed ( Exception ) : [EOL] def __init__ ( self , * args , output = None , ** kwargs ) : [comment] [EOL] super ( ) . __init__ ( self , * args , ** kwargs ) [comment] [EOL] self . output = output [EOL] [EOL] [EOL] class Nix : [EOL] def __init__ ( self , logger , nix_path = [ ] , executable_directory = None , ) : [EOL] self . nix_path = nix_path [EOL] self . executable_directory = executable_directory [EOL] self . logger = logger [EOL] [EOL] def evaluate_expression ( self , expression ) : [EOL] output = self . run_nix_command ( [string] , [ [string] , [string] , expression ] ) [EOL] [comment] [EOL] return output [ : - [number] ] [EOL] [EOL] def shell ( self , command , derivation_path , nix_arguments = { } , pure = True , ) : [EOL] output = self . run_nix_command ( [string] , create_command_options ( nix_arguments ) + ( [ [string] ] if pure else [ ] ) + [ derivation_path , [string] , command ] , ) [EOL] return output [EOL] [EOL] def build ( self , source_file , attribute = None , out_link = None , arguments = dict ( ) , ) : [EOL] self . run_nix_command ( [string] , [ source_file ] + ( [ [string] , out_link ] if out_link else [ ] ) + ( [ [string] , attribute ] if attribute else [ ] ) + create_command_options ( arguments ) , ) [EOL] [EOL] def evaluate_file ( self , source_file , attribute = None ) : [EOL] absolute_source_file = os . path . abspath ( source_file ) [EOL] self . evaluate_expression ( f" [string] { absolute_source_file } [string] " + [string] + [string] + f" [string] { attribute }" [EOL] if attribute [EOL] else [string] , ) [EOL] [EOL] def build_expression ( self , expression , out_link = None , arguments = dict ( ) , ) : [EOL] self . run_nix_command ( [string] , [ [string] , expression ] + ( [ [string] , out_link ] if out_link else [ [string] ] ) + create_command_options ( arguments ) , ) [EOL] [EOL] def run_nix_command ( self , binary_name , command ) : [EOL] final_command = ( [ self . executable_path ( binary_name ) ] + self . nix_path_arguments ( ) + command ) [EOL] returncode = ... [EOL] output = ... [EOL] try : [EOL] returncode , output = cmd ( final_command , self . logger ) [EOL] except FileNotFoundError : [EOL] raise ExecutableNotFound ( [string] . format ( program = binary_name ) ) [EOL] if returncode != [number] : [EOL] raise EvaluationFailed ( [string] . format ( program = binary_name , code = returncode ) , output = output , ) [EOL] return output [EOL] [EOL] def nix_path_arguments ( self ) : [EOL] path_arguments = [ ] [EOL] for path in self . nix_path : [EOL] path_arguments . append ( [string] ) [EOL] path_arguments . append ( path ) [EOL] return path_arguments [EOL] [EOL] def executable_path ( self , program_name ) : [EOL] if self . executable_directory is None : [EOL] return program_name [EOL] else : [EOL] return os . path . join ( self . executable_directory , program_name ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0
from typing import Set [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] from typing import Set [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] from pypi2nix . pypi_release import PypiRelease [EOL] [EOL] [EOL] @ attrs class PypiPackage : [EOL] name = attrib ( ) [EOL] releases = attrib ( ) [EOL] version = attrib ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[pypi2nix.pypi_release.PypiRelease]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Tuple , List , Dict [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Tuple [EOL] [EOL] from pypi2nix . package_source import PackageSource [EOL] [EOL] [EOL] class Sources : [EOL] def __init__ ( self ) : [EOL] self . sources = dict ( ) [EOL] [EOL] def add ( self , name , source ) : [EOL] self . sources [ name ] = source [EOL] [EOL] def __contains__ ( self , item ) : [EOL] return item in self . sources [EOL] [EOL] def __getitem__ ( self , item_name ) : [EOL] return self . sources [ item_name ] [EOL] [EOL] def update ( self , other_sources ) : [EOL] self . sources = dict ( self . sources , ** other_sources . sources ) [EOL] [EOL] def items ( self ) : [EOL] return list ( self . sources . items ( ) ) [EOL] [EOL] def __len__ ( self ) : [EOL] return len ( self . sources ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pypi2nix.package_source.PackageSource]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pypi2nix.package_source.PackageSource$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $pypi2nix.package_source.PackageSource$ 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $pypi2nix.package_source.PackageSource$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $"Sources"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Sources"$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,pypi2nix.package_source.PackageSource]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0
import src [EOL] from contextlib import contextmanager [EOL] from typing import no_type_check [EOL] [EOL] from parsley import makeGrammar [EOL] [EOL] from pypi2nix . environment_marker import EnvironmentMarker [EOL] from pypi2nix . logger import ProxyLogger [EOL] from pypi2nix . requirements import PathRequirement [EOL] from pypi2nix . requirements import UrlRequirement [EOL] from pypi2nix . requirements import VersionRequirement [EOL] [EOL] [EOL] class _RequirementParserGrammar : [EOL] [docstring] [EOL] [EOL] @ no_type_check def __init__ ( self ) : [EOL] self . _compiled_grammar = None [EOL] self . _logger = ProxyLogger ( ) [EOL] [EOL] requirement_grammar = [string] [EOL] [EOL] @ no_type_check @ contextmanager def __call__ ( self , logger ) : [EOL] if self . _compiled_grammar is None : [EOL] self . _compiled_grammar = makeGrammar ( self . requirement_grammar , { [string] : VersionRequirement , [string] : UrlRequirement , [string] : PathRequirement , [string] : EnvironmentMarker , [string] : lambda : self . _logger . get_target_logger ( ) , } , ) [EOL] pass [EOL] self . _logger . set_target_logger ( logger ) [EOL] yield self . _compiled_grammar [EOL] [EOL] [EOL] requirement_parser_grammar = _RequirementParserGrammar ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirement_parser_grammar._RequirementParserGrammar$ 0 0 0 0 0
import pypi2nix [EOL] import builtins [EOL] from typing import no_type_check [EOL] [EOL] import parsley [EOL] [EOL] from pypi2nix . requirement_parser_grammar import requirement_parser_grammar [EOL] from pypi2nix . requirements import Logger [EOL] from pypi2nix . requirements import Requirement [EOL] [EOL] [EOL] class ParsingFailed ( Exception ) : [EOL] def __init__ ( self , reason ) : [EOL] self . reason = reason [EOL] [EOL] def __str__ ( self ) : [EOL] return self . reason [EOL] [EOL] [EOL] class RequirementParser : [EOL] def __init__ ( self , logger ) : [EOL] self . _compiled_grammar = None [EOL] self . logger = logger [EOL] [EOL] @ no_type_check def compiled_grammar ( self ) : [EOL] with requirement_parser_grammar ( self . logger ) as grammar : [EOL] return grammar [EOL] [EOL] def parse ( self , line ) : [EOL] line = line . strip ( ) [EOL] if [string] in line : [EOL] raise ParsingFailed ( [string] . format ( line ) ) [EOL] try : [EOL] return self . compiled_grammar ( ) ( line ) . specification ( ) [comment] [EOL] except parsley . ParseError as e : [EOL] raise ParsingFailed ( [string] . format ( message = e . formatError ( ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import os . path [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] VERSION_FILE = os . path . join ( HERE , [string] ) [EOL] with open ( VERSION_FILE ) as handle : [EOL] pypi2nix_version = handle . read ( ) . strip ( ) [EOL]	0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import Verbosity [EOL] from pypi2nix . overrides import Overrides [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . python_version import PythonVersion [EOL] [EOL] [EOL] @ attrs class ApplicationConfiguration : [EOL] verbosity = attrib ( ) [EOL] nix_executable_directory = attrib ( ) [EOL] nix_path = attrib ( ) [EOL] extra_build_inputs = attrib ( ) [EOL] emit_extra_build_inputs = attrib ( ) [EOL] extra_environment = attrib ( ) [EOL] enable_tests = attrib ( ) [EOL] python_version = attrib ( ) [EOL] requirement_files = attrib ( ) [EOL] requirements = attrib ( ) [EOL] setup_requirements = attrib ( ) [EOL] overrides = attrib ( ) [EOL] wheels_caches = attrib ( ) [EOL] output_basename = attrib ( ) [EOL] project_directory = attrib ( ) [EOL] target_directory = attrib ( ) [EOL] dependency_graph_output_location = attrib ( ) [EOL] dependency_graph_input = attrib ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Verbosity$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[pypi2nix.overrides.Overrides]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Optional[pypi2nix.path.Path]$ 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pypi2nix [EOL] import os [EOL] import os . path [EOL] import sys [EOL] from typing import List [EOL] [EOL] from pypi2nix . configuration import ApplicationConfiguration [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . expression_renderer import render_expression [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . external_dependency_collector import ExternalDependencyCollector [EOL] from pypi2nix . external_dependency_collector import RequirementDependencyRetriever [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . memoize import memoize [EOL] from pypi2nix . metadata_fetcher import MetadataFetcher [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . pip import NixPip [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements_collector import RequirementsCollector [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import PlatformGenerator [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . version import pypi2nix_version [EOL] from pypi2nix . wheel_builder import WheelBuilder [EOL] [EOL] [EOL] class Pypi2nix : [EOL] def __init__ ( self , configuration ) : [EOL] self . configuration = configuration [EOL] [EOL] def run ( self ) : [EOL] requirements = self . requirements_collector ( ) . requirements ( ) [EOL] self . logger ( ) . info ( [string] . format ( pypi2nix_version ) ) [EOL] if not requirements : [EOL] self . logger ( ) . info ( [string] ) [EOL] return [EOL] [EOL] setup_requirements = self . setup_requirements_collector ( ) . requirements ( ) [EOL] requirements_name = os . path . join ( self . configuration . target_directory , self . configuration . output_basename ) [EOL] [EOL] sources = Sources ( ) [EOL] sources . update ( setup_requirements . sources ( ) ) [EOL] sources . update ( requirements . sources ( ) ) [EOL] sources . update ( self . setup_requirements_collector ( ) . sources ( ) ) [EOL] sources . update ( self . requirements_collector ( ) . sources ( ) ) [EOL] [EOL] self . logger ( ) . info ( [string] ) [EOL] [EOL] pip = NixPip ( nix = self . nix ( ) , project_directory = self . configuration . project_directory , extra_env = self . configuration . extra_environment , extra_build_inputs = self . _extra_build_inputs ( ) , wheels_cache = self . configuration . wheels_caches , target_platform = self . target_platform ( ) , logger = self . logger ( ) , requirement_parser = self . requirement_parser ( ) , ) [EOL] wheel_builder = WheelBuilder ( pip = pip , download_directory = self . configuration . project_directory / [string] , lib_directory = self . configuration . project_directory / [string] , extracted_wheel_directory = self . configuration . project_directory / [string] , wheel_directory = self . configuration . project_directory / [string] , logger = self . logger ( ) , requirement_parser = self . requirement_parser ( ) , target_platform = self . target_platform ( ) , base_dependency_graph = self . base_dependency_graph ( ) , ) [EOL] wheels = wheel_builder . build ( requirements = requirements , setup_requirements = setup_requirements ) [EOL] requirements_frozen = wheel_builder . get_frozen_requirements ( ) [EOL] source_distributions = wheel_builder . source_distributions [EOL] [EOL] self . logger ( ) . info ( [string] ) [EOL] [EOL] metadata_fetcher = MetadataFetcher ( sources = sources , logger = self . logger ( ) , requirement_parser = self . requirement_parser ( ) , pypi = Pypi ( logger = self . logger ( ) ) , ) [EOL] [EOL] packages_metadata = metadata_fetcher . main ( wheel_paths = wheels , target_platform = self . target_platform ( ) , source_distributions = source_distributions , ) [EOL] self . logger ( ) . info ( [string] ) [EOL] [EOL] render_expression ( packages_metadata = packages_metadata , sources = sources , requirements_name = requirements_name , requirements_frozen = requirements_frozen , extra_build_inputs = ( self . configuration . extra_build_inputs [EOL] if self . configuration . emit_extra_build_inputs [EOL] else [ ] ) , enable_tests = self . configuration . enable_tests , python_version = self . configuration . python_version , target_directory = self . configuration . target_directory , logger = self . logger ( ) , common_overrides = self . configuration . overrides , target_platform = self . target_platform ( ) , ) [EOL] if self . configuration . dependency_graph_output_location : [EOL] dependency_graph = DependencyGraph ( ) [EOL] for wheel in packages_metadata : [EOL] dependency_graph . import_wheel ( wheel , self . requirement_parser ( ) ) [EOL] with open ( str ( self . configuration . dependency_graph_output_location ) , [string] ) as output_file : [EOL] output_file . write ( dependency_graph . serialize ( ) ) [EOL] self . print_user_information ( ) [EOL] [EOL] def print_user_information ( self ) : [EOL] self . logger ( ) . info ( [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) ) [EOL] [EOL] @ memoize def _extra_build_inputs ( self ) : [EOL] retriever = RequirementDependencyRetriever ( ) [EOL] collector = ExternalDependencyCollector ( requirement_dependency_retriever = retriever ) [EOL] for external_input in self . configuration . extra_build_inputs : [EOL] collector . collect_explicit ( external_input ) [EOL] return list ( collector . get_collected ( ) ) [EOL] [EOL] @ memoize def requirements_collector ( self ) : [EOL] requirement_collector = RequirementsCollector ( self . target_platform ( ) , self . requirement_parser ( ) , self . logger ( ) , str ( self . configuration . project_directory ) , self . base_dependency_graph ( ) , ) [EOL] for item in self . configuration . requirements : [EOL] requirement_collector . add_line ( item ) [EOL] for requirement_file_path in self . configuration . requirement_files : [EOL] requirement_collector . add_file ( requirement_file_path ) [EOL] return requirement_collector [EOL] [EOL] @ memoize def setup_requirements_collector ( self ) : [EOL] setup_requirement_collector = RequirementsCollector ( self . target_platform ( ) , self . requirement_parser ( ) , self . logger ( ) , str ( self . configuration . project_directory ) , DependencyGraph ( ) , ) [EOL] for build_input in self . configuration . setup_requirements : [EOL] setup_requirement_collector . add_line ( build_input ) [EOL] return setup_requirement_collector [EOL] [EOL] @ memoize def requirement_parser ( self ) : [EOL] return RequirementParser ( self . logger ( ) ) [EOL] [EOL] @ memoize def target_platform ( self ) : [EOL] platform_generator = PlatformGenerator ( nix = self . nix ( ) , logger = self . logger ( ) ) [EOL] target_platform = platform_generator . from_python_version ( self . configuration . python_version ) [EOL] return target_platform [EOL] [EOL] @ memoize def nix ( self ) : [EOL] return Nix ( nix_path = self . configuration . nix_path , executable_directory = self . configuration . nix_executable_directory , logger = self . logger ( ) , ) [EOL] [EOL] @ memoize def logger ( self ) : [EOL] logger = StreamLogger ( output = sys . stdout ) [EOL] logger . set_verbosity ( self . configuration . verbosity ) [EOL] return logger [EOL] [EOL] @ memoize def base_dependency_graph ( self ) : [EOL] return self . configuration . dependency_graph_input [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements_collector.RequirementsCollector$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pypi2nix.requirements_collector.RequirementsCollector$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $pypi2nix.nix.Nix$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Type [EOL] import typing [EOL] import builtins [EOL] import types [EOL] import tempfile [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from sys import stderr [EOL] from types import TracebackType [EOL] from typing import Optional [EOL] from typing import Type [EOL] [EOL] [EOL] class ProjectDirectory ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def __enter__ ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def __exit__ ( self , exc_type , exc_value , traceback , ) : [EOL] pass [EOL] [EOL] [EOL] class TemporaryProjectDirectory ( ProjectDirectory ) : [EOL] def __init__ ( self ) : [EOL] self . temporary_directory = tempfile . TemporaryDirectory ( ) [EOL] [EOL] def __enter__ ( self ) : [EOL] return self . temporary_directory . __enter__ ( ) [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback , ) : [EOL] return self . temporary_directory . __exit__ ( exc_type , exc_value , traceback ) [EOL] [EOL] [EOL] class PersistentProjectDirectory ( ProjectDirectory ) : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] [EOL] def __enter__ ( self ) : [EOL] print ( [string] , file = stderr ) [EOL] print ( [string] , file = stderr ) [EOL] return self . path [EOL] [EOL] def __exit__ ( self , exc_type , exc_value , traceback , ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Type]$ 0 $typing.Optional[builtins.Exception]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Type]$ 0 $typing.Optional[builtins.Exception]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Type]$ 0 $typing.Optional[builtins.Exception]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Optional[typing.Type]$ 0 $typing.Optional[builtins.Exception]$ 0 $typing.Optional[types.TracebackType]$ 0 0 0 0 0 0
from typing import Optional , Dict [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os . path [EOL] import tempfile [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from typing import Dict [EOL] from typing import Optional [EOL] from urllib . request import urlopen [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . memoize import memoize [EOL] from pypi2nix . utils import cmd [EOL] from pypi2nix . utils import prefetch_git [EOL] from pypi2nix . utils import prefetch_url [EOL] [EOL] [EOL] class NetworkFile ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def nix_expression ( self ) : [EOL] pass [EOL] [EOL] @ abstractmethod def fetch ( self ) : [EOL] pass [EOL] [EOL] [EOL] class UrlTextFile ( NetworkFile ) : [EOL] def __init__ ( self , url , logger , sha256 = None , name = None , ) : [EOL] self . url = url [EOL] self . _sha256 = sha256 [EOL] self . _logger = logger [EOL] self . _name = name [EOL] [EOL] def nix_expression ( self ) : [EOL] fetchurl_arguments = f' [string] { self . url } [string] ' [EOL] fetchurl_arguments += f' [string] { self . sha256 } [string] ' [EOL] if self . _name : [EOL] fetchurl_arguments += f' [string] { self . _name } [string] ' [EOL] return f" [string] { fetchurl_arguments } [string] " [EOL] [EOL] @ property @ memoize def sha256 ( self ) : [EOL] if self . _sha256 : [EOL] return self . _sha256 [EOL] else : [EOL] return prefetch_url ( self . url , self . _logger , name = self . _name ) [EOL] [EOL] def fetch ( self ) : [EOL] with urlopen ( self . url ) as content : [EOL] return content . read ( ) . decode ( [string] ) [comment] [EOL] [EOL] [EOL] class GitTextFile ( NetworkFile ) : [EOL] def __init__ ( self , repository_url , revision_name , path , logger ) : [EOL] self . repository_url = repository_url [EOL] self . _revision_name = revision_name [EOL] self . path = path [EOL] self . _logger = logger [EOL] [EOL] def nix_expression ( self ) : [EOL] fetchgit_arguments = f' [string] { self . repository_url } [string] ' [EOL] fetchgit_arguments += f' [string] { self . sha256 } [string] ' [EOL] fetchgit_arguments += f' [string] { self . revision } [string] ' [EOL] fetchgit_expression = f" [string] { fetchgit_arguments } [string] " [EOL] return f' [string] { fetchgit_expression } [string] { self . path } [string] ' [EOL] [EOL] @ property def revision ( self ) : [EOL] return self . _prefetch_data [ [string] ] [EOL] [EOL] @ property def sha256 ( self ) : [EOL] return self . _prefetch_data [ [string] ] [EOL] [EOL] @ property @ memoize def _prefetch_data ( self ) : [EOL] return prefetch_git ( self . repository_url , self . _revision_name ) [EOL] [EOL] @ memoize def fetch ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as target_directory : [EOL] cmd ( [ [string] , [string] , self . repository_url , target_directory ] , logger = self . _logger , ) [EOL] cmd ( [ [string] , [string] , self . _revision_name ] , logger = self . _logger , cwd = target_directory , ) [EOL] with open ( os . path . join ( target_directory , self . path ) ) as f : [EOL] return f . read ( ) [EOL] [EOL] [EOL] class DiskTextFile ( NetworkFile ) : [EOL] def __init__ ( self , path ) : [EOL] self . _path = path [EOL] [EOL] def nix_expression ( self ) : [EOL] return self . _path [EOL] [EOL] def fetch ( self ) : [EOL] with open ( self . _path ) as f : [EOL] return f . read ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pypi2nix.logger.Logger$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] def escape_string ( string ) : [EOL] return string . replace ( [string] , [string] ) [EOL]	0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Iterable , Any , List , Dict [EOL] import jinja2 [EOL] import builtins [EOL] import pypi2nix [EOL] import typing [EOL] import os [EOL] import shlex [EOL] import sys [EOL] from typing import Dict [EOL] from typing import Iterable [EOL] [EOL] import jinja2 [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . nix_language import escape_string [EOL] from pypi2nix . overrides import Overrides [EOL] from pypi2nix . python_version import PythonVersion [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . version import pypi2nix_version [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def render_expression ( packages_metadata , sources , requirements_name , requirements_frozen , extra_build_inputs , enable_tests , python_version , target_directory , logger , target_platform , common_overrides = [ ] , ) : [EOL] [docstring] [EOL] [EOL] default_file = os . path . join ( target_directory , f"{ requirements_name } [string] " ) [EOL] overrides_file = os . path . join ( target_directory , f"{ requirements_name } [string] " ) [EOL] frozen_file = os . path . join ( target_directory , f"{ requirements_name } [string] " ) [EOL] [EOL] metadata_by_name = { x . name : x for x in packages_metadata } [EOL] [EOL] generated_packages_metadata = [ ] [EOL] for item in sorted ( packages_metadata , key = lambda x : x . name ) : [EOL] if item . build_dependencies : [EOL] buildInputs = [string] . join ( sorted ( [ [string] . format ( dependency . name ( ) ) for dependency in item . build_dependencies ( target_platform ) ] ) ) [EOL] buildInputs = [string] + buildInputs + [string] [EOL] else : [EOL] buildInputs = [string] [EOL] propagatedBuildInputs = [string] [EOL] dependencies = item . dependencies ( extras = [ ] ) [EOL] if dependencies : [EOL] deps = [ x . name ( ) for x in dependencies if x . name ( ) in metadata_by_name . keys ( ) ] [EOL] if deps : [EOL] propagatedBuildInputs = [string] % ( [string] . join ( sorted ( [ [string] % ( metadata_by_name [ x ] . name ) for x in deps if x != item . name ] ) ) ) [EOL] source = sources [ item . name ] [EOL] fetch_expression = source . nix_expression ( ) [EOL] package_format = item . package_format [EOL] generated_packages_metadata . append ( dict ( name = item . name , version = item . version , fetch_expression = fetch_expression , buildInputs = buildInputs , propagatedBuildInputs = propagatedBuildInputs , homepage = item . homepage , license = item . license , description = escape_string ( item . description ) , package_format = package_format , ) ) [EOL] [EOL] templates = jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( HERE + [string] ) ) [EOL] [EOL] generated_template = templates . get_template ( [string] ) [EOL] generated = [string] . join ( generated_template . render ( ** x ) for x in generated_packages_metadata ) [EOL] [EOL] overrides = templates . get_template ( [string] ) . render ( ) [EOL] [EOL] common_overrides_expressions = [ [string] + override . nix_expression ( logger ) + [string] for override in common_overrides ] [EOL] [EOL] default_template = templates . get_template ( [string] ) [EOL] overrides_file_nix_path = os . path . join ( [string] , os . path . split ( overrides_file ) [ [number] ] ) [EOL] default = default_template . render ( version = pypi2nix_version , command_arguments = [string] . join ( map ( shlex . quote , sys . argv [ [number] : ] ) ) , python_version = python_version . derivation_name ( ) , extra_build_inputs = ( extra_build_inputs [EOL] and [string] % ( [string] . join ( extra_build_inputs ) ) or [string] ) , overrides_file = overrides_file_nix_path , enable_tests = str ( enable_tests ) . lower ( ) , generated_package_nix = generated , common_overrides = [string] . join ( common_overrides_expressions ) , python_major_version = python_version . major_version ( ) , ) [EOL] [EOL] if not os . path . exists ( overrides_file ) : [EOL] with open ( overrides_file , [string] ) as f : [EOL] f . write ( overrides . strip ( ) ) [EOL] logger . info ( [string] % overrides_file ) [EOL] [EOL] with open ( default_file , [string] ) as f : [EOL] f . write ( default . strip ( ) ) [EOL] [EOL] with open ( frozen_file , [string] ) as f : [EOL] f . write ( requirements_frozen ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , Union , Any , List , Dict , Optional , Type [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import subprocess [EOL] import json [EOL] import os [EOL] import shlex [EOL] import subprocess [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] from typing import Tuple [EOL] from typing import Union [EOL] [EOL] import click [EOL] from nix_prefetch_github import nix_prefetch_github [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . path import Path [EOL] [EOL] NixOption = Union [ str , List [ str ] , bool , Path , List [ Path ] ] [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def pretty_option ( option ) : [EOL] if option is None : [EOL] return [string] [EOL] else : [EOL] return [string] . format ( type ( option ) in [ list , tuple ] and [string] . join ( option ) or option ) [EOL] [EOL] [EOL] def cmd ( command , logger , stderr = None , cwd = None , ) : [EOL] if isinstance ( command , str ) : [EOL] command = shlex . split ( command ) [EOL] [EOL] logger . debug ( [string] + [string] . join ( map ( shlex . quote , command ) ) ) [EOL] [EOL] p = subprocess . Popen ( command , stdout = subprocess . PIPE , stderr = stderr , cwd = cwd ) [EOL] [EOL] try : [EOL] out = [ ] [EOL] while True : [EOL] line = p . stdout . readline ( ) . decode ( ) [EOL] if line == [string] and p . poll ( ) is not None : [EOL] break [EOL] if line != [string] : [EOL] logger . debug ( [string] + line . rstrip ( [string] ) ) [EOL] out . append ( line ) [EOL] except Exception : [EOL] p . kill ( ) [EOL] raise [EOL] else : [EOL] p . communicate ( ) [EOL] return p . returncode , [string] . join ( out ) [EOL] [EOL] [EOL] def create_command_options ( options , ) : [EOL] command_options = [ ] [EOL] for name , value in options . items ( ) : [EOL] if isinstance ( value , ( str , Path ) ) : [EOL] command_options . append ( [string] ) [EOL] command_options . append ( name ) [EOL] command_options . append ( str ( value ) ) [EOL] elif isinstance ( value , list ) or isinstance ( value , tuple ) : [EOL] value = [string] % ( [string] . join ( [ [string] % x for x in value ] ) ) [EOL] command_options . append ( [string] ) [EOL] command_options . append ( name ) [EOL] command_options . append ( value ) [EOL] elif isinstance ( value , bool ) : [EOL] command_options . append ( [string] ) [EOL] command_options . append ( name ) [EOL] command_options . append ( [string] if value else [string] ) [EOL] return command_options [EOL] [EOL] [EOL] def args_as_list ( inputs ) : [EOL] return list ( filter ( lambda x : x != [string] , ( [string] . join ( inputs ) ) . split ( [string] ) ) ) [EOL] [EOL] [EOL] def prefetch_git ( url , rev = None ) : [EOL] command = [ [string] , url ] [EOL] [EOL] if rev is not None : [EOL] command += [ [string] , rev ] [EOL] try : [EOL] completed_proc = subprocess . run ( command , universal_newlines = True , stdout = subprocess . PIPE , stderr = subprocess . PIPE , ) [EOL] except FileNotFoundError : [EOL] raise click . ClickException ( [string] [string] [string] ) [EOL] [EOL] returncode = completed_proc . returncode [EOL] [EOL] if returncode != [number] : [EOL] raise click . ClickException ( ( [string] [string] ) . format ( url = url , code = returncode , stdout = completed_proc . stdout , stderr = completed_proc . stderr , ) ) [EOL] repo_data = json . loads ( completed_proc . stdout ) [EOL] return repo_data [comment] [EOL] [EOL] [EOL] def prefetch_hg ( url , logger , rev = None ) : [EOL] command = [ [string] , url ] + ( [ rev ] if rev else [ ] ) [EOL] return_code , output = cmd ( command , logger , stderr = subprocess . STDOUT ) [EOL] if return_code != [number] : [EOL] raise click . ClickException ( [string] . join ( [ [string] [string] ] ) . format ( url = url , code = return_code , output = output ) ) [EOL] HASH_PREFIX = [string] [EOL] REV_PREFIX = [string] [EOL] hash_value = None [EOL] revision = None [EOL] for output_line in output . splitlines ( ) : [EOL] output_line = output_line . strip ( ) [EOL] if output_line . startswith ( HASH_PREFIX ) : [EOL] hash_value = output_line [ len ( HASH_PREFIX ) : ] . strip ( ) [EOL] elif output_line . startswith ( REV_PREFIX ) : [EOL] revision = output_line [ len ( REV_PREFIX ) : ] . strip ( ) [EOL] [EOL] if hash_value is None : [EOL] raise click . ClickException ( [string] . format ( output = output ) ) [EOL] if revision is None : [EOL] raise click . ClickException ( [string] . format ( output = output ) ) [EOL] return { [string] : hash_value , [string] : revision } [EOL] [EOL] [EOL] def prefetch_github ( owner , repo , rev = None ) : [EOL] return nix_prefetch_github ( owner , repo , rev = rev ) [EOL] [EOL] [EOL] def escape_double_quotes ( text ) : [EOL] return text . replace ( [string] , [string] ) [EOL] [EOL] [EOL] def prefetch_url ( url , logger , name = None ) : [EOL] command = [ [string] , url ] [EOL] if name is not None : [EOL] command += [ [string] , name ] [EOL] returncode , output = cmd ( command , logger , stderr = subprocess . DEVNULL ) [EOL] if not output : [EOL] raise ValueError ( f" [string] { url }" ) [EOL] return output . rstrip ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Generator , Match , List , Optional , Set , Union [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import packaging [EOL] import json [EOL] import re [EOL] from functools import lru_cache [EOL] from http . client import HTTPException [EOL] from typing import Optional [EOL] from typing import Union [EOL] from urllib . request import urlopen [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from packaging . version import LegacyVersion [EOL] from packaging . version import Version [EOL] from packaging . version import parse as parse_version [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . pypi_package import PypiPackage [EOL] from pypi2nix . pypi_release import PypiRelease [EOL] from pypi2nix . pypi_release import ReleaseType [EOL] from pypi2nix . pypi_release import get_release_type_by_packagetype [EOL] [EOL] [EOL] @ attrs ( frozen = True ) class Pypi : [EOL] _logger = attrib ( ) [EOL] _index = attrib ( default = [string] ) [EOL] [EOL] @ lru_cache ( maxsize = None ) def get_package ( self , name ) : [EOL] def get_release_type ( package_type ) : [EOL] release_type = get_release_type_by_packagetype ( package_type ) [EOL] if release_type is None : [EOL] self . _logger . warning ( f" [string] { package_type } [string] { name } [string] " ) [EOL] return ReleaseType . UNKNOWN [EOL] else : [EOL] return release_type [EOL] [EOL] url = f"{ self . _index } [string] { name } [string] " [EOL] try : [EOL] with urlopen ( url ) as response_buffer : [EOL] metadata = json . loads ( response_buffer . read ( ) . decode ( [string] ) ) [EOL] except HTTPException : [EOL] raise PypiFailed ( f" [string] { url } [string] { name } [string] " ) [EOL] releases = { PypiRelease ( url = data [ [string] ] , sha256_digest = data [ [string] ] [ [string] ] , version = version , type = get_release_type ( data [ [string] ] ) , filename = data [ [string] ] , ) for version , release_list in metadata [ [string] ] . items ( ) for data in release_list } [EOL] [EOL] return PypiPackage ( name = metadata [ [string] ] [ [string] ] , releases = releases , version = metadata [ [string] ] [ [string] ] , ) [EOL] [EOL] def get_source_release ( self , name , version ) : [EOL] def version_tag_from_filename ( filename ) : [EOL] extension = [string] . join ( map ( re . escape , [ [string] , [string] , [string] , [string] , [string] ] ) ) [EOL] regular_expression = [string] . format ( name = re . escape ( name ) , extension = extension ) [EOL] result = re . match ( regular_expression , filename ) [EOL] if result : [EOL] return parse_version ( result . group ( [string] ) ) [EOL] else : [EOL] message = f" [string] { filename } [string] " [EOL] self . _logger . error ( message ) [EOL] raise PypiFailed ( message ) [EOL] [EOL] package = self . get_package ( name ) [EOL] source_releases = [ release for release in package . releases if release . type == ReleaseType . SOURCE ] [EOL] releases_for_version = ( release for release in source_releases if parse_version ( release . version ) == parse_version ( version ) ) [EOL] [EOL] for release in releases_for_version : [EOL] return release [EOL] else : [EOL] releases_for_version_by_filename = ( release for release in source_releases if version_tag_from_filename ( release . filename ) == parse_version ( version ) ) [EOL] for release in releases_for_version_by_filename : [EOL] return release [EOL] else : [EOL] return None [EOL] [EOL] [EOL] class PypiFailed ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.pypi_package.PypiPackage$ 0 0 0 $builtins.str$ 0 0 0 0 $pypi2nix.pypi_release.ReleaseType$ 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 $typing.Set[typing.Any]$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[pypi2nix.pypi_release.PypiRelease]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Union[packaging.version.Version,packaging.version.LegacyVersion]$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 $typing.Optional[typing.Match[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Generator[typing.Any,None,None]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set , Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os . path [EOL] [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . requirements import PathRequirement [EOL] from pypi2nix . requirements_file import RequirementsFile [EOL] from pypi2nix . sources import Sources [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class RequirementsCollector : [EOL] def __init__ ( self , platform , requirement_parser , logger , project_directory , base_dependency_graph , ) : [EOL] self . platform = platform [EOL] self . requirement_set = RequirementSet ( platform ) [EOL] self . requirement_parser = requirement_parser [EOL] self . logger = logger [EOL] self . _project_directory = project_directory [EOL] self . _sources = Sources ( ) [EOL] self . _base_dependency_graph = base_dependency_graph [EOL] [EOL] def requirements ( self ) : [EOL] return self . requirement_set [EOL] [EOL] def add_line ( self , line ) : [EOL] original_dependency = self . requirement_parser . parse ( line ) [EOL] transitive_requirements = self . _base_dependency_graph . get_all_build_dependency_names ( original_dependency ) [EOL] self . _add_line_without_dependency_check ( line ) [EOL] for requirement in transitive_requirements : [EOL] self . _add_line_without_dependency_check ( requirement ) [EOL] [EOL] def add_file ( self , file_path ) : [EOL] requirements_file = RequirementsFile ( file_path , self . _project_directory , self . requirement_parser , self . logger ) [EOL] requirements_file . process ( ) [EOL] self . _sources . update ( requirements_file . sources ( ) ) [EOL] added_requirements = RequirementSet . from_file ( requirements_file , self . platform , self . requirement_parser , self . logger ) [EOL] transitive_requirements = set ( ) [EOL] for requirement in added_requirements : [EOL] transitive_requirements . update ( self . _base_dependency_graph . get_all_build_dependency_names ( requirement ) ) [EOL] for line in transitive_requirements : [EOL] self . _add_line_without_dependency_check ( line ) [EOL] self . requirement_set += added_requirements [EOL] [EOL] def sources ( self ) : [EOL] sources = Sources ( ) [EOL] sources . update ( self . requirement_set . sources ( ) ) [EOL] sources . update ( self . _sources ) [EOL] return sources [EOL] [EOL] def _add_line_without_dependency_check ( self , line ) : [EOL] requirement = self . requirement_parser . parse ( line ) [EOL] if isinstance ( requirement , PathRequirement ) : [EOL] requirement = requirement . change_path ( lambda path : self . _handle_requirements_path ( name = requirement . name ( ) , path = path ) ) [EOL] self . requirement_set . add ( requirement ) [EOL] [EOL] def _handle_requirements_path ( self , name , path ) : [EOL] self . _sources . add ( name , PathSource ( path ) ) [EOL] return os . path . abspath ( path ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.sources.Sources$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0
from typing import Iterator [EOL] import typing [EOL] import builtins [EOL] import tarfile [EOL] import tempfile [EOL] import zipfile [EOL] from contextlib import contextmanager [EOL] from typing import Iterator [EOL] [EOL] [EOL] class UnpackingFailed ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Archive : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] [EOL] @ contextmanager def extracted_files ( self ) : [EOL] with tempfile . TemporaryDirectory ( ) as directory : [EOL] self . unpack_archive ( directory ) [EOL] yield directory [EOL] [EOL] def unpack_archive ( self , target_directory ) : [EOL] if self . path . endswith ( [string] ) : [EOL] with tarfile . open ( self . path , [string] ) as tar : [EOL] tar . extractall ( path = target_directory ) [EOL] elif self . path . endswith ( [string] ) or self . path . endswith ( [string] ) : [EOL] with zipfile . ZipFile ( self . path ) as archive : [EOL] archive . extractall ( path = target_directory ) [EOL] elif self . path . endswith ( [string] ) : [EOL] with tarfile . open ( self . path , [string] ) as tar : [EOL] tar . extractall ( path = target_directory ) [EOL] else : [EOL] raise UnpackingFailed ( [string] . format ( self . path ) ) [EOL] [EOL] def __str__ ( self ) : [EOL] return f" [string] { self . path } [string] " [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict [EOL] import urllib [EOL] import pypi2nix [EOL] import src [EOL] import typing [EOL] import builtins [EOL] import urllib [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from typing import Dict [EOL] from typing import Optional [EOL] from typing import no_type_check [EOL] from urllib . parse import urldefrag [EOL] from urllib . parse import urlparse [EOL] [EOL] import click [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . network_file import DiskTextFile [EOL] from pypi2nix . network_file import GitTextFile [EOL] from pypi2nix . network_file import NetworkFile [EOL] from pypi2nix . network_file import UrlTextFile [EOL] [EOL] from . utils import prefetch_github [EOL] [EOL] [EOL] class UnsupportedUrlError ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] class Overrides ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def nix_expression ( self , logger ) : [EOL] pass [EOL] [EOL] [EOL] class OverridesNetworkFile ( Overrides ) : [EOL] def __init__ ( self , network_file ) : [EOL] self . _network_file = network_file [EOL] [EOL] def nix_expression ( self , logger ) : [EOL] return f" [string] { self . _network_file . nix_expression ( ) } [string] " [EOL] [EOL] [EOL] class OverridesGithub ( Overrides ) : [EOL] def __init__ ( self , owner , repo , path , rev = None ) : [EOL] self . owner = owner [EOL] self . repo = repo [EOL] self . path = path [EOL] self . rev = rev [EOL] [EOL] def nix_expression ( self , logger ) : [comment] [EOL] prefetch_data = prefetch_github ( self . owner , self . repo , self . rev ) [EOL] template = [string] . join ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] ) [EOL] return template . format ( owner = self . owner , repo = self . repo , rev = prefetch_data [ [string] ] , sha256 = prefetch_data [ [string] ] , path = self . path , ) [EOL] [EOL] [EOL] class NetworkFileParameter ( click . ParamType ) : [EOL] name = [string] [EOL] [EOL] @ no_type_check def convert ( self , value , param , ctx ) : [EOL] try : [EOL] return self . _url_to_network_file ( value ) [EOL] except UnsupportedUrlError as e : [EOL] self . fail ( str ( e ) , param , ctx ) [EOL] [EOL] def _url_to_network_file ( self , url_string ) : [EOL] url = urlparse ( url_string ) [EOL] if url . scheme == [string] : [EOL] return DiskTextFile ( url . path ) [EOL] elif url . scheme == [string] : [EOL] return DiskTextFile ( url . path ) [EOL] elif url . scheme == [string] or url . scheme == [string] : [EOL] return UrlTextFile ( url . geturl ( ) , StreamLogger . stdout_logger ( ) ) [EOL] elif url . scheme . startswith ( [string] ) : [EOL] return self . _handle_git_override_url ( url , url_string ) [EOL] else : [EOL] raise UnsupportedUrlError ( [string] % url_string ) [EOL] [EOL] def _handle_git_override_url ( self , url , url_string ) : [EOL] if not url . fragment : [EOL] raise UnsupportedUrlError ( ( [string] [string] ) . format ( url = url_string ) ) [EOL] fragments = dict ( ) [EOL] for fragment_item in url . fragment . split ( [string] ) : [EOL] try : [EOL] fragment_name , fragment_value = fragment_item . split ( ) [EOL] except ValueError : [EOL] raise UnsupportedUrlError ( f" [string] { fragment_item } [string] " f" [string] { url_string } [string] " ) [EOL] else : [EOL] fragments [ fragment_name ] = fragment_value [EOL] return GitTextFile ( repository_url = urldefrag ( url . geturl ( ) [ [number] : ] ) [ [number] ] , path = fragments [ [string] ] , revision_name = fragments . get ( [string] , [string] ) , logger = StreamLogger . stdout_logger ( ) , ) [EOL] [EOL] [EOL] FILE_URL = NetworkFileParameter ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.network_file.NetworkFile$ 0 0 0 0 0 0 0 $pypi2nix.network_file.NetworkFile$ 0 0 0 $builtins.str$ 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.network_file.NetworkFile$ 0 0 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 $builtins.str$ 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pypi2nix.network_file.GitTextFile$ 0 0 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.parse.ParseResult$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.overrides.NetworkFileParameter$ 0 0 0 0 0
from typing import Tuple , Type , Any , List , Union [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import src [EOL] import hashlib [EOL] import os [EOL] import os . path [EOL] import tempfile [EOL] from typing import List [EOL] from typing import Tuple [EOL] from typing import Type [EOL] from typing import Union [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . package_source import PathSource [EOL] from pypi2nix . requirement_parser import ParsingFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements import PathRequirement [EOL] from pypi2nix . sources import Sources [EOL] [EOL] LineHandler = Union [ [string] , [string] , [string] ] [EOL] [EOL] [EOL] class RequirementsFile : [EOL] def __init__ ( self , path , project_dir , requirement_parser , logger , ) : [EOL] self . project_dir = project_dir [EOL] self . original_path = path [EOL] self . requirement_parser = requirement_parser [EOL] self . _logger = logger [EOL] self . _sources = Sources ( ) [EOL] [EOL] @ classmethod def from_lines ( constructor , lines , project_dir , requirement_parser , logger , ) : [EOL] assert not isinstance ( lines , str ) [EOL] temporary_file_descriptor , temporary_file_path = tempfile . mkstemp ( dir = project_dir , text = True ) [EOL] try : [EOL] with open ( temporary_file_descriptor , [string] ) as f : [EOL] for line in lines : [EOL] f . write ( line ) [EOL] f . write ( [string] ) [EOL] requirements_file = constructor ( project_dir = project_dir , path = temporary_file_path , requirement_parser = requirement_parser , logger = logger , ) [EOL] requirements_file . process ( ) [EOL] finally : [EOL] os . remove ( temporary_file_path ) [EOL] return requirements_file [EOL] [EOL] def read ( self ) : [EOL] if os . path . exists ( self . processed_requirements_file_path ( ) ) : [EOL] path = self . processed_requirements_file_path ( ) [EOL] else : [EOL] path = self . original_path [EOL] with open ( path ) as f : [EOL] return f . read ( ) [EOL] [EOL] def process ( self ) : [EOL] new_requirements_file = self . processed_requirements_file_path ( ) [EOL] [EOL] with open ( self . original_path ) as original_file , open ( new_requirements_file , [string] ) as new_file : [EOL] for requirements_line in original_file . readlines ( ) : [EOL] requirements_line = requirements_line . strip ( ) [EOL] if requirements_line : [EOL] processed_requirements_line = self . _process_line ( requirements_line ) [EOL] print ( processed_requirements_line , file = new_file ) [EOL] self . _logger . debug ( f" [string] { new_requirements_file }" ) [EOL] [EOL] def _process_line ( self , requirements_line ) : [EOL] line_handler = ... [EOL] if self . is_include_line ( requirements_line ) : [EOL] line_handler = _RequirementIncludeLineHandler ( line = requirements_line , original_path = self . original_path , project_directory = self . project_dir , requirement_parser = self . requirement_parser , logger = self . _logger , ) [EOL] elif self . is_editable_line ( requirements_line ) : [EOL] line_handler = _EditableLineHandler ( line = requirements_line , original_path = self . original_path , requirement_parser = self . requirement_parser , ) [EOL] else : [EOL] line_handler = _RequirementLineHandler ( line = requirements_line , requirement_parser = self . requirement_parser , original_path = self . original_path , ) [EOL] line , sources = line_handler . process ( ) [EOL] self . _sources . update ( sources ) [EOL] return line [EOL] [EOL] def processed_requirements_file_path ( self ) : [EOL] return [string] % ( self . project_dir , hashlib . md5 ( self . original_path . encode ( ) ) . hexdigest ( ) , ) [EOL] [EOL] def is_include_line ( self , line ) : [EOL] return line . startswith ( [string] ) or line . startswith ( [string] ) [EOL] [EOL] def is_vcs_line ( self , line ) : [EOL] return line . startswith ( [string] ) or line . startswith ( [string] ) [EOL] [EOL] def is_editable_line ( self , line ) : [EOL] return line . startswith ( [string] ) and not self . is_vcs_line ( line ) [EOL] [EOL] def sources ( self ) : [EOL] return self . _sources [EOL] [EOL] [EOL] class _RequirementIncludeLineHandler : [EOL] def __init__ ( self , line , original_path , project_directory , requirement_parser , logger , ) : [EOL] self . _line = line [EOL] self . _original_path = original_path [EOL] self . _project_directory = project_directory [EOL] self . _requirement_parser = requirement_parser [EOL] self . _logger = logger [EOL] [EOL] def process ( self ) : [EOL] [comment] [EOL] original_file_path = self . _line [ [number] : ] . strip ( ) [EOL] if os . path . isabs ( original_file_path ) : [EOL] included_file_path = original_file_path [EOL] else : [EOL] included_file_path = os . path . abspath ( os . path . join ( os . path . dirname ( self . _original_path ) , original_file_path ) ) [EOL] new_requirements_file = RequirementsFile ( included_file_path , self . _project_directory , requirement_parser = self . _requirement_parser , logger = self . _logger , ) [EOL] new_requirements_file . process ( ) [EOL] return ( self . _line [ [number] : [number] ] + new_requirements_file . processed_requirements_file_path ( ) , new_requirements_file . sources ( ) , ) [EOL] [EOL] [EOL] class _EditableLineHandler : [EOL] def __init__ ( self , line , original_path , requirement_parser ) : [EOL] self . _line = line [EOL] self . _original_path = original_path [EOL] self . _requirement_parser = requirement_parser [EOL] [EOL] def process ( self ) : [EOL] self . _strip_editable ( ) [EOL] line_handler = _RequirementLineHandler ( line = self . _line , requirement_parser = self . _requirement_parser , original_path = self . _original_path , ) [EOL] line , sources = line_handler . process ( ) [EOL] return [string] + line , sources [EOL] [EOL] def _strip_editable ( self ) : [EOL] self . _line = self . _line [ [number] : ] . strip ( ) [EOL] [EOL] [EOL] class _RequirementLineHandler : [EOL] def __init__ ( self , line , requirement_parser , original_path ) : [EOL] self . _line = line [EOL] self . _requirement_parser = requirement_parser [EOL] self . _original_path = original_path [EOL] self . _sources = Sources ( ) [EOL] [EOL] def process ( self ) : [EOL] try : [EOL] requirement = self . _requirement_parser . parse ( self . _line ) [EOL] except ParsingFailed : [EOL] return self . _line , self . _sources [EOL] else : [EOL] if isinstance ( requirement , PathRequirement ) : [EOL] requirement = requirement . change_path ( lambda path : self . _update_path ( requirement . name ( ) , path ) ) [EOL] return requirement . to_line ( ) , self . _sources [EOL] [EOL] def _update_path ( self , requirement_name , requirement_path ) : [EOL] if not os . path . isabs ( requirement_path ) : [EOL] requirement_path = os . path . relpath ( os . path . join ( os . path . dirname ( self . _original_path ) , requirement_path ) ) [EOL] self . _sources . add ( requirement_name , PathSource ( path = requirement_path ) ) [EOL] if os . path . isabs ( requirement_path ) : [EOL] return requirement_path [EOL] else : [EOL] absolute_path = os . path . abspath ( requirement_path ) [EOL] return absolute_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"RequirementsFile"$ 0 $"Type[RequirementsFile]"$ 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 $"Type[RequirementsFile]"$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.logger.Logger$ 0 $pypi2nix.logger.Logger$ 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Union[src.pypi2nix.requirements_file._EditableLineHandler,src.pypi2nix.requirements_file._RequirementIncludeLineHandler,src.pypi2nix.requirements_file._RequirementLineHandler]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[src.pypi2nix.requirements_file._EditableLineHandler,src.pypi2nix.requirements_file._RequirementIncludeLineHandler,src.pypi2nix.requirements_file._RequirementLineHandler]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Union[src.pypi2nix.requirements_file._EditableLineHandler,src.pypi2nix.requirements_file._RequirementIncludeLineHandler,src.pypi2nix.requirements_file._RequirementLineHandler]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[src.pypi2nix.requirements_file._EditableLineHandler,src.pypi2nix.requirements_file._RequirementIncludeLineHandler,src.pypi2nix.requirements_file._RequirementLineHandler]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[src.pypi2nix.requirements_file._EditableLineHandler,src.pypi2nix.requirements_file._RequirementIncludeLineHandler,src.pypi2nix.requirements_file._RequirementLineHandler]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $pypi2nix.sources.Sources$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 $typing.Tuple[builtins.str,pypi2nix.sources.Sources]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 0 0 $src.pypi2nix.requirements_file.RequirementsFile$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 $typing.Tuple[builtins.str,pypi2nix.sources.Sources]$ 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file._RequirementLineHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $src.pypi2nix.requirements_file._RequirementLineHandler$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.str,pypi2nix.sources.Sources]$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0
from typing import Optional , Any , List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os [EOL] import os . path [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] import click [EOL] [EOL] from pypi2nix . configuration import ApplicationConfiguration [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import verbosity_from_int [EOL] from pypi2nix . main import Pypi2nix [EOL] from pypi2nix . network_file import NetworkFile [EOL] from pypi2nix . overrides import FILE_URL [EOL] from pypi2nix . overrides import Overrides [EOL] from pypi2nix . overrides import OverridesGithub [EOL] from pypi2nix . overrides import OverridesNetworkFile [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . project_directory import PersistentProjectDirectory [EOL] from pypi2nix . project_directory import ProjectDirectory [EOL] from pypi2nix . project_directory import TemporaryProjectDirectory [EOL] from pypi2nix . python_version import PythonVersion [EOL] from pypi2nix . python_version import available_python_versions [EOL] from pypi2nix . utils import args_as_list [EOL] from pypi2nix . version import pypi2nix_version [EOL] [EOL] [EOL] @ click . command ( [string] ) @ click . option ( [string] , is_flag = True , help = [string] ) @ click . option ( [string] , [string] , count = True ) @ click . option ( [string] , [string] , count = True ) @ click . option ( [string] , [string] , multiple = True , default = None , help = [string] [string] [string] [string] [string] , ) @ click . option ( [string] , required = False , default = None , help = [string] ) @ click . option ( [string] , required = False , default = [string] , help = [string] [string] , ) @ click . option ( [string] , [string] , multiple = True , default = None , help = [string] [string] , ) @ click . option ( [string] , default = True , help = [string] , ) @ click . option ( [string] , [string] , default = [string] , help = [string] [string] [string] , ) @ click . option ( [string] , [string] , is_flag = True , help = [string] ) @ click . option ( [string] , [string] , [string] , required = False , default = [string] , type = click . Choice ( available_python_versions ) , show_default = True , help = [string] , ) @ click . option ( [string] , [string] , required = False , default = [ ] , multiple = True , type = click . Path ( exists = True , file_okay = True , dir_okay = False , resolve_path = True ) , help = [string] , ) @ click . option ( [string] , required = False , default = None , type = click . Path ( file_okay = True , dir_okay = False , resolve_path = True ) , help = [string] , ) @ click . option ( [string] , required = False , default = None , type = FILE_URL , help = [string] , ) @ click . option ( [string] , [string] , multiple = True , required = False , default = [ ] , type = str , help = [string] , ) @ click . option ( [string] , [string] , multiple = True , required = False , default = None , type = str , help = [string] [string] , ) @ click . option ( [string] , [string] , multiple = True , required = False , type = FILE_URL , help = [string] + [string] , ) @ click . option ( [string] , default = True , help = [string] , ) @ click . option ( [string] , [string] , multiple = True , required = False , default = [ ] , type = str , help = [string] , ) @ click . option ( [string] , default = None , type = click . Path ( exists = True , file_okay = False , dir_okay = True , resolve_path = True ) , help = [string] . join ( [ [string] , [string] , [string] , ] ) , ) def main ( version , verbose , quiet , nix_shell , nix_path , basename , extra_build_inputs , emit_extra_build_inputs , extra_env , enable_tests , python_version_argument , requirements , editable , setup_requires , overrides , default_overrides , wheels_cache , build_directory , dependency_graph_output , dependency_graph_input , ) : [EOL] overrides_list = [ ] [EOL] if version : [EOL] click . echo ( pypi2nix_version ) [EOL] exit ( [number] ) [EOL] verbosity = verbosity_from_int ( verbose - quiet + DEFAULT_VERBOSITY ) [EOL] nix_executable_directory = ... [EOL] if nix_shell is None : [EOL] nix_executable_directory = None [EOL] else : [EOL] if not os . path . isfile ( nix_shell ) : [EOL] raise click . exceptions . UsageError ( f" [string] { nix_shell } [string] " ) [EOL] else : [EOL] nix_executable_directory = os . path . dirname ( os . path . abspath ( nix_shell ) ) [EOL] overrides_list += [ OverridesNetworkFile ( network_file ) for network_file in overrides ] [EOL] if default_overrides : [EOL] overrides_list += tuple ( [ OverridesGithub ( owner = [string] , repo = [string] , path = [string] , ) ] ) [EOL] python_version = getattr ( PythonVersion , python_version_argument , None ) [EOL] if python_version is None : [EOL] raise click . exceptions . UsageError ( f" [string] { python_version_argument } [string] " ) [EOL] [EOL] project_directory_context = ( TemporaryProjectDirectory ( ) [EOL] if build_directory is None [EOL] else PersistentProjectDirectory ( path = build_directory ) ) [EOL] if dependency_graph_input : [EOL] dependency_graph = DependencyGraph . deserialize ( dependency_graph_input . fetch ( ) ) [EOL] else : [EOL] dependency_graph = DependencyGraph ( ) [EOL] with project_directory_context as _project_directory : [EOL] configuration = ApplicationConfiguration ( emit_extra_build_inputs = emit_extra_build_inputs , enable_tests = enable_tests , extra_build_inputs = args_as_list ( extra_build_inputs ) , extra_environment = extra_env , nix_executable_directory = nix_executable_directory , nix_path = nix_path , output_basename = basename , overrides = overrides_list , python_version = python_version , requirement_files = requirements , requirements = editable , setup_requirements = setup_requires , verbosity = verbosity , wheels_caches = wheels_cache , project_directory = Path ( _project_directory ) , target_directory = os . getcwd ( ) , dependency_graph_output_location = Path ( dependency_graph_output ) [EOL] if dependency_graph_output [EOL] else None , dependency_graph_input = dependency_graph , ) [EOL] Pypi2nix ( configuration ) . run ( ) [EOL] [EOL] [EOL] DEFAULT_VERBOSITY = [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Dict [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from enum import Enum [EOL] from enum import unique [EOL] from typing import Optional [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] [EOL] @ unique class ReleaseType ( Enum ) : [EOL] UNKNOWN = [number] [EOL] SOURCE = [number] [EOL] WHEEL = [number] [EOL] EGG = [number] [EOL] WIN_INSTALLER = [number] [EOL] RPM = [number] [EOL] MSI = [number] [EOL] [EOL] [EOL] _release_type_mapping = { [string] : ReleaseType . SOURCE , [string] : ReleaseType . WHEEL , [string] : ReleaseType . EGG , [string] : ReleaseType . WIN_INSTALLER , [string] : ReleaseType . RPM , [string] : ReleaseType . MSI , } [EOL] [EOL] [EOL] def get_release_type_by_packagetype ( packagetype ) : [EOL] return _release_type_mapping . get ( packagetype ) [EOL] [EOL] [EOL] @ attrs ( frozen = True ) class PypiRelease : [EOL] url = attrib ( ) [EOL] sha256_digest = attrib ( ) [EOL] version = attrib ( ) [EOL] type = attrib ( ) [EOL] filename = attrib ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $ReleaseType$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0
from typing import Optional , Any , List , Dict [EOL] import typing [EOL] import builtins [EOL] import re [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] from pypi2nix . nix_language import escape_string [EOL] [EOL] all_classifiers = { [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : None , [string] : None , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : None , [string] : None , [string] : [string] , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : [string] , [string] : None , [string] : [string] , [string] : None , } [EOL] [EOL] [EOL] def escape_regex ( text ) : [EOL] return re . escape ( text ) [EOL] [EOL] [EOL] LICENSE_PATTERNS = { [string] : list ( map ( escape_regex , [ [string] , [string] ] ) ) , [string] : list ( map ( escape_regex , [ [string] , [string] ] ) ) , [string] : list ( map ( escape_regex , [ [string] , [string] , [string] , [string] , [string] , [string] , ] , ) ) , [string] : list ( map ( escape_regex , [ [string] , [string] , [string] , [string] ] , ) ) + [ [string] ] , [string] : list ( map ( escape_regex , [ [string] , [string] , [string] , [string] , [string] , [string] , ] , ) ) , [string] : list ( map ( escape_regex , [ [string] , [string] ] , ) ) , [string] : list ( map ( escape_regex , [ [string] ] ) ) , [string] : list ( map ( escape_regex , [ [string] , [string] , [string] , [string] ] , ) ) , [string] : list ( map ( escape_regex , [ [string] ] ) ) , [string] : list ( map ( escape_regex , [ [string] ] ) ) , } [EOL] [EOL] [EOL] def recognized_nix_license_from_classifiers ( classifiers , ) : [EOL] license_classifiers = [ i for i in classifiers if i in all_classifiers ] [EOL] for license_classifier in license_classifiers : [EOL] license_nix = all_classifiers [ license_classifier ] [EOL] if license_nix is not None : [EOL] return license_nix [EOL] return None [EOL] [EOL] [EOL] def first_license_classifier_from_list ( classifiers ) : [EOL] for classifier in classifiers : [EOL] if classifier in all_classifiers : [EOL] escaped_classifier = escape_string ( classifier ) [EOL] return [string] + escaped_classifier + [string] [EOL] return None [EOL] [EOL] [EOL] def license_from_string ( license_string ) : [EOL] for nix_license , license_patterns in LICENSE_PATTERNS . items ( ) : [EOL] for pattern in license_patterns : [EOL] if re . match ( [string] + pattern + [string] , license_string ) : [EOL] return nix_license [EOL] return None [EOL] [EOL] [EOL] def find_license ( classifiers , license_string ) : [EOL] return ( recognized_nix_license_from_classifiers ( classifiers ) or license_from_string ( license_string ) or first_license_classifier_from_list ( classifiers ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , List , Dict [EOL] import typing [EOL] import builtins [EOL] from enum import Enum [EOL] from enum import unique [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] [EOL] @ unique class PythonVersion ( Enum ) : [EOL] python35 = [string] [EOL] python36 = [string] [EOL] python37 = [string] [EOL] python38 = [string] [EOL] python3 = [string] [EOL] [EOL] def nixpkgs_attribute ( self ) : [EOL] return self . value [comment] [EOL] [EOL] def derivation_name ( self ) : [EOL] return self . value [comment] [EOL] [EOL] def major_version ( self ) : [EOL] return self . derivation_name ( ) . replace ( [string] , [string] ) [ [number] ] [EOL] [EOL] [EOL] _PYTHON_VERSIONS = { [string] : PythonVersion . python35 , [string] : PythonVersion . python36 , [string] : PythonVersion . python37 , [string] : PythonVersion . python38 , } [EOL] [EOL] [EOL] def python_version_from_version_string ( version_string ) : [EOL] return _PYTHON_VERSIONS . get ( version_string ) [EOL] [EOL] [EOL] available_python_versions = [ version . name for version in PythonVersion ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,PythonVersion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[PythonVersion]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,PythonVersion]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os . path [EOL] from typing import Dict [EOL] from typing import Optional [EOL] from typing import Union [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . utils import prefetch_git [EOL] from pypi2nix . utils import prefetch_hg [EOL] from pypi2nix . utils import prefetch_url [EOL] [EOL] PackageSource = Union [ [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] class GitSource : [EOL] def __init__ ( self , url , revision = None ) : [EOL] self . url = url [EOL] self . _prefetch_data = None [EOL] self . _revision = revision [EOL] [EOL] def nix_expression ( self ) : [EOL] return [string] . join ( [ [string] , [string] , [string] , [string] , [string] , ] ) % dict ( url = self . url , hash_type = [string] , hash_value = self . hash_value ( ) , rev = self . revision ( ) , ) [EOL] [EOL] def hash_value ( self ) : [EOL] return self . prefetch_data ( ) [ [string] ] [EOL] [EOL] def revision ( self ) : [EOL] return self . prefetch_data ( ) [ [string] ] [EOL] [EOL] def prefetch_data ( self ) : [EOL] if self . _prefetch_data is None : [EOL] self . _prefetch_data = prefetch_git ( self . url , self . _revision ) [EOL] return self . _prefetch_data [EOL] [EOL] [EOL] class HgSource : [EOL] def __init__ ( self , url , logger , revision = None ) : [EOL] self . url = url [EOL] self . _revision = revision [EOL] self . _prefetch_data = None [EOL] self . logger = logger [EOL] [EOL] def nix_expression ( self ) : [EOL] return [string] . join ( [ [string] , [string] , [string] , [string] , [string] , ] ) . format ( url = self . url , hash_value = self . hash_value ( ) , revision = self . revision ( ) ) [EOL] [EOL] def hash_value ( self ) : [EOL] return self . prefetch_data ( ) [ [string] ] [EOL] [EOL] def revision ( self ) : [EOL] return self . prefetch_data ( ) [ [string] ] [EOL] [EOL] def prefetch_data ( self ) : [EOL] if self . _prefetch_data is None : [EOL] self . _prefetch_data = prefetch_hg ( self . url , self . logger , self . _revision ) [EOL] return self . _prefetch_data [EOL] [EOL] [EOL] class UrlSource : [EOL] def __init__ ( self , url , logger , hash_value = None ) : [EOL] self . url = url [EOL] self . _hash_value = hash_value [EOL] self . chunk_size = [number] [EOL] self . logger = logger [EOL] [EOL] def nix_expression ( self ) : [EOL] return [string] . join ( [ [string] , [string] , [string] , [string] , ] ) . format ( url = self . url , hash_value = self . hash_value ( ) ) [EOL] [EOL] def hash_value ( self ) : [EOL] if self . _hash_value is None : [EOL] self . _hash_value = self . calculate_hash_value ( ) [EOL] return self . _hash_value [EOL] [EOL] def calculate_hash_value ( self ) : [EOL] return prefetch_url ( self . url , self . logger ) [EOL] [EOL] [EOL] class PathSource : [EOL] def __init__ ( self , path ) : [EOL] self . path = path [EOL] [EOL] @ property def _normalized_path ( self ) : [EOL] if os . path . isabs ( self . path ) : [EOL] return self . path [EOL] else : [EOL] head , tail = os . path . split ( self . path ) [EOL] if head : [EOL] return self . path [EOL] else : [EOL] return os . path . join ( self . path , [string] ) [EOL] [EOL] def nix_expression ( self ) : [EOL] return self . _normalized_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,builtins.str]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
class UnknownTargetPlatform ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
from typing import Optional , TextIO [EOL] import typing [EOL] import builtins [EOL] import src [EOL] from __future__ import annotations [EOL] [EOL] import sys [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from enum import Enum [EOL] from enum import unique [EOL] from typing import Optional [EOL] from typing import TextIO [EOL] [EOL] [EOL] class LoggerNotConnected ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] @ unique class Verbosity ( Enum ) : [EOL] ERROR = - [number] [EOL] WARNING = [number] [EOL] INFO = [number] [EOL] DEBUG = [number] [EOL] [EOL] [EOL] VERBOSITY_MIN = min ( * map ( lambda v : v . value , Verbosity ) ) [comment] [EOL] VERBOSITY_MAX = max ( * map ( lambda v : v . value , Verbosity ) ) [comment] [EOL] [EOL] [EOL] def verbosity_from_int ( n ) : [EOL] for verbosity_level in Verbosity : [EOL] if verbosity_level . value == n : [EOL] return verbosity_level [EOL] if n < VERBOSITY_MIN : [EOL] return Verbosity . ERROR [EOL] else : [EOL] return Verbosity . DEBUG [EOL] [EOL] [EOL] class Logger ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def error ( self , text ) : [EOL] pass [EOL] [EOL] @ abstractmethod def warning ( self , text ) : [EOL] pass [EOL] [EOL] @ abstractmethod def info ( self , text ) : [EOL] pass [EOL] [EOL] @ abstractmethod def debug ( self , text ) : [EOL] pass [EOL] [EOL] @ abstractmethod def set_verbosity ( self , level ) : [EOL] pass [EOL] [EOL] [EOL] class StreamLogger ( Logger ) : [EOL] def __init__ ( self , output ) : [EOL] self . output = output [EOL] self . verbosity_level = Verbosity . DEBUG [EOL] [EOL] def warning ( self , text ) : [EOL] if self . verbosity_level . value >= Verbosity . WARNING . value : [EOL] for line in text . splitlines ( ) : [EOL] print ( [string] , line , file = self . output ) [EOL] [EOL] def error ( self , text ) : [EOL] for line in text . splitlines ( ) : [EOL] print ( [string] , line , file = self . output ) [EOL] [EOL] def info ( self , text ) : [EOL] if self . verbosity_level . value >= Verbosity . INFO . value : [EOL] for line in text . splitlines ( ) : [EOL] print ( [string] , line , file = self . output ) [EOL] [EOL] def debug ( self , text ) : [EOL] if self . verbosity_level . value >= Verbosity . DEBUG . value : [EOL] for line in text . splitlines ( ) : [EOL] print ( [string] , line , file = self . output ) [EOL] [EOL] def set_verbosity ( self , level ) : [EOL] self . verbosity_level = level [EOL] [EOL] @ classmethod def stdout_logger ( constructor ) : [EOL] return constructor ( sys . stdout ) [EOL] [EOL] [EOL] class ProxyLogger ( Logger ) : [EOL] def __init__ ( self ) : [EOL] self . _target_logger = None [EOL] [EOL] def info ( self , text ) : [EOL] if self . _target_logger is not None : [EOL] self . _target_logger . info ( text ) [EOL] else : [EOL] raise LoggerNotConnected ( [string] ) [EOL] [EOL] def debug ( self , text ) : [EOL] if self . _target_logger is not None : [EOL] self . _target_logger . debug ( text ) [EOL] else : [EOL] raise LoggerNotConnected ( [string] ) [EOL] [EOL] def warning ( self , text ) : [EOL] if self . _target_logger is not None : [EOL] self . _target_logger . warning ( text ) [EOL] else : [EOL] raise LoggerNotConnected ( [string] ) [EOL] [EOL] def error ( self , text ) : [EOL] if self . _target_logger is not None : [EOL] self . _target_logger . error ( text ) [EOL] else : [EOL] raise LoggerNotConnected ( [string] ) [EOL] [EOL] def set_verbosity ( self , level ) : [EOL] if self . _target_logger is not None : [EOL] self . _target_logger . set_verbosity ( level ) [EOL] else : [EOL] raise LoggerNotConnected ( [string] ) [EOL] [EOL] def set_target_logger ( self , target ) : [EOL] self . _target_logger = target [EOL] [EOL] def get_target_logger ( self ) : [EOL] return self . _target_logger [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Verbosity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.TextIO$ 0 0 0 0 0 $typing.TextIO$ 0 $typing.TextIO$ 0 0 0 $Verbosity$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Verbosity$ 0 0 0 0 0 $src.pypi2nix.logger.Verbosity$ 0 $Verbosity$ 0 0 0 0 0 $StreamLogger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.Optional[Logger]$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Verbosity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Verbosity$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $Logger$ 0 0 0 0 0 $typing.Optional[src.pypi2nix.logger.Logger]$ 0 $Logger$ 0 0 0 $typing.Optional[Logger]$ 0 0 0 0 0 0 0 0 0 0
from typing import TypeVar , DefaultDict , Generator , List , Dict , Set , Callable [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] from collections import defaultdict [EOL] from copy import copy [EOL] from typing import Callable [EOL] from typing import DefaultDict [EOL] from typing import Dict [EOL] from typing import Generator [EOL] from typing import List [EOL] from typing import Set [EOL] from typing import TypeVar [EOL] [EOL] import yaml [EOL] [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirements import Requirement [EOL] from pypi2nix . wheel import Wheel [EOL] [EOL] K = TypeVar ( [string] ) [EOL] V = TypeVar ( [string] ) [EOL] [EOL] [EOL] class DependencyGraph : [EOL] def __init__ ( self ) : [EOL] self . _runtime_dependencies = defaultdict ( lambda : set ( ) ) [EOL] self . _buildtime_dependencies = defaultdict ( lambda : set ( ) ) [EOL] self . _external_dependencies = defaultdict ( lambda : set ( ) ) [EOL] [EOL] def set_runtime_dependency ( self , dependent , dependency ) : [EOL] self . _raise_on_cyclic_dependency ( dependent , dependency ) [EOL] self . _runtime_dependencies [ dependent . name ( ) ] . add ( dependency . name ( ) ) [EOL] [EOL] def set_buildtime_dependency ( self , dependent , dependency ) : [EOL] self . _raise_on_cyclic_dependency ( dependent , dependency ) [EOL] self . _buildtime_dependencies [ dependent . name ( ) ] . add ( dependency . name ( ) ) [EOL] [EOL] def set_external_dependency ( self , dependent , dependency ) : [EOL] self . _external_dependencies [ dependent . name ( ) ] . add ( dependency ) [EOL] [EOL] def is_runtime_dependency ( self , dependent , dependency ) : [EOL] return self . _is_runtime_child ( dependent . name ( ) , dependency . name ( ) ) [EOL] [EOL] def is_buildtime_dependency ( self , dependent , dependency ) : [EOL] return self . _is_python_child ( dependent . name ( ) , dependency . name ( ) ) [EOL] [EOL] def get_all_build_dependency_names ( self , package ) : [EOL] return set ( self . _get_python_children ( package . name ( ) ) ) [EOL] [EOL] def get_all_runtime_dependency_names ( self , package ) : [EOL] return set ( self . _get_runtime_children ( package . name ( ) ) ) [EOL] [EOL] def get_all_external_dependencies ( self , package ) : [EOL] found_dependencies = set ( ) [EOL] for package_name in self . _get_python_children ( package . name ( ) ) : [EOL] found_dependencies . update ( self . _external_dependencies [ package_name ] ) [EOL] return found_dependencies [EOL] [EOL] def import_wheel ( self , wheel , requirement_parser ) : [EOL] dependent = requirement_parser . parse ( wheel . name ) [EOL] for runtime_dependency in wheel . runtime_dependencies ( wheel . target_platform ( ) ) : [EOL] [EOL] self . set_runtime_dependency ( dependent , runtime_dependency ) [EOL] for build_dependency in wheel . build_dependencies ( wheel . target_platform ( ) ) : [EOL] self . set_buildtime_dependency ( dependent , build_dependency ) [EOL] [EOL] def serialize ( self ) : [EOL] document = defaultdict ( lambda : dict ( ) ) [EOL] for key , external_dependencies in self . _external_dependencies . items ( ) : [EOL] document [ key ] [ [string] ] = [ dep . attribute_name ( ) for dep in external_dependencies ] [EOL] for key , runtime_dependencies in self . _runtime_dependencies . items ( ) : [EOL] document [ key ] [ [string] ] = list ( runtime_dependencies ) [EOL] for key , buildtime_dependencies in self . _buildtime_dependencies . items ( ) : [EOL] document [ key ] [ [string] ] = list ( buildtime_dependencies ) [EOL] return yaml . dump ( dict ( document ) ) [comment] [EOL] [EOL] @ classmethod def deserialize ( _class , data ) : [EOL] document = ... [EOL] document = yaml . load ( data , Loader = yaml . Loader ) [EOL] graph = DependencyGraph ( ) [EOL] for package , dependencies in document . items ( ) : [EOL] external_dependencies = dependencies . get ( [string] ) [EOL] if external_dependencies is not None : [EOL] graph . _external_dependencies [ package ] = { ExternalDependency ( name ) for name in external_dependencies } [EOL] runtime_dependencies = dependencies . get ( [string] ) [EOL] if runtime_dependencies is not None : [EOL] graph . _runtime_dependencies [ package ] = set ( runtime_dependencies ) [EOL] buildtime_dependencies = dependencies . get ( [string] ) [EOL] if buildtime_dependencies is not None : [EOL] graph . _buildtime_dependencies [ package ] = set ( buildtime_dependencies ) [EOL] return graph [EOL] [EOL] def _raise_on_cyclic_dependency ( self , dependent , dependency ) : [EOL] if self . is_buildtime_dependency ( dependency , dependent ) : [EOL] raise CyclicDependencyOccured ( f" [string] { dependent } [string] { dependency } [string] " f" [string] { dependent } [string] { dependency }" ) [EOL] [EOL] def _is_python_child ( self , dependent , dependency ) : [EOL] for child in self . _get_python_children ( dependent ) : [EOL] if child == dependency : [EOL] return True [EOL] return False [EOL] [EOL] def _is_runtime_child ( self , dependent , dependency ) : [EOL] for child in self . _get_runtime_children ( dependent ) : [EOL] if child == dependency : [EOL] return True [EOL] return False [EOL] [EOL] def _get_python_children ( self , package_name ) : [EOL] alread_seen = set ( ) [EOL] pending = { package_name } [EOL] while pending : [EOL] package = pending . pop ( ) [EOL] yield package [EOL] alread_seen . add ( package ) [EOL] for dependency in ( self . _runtime_dependencies [ package ] | self . _buildtime_dependencies [ package ] ) : [EOL] if dependency in alread_seen : [EOL] continue [EOL] else : [EOL] pending . add ( dependency ) [EOL] [EOL] def _get_runtime_children ( self , package_name ) : [EOL] alread_seen = set ( ) [EOL] pending = { package_name } [EOL] while pending : [EOL] package = pending . pop ( ) [EOL] yield package [EOL] alread_seen . add ( package ) [EOL] for dependency in self . _runtime_dependencies [ package ] : [EOL] if dependency in alread_seen : [EOL] continue [EOL] else : [EOL] pending . add ( dependency ) [EOL] [EOL] def __add__ ( self , other ) : [EOL] new_graph = DependencyGraph ( ) [EOL] new_graph . _runtime_dependencies = _merge_defaultdicts ( self . _runtime_dependencies , other . _runtime_dependencies ) [EOL] new_graph . _buildtime_dependencies = _merge_defaultdicts ( self . _buildtime_dependencies , other . _buildtime_dependencies ) [EOL] new_graph . _external_dependencies = _merge_defaultdicts ( self . _external_dependencies , other . _external_dependencies ) [EOL] return new_graph [EOL] [EOL] def __copy__ ( self ) : [EOL] new_graph = DependencyGraph ( ) [EOL] new_graph . _buildtime_dependencies = copy ( self . _buildtime_dependencies ) [EOL] new_graph . _runtime_dependencies = copy ( self . _runtime_dependencies ) [EOL] new_graph . _external_dependencies = copy ( self . _external_dependencies ) [EOL] return new_graph [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , DependencyGraph ) : [EOL] return ( self . _runtime_dependencies == other . _runtime_dependencies [EOL] and self . _buildtime_dependencies == other . _buildtime_dependencies [EOL] and self . _external_dependencies == other . _external_dependencies ) [EOL] else : [EOL] return False [EOL] [EOL] def __repr__ ( self ) : [EOL] return ( [string] f" [string] { repr ( self . _runtime_dependencies ) } [string] " f" [string] { repr ( self . _buildtime_dependencies ) } [string] " f" [string] { repr ( self . _external_dependencies ) }" [string] ) [EOL] [EOL] [EOL] class CyclicDependencyOccured ( Exception ) : [EOL] pass [EOL] [EOL] [EOL] def _merge_defaultdicts ( first , second ) : [EOL] return _merge_with_combine ( first , second , combine_function = lambda x , y : x | y , constructor = lambda : set ( ) , ) [EOL] [EOL] [EOL] def _merge_with_combine ( first , second , combine_function , constructor , ) : [EOL] combination = defaultdict ( constructor ) [EOL] for first_key , first_value in first . items ( ) : [EOL] combination [ first_key ] = first_value [EOL] for second_key , second_value in second . items ( ) : [EOL] combination [ second_key ] = ( combine_function ( combination [ second_key ] , second_value ) [EOL] if second_key in combination [EOL] else second_value ) [EOL] return combination [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Set[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Set[pypi2nix.external_dependencies.ExternalDependency]]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.external_dependencies.ExternalDependency$ 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.external_dependencies.ExternalDependency$ 0 0 0 0 $builtins.bool$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 $None$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 $pypi2nix.wheel.Wheel$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,None,None]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Generator[builtins.str,None,None]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $builtins.str$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 $"DependencyGraph"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 0 0 0 0 0 0 $"DependencyGraph"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[builtins.str,typing.Set[V]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.DefaultDict[K,V]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Iterator , Any , Dict [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import json [EOL] import os [EOL] import shlex [EOL] import tempfile [EOL] from contextlib import contextmanager [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Iterator [EOL] from typing import Optional [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from packaging . markers import default_environment [EOL] [EOL] from pypi2nix . exceptions import UnknownTargetPlatform [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . python_version import PythonVersion [EOL] from pypi2nix . python_version import python_version_from_version_string [EOL] [EOL] [EOL] class PlatformGenerator : [EOL] def __init__ ( self , nix , logger ) : [EOL] self . nix = nix [EOL] self . logger = logger [EOL] [EOL] def from_python_version ( self , version ) : [EOL] with self . _python_environment_nix ( version . derivation_name ( ) ) as nix_file : [EOL] default_environment_string = self . nix . shell ( command = [string] . format ( command = shlex . quote ( self . _python_command_for_default_environment ( ) ) ) , derivation_path = nix_file , ) [EOL] return self . _target_platform_from_default_environment_string ( default_environment_string , python_version = version ) [EOL] [EOL] def current_platform ( self ) : [EOL] environment_json_string = json . dumps ( default_environment ( ) ) [EOL] environment = self . _load_default_environment ( environment_json_string ) [EOL] python_version = python_version_from_version_string ( environment [ [string] ] ) [EOL] if python_version is None : [EOL] return None [EOL] else : [EOL] return self . _target_platform_from_default_environment_string ( environment_json_string , python_version = python_version ) [EOL] [EOL] def _python_command_for_default_environment ( self ) : [EOL] return [string] . join ( [ [string] , [string] , [string] , ] ) [EOL] [EOL] def _target_platform_from_default_environment_string ( self , json_string , python_version ) : [EOL] default_environment = self . _load_default_environment ( json_string ) [EOL] return TargetPlatform ( python_version = default_environment [ [string] ] , nixpkgs_python_version = python_version , python_full_version = default_environment [ [string] ] , implementation_version = default_environment [ [string] ] , os_name = default_environment [ [string] ] , implementation_name = default_environment [ [string] ] , sys_platform = default_environment [ [string] ] , platform_machine = default_environment [ [string] ] , platform_python_implementation = default_environment [ [string] ] , platform_release = default_environment [ [string] ] , platform_system = default_environment [ [string] ] , platform_version = default_environment [ [string] ] , ) [EOL] [EOL] def _load_default_environment ( self , json_string ) : [EOL] result = dict ( ) [EOL] loaded_json = self . _parse_target_platform_string ( json_string ) [EOL] if not isinstance ( loaded_json , dict ) : [EOL] return result [EOL] for key , value in loaded_json . items ( ) : [EOL] if isinstance ( key , str ) and isinstance ( value , str ) : [EOL] result [ key ] = value [EOL] return result [EOL] [EOL] def _parse_target_platform_string ( self , json_string ) : [EOL] try : [EOL] return json . loads ( json_string ) [EOL] except json . decoder . JSONDecodeError : [EOL] error_message = ( [string] [string] + json_string ) [EOL] self . logger . error ( error_message ) [EOL] raise UnknownTargetPlatform ( error_message ) [EOL] [EOL] @ contextmanager def _python_environment_nix ( self , nixpkgs_attribute_name ) : [EOL] fd , path = tempfile . mkstemp ( ) [EOL] with open ( fd , [string] ) as f : [EOL] f . write ( [string] . join ( [ [string] , [string] , [string] , [string] , [string] , ] ) . format ( interpreter = nixpkgs_attribute_name , packages = [string] ) ) [EOL] try : [EOL] yield path [EOL] finally : [EOL] os . remove ( path ) [EOL] [EOL] [EOL] @ attrs class TargetPlatform : [EOL] python_version = attrib ( ) [EOL] nixpkgs_python_version = attrib ( ) [EOL] python_full_version = attrib ( ) [EOL] implementation_version = attrib ( ) [EOL] os_name = attrib ( ) [EOL] sys_platform = attrib ( ) [EOL] implementation_name = attrib ( ) [EOL] platform_machine = attrib ( ) [EOL] platform_python_implementation = attrib ( ) [EOL] platform_release = attrib ( ) [EOL] platform_system = attrib ( ) [EOL] platform_version = attrib ( ) [EOL] [EOL] def environment_dictionary ( self ) : [EOL] dictionary = { } [EOL] dictionary [ [string] ] = self . python_version [EOL] dictionary [ [string] ] = self . python_full_version [EOL] dictionary [ [string] ] = self . implementation_version [EOL] dictionary [ [string] ] = self . os_name [EOL] dictionary [ [string] ] = self . sys_platform [EOL] dictionary [ [string] ] = self . platform_machine [EOL] dictionary [ [string] ] = self . platform_python_implementation [EOL] dictionary [ [string] ] = self . platform_release [EOL] dictionary [ [string] ] = self . platform_system [EOL] dictionary [ [string] ] = self . platform_version [EOL] dictionary [ [string] ] = self . implementation_name [EOL] return dictionary [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TargetPlatform"$ 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 0 0 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 0 $typing.Optional["TargetPlatform"]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TargetPlatform"$ 0 0 0 $builtins.str$ 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $pypi2nix.python_version.PythonVersion$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import List , Union [EOL] import typing [EOL] import builtins [EOL] import pathlib [EOL] from __future__ import annotations [EOL] [EOL] import os [EOL] import os . path [EOL] import pathlib [EOL] from typing import List [EOL] from typing import Union [EOL] [EOL] [EOL] class Path : [EOL] def __init__ ( self , path ) : [EOL] self . _path = ... [EOL] if isinstance ( path , str ) : [EOL] self . _path = pathlib . Path ( path ) [EOL] elif isinstance ( path , pathlib . Path ) : [EOL] self . _path = path [EOL] else : [EOL] self . _path = path . _path [EOL] [EOL] def list_files ( self ) : [EOL] return list ( map ( lambda f : self / f , os . listdir ( str ( self ) ) ) ) [EOL] [EOL] def ensure_directory ( self ) : [EOL] return os . makedirs ( self . _path , exist_ok = True ) [EOL] [EOL] def write_text ( self , text ) : [EOL] self . _path . write_text ( text ) [EOL] [EOL] def endswith ( self , suffix ) : [EOL] return str ( self ) . endswith ( suffix ) [EOL] [EOL] def is_file ( self ) : [EOL] return os . path . isfile ( self . _path ) [EOL] [EOL] def __truediv__ ( self , other ) : [EOL] if isinstance ( other , str ) : [EOL] return Path ( self . _path / other ) [EOL] else : [EOL] return Path ( self . _path / other . _path ) [EOL] [EOL] def __str__ ( self ) : [EOL] return str ( self . _path ) [EOL] [EOL] def __hash__ ( self ) : [EOL] return hash ( self . _path ) [EOL] [EOL] def __eq__ ( self , other ) : [EOL] if isinstance ( other , Path ) : [EOL] return self . _path == other . _path [EOL] else : [EOL] return False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 0 0 0 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 0 0 0 0 0 $pathlib.Path$ 0 $typing.Union[pathlib.Path,builtins.str,Path]$ 0 $pathlib.Path$ 0 0 0 $typing.List[Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Path$ 0 0 0 $typing.Union[builtins.str,Path]$ 0 0 0 0 0 0 $typing.Union[builtins.str,Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Union[builtins.str,Path]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $builtins.object$ 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0 0 $builtins.object$ 0 0 0 0 0 0 0 0 0
from typing import Dict , List , Union [EOL] import typing [EOL] URL_SCHEMA = { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , } , } , [string] : [ [string] , [string] , [string] ] , } [EOL] [EOL] GIT_SCHEMA = { [string] : [string] , [string] : { [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , [string] : [ [string] , [string] , [string] , [string] ] , } [EOL] [EOL] INDEX_ITEM_SCHEMA = { [string] : [ URL_SCHEMA , GIT_SCHEMA , ] } [EOL] [EOL] INDEX_SCHEMA = { [string] : [string] , [string] : INDEX_ITEM_SCHEMA , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]]],builtins.str]]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]],typing.List[builtins.str],builtins.str]]]]$ 0 0 0
from typing import Iterator , Dict , Any , Type [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import src [EOL] import json [EOL] import os . path [EOL] from collections import namedtuple [EOL] from contextlib import contextmanager [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import Iterator [EOL] from typing import Union [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from jsonschema import ValidationError [EOL] from jsonschema import validate [EOL] [EOL] from pypi2nix . logger import Logger [EOL] [EOL] from . schema import GIT_SCHEMA [EOL] from . schema import INDEX_SCHEMA [EOL] from . schema import URL_SCHEMA [EOL] [EOL] [EOL] @ attrs class Index : [EOL] UrlEntry = namedtuple ( [string] , [ [string] , [string] ] ) [EOL] GitEntry = namedtuple ( [string] , [ [string] , [string] , [string] ] ) [EOL] Entry = Union [ UrlEntry , GitEntry ] [EOL] [EOL] logger = attrib ( ) [EOL] path = attrib ( default = os . path . join ( os . path . dirname ( __file__ ) , [string] ) ) [EOL] [EOL] def __getitem__ ( self , key ) : [EOL] with self . _index_json ( ) as index : [EOL] entry = index [ key ] [EOL] if self . _is_schema_valid ( entry , URL_SCHEMA ) : [EOL] return Index . UrlEntry ( url = entry [ [string] ] , sha256 = entry [ [string] ] ) [EOL] elif self . _is_schema_valid ( entry , GIT_SCHEMA ) : [EOL] return Index . GitEntry ( url = entry [ [string] ] , sha256 = entry [ [string] ] , rev = entry [ [string] ] ) [EOL] else : [EOL] raise Exception ( ) [EOL] [EOL] def __setitem__ ( self , key , value ) : [EOL] with self . _index_json ( write = True ) as index : [EOL] if isinstance ( value , self . UrlEntry ) : [EOL] index [ key ] = { [string] : value . url , [string] : value . sha256 , [string] : [string] , } [EOL] if isinstance ( value , self . GitEntry ) : [EOL] index [ key ] = { [string] : value . url , [string] : value . sha256 , [string] : value . rev , [string] : [string] , } [EOL] [EOL] def is_valid ( self ) : [EOL] with self . _index_json ( ) as index : [EOL] return self . _is_schema_valid ( index , INDEX_SCHEMA ) [EOL] [EOL] @ contextmanager def _index_json ( self , write = False ) : [EOL] with open ( self . path ) as f : [EOL] index = json . load ( f ) [EOL] yield index [EOL] if write : [EOL] with open ( self . path , [string] ) as f : [EOL] json . dump ( index , f , sort_keys = True , indent = [number] ) [EOL] [EOL] def _is_schema_valid ( self , json_value , schema ) : [EOL] try : [EOL] validate ( json_value , schema ) [EOL] except ValidationError as e : [EOL] self . logger . error ( str ( e ) ) [EOL] return False [EOL] else : [EOL] return True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Index.Entry"$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $"Index.Entry"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 0 0 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 $"Index.Entry"$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.str]]]$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] import toml [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import ParsingFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . interfaces import HasBuildDependencies [EOL] [EOL] [EOL] class PyprojectToml ( HasBuildDependencies ) : [EOL] def __init__ ( self , name , file_content , logger , requirement_parser , ) : [EOL] self . pyproject_toml = toml . loads ( file_content ) [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] self . name = name [EOL] [EOL] def build_dependencies ( self , target_platform ) : [EOL] requirement_set = RequirementSet ( target_platform ) [EOL] if self . pyproject_toml is not None : [EOL] for build_input in self . pyproject_toml . get ( [string] , { } ) . get ( [string] , [ ] ) : [EOL] try : [EOL] requirement = self . requirement_parser . parse ( build_input ) [EOL] except ParsingFailed as e : [EOL] self . logger . warning ( [string] . format ( name = self . name ) ) [EOL] self . logger . warning ( [string] . format ( reason = e . reason ) ) [EOL] else : [EOL] if requirement . applies_to_target ( target_platform ) : [EOL] requirement_set . add ( requirement ) [EOL] return requirement_set [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0
from typing import Optional , Any [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from typing import Optional [EOL] [EOL] from setuptools . config import read_configuration [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . requirement_parser import ParsingFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] from . interfaces import HasBuildDependencies [EOL] [EOL] [EOL] class SetupCfg ( HasBuildDependencies ) : [EOL] def __init__ ( self , setup_cfg_path , logger , requirement_parser , ) : [EOL] self . setup_cfg_path = setup_cfg_path [EOL] self . setup_cfg = read_configuration ( setup_cfg_path ) [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] [EOL] def build_dependencies ( self , target_platform ) : [EOL] setup_requires = self . setup_cfg . get ( [string] , { } ) . get ( [string] ) [EOL] requirements = RequirementSet ( target_platform ) [EOL] if isinstance ( setup_requires , str ) : [EOL] requirements . add ( self . requirement_parser . parse ( setup_requires ) ) [EOL] elif isinstance ( setup_requires , list ) : [EOL] for requirement_string in setup_requires : [EOL] try : [EOL] requirement = self . requirement_parser . parse ( requirement_string ) [EOL] except ParsingFailed as e : [EOL] self . logger . warning ( f" [string] { self . setup_cfg_path } [string] " ) [EOL] self . logger . warning ( f" [string] { e . reason } [string] " ) [EOL] else : [EOL] if requirement . applies_to_target ( target_platform ) : [EOL] requirements . add ( requirement ) [EOL] return requirements [EOL] [EOL] @ property def name ( self ) : [EOL] return self . setup_cfg . get ( [string] , { } ) . get ( [string] , None ) [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
class DistributionNotDetected ( Exception ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0
import builtins [EOL] import src [EOL] import email [EOL] import os [EOL] from email . header import Header [EOL] from email . parser import Parser as EmailParser [EOL] [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] from . exceptions import DistributionNotDetected [EOL] [EOL] [EOL] @ attrs class PackageMetadata : [EOL] name = attrib ( ) [EOL] [EOL] @ classmethod def from_package_directory ( package_metadata , path ) : [EOL] builder = _PackageMetadataBuilder ( path ) [EOL] return package_metadata ( name = builder . name ) [EOL] [EOL] [EOL] class _PackageMetadataBuilder : [EOL] def __init__ ( self , path_to_directory ) : [EOL] self . path_to_directory = path_to_directory [EOL] self . _name = [string] [EOL] [EOL] self . build ( ) [EOL] [EOL] @ property def name ( self ) : [EOL] return self . _name [EOL] [EOL] def build ( self ) : [EOL] pkg_info_file = os . path . join ( self . path_to_directory , [string] ) [EOL] try : [EOL] with open ( pkg_info_file ) as f : [EOL] parser = EmailParser ( ) [EOL] metadata = parser . parse ( f ) [EOL] except FileNotFoundError : [EOL] raise DistributionNotDetected ( f" [string] { self . path_to_directory }" ) [EOL] self . _name = metadata . get ( [string] ) [EOL] if isinstance ( self . _name , Header ) : [EOL] raise DistributionNotDetected ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $"PackageMetadata"$ 0 0 0 $builtins.str$ 0 0 0 $src.pypi2nix.package.metadata._PackageMetadataBuilder$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $src.pypi2nix.package.metadata._PackageMetadataBuilder$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $email.parser.Parser$ 0 0 0 0 0 $email.message.Message$ 0 $email.parser.Parser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $email.message.Message$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0
import pypi2nix [EOL] import builtins [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] [EOL] [EOL] class HasBuildDependencies ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def build_dependencies ( self , target_platform ) : [EOL] pass [EOL] [EOL] [EOL] class HasRuntimeDependencies ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def runtime_dependencies ( self , target_platform ) : [EOL] pass [EOL] [EOL] [EOL] class HasPackageName ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def package_name ( self ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 $pypi2nix.target_platform.TargetPlatform$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0
from . exceptions import DistributionNotDetected [EOL] from . interfaces import HasBuildDependencies [EOL] from . interfaces import HasPackageName [EOL] from . interfaces import HasRuntimeDependencies [EOL] from . metadata import PackageMetadata [EOL] from . pyproject import PyprojectToml [EOL] from . setupcfg import SetupCfg [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import lookup [EOL] import pypi2nix [EOL] import src [EOL] import typing [EOL] import builtins [EOL] from copy import copy [EOL] from typing import Set [EOL] [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] [EOL] from . lookup import RequirementDependencyRetriever [EOL] [EOL] [EOL] class ExternalDependencyCollector : [EOL] def __init__ ( self , requirement_dependency_retriever ) : [EOL] self . _external_dependencies = set ( ) [EOL] self . _requirement_dependency_retriever = requirement_dependency_retriever [EOL] [EOL] def collect_explicit ( self , attribute_name ) : [EOL] self . _external_dependencies . add ( ExternalDependency ( attribute_name ) ) [EOL] [EOL] def collect_from_requirements ( self , requirements ) : [EOL] for requirement in requirements : [EOL] self . _external_dependencies . update ( self . _requirement_dependency_retriever . get_external_dependency_for_requirement ( requirement ) ) [EOL] [EOL] def get_collected ( self ) : [EOL] return copy ( self . _external_dependencies ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $lookup.RequirementDependencyRetriever$ 0 0 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 0 0 0 0 $src.pypi2nix.external_dependency_collector.lookup.RequirementDependencyRetriever$ 0 $lookup.RequirementDependencyRetriever$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Set [EOL] import pypi2nix [EOL] import typing [EOL] from typing import Set [EOL] [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . requirements import Requirement [EOL] [EOL] [EOL] class RequirementDependencyRetriever : [EOL] def __init__ ( self , dependency_graph = DependencyGraph ( ) ) : [EOL] self . _dependency_graph = dependency_graph [EOL] [EOL] def get_external_dependency_for_requirement ( self , requirement ) : [EOL] return self . _dependency_graph . get_all_external_dependencies ( requirement ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 $typing.Set[pypi2nix.external_dependencies.ExternalDependency]$ 0 0 0 $pypi2nix.requirements.Requirement$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirements.Requirement$ 0 0
from . collector import ExternalDependencyCollector [EOL] from . lookup import RequirementDependencyRetriever [EOL]	0 0 0 0 0 0 0 0 0 0 0 0
from . external_dependency import ExternalDependency [EOL]	0 0 0 0 0 0
import builtins [EOL] from attr import attrib [EOL] from attr import attrs [EOL] [EOL] [EOL] @ attrs ( frozen = True ) class ExternalDependency : [EOL] _attribute_name = attrib ( ) [EOL] [EOL] def attribute_name ( self ) : [EOL] return self . _attribute_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Iterator , List , Dict , Optional [EOL] import pypi2nix [EOL] import builtins [EOL] import venv [EOL] import typing [EOL] import os [EOL] import os . path [EOL] from contextlib import contextmanager [EOL] from tempfile import TemporaryDirectory [EOL] from typing import Dict [EOL] from typing import Iterator [EOL] from typing import List [EOL] from typing import Optional [EOL] from venv import EnvBuilder [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . pip import Pip [EOL] from pypi2nix . pip import PipFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . utils import cmd [EOL] [EOL] [EOL] class VirtualenvPip ( Pip ) : [EOL] def __init__ ( self , logger , target_platform , target_directory , env_builder , requirement_parser , no_index = False , wheel_distribution_path = None , find_links = [ ] , ) : [EOL] self . logger = logger [EOL] self . target_platform = target_platform [EOL] self . target_directory = target_directory [EOL] self . env_builder = env_builder [EOL] self . no_index = no_index [EOL] self . wheel_distribution_path = wheel_distribution_path [EOL] self . find_links = find_links [EOL] self . requirement_parser = requirement_parser [EOL] [EOL] def prepare_virtualenv ( self ) : [EOL] self . env_builder . create ( self . target_directory ) [EOL] self . _execute_pip_command ( [ [string] , self . _wheel_requirement_name ( ) ] + self . _maybe_index ( ) ) [EOL] [EOL] def download_sources ( self , requirements , target_directory ) : [EOL] with self . _requirements_file ( requirements ) as requirement_file : [EOL] self . _execute_pip_command ( [ [string] , [string] , requirement_file , [string] , str ( target_directory ) , [string] , [string] , ] + self . _maybe_index ( ) ) [EOL] [EOL] def build_wheels ( self , requirements , target_directory , source_directories , ) : [EOL] with self . _requirements_file ( requirements ) as requirement_file : [EOL] source_dir_arguments = [ ] [EOL] for source_directory in source_directories : [EOL] source_dir_arguments . append ( [string] ) [EOL] source_dir_arguments . append ( str ( source_directory ) ) [EOL] self . _execute_pip_command ( [ [string] , [string] , str ( target_directory ) , [string] ] + source_dir_arguments + [ [string] , requirement_file ] ) [EOL] [EOL] def install ( self , requirements , source_directories , target_directory , ) : [EOL] with self . _requirements_file ( requirements ) as requirements_file : [EOL] source_directories_arguments = [ ] [EOL] for source_directory in source_directories : [EOL] source_directories_arguments . append ( [string] ) [EOL] source_directories_arguments . append ( str ( source_directory ) ) [EOL] self . _execute_pip_command ( [ [string] , [string] , [string] , str ( target_directory ) , [string] , requirements_file , ] + source_directories_arguments ) [EOL] [EOL] def freeze ( self , python_path ) : [EOL] return self . _execute_pip_command ( [ [string] ] , pythonpath = python_path ) [EOL] [EOL] def _pip_path ( self ) : [EOL] return os . path . join ( self . target_directory , [string] , [string] ) [EOL] [EOL] def _execute_pip_command ( self , arguments , pythonpath = [ ] ) : [EOL] with self . _explicit_pythonpath ( pythonpath ) , self . _set_environment_variable ( { [string] : [string] , } ) : [EOL] returncode , output = cmd ( [ self . _pip_path ( ) ] + arguments , logger = self . logger ) [EOL] if returncode != [number] : [EOL] raise PipFailed ( output = output ) [EOL] return output [EOL] [EOL] @ contextmanager def _explicit_pythonpath ( self , pythonpath ) : [EOL] additional_paths = [string] . join ( map ( str , pythonpath ) ) [EOL] with self . _set_environment_variable ( { [string] : additional_paths } ) : [EOL] yield [EOL] [EOL] @ contextmanager def _requirements_file ( self , requirements ) : [EOL] with TemporaryDirectory ( ) as directory : [EOL] yield requirements . to_file ( directory , self . target_platform , self . requirement_parser , self . logger ) . processed_requirements_file_path ( ) [EOL] [EOL] @ contextmanager def _set_environment_variable ( self , variables ) : [EOL] def set_environment ( environment ) : [EOL] for name , value in variables . items ( ) : [EOL] if value is None : [EOL] del os . environ [ name ] [EOL] else : [EOL] os . environ [ name ] = value [EOL] [EOL] old_environment = dict ( os . environ ) [EOL] set_environment ( variables ) [EOL] try : [EOL] yield [EOL] finally : [EOL] for key , value in old_environment . items ( ) : [EOL] os . environ [ key ] = value [EOL] for key in os . environ . keys ( ) : [EOL] if key not in old_environment : [EOL] del os . environ [ key ] [EOL] [EOL] def _maybe_index ( self ) : [EOL] arguments = [ ] [EOL] if self . no_index : [EOL] arguments . append ( [string] ) [EOL] for link in self . find_links : [EOL] arguments . append ( [string] ) [EOL] arguments . append ( link ) [EOL] return arguments [EOL] [EOL] def _wheel_requirement_name ( self ) : [EOL] if self . wheel_distribution_path is None : [EOL] return [string] [EOL] else : [EOL] return self . wheel_distribution_path [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 $venv.EnvBuilder$ 0 0 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $venv.EnvBuilder$ 0 $venv.EnvBuilder$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Optional[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $typing.List[pypi2nix.path.Path]$ 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[None]$ 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[None]$ 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 $None$ 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Optional[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from . exceptions import PipFailed [EOL] from . implementation import NixPip [EOL] from . interface import Pip [EOL] from . virtualenv import VirtualenvPip [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import pypi2nix [EOL] import builtins [EOL] import typing [EOL] from abc import ABCMeta [EOL] from abc import abstractmethod [EOL] from typing import List [EOL] [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] [EOL] [EOL] class Pip ( metaclass = ABCMeta ) : [EOL] @ abstractmethod def download_sources ( self , requirements , target_directory ) : [EOL] pass [EOL] [EOL] @ abstractmethod def build_wheels ( self , requirements , target_directory , source_directories , ) : [EOL] pass [EOL] [EOL] @ abstractmethod def install ( self , requirements , source_directories , target_directory , ) : [EOL] pass [EOL] [EOL] @ abstractmethod def freeze ( self , python_path ) : [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $typing.List[pypi2nix.path.Path]$ 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0
from typing import Any , Iterator , List , Dict , Optional [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import os . path [EOL] import shlex [EOL] import shutil [EOL] import sys [EOL] import urllib . parse [EOL] from typing import Any [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] [EOL] import click [EOL] [EOL] from pypi2nix . external_dependencies import ExternalDependency [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . nix import EvaluationFailed [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . path import Path [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from pypi2nix . requirement_set import RequirementSet [EOL] from pypi2nix . target_platform import TargetPlatform [EOL] from pypi2nix . utils import NixOption [EOL] from pypi2nix . utils import escape_double_quotes [EOL] [EOL] from . interface import Pip [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] DOWNLOAD_NIX = os . path . join ( HERE , [string] ) [EOL] WHEEL_NIX = os . path . join ( HERE , [string] ) [EOL] INSTALL_NIX = os . path . join ( HERE , [string] ) [EOL] BASE_NIX = os . path . join ( HERE , [string] ) [EOL] [EOL] [EOL] class NixPip ( Pip ) : [EOL] def __init__ ( self , nix , project_directory , extra_build_inputs , extra_env , wheels_cache , target_platform , logger , requirement_parser , ) : [EOL] self . nix = nix [EOL] self . project_directory = project_directory [EOL] self . extra_build_inputs = extra_build_inputs [EOL] self . extra_env = extra_env [EOL] self . build_output = [string] [EOL] self . wheels_cache = wheels_cache [EOL] self . target_platform = target_platform [EOL] self . logger = logger [EOL] self . requirement_parser = requirement_parser [EOL] [EOL] output = self . nix . evaluate_expression ( [string] % escape_double_quotes ( extra_env ) ) [EOL] [comment] [EOL] self . extra_env = output [ [number] : - [number] ] [EOL] [EOL] self . default_lib_directory = self . project_directory / [string] [EOL] self . download_cache_directory = self . project_directory / [string] [EOL] [EOL] def download_sources ( self , requirements , target_directory ) : [EOL] if not requirements : [EOL] return [EOL] requirements_files = [ requirements . to_file ( str ( self . project_directory ) , self . target_platform , self . requirement_parser , self . logger , ) . processed_requirements_file_path ( ) ] [EOL] self . build_from_nix_file ( command = [string] , file_path = DOWNLOAD_NIX , nix_arguments = self . nix_arguments ( requirements_files = requirements_files , destination_directory = target_directory , editable_sources_directory = self . editable_sources_directory ( ) , build_directory = self . build_directory ( ) , ) , ) [EOL] [EOL] def build_wheels ( self , requirements , target_directory , source_directories , ) : [EOL] if not requirements : [EOL] return [EOL] requirements_files = [ requirements . to_file ( str ( self . project_directory ) , self . target_platform , self . requirement_parser , self . logger , ) . processed_requirements_file_path ( ) ] [EOL] self . build_from_nix_file ( command = [string] , file_path = WHEEL_NIX , nix_arguments = self . nix_arguments ( wheels_cache = self . wheels_cache , requirements_files = requirements_files , editable_sources_directory = self . editable_sources_directory ( ) , build_directory = self . build_directory ( ) , wheels_dir = target_directory , sources = source_directories , ) , ) [EOL] [EOL] def install ( self , requirements , source_directories , target_directory = None , ) : [EOL] if not requirements : [EOL] return [EOL] if target_directory is None : [EOL] target_directory = self . default_lib_directory [EOL] requirements_files = [ requirements . to_file ( str ( self . project_directory ) , self . target_platform , self . requirement_parser , self . logger , ) . processed_requirements_file_path ( ) ] [EOL] self . build_from_nix_file ( command = [string] , file_path = INSTALL_NIX , nix_arguments = self . nix_arguments ( requirements_files = requirements_files , target_directory = target_directory , sources_directories = source_directories , ) , ) [EOL] [EOL] def freeze ( self , python_path = [ ] ) : [EOL] additional_paths = [string] . join ( shlex . quote ( str ( path ) ) for path in python_path ) [EOL] [EOL] output = self . nix . shell ( [string] . format ( PYTHONPATH = [string] + additional_paths + [string] [EOL] if python_path [EOL] else [string] ) , BASE_NIX , nix_arguments = self . nix_arguments ( ) , ) [EOL] lines = map ( lambda x : x . strip ( ) , output . splitlines ( ) ) [EOL] return ( [string] . join ( lines ) + [string] ) if lines else [string] [EOL] [EOL] def editable_sources_directory ( self ) : [EOL] return self . project_directory / [string] [EOL] [EOL] def build_directory ( self ) : [EOL] return self . project_directory / [string] [EOL] [EOL] def nix_arguments ( self , ** arguments ) : [EOL] return dict ( dict ( download_cache_dir = str ( self . download_cache_directory ) , extra_build_inputs = [ input . attribute_name ( ) for input in self . extra_build_inputs ] , project_dir = str ( self . project_directory ) , python_version = self . target_platform . nixpkgs_python_version . derivation_name ( ) , extra_env = self . extra_env , ) , ** arguments , ) [EOL] [EOL] def build_from_nix_file ( self , file_path , command , nix_arguments ) : [EOL] self . create_download_cache_if_missing ( ) [EOL] self . delete_build_directory ( ) [EOL] try : [EOL] self . build_output = self . nix . shell ( command = command , derivation_path = file_path , nix_arguments = nix_arguments ) [EOL] except EvaluationFailed as error : [EOL] if error . output is not None : [EOL] self . build_output += error . output [EOL] is_failure = True [EOL] else : [EOL] is_failure = False [EOL] self . handle_build_error ( is_failure = is_failure ) [EOL] [EOL] def create_download_cache_if_missing ( self ) : [EOL] self . download_cache_directory . ensure_directory ( ) [EOL] [EOL] def delete_build_directory ( self ) : [EOL] try : [EOL] shutil . rmtree ( str ( self . build_directory ( ) ) ) [EOL] except FileNotFoundError : [EOL] pass [EOL] [EOL] def handle_build_error ( self , is_failure ) : [EOL] if not is_failure : [EOL] if not self . build_output . endswith ( [string] ) : [EOL] return [EOL] [EOL] self . logger . error ( self . build_output ) [EOL] [EOL] message = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] no_matching_dist = [string] [EOL] if no_matching_dist in self . build_output : [EOL] dist_name = self . build_output [ self . build_output . find ( no_matching_dist ) + len ( no_matching_dist ) : ] [EOL] dist_name = dist_name [ : dist_name . find ( [string] ) ] [EOL] message = ( [string] [string] % dist_name ) [EOL] [EOL] else : [EOL] try : [EOL] self . send_crash_report ( ) [EOL] except OSError : [EOL] self . logger . error ( [string] ) [EOL] [EOL] raise click . ClickException ( message ) [EOL] [EOL] def send_crash_report ( self ) : [EOL] if click . confirm ( [string] [string] ) : [EOL] title = [string] [EOL] body = [string] [EOL] [docstring] [EOL] body += [string] [EOL] body += [string] [EOL] body += [string] + [string] . join ( sys . argv [ [number] : ] ) + [string] [EOL] body += self . build_output + [string] [EOL] click . launch ( [string] % ( urllib . parse . urlencode ( dict ( title = title , body = body ) ) ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $pypi2nix.path.Path$ 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 $typing.List[typing.Any]$ 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 0 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 $pypi2nix.requirement_set.RequirementSet$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[pypi2nix.path.Path]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 $typing.Iterator[builtins.str]$ 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.path.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,pypi2nix.utils.NixOption]$ 0 0 0 0 $pypi2nix.utils.NixOption$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.utils.NixOption$ 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.bool$ 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0
import builtins [EOL] class PipFailed ( Exception ) : [EOL] def __init__ ( self , output ) : [EOL] self . output = output [EOL] super ( ) . __init__ ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class FavaTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] external_dependencies = [ [string] , [string] ] [EOL] constraints = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List , Type [EOL] import typing [EOL] import integrationtests [EOL] from . framework import IntegrationTest [EOL] [EOL] REVISION = [string] [EOL] [EOL] [EOL] class Flake8MercurialTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] . format ( revision = REVISION ) ] [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ [string] , [string] ] [EOL] [EOL] def requirements_file_check ( self , content ) : [EOL] self . assertIn ( REVISION , content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , List , Dict [EOL] import integrationtests [EOL] import pypi2nix [EOL] import subprocess [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import os . path [EOL] import shutil [EOL] import subprocess [EOL] import sys [EOL] from typing import Dict [EOL] from typing import List [EOL] from typing import Optional [EOL] from unittest import TestCase [EOL] [EOL] import yaml [EOL] from attr import attrib [EOL] from attr import attrs [EOL] from attr import evolve [EOL] [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . memoize import memoize [EOL] from pypi2nix . nix import EvaluationFailed [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] [EOL] HERE = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] class IntegrationTest ( TestCase ) : [EOL] [docstring] [EOL] [EOL] def setUp ( self ) : [EOL] self . logger = StreamLogger ( output = sys . stdout ) [EOL] self . nix = Nix ( logger = self . logger ) [EOL] self . assertNotEqual ( self . name_of_testcase , [string] ) [EOL] self . requirement_parser = RequirementParser ( self . logger ) [EOL] [EOL] def test_build_example ( self ) : [EOL] self . build_pypi2nix ( ) [EOL] self . generate_requirements_file ( ) [EOL] self . build_nix_expression ( ) [EOL] self . check_requirements_file_content ( ) [EOL] self . run_expression_tests ( ) [EOL] self . run_dependency_graph_tests ( ) [EOL] [EOL] def build_pypi2nix ( self ) : [EOL] print ( [string] ) [EOL] try : [EOL] self . nix . build ( os . path . join ( os . path . dirname ( HERE ) , [string] ) , out_link = os . path . join ( HERE , [string] ) , ) [EOL] except EvaluationFailed : [EOL] self . fail ( [string] ) [EOL] [EOL] def generate_requirements_file ( self ) : [EOL] print ( [string] ) [EOL] requirements_file_content = self . generate_requirements_file_content ( ) [EOL] self . write_requirements_file ( requirements_file_content ) [EOL] [EOL] def build_nix_expression ( self ) : [EOL] print ( [string] ) [EOL] if self . explicit_build_directory : [EOL] self . prepare_build_directory ( ) [EOL] process = subprocess . Popen ( self . build_nix_expression_command ( ) , cwd = self . example_directory ( ) , env = self . nix_build_env ( ) , stdin = subprocess . DEVNULL , ) [EOL] process . communicate ( ) [EOL] if process . returncode != [number] : [EOL] self . fail ( [string] . format ( testname = self . name_of_testcase ) ) [EOL] [EOL] def build_nix_expression_command ( self ) : [EOL] command = [ os . path . join ( HERE , [string] , [string] , [string] ) , [string] , [string] , self . python_version , [string] , [string] , [string] , [string] , self . rendered_dependency_graph ( ) , [string] , self . _dependency_graph_output_path ( ) , ] [EOL] for requirement in self . setup_requires ( ) : [EOL] command . append ( [string] ) [EOL] command . append ( requirement ) [EOL] for variable_name , value in self . extra_environment ( ) . items ( ) : [EOL] command . append ( [string] ) [EOL] command . append ( [string] . format ( name = variable_name , value = value ) ) [EOL] for dependency in self . external_dependencies : [EOL] command . append ( [string] ) [EOL] command . append ( dependency ) [EOL] if self . explicit_build_directory : [EOL] command . append ( [string] ) [EOL] command . append ( self . build_directory ( ) ) [EOL] return command [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ ] [EOL] [EOL] def check_requirements_file_content ( self ) : [EOL] requirements_file_content = self . read_requirements_file_contents ( ) [EOL] self . requirements_file_check ( requirements_file_content ) [EOL] [EOL] def run_expression_tests ( self ) : [EOL] self . build_interpreter_from_generated_expression ( ) [EOL] self . build_additional_attributes ( ) [EOL] self . run_interpreter_with_test_code ( ) [EOL] self . run_executable_tests ( ) [EOL] [EOL] def run_dependency_graph_tests ( self ) : [EOL] dependency_graph = self . _read_dependency_graph ( ) [EOL] self . check_dependency_graph ( dependency_graph , self . requirement_parser ) [EOL] [EOL] def build_interpreter_from_generated_expression ( self ) : [EOL] print ( [string] ) [EOL] try : [EOL] self . nix . build ( os . path . join ( self . example_directory ( ) , [string] ) , attribute = [string] , out_link = os . path . join ( self . example_directory ( ) , [string] ) , ) [EOL] except EvaluationFailed : [EOL] self . fail ( [string] ) [EOL] [EOL] def build_additional_attributes ( self ) : [EOL] for additional_path in self . additional_paths_to_build : [EOL] try : [EOL] self . nix . evaluate_file ( os . path . join ( self . example_directory ( ) , [string] ) , attribute = additional_path , ) [EOL] except EvaluationFailed : [EOL] self . fail ( f" [string] { additional_path }" ) [EOL] [EOL] def run_interpreter_with_test_code ( self ) : [EOL] if self . code_for_testing_string ( ) : [EOL] test_code = self . code_for_testing_string ( ) [EOL] self . run_interpreter_with_test_code_from_result ( test_code ) [EOL] self . run_interpreter_with_test_code_in_nix_shell ( test_code ) [EOL] [EOL] def run_interpreter_with_test_code_from_result ( self , test_code ) : [EOL] print ( [string] ) [EOL] process = subprocess . Popen ( [ os . path . join ( self . example_directory ( ) , [string] , [string] , [string] ) ] , stdin = subprocess . PIPE , ) [EOL] process . communicate ( input = test_code . encode ( ) ) [EOL] if process . returncode != [number] : [EOL] self . fail ( [string] ) [EOL] [EOL] def run_interpreter_with_test_code_in_nix_shell ( self , test_code ) : [EOL] print ( [string] ) [EOL] test_command_line = [ [string] , [string] , [string] , [string] , os . path . join ( self . example_directory ( ) , [string] ) , [string] , [string] , [string] , ] [EOL] process = subprocess . Popen ( test_command_line , cwd = os . path . join ( self . example_directory ( ) , [string] , [string] ) , env = self . nix_build_env ( ) , stdin = subprocess . PIPE , ) [EOL] process . communicate ( input = test_code . encode ( ) ) [EOL] if process . returncode != [number] : [EOL] self . fail ( [string] ) [EOL] [EOL] def read_requirements_file_contents ( self ) : [EOL] with open ( os . path . join ( self . example_directory ( ) , [string] ) ) as f : [EOL] return f . read ( ) [EOL] [EOL] def code_for_testing_string ( self ) : [EOL] if self . code_for_testing and self . code_for_testing_filename : [EOL] self . fail ( [string] ) [EOL] if self . code_for_testing : [EOL] return [string] . join ( self . code_for_testing ) [EOL] elif self . code_for_testing_filename : [EOL] with open ( os . path . join ( self . example_directory ( ) , self . code_for_testing_filename ) ) as f : [EOL] return f . read ( ) [EOL] else : [EOL] return [string] [EOL] [EOL] code_for_testing = [ ] [EOL] code_for_testing_filename = None [EOL] [EOL] def extra_environment ( self ) : [EOL] return dict ( ) [EOL] [EOL] def run_executable_tests ( self ) : [EOL] for test_command in self . executables_for_testing ( ) : [EOL] self . run_test_command_in_shell ( test_command ) [EOL] self . run_test_command_from_build_output ( test_command ) [EOL] [EOL] def run_test_command_in_shell ( self , test_command ) : [EOL] print ( [string] . format ( command = test_command ) ) [EOL] test_command_line = [ [string] , [string] , [string] , [string] , os . path . join ( self . example_directory ( ) , [string] ) , [string] , [string] , ] + test_command . command [EOL] process = subprocess . Popen ( test_command_line , cwd = os . path . join ( self . example_directory ( ) , [string] , [string] ) , env = dict ( self . nix_build_env ( ) , ** test_command . env ) , ) [EOL] process . communicate ( ) [EOL] print ( ) [comment] [EOL] if process . returncode != [number] : [EOL] self . fail ( [string] . format ( command = test_command ) ) [EOL] [EOL] def run_test_command_from_build_output ( self , test_command ) : [EOL] prepared_test_command = evolve ( test_command , command = [ [string] + test_command . command [ [number] ] ] + test_command . command [ [number] : ] , ) [EOL] print ( [string] . format ( command = prepared_test_command ) ) [EOL] process = subprocess . Popen ( prepared_test_command . command , cwd = os . path . join ( self . example_directory ( ) , [string] , [string] ) , env = dict ( self . nix_build_env ( ) , ** prepared_test_command . env ) , ) [EOL] process . communicate ( ) [EOL] print ( ) [comment] [EOL] if process . returncode != [number] : [EOL] self . fail ( [string] . format ( command = test_command ) ) [EOL] [EOL] def executables_for_testing ( self ) : [EOL] return [ ] [EOL] [EOL] def nix_build_env ( self ) : [EOL] environment_variables = dict ( os . environ ) [EOL] del environment_variables [ [string] ] [EOL] return environment_variables [EOL] [EOL] def generate_requirements_file_content ( self ) : [EOL] if self . constraints : [EOL] self . generate_constraints_txt ( ) [EOL] requirements_txt_extra_content = [ [string] + self . constraints_txt_path ( ) ] [EOL] else : [EOL] requirements_txt_extra_content = [ ] [EOL] return [string] . join ( self . requirements + requirements_txt_extra_content ) [EOL] [EOL] def generate_constraints_txt ( self ) : [EOL] with open ( self . constraints_txt_path ( ) , [string] ) as f : [EOL] f . write ( [string] . join ( self . constraints ) ) [EOL] [EOL] def constraints_txt_path ( self ) : [EOL] return os . path . join ( self . example_directory ( ) , [string] ) [EOL] [EOL] def write_requirements_file ( self , content ) : [EOL] os . makedirs ( os . path . dirname ( self . requirements_file_path ( ) ) , exist_ok = True ) [EOL] with open ( self . requirements_file_path ( ) , [string] ) as f : [EOL] f . write ( content ) [EOL] [EOL] def requirements_file_path ( self ) : [EOL] return os . path . join ( self . example_directory ( ) , [string] ) [EOL] [EOL] def example_directory ( self ) : [EOL] return os . path . join ( HERE , self . name_of_testcase ) [EOL] [EOL] def requirements_file_check ( self , _ ) : [EOL] pass [EOL] [EOL] def _dependency_graph_output_path ( self ) : [EOL] return os . path . join ( self . example_directory ( ) , [string] ) [EOL] [EOL] def build_directory ( self ) : [EOL] return os . path . join ( self . example_directory ( ) , [string] ) [EOL] [EOL] def prepare_build_directory ( self ) : [EOL] if os . path . exists ( self . build_directory ( ) ) : [EOL] shutil . rmtree ( self . build_directory ( ) ) [EOL] os . makedirs ( self . build_directory ( ) ) [EOL] [EOL] def check_dependency_graph ( self , dependency_graph , requirement_parser ) : [EOL] pass [EOL] [EOL] def _read_dependency_graph ( self ) : [EOL] with open ( self . _dependency_graph_output_path ( ) ) as f : [EOL] return DependencyGraph . deserialize ( f . read ( ) ) [EOL] [EOL] constraints = [ ] [EOL] python_version = [string] [EOL] requirements = [ ] [EOL] name_of_testcase = [string] [EOL] external_dependencies = [ ] [EOL] explicit_build_directory = False [EOL] additional_paths_to_build = [ ] [EOL] dependency_graph = { } [EOL] [EOL] @ memoize def rendered_dependency_graph ( self ) : [EOL] path = os . path . join ( self . example_directory ( ) , [string] ) [EOL] with open ( path , [string] ) as f : [EOL] yaml . dump ( self . dependency_graph , f , ) [EOL] return path [EOL] [EOL] [EOL] @ attrs class TestCommand : [EOL] command = attrib ( ) [EOL] env = attrib ( default = dict ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $"TestCommand"$ 0 0 0 0 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 0 0 $None$ 0 0 0 $"TestCommand"$ 0 0 0 $integrationtests.framework.TestCommand$ 0 0 0 $"TestCommand"$ 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $integrationtests.framework.TestCommand$ 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 $integrationtests.framework.TestCommand$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $integrationtests.framework.TestCommand$ 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $subprocess.Popen[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"TestCommand"$ 0 0 0 0 0 $typing.List["TestCommand"]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $builtins.bool$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] from . framework import TestCommand [EOL] [EOL] [EOL] class AwscliAndRequestsTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] , [string] ] [EOL] code_for_testing = [ [string] , [string] ] [EOL] [EOL] def executables_for_testing ( self ) : [EOL] return [ TestCommand ( command = [ [string] , [string] ] , env = { [string] : [string] } ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class Flake8TestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class RelativePathsTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] [EOL] def requirements_file_check ( self , content ) : [EOL] self . assertIn ( [string] , content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] REVISION = [string] [EOL] [EOL] [EOL] class TornadoTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] [EOL] def requirements_file_check ( self , content ) : [EOL] self . assertIn ( REVISION , content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class LocalPathTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from unittest import expectedFailure [EOL] [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] @ expectedFailure class LdapTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] python_version = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] external_dependencies = [ [string] , [string] , [string] ] [EOL] [EOL] def extra_environment ( self ) : [EOL] return { [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class AiohttpTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] python_version = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0
from typing import List [EOL] import typing [EOL] from unittest import expectedFailure [EOL] [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] @ expectedFailure class ScipyTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] , [string] ] [EOL] external_dependencies = [ [string] , [string] ] [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] from . framework import TestCommand [EOL] [EOL] [EOL] class LektorTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] external_dependencies = [ [string] , [string] , [string] ] [EOL] [EOL] def executables_for_testing ( self ) : [EOL] return [ TestCommand ( command = [ [string] , [string] ] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List , Dict [EOL] import typing [EOL] import pypi2nix [EOL] from pypi2nix . dependency_graph import DependencyGraph [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class DependencyGraphOutputTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] [EOL] def check_dependency_graph ( self , dependency_graph , requirement_parser ) : [EOL] self . assertTrue ( dependency_graph . is_runtime_dependency ( requirement_parser . parse ( [string] ) , requirement_parser . parse ( [string] ) , ) ) [EOL] [EOL] [EOL] class DependencyGraphInputTestCase ( IntegrationTest ) : [EOL] [docstring] [EOL] [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] dependency_graph = { [string] : { [string] : [ [string] ] } } [EOL] code_for_testing = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 $pypi2nix.dependency_graph.DependencyGraph$ 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 $pypi2nix.requirement_parser.RequirementParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Dict[builtins.str,typing.List[builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class PillowTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] [EOL] external_dependencies = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class FlitTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class SetuptoolsTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_to_test = [ [string] ] [EOL] requirements = [ [string] ] [EOL] [EOL] def requirements_file_check ( self , content ) : [EOL] self . assertIn ( [string] , content ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class EmpyTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class SerpyTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class ConnexionTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] code_for_testing = [ [string] ] [EOL] constraints = [ [string] , [string] ] [EOL] [EOL] def setup_requires ( self ) : [EOL] return [ [string] , [string] , [string] , [string] , [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] class AppDirsTestCase ( IntegrationTest ) : [EOL] [docstring] [EOL] [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] additional_paths_to_build = [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from . framework import IntegrationTest [EOL] from . framework import TestCommand [EOL] [EOL] [EOL] class Rss2EmailTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] code_for_testing = [ [string] ] [EOL] requirements = [ [string] ] [EOL] [EOL] def executables_for_testing ( self ) : [EOL] return [ TestCommand ( command = [ [string] , [string] ] ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import typing [EOL] from unittest import expectedFailure [EOL] [EOL] from . framework import IntegrationTest [EOL] [EOL] [EOL] @ expectedFailure class PynaclTestCase ( IntegrationTest ) : [EOL] name_of_testcase = [string] [EOL] requirements = [ [string] ] [EOL] external_dependencies = [ [string] ] [EOL] explicit_build_directory = True [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $builtins.bool$ 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
from setuptools import setup [EOL] [EOL] setup ( ) [EOL]	0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import builtins [EOL] import os [EOL] import shlex [EOL] import shutil [EOL] import sys [EOL] import tempfile [EOL] [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . nix import Nix [EOL] from pypi2nix . requirement_parser import ParsingFailed [EOL] from pypi2nix . requirement_parser import RequirementParser [EOL] from repository import ROOT [EOL] [EOL] HERE = os . path . abspath ( os . path . dirname ( __file__ ) ) [EOL] DERIVATION_PATH = os . path . join ( HERE , [string] ) [EOL] [EOL] [EOL] def build_wheel ( target_directory , requirement ) : [EOL] logger = StreamLogger ( sys . stdout ) [EOL] requirement_parser = RequirementParser ( logger = logger ) [EOL] package_directory = os . path . join ( ROOT , [string] , [string] ) [EOL] escaped_requirement = shlex . quote ( requirement ) [EOL] target_directory = os . path . abspath ( target_directory ) [EOL] with tempfile . TemporaryDirectory ( ) as build_directory : [EOL] os . chdir ( build_directory ) [EOL] nix = Nix ( logger = logger ) [EOL] nix . shell ( command = f" [string] { escaped_requirement } [string] { package_directory } [string] " , derivation_path = DERIVATION_PATH , nix_arguments = dict ( ) , ) [EOL] try : [EOL] parsed_requirement = requirement_parser . parse ( requirement ) [EOL] except ParsingFailed : [EOL] for path in os . listdir ( [string] ) : [EOL] if path . endswith ( [string] ) : [EOL] wheel_path = path [EOL] break [EOL] else : [EOL] raise Exception ( [string] ) [EOL] else : [EOL] for path in os . listdir ( [string] ) : [EOL] if path . endswith ( [string] ) and parsed_requirement . name ( ) in path : [EOL] wheel_path = path [EOL] break [EOL] else : [EOL] raise Exception ( [string] ) [EOL] [EOL] target_file_name = os . path . basename ( wheel_path ) [EOL] target_path = os . path . join ( target_directory , target_file_name ) [EOL] shutil . move ( wheel_path , target_path ) [EOL] return target_file_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import os [EOL] import os . path [EOL] import shutil [EOL] import subprocess [EOL] [EOL] from pypi2nix . version import pypi2nix_version [EOL] [EOL] [EOL] def main ( ) : [EOL] set_up_environment ( ) [EOL] create_virtual_env ( ) [EOL] create_sdist ( ) [EOL] install_sdist ( ) [EOL] run_help_command ( ) [EOL] create_virtual_env ( ) [EOL] create_wheel ( ) [EOL] install_wheel ( ) [EOL] run_help_command ( ) [EOL] [EOL] [EOL] def set_up_environment ( ) : [EOL] os . putenv ( [string] , [string] ) [EOL] os . unsetenv ( [string] ) [EOL] [EOL] [EOL] def create_sdist ( ) : [EOL] shutil . rmtree ( os . path . join ( [string] , [string] ) , ignore_errors = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] def create_virtual_env ( ) : [EOL] os . makedirs ( [string] , exist_ok = True ) [EOL] try : [EOL] shutil . rmtree ( [string] ) [EOL] except FileNotFoundError : [EOL] pass [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] def create_wheel ( ) : [EOL] shutil . rmtree ( os . path . join ( [string] , [string] ) , ignore_errors = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , [string] ] , check = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] def install_sdist ( ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , f" [string] { pypi2nix_version } [string] " , ] , check = True , ) [EOL] [EOL] [EOL] def install_wheel ( ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , f" [string] { pypi2nix_version } [string] " , ] , check = True , ) [EOL] [EOL] [EOL] def run_help_command ( ) : [EOL] subprocess . run ( [ [string] , [string] ] , check = True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import pathlib [EOL] from pathlib import Path [EOL] [EOL] [EOL] def find_root ( start = Path ( [string] ) ) : [EOL] absolute_location = start . resolve ( ) [EOL] if ( absolute_location / [string] ) . is_dir ( ) : [EOL] return absolute_location [EOL] else : [EOL] return find_root ( absolute_location / [string] ) [EOL] [EOL] [EOL] ROOT = find_root ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0
[comment] [EOL] [EOL] from typing import List [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] import subprocess [EOL] import os [EOL] import os . path [EOL] import subprocess [EOL] import sys [EOL] from typing import List [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . logger import StreamLogger [EOL] from repository import ROOT [EOL] [EOL] [EOL] class CodeFormatter : [EOL] def __init__ ( self ) : [EOL] self . _logger = initialize_logger ( ) [EOL] [EOL] def main ( self ) : [EOL] relative_paths = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] self . format_nix_files ( ) [EOL] absolute_paths = [ os . path . join ( ROOT , relative ) for relative in relative_paths ] [EOL] self . _logger . info ( [string] ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] , check = True ) [EOL] self . _logger . info ( [string] ) [EOL] subprocess . run ( [ [string] ] + absolute_paths , check = True ) [EOL] self . run_check_process ( [string] ) [EOL] self . run_check_process ( [string] ) [EOL] [EOL] def run_check_process ( self , executable , arguments = [ ] ) : [EOL] self . _logger . info ( f" [string] { executable }" ) [EOL] try : [EOL] subprocess . run ( [ executable ] + arguments , check = True ) [EOL] except subprocess . CalledProcessError : [EOL] self . _logger . error ( f"{ executable } [string] " ) [EOL] exit ( [number] ) [EOL] [EOL] def format_nix_files ( self ) : [EOL] if is_nixfmt_installed ( ) : [EOL] self . _logger . info ( [string] ) [EOL] integration_test_nix_files = find_nix_files_in_integration_tests ( ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] + integration_test_nix_files , check = True , ) [EOL] else : [EOL] self . _logger . warning ( [string] ) [EOL] [EOL] [EOL] def find_nix_files_in_integration_tests ( ) : [EOL] found_files = [ ] [EOL] for root , _ , files in os . walk ( [string] ) : [EOL] found_files += [ os . path . join ( root , file ) for file in files if file . endswith ( [string] ) ] [EOL] return found_files [EOL] [EOL] [EOL] def initialize_logger ( ) : [EOL] return StreamLogger ( output = sys . stdout ) [EOL] [EOL] [EOL] def is_nixfmt_installed ( ) : [EOL] process_result = subprocess . run ( [string] , shell = True , capture_output = True ) [EOL] return process_result . returncode == [number] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] CodeFormatter ( ) . main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pypi2nix.logger.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Optional , Any , Dict [EOL] import typing [EOL] import builtins [EOL] import pypi2nix [EOL] from typing import Optional [EOL] [EOL] from pypi2nix . logger import Logger [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . utils import prefetch_git [EOL] from pypi2nix . wheels import Index [EOL] [EOL] [EOL] class PackageSource : [EOL] def __init__ ( self , index , pypi , logger ) : [EOL] self . index = index [EOL] self . pypi = pypi [EOL] self . logger = logger [EOL] [EOL] def update_package_from_master ( self , package_name ) : [EOL] url = self . _get_url_for_package ( package_name ) [EOL] if url is None : [EOL] self . _log_no_update_warning ( package_name ) [EOL] return [EOL] repo_data = prefetch_git ( url ) [EOL] self . index [ package_name ] = Index . GitEntry ( url = repo_data [ [string] ] , rev = repo_data [ [string] ] , sha256 = repo_data [ [string] ] , ) [EOL] self . _log_update_success ( package_name ) [EOL] [EOL] def update_package_from_pip ( self , package_name ) : [EOL] package = self . pypi . get_package ( package_name ) [EOL] source_release = self . pypi . get_source_release ( name = package_name , version = package . version ) [EOL] if source_release is None : [EOL] self . _log_no_update_warning ( package_name ) [EOL] return [EOL] self . index [ package_name ] = Index . UrlEntry ( url = source_release . url , sha256 = source_release . sha256_digest ) [EOL] self . _log_update_success ( package_name ) [EOL] [EOL] def _get_url_for_package ( self , package_name ) : [EOL] return SOURCE_BY_PACKAGE_NAME . get ( package_name ) [EOL] [EOL] def _log_no_update_warning ( self , package_name ) : [EOL] self . logger . warning ( f" [string] { package_name } [string] " ) [EOL] [EOL] def _log_update_success ( self , package_name ) : [EOL] self . logger . info ( f" [string] { package_name } [string] " ) [EOL] [EOL] [EOL] SOURCE_BY_PACKAGE_NAME = { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] from typing import Any , List [EOL] import typing [EOL] import builtins [EOL] import sys [EOL] from typing import List [EOL] [EOL] from package_source import PackageSource [EOL] from pypi2nix . logger import StreamLogger [EOL] from pypi2nix . pypi import Pypi [EOL] from pypi2nix . wheels import Index [EOL] [EOL] [EOL] def main ( ) : [EOL] logger = StreamLogger ( sys . stdout ) [EOL] pypi = Pypi ( logger = logger ) [EOL] pip_requirements = [ [string] , [string] , [string] ] [EOL] git_requirements = [ ] [EOL] index = Index ( logger = logger ) [EOL] package_source = PackageSource ( index = index , pypi = pypi , logger = logger ) [EOL] for requirement in pip_requirements : [EOL] package_source . update_package_from_pip ( requirement ) [EOL] for requirement in git_requirements : [EOL] package_source . update_package_from_master ( requirement ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] [docstring] [EOL] [EOL] import os [EOL] import os . path [EOL] import shutil [EOL] import subprocess [EOL] [EOL] from build_wheel import build_wheel [EOL] from repository import ROOT [EOL] [EOL] wheel_target_directory = os . path . join ( ROOT , [string] , [string] ) [EOL] TEST_PACKAGES = [ [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def build_test_package ( package_name ) : [EOL] package_name_with_underscores = package_name . replace ( [string] , [string] ) [EOL] package_dir = os . path . join ( ROOT , [string] , [string] , package_name ) [EOL] paths_to_delete = [ f"{ package_name_with_underscores } [string] " , [string] , f"{ package_name } [string] " , ] [EOL] for path in paths_to_delete : [EOL] shutil . rmtree ( os . path . join ( package_dir , [string] ) , ignore_errors = True ) [EOL] subprocess . run ( [ [string] , [string] , [string] ] , cwd = package_dir , check = True ) [EOL] shutil . copy ( os . path . join ( package_dir , [string] , f"{ package_name } [string] " ) , wheel_target_directory , ) [EOL] shutil . move ( os . path . join ( package_dir , [string] , f"{ package_name } [string] " ) , os . path . join ( package_dir , f"{ package_name } [string] " ) , ) [EOL] build_wheel ( wheel_target_directory , package_dir ) [EOL] [EOL] [EOL] def download_flit_wheel ( ) : [EOL] build_wheel ( wheel_target_directory , [string] ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] for test_package in TEST_PACKAGES : [EOL] build_test_package ( test_package ) [EOL] download_flit_wheel ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Generator , List [EOL] import typing [EOL] import argparse [EOL] import builtins [EOL] import argparse [EOL] import os [EOL] import shlex [EOL] import subprocess [EOL] [EOL] from repository import ROOT [EOL] [EOL] [EOL] def generator ( iterable ) : [EOL] yield from iterable [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( ) [EOL] parser . add_argument ( [string] , default = None ) [EOL] args = parser . parse_args ( ) [EOL] return args . file [EOL] [EOL] [EOL] def run_tests_from_file ( path ) : [EOL] command = [ [string] , [string] , [string] , path , [string] , [string] ] [EOL] print ( [string] , [string] . join ( map ( shlex . quote , command ) ) ) [EOL] subprocess . run ( command , check = True ) [EOL] [EOL] [EOL] def main ( ) : [EOL] file = parse_args ( ) [EOL] if file : [EOL] files = generator ( [ file ] ) [EOL] else : [EOL] files = ( os . path . join ( ROOT , [string] , name ) for name in os . listdir ( os . path . join ( ROOT , [string] ) ) if name . startswith ( [string] ) and name . endswith ( [string] ) ) [EOL] for path in files : [EOL] run_tests_from_file ( path ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , List [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] import os [EOL] import shutil [EOL] import subprocess [EOL] [EOL] from pypi2nix . version import pypi2nix_version [EOL] [EOL] [EOL] def main ( ) : [EOL] set_up_environment ( ) [EOL] args = parse_args ( ) [EOL] pypi_name = get_pypi_name_from_args ( args ) [EOL] remove_old_build_artifacts ( ) [EOL] deploy_to ( pypi_name ) [EOL] [EOL] [EOL] def set_up_environment ( ) : [EOL] os . putenv ( [string] , [string] ) [EOL] [EOL] [EOL] def parse_args ( ) : [EOL] parser = argparse . ArgumentParser ( description = [string] ) [EOL] parser . add_argument ( [string] , action = [string] , default = False ) [EOL] return parser . parse_args ( ) [EOL] [EOL] [EOL] def get_pypi_name_from_args ( args ) : [EOL] return [string] if args . production else [string] [EOL] [EOL] [EOL] def remove_old_build_artifacts ( ) : [EOL] shutil . rmtree ( [string] , ignore_errors = True ) [EOL] [EOL] [EOL] def deploy_to ( pypi_name ) : [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] ] , check = True ) [EOL] distribution_paths = [ f" [string] { pypi2nix_version } [string] " , f" [string] { pypi2nix_version } [string] " , ] [EOL] subprocess . run ( [ [string] , [string] , [string] , pypi_name ] + distribution_paths , check = True ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] from typing import Any [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] import subprocess [EOL] [EOL] from repository import ROOT [EOL] [EOL] [EOL] def main ( ) : [EOL] arguments = parse_arguments ( ) [EOL] subprocess . run ( [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] + ( [ [string] ] if arguments . verbose else [ ] ) , cwd = ROOT , check = True , ) [EOL] [EOL] [EOL] def parse_arguments ( ) : [EOL] argument_parser = argparse . ArgumentParser ( description = [string] ) [EOL] argument_parser . add_argument ( [string] , [string] , help = [string] , default = False , action = [string] , ) [EOL] args = argument_parser . parse_args ( ) [EOL] return args [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0