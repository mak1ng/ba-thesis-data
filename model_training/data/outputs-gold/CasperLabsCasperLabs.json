from typing import Any [EOL] import typing [EOL] import argparse [EOL] import argparse [EOL] import logging [EOL] import random [EOL] import jsonpickle [EOL] from dramatiq import actor [EOL] from erc20 import ERC20 , Node , DeployedERC20 [EOL] from config import Configuration [EOL] [EOL] [EOL] @ actor def transfer_tokens ( pickled_erc20_deployer , token_name , node_host , node_port , pickled_sender , pickled_recipient , amount , wait_for_processed = False , ) : [EOL] try : [EOL] erc20_deployer = jsonpickle . decode ( pickled_erc20_deployer ) [EOL] node = Node ( node_host , node_port ) [EOL] sender = jsonpickle . decode ( pickled_sender ) [EOL] recipient = jsonpickle . decode ( pickled_recipient ) [EOL] [EOL] deployed_erc20 = DeployedERC20 . create ( erc20_deployer . on ( node ) , token_name ) [EOL] [EOL] sender . on ( node ) . call_contract ( deployed_erc20 . transfer ( sender_private_key = sender . private_key , recipient_public_key_hex = recipient . public_key_hex , amount = amount , ) , wait_for_processed = wait_for_processed , ) [EOL] except Exception as e : [EOL] logging . error ( f" [string] { sender . public_key_hex } [string] { recipient . public_key_hex } [string] { amount } [string] { str ( e ) }" ) [EOL] [EOL] [EOL] def initialize_erc20_simulation ( node , deployer , agents , token_name , total_token_supply , initial_agent_clx_funds , tokens_per_agent , ) : [EOL] [docstring] [EOL] bound_deployer = deployer . on ( node ) [EOL] bound_deployer . call_contract ( ERC20 ( token_name ) . deploy ( initial_balance = total_token_supply ) ) [EOL] abc = DeployedERC20 . create ( bound_deployer , token_name ) [EOL] [EOL] balance = bound_deployer . query ( abc . balance ( deployer . public_key_hex ) ) [EOL] [EOL] [comment] [EOL] assert balance == total_token_supply [EOL] [EOL] for agent in agents : [EOL] bound_deployer . transfer_clx ( agent . public_key_hex , initial_agent_clx_funds ) [EOL] [EOL] [comment] [EOL] for agent in agents : [EOL] bound_deployer . call_contract ( abc . transfer ( sender_private_key = deployer . private_key , recipient_public_key_hex = agent . public_key_hex , amount = tokens_per_agent , ) ) [EOL] balance = bound_deployer . query ( abc . balance ( agent . public_key_hex ) ) [EOL] assert balance == tokens_per_agent [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] parser = argparse . ArgumentParser ( [string] ) [EOL] parser . add_argument ( [string] , choices = ( [string] , [string] ) ) [EOL] parser . add_argument ( [string] , required = False , default = None ) [EOL] args = parser . parse_args ( ) [EOL] [EOL] if args . configuration : [EOL] print ( f" [string] { args . configuration }" ) [EOL] cfg = Configuration . read ( args . configuration ) [EOL] else : [EOL] cfg = Configuration . default ( ) [EOL] [EOL] if args . command == [string] : [EOL] initialize_erc20_simulation ( cfg . nodes [ [number] ] , cfg . erc20_deployer , cfg . agents , cfg . token_name , cfg . total_token_supply , cfg . initial_agent_clx_funds , cfg . tokens_per_agent , ) [EOL] [EOL] erc20_deployer = cfg . erc20_deployer [EOL] agents = cfg . agents [EOL] nodes = cfg . nodes [EOL] [EOL] if args . command == [string] : [EOL] for _ in range ( [number] ) : [EOL] sender , recipient = random . sample ( agents , [number] ) [EOL] node = random . sample ( nodes , [number] ) [ [number] ] [EOL] amount = random . randint ( [number] , cfg . max_transfer ) [EOL] [EOL] transfer_tokens ( jsonpickle . encode ( erc20_deployer ) , cfg . token_name , node . host , node . port , jsonpickle . encode ( sender ) , jsonpickle . encode ( recipient ) , amount , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0
from typing import Any , List [EOL] import typing [EOL] import pytest [EOL] from erc20 import Node , Agent [EOL] from simulate_erc20 import run_erc20_simulation [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] TOKEN_NAME = [string] [EOL] TOTAL_TOKEN_SUPPLY = [number] [EOL] INITIAL_AGENT_CLX_FUNDS = [number] ** [number] [EOL] [EOL] [EOL] @ pytest . fixture ( ) def node ( ) : [EOL] return Node ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def faucet ( ) : [EOL] return Agent ( [string] ) [EOL] [EOL] [EOL] @ pytest . fixture ( ) def agents ( faucet , node ) : [EOL] agents = [ Agent ( [string] ) , Agent ( [string] ) , Agent ( [string] ) ] [EOL] return agents [EOL] [EOL] [EOL] def test_erc20 ( node , faucet , agents ) : [EOL] run_erc20_simulation ( [ node ] , faucet , agents , TOKEN_NAME , TOTAL_TOKEN_SUPPLY , INITIAL_AGENT_CLX_FUNDS , [number] , [number] , [number] , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] from google . protobuf . json_format import MessageToDict [EOL] from dramatiq import actor [EOL] from erc20 import Node [EOL] import base64 [EOL] [EOL] NODE = Node ( [string] ) [EOL] [EOL] [EOL] def b64_to_hex ( s ) : [EOL] return base64 . b64decode ( s ) . hex ( ) [EOL] [EOL] [EOL] @ actor def new_deploy_processed ( deploy_info ) : [EOL] deploy_hash = b64_to_hex ( deploy_info [ [string] ] [ [string] ] ) [EOL] print ( f" [string] { deploy_hash }" ) [EOL] [EOL] [EOL] @ actor def new_block ( block_info ) : [EOL] block_hash = b64_to_hex ( block_info [ [string] ] [ [string] ] ) [EOL] print ( f" [string] { block_hash }" ) [EOL] for deploy_info in NODE . client . showDeploys ( block_hash ) : [EOL] new_deploy_processed ( MessageToDict ( deploy_info ) ) [EOL] [EOL] [EOL] def poll_new_blocks ( ) : [EOL] for event in NODE . client . stream_events ( ) : [EOL] if event . HasField ( [string] ) : [EOL] block_info = event . block_added . block [EOL] new_block ( MessageToDict ( block_info ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] poll_new_blocks ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import json [EOL] from erc20 import Agent , Node [EOL] import casperlabs_client [EOL] [EOL] DEFAULT_CONFIG = [string] [EOL] [EOL] [EOL] class Configuration : [EOL] def __init__ ( self , dictionary ) : [EOL] self . dictionary = dictionary [EOL] [EOL] @ property def erc20_deployer ( self ) : [EOL] deployer = self . dictionary [ [string] ] [EOL] return Agent ( deployer ) [EOL] [EOL] @ property def agents ( self ) : [EOL] return [ Agent ( d ) for d in self . dictionary [ [string] ] ] [EOL] [EOL] @ property def nodes ( self ) : [EOL] def make_node ( node_config ) : [EOL] host = [string] [EOL] port = casperlabs_client . DEFAULT_PORT [EOL] if type ( node_config ) == str : [EOL] host = node_config [EOL] else : [EOL] host = node_config . get ( [string] , host ) [EOL] port = node_config . get ( [string] , port ) [EOL] return Node ( host , port ) [EOL] [EOL] return [ make_node ( cfg ) for cfg in self . dictionary [ [string] ] ] [EOL] [EOL] def __getattr__ ( self , name ) : [EOL] return self . dictionary [ name ] [EOL] [EOL] @ staticmethod def default ( ) : [EOL] return Configuration ( json . loads ( DEFAULT_CONFIG ) ) [EOL] [EOL] @ staticmethod def read ( file_name ) : [EOL] with open ( file_name ) as f : [EOL] d = Configuration . default ( ) . dictionary [EOL] d . update ( json . load ( f ) ) [EOL] return Configuration ( d ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import builtins [EOL] import pathlib [EOL] import string [EOL] import random [EOL] [EOL] SELENIUM_COMMAND_EXECUTOR_URL = [string] [EOL] CLARITY_URL = [string] [EOL] [EOL] import os [EOL] from pathlib import Path [EOL] [EOL] THIS_DIRECTORY = Path ( os . path . dirname ( os . path . realpath ( __file__ ) ) ) [EOL] CASPERLABS_ROOT_DIRECTORY = THIS_DIRECTORY . parent . parent . parent [EOL] [EOL] HACK_DOCKER_DIRECTORY = CASPERLABS_ROOT_DIRECTORY / [string] / [string] [EOL] KEYS_DIRECTORY = HACK_DOCKER_DIRECTORY / [string] [EOL] FAUCET_HASH_PATH = KEYS_DIRECTORY / [string] / [string] [EOL] [EOL] [EOL] def random_string ( length ) : [EOL] return [string] . join ( random . choice ( string . ascii_lowercase ) for _ in range ( length ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 $pathlib.Path$ 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import Any , Dict [EOL] import test [EOL] import explorer [EOL] import typing [EOL] from typing import Any [EOL] [EOL] import pytest [EOL] from dataclasses import dataclass [EOL] [EOL] from selenium import webdriver [EOL] from selenium . webdriver . chrome . options import Options [EOL] from selenium . webdriver . common . desired_capabilities import DesiredCapabilities [EOL] [EOL] from . common import SELENIUM_COMMAND_EXECUTOR_URL , CLARITY_URL , FAUCET_HASH_PATH [EOL] [EOL] [EOL] @ dataclass class ClarityConfig : [EOL] url = ... [EOL] selenium_driver = ... [EOL] [EOL] [EOL] @ pytest . fixture ( [string] ) def clarity_config ( ) : [EOL] command_executor = SELENIUM_COMMAND_EXECUTOR_URL [EOL] chrome_options = Options ( ) [EOL] prefs = { [string] : [number] } [EOL] chrome_options . add_experimental_option ( [string] , prefs ) [EOL] selenium_driver = webdriver . Remote ( command_executor = command_executor , desired_capabilities = DesiredCapabilities . CHROME , options = chrome_options ) [EOL] selenium_driver . implicitly_wait ( [number] ) [EOL] config = ClarityConfig ( CLARITY_URL , selenium_driver ) [EOL] [EOL] [comment] [EOL] selenium_driver . get ( config . url ) [EOL] assert selenium_driver . title == [string] [EOL] [EOL] return config [EOL] [EOL] [EOL] @ pytest . fixture ( [string] ) def faucet_public_key_hash ( ) : [EOL] with open ( FAUCET_HASH_PATH , [string] ) as f : [EOL] faucet_hash = f . read ( ) . strip ( ) [EOL] return faucet_hash . decode ( [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import time [EOL] [EOL] from selenium . webdriver . common . by import By [EOL] from selenium . webdriver . support . select import Select [EOL] from selenium . webdriver . support . wait import WebDriverWait [EOL] [EOL] from . common import random_string [EOL] [EOL] REQUEST_TOKEN_WAIT = [number] [EOL] [EOL] [EOL] def test_create_account_key ( clarity_config , faucet_public_key_hash ) : [EOL] [docstring] [EOL] clarity_host = clarity_config . url [EOL] driver = clarity_config . selenium_driver [EOL] driver . get ( clarity_host ) [EOL] driver . set_window_size ( [number] , [number] ) [EOL] [EOL] [comment] [EOL] sign_in_button = driver . find_element ( By . LINK_TEXT , [string] ) [EOL] sign_in_button . click ( ) [EOL] [EOL] [comment] [EOL] account_name = create_account ( driver ) [EOL] another_account_name = create_account ( driver ) [EOL] [EOL] request_token ( driver , account_name ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] trs = find_deploys ( driver , faucet_public_key_hash ) [EOL] assert ( len ( trs ) == [number] ) [EOL] [EOL] [comment] [EOL] request_token ( driver , another_account_name ) [EOL] trs = find_deploys ( driver , faucet_public_key_hash ) [EOL] assert ( len ( trs ) == [number] ) [EOL] [EOL] remove_account ( driver , account_name ) [EOL] remove_account ( driver , another_account_name ) [EOL] [EOL] [EOL] def remove_account ( driver , account_name ) : [EOL] [docstring] [EOL] driver . find_element ( By . LINK_TEXT , [string] ) . click ( ) [EOL] [comment] [EOL] remove_button = driver . find_element ( By . XPATH , f" [string] { account_name } [string] " ) [EOL] remove_button . click ( ) [EOL] driver . switch_to . alert . accept ( ) [EOL] [comment] [EOL] assert ( len ( driver . find_elements ( By . XPATH , f" [string] { account_name } [string] " ) ) == [number] ) [EOL] [EOL] [EOL] def find_deploys ( driver , public_key ) : [EOL] [docstring] [EOL] driver . find_element ( By . LINK_TEXT , [string] ) . click ( ) [EOL] driver . find_element ( By . CSS_SELECTOR , [string] ) . click ( ) [EOL] driver . find_element ( By . CSS_SELECTOR , [string] ) . send_keys ( public_key ) [EOL] driver . find_element ( By . CSS_SELECTOR , [string] ) . click ( ) [EOL] return driver . find_elements ( By . CSS_SELECTOR , [string] ) [EOL] [EOL] [EOL] def request_token ( driver , account_name ) : [EOL] [docstring] [EOL] driver . find_element ( By . LINK_TEXT , [string] ) . click ( ) [EOL] select = Select ( driver . find_element ( By . ID , [string] ) ) [EOL] select . select_by_visible_text ( account_name ) [EOL] driver . find_element ( By . XPATH , [string] ) . click ( ) [EOL] time . sleep ( [number] ) [EOL] WebDriverWait ( driver , REQUEST_TOKEN_WAIT ) . until_not ( lambda d : d . find_element ( By . CSS_SELECTOR , [string] ) . get_attribute ( [string] ) . startswith ( [string] ) ) [EOL] title = driver . find_element ( By . CSS_SELECTOR , [string] ) . get_attribute ( [string] ) [EOL] assert title . startswith ( [string] ) [EOL] [EOL] [comment] [EOL] driver . find_element ( By . LINK_TEXT , [string] ) . click ( ) [EOL] xpath_correct_balance = f" [string] { account_name } [string] " [EOL] assert len ( driver . find_elements ( By . XPATH , xpath_correct_balance ) ) == [number] [EOL] [EOL] [EOL] def create_account ( driver ) : [EOL] [docstring] [EOL] driver . find_element ( By . LINK_TEXT , [string] ) . click ( ) [EOL] driver . find_element ( By . XPATH , [string] ) . click ( ) [EOL] account_name = random_string ( [number] ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] account_name_input = driver . find_element ( By . ID , [string] ) [EOL] account_name_input . click ( ) [EOL] account_name_input . send_keys ( account_name ) [EOL] driver . find_element ( By . XPATH , [string] ) . click ( ) [EOL] [comment] [EOL] time . sleep ( [number] ) [EOL] assert ( len ( driver . find_elements ( By . XPATH , f" [string] { account_name } [string] " ) ) == [number] ) [EOL] return account_name [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0