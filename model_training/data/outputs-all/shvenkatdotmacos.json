from typing import List , Any [EOL] import typing [EOL] import configparser [EOL] import pathlib [EOL] import builtins [EOL] from configparser import ConfigParser [EOL] from pathlib import Path [EOL] import re [EOL] from setuptools import setup [EOL] from typing import List [EOL] [EOL] [EOL] PROJECT_NAME = [string] [EOL] [EOL] [EOL] def get_version ( ) : [EOL] info_path = Path ( __file__ ) . parent / PROJECT_NAME / [string] [EOL] with open ( info_path , [string] ) as info_handle : [EOL] info = info_handle . read ( ) [EOL] try : [EOL] version = ( re . search ( [string] , info , re . MULTILINE ) . group ( [number] ) ) [EOL] except Exception as e : [EOL] raise RuntimeError ( [string] . format ( path = info_path . as_posix ( ) ) ) [EOL] return version [EOL] [EOL] [EOL] def get_required_packages_from_pipfile ( ) : [EOL] [docstring] [EOL] pipfile_path = Path ( __file__ ) . parent / [string] [EOL] if not pipfile_path . exists ( ) : [EOL] return [ ] [EOL] config = ConfigParser ( ) [EOL] config . read ( pipfile_path . as_posix ( ) ) [EOL] return [ k if v . strip ( [string] ) == [string] else k + v . strip ( [string] ) for k , v in config . items ( [string] ) ] [EOL] [EOL] [EOL] setup ( name = PROJECT_NAME , version = get_version ( ) , description = [string] , packages = [ PROJECT_NAME ] , py_modules = [ ] , package_data = { [string] : [ [string] ] } , include_package_data = True , install_requires = get_required_packages_from_pipfile ( ) , entry_points = [string] . format ( name = PROJECT_NAME ) , ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import List , Optional , Tuple , Set , FrozenSet , Dict , Container , Any , Type [EOL] import dotmacos [EOL] import pathlib [EOL] import builtins [EOL] import typing [EOL] import subprocess [EOL] import enum [EOL] import datetime [EOL] import numbers [EOL] import os [EOL] from pathlib import Path [EOL] import plistlib [EOL] from pprint import pformat [EOL] import subprocess [EOL] import tempfile [EOL] from typing import ( Any , ByteString , cast , Container , Dict , FrozenSet , Optional , Sequence ) [EOL] import xml . parsers . expat as expat [EOL] [EOL] import pyjson5 [EOL] [EOL] [EOL] class FileFormat ( enum . Enum ) : [EOL] json5 = enum . auto ( ) [EOL] json = enum . auto ( ) [EOL] yaml = enum . auto ( ) [EOL] [EOL] [EOL] IS_ROOT_USER = os . geteuid ( ) == [number] [EOL] ALL_SECTIONS = frozenset ( [ [string] , [string] , [string] ] ) [EOL] ACCESSIBLE_SECTIONS = frozenset ( [ [string] ] if IS_ROOT_USER else [ [string] , [string] ] ) [EOL] [EOL] [EOL] class Prefs ( Dict ) : [EOL] [EOL] def __new__ ( cls , mapping ) : [EOL] [comment] [EOL] if not isinstance ( mapping , dict ) : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] if not all ( isinstance ( key , str ) for key in mapping ) : [EOL] raise ValueError ( [string] . format ( [string] . join ( key for key in mapping if not isinstance ( key , str ) ) ) ) [EOL] [comment] [EOL] if not all ( cls . _is_valid_value ( value ) for value in mapping . values ( ) ) : [EOL] raise ValueError ( [string] . format ( [string] . join ( pformat ( value ) for value in mapping . values ( ) if not cls . _is_valid_value ( value ) ) ) ) [EOL] self = dict . __new__ ( cls , mapping ) [EOL] return cast ( Prefs , self ) [EOL] [EOL] @ staticmethod def merge ( * , old , new ) : [EOL] [docstring] [EOL] result = dict ( old ) [EOL] for new_key , new_value in new . items ( ) : [EOL] if ( new_key in old and isinstance ( new_value , dict ) and isinstance ( old [ new_key ] , dict ) ) : [EOL] [comment] [EOL] result [ new_key ] = dict ( old [ new_key ] ) [EOL] result [ new_key ] . update ( new_value ) [EOL] else : [EOL] [comment] [EOL] result [ new_key ] = new_value [EOL] return Prefs ( result ) [EOL] [EOL] @ staticmethod def diff_types ( * , old , new ) : [EOL] shared_keys = set ( new . keys ( ) ) . intersection ( set ( old . keys ( ) ) ) [EOL] diff_types = [ ( key , type ( old [ key ] ) , type ( new [ key ] ) ) for key in shared_keys if not isinstance ( new [ key ] , type ( old [ key ] ) ) ] [EOL] return [string] . join ( [ [string] . format ( key = key , old = str ( old_type ) , new = str ( new_type ) ) for key , old_type , new_type in diff_types ] ) [EOL] [EOL] @ staticmethod def diff ( * , old , new ) : [EOL] adds = [ [string] . format ( key = key , value = value ) for key , value in new . items ( ) if key not in old ] [EOL] modifs = [ ( [string] . format ( key = key , old = str ( old [ key ] ) , new = value ) [EOL] if isinstance ( value , type ( old [ key ] ) ) else [EOL] [string] . format ( key = key , old = str ( old [ key ] ) , new = value , old_type = type ( old [ key ] ) . __name__ , new_type = type ( value ) . __name__ ) ) for key , value in new . items ( ) if key in old and value != old [ key ] ] [EOL] return [string] . join ( adds + modifs ) [EOL] [EOL] @ classmethod def from_os ( cls , * , section , domain , keys = None ) : [EOL] if not cls . _is_accessible ( section ) : [EOL] raise Exception ( [string] . format ( section = section , uid = os . geteuid ( ) ) ) [EOL] plist_fd , plist_name = tempfile . mkstemp ( suffix = [string] ) [EOL] cmd = ( [ [string] ] + ( [ [string] ] if section == [string] else [ ] ) + [ [string] , domain , plist_name ] ) [EOL] export_proc = subprocess . run ( cmd , stdin = subprocess . DEVNULL , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] if export_proc . returncode != [number] or len ( export_proc . stderr ) > [number] : [EOL] raise OSError ( [string] [string] [string] . format ( section = section , domain = domain , cmd = [string] . join ( cmd ) , status = export_proc . returncode , stdout = export_proc . stdout . decode ( ) , stderr = export_proc . stderr . decode ( ) ) ) [EOL] try : [EOL] with open ( plist_name , [string] ) as plist_file : [EOL] keyvalue = plistlib . load ( plist_file , use_builtin_types = True ) [EOL] except FileNotFoundError : [EOL] raise Exception ( [string] ) [EOL] except ( plistlib . InvalidFileException , expat . ExpatError ) as e : [EOL] raise Exception ( [string] ) [EOL] os . close ( plist_fd ) [EOL] os . remove ( plist_name ) [EOL] if keys is None : [EOL] prefs = Prefs ( keyvalue ) [EOL] else : [EOL] prefs = Prefs ( { key : value for key , value in keyvalue . items ( ) if key in keys } ) [EOL] return prefs [EOL] [EOL] def to_os ( self , * , section , domain ) : [EOL] if not self . _is_accessible ( section ) : [EOL] raise Exception ( [string] . format ( section = section , uid = os . geteuid ( ) ) ) [EOL] with tempfile . NamedTemporaryFile ( [string] , suffix = [string] ) as plist_file : [EOL] try : [EOL] plistlib . dump ( self , plist_file , fmt = plistlib . FMT_BINARY ) [EOL] except ( FileNotFoundError , PermissionError , TypeError , OverflowError ) as e : [EOL] raise Exception ( [string] + str ( e ) ) [EOL] plist_file . flush ( ) [EOL] os . sync ( ) [EOL] cmd = ( [ [string] ] + ( [ [string] ] if section == [string] else [ ] ) + [ [string] , domain , plist_file . name ] ) [EOL] import_proc = subprocess . run ( cmd , stdin = subprocess . DEVNULL , stdout = subprocess . PIPE , stderr = subprocess . PIPE ) [EOL] if import_proc . returncode != [number] or len ( import_proc . stderr ) > [number] : [EOL] raise OSError ( [string] [string] [string] . format ( section = section , domain = domain , cmd = [string] . join ( cmd ) , status = import_proc . returncode , stdout = import_proc . stdout , stderr = import_proc . stderr ) ) [EOL] [EOL] @ classmethod def _is_valid_value ( cls , value ) : [EOL] [docstring] [EOL] if isinstance ( value , ( bool , numbers . Real , datetime . datetime , str , ByteString ) ) : [EOL] return True [EOL] elif isinstance ( value , Sequence ) : [EOL] return all ( cls . _is_valid_value ( x ) for x in value ) [EOL] elif isinstance ( value , Dict ) : [EOL] return all ( ( isinstance ( k , str ) and cls . _is_valid_value ( v ) ) for k , v in value . items ( ) ) [EOL] else : [EOL] return False [EOL] [EOL] @ staticmethod def _is_accessible ( section ) : [EOL] return ( ( section in [ [string] , [string] ] and not IS_ROOT_USER ) or ( section in [ [string] ] and IS_ROOT_USER ) ) [EOL] [EOL] [EOL] class Domains ( Dict ) : [EOL] [EOL] def __new__ ( cls , mapping ) : [EOL] [comment] [EOL] if not isinstance ( mapping , dict ) : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] if not all ( isinstance ( key , str ) for key in mapping ) : [EOL] raise ValueError ( [string] . format ( [string] . join ( key for key in mapping if not isinstance ( key , str ) ) ) ) [EOL] [comment] [EOL] self = dict . __new__ ( cls , { domain : Prefs ( prefs ) for domain , prefs in mapping . items ( ) } ) [EOL] return cast ( Domains , self ) [EOL] [EOL] [EOL] class Sections ( Dict ) : [EOL] [EOL] def __new__ ( cls , mapping ) : [EOL] [comment] [EOL] if not isinstance ( mapping , dict ) : [EOL] raise ValueError ( [string] ) [EOL] [comment] [EOL] if not all ( key in ALL_SECTIONS for key in mapping ) : [EOL] raise ValueError ( [string] . format ( [string] . join ( key for key in mapping if key not in ALL_SECTIONS ) ) ) [EOL] [comment] [EOL] self = dict . __new__ ( cls , { section : Domains ( domains ) for section , domains in mapping . items ( ) } ) [EOL] return cast ( Sections , self ) [EOL] [EOL] def diff_with_os ( self , os_is_base , all_keys = False ) : [EOL] [EOL] def diff_domain ( section , domain , prefs ) : [EOL] if os_is_base : [EOL] diff = Prefs . diff ( old = Prefs . from_os ( section = section , domain = domain ) , new = prefs ) [EOL] else : [EOL] diff = Prefs . diff ( old = prefs , new = Prefs . from_os ( section = section , domain = domain , keys = None if all_keys else prefs . keys ( ) ) ) [EOL] return ( [string] . format ( domain = domain , diff = [string] + diff . replace ( [string] , [string] ) ) [EOL] if len ( diff ) > [number] else [EOL] [string] ) [EOL] [EOL] def diff_section ( section , domains ) : [EOL] diff = [string] . join ( filter ( lambda e : len ( e ) > [number] , [ diff_domain ( section , domain , prefs ) for domain , prefs in domains . items ( ) ] ) ) [EOL] return ( [string] . format ( section = section , diff = [string] + diff . replace ( [string] , [string] ) ) [EOL] if len ( diff ) > [number] else [EOL] [string] ) [EOL] [EOL] return [string] . join ( filter ( lambda e : len ( e ) > [number] , [ diff_section ( section , domains ) for section , domains in self . items ( ) if section in ACCESSIBLE_SECTIONS ] ) ) [EOL] [EOL] def merge_from_os ( self , all_keys = False ) : [EOL] return Sections ( { section : ( { domain : Prefs . merge ( old = prefs , new = Prefs . from_os ( section = section , domain = domain , keys = None if all_keys else prefs . keys ( ) ) ) for domain , prefs in domains . items ( ) } [EOL] if section in ACCESSIBLE_SECTIONS else [EOL] domains ) for section , domains in self . items ( ) } ) [EOL] [EOL] def merge_to_os ( self ) : [EOL] for section , domains in self . items ( ) : [EOL] if section in ACCESSIBLE_SECTIONS : [EOL] for domain , prefs in domains . items ( ) : [EOL] ( Prefs . merge ( old = Prefs . from_os ( section = section , domain = domain ) , new = prefs ) . to_os ( section = section , domain = domain ) ) [EOL] [EOL] @ classmethod def from_config_file ( cls , path , * , file_format , include_sections = ALL_SECTIONS , ) : [EOL] if file_format == FileFormat . json5 : [EOL] sections = cls . _read_json5 ( path ) [EOL] elif file_format == FileFormat . json : [EOL] sections = cls . _read_json ( path ) [EOL] elif file_format == FileFormat . yaml : [EOL] sections = cls . _read_yaml ( path ) [EOL] else : [EOL] raise ValueError ( [string] . format ( file_format . name ) ) [EOL] return Sections ( { section : value for section , value in sections . items ( ) if section in include_sections } ) [EOL] [EOL] @ classmethod def _read_json5 ( cls , path ) : [EOL] with open ( path . as_posix ( ) , [string] ) as file_handle : [EOL] data = pyjson5 . load ( file_handle ) [EOL] if cls . _is_valid_data ( data ) : [EOL] return cast ( Dict [ str , Any ] , data ) [EOL] else : [EOL] raise ValueError ( [string] . format ( path . as_posix ( ) ) ) [EOL] [EOL] @ classmethod def _read_json ( cls , path ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ classmethod def _read_yaml ( cls , path ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] @ staticmethod def _is_valid_data ( data ) : [EOL] return ( isinstance ( data , dict ) and all ( isinstance ( key , str ) for key in data ) ) [EOL] [EOL] def to_config_file ( self , path , file_format ) : [EOL] if file_format == FileFormat . json5 : [EOL] self . _write_json5 ( path ) [EOL] elif file_format == FileFormat . json : [EOL] self . _write_json ( path ) [EOL] elif file_format == FileFormat . yaml : [EOL] self . _write_yaml ( path ) [EOL] else : [EOL] raise ValueError ( [string] . format ( file_format . name ) ) [EOL] [EOL] def _write_json5 ( self , path ) : [EOL] with open ( path . as_posix ( ) , [string] ) as file_handle : [EOL] pyjson5 . dump ( self , file_handle ) [EOL] [EOL] def _write_json ( self , path ) : [EOL] raise NotImplementedError ( ) [EOL] [EOL] def _write_yaml ( self , path ) : [EOL] raise NotImplementedError ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dotmacos.preflib.Prefs$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $dotmacos.preflib.Prefs$ 0 0 0 0 0 0 $"Prefs"$ 0 0 0 $"Prefs"$ 0 $"Prefs"$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $"Prefs"$ 0 $"Prefs"$ 0 0 0 $typing.Set[typing.Any]$ 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Type[typing.Any],typing.Type[typing.Any]]]$ 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 $typing.Set[typing.Any]$ 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[typing.Any,typing.Type[typing.Any],typing.Type[typing.Any]]]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $"Prefs"$ 0 $"Prefs"$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 $"Prefs"$ 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 $"Prefs"$ 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 $"Prefs"$ 0 0 0 $"Prefs"$ 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $"Prefs"$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Optional[typing.Container[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Container[builtins.str]]$ 0 0 0 0 $dotmacos.preflib.Prefs$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $dotmacos.preflib.Prefs$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Optional[typing.Container[builtins.str]]$ 0 0 0 0 $dotmacos.preflib.Prefs$ 0 0 0 $None$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 $subprocess.CompletedProcess[builtins.bytes]$ 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Domains"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $dotmacos.preflib.Domains$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $dotmacos.preflib.Domains$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Sections"$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 $dotmacos.preflib.Sections$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $dotmacos.preflib.Sections$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.bool$ 0 $builtins.bool$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $Prefs$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $Prefs$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $Prefs$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $Prefs$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $Domains$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $Domains$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Sections"$ 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $"Sections"$ 0 0 0 $pathlib.Path$ 0 0 0 $FileFormat$ 0 $typing.Container[builtins.str]$ 0 0 0 0 0 0 0 $FileFormat$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $FileFormat$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 $FileFormat$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $FileFormat$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Container[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 $typing.Any$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 $FileFormat$ 0 0 0 0 $FileFormat$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $FileFormat$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 $FileFormat$ 0 0 0 0 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 $FileFormat$ 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $pathlib.Path$ 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] __version__ = [string] [EOL] [EOL] from . preflib import FileFormat , Sections [EOL]	0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0