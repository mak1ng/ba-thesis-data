from typing import Dict , List [EOL] import typing [EOL] from setuptools import find_packages , setup [EOL] [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] PACKAGE_DATA = { [string] : [ [string] [string] , [string] ] } [EOL] [EOL] with open ( [string] ) as f : [EOL] README = f . read ( ) [EOL] [EOL] with open ( [string] ) as f : [EOL] INSTALL_REQUIREMENTS = f . read ( ) . splitlines ( ) [EOL] [EOL] setup ( name = [string] , version = Settings . VERSION , python_requires = [string] , description = [string] , long_description = README , author = [string] , author_email = [string] , url = [string] , license = [string] , packages = find_packages ( exclude = ( [string] , [string] ) ) , install_requires = INSTALL_REQUIREMENTS , zip_safe = False , scripts = [ [string] ] , classifiers = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] , package_data = PACKAGE_DATA , include_package_data = True ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0
from typing import Tuple , List [EOL] import builtins [EOL] import multiprocessing [EOL] import fusion_report [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import os [EOL] import tarfile [EOL] import time [EOL] [EOL] from argparse import Namespace [EOL] from multiprocessing import Manager , Pool , Process [EOL] from typing import List [EOL] [EOL] from fusion_report . common . exceptions . download import DownloadException [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . common . net import Net [EOL] from fusion_report . data . fusiongdb import FusionGDB [EOL] from fusion_report . data . mitelman import MitelmanDB [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Sync : [EOL] [EOL] def __init__ ( self , params ) : [EOL] self . cosmic_token = Net . get_cosmic_token ( params ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( params . output ) : [EOL] os . makedirs ( params . output , [number] ) [EOL] [EOL] os . chdir ( params . output ) [EOL] return_err = Manager ( ) . list ( ) [EOL] [EOL] processes = [ Process ( name = Settings . FUSIONGDB [ [string] ] , target = self . get_fusiongdb , args = ( return_err , ) ) , Process ( name = Settings . MITELMAN [ [string] ] , target = self . get_mitelman , args = ( return_err , ) ) , Process ( name = Settings . COSMIC [ [string] ] , target = Net . get_cosmic , args = ( self . cosmic_token , return_err , ) ) ] [EOL] [EOL] for process in processes : [EOL] process . start ( ) [EOL] [EOL] for process in processes : [EOL] process . join ( ) [EOL] [EOL] if len ( return_err ) > [number] : [EOL] raise DownloadException ( return_err ) [EOL] [EOL] time . sleep ( [number] ) [EOL] Logger ( __name__ ) . info ( [string] ) [EOL] Net . clean ( ) [EOL] [EOL] def get_fusiongdb ( self , return_err ) : [EOL] [docstring] [EOL] [EOL] pool_params = [ ( f'{ Settings . FUSIONGDB [ [string] ] } [string] { x }' , True ) for x in Settings . FUSIONGDB [ [string] ] ] [EOL] pool = Pool ( Settings . THREAD_NUM ) [EOL] pool . starmap ( Net . get_large_file , pool_params ) [EOL] pool . close ( ) [EOL] pool . join ( ) [EOL] db = FusionGDB ( [string] ) [EOL] db . setup ( Settings . FUSIONGDB [ [string] ] , delimiter = [string] , skip_header = False ) [EOL] [EOL] def get_mitelman ( self , return_err ) : [EOL] [docstring] [EOL] try : [EOL] url = f'{ Settings . MITELMAN [ [string] ] } [string] { Settings . MITELMAN [ [string] ] }' [EOL] Net . get_large_file ( url ) [EOL] [EOL] with tarfile . open ( Settings . MITELMAN [ [string] ] ) as archive : [EOL] files = archive . getnames ( ) [EOL] archive . extractall ( ) [EOL] [EOL] db = MitelmanDB ( [string] ) [EOL] db . setup ( files , delimiter = [string] , skip_header = True , encoding = [string] ) [EOL] except DownloadException as ex : [EOL] return_err . append ( f' [string] { ex }' ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[multiprocessing.context.Process]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 0 0 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,builtins.bool]]$ 0 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 $multiprocessing.pool.Pool$ 0 0 0 0 0 $fusion_report.data.fusiongdb.FusionGDB$ 0 0 0 0 0 0 $fusion_report.data.fusiongdb.FusionGDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.data.mitelman.MitelmanDB$ 0 0 0 0 0 0 $fusion_report.data.mitelman.MitelmanDB$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import Any , Union , Dict , List [EOL] import builtins [EOL] import _csv [EOL] import fusion_report [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import csv [EOL] import os [EOL] import sys [EOL] import time [EOL] [EOL] from argparse import Namespace [EOL] from collections import defaultdict [EOL] from typing import Any , Dict , List [EOL] [EOL] import rapidjson [EOL] [EOL] from tqdm import tqdm [EOL] [EOL] from fusion_report . args_builder import ArgsBuilder [EOL] from fusion_report . common . exceptions . app import AppException [EOL] from fusion_report . common . exceptions . db import DbException [EOL] from fusion_report . common . exceptions . download import DownloadException [EOL] from fusion_report . common . fusion_manager import FusionManager [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . common . models . fusion import Fusion [EOL] from fusion_report . common . report import Report [EOL] from fusion_report . data . cosmic import CosmicDB [EOL] from fusion_report . data . fusiongdb import FusionGDB [EOL] from fusion_report . data . mitelman import MitelmanDB [EOL] from fusion_report . download import Download [EOL] from fusion_report . settings import Settings [EOL] from fusion_report . sync import Sync [EOL] [EOL] [EOL] class App : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] try : [EOL] self . args = ArgsBuilder ( ) [EOL] self . manager = FusionManager ( self . args . supported_tools ) [EOL] except IOError as ex : [EOL] raise AppException ( ex ) [EOL] [EOL] def build_args ( self ) : [EOL] [docstring] [EOL] self . args . build ( ) [EOL] [EOL] def run ( self ) : [EOL] [docstring] [EOL] params = self . args . parse ( ) [EOL] try : [EOL] if params . command == [string] : [EOL] Logger ( __name__ ) . info ( [string] ) [EOL] self . preprocess ( params ) [EOL] self . generate_report ( params ) [EOL] self . export_results ( params . output , params . export ) [EOL] self . generate_multiqc ( params . output , self . manager . fusions , params . sample , len ( self . manager . running_tools ) ) [EOL] self . generate_fusion_list ( params . output , params . tool_cutoff ) [EOL] elif params . command == [string] : [EOL] Logger ( __name__ ) . info ( [string] ) [EOL] Download ( params ) [EOL] elif params . command == [string] : [EOL] Logger ( __name__ ) . info ( [string] ) [EOL] Sync ( params ) [EOL] else : [EOL] sys . exit ( f' [string] { params . command } [string] ' ) [EOL] except ( AppException , DbException , DownloadException , IOError ) as ex : [EOL] raise AppException ( ex ) [EOL] [EOL] def preprocess ( self , params ) : [EOL] [docstring] [EOL] self . parse_fusion_outputs ( vars ( params ) ) [EOL] self . enrich ( params . db_path ) [EOL] self . score ( vars ( params ) ) [EOL] [EOL] def generate_report ( self , params ) : [EOL] [docstring] [EOL] report = Report ( params . config , params . output ) [EOL] fusions = self . manager . fusions [EOL] [EOL] index_page = report . create_page ( [string] , filename = [string] , page_variables = { [string] : params . sample } ) [EOL] index_page . add_module ( [string] , self . manager , params = { [string] : params . tool_cutoff } ) [EOL] report . render ( index_page ) [EOL] [EOL] with tqdm ( total = len ( fusions ) ) as pbar : [EOL] for fusion in fusions : [EOL] fusion_page = report . create_page ( fusion . name , page_variables = { [string] : params . sample } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion . name , [string] : params . db_path } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion . name , [string] : params . db_path } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion . name , [string] : params . db_path } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion . name , [string] : params . db_path } ) [EOL] fusion_page . add_module ( [string] , params = { [string] : fusion . name , [string] : params . db_path } ) [EOL] report . render ( fusion_page ) [EOL] pbar . set_description ( f' [string] { fusion . name }' ) [EOL] time . sleep ( [number] ) [EOL] pbar . update ( [number] ) [EOL] [EOL] def parse_fusion_outputs ( self , params ) : [EOL] [docstring] [EOL] for param , value in params . items ( ) : [EOL] if param in self . manager . supported_tools and value : [EOL] [comment] [EOL] [comment] [EOL] self . manager . parse ( param , value , params [ [string] ] ) [EOL] [EOL] def enrich ( self , path ) : [EOL] [docstring] [EOL] local_fusions = { FusionGDB ( path ) . name : FusionGDB ( path ) . get_all_fusions ( ) , MitelmanDB ( path ) . name : MitelmanDB ( path ) . get_all_fusions ( ) , CosmicDB ( path ) . name : CosmicDB ( path ) . get_all_fusions ( ) } [EOL] for fusion in self . manager . fusions : [EOL] for db_name , db_list in local_fusions . items ( ) : [EOL] if fusion . name in db_list : [EOL] fusion . add_db ( db_name ) [EOL] [EOL] def export_results ( self , path , extension ) : [EOL] [docstring] [EOL] dest = f"{ os . path . join ( path , [string] ) } [string] { extension }" [EOL] if extension == [string] : [EOL] with open ( dest , [string] , encoding = [string] ) as output : [EOL] results = [ fusion . json_serialize ( ) for fusion in self . manager . fusions ] [EOL] output . write ( rapidjson . dumps ( results ) ) [EOL] elif extension == [string] : [EOL] with open ( dest , [string] , encoding = [string] ) as output : [EOL] csv_writer = csv . writer ( output , delimiter = [string] , quotechar = [string] , quoting = csv . QUOTE_MINIMAL ) [EOL] [comment] [EOL] header = [ [string] , [string] , [string] , [string] ] [EOL] header . extend ( [ x for x in sorted ( self . manager . running_tools ) ] ) [EOL] csv_writer . writerow ( header ) [EOL] for fusion in self . manager . fusions : [EOL] row = [ fusion . name , [string] . join ( fusion . dbs ) , fusion . score , fusion . score_explained , ] [EOL] for tool in sorted ( self . manager . running_tools ) : [EOL] if tool in fusion . tools . keys ( ) : [EOL] row . append ( [string] . join ( [ f'{ key } [string] { value }' for key , value in fusion . tools [ tool ] . items ( ) ] ) ) [EOL] else : [EOL] row . append ( [string] ) [EOL] csv_writer . writerow ( row ) [EOL] else : [EOL] Logger ( __name__ ) . error ( [string] , extension ) [EOL] [EOL] def generate_fusion_list ( self , path , cutoff ) : [EOL] [docstring] [EOL] [comment] [EOL] with open ( os . path . join ( path , [string] ) , [string] , encoding = [string] ) as output : [EOL] for fusion in self . manager . fusions : [EOL] output . write ( f'{ fusion . name } [string] ' ) [EOL] [EOL] [comment] [EOL] with open ( os . path . join ( path , [string] ) , [string] , encoding = [string] ) as output : [EOL] for fusion in self . manager . fusions : [EOL] if len ( fusion . tools ) >= cutoff : [EOL] output . write ( f'{ fusion . name } [string] ' ) [EOL] [EOL] def score ( self , params ) : [EOL] [docstring] [EOL] [EOL] for fusion in self . manager . fusions : [EOL] [EOL] [comment] [EOL] tool_score = sum ( [ params [ f'{ tool . lower ( ) } [string] ' ] / [number] for tool , _ in fusion . tools . items ( ) ] ) [EOL] tool_score_expl = [ format ( ( params [ f'{ tool } [string] ' ] / [number] ) , [string] ) for tool , _ in fusion . tools . items ( ) ] [EOL] [EOL] [comment] [EOL] db_score = sum ( float ( Settings . FUSION_WEIGHTS [ db_name . lower ( ) ] ) for db_name in fusion . dbs ) [EOL] db_score_expl = [ format ( Settings . FUSION_WEIGHTS [ db_name . lower ( ) ] , [string] ) for db_name in fusion . dbs ] [EOL] [EOL] score = float ( [string] % ( [number] * tool_score + [number] * db_score ) ) [EOL] score_explained = f' [string] { [string] . join ( tool_score_expl ) } [string] { [string] . join ( db_score_expl ) } [string] ' [EOL] fusion . score , fusion . score_explained = score , score_explained [EOL] [EOL] @ staticmethod def generate_multiqc ( path , fusions , sample_name , running_tools_count ) : [EOL] [docstring] [EOL] [EOL] counts = defaultdict ( lambda : [number] ) [EOL] for fusion in fusions : [EOL] tools = fusion . dbs [EOL] if len ( tools ) == running_tools_count : [EOL] counts [ [string] ] += [number] [EOL] for tool in tools : [EOL] counts [ tool ] += [number] [EOL] [EOL] configuration = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] } , [string] : { sample_name : counts } } [EOL] [EOL] dest = f"{ os . path . join ( path , [string] ) }" [EOL] with open ( dest , [string] , encoding = [string] ) as output : [EOL] output . write ( rapidjson . dumps ( configuration ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.report.Report$ 0 0 0 $argparse.Namespace$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $fusion_report.common.report.Report$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.report.Report$ 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $fusion_report.common.report.Report$ 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $fusion_report.common.report.Report$ 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $_csv._writer$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 $_csv._writer$ 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 $builtins.str$ 0 $typing.List[fusion_report.common.models.fusion.Fusion]$ 0 $builtins.str$ 0 $builtins.int$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[fusion_report.common.models.fusion.Fusion]$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $builtins.int$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]],typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,builtins.int]$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Dict[builtins.str,builtins.int]],typing.Dict[builtins.str,builtins.str],builtins.str]]$ 0 0 0
	0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import base64 [EOL] import os [EOL] [EOL] from datetime import datetime [EOL] from typing import Any , Dict , List [EOL] [EOL] from yaml import YAMLError , safe_load [EOL] [EOL] from fusion_report . common . exceptions . config import ConfigException [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Config : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] self . _report_title = [string] [EOL] self . logos = { [string] : base64 . b64encode ( open ( os . path . join ( Settings . ROOT_DIR , [string] ) , [string] ) . read ( ) ) . decode ( [string] ) , [string] : base64 . b64encode ( open ( os . path . join ( Settings . ROOT_DIR , [string] ) , [string] ) . read ( ) ) . decode ( [string] ) } [EOL] self . _institution = { } [EOL] self . _date = datetime . now ( ) . strftime ( Settings . DATE_FORMAT ) [EOL] self . _assets = { } [EOL] [EOL] @ property def report_title ( self ) : [EOL] [docstring] [EOL] return self . _report_title [EOL] [EOL] @ report_title . setter def report_title ( self , title ) : [EOL] if title . strip ( ) : [EOL] self . _report_title = title . strip ( ) [EOL] [EOL] @ property def institution ( self ) : [EOL] [docstring] [EOL] return self . _institution [EOL] [EOL] @ institution . setter def institution ( self , institution ) : [EOL] if [string] in institution . keys ( ) : [EOL] self . _institution [ [string] ] = institution [ [string] ] [EOL] [EOL] if [string] in institution . keys ( ) and os . path . exists ( institution [ [string] ] ) : [EOL] image = os . path . join ( Settings . ROOT_DIR , institution [ [string] ] ) [EOL] self . _institution [ [string] ] = base64 . b64encode ( open ( image , [string] ) . read ( ) ) . decode ( [string] ) [EOL] [EOL] if [string] in institution . keys ( ) : [EOL] self . _institution [ [string] ] = institution [ [string] ] [EOL] [EOL] @ property def date ( self ) : [EOL] [docstring] [EOL] return self . _date [EOL] [EOL] @ date . setter def date ( self , date_format ) : [EOL] if date_format . strip ( ) : [EOL] self . _date = datetime . now ( ) . strftime ( date_format ) [EOL] [EOL] @ property def assets ( self ) : [EOL] [docstring] [EOL] return self . _assets [EOL] [EOL] @ assets . setter def assets ( self , assets ) : [EOL] for key , value in assets . items ( ) : [EOL] if key in ( [string] , [string] ) and value is not None : [EOL] self . assets [ key ] = [ x for x in value if os . path . exists ( x ) ] [EOL] [EOL] def parse ( self , path ) : [EOL] [docstring] [EOL] if path : [EOL] try : [EOL] with open ( path , [string] , encoding = [string] ) as in_file : [EOL] try : [EOL] data = safe_load ( in_file ) [EOL] self . report_title = data [ [string] ] [EOL] self . institution = data [ [string] ] [EOL] self . date = data [ [string] ] [EOL] self . assets = data [ [string] ] [EOL] return self [EOL] except YAMLError as ex : [EOL] raise ConfigException ( ex ) [EOL] except IOError as ex : [EOL] raise ConfigException ( ex ) [EOL] [EOL] return self [EOL] [EOL] def json_serialize ( self ) : [EOL] [docstring] [EOL] return { [string] : self . report_title , [string] : self . logos , [string] : self . institution , [string] : self . date , [string] : self . assets } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $'Config'$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 $typing.Any$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import os [EOL] [EOL] from typing import Any , Dict [EOL] [EOL] [EOL] class Settings : [EOL] [EOL] ROOT_DIR = os . path . dirname ( os . path . abspath ( __file__ ) ) [EOL] VERSION = [string] [EOL] DATE_FORMAT = [string] [EOL] THREAD_NUM = [number] [EOL] FUSION_WEIGHTS = { [string] : [number] , [string] : [number] , [string] : [number] } [EOL] [EOL] COSMIC = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] FUSIONGDB = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [ [string] , [string] , [string] , [string] , [string] , [string] ] } [EOL] [EOL] MITELMAN = { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] SOURCEFORGE = { [string] : [string] , [string] : [string] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 $typing.Dict[builtins.str,builtins.float]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0
from typing import List [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import os [EOL] import shutil [EOL] [EOL] from argparse import Namespace [EOL] from typing import List [EOL] [EOL] from fusion_report . common . exceptions . download import DownloadException [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . common . net import Net [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Download : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , params ) : [EOL] self . validate ( params ) [EOL] self . download_all ( params ) [EOL] [EOL] def validate ( self , params ) : [EOL] [docstring] [EOL] self . cosmic_token = Net . get_cosmic_token ( params ) [EOL] [EOL] [comment] [EOL] if not os . path . exists ( params . output ) : [EOL] os . makedirs ( params . output , [number] ) [EOL] [EOL] def download_all ( self , params ) : [EOL] [docstring] [EOL] return_err = [ ] [EOL] os . chdir ( params . output ) [EOL] [EOL] [comment] [EOL] url = f'{ Settings . SOURCEFORGE [ [string] ] } [string] { Settings . SOURCEFORGE [ [string] ] }' [EOL] Net . get_large_file ( url , ignore_ssl = False ) [EOL] shutil . unpack_archive ( Settings . SOURCEFORGE [ [string] ] ) [EOL] [EOL] [comment] [EOL] Net . get_cosmic ( self . cosmic_token , return_err ) [EOL] [EOL] if len ( return_err ) > [number] : [EOL] raise DownloadException ( return_err ) [EOL] [EOL] Logger ( __name__ ) . info ( [string] ) [EOL] Net . clean ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 $argparse.Namespace$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict [EOL] import builtins [EOL] import typing [EOL] import argparse [EOL] [docstring] [EOL] import os [EOL] [EOL] from argparse import ArgumentParser , Namespace , _SubParsersAction [EOL] from typing import Any , Dict [EOL] [EOL] import rapidjson [EOL] [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class ArgsBuilder : [EOL] [docstring] [EOL] [EOL] def __init__ ( self ) : [EOL] configuration = os . path . join ( Settings . ROOT_DIR , [string] ) [EOL] self . arguments = rapidjson . loads ( open ( configuration , [string] ) . read ( ) ) [EOL] self . arguments [ [string] ] = float ( [number] / len ( self . supported_tools ) ) [EOL] self . parser = ArgumentParser ( description = [string] ) [EOL] self . parser . add_argument ( [string] , [string] , action = [string] , version = f' [string] { Settings . VERSION }' ) [EOL] self . command_parser = self . parser . add_subparsers ( dest = [string] ) [EOL] [EOL] @ property def supported_tools ( self ) : [EOL] [docstring] [EOL] return [ tool [ [string] ] . replace ( [string] , [string] ) for tool in self . arguments [ [string] ] [ [string] ] [ [string] ] ] [EOL] [EOL] def build ( self ) : [EOL] [docstring] [EOL] self . run_args ( self . arguments [ [string] ] [ [string] ] , self . arguments [ [string] ] ) [EOL] self . download_args ( self . arguments [ [string] ] [ [string] ] ) [EOL] self . sync_args ( self . arguments [ [string] ] [ [string] ] ) [EOL] [EOL] def run_args ( self , args , weight ) : [EOL] [docstring] [EOL] run_parser = self . command_parser . add_parser ( [string] , help = [string] ) [EOL] [comment] [EOL] run_mandatory = run_parser . add_argument_group ( [string] , [string] ) [EOL] for mandatory in args [ [string] ] : [EOL] run_mandatory . add_argument ( mandatory [ [string] ] , help = mandatory [ [string] ] , type = str ) [EOL] [comment] [EOL] run_tools = run_parser . add_argument_group ( [string] , [string] ) [EOL] for tool in args [ [string] ] : [EOL] run_tools . add_argument ( tool [ [string] ] , help = tool [ [string] ] , type = str ) [EOL] run_tools . add_argument ( f'{ tool [ [string] ] } [string] ' , help = tool [ [string] ] , type = float , default = weight ) [EOL] [comment] [EOL] run_optional = run_parser . add_argument_group ( [string] , [string] ) [EOL] for optional in args [ [string] ] : [EOL] if len ( optional [ [string] ] ) > [number] : [EOL] if optional . get ( [string] ) : [EOL] run_optional . add_argument ( optional [ [string] ] [ [number] ] , optional [ [string] ] [ [number] ] , help = optional . get ( [string] ) , action = optional . get ( [string] ) ) [EOL] else : [EOL] run_optional . add_argument ( optional [ [string] ] [ [number] ] , optional [ [string] ] [ [number] ] , default = optional . get ( [string] ) , help = optional . get ( [string] ) , type = type ( optional . get ( [string] ) ) ) [EOL] else : [EOL] if optional . get ( [string] ) : [EOL] run_optional . add_argument ( optional [ [string] ] [ [number] ] , default = optional . get ( [string] ) , help = optional . get ( [string] ) , action = optional . get ( [string] ) ) [EOL] else : [EOL] run_optional . add_argument ( optional [ [string] ] [ [number] ] , default = optional . get ( [string] ) , help = optional . get ( [string] ) , type = type ( optional . get ( [string] ) ) ) [EOL] [EOL] def download_args ( self , args ) : [EOL] [docstring] [EOL] download_parser = self . command_parser . add_parser ( [string] , help = [string] ) [EOL] for mandatory in args [ [string] ] : [EOL] download_parser . add_argument ( mandatory [ [string] ] , help = mandatory [ [string] ] , type = str ) [EOL] [EOL] self . _cosmic ( args , download_parser ) [EOL] [EOL] def sync_args ( self , args ) : [EOL] [docstring] [EOL] download_parser = self . command_parser . add_parser ( [string] , help = [string] ) [EOL] for mandatory in args [ [string] ] : [EOL] download_parser . add_argument ( mandatory [ [string] ] , help = mandatory [ [string] ] , type = str ) [EOL] [EOL] self . _cosmic ( args , download_parser ) [EOL] [EOL] def _cosmic ( self , args , parser ) : [EOL] [docstring] [EOL] download_cosmic = parser . add_argument_group ( [string] , [string] ) [EOL] for cosmic in args [ [string] ] : [EOL] download_cosmic . add_argument ( cosmic [ [string] ] , help = cosmic [ [string] ] , type = str ) [EOL] [EOL] def parse ( self ) : [EOL] [docstring] [EOL] return self . parser . parse_args ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._SubParsersAction$ 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse._ArgumentGroup$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $argparse.ArgumentParser$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $argparse.ArgumentParser$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $argparse.ArgumentParser$ 0 0 0 0 $None$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $argparse.Namespace$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . common . fusion_manager import FusionManager [EOL] [EOL] [EOL] class BaseModule : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , manager , params ) : [EOL] self . manager = manager [EOL] self . params = params [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $fusion_report.common.fusion_manager.FusionManager$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $fusion_report.common.fusion_manager.FusionManager$ 0 $fusion_report.common.fusion_manager.FusionManager$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0
	0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] import os [EOL] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . common . exceptions . module import ModuleException [EOL] from fusion_report . common . fusion_manager import FusionManager [EOL] [EOL] [EOL] class ModuleLoader : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , manager = None , params = None ) : [EOL] self . manager = manager [EOL] self . params = params [EOL] [EOL] def exec ( self , name ) : [EOL] [docstring] [EOL] try : [EOL] variables = self . __build_factory ( name , self . manager , self . params ) . load ( ) [EOL] variables [ [string] ] = os . path . join ( f'{ name . replace ( [string] , [string] ) }' , [string] ) [EOL] return variables [EOL] except AttributeError as ex : [EOL] raise ModuleException ( ex ) [EOL] [EOL] @ staticmethod def __build_factory ( name , manager , params = None ) : [EOL] [docstring] [EOL] module_name = f' [string] { name } [string] { name . split ( [string] ) [ - [number] ] }' [EOL] module = __import__ ( module_name , fromlist = [ [string] ] ) [EOL] klass = getattr ( module , [string] ) [EOL] return klass ( manager , params ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $fusion_report.common.fusion_manager.FusionManager$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 $fusion_report.common.fusion_manager.FusionManager$ 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . modules . base_module import BaseModule [EOL] [EOL] [EOL] class CustomModule ( BaseModule ) : [EOL] [docstring] [EOL] [EOL] def load ( self ) : [EOL] [docstring] [EOL] return { [string] : self . params [ [string] ] , [string] : [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . data . fusiongdb import FusionGDB [EOL] from fusion_report . modules . base_module import BaseModule [EOL] [EOL] [EOL] class CustomModule ( BaseModule ) : [EOL] [docstring] [EOL] [EOL] def get_data ( self ) : [EOL] [docstring] [EOL] [EOL] return FusionGDB ( self . params [ [string] ] ) . select ( [string] , self . params [ [string] ] . split ( [string] ) ) [EOL] [EOL] def load ( self ) : [EOL] [docstring] [EOL] [EOL] return { [string] : self . get_data ( ) , [string] : [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
from typing import List , Any , Dict , Union , Set [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , List [EOL] [EOL] from fusion_report . data . fusiongdb import FusionGDB [EOL] from fusion_report . modules . base_module import BaseModule [EOL] [EOL] [EOL] class CustomModule ( BaseModule ) : [EOL] [docstring] [EOL] [EOL] def get_data ( self ) : [EOL] [docstring] [EOL] [EOL] return FusionGDB ( self . params [ [string] ] ) . select ( [string] , self . params [ [string] ] . split ( [string] ) ) [EOL] [EOL] def build_graph ( self ) : [EOL] [docstring] [EOL] data = self . get_data ( ) [EOL] if not data : [EOL] return [ ] [EOL] [EOL] graph_data = [ { [string] : { [string] : [string] } , [string] : [string] } , { [string] : { [string] : data [ [number] ] [ [string] ] } , [string] : [string] } , { [string] : { [string] : data [ [number] ] [ [string] ] } , [string] : [string] } , { [string] : { [string] : [string] + data [ [number] ] [ [string] ] , [string] : [string] , [string] : data [ [number] ] [ [string] ] } , [string] : [string] } , { [string] : { [string] : [string] + data [ [number] ] [ [string] ] , [string] : [string] , [string] : data [ [number] ] [ [string] ] } , [string] : [string] } , ] [EOL] [EOL] left_fusion = set ( map ( str . strip , data [ [number] ] [ [string] ] . split ( [string] ) ) ) [EOL] right_fusion = set ( map ( str . strip , data [ [number] ] [ [string] ] . split ( [string] ) ) ) [EOL] intersect = left_fusion & right_fusion [EOL] left_fusion -= intersect [EOL] right_fusion -= intersect [EOL] [EOL] [comment] [EOL] for gene in left_fusion : [EOL] graph_data . append ( { [string] : { [string] : gene } } ) [EOL] graph_data . append ( { [string] : { [string] : gene + [string] + data [ [number] ] [ [string] ] , [string] : data [ [number] ] [ [string] ] , [string] : gene } } ) [EOL] [EOL] [comment] [EOL] for gene in right_fusion : [EOL] graph_data . append ( { [string] : { [string] : gene } } ) [EOL] graph_data . append ( { [string] : { [string] : gene + [string] + data [ [number] ] [ [string] ] , [string] : data [ [number] ] [ [string] ] , [string] : gene } } ) [EOL] [EOL] [comment] [EOL] for gene in list ( intersect ) : [EOL] graph_data . append ( { [string] : { [string] : gene } } ) [EOL] graph_data . append ( { [string] : { [string] : [string] + [string] + gene , [string] : [string] , [string] : gene } } ) [EOL] [EOL] return graph_data [EOL] [EOL] def load ( self ) : [EOL] [docstring] [EOL] [EOL] return { [string] : self . build_graph ( ) , [string] : [ [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 $typing.List[typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Dict[builtins.str,typing.Union[typing.Dict[builtins.str,typing.Any],builtins.str]]]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
	0
	0
from typing import KeysView , List , Any , Dict , Set [EOL] import builtins [EOL] import typing [EOL] from typing import Any , Dict , List [EOL] [EOL] from fusion_report . modules . base_module import BaseModule [EOL] [EOL] [EOL] class CustomModule ( BaseModule ) : [EOL] [EOL] def known_vs_unknown ( self ) : [EOL] [docstring] [EOL] all_fusions = len ( self . manager . fusions ) [EOL] known_fusions = len ( self . manager . get_known_fusions ( ) ) [EOL] return [ [ [string] , known_fusions ] , [ [string] , all_fusions - known_fusions ] ] [EOL] [EOL] def tool_detection ( self ) : [EOL] [docstring] [EOL] running_tools = sorted ( self . manager . running_tools ) [EOL] counts = dict . fromkeys ( running_tools , [number] ) [EOL] counts [ [string] ] = [number] [EOL] running_tools_count = len ( running_tools ) [EOL] for fusion in self . manager . fusions : [EOL] fusion_tools = fusion . tools . keys ( ) [EOL] for tool in fusion_tools : [EOL] counts [ tool ] += [number] [EOL] [comment] [EOL] if len ( fusion_tools ) == running_tools_count : [EOL] counts [ [string] ] += [number] [EOL] [EOL] return [ [ k , v ] for k , v in counts . items ( ) ] [EOL] [EOL] def detection_distribution ( self ) : [EOL] [docstring] [EOL] counts = [ [number] ] * ( len ( self . manager . running_tools ) + [number] ) [EOL] for fusion in self . manager . fusions : [EOL] counts [ len ( fusion . tools . keys ( ) ) ] += [number] [EOL] [EOL] return [ [ f"{ index } [string] " , counts [ index ] ] for index in range ( len ( counts ) ) ] [EOL] [EOL] def create_fusions_table ( self ) : [EOL] [docstring] [EOL] rows = [ ] [EOL] tools = self . manager . running_tools [EOL] filter_flag = len ( tools ) < self . params [ [string] ] [EOL] for fusion in self . manager . fusions : [EOL] row = { } [EOL] [comment] [EOL] if filter_flag : [EOL] row = { [string] : fusion . name , [string] : fusion . dbs , [string] : len ( fusion . tools ) , [string] : f'{ fusion . score : [string] }' } [EOL] [comment] [EOL] [comment] [EOL] if not filter_flag and len ( fusion . tools ) >= self . params [ [string] ] : [EOL] row = { [string] : fusion . name , [string] : fusion . dbs , [string] : len ( fusion . tools ) , [string] : f'{ fusion . score : [string] }' } [EOL] [EOL] [comment] [EOL] if bool ( row ) : [EOL] for tool in tools : [EOL] row [ tool ] = [string] if tool in sorted ( fusion . tools ) else [string] [EOL] rows . append ( row ) [EOL] [EOL] return { [string] : rows , [string] : list ( sorted ( tools ) ) } [EOL] [EOL] def load ( self ) : [EOL] [docstring] [EOL] [EOL] return { [string] : self . manager . running_tools , [string] : len ( self . manager . fusions ) , [string] : len ( self . manager . get_known_fusions ( ) ) , [string] : self . tool_detection ( ) , [string] : self . known_vs_unknown ( ) , [string] : self . detection_distribution ( ) , [string] : self . create_fusions_table ( ) , [string] : self . params [ [string] ] , [string] : [ [string] , [string] ] } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
from typing import Dict , Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import abc [EOL] [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] [EOL] class AbstractFusionTool ( metaclass = abc . ABCMeta ) : [EOL] [docstring] [EOL] [EOL] @ abc . abstractmethod def parse ( self , line , delimiter = None ) : [EOL] [docstring] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0
from typing import Dict , Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] from fusion_report . parsers . abstract_fusion import AbstractFusionTool [EOL] [EOL] [EOL] class Arriba ( AbstractFusionTool ) : [EOL] [docstring] [EOL] [EOL] def parse_multiple ( self , left_fusion , right_fusion , delimiter ) : [EOL] if delimiter not in left_fusion and delimiter not in right_fusion : [EOL] return [ f'{ left_fusion } [string] { right_fusion }' ] [EOL] [EOL] left = [ x . split ( [string] ) [ [number] ] for x in left_fusion . split ( delimiter ) ] [EOL] right = [ x . split ( [string] ) [ [number] ] for x in right_fusion . split ( delimiter ) ] [EOL] fusions = [ f'{ a } [string] { b }' for a in left for b in right ] [EOL] [EOL] return fusions [EOL] [EOL] def parse ( self , line , delimiter = [string] ) : [EOL] col = line . strip ( ) . split ( delimiter ) [EOL] fusions = self . parse_multiple ( col [ [number] ] , col [ [number] ] , [string] ) [EOL] details = { [string] : f"{ col [ [number] ] } [string] { col [ [number] ] }" , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , [string] : f'{ col [ [number] ] }' , } [EOL] [EOL] return [ ( fusion , details ) for fusion in fusions ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0
from typing import Dict , Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] from fusion_report . parsers . abstract_fusion import AbstractFusionTool [EOL] [EOL] [EOL] class Starfusion ( AbstractFusionTool ) : [EOL] [docstring] [EOL] [EOL] def parse ( self , line , delimiter = [string] ) : [EOL] col = line . strip ( ) . split ( delimiter ) [EOL] fusion = f"{ col [ [number] ] }" [EOL] details = { [string] : f"{ col [ [number] ] } [string] { col [ [number] ] }" , [string] : int ( col [ [number] ] ) , [string] : int ( col [ [number] ] ) , [string] : float ( col [ [number] ] ) } [EOL] [EOL] return [ ( fusion , details ) ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0
	0
from typing import Dict , Any , Tuple , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , List , Tuple [EOL] [EOL] from fusion_report . parsers . abstract_fusion import AbstractFusionTool [EOL] [EOL] [EOL] class Squid ( AbstractFusionTool ) : [EOL] [docstring] [EOL] [EOL] def parse_multiple ( self , col , delimiter ) : [EOL] return [ fusion . replace ( [string] , [string] ) for fusion in col . split ( delimiter ) ] [EOL] [EOL] def parse ( self , line , delimiter = [string] ) : [EOL] col = line . strip ( ) . split ( delimiter ) [EOL] if col [ [number] ] . strip ( ) == [string] : [EOL] return [ ( [string] , { } ) ] [EOL] [EOL] fusions = self . parse_multiple ( col [ [number] ] , [string] ) [EOL] left_breakpoint = f"{ col [ [number] ] } [string] { col [ [number] ] } [string] { col [ [number] ] } [string] { col [ [number] ] }" . replace ( [string] , [string] ) [EOL] right_breakpoint = f"{ col [ [number] ] } [string] { col [ [number] ] } [string] { col [ [number] ] } [string] { col [ [number] ] }" . replace ( [string] , [string] ) [EOL] details = { [string] : f"{ left_breakpoint } [string] { right_breakpoint }" [EOL] if col [ [number] ] == [string] else f"{ right_breakpoint } [string] { left_breakpoint }" , [string] : int ( col [ [number] ] ) } [EOL] [EOL] return [ ( fusion , details ) for fusion in fusions ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[builtins.str]$ 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] from fusion_report . common . db import Db [EOL] from fusion_report . common . singleton import Singleton [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class MitelmanDB ( Db , metaclass = Singleton ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( path , Settings . MITELMAN [ [string] ] , Settings . MITELMAN [ [string] ] ) [EOL] [EOL] def get_all_fusions ( self ) : [EOL] [docstring] [EOL] query = [string] [EOL] res = self . select ( query ) [EOL] [EOL] return [ fusion [ [string] ] . strip ( ) . replace ( [string] , [string] ) for fusion in res ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import re [EOL] [EOL] from typing import List [EOL] [EOL] from fusion_report . common . db import Db [EOL] from fusion_report . common . singleton import Singleton [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class CosmicDB ( Db , metaclass = Singleton ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( path , Settings . COSMIC [ [string] ] , Settings . COSMIC [ [string] ] ) [EOL] [EOL] def get_all_fusions ( self ) : [EOL] [docstring] [EOL] query = [string] [EOL] res = self . select ( query ) [EOL] [EOL] return [ [string] . join ( re . findall ( [string] , x [ [string] ] ) ) for x in res ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import List [EOL] [EOL] from fusion_report . common . db import Db [EOL] from fusion_report . common . singleton import Singleton [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class FusionGDB ( Db , metaclass = Singleton ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path ) : [EOL] super ( ) . __init__ ( path , Settings . FUSIONGDB [ [string] ] , Settings . FUSIONGDB [ [string] ] ) [EOL] [EOL] def setup ( self , files , delimiter = [string] , skip_header = False , encoding = [string] ) : [EOL] super ( ) . setup ( files , delimiter ) [EOL] [EOL] [comment] [EOL] sql = [string] [EOL] self . execute ( sql ) [EOL] [EOL] def get_all_fusions ( self ) : [EOL] [docstring] [EOL] query = [string] [EOL] res = self . select ( query ) [EOL] [EOL] return [ fusion [ [string] ] for fusion in res ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0
	0
from typing import Dict , Any [EOL] import builtins [EOL] import jinja2 [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] import os [EOL] [EOL] from pathlib import Path [EOL] from typing import Any , Dict [EOL] [EOL] from jinja2 import Environment , FileSystemLoader , Markup [EOL] [EOL] from fusion_report . common . page import Page [EOL] from fusion_report . config import Config [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Template : [EOL] [docstring] [EOL] def __init__ ( self , config_path , output_dir ) : [EOL] self . j2_env = Environment ( loader = FileSystemLoader ( [ os . path . join ( Settings . ROOT_DIR , [string] ) , os . path . join ( Settings . ROOT_DIR , [string] ) ] ) , trim_blocks = True , autoescape = True ) [EOL] self . j2_variables = Config ( ) . parse ( config_path ) [EOL] self . output_dir = output_dir [EOL] [EOL] [comment] [EOL] self . j2_env . globals [ [string] ] = self . include_raw [EOL] self . j2_env . globals [ [string] ] = self . get_id [EOL] [EOL] [comment] [EOL] if not os . path . exists ( output_dir ) : [EOL] os . mkdir ( output_dir ) [EOL] [EOL] def render ( self , page , extra_variables ) : [EOL] [docstring] [EOL] merged_variables = { ** self . j2_variables . json_serialize ( ) , ** extra_variables } [EOL] view = self . j2_env . get_template ( page . view ) . render ( merged_variables ) [EOL] with open ( os . path . join ( self . output_dir , page . filename ) , [string] , encoding = [string] ) as file_out : [EOL] file_out . write ( view ) [EOL] [EOL] def include_raw ( self , filename ) : [EOL] [docstring] [EOL] file_extension = Path ( filename ) . suffix [EOL] if file_extension == [string] : [EOL] return Markup ( [string] . format ( css = self . j2_env . loader . get_source ( self . j2_env , filename ) [ [number] ] ) ) [EOL] if file_extension == [string] : [EOL] return Markup ( [string] . format ( js = self . j2_env . loader . get_source ( self . j2_env , filename ) [ [number] ] ) ) [EOL] [EOL] return Markup ( self . j2_env . loader . get_source ( self . j2_env , filename ) [ [number] ] ) [EOL] [EOL] @ staticmethod def get_id ( title ) : [EOL] [docstring] [EOL] return title . lower ( ) . replace ( [string] , [string] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.config.Config$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 $jinja2.environment.Environment$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $fusion_report.common.page.Page$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $builtins.str$ 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $jinja2.Markup$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import sqlite3 [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] import os [EOL] import sqlite3 [EOL] [EOL] from typing import List [EOL] [EOL] from fusion_report . common . exceptions . db import DbException [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Db : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , path , name , schema ) : [EOL] self . name = name [EOL] self . _schema = schema [EOL] self . database = f'{ name . lower ( ) } [string] ' [EOL] self . connection = self . connect ( path , self . database ) [EOL] [EOL] def connect ( self , path , database ) : [EOL] [docstring] [EOL] try : [EOL] connection = sqlite3 . connect ( os . path . join ( path , database ) ) [EOL] connection . row_factory = self . __dict_factory [EOL] return connection [EOL] except sqlite3 . DatabaseError as ex : [EOL] raise DbException ( ex ) [EOL] [EOL] def setup ( self , files , delimiter = [string] , skip_header = False , encoding = [string] ) : [EOL] [docstring] [EOL] try : [EOL] [comment] [EOL] self . create_database ( ) [EOL] [EOL] [comment] [EOL] for file in filter ( lambda x : not x . endswith ( [string] ) , files ) : [EOL] with open ( file , [string] , encoding = encoding ) as resource : [EOL] if skip_header : [EOL] next ( resource ) [EOL] first_line = resource . readline ( ) . split ( delimiter ) [EOL] rows = [ first_line ] [EOL] for line in resource : [EOL] row = line . split ( delimiter ) [EOL] rows . append ( row + [ [string] for _ in range ( len ( row ) , len ( first_line ) ) ] ) [EOL] self . connection . executemany ( f''' [string] { file . split ( [string] ) [ [number] ] . lower ( ) } [string] { [string] . join ( [ [string] for _ in range ( [number] , len ( first_line ) ) ] ) } [string] ''' , rows ) [EOL] self . connection . commit ( ) [EOL] except ( IOError , sqlite3 . Error ) as ex : [EOL] raise DbException ( ex ) [EOL] [EOL] def create_database ( self ) : [EOL] [docstring] [EOL] with open ( self . schema , [string] , encoding = [string] ) as schema : [EOL] self . connection . executescript ( schema . read ( ) . lower ( ) ) [EOL] [EOL] def select ( self , query , params = None ) : [EOL] [docstring] [EOL] try : [EOL] with self . connection as conn : [EOL] cur = conn . cursor ( ) [EOL] if not params : [EOL] cur . execute ( query ) [EOL] else : [EOL] cur . execute ( query , params ) [EOL] res = cur . fetchall ( ) [EOL] cur . close ( ) [EOL] return res [EOL] except sqlite3 . OperationalError as ex : [EOL] raise DbException ( ex ) [EOL] [EOL] def execute ( self , query , params = None ) : [EOL] [docstring] [EOL] try : [EOL] with self . connection as conn : [EOL] cur = conn . cursor ( ) [EOL] if not params : [EOL] cur . execute ( query ) [EOL] else : [EOL] cur . execute ( query , params ) [EOL] self . connection . commit ( ) [EOL] except sqlite3 . Error as ex : [EOL] raise DbException ( ex ) [EOL] [EOL] @ property def schema ( self ) : [EOL] [docstring] [EOL] return os . path . join ( Settings . ROOT_DIR , f' [string] { self . _schema }' ) [EOL] [EOL] @ classmethod def __dict_factory ( cls , cursor , row ) : [EOL] [docstring] [EOL] tmp_dictionary = { } [EOL] for idx , col in enumerate ( cursor . description ) : [EOL] tmp_dictionary [ col [ [number] ] ] = row [ idx ] [EOL] return tmp_dictionary [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[typing.Any,typing.Any]$ 0
from typing import Any [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] [docstring] [EOL] import logging [EOL] import sys [EOL] [EOL] from logging . handlers import TimedRotatingFileHandler [EOL] from typing import Any [EOL] [EOL] from colorlog import ColoredFormatter [EOL] [EOL] from fusion_report . common . singleton import Singleton [EOL] [EOL] [EOL] class Logger ( metaclass = Singleton ) : [EOL] [docstring] [EOL] logger = { } [EOL] [EOL] def __init__ ( self , name ) : [EOL] if not self . logger : [EOL] self . logger = logging . getLogger ( name ) [EOL] self . filename = [string] [EOL] self . logger . setLevel ( logging . INFO ) [EOL] self . logger . addHandler ( self . get_critical_handler ( self . filename ) ) [EOL] self . logger . addHandler ( self . get_info_handler ( ) ) [EOL] [EOL] def get_logger ( self ) : [EOL] [docstring] [EOL] return self . logger [EOL] [EOL] def critical ( self , msg , * args ) : [EOL] [docstring] [EOL] self . logger . critical ( msg , * args ) [EOL] [EOL] def debug ( self , msg , * args ) : [EOL] [docstring] [EOL] self . logger . debug ( msg , * args ) [EOL] [EOL] def error ( self , msg , * args ) : [EOL] [docstring] [EOL] self . logger . error ( msg , * args ) [EOL] [EOL] def fatal ( self , msg , * args , ** kwargs ) : [EOL] [docstring] [EOL] self . logger . fatal ( msg , * args , ** kwargs ) [EOL] [EOL] def info ( self , msg , * args ) : [EOL] [docstring] [EOL] self . logger . info ( msg , * args ) [EOL] [EOL] def warning ( self , msg , * args ) : [EOL] [docstring] [EOL] self . logger . warning ( msg , * args ) [EOL] [EOL] @ staticmethod def get_critical_handler ( filename ) : [EOL] [docstring] [EOL] file_handler = TimedRotatingFileHandler ( filename , when = [string] ) [EOL] file_handler . setFormatter ( logging . Formatter ( [string] ) ) [EOL] file_handler . setLevel ( logging . WARNING ) [EOL] [EOL] return file_handler [EOL] [EOL] @ staticmethod def get_info_handler ( ) : [EOL] [docstring] [EOL] info_handler = logging . StreamHandler ( sys . stdout ) [EOL] info_handler . setFormatter ( ColoredFormatter ( [string] ) ) [EOL] info_handler . setLevel ( logging . INFO ) [EOL] [EOL] return info_handler [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $logging.handlers.TimedRotatingFileHandler$ 0 $builtins.str$ 0 0 0 0 0 $logging.handlers.TimedRotatingFileHandler$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $logging.handlers.TimedRotatingFileHandler$ 0 0 0 0 0 0 0 0 0 0 0 $logging.handlers.TimedRotatingFileHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.handlers.TimedRotatingFileHandler$ 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0 0 0 0 0 0 0 0 0 0 $logging.StreamHandler$ 0
from typing import Any , List [EOL] import builtins [EOL] import ssl [EOL] import fusion_report [EOL] import urllib [EOL] import typing [EOL] import argparse [EOL] import base64 [EOL] import glob [EOL] import gzip [EOL] import os [EOL] import shutil [EOL] import ssl [EOL] import urllib . error [EOL] import urllib . request [EOL] [EOL] from argparse import Namespace [EOL] from typing import List [EOL] [EOL] import rapidjson [EOL] [EOL] from fusion_report . common . exceptions . download import DownloadException [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . data . cosmic import CosmicDB [EOL] from fusion_report . settings import Settings [EOL] [EOL] [EOL] class Net : [EOL] [EOL] @ staticmethod def get_cosmic_token ( params ) : [EOL] if params . cosmic_token is not None : [EOL] return params . cosmic_token [EOL] [EOL] if ( params . cosmic_token is None [EOL] and ( params . cosmic_usr is not None or params . cosmic_passwd is not None ) ) : [EOL] return base64 . b64encode ( f'{ params . cosmic_usr } [string] { params . cosmic_passwd }' . encode ( ) ) . decode ( [string] ) [EOL] else : [EOL] raise DownloadException ( [string] ) [EOL] [EOL] @ staticmethod def get_large_file ( url , ignore_ssl = False ) : [EOL] [docstring] [EOL] [EOL] ctx = None [EOL] if ignore_ssl : [EOL] ctx = ssl . create_default_context ( ) [EOL] ctx . check_hostname = False [EOL] ctx . verify_mode = ssl . CERT_NONE [EOL] [EOL] if url . startswith ( [string] ) or url . startswith ( [string] ) : [EOL] try : [EOL] with urllib . request . urlopen ( url , context = ctx ) as response : [EOL] file = url . split ( [string] ) [ - [number] ] . split ( [string] ) [ [number] ] [EOL] Logger ( __name__ ) . info ( [string] , file ) [EOL] [comment] [EOL] if not os . path . exists ( file ) or ( response . info ( ) [ [string] ] or [number] ) != os . stat ( file ) . st_size : [EOL] with open ( file , [string] ) as out_file : [EOL] shutil . copyfileobj ( response , out_file ) [EOL] except urllib . error . HTTPError as ex : [EOL] raise DownloadException ( ex ) [EOL] else : [EOL] Logger ( __name__ ) . error ( [string] ) [EOL] [EOL] @ staticmethod def get_cosmic ( token , return_err ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] files = [ ] [EOL] file = Settings . COSMIC [ [string] ] [EOL] url = f'{ Settings . COSMIC [ [string] ] } [string] { Settings . COSMIC [ [string] ] }' [EOL] req = urllib . request . Request ( url ) [EOL] req . add_header ( [string] , f' [string] { token }' ) [EOL] req . add_header ( [string] , [string] ) [EOL] try : [EOL] res = urllib . request . urlopen ( req ) [EOL] auth_url = rapidjson . loads ( res . read ( ) . decode ( [string] ) ) [ [string] ] [EOL] Net . get_large_file ( auth_url ) [EOL] [EOL] files . append ( [string] . join ( file . split ( [string] ) [ : - [number] ] ) ) [EOL] with gzip . open ( file , [string] ) as archive , open ( files [ [number] ] , [string] ) as out_file : [EOL] shutil . copyfileobj ( archive , out_file ) [EOL] [EOL] db = CosmicDB ( [string] ) [EOL] db . setup ( files , delimiter = [string] , skip_header = True ) [EOL] except urllib . error . HTTPError as ex : [EOL] return_err . append ( f'{ Settings . COSMIC [ [string] ] } [string] { ex }' ) [EOL] [EOL] @ staticmethod def clean ( ) : [EOL] [docstring] [EOL] for temp in glob . glob ( [string] ) : [EOL] os . remove ( temp ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.request.Request$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 $urllib.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 0 $urllib.request.Request$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 $urllib.request.Request$ 0 0 $builtins.str$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.data.cosmic.CosmicDB$ 0 0 0 0 0 0 $fusion_report.data.cosmic.CosmicDB$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Tuple , List , Dict , Any , Set [EOL] import builtins [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] from typing import Any , Dict , List , Set , Tuple [EOL] [EOL] from fusion_report . common . exceptions . app import AppException [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . common . models . fusion import Fusion [EOL] [EOL] [EOL] class FusionManager : [EOL] [docstring] [EOL] def __init__ ( self , supported_tools ) : [EOL] self . fusions = [ ] [EOL] self . running_tools = set ( ) [EOL] self . supported_tools = supported_tools [EOL] [EOL] def parse ( self , tool , file , allow_multiple_genes ) : [EOL] [docstring] [EOL] if tool in self . supported_tools : [EOL] self . running_tools . add ( tool ) [EOL] factory_parser = self . __build_factory ( tool ) [EOL] try : [EOL] with open ( file , [string] , encoding = [string] ) as fusion_output : [EOL] next ( fusion_output ) [comment] [EOL] for line in fusion_output : [EOL] fusion_list = factory_parser . parse ( line ) [EOL] if allow_multiple_genes is None and len ( fusion_list ) > [number] : [EOL] fusion_list = [ fusion_list [ [number] ] ] [EOL] for fusion_name , details in fusion_list : [EOL] self . add ( fusion_name , tool , details ) [EOL] except IOError as ex : [EOL] raise AppException ( ex ) [EOL] else : [EOL] Logger ( __name__ ) . error ( [string] , tool ) [EOL] [EOL] def add ( self , fusion_name , tool , details ) : [EOL] [docstring] [EOL] if fusion_name and tool : [EOL] index = self . index_by ( fusion_name ) [EOL] if index == - [number] : [EOL] fusion = Fusion ( fusion_name ) [EOL] fusion . add_tool ( tool , details ) [EOL] self . fusions . append ( fusion ) [EOL] else : [EOL] fusion = self . fusions [ index ] [EOL] fusion . add_tool ( tool , details ) [EOL] [EOL] def get_known_fusions ( self ) : [EOL] [docstring] [EOL] return [ fusion for fusion in self . fusions if fusion . dbs ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] @ staticmethod def __build_factory ( tool ) : [EOL] [docstring] [EOL] try : [EOL] module_name = f' [string] { tool . lower ( ) }' [EOL] module = __import__ ( module_name , fromlist = [ tool . capitalize ( ) ] ) [EOL] klass = getattr ( module , tool . capitalize ( ) ) [EOL] return klass ( ) [EOL] except AttributeError as ex : [EOL] raise AppException ( ex ) [EOL] [EOL] def index_by ( self , value ) : [EOL] [docstring] [EOL] for index , fusion in enumerate ( self . fusions ) : [EOL] if fusion . name == value : [EOL] return index [EOL] return - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 $typing.List[fusion_report.common.models.fusion.Fusion]$ 0 0 0 0 0 0 $typing.Set[builtins.str]$ 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 $typing.List[builtins.str]$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.bool$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Any$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 $typing.Any$ 0 0 0 0 0 0 0 $builtins.bool$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Dict[builtins.str,typing.Any]]]$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 $fusion_report.common.models.fusion.Fusion$ 0 0 0 $builtins.str$ 0 0 $fusion_report.common.models.fusion.Fusion$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $fusion_report.common.models.fusion.Fusion$ 0 0 0 0 0 $fusion_report.common.models.fusion.Fusion$ 0 0 0 0 0 $builtins.int$ 0 0 $fusion_report.common.models.fusion.Fusion$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.List[fusion_report.common.models.fusion.Fusion]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List , Optional [EOL] import builtins [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] from typing import Any , Dict , List , Optional [EOL] [EOL] from fusion_report . common . exceptions . report import ReportException [EOL] from fusion_report . common . page import Page [EOL] from fusion_report . common . template import Template [EOL] [EOL] [EOL] class Report ( Template ) : [EOL] [docstring] [EOL] def __init__ ( self , config_path , output_dir ) : [EOL] self . pages = [ ] [EOL] super ( ) . __init__ ( config_path , output_dir ) [EOL] [EOL] def create_page ( self , title , view = [string] , filename = None , page_variables = None ) : [EOL] [docstring] [EOL] if page_variables is None : [EOL] page_variables = { } [EOL] [EOL] page = Page ( title , view , filename , page_variables ) [EOL] if self . index_by ( filename ) != - [number] : [EOL] raise ReportException ( f' [string] { page . filename } [string] ' ) [EOL] [EOL] self . pages . append ( page ) [EOL] return page [EOL] [EOL] def get_page ( self , filename ) : [EOL] [docstring] [EOL] index = self . index_by ( filename ) [EOL] if index == - [number] : [EOL] raise ReportException ( f' [string] { filename } [string] ' ) [EOL] [EOL] return self . pages [ index ] [EOL] [EOL] def render ( self , page , extra_variables = None ) : [EOL] [docstring] [EOL] template_variables = page . get_content ( ) [EOL] [EOL] [comment] [EOL] template_variables [ [string] ] = page . modules [EOL] [EOL] [comment] [EOL] template_variables [ [string] ] = [ ] [EOL] for _ , module in template_variables [ [string] ] . items ( ) : [EOL] for item in module [ [string] ] : [EOL] template_variables [ [string] ] . append ( ( self . get_id ( item ) , item ) ) [EOL] [EOL] if extra_variables : [EOL] template_variables = { ** template_variables , ** extra_variables } [EOL] [EOL] super ( ) . render ( page , template_variables ) [EOL] [EOL] def index_by ( self , value ) : [EOL] [docstring] [EOL] if value : [EOL] for index , page in enumerate ( self . pages ) : [EOL] if page . filename == value : [EOL] return index [EOL] [EOL] return - [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $typing.List[fusion_report.common.page.Page]$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 $fusion_report.common.page.Page$ 0 0 0 $fusion_report.common.page.Page$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.int$ 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $fusion_report.common.page.Page$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 $typing.Optional[typing.Dict[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 $fusion_report.common.page.Page$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 $builtins.int$ 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Optional[builtins.str]$ 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] import fusion_report [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . common . fusion_manager import FusionManager [EOL] from fusion_report . common . logger import Logger [EOL] from fusion_report . modules . loader import ModuleLoader [EOL] [EOL] [EOL] class BasePage : [EOL] [docstring] [EOL] def __init__ ( self , title , view , filename = None ) : [EOL] self . title = title . strip ( ) [EOL] self . view = f' [string] { view } [string] ' [EOL] self . modules = { } [EOL] self . filename = filename if filename else self . _set_filename ( title ) [EOL] [EOL] def add_module ( self , name , manager = None , params = None ) : [EOL] [docstring] [EOL] if name not in self . modules : [EOL] self . modules [ name ] = ModuleLoader ( manager , params ) . exec ( name ) [EOL] else : [EOL] Logger ( __name__ ) . warning ( [string] , name ) [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] return { [string] : self . title , [string] : self . filename , [string] : self . view } [EOL] [EOL] @ staticmethod def _set_filename ( fusion ) : [EOL] [docstring] [EOL] for char in [ [string] , [string] , [string] ] : [EOL] if char in fusion : [EOL] fusion = fusion . replace ( char , [string] ) [EOL] [EOL] return f'{ fusion } [string] ' [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $fusion_report.common.fusion_manager.FusionManager$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $fusion_report.common.fusion_manager.FusionManager$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0
from typing import Dict , Any [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict [EOL] [EOL] from fusion_report . common . base_page import BasePage [EOL] [EOL] [EOL] class Page ( BasePage ) : [EOL] [docstring] [EOL] def __init__ ( self , title , view , filename = None , page_variables = None ) : [EOL] self . __page_variables = { } if not page_variables else page_variables [EOL] super ( ) . __init__ ( title , view , filename ) [EOL] [EOL] def get_content ( self ) : [EOL] [docstring] [EOL] master_content = super ( ) . get_content ( ) [EOL] page_variables = { ** master_content , ** self . __page_variables } [EOL] [EOL] return page_variables [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class DbException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class ConfigException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class AppException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class ReportException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[docstring] [EOL] [EOL] [EOL] class DownloadException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[docstring] [EOL] [EOL] [EOL] class ModuleException ( Exception ) : [EOL] [docstring] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Dict , Any , List [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] from typing import Any , Dict , List [EOL] [EOL] from fusion_report . common . logger import Logger [EOL] [EOL] [EOL] class Fusion : [EOL] [docstring] [EOL] def __init__ ( self , name ) : [EOL] self . name = name . strip ( ) [EOL] self . _score = { [string] : [number] , [string] : [string] } [EOL] self . dbs = [ ] [EOL] self . tools = { } [EOL] [EOL] @ property def score ( self ) : [EOL] return self . _score [ [string] ] [EOL] [EOL] @ score . setter def score ( self , value ) : [EOL] self . _score [ [string] ] = float ( value ) [EOL] [EOL] @ property def score_explained ( self ) : [EOL] [docstring] [EOL] return self . _score [ [string] ] [EOL] [EOL] @ score_explained . setter def score_explained ( self , value ) : [EOL] self . _score [ [string] ] = value [EOL] [EOL] def add_tool ( self , tool , details ) : [EOL] [docstring] [EOL] if tool and tool not in self . tools . keys ( ) : [EOL] self . tools [ tool ] = details [EOL] else : [EOL] Logger ( __name__ ) . debug ( [string] , tool ) [EOL] [EOL] def add_db ( self , database ) : [EOL] [docstring] [EOL] if database and database not in self . dbs : [EOL] self . dbs . append ( database ) [EOL] else : [EOL] Logger ( __name__ ) . debug ( [string] , database ) [EOL] [EOL] def json_serialize ( self ) : [EOL] [docstring] [EOL] json = { [string] : self . name , [string] : self . dbs , [string] : self . score , [string] : self . score_explained , } [EOL] [EOL] return { ** json , ** self . tools } [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.float$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.float$ 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $None$ 0 0 0 $builtins.str$ 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $None$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.Any]$ 0 0 0 0 0 0 0
	0