__version__ = [string] [EOL]	$builtins.str$ 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] import logging [EOL] [EOL] [comment] [EOL] import bel . db [EOL] import bel . edge [EOL] import bel . lang [EOL] import bel . lang . bel_specification as bel_specification [EOL] import bel . nanopub [EOL] import bel . resources [EOL] from bel . lang . belobj import BEL [EOL] [EOL] logging . getLogger ( __name__ ) . addHandler ( logging . NullHandler ( ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import logging . config [EOL] [EOL] [comment] [EOL] from structlog import configure , processors , stdlib , threadlocal [EOL] [EOL] [comment] [EOL] [EOL] logging . config . dictConfig ( { [string] : [number] , [string] : False , [string] : { [string] : { [string] : [string] , [string] : [string] , } } , [string] : { [string] : { [string] : [string] , [string] : [string] } } , [string] : { [string] : { [string] : [ [string] ] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] , [string] : [string] } , [string] : { [string] : [string] } , [string] : { [string] : [string] } , } , } ) [EOL] [EOL] configure ( context_class = threadlocal . wrap_dict ( dict ) , logger_factory = stdlib . LoggerFactory ( ) , wrapper_class = stdlib . BoundLogger , processors = [ stdlib . filter_by_level , stdlib . add_logger_name , stdlib . add_log_level , stdlib . PositionalArgumentsFormatter ( ) , processors . TimeStamper ( fmt = [string] ) , processors . StackInfoRenderer ( ) , processors . format_exc_info , processors . UnicodeDecoder ( ) , stdlib . render_to_log_kwargs , ] , ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Union , Any , Dict , List , Mapping [EOL] import io [EOL] import bel [EOL] import click [EOL] import logging [EOL] import typing [EOL] import gzip [EOL] import json [EOL] import logging [EOL] import logging . config [EOL] import re [EOL] import sys [EOL] [EOL] [comment] [EOL] import click [EOL] import timy [EOL] import yaml [EOL] [EOL] [comment] [EOL] import bel . Config [EOL] import bel . db . arangodb [EOL] import bel . db . elasticsearch [EOL] import bel . edge . edges [EOL] import bel . nanopub . belscripts [EOL] import bel . nanopub . files as bnf [EOL] import bel . nanopub . nanopubs as bnn [EOL] import bel . utils as utils [EOL] from bel . Config import config [EOL] from bel . lang . belobj import BEL [EOL] [EOL] if config . get ( [string] , False ) : [EOL] logging . config . dictConfig ( config . get ( [string] ) ) [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] CONTEXT_SETTINGS = dict ( help_option_names = [ [string] , [string] ] ) [EOL] [EOL] [EOL] class Context ( object ) : [EOL] def __init__ ( self ) : [EOL] self . config = config [EOL] [EOL] [EOL] pass_context = click . make_pass_decorator ( Context , ensure = True ) [EOL] [EOL] [EOL] @ click . group ( context_settings = CONTEXT_SETTINGS ) def belc ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ belc . group ( ) def nanopub ( ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] @ nanopub . command ( name = [string] , context_settings = CONTEXT_SETTINGS ) @ click . option ( [string] , type = click . File ( [string] ) , default = [string] , help = [string] , ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . argument ( [string] ) @ pass_context def nanopub_validate ( ctx , input_fn , output_fn , api , config_fn ) : [EOL] [docstring] [EOL] [EOL] if config_fn : [EOL] config = bel . db . Config . merge_config ( ctx . config , override_config_fn = config_fn ) [EOL] else : [EOL] config = ctx . config [EOL] [EOL] api = utils . first_true ( [ api , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] [EOL] print ( f" [string] { api }" ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ nanopub . command ( name = [string] , context_settings = CONTEXT_SETTINGS ) @ click . option ( [string] , [string] , default = [string] ) @ click . option ( [string] , [string] , default = [string] ) @ pass_context def convert_belscript ( ctx , input_fn , output_fn ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] [EOL] ( out_fh , yaml_flag , jsonl_flag , json_flag ) = bel . nanopub . files . create_nanopubs_fh ( output_fn ) [EOL] if yaml_flag or json_flag : [EOL] docs = [ ] [EOL] [EOL] [comment] [EOL] if re . search ( [string] , input_fn ) : [EOL] f = gzip . open ( input_fn , [string] ) [EOL] else : [EOL] f = open ( input_fn , [string] ) [EOL] [EOL] [comment] [EOL] for doc in bel . nanopub . belscripts . parse_belscript ( f ) : [EOL] if yaml_flag or json_flag : [EOL] docs . append ( doc ) [EOL] elif jsonl_flag : [EOL] out_fh . write ( [string] . format ( json . dumps ( doc ) ) ) [EOL] [EOL] if yaml_flag : [EOL] yaml . dump ( docs , out_fh ) [EOL] [EOL] elif json_flag : [EOL] json . dump ( docs , out_fh , indent = [number] ) [EOL] [EOL] finally : [EOL] f . close ( ) [EOL] out_fh . close ( ) [EOL] [EOL] [EOL] @ nanopub . command ( name = [string] , context_settings = CONTEXT_SETTINGS ) @ click . option ( [string] , [string] ) @ click . option ( [string] , [string] ) @ pass_context def reformat ( ctx , input_fn , output_fn ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] [EOL] ( out_fh , yaml_flag , jsonl_flag , json_flag ) = bel . nanopub . files . create_nanopubs_fh ( output_fn ) [EOL] if yaml_flag or json_flag : [EOL] docs = [ ] [EOL] [EOL] [comment] [EOL] if re . search ( [string] , input_fn ) : [EOL] f = gzip . open ( input_fn , [string] ) [EOL] else : [EOL] f = open ( input_fn , [string] ) [EOL] [EOL] for np in bnf . read_nanopubs ( input_fn ) : [EOL] if yaml_flag or json_flag : [EOL] docs . append ( np ) [EOL] elif jsonl_flag : [EOL] out_fh . write ( [string] . format ( json . dumps ( np ) ) ) [EOL] [EOL] if yaml_flag : [EOL] yaml . dump ( docs , out_fh ) [EOL] [EOL] elif json_flag : [EOL] json . dump ( docs , out_fh , indent = [number] ) [EOL] [EOL] finally : [EOL] f . close ( ) [EOL] out_fh . close ( ) [EOL] [EOL] [EOL] @ nanopub . command ( name = [string] , context_settings = CONTEXT_SETTINGS ) @ click . argument ( [string] ) @ pass_context def nanopub_stats ( ctx , input_fn ) : [EOL] [docstring] [EOL] [EOL] counts = { [string] : [number] , [string] : { [string] : [number] , [string] : [number] , [string] : [number] , [string] : { } } , } [EOL] [EOL] for np in bnf . read_nanopubs ( input_fn ) : [EOL] if [string] in np : [EOL] counts [ [string] ] += [number] [EOL] counts [ [string] ] [ [string] ] += len ( np [ [string] ] [ [string] ] ) [EOL] for assertion in np [ [string] ] [ [string] ] : [EOL] if assertion [ [string] ] is None : [EOL] counts [ [string] ] [ [string] ] += [number] [EOL] else : [EOL] if re . match ( [string] , assertion [ [string] ] ) : [EOL] counts [ [string] ] [ [string] ] += [number] [EOL] [EOL] if not assertion . get ( [string] ) in counts [ [string] ] [ [string] ] : [EOL] counts [ [string] ] [ [string] ] [ assertion . get ( [string] ) ] = [number] [EOL] else : [EOL] counts [ [string] ] [ [string] ] [ assertion . get ( [string] ) ] += [number] [EOL] [EOL] counts [ [string] ] [ [string] ] = sorted ( counts [ [string] ] [ [string] ] ) [EOL] [EOL] print ( [string] , json . dumps ( counts , indent = [number] ) ) [EOL] [EOL] [EOL] @ belc . group ( ) def stmt ( ) : [EOL] [docstring] [EOL] [EOL] pass [EOL] [EOL] [EOL] @ stmt . command ( name = [string] , context_settings = CONTEXT_SETTINGS ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . argument ( [string] ) @ pass_context def stmt_validate ( ctx , statement , version , api , config_fn ) : [EOL] [docstring] [EOL] [EOL] if config_fn : [EOL] config = bel . db . Config . merge_config ( ctx . config , override_config_fn = config_fn ) [EOL] else : [EOL] config = ctx . config [EOL] [EOL] [comment] [EOL] api = utils . first_true ( [ api , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] version = utils . first_true ( [ version , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] . format ( version ) ) [EOL] print ( [string] . format ( api ) ) [EOL] print ( [string] ) [EOL] [EOL] bo = BEL ( version = version , endpoint = api ) [EOL] bo . parse ( statement ) [EOL] [EOL] if bo . ast is None : [EOL] print ( bo . original_bel_stmt ) [EOL] print ( bo . parse_visualize_error ) [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( bo . ast . to_triple ( ) ) [EOL] if bo . validation_messages : [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [EOL] @ stmt . command ( ) @ click . option ( [string] , help = [string] , ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . argument ( [string] ) @ pass_context def canonicalize ( ctx , statement , namespace_targets , version , api , config_fn ) : [EOL] [docstring] [EOL] [EOL] if config_fn : [EOL] config = bel . db . Config . merge_config ( ctx . config , override_config_fn = config_fn ) [EOL] else : [EOL] config = ctx . config [EOL] [EOL] [comment] [EOL] if namespace_targets : [EOL] namespace_targets = json . loads ( namespace_targets ) [EOL] [EOL] namespace_targets = utils . first_true ( [ namespace_targets , config . get ( [string] ) ] , None ) [EOL] api = utils . first_true ( [ api , config . get ( [string] , None ) ] , None ) [EOL] version = utils . first_true ( [ version , config . get ( [string] , None ) ] , None ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] . format ( version ) ) [EOL] print ( [string] . format ( api ) ) [EOL] print ( [string] ) [EOL] [EOL] bo = BEL ( version = version , endpoint = api ) [EOL] bo . parse ( statement ) . canonicalize ( namespace_targets = namespace_targets ) [EOL] [EOL] if bo . ast is None : [EOL] print ( bo . original_bel_stmt ) [EOL] print ( bo . parse_visualize_error ) [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] , bo . original_bel_stmt ) [EOL] print ( [string] , bo . ast ) [EOL] if bo . validation_messages : [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [EOL] @ stmt . command ( ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . argument ( [string] ) @ pass_context def orthologize ( ctx , statement , species , version , api , config_fn ) : [EOL] [docstring] [EOL] [EOL] if config_fn : [EOL] config = bel . db . Config . merge_config ( ctx . config , override_config_fn = config_fn ) [EOL] else : [EOL] config = ctx . config [EOL] [EOL] [comment] [EOL] api_url = utils . first_true ( [ api , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] version = utils . first_true ( [ version , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] . format ( version ) ) [EOL] print ( [string] . format ( api ) ) [EOL] print ( [string] ) [EOL] [EOL] bo = BEL ( version = version , endpoint = api_url ) [EOL] bo . parse ( statement ) . orthologize ( species ) [EOL] [EOL] if bo . ast is None : [EOL] print ( bo . original_bel_stmt ) [EOL] print ( bo . parse_visualize_error ) [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] , bo . original_bel_stmt ) [EOL] print ( [string] , bo . ast ) [EOL] if bo . validation_messages : [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [EOL] @ stmt . command ( ) @ click . option ( [string] , help = [string] , ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] , ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . option ( [string] , help = [string] ) @ click . argument ( [string] ) @ pass_context def edges ( ctx , statement , rules , species , namespace_targets , version , api , config_fn ) : [EOL] [docstring] [EOL] [EOL] if config_fn : [EOL] config = bel . db . Config . merge_config ( ctx . config , override_config_fn = config_fn ) [EOL] else : [EOL] config = ctx . config [EOL] [EOL] [comment] [EOL] if namespace_targets : [EOL] namespace_targets = json . loads ( namespace_targets ) [EOL] if rules : [EOL] rules = rules . replace ( [string] , [string] ) . split ( [string] ) [EOL] [EOL] namespace_targets = utils . first_true ( [ namespace_targets , config [ [string] ] [ [string] ] . get ( [string] ) ] , None ) [EOL] api_url = utils . first_true ( [ api , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] version = utils . first_true ( [ version , config [ [string] ] [ [string] ] . get ( [string] , None ) ] , None ) [EOL] [EOL] print ( [string] ) [EOL] print ( [string] . format ( version ) ) [EOL] print ( [string] . format ( api ) ) [EOL] print ( [string] ) [EOL] [EOL] bo = BEL ( version = version , endpoint = api_url ) [EOL] if species : [EOL] edges = ( bo . parse ( statement ) . orthologize ( species ) . canonicalize ( namespace_targets = namespace_targets ) . compute_edges ( rules = rules ) ) [EOL] else : [EOL] edges = ( bo . parse ( statement ) . canonicalize ( namespace_targets = namespace_targets ) . compute_edges ( rules = rules ) ) [EOL] [EOL] if edges is None : [EOL] print ( bo . original_bel_stmt ) [EOL] print ( bo . parse_visualize_error ) [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( json . dumps ( edges , indent = [number] ) ) [EOL] [EOL] if bo . validation_messages : [EOL] print ( bo . validation_messages ) [EOL] else : [EOL] print ( [string] ) [EOL] return [EOL] [EOL] [EOL] @ belc . group ( ) def db ( ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] @ db . command ( ) @ click . option ( [string] , default = False , help = [string] ) @ click . option ( [string] , default = [string] , help = [string] ) def elasticsearch ( delete , index_name ) : [EOL] [docstring] [EOL] [EOL] if delete : [EOL] bel . db . elasticsearch . get_client ( delete = True ) [EOL] else : [EOL] bel . db . elasticsearch . get_client ( ) [EOL] [EOL] [EOL] @ db . command ( ) @ click . argument ( [string] , default = [string] ) @ click . option ( [string] , default = False , help = [string] ) def arangodb ( delete , db_name ) : [EOL] [docstring] [EOL] [EOL] if delete : [EOL] arango_client = bel . db . arangodb . get_client ( ) [EOL] if not arango_client : [EOL] print ( [string] ) [EOL] quit ( ) [EOL] bel . db . arangodb . delete_database ( arango_client , db_name ) [EOL] [EOL] if db_name == [string] : [EOL] bel . db . arangodb . get_belns_handle ( client ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,typing.List[builtins.str]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $click.decorators._IdentityFunction$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import builtins [EOL] import arango [EOL] import typing [EOL] import re [EOL] [EOL] [comment] [EOL] import arango [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] import bel . utils as utils [EOL] from bel . Config import config [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] edgestore_db_name = [string] [EOL] belns_db_name = [string] [EOL] belapi_db_name = [string] [EOL] [EOL] edgestore_nodes_name = [string] [comment] [EOL] edgestore_edges_name = [string] [comment] [EOL] edgestore_pipeline_name = [string] [comment] [EOL] [EOL] [EOL] equiv_nodes_name = [string] [comment] [EOL] equiv_edges_name = [string] [comment] [EOL] ortholog_nodes_name = [string] [comment] [EOL] ortholog_edges_name = [string] [comment] [EOL] belns_metadata_name = [string] [comment] [EOL] [EOL] belapi_settings_name = [string] [comment] [EOL] belapi_statemgmt_name = [string] [comment] [EOL] [EOL] bel_validations_name = [string] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def get_user_creds ( username , password ) : [EOL] [docstring] [EOL] username = utils . first_true ( [ username , config [ [string] ] [ [string] ] [ [string] ] ] , default = [string] ) [EOL] password = utils . first_true ( [ password , config [ [string] ] [ [string] ] [ [string] ] . get ( [string] ) ] , default = [string] ) [EOL] [EOL] return username , password [EOL] [EOL] [EOL] def get_client ( host = None , port = None , username = None , password = None , enable_logging = True ) : [EOL] [docstring] [EOL] [EOL] host = utils . first_true ( [ host , config [ [string] ] [ [string] ] [ [string] ] , [string] ] ) [EOL] port = utils . first_true ( [ port , config [ [string] ] [ [string] ] [ [string] ] , [number] ] ) [EOL] username = utils . first_true ( [ username , config [ [string] ] [ [string] ] [ [string] ] , [string] ] ) [EOL] password = utils . first_true ( [ password , config . get ( [string] , config [ [string] ] [ [string] ] [ [string] ] . get ( [string] ) ) , [string] , ] ) [EOL] [EOL] arango_url = f" [string] { host } [string] { port }" [EOL] try : [EOL] client = arango . ArangoClient ( hosts = arango_url ) [EOL] client . db ( verify = True ) [EOL] return client [EOL] [EOL] except Exception as e : [EOL] log . error ( f" [string] { arango_url }" ) [EOL] return None [EOL] [EOL] [EOL] def aql_query ( db , query ) : [EOL] [docstring] [EOL] [EOL] result = db . aql . execute ( query ) [EOL] return result [EOL] [EOL] [EOL] def get_edgestore_handle ( client , username = None , password = None , edgestore_db_name = edgestore_db_name , edgestore_edges_name = edgestore_edges_name , edgestore_nodes_name = edgestore_nodes_name , edgestore_pipeline_name = edgestore_pipeline_name , ) : [EOL] [docstring] [EOL] [EOL] ( username , password ) = get_user_creds ( username , password ) [EOL] [EOL] [comment] [EOL] sys_db = client . db ( [string] , username = username , password = password ) [EOL] [EOL] [comment] [EOL] if sys_db . has_database ( edgestore_db_name ) : [EOL] if username and password : [EOL] edgestore_db = client . db ( edgestore_db_name , username = username , password = password ) [EOL] else : [EOL] edgestore_db = client . db ( edgestore_db_name ) [EOL] else : [EOL] if username and password : [EOL] sys_db . create_database ( name = edgestore_db_name , users = [ { [string] : username , [string] : password , [string] : True } ] , ) [EOL] else : [EOL] sys_db . create_database ( name = edgestore_db_name ) [EOL] edgestore_db = client . db ( edgestore_db_name ) [EOL] [EOL] [comment] [EOL] if edgestore_db . has_collection ( edgestore_edges_name ) : [EOL] edges_coll = edgestore_db . collection ( edgestore_edges_name ) [EOL] else : [EOL] edges_coll = edgestore_db . create_collection ( edgestore_edges_name , edge = True , index_bucket_count = [number] ) [EOL] edges_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] edges_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] edges_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] edges_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] edges_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] [EOL] [comment] [EOL] if edgestore_db . has_collection ( edgestore_nodes_name ) : [EOL] nodes_coll = edgestore_db . collection ( edgestore_nodes_name ) [EOL] else : [EOL] nodes_coll = edgestore_db . create_collection ( edgestore_nodes_name , index_bucket_count = [number] ) [EOL] nodes_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] nodes_coll . add_hash_index ( fields = [ [string] ] , unique = False ) [EOL] [EOL] [comment] [EOL] if edgestore_db . has_collection ( edgestore_pipeline_name ) : [EOL] pipeline_coll = edgestore_db . collection ( edgestore_pipeline_name ) [EOL] else : [EOL] pipeline_coll = edgestore_db . create_collection ( edgestore_pipeline_name , index_bucket_count = [number] ) [EOL] pipeline_coll . add_persistent_index ( fields = [ [string] ] , sparse = False ) [EOL] [EOL] return edgestore_db [EOL] [EOL] [EOL] def get_belns_handle ( client , username = None , password = None ) : [EOL] [docstring] [EOL] [EOL] ( username , password ) = get_user_creds ( username , password ) [EOL] [EOL] sys_db = client . db ( [string] , username = username , password = password ) [EOL] [EOL] [comment] [EOL] if sys_db . has_database ( belns_db_name ) : [EOL] if username and password : [EOL] belns_db = client . db ( belns_db_name , username = username , password = password ) [EOL] else : [EOL] belns_db = client . db ( belns_db_name ) [EOL] else : [EOL] if username and password : [EOL] belns_db = sys_db . create_database ( name = belns_db_name , users = [ { [string] : username , [string] : password , [string] : True } ] , ) [EOL] else : [EOL] belns_db = sys_db . create_database ( name = belns_db_name ) [EOL] [EOL] if belns_db . has_collection ( belns_metadata_name ) : [EOL] belns_metadata = belns_db . collection ( belns_metadata_name ) [EOL] else : [EOL] belns_metadata = belns_db . create_collection ( belns_metadata_name ) [EOL] [EOL] if belns_db . has_collection ( equiv_nodes_name ) : [EOL] equiv_nodes = belns_db . collection ( equiv_nodes_name ) [EOL] else : [EOL] equiv_nodes = belns_db . create_collection ( equiv_nodes_name ) [EOL] equiv_nodes . add_hash_index ( fields = [ [string] ] , unique = True ) [EOL] [EOL] if belns_db . has_collection ( equiv_edges_name ) : [EOL] equiv_edges = belns_db . collection ( equiv_edges_name ) [EOL] else : [EOL] equiv_edges = belns_db . create_collection ( equiv_edges_name ) [EOL] [EOL] if belns_db . has_collection ( ortholog_nodes_name ) : [EOL] ortholog_nodes = belns_db . collection ( ortholog_nodes_name ) [EOL] else : [EOL] ortholog_nodes = belns_db . create_collection ( ortholog_nodes_name ) [EOL] ortholog_nodes . add_hash_index ( fields = [ [string] ] , unique = True ) [EOL] [EOL] if belns_db . has_collection ( ortholog_edges_name ) : [EOL] ortholog_edges = belns_db . collection ( ortholog_edges_name ) [EOL] else : [EOL] ortholog_edges = belns_db . create_collection ( ortholog_edges_name ) [EOL] [EOL] return belns_db [EOL] [EOL] [EOL] def get_belapi_handle ( client , username = None , password = None ) : [EOL] [docstring] [EOL] [EOL] ( username , password ) = get_user_creds ( username , password ) [EOL] [EOL] sys_db = client . db ( [string] , username = username , password = password ) [EOL] [EOL] [comment] [EOL] if sys_db . has_database ( belapi_db_name ) : [EOL] if username and password : [EOL] belapi_db = client . db ( belapi_db_name , username = username , password = password ) [EOL] else : [EOL] belapi_db = client . db ( belapi_db_name ) [EOL] else : [EOL] if username and password : [EOL] sys_db . create_database ( name = belapi_db_name , users = [ { [string] : username , [string] : password , [string] : True } ] , ) [EOL] else : [EOL] sys_db . create_database ( name = belapi_db_name ) [EOL] [EOL] belapi_db = client . db ( belapi_db_name ) [EOL] [EOL] if belapi_db . has_collection ( belapi_settings_name ) : [EOL] belapi_settings_coll = belapi_db . collection ( belapi_settings_name ) [EOL] else : [EOL] belapi_settings_coll = belapi_db . create_collection ( belapi_settings_name , index_bucket_count = [number] ) [EOL] [EOL] if belapi_db . has_collection ( belapi_statemgmt_name ) : [EOL] belapi_statemgmt_coll = belapi_db . collection ( belapi_statemgmt_name ) [EOL] else : [EOL] belapi_statemgmt_coll = belapi_db . create_collection ( belapi_statemgmt_name , index_bucket_count = [number] ) [EOL] [EOL] if belapi_db . has_collection ( bel_validations_name ) : [EOL] bel_validations = belapi_db . collection ( bel_validations_name ) [EOL] else : [EOL] bel_validations = belapi_db . create_collection ( bel_validations_name , index_bucket_count = [number] ) [EOL] [EOL] return belapi_db [EOL] [EOL] [EOL] def delete_database ( client , db_name , username = None , password = None ) : [EOL] [docstring] [EOL] [EOL] ( username , password ) = get_user_creds ( username , password ) [EOL] [EOL] sys_db = client . db ( [string] , username = username , password = password ) [EOL] [EOL] try : [EOL] return sys_db . delete_database ( db_name ) [EOL] except Exception : [EOL] log . warn ( [string] ) [EOL] [EOL] [EOL] def batch_load_docs ( db , doc_iterator , on_duplicate = [string] ) : [EOL] [docstring] [EOL] [EOL] batch_size = [number] [EOL] [EOL] counter = [number] [EOL] collections = { } [EOL] docs = { } [EOL] [EOL] if on_duplicate not in [ [string] , [string] , [string] , [string] ] : [EOL] log . error ( f" [string] { on_duplicate }" ) [EOL] return [EOL] [EOL] for ( collection_name , doc ) in doc_iterator : [EOL] if collection_name not in collections : [EOL] collections [ collection_name ] = db . collection ( collection_name ) [EOL] docs [ collection_name ] = [ ] [EOL] [EOL] counter += [number] [EOL] [EOL] docs [ collection_name ] . append ( doc ) [EOL] [EOL] if counter % batch_size == [number] : [EOL] log . info ( f" [string] { counter }" ) [EOL] for cname in docs : [EOL] collections [ cname ] . import_bulk ( docs [ cname ] , on_duplicate = on_duplicate , halt_on_error = False ) [EOL] docs [ cname ] = [ ] [EOL] [EOL] log . info ( f" [string] { counter }" ) [EOL] for cname in docs : [EOL] collections [ cname ] . import_bulk ( docs [ cname ] , on_duplicate = on_duplicate , halt_on_error = False ) [EOL] docs [ cname ] = [ ] [EOL] [EOL] [EOL] def arango_id_to_key ( _id ) : [EOL] [docstring] [EOL] [EOL] key = re . sub ( [string] , [string] , _id ) [EOL] if len ( key ) > [number] : [EOL] log . error ( f" [string] { len ( key ) } [string] { key }" ) [EOL] elif len ( key ) < [number] : [EOL] log . error ( f" [string] { len ( key ) } [string] { key }" ) [EOL] [EOL] return key [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $arango.database.StandardDatabase$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import logging [EOL] import logging [EOL] import os [EOL] [EOL] [comment] [EOL] import elasticsearch . helpers [EOL] import yaml [EOL] from elasticsearch import Elasticsearch [EOL] [EOL] [comment] [EOL] from bel . Config import config [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] cur_dir_name = os . path . dirname ( os . path . realpath ( __file__ ) ) [EOL] mappings_terms_fn = f"{ cur_dir_name } [string] " [EOL] terms_alias = [string] [EOL] [EOL] [EOL] def get_all_index_names ( es ) : [EOL] [docstring] [EOL] [EOL] indices = es . indices . get_alias ( ) [EOL] [EOL] return indices [EOL] [EOL] [EOL] def add_index_alias ( es , index_name , alias_name ) : [EOL] [docstring] [EOL] [EOL] es . indices . put_alias ( index = index_name , name = terms_alias ) [EOL] [EOL] [EOL] def index_exists ( es , index_name ) : [EOL] [docstring] [EOL] return es . indices . exists ( index = index_name ) [EOL] [EOL] [EOL] def delete_index ( es , index_name ) : [EOL] [docstring] [EOL] [EOL] if not index_name : [EOL] log . warn ( [string] ) [EOL] return None [EOL] [EOL] result = es . indices . delete ( index = index_name ) [EOL] return result [EOL] [EOL] [EOL] def create_terms_index ( es , index_name ) : [EOL] [docstring] [EOL] [EOL] with open ( mappings_terms_fn , [string] ) as f : [EOL] mappings_terms = yaml . load ( f , Loader = yaml . SafeLoader ) [EOL] [EOL] try : [EOL] es . indices . create ( index = index_name , body = mappings_terms ) [EOL] [EOL] except Exception as e : [EOL] log . error ( f" [string] { e }" ) [EOL] [EOL] [EOL] def delete_terms_indexes ( es , index_name = [string] ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] es . indices . delete ( index = index_name ) [EOL] except Exception as e : [EOL] log . error ( f" [string] { e }" ) [EOL] [EOL] [EOL] def get_client ( ) : [EOL] [docstring] [EOL] [EOL] es = Elasticsearch ( [ config [ [string] ] [ [string] ] [ [string] ] ] , send_get_body_as = [string] ) [EOL] [EOL] return es [EOL] [EOL] [EOL] def bulk_load_docs ( es , docs ) : [EOL] [docstring] [EOL] [EOL] chunk_size = [number] [EOL] [EOL] try : [EOL] results = elasticsearch . helpers . bulk ( es , docs , chunk_size = chunk_size ) [EOL] log . debug ( f" [string] { results [ [number] ] }" ) [EOL] [EOL] [comment] [EOL] if len ( results [ [number] ] ) > [number] : [EOL] log . error ( [string] . format ( results ) ) [EOL] except elasticsearch . ElasticsearchException as e : [EOL] log . error ( [string] . format ( e ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL]	0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Mapping , Tuple [EOL] import builtins [EOL] import bel [EOL] import typing [EOL] import logging [EOL] import gzip [EOL] import logging [EOL] from typing import Any , Iterable , List , Mapping , Tuple [EOL] [EOL] [comment] [EOL] import jsonschema [EOL] from cityhash import CityHash64 [EOL] [EOL] [comment] [EOL] import bel . edge . edges [EOL] import bel . lang . belobj [EOL] from bel . Config import config [EOL] from bel . utils import http_client [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] class Nanopub ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , endpoint = config . get ( [string] , [string] ) ) : [EOL] [docstring] [EOL] self . endpoint = endpoint [EOL] [EOL] def validate ( self , nanopub ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] ( is_valid , messages ) = validate_to_schema ( nanopub , self . nanopub_schema ) [EOL] if not is_valid : [EOL] return messages [EOL] [EOL] [comment] [EOL] if nanopub [ [string] ] [ [string] ] [ [string] ] . upper ( ) == [string] : [EOL] bel_version = nanopub [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] is_valid = False [EOL] return ( is_valid , f" [string] { nanopub [ [string] ] [ [string] ] [ [string] ] }" , ) [EOL] [EOL] all_messages = [ ] [EOL] [comment] [EOL] bel_obj = bel . lang . belobj . BEL ( bel_version , self . endpoint ) [EOL] for edge in nanopub [ [string] ] [ [string] ] : [EOL] bel_statement = f"{ edge [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] }" [EOL] parse_obj = bel_obj . parse ( bel_statement ) [EOL] if not parse_obj . valid : [EOL] all_messages . extend ( ( [string] , f" [string] { parse_obj . error } [string] { parse_obj . err_visual }" , ) ) [EOL] [EOL] [comment] [EOL] for context in nanopub [ [string] ] [ [string] ] : [EOL] ( is_valid , messages ) = self . validate_context ( context ) [EOL] all_messages . extend ( messages ) [EOL] [EOL] is_valid = True [EOL] for _type , msg in all_messages : [EOL] if _type == [string] : [EOL] is_valid = False [EOL] [EOL] return ( is_valid , all_messages ) [EOL] [EOL] def validate_context ( self , context ) : [EOL] [docstring] [EOL] [EOL] url = f'{ self . endpoint } [string] { context [ [string] ] }' [EOL] [EOL] res = http_client . get ( url ) [EOL] if res . status_code == [number] : [EOL] return ( True , [ ] ) [EOL] else : [EOL] return ( False , [ ( [string] , f' [string] { context [ [string] ] } [string] { url }' ) ] ) [EOL] [EOL] def bel_edges ( self , nanopub , namespace_targets = { } , rules = [ ] , orthologize_target = None , ) : [EOL] [docstring] [EOL] [EOL] edges = bel . edge . edges . create_edges ( nanopub , self . endpoint , namespace_targets = namespace_targets , rules = rules , orthologize_target = orthologize_target , ) [EOL] [EOL] return edges [EOL] [EOL] [EOL] def validate_to_schema ( nanopub , schema ) : [EOL] [docstring] [EOL] [EOL] v = jsonschema . Draft4Validator ( schema ) [EOL] messages = [ ] [EOL] errors = sorted ( v . iter_errors ( nanopub ) , key = lambda e : e . path ) [EOL] for error in errors : [EOL] for suberror in sorted ( error . context , key = lambda e : e . schema_path ) : [EOL] print ( list ( suberror . schema_path ) , suberror . message , sep = [string] ) [EOL] messages . append ( ( [string] , suberror . message ) ) [EOL] [EOL] is_valid = True [EOL] if errors : [EOL] is_valid = False [EOL] [EOL] return ( is_valid , messages ) [EOL] [EOL] [EOL] [comment] [EOL] def hash_nanopub ( nanopub ) : [EOL] [docstring] [EOL] [EOL] hash_list = [ ] [EOL] [EOL] [comment] [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] [EOL] [comment] [EOL] if nanopub [ [string] ] [ [string] ] . get ( [string] , False ) : [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] elif nanopub [ [string] ] [ [string] ] . get ( [string] , False ) : [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] elif nanopub [ [string] ] [ [string] ] . get ( [string] , False ) : [EOL] hash_list . append ( nanopub [ [string] ] [ [string] ] . get ( [string] , [string] ) . strip ( ) ) [EOL] [EOL] [comment] [EOL] assertions = [ ] [EOL] for assertion in nanopub [ [string] ] [ [string] ] : [EOL] if assertion . get ( [string] ) is None : [EOL] assertion [ [string] ] = [string] [EOL] if assertion . get ( [string] ) is None : [EOL] assertion [ [string] ] = [string] [EOL] assertions . append ( [string] . join ( ( assertion [ [string] ] . strip ( ) , assertion . get ( [string] , [string] ) . strip ( ) , assertion . get ( [string] , [string] ) . strip ( ) , ) ) . strip ( ) ) [EOL] assertions = sorted ( assertions ) [EOL] hash_list . extend ( assertions ) [EOL] [EOL] [comment] [EOL] annotations = [ ] [EOL] [EOL] for anno in nanopub [ [string] ] [ [string] ] : [EOL] annotations . append ( [string] . join ( ( anno . get ( [string] , [string] ) . strip ( ) , anno . get ( [string] , [string] ) . strip ( ) ) ) . strip ( ) ) [EOL] [EOL] annotations = sorted ( annotations ) [EOL] hash_list . extend ( annotations ) [EOL] [EOL] np_string = [string] . join ( [ l . lower ( ) for l in hash_list ] ) [EOL] [EOL] return [string] . format ( CityHash64 ( np_string ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL]	0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Match , Any , Dict , List , Optional [EOL] import builtins [EOL] import typing [EOL] import _csv [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import collections [EOL] import copy [EOL] import csv [EOL] import gzip [EOL] import json [EOL] import re [EOL] import sys [EOL] [EOL] [comment] [EOL] import structlog [EOL] import yaml [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] [EOL] nanopub_type = { [string] : [string] , [string] : [string] } [EOL] [EOL] [EOL] def convert_csv_str_to_list ( csv_str ) : [EOL] [docstring] [EOL] [EOL] csv_str = re . sub ( [string] , [string] , csv_str ) [EOL] csv_str = re . sub ( [string] , [string] , csv_str ) [EOL] r = csv . reader ( [ csv_str ] ) [EOL] row = list ( r ) [ [number] ] [EOL] new = [ ] [EOL] for col in row : [EOL] col = re . sub ( [string] , [string] , col ) [EOL] col = re . sub ( [string] , [string] , col ) [EOL] new . append ( col ) [EOL] [EOL] return new [EOL] [EOL] [EOL] def process_citation ( citation_str ) : [EOL] [docstring] [EOL] [EOL] citation_obj = { } [EOL] [EOL] citation_list = convert_csv_str_to_list ( citation_str ) [EOL] ( citation_type , name , doc_id , pub_date , authors , comment , * extra ) = citation_list + [ None ] * [number] [EOL] [comment] [EOL] [EOL] authors_list = [ ] [EOL] if authors : [EOL] authors_list = authors . split ( [string] ) [EOL] citation_obj [ [string] ] = authors_list [EOL] [EOL] if name and re . match ( [string] , name ) : [EOL] citation_obj [ [string] ] = name [EOL] [EOL] elif citation_type and citation_type . upper ( ) == [string] : [EOL] citation_obj [ [string] ] = { [string] : [string] , [string] : doc_id } [EOL] if name : [EOL] citation_obj [ [string] ] = name [EOL] elif name : [EOL] citation_obj [ [string] ] = name [EOL] [EOL] else : [EOL] citation_obj [ [string] ] = [string] [EOL] [EOL] if pub_date : [EOL] citation_obj [ [string] ] = pub_date [EOL] [EOL] if comment : [EOL] citation_obj [ [string] ] = comment [EOL] [EOL] return citation_obj [EOL] [EOL] [EOL] def yield_metadata ( nanopubs_metadata ) : [EOL] [docstring] [EOL] [EOL] return { [string] : copy . deepcopy ( nanopubs_metadata ) } [EOL] [EOL] [EOL] def split_bel_stmt ( stmt , line_num ) : [EOL] [docstring] [EOL] [EOL] m = re . match ( f" [string] " , stmt , flags = [number] ) [EOL] if m : [EOL] return ( m . group ( [number] ) , m . group ( [number] ) , m . group ( [number] ) ) [EOL] else : [EOL] log . info ( f" [string] { line_num } [string] { stmt }" ) [EOL] return ( stmt , None , None ) [EOL] [EOL] [EOL] def yield_nanopub ( assertions , annotations , line_num ) : [EOL] [docstring] [EOL] [EOL] if not assertions : [EOL] return { } [EOL] [EOL] anno = copy . deepcopy ( annotations ) [EOL] [EOL] evidence = anno . pop ( [string] , None ) [EOL] stmt_group = anno . pop ( [string] , None ) [EOL] citation = anno . pop ( [string] , None ) [EOL] [EOL] anno_list = [ ] [EOL] for anno_type in anno : [EOL] if isinstance ( anno [ anno_type ] , ( list , tuple ) ) : [EOL] for val in anno [ anno_type ] : [EOL] anno_list . append ( { [string] : anno_type , [string] : val } ) [EOL] else : [EOL] anno_list . append ( { [string] : anno_type , [string] : anno [ anno_type ] } ) [EOL] [EOL] assertions_list = [ ] [EOL] for assertion in assertions : [EOL] ( subj , rel , obj ) = split_bel_stmt ( assertion , line_num ) [EOL] assertions_list . append ( { [string] : subj , [string] : rel , [string] : obj } ) [EOL] [EOL] nanopub = { [string] : [string] , [string] : copy . deepcopy ( nanopub_type ) , [string] : copy . deepcopy ( anno_list ) , [string] : copy . deepcopy ( citation ) , [string] : copy . deepcopy ( assertions_list ) , [string] : evidence , [string] : { [string] : stmt_group } , } [EOL] [EOL] return { [string] : copy . deepcopy ( nanopub ) } [EOL] [EOL] [EOL] def process_documentline ( line , nanopubs_metadata ) : [EOL] [docstring] [EOL] [EOL] matches = re . match ( [string] , line ) [EOL] key = matches . group ( [number] ) [EOL] val = matches . group ( [number] ) [EOL] nanopubs_metadata [ key ] = val [EOL] [EOL] return nanopubs_metadata [EOL] [EOL] [EOL] def process_definition ( line , nanopubs_metadata ) : [EOL] [docstring] [EOL] [EOL] matches = re . match ( [string] , line ) [EOL] if matches : [EOL] def_type = matches . group ( [number] ) . lower ( ) [EOL] if def_type == [string] : [EOL] def_type = [string] [EOL] elif def_type == [string] : [EOL] def_type == [string] [EOL] [EOL] key = matches . group ( [number] ) [EOL] val = matches . group ( [number] ) [EOL] [EOL] if def_type in nanopubs_metadata : [EOL] nanopubs_metadata [ def_type ] [ key ] = val [EOL] else : [EOL] nanopubs_metadata [ def_type ] = { key : val } [EOL] [EOL] matches = re . match ( [string] , line ) [EOL] if matches : [EOL] def_type = matches . group ( [number] ) . lower ( ) [EOL] if def_type == [string] : [EOL] def_type = [string] [EOL] elif def_type == [string] : [EOL] def_type == [string] [EOL] [EOL] key = matches . group ( [number] ) [EOL] val = matches . group ( [number] ) [EOL] vals = convert_csv_str_to_list ( val ) [EOL] [EOL] if def_type in nanopubs_metadata : [EOL] nanopubs_metadata [ def_type ] [ key ] = vals [EOL] else : [EOL] nanopubs_metadata [ def_type ] = { key : vals } [EOL] [EOL] return nanopubs_metadata [EOL] [EOL] [EOL] def process_unset ( line , annotations ) : [EOL] [docstring] [EOL] [EOL] matches = re . match ( [string] , line ) [EOL] if matches : [EOL] val = matches . group ( [number] ) [EOL] if val == [string] or val == [string] : [EOL] annotations = { } [EOL] elif re . match ( [string] , val ) : [EOL] vals = convert_csv_str_to_list ( val ) [EOL] for val in vals : [EOL] annotations . pop ( val , None ) [EOL] else : [EOL] annotations . pop ( val , None ) [EOL] [EOL] else : [EOL] log . warn ( f" [string] { line }" ) [EOL] [EOL] return annotations [EOL] [EOL] [EOL] def process_set ( line , annotations ) : [EOL] [docstring] [EOL] [EOL] matches = re . match ( [string] , line ) [EOL] [EOL] key = None [EOL] if matches : [EOL] key = matches . group ( [number] ) [EOL] val = matches . group ( [number] ) [EOL] [EOL] if key == [string] : [EOL] annotations [ [string] ] = val [EOL] elif key == [string] : [EOL] annotations [ [string] ] = process_citation ( val ) [EOL] elif key . lower ( ) == [string] or key . lower ( ) == [string] : [EOL] annotations [ [string] ] = val [EOL] elif re . match ( [string] , val ) : [EOL] vals = convert_csv_str_to_list ( val ) [EOL] annotations [ key ] = vals [EOL] else : [EOL] annotations [ key ] = val [EOL] [EOL] return annotations [EOL] [EOL] [EOL] def set_single_line ( lines ) : [EOL] [EOL] flag = False [EOL] hold = [string] [EOL] [EOL] for line in lines : [EOL] if flag and re . match ( [string] , line ) : [EOL] line = hold + [string] + line [EOL] flag = False [EOL] line = re . sub ( [string] , [string] , line ) [EOL] yield line [EOL] elif flag : [EOL] hold += [string] + line . rstrip ( ) [EOL] [EOL] elif re . match ( [string] , line ) : [EOL] line = re . sub ( [string] , [string] , line ) [EOL] yield line [EOL] elif re . match ( [string] , line ) : [EOL] hold = line . rstrip ( ) [EOL] flag = True [EOL] else : [EOL] line = re . sub ( [string] , [string] , line ) [EOL] yield line [EOL] [EOL] [EOL] def preprocess_belscript ( lines ) : [EOL] [docstring] [EOL] [EOL] set_flag = False [EOL] for line in lines : [EOL] if set_flag is False and re . match ( [string] , line ) : [EOL] set_flag = True [EOL] set_line = [ line . rstrip ( ) ] [EOL] [comment] [EOL] elif set_flag and re . match ( [string] , line ) : [EOL] yield f"{ [string] . join ( set_line ) } [string] " [EOL] set_line = [ line . rstrip ( ) ] [EOL] [comment] [EOL] elif set_flag and re . match ( [string] , line ) : [EOL] yield f"{ [string] . join ( set_line ) } [string] " [EOL] yield line [EOL] set_flag = False [EOL] [EOL] [comment] [EOL] elif set_flag : [EOL] set_line . append ( line . rstrip ( ) ) [EOL] else : [EOL] yield line [EOL] [EOL] [EOL] def parse_belscript ( lines ) : [EOL] [docstring] [EOL] [EOL] nanopubs_metadata = { } [EOL] annotations = { } [EOL] assertions = [ ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] line_num = [number] [EOL] [EOL] [comment] [EOL] for line in set_single_line ( lines ) : [EOL] [EOL] line_num += [number] [EOL] [comment] [EOL] line = re . sub ( [string] , [string] , line ) [EOL] [EOL] line = line . rstrip ( ) [EOL] [EOL] [comment] [EOL] while re . search ( [string] , line ) : [EOL] line = line . replace ( [string] , [string] ) + next ( lines ) [EOL] [EOL] [comment] [EOL] if re . match ( [string] , line ) or re . match ( [string] , line ) : [EOL] [comment] [EOL] continue [EOL] elif re . match ( [string] , line ) : [EOL] nanopubs_metadata = process_documentline ( line , nanopubs_metadata ) [EOL] elif re . match ( [string] , line ) : [EOL] nanopubs_metadata = process_definition ( line , nanopubs_metadata ) [EOL] elif re . match ( [string] , line ) : [EOL] [EOL] [comment] [EOL] if assertions : [EOL] yield yield_nanopub ( assertions , annotations , line_num ) [EOL] assertions = [ ] [EOL] annotations = process_unset ( line , annotations ) [EOL] [EOL] elif re . match ( [string] , line ) : [EOL] [comment] [EOL] if nanopubs_metadata : [EOL] yield yield_metadata ( nanopubs_metadata ) [EOL] nanopubs_metadata = { } [EOL] [EOL] [comment] [EOL] if assertions : [EOL] yield yield_nanopub ( assertions , annotations , line_num ) [EOL] assertions = [ ] [EOL] [EOL] annotations = process_set ( line , annotations ) [EOL] [EOL] else : [EOL] assertions . append ( line ) [EOL] [EOL] [comment] [EOL] yield_nanopub ( assertions , annotations , line_num ) [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] with open ( [string] , [string] ) as f : [EOL] for doc in parse_belscript ( f ) : [EOL] print ( json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] quit ( ) [EOL] [EOL] bel = [string] [EOL] print ( split_bel_stmt ( bel ) ) [EOL] quit ( ) [EOL] [EOL] citation_str = [string] [EOL] print ( process_citation ( citation_str ) ) [EOL] quit ( ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.list$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.tuple$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Dict[builtins.str,builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Iterator , Union , TextIO , Any , Dict , List , Iterable , Mapping [EOL] import builtins [EOL] import typing [EOL] import io [EOL] import logging [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import gzip [EOL] import json [EOL] import logging [EOL] import re [EOL] import sys [EOL] from typing import Any , Iterable , List , Mapping , Tuple [EOL] [EOL] [comment] [EOL] import click [EOL] import yaml [EOL] [EOL] log = logging . getLogger ( __name__ ) [EOL] [EOL] [EOL] def read_nanopubs ( fn ) : [EOL] [docstring] [EOL] [EOL] jsonl_flag , json_flag , yaml_flag = False , False , False [EOL] if fn == [string] or [string] in fn : [EOL] jsonl_flag = True [EOL] elif [string] in fn : [EOL] json_flag = True [EOL] elif re . search ( [string] , fn ) : [EOL] yaml_flag = True [EOL] else : [EOL] log . error ( [string] ) [EOL] return { } [EOL] [EOL] try : [EOL] if re . search ( [string] , fn ) : [EOL] f = gzip . open ( fn , [string] ) [EOL] else : [EOL] try : [EOL] f = click . open_file ( fn , mode = [string] ) [EOL] except Exception as e : [EOL] log . info ( f" [string] { fn } [string] { e }" ) [EOL] quit ( ) [EOL] [EOL] if jsonl_flag : [EOL] for line in f : [EOL] yield json . loads ( line ) [EOL] elif json_flag : [EOL] nanopubs = json . load ( f ) [EOL] for nanopub in nanopubs : [EOL] yield nanopub [EOL] elif yaml_flag : [EOL] nanopubs = yaml . load ( f , Loader = yaml . SafeLoader ) [EOL] for nanopub in nanopubs : [EOL] yield nanopub [EOL] [EOL] except Exception as e : [EOL] log . exception ( f" [string] { fn }" ) [EOL] [EOL] [EOL] def create_nanopubs_fh ( output_fn ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] json_flag , jsonl_flag , yaml_flag = False , False , False [EOL] if output_fn : [EOL] if re . search ( [string] , output_fn ) : [EOL] out_fh = gzip . open ( output_fn , [string] ) [EOL] else : [EOL] out_fh = click . open_file ( output_fn , mode = [string] ) [EOL] [EOL] if re . search ( [string] , output_fn ) : [EOL] yaml_flag = True [EOL] elif [string] in output_fn or [string] == output_fn : [EOL] jsonl_flag = True [EOL] elif [string] in output_fn : [EOL] json_flag = True [EOL] [EOL] else : [EOL] out_fh = sys . stdout [EOL] [EOL] return ( out_fh , yaml_flag , jsonl_flag , json_flag ) [EOL] [EOL] [EOL] def read_edges ( fn ) : [EOL] [EOL] if not fn : [EOL] return [ ] [EOL] jsonl_flag , json_flag , yaml_flag = False , False , False [EOL] if [string] in fn : [EOL] jsonl_flag = True [EOL] elif [string] in fn : [EOL] json_flag = True [EOL] elif re . search ( [string] , fn ) : [EOL] yaml_flag = True [EOL] else : [EOL] log . error ( [string] ) [EOL] return [ ] [EOL] [EOL] try : [EOL] if re . search ( [string] , fn ) : [EOL] f = gzip . open ( fn , [string] ) [EOL] else : [EOL] f = open ( fn , [string] ) [EOL] [EOL] if jsonl_flag : [EOL] for line in f : [EOL] edges = json . loads ( line ) [EOL] for edge in edges : [EOL] yield edge [EOL] elif json_flag : [EOL] edges = json . load ( f ) [EOL] for edge in edges : [EOL] yield edge [EOL] elif yaml_flag : [EOL] edges = yaml . load_all ( f , Loader = yaml . SafeLoader ) [EOL] for edge in edges : [EOL] yield edge [EOL] [EOL] except Exception as e : [EOL] log . exception ( f" [string] { fn }" ) [EOL] [EOL] [EOL] def write_edges ( edges , filename , jsonlines = False , gzipflag = False , yaml = False , ) : [EOL] [docstring] [EOL] pass [EOL] [EOL] [EOL] def edges_to_jgf ( fn , edges ) : [EOL] [EOL] jgf_nodes = [ ] [EOL] jgf_edges = [ ] [EOL] for edge in edges : [EOL] if [string] in edge : [EOL] jgf_nodes . append ( { [string] : edge [ [string] ] [ [string] ] [ [string] ] } ) [EOL] jgf_nodes . append ( { [string] : edge [ [string] ] [ [string] ] [ [string] ] } ) [EOL] jgf_edges . append ( { [string] : edge [ [string] ] [ [string] ] [ [string] ] , [string] : edge [ [string] ] [ [string] ] [ [string] ] , [string] : edge [ [string] ] [ [string] ] [ [string] ] , } ) [EOL] [EOL] with open ( fn , [string] ) as f : [EOL] graph = { [string] : { [string] : [string] , [string] : [string] , [string] : copy . deepcopy ( jgf_nodes ) , [string] : copy . deepcopy ( jgf_edges ) , } } [EOL] [EOL] f . write ( [string] . format ( json . dumps ( graph , indent = [number] ) ) ) [EOL] [EOL] [EOL] def main ( ) : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Iterable[typing.Mapping[builtins.str,typing.Any]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $logging.Logger$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Union , Sized , Any , Dict , Type , Literal , List , Mapping [EOL] import builtins [EOL] import typing_extensions [EOL] import jinja2 [EOL] import datetime [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import datetime [EOL] import glob [EOL] import importlib [EOL] import itertools [EOL] import json [EOL] import os [EOL] import re [EOL] import sys [EOL] from typing import Any , List , Mapping [EOL] [EOL] [comment] [EOL] import jinja2 [EOL] import structlog [EOL] import tatsu [EOL] import yaml [EOL] [EOL] [comment] [EOL] from bel . Config import config [EOL] from bel . utils import http_client [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] [comment] [EOL] BELSpec = Mapping [ str , Any ] [EOL] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def get_specification ( version ) : [EOL] [docstring] [EOL] [EOL] spec_dir = config [ [string] ] [ [string] ] [ [string] ] [EOL] spec_dict = { } [EOL] [EOL] bel_versions = get_bel_versions ( ) [EOL] if version not in bel_versions : [EOL] log . error ( [string] ) [EOL] return { [string] : [string] } [EOL] [EOL] [comment] [EOL] version_underscored = version . replace ( [string] , [string] ) [EOL] [EOL] json_fn = f"{ spec_dir } [string] { version_underscored } [string] " [EOL] [EOL] with open ( json_fn , [string] ) as f : [EOL] spec_dict = json . load ( f ) [EOL] [EOL] return spec_dict [EOL] [EOL] [EOL] def get_bel_versions ( ) : [EOL] [docstring] [EOL] [EOL] spec_dir = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] fn = f"{ spec_dir } [string] " [EOL] with open ( fn , [string] ) as f : [EOL] versions = json . load ( f ) [EOL] [EOL] return versions [EOL] [EOL] [EOL] def update_specifications ( force = False ) : [EOL] [docstring] [EOL] [EOL] spec_dir = config [ [string] ] [ [string] ] [ [string] ] [EOL] if not os . path . isdir ( spec_dir ) : [EOL] os . mkdir ( spec_dir ) [EOL] [EOL] log . info ( f" [string] { spec_dir }" ) [EOL] [EOL] [comment] [EOL] if config [ [string] ] [ [string] ] [ [string] ] : [EOL] github_belspec_files ( spec_dir , force = force ) [EOL] [EOL] [comment] [EOL] files = glob . glob ( f"{ spec_dir } [string] " ) [EOL] for fn in files : [EOL] new_fn = fn . replace ( [string] , [string] ) [EOL] os . rename ( fn , new_fn ) [EOL] [EOL] [comment] [EOL] files = glob . glob ( f"{ spec_dir } [string] " ) [EOL] versions = { } [EOL] for fn in files : [EOL] filename = os . path . basename ( fn ) [EOL] [EOL] check_version = filename . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] [EOL] json_fn = fn . replace ( [string] , [string] ) [EOL] version = belspec_yaml2json ( fn , json_fn ) [EOL] [EOL] if version != check_version : [EOL] log . error ( f" [string] { fn } [string] { check_version } [string] { version }" ) [EOL] versions [ version ] = filename [EOL] [EOL] with open ( f"{ spec_dir } [string] " , [string] ) as f : [EOL] json . dump ( list ( set ( versions ) ) , f , indent = [number] ) [EOL] [EOL] [comment] [EOL] [EOL] create_ebnf_parser ( files ) [EOL] [EOL] [EOL] def github_belspec_files ( spec_dir , force = False ) : [EOL] [docstring] [EOL] [EOL] if not force : [EOL] dtnow = datetime . datetime . utcnow ( ) [EOL] delta = datetime . timedelta ( [number] ) [EOL] yesterday = dtnow - delta [EOL] [EOL] for fn in glob . glob ( f"{ spec_dir } [string] " ) : [EOL] if datetime . datetime . fromtimestamp ( os . path . getmtime ( fn ) ) > yesterday : [EOL] log . info ( [string] ) [EOL] return [EOL] [EOL] repo_url = [string] [EOL] params = { } [EOL] github_access_token = os . getenv ( [string] , [string] ) [EOL] if github_access_token : [EOL] params = { [string] : github_access_token } [EOL] [EOL] r = http_client . get ( repo_url , params = params ) [EOL] if r . status_code == [number] : [EOL] results = r . json ( ) [EOL] for f in results : [EOL] url = f [ [string] ] [EOL] fn = os . path . basename ( url ) [EOL] [EOL] if [string] not in fn and [string] in fn : [EOL] fn = fn . replace ( [string] , [string] ) [EOL] [EOL] r = http_client . get ( url , params = params , allow_redirects = True ) [EOL] if r . status_code == [number] : [EOL] open ( f"{ spec_dir } [string] { fn }" , [string] ) . write ( r . content ) [EOL] else : [EOL] sys . exit ( f" [string] { url } [string] { r . status_code } [string] { r . content }" ) [EOL] else : [EOL] sys . exit ( f" [string] { r . status_code } [string] { r . content }" ) [EOL] [EOL] [EOL] def belspec_yaml2json ( yaml_fn , json_fn ) : [EOL] [docstring] [EOL] [EOL] try : [EOL] spec_dict = yaml . load ( open ( yaml_fn , [string] ) . read ( ) , Loader = yaml . SafeLoader ) [EOL] [EOL] [comment] [EOL] spec_dict [ [string] ] = { } [EOL] spec_dict [ [string] ] [ [string] ] = spec_dict [ [string] ] . replace ( [string] , [string] ) [EOL] spec_dict [ [string] ] [ [string] ] = yaml_fn . replace ( [string] , [string] ) [EOL] [EOL] [comment] [EOL] add_relations ( spec_dict ) [EOL] [comment] [EOL] add_functions ( spec_dict ) [EOL] [comment] [EOL] add_namespaces ( spec_dict ) [EOL] [EOL] enhance_function_signatures ( spec_dict ) [EOL] [EOL] add_function_signature_help ( spec_dict ) [EOL] [EOL] with open ( json_fn , [string] ) as f : [EOL] json . dump ( spec_dict , f ) [EOL] [EOL] except Exception as e : [EOL] log . exception ( f" [string] { yaml_fn } [string] { str ( e ) }" ) [EOL] print ( [string] , json . dumps ( spec_dict , indent = [number] ) ) [EOL] sys . exit ( ) [EOL] [EOL] return spec_dict [ [string] ] [EOL] [EOL] [EOL] def add_function_signature_help ( spec_dict ) : [EOL] [docstring] [EOL] for f in spec_dict [ [string] ] [ [string] ] : [EOL] for argset_idx , argset in enumerate ( spec_dict [ [string] ] [ [string] ] [ f ] [ [string] ] ) : [EOL] args_summary = [string] [EOL] args_list = [ ] [EOL] arg_idx = [number] [EOL] for arg_idx , arg in enumerate ( spec_dict [ [string] ] [ [string] ] [ f ] [ [string] ] [ argset_idx ] [ [string] ] ) : [EOL] if arg [ [string] ] in [ [string] , [string] ] : [EOL] vals = [ spec_dict [ [string] ] [ [string] ] . get ( val , spec_dict [ [string] ] [ [string] ] . get ( val ) ) for val in arg [ [string] ] ] [EOL] args_summary += [string] . join ( vals ) + [string] [EOL] arg_idx += [number] [EOL] [EOL] if arg . get ( [string] , False ) and arg . get ( [string] , False ) is False : [EOL] args_summary += [string] [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] elif arg . get ( [string] , False ) : [EOL] args_summary += [string] [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] else : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] [EOL] elif arg [ [string] ] in [ [string] , [string] , [string] ] : [EOL] args_summary += f'{ arg [ [string] ] }' [EOL] if arg . get ( [string] , False ) and arg . get ( [string] , False ) is False : [EOL] args_summary += [string] [EOL] if arg [ [string] ] in [ [string] ] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] elif arg [ [string] ] == [string] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] else : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] elif arg . get ( [string] , False ) : [EOL] args_summary += [string] [EOL] if arg [ [string] ] in [ [string] ] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] elif arg [ [string] ] == [string] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] else : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] else : [EOL] if arg [ [string] ] in [ [string] ] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] elif arg [ [string] ] == [string] : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] else : [EOL] text = f' [string] { [string] . join ( [ val for val in arg [ [string] ] ] ) }' [EOL] [EOL] args_summary += [string] [EOL] args_list . append ( text ) [EOL] [EOL] args_summary = re . sub ( [string] , [string] , args_summary ) [EOL] spec_dict [ [string] ] [ [string] ] [ f ] [ [string] ] [ argset_idx ] [ [string] ] = f"{ f } [string] { args_summary } [string] " [EOL] spec_dict [ [string] ] [ [string] ] [ f ] [ [string] ] [ argset_idx ] [ [string] ] = args_list [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] return spec_dict [EOL] [EOL] [EOL] def add_relations ( spec_dict ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] [EOL] for relation_name in spec_dict [ [string] ] [ [string] ] : [EOL] [EOL] abbreviated_name = spec_dict [ [string] ] [ [string] ] [ relation_name ] [ [string] ] [EOL] spec_dict [ [string] ] [ [string] ] . extend ( ( relation_name , abbreviated_name ) ) [EOL] spec_dict [ [string] ] [ [string] ] . append ( relation_name ) [EOL] spec_dict [ [string] ] [ [string] ] . append ( abbreviated_name ) [EOL] [EOL] spec_dict [ [string] ] [ [string] ] [ relation_name ] = abbreviated_name [EOL] spec_dict [ [string] ] [ [string] ] [ abbreviated_name ] = abbreviated_name [EOL] [EOL] spec_dict [ [string] ] [ [string] ] [ abbreviated_name ] = relation_name [EOL] spec_dict [ [string] ] [ [string] ] [ relation_name ] = relation_name [EOL] [EOL] return spec_dict [EOL] [EOL] [EOL] def add_functions ( spec_dict ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] = [ ] [EOL] [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] = [ ] [EOL] [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] = [ ] [EOL] [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] spec_dict [ [string] ] [ [string] ] = { } [EOL] [EOL] for func_name in spec_dict [ [string] ] [ [string] ] : [EOL] [EOL] abbreviated_name = spec_dict [ [string] ] [ [string] ] [ func_name ] [ [string] ] [EOL] [EOL] spec_dict [ [string] ] [ [string] ] . extend ( ( func_name , abbreviated_name ) ) [EOL] [EOL] spec_dict [ [string] ] [ [string] ] . append ( func_name ) [EOL] spec_dict [ [string] ] [ [string] ] . append ( abbreviated_name ) [EOL] [EOL] if spec_dict [ [string] ] [ [string] ] [ func_name ] [ [string] ] == [string] : [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] . append ( func_name ) [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] . append ( abbreviated_name ) [EOL] else : [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] . append ( func_name ) [EOL] spec_dict [ [string] ] [ [string] ] [ [string] ] . append ( abbreviated_name ) [EOL] [EOL] spec_dict [ [string] ] [ [string] ] [ abbreviated_name ] = abbreviated_name [EOL] spec_dict [ [string] ] [ [string] ] [ func_name ] = abbreviated_name [EOL] [EOL] spec_dict [ [string] ] [ [string] ] [ abbreviated_name ] = func_name [EOL] spec_dict [ [string] ] [ [string] ] [ func_name ] = func_name [EOL] [EOL] return spec_dict [EOL] [EOL] [EOL] def add_namespaces ( spec_dict ) : [EOL] [docstring] [EOL] [EOL] for ns in spec_dict [ [string] ] : [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] = [ ] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] = [ ] [EOL] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] = { } [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] = { } [EOL] [EOL] for obj in spec_dict [ [string] ] [ ns ] [ [string] ] : [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] . extend ( [ obj [ [string] ] , obj [ [string] ] ] ) [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] . append ( obj [ [string] ] ) [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] . append ( obj [ [string] ] ) [EOL] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] [EOL] [comment] [EOL] if [string] in obj : [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] spec_dict [ [string] ] [ ns ] [ [string] ] [ obj [ [string] ] ] = obj [ [string] ] [EOL] [EOL] [EOL] def enhance_function_signatures ( spec_dict ) : [EOL] [docstring] [EOL] [EOL] for func in spec_dict [ [string] ] [ [string] ] : [EOL] for i , sig in enumerate ( spec_dict [ [string] ] [ [string] ] [ func ] [ [string] ] ) : [EOL] args = sig [ [string] ] [EOL] req_args = [ ] [EOL] pos_args = [ ] [EOL] opt_args = [ ] [EOL] mult_args = [ ] [EOL] for arg in args : [EOL] [comment] [EOL] if arg . get ( [string] , False ) : [EOL] if arg [ [string] ] in [ [string] , [string] ] : [EOL] mult_args . extend ( arg . get ( [string] , [ ] ) ) [EOL] elif arg [ [string] ] in [ [string] , [string] , [string] ] : [EOL] [comment] [EOL] mult_args . append ( arg [ [string] ] ) [EOL] [EOL] [comment] [EOL] elif arg . get ( [string] , False ) and arg . get ( [string] , False ) : [EOL] if arg [ [string] ] in [ [string] , [string] ] : [EOL] pos_args . append ( arg . get ( [string] , [ ] ) ) [EOL] elif arg [ [string] ] in [ [string] , [string] , [string] ] : [EOL] pos_args . append ( arg [ [string] ] ) [EOL] [EOL] [comment] [EOL] elif arg . get ( [string] , False ) : [EOL] if arg [ [string] ] in [ [string] , [string] ] : [EOL] opt_args . extend ( arg . get ( [string] , [ ] ) ) [EOL] elif arg [ [string] ] in [ [string] , [string] , [string] ] : [EOL] opt_args . append ( arg [ [string] ] ) [EOL] [EOL] [comment] [EOL] else : [EOL] if arg [ [string] ] in [ [string] , [string] ] : [EOL] req_args . append ( arg . get ( [string] , [ ] ) ) [EOL] elif arg [ [string] ] in [ [string] , [string] , [string] ] : [EOL] req_args . append ( arg [ [string] ] ) [EOL] [EOL] spec_dict [ [string] ] [ [string] ] [ func ] [ [string] ] [ i ] [ [string] ] = copy . deepcopy ( req_args ) [EOL] spec_dict [ [string] ] [ [string] ] [ func ] [ [string] ] [ i ] [ [string] ] = copy . deepcopy ( pos_args ) [EOL] spec_dict [ [string] ] [ [string] ] [ func ] [ [string] ] [ i ] [ [string] ] = copy . deepcopy ( opt_args ) [EOL] spec_dict [ [string] ] [ [string] ] [ func ] [ [string] ] [ i ] [ [string] ] = copy . deepcopy ( mult_args ) [EOL] [EOL] return spec_dict [EOL] [EOL] [EOL] def get_ebnf_template ( ) : [EOL] [docstring] [EOL] [EOL] spec_dir = config [ [string] ] [ [string] ] [ [string] ] [EOL] local_fp = f"{ spec_dir } [string] " [EOL] [EOL] repo_url = ( [string] ) [EOL] [EOL] params = { } [EOL] github_access_token = os . getenv ( [string] , [string] ) [EOL] if github_access_token : [EOL] params = { [string] : github_access_token } [EOL] [EOL] try : [EOL] [comment] [EOL] r = http_client . get ( repo_url , params = params ) [EOL] [EOL] if r . status_code == [number] : [EOL] template_url = r . json ( ) [ [string] ] [EOL] else : [EOL] log . warning ( [string] ) [EOL] [EOL] [comment] [EOL] try : [EOL] r = http_client . get ( template_url , params = params , allow_redirects = True ) [EOL] if r . status_code == [number] : [EOL] open ( local_fp , [string] ) . write ( r . text ) [EOL] else : [EOL] log . warning ( f" [string] { r . status_code } [string] { r . text }" ) [EOL] [EOL] except Exception as e : [EOL] log . warning ( f" [string] { r . status_code } [string] { e }" ) [EOL] [EOL] except Exception as e : [EOL] log . warning ( [string] ) [EOL] if not os . path . exists ( f"{ spec_dir } [string] " ) : [EOL] log . error ( [string] ) [EOL] [EOL] return local_fp [EOL] [EOL] [EOL] def create_ebnf_parser ( files ) : [EOL] [docstring] [EOL] [EOL] flag = False [EOL] for belspec_fn in files : [EOL] [comment] [EOL] if config [ [string] ] [ [string] ] [ [string] ] : [EOL] tmpl_fn = get_ebnf_template ( ) [EOL] [EOL] [comment] [EOL] ebnf_fn = belspec_fn . replace ( [string] , [string] ) [EOL] if not os . path . exists ( ebnf_fn ) or os . path . getmtime ( belspec_fn ) > os . path . getmtime ( ebnf_fn ) : [EOL] with open ( belspec_fn , [string] ) as f : [EOL] belspec = yaml . load ( f , Loader = yaml . SafeLoader ) [EOL] [EOL] tmpl_dir = os . path . dirname ( tmpl_fn ) [EOL] tmpl_basename = os . path . basename ( tmpl_fn ) [EOL] [EOL] bel_major_version = belspec [ [string] ] . split ( [string] ) [ [number] ] [EOL] [EOL] env = jinja2 . Environment ( loader = jinja2 . FileSystemLoader ( tmpl_dir ) ) [comment] [EOL] template = env . get_template ( tmpl_basename ) [comment] [EOL] [EOL] [comment] [EOL] relations_list = [ ( relation , belspec [ [string] ] [ [string] ] [ relation ] [ [string] ] ) for relation in belspec [ [string] ] [ [string] ] ] [EOL] relations_list = sorted ( list ( itertools . chain ( * relations_list ) ) , key = len , reverse = True ) [EOL] [EOL] functions_list = [ ( function , belspec [ [string] ] [ [string] ] [ function ] [ [string] ] ) for function in belspec [ [string] ] [ [string] ] if belspec [ [string] ] [ [string] ] [ function ] [ [string] ] == [string] ] [EOL] functions_list = sorted ( list ( itertools . chain ( * functions_list ) ) , key = len , reverse = True ) [EOL] [EOL] modifiers_list = [ ( function , belspec [ [string] ] [ [string] ] [ function ] [ [string] ] ) for function in belspec [ [string] ] [ [string] ] if belspec [ [string] ] [ [string] ] [ function ] [ [string] ] == [string] ] [EOL] modifiers_list = sorted ( list ( itertools . chain ( * modifiers_list ) ) , key = len , reverse = True ) [EOL] [EOL] created_time = datetime . datetime . now ( ) . strftime ( [string] ) [EOL] [EOL] ebnf = template . render ( functions = functions_list , m_functions = modifiers_list , relations = relations_list , bel_version = belspec [ [string] ] , bel_major_version = bel_major_version , created_time = created_time , ) [EOL] [EOL] with open ( ebnf_fn , [string] ) as f : [EOL] f . write ( ebnf ) [EOL] [EOL] parser_fn = ebnf_fn . replace ( [string] , [string] ) [EOL] [EOL] parser = tatsu . to_python_sourcecode ( ebnf , filename = parser_fn ) [EOL] flag = True [EOL] with open ( parser_fn , [string] ) as f : [EOL] f . write ( parser ) [EOL] [EOL] if flag : [EOL] [comment] [EOL] importlib . invalidate_caches ( ) [EOL] [EOL] [EOL] def get_function_help ( function , bel_spec ) : [EOL] [docstring] [EOL] [EOL] function_long = bel_spec [ [string] ] [ [string] ] . get ( function ) [EOL] function_help = [ ] [EOL] [EOL] if function_long : [EOL] for signature in bel_spec [ [string] ] [ [string] ] [ function_long ] [ [string] ] : [EOL] function_help . append ( { [string] : signature [ [string] ] , [string] : signature [ [string] ] , [string] : bel_spec [ [string] ] [ [string] ] [ function_long ] [ [string] ] , } ) [EOL] [EOL] return function_help [EOL] [EOL] [EOL] def main ( ) : [EOL] pass [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL] [EOL] else : [EOL] [comment] [EOL] if os . getenv ( [string] , False ) : [EOL] config = { } [EOL] log . info ( [string] ) [EOL] else : [EOL] update_specifications ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Tuple , Union , Any , Dict , Type , List , Mapping [EOL] import builtins [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import json [EOL] import re [EOL] from typing import Any , List , Mapping , Optional , Tuple [EOL] [EOL] [comment] [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] import bel . lang . bel_specification as bel_specification [EOL] import bel . lang . partialparse as pparse [EOL] from bel . Config import config [EOL] from bel . utils import http_client , url_path_param_quoting [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] default_bel_version = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] Span = Tuple [ int , int ] [EOL] AST = Mapping [ str , Any ] [EOL] BELSpec = Mapping [ str , Any ] [EOL] [EOL] [EOL] def in_span ( loc , span ) : [EOL] [docstring] [EOL] [EOL] if loc >= span [ [number] ] and loc <= span [ [number] ] : [EOL] return True [EOL] else : [EOL] return False [EOL] [EOL] [EOL] def cursor ( belstr , ast , cursor_loc , result = None ) : [EOL] [docstring] [EOL] [EOL] log . debug ( f" [string] { json . dumps ( ast , indent = [number] ) }" ) [EOL] [EOL] [comment] [EOL] log . debug ( f" [string] { ast . keys ( ) } [string] { belstr }" ) [EOL] [EOL] if len ( belstr ) == [number] : [EOL] return { [string] : [string] , [string] : ( [number] , [number] ) , [string] : [string] } [EOL] [EOL] if [string] in ast and in_span ( cursor_loc , ast [ [string] ] [ [string] ] ) : [EOL] log . debug ( [string] ) [EOL] [EOL] completion_text = belstr [ ast [ [string] ] [ [string] ] [ [number] ] : cursor_loc + [number] ] [EOL] return { [string] : [string] , [string] : ast [ [string] ] [ [string] ] , [string] : completion_text , } [EOL] [EOL] [comment] [EOL] elif [string] not in ast and isinstance ( ast , dict ) : [EOL] for key in ast : [EOL] if key in [ [string] , [string] , [string] ] : [EOL] log . debug ( f" [string] { key }" ) [EOL] result = cursor ( belstr , ast [ key ] , cursor_loc , result = result ) [EOL] if result : [EOL] return result [EOL] [EOL] [comment] [EOL] if [string] in ast and in_span ( cursor_loc , ast [ [string] ] ) : [EOL] log . debug ( [string] ) [EOL] if [string] in ast : [EOL] name_span = ast [ [string] ] [ [string] ] [EOL] if in_span ( cursor_loc , name_span ) : [EOL] return { [string] : [string] , [string] : name_span , [string] : belstr [ name_span [ [number] ] : cursor_loc + [number] ] , } [EOL] for idx , arg in enumerate ( ast [ [string] ] ) : [EOL] if ( cursor_loc == ast [ [string] ] [ [string] ] [ [number] ] [EOL] and ast [ [string] ] [ [string] ] [ [number] ] == - [number] ) : [EOL] return { [string] : [string] , [string] : idx , [string] : arg [ [string] ] , [string] : ast [ [string] ] [ [string] ] , [string] : [string] , } [EOL] [EOL] elif in_span ( cursor_loc , arg [ [string] ] ) : [EOL] log . debug ( f' [string] { arg [ [string] ] } [string] { cursor_loc }' ) [EOL] if arg [ [string] ] == [string] : [EOL] if in_span ( cursor_loc , arg [ [string] ] [ [string] ] ) : [EOL] log . debug ( [string] ) [EOL] return { [string] : [string] , [string] : arg [ [string] ] [ [string] ] , [string] : idx , [string] : copy . deepcopy ( ast [ [string] ] ) , [string] : ast [ [string] ] [ [string] ] , [string] : belstr [ arg [ [string] ] [ [string] ] [ [number] ] : cursor_loc + [number] ] , } [EOL] else : [EOL] log . debug ( f' [string] { arg [ [string] ] }' ) [EOL] result = cursor ( belstr , arg , cursor_loc , result = result ) [EOL] elif arg [ [string] ] == [string] : [EOL] [EOL] result = { [string] : [string] , [string] : arg [ [string] ] , [string] : idx , [string] : copy . deepcopy ( ast [ [string] ] ) , [string] : ast [ [string] ] [ [string] ] , } [EOL] [EOL] [comment] [EOL] if in_span ( cursor_loc , arg [ [string] ] [ [string] ] ) : [EOL] result [ [string] ] = arg [ [string] ] [ [string] ] [comment] [EOL] result [ [string] ] = belstr [ arg [ [string] ] [ [string] ] [ [number] ] : cursor_loc + [number] ] [EOL] [comment] [EOL] else : [EOL] result [ [string] ] = belstr [ arg [ [string] ] [ [string] ] [ [number] ] : cursor_loc + [number] ] [EOL] [EOL] log . debug ( f" [string] { result }" ) [EOL] return result [EOL] elif arg [ [string] ] == [string] : [comment] [EOL] if arg [ [string] ] [ [number] ] == arg [ [string] ] [ [number] ] : [comment] [EOL] completion_text = arg [ [string] ] [EOL] else : [EOL] completion_text = belstr [ arg [ [string] ] [ [number] ] : cursor_loc + [number] ] [EOL] [EOL] return { [string] : [string] , [string] : idx , [string] : arg [ [string] ] , [string] : ast [ [string] ] [ [string] ] , [string] : completion_text . lstrip ( ) , } [EOL] return result [comment] [EOL] [EOL] [EOL] def nsarg_completions ( completion_text , entity_types , bel_spec , namespace , species_id , bel_fmt , size , ) : [EOL] [docstring] [EOL] [EOL] minimal_nsarg_completion_len = [number] [EOL] [EOL] species = [ species_id ] [EOL] namespaces = [ namespace ] [EOL] replace_list = [ ] [EOL] [EOL] if len ( completion_text ) >= minimal_nsarg_completion_len : [EOL] [comment] [EOL] [comment] [EOL] [EOL] url = f'{ config [ [string] ] [ [string] ] [ [string] ] } [string] { url_path_param_quoting ( completion_text ) }' [EOL] [EOL] params = { [string] : size , [string] : entity_types , [string] : namespaces , [string] : species , } [EOL] [EOL] if [string] in entity_types : [EOL] params . pop ( [string] , [string] ) [EOL] [EOL] log . info ( [string] , api_url = config [ [string] ] [ [string] ] [ [string] ] , url = url , params = params , ) [EOL] [EOL] r = http_client . get ( url , params = params ) [EOL] [EOL] if r . status_code == [number] : [EOL] ns_completions = r . json ( ) [EOL] else : [EOL] log . error ( f" [string] { r . status_code } [string] { url }" ) [EOL] ns_completions = { } [EOL] [EOL] for complete in ns_completions . get ( [string] , [ ] ) : [EOL] replace_list . append ( { [string] : complete [ [string] ] , [string] : f"{ complete [ [string] ] } [string] { complete [ [string] ] } [string] " , [string] : complete [ [string] ] [ - [number] ] , [string] : [string] , } ) [EOL] [EOL] [comment] [EOL] for entity_type in entity_types : [EOL] default_namespace = bel_spec [ [string] ] . get ( entity_type , [ ] ) [EOL] if default_namespace : [EOL] for obj in default_namespace [ [string] ] : [EOL] replacement = None [EOL] if bel_fmt == [string] and re . match ( completion_text , obj [ [string] ] , re . IGNORECASE ) : [EOL] replacement = obj [ [string] ] [EOL] elif bel_fmt in [ [string] , [string] ] and re . match ( completion_text , obj [ [string] ] , re . IGNORECASE ) : [EOL] replacement = obj [ [string] ] [EOL] [EOL] if replacement : [EOL] highlight = replacement . replace ( completion_text , f" [string] { completion_text } [string] " ) [EOL] replace_list . insert ( [number] , { [string] : replacement , [string] : replacement , [string] : highlight , [string] : [string] , } , ) [EOL] [EOL] return replace_list [ : size ] [EOL] [EOL] [EOL] def relation_completions ( completion_text , bel_spec , bel_fmt , size ) : [EOL] [docstring] [EOL] [EOL] if bel_fmt == [string] : [EOL] relation_list = bel_spec [ [string] ] [ [string] ] [EOL] else : [EOL] relation_list = bel_spec [ [string] ] [ [string] ] [EOL] [EOL] matches = [ ] [EOL] for r in relation_list : [EOL] if re . match ( completion_text , r ) : [EOL] matches . append ( r ) [EOL] [EOL] replace_list = [ ] [EOL] for match in matches : [EOL] highlight = match . replace ( completion_text , f" [string] { completion_text } [string] " ) [EOL] replace_list . append ( { [string] : match , [string] : match , [string] : highlight , [string] : [string] } ) [EOL] [EOL] return replace_list [ : size ] [EOL] [EOL] [EOL] def function_completions ( completion_text , bel_spec , function_list , bel_fmt , size ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] if isinstance ( function_list , list ) : [EOL] if bel_fmt in [ [string] , [string] ] : [EOL] function_list = [ bel_spec [ [string] ] [ [string] ] [ fn ] for fn in function_list ] [EOL] else : [EOL] function_list = [ bel_spec [ [string] ] [ [string] ] [ fn ] for fn in function_list ] [EOL] elif bel_fmt in [ [string] , [string] ] : [EOL] function_list = bel_spec [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] function_list = bel_spec [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] matches = [ ] [EOL] for f in function_list : [EOL] escaped_completion_text = completion_text . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] log . debug ( f" [string] { escaped_completion_text } [string] { f }" ) [EOL] if re . match ( escaped_completion_text , f ) : [EOL] matches . append ( f ) [EOL] [EOL] replace_list = [ ] [EOL] for match in matches : [EOL] if completion_text : [EOL] highlight = match . replace ( completion_text , f" [string] { completion_text } [string] " ) [EOL] else : [EOL] highlight = completion_text [EOL] [EOL] replace_list . append ( { [string] : match , [string] : f"{ match } [string] " , [string] : highlight , [string] : [string] , } ) [EOL] [EOL] return replace_list [ : size ] [EOL] [EOL] [EOL] def arg_completions ( completion_text , parent_function , args , arg_idx , bel_spec , bel_fmt , species_id , namespace , size , ) : [EOL] [docstring] [EOL] [EOL] function_long = bel_spec [ [string] ] [ [string] ] . get ( parent_function ) [EOL] if not function_long : [EOL] return [ ] [EOL] [EOL] signatures = bel_spec [ [string] ] [ [string] ] [ function_long ] [ [string] ] [EOL] [EOL] [comment] [EOL] function_list = [ ] [EOL] entity_types = [ ] [EOL] fn_replace_list , ns_arg_replace_list = [ ] , [ ] [EOL] position_flag = False [comment] [EOL] [EOL] [comment] [EOL] for signature in signatures : [EOL] sig_arg = signature [ [string] ] [ arg_idx ] [EOL] sig_type = sig_arg [ [string] ] [EOL] [EOL] if sig_arg . get ( [string] , False ) and arg_idx == sig_arg [ [string] ] - [number] : [EOL] position_flag = True [EOL] if sig_type in [ [string] , [string] ] : [EOL] function_list . extend ( sig_arg [ [string] ] ) [EOL] elif sig_type in [ [string] , [string] ] : [EOL] entity_types . extend ( sig_arg [ [string] ] ) [EOL] [EOL] if not position_flag : [EOL] [comment] [EOL] opt_fn_sig_args = [ ] [EOL] opt_nsarg_sig_args = [ ] [EOL] mult_fn_sig_args = [ ] [EOL] mult_nsarg_sig_args = [ ] [EOL] for signature in signatures : [EOL] signature_opt_fn_sig_args = [ ] [EOL] signature_opt_nsarg_sig_args = [ ] [EOL] signature_mult_fn_sig_args = [ ] [EOL] signature_mult_nsarg_sig_args = [ ] [EOL] max_position = - [number] [EOL] for sig_arg in signature [ [string] ] : [EOL] if [string] in sig_arg : [EOL] max_position = sig_arg [ [string] ] [EOL] continue [comment] [EOL] [EOL] if ( sig_arg . get ( [string] , False ) is True [EOL] and sig_arg . get ( [string] , False ) is False ) : [EOL] if sig_arg [ [string] ] in [ [string] , [string] ] : [EOL] signature_opt_fn_sig_args . extend ( sig_arg [ [string] ] ) [EOL] elif sig_arg [ [string] ] in [ [string] , [string] ] : [EOL] signature_opt_nsarg_sig_args . extend ( sig_arg [ [string] ] ) [EOL] elif sig_arg . get ( [string] , False ) is True : [EOL] if sig_arg [ [string] ] in [ [string] , [string] ] : [EOL] signature_mult_fn_sig_args . extend ( sig_arg [ [string] ] ) [EOL] elif sig_arg [ [string] ] in [ [string] , [string] ] : [EOL] signature_mult_nsarg_sig_args . extend ( sig_arg [ [string] ] ) [EOL] [EOL] [comment] [EOL] for idx , arg in enumerate ( args ) : [EOL] if idx <= max_position - [number] : [comment] [EOL] continue [EOL] if idx == arg_idx : [comment] [EOL] continue [EOL] log . debug ( f" [string] { arg } [string] { signature_opt_fn_sig_args }" ) [EOL] [EOL] opt_fn_sig_args . extend ( signature_opt_fn_sig_args ) [EOL] opt_nsarg_sig_args . extend ( signature_opt_nsarg_sig_args ) [EOL] mult_fn_sig_args . extend ( signature_mult_fn_sig_args ) [EOL] mult_nsarg_sig_args . extend ( signature_mult_nsarg_sig_args ) [EOL] [EOL] function_list . extend ( list ( set ( opt_fn_sig_args + mult_fn_sig_args ) ) ) [EOL] entity_types . extend ( list ( set ( opt_nsarg_sig_args + mult_nsarg_sig_args ) ) ) [EOL] [EOL] if function_list : [EOL] log . debug ( f" [string] { function_list }" ) [EOL] fn_replace_list = function_completions ( completion_text , bel_spec , function_list , bel_fmt , size ) [EOL] [EOL] if entity_types : [EOL] log . debug ( f" [string] { entity_types }" ) [EOL] ns_arg_replace_list = nsarg_completions ( completion_text , entity_types , bel_spec , namespace , species_id , bel_fmt , size ) [EOL] [EOL] replace_list = fn_replace_list + ns_arg_replace_list [EOL] [EOL] return replace_list [EOL] [EOL] [EOL] def add_completions ( replace_list , belstr , replace_span , completion_text ) : [EOL] [docstring] [EOL] [EOL] completions = [ ] [EOL] [EOL] for r in replace_list : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] if len ( belstr ) > [number] : [EOL] belstr_end = len ( belstr ) - [number] [EOL] else : [EOL] belstr_end = [number] [EOL] [EOL] log . debug ( f' [string] { r } [string] { replace_span } [string] { belstr } [string] { belstr_end } [string] { r [ [string] ] == [string] } [string] { replace_span [ [number] ] + [number] == len ( belstr ) }' ) [EOL] [EOL] [comment] [EOL] if r [ [string] ] == [string] and replace_span [ [number] ] > [number] and belstr [ replace_span [ [number] ] - [number] ] == [string] : [EOL] log . debug ( [string] ) [EOL] replacement = ( belstr [ [number] : replace_span [ [number] ] ] + [string] + f"{ r [ [string] ] } [string] " + belstr [ replace_span [ [number] ] + [number] : ] ) [EOL] cursor_loc = len ( belstr [ [number] : replace_span [ [number] ] ] + [string] + f"{ r [ [string] ] } [string] " ) [EOL] [comment] [EOL] elif replace_span [ [number] ] > [number] and belstr [ replace_span [ [number] ] - [number] ] == [string] : [EOL] log . debug ( [string] ) [EOL] replacement = ( belstr [ [number] : replace_span [ [number] ] ] + [string] + r [ [string] ] + belstr [ replace_span [ [number] ] + [number] : ] ) [EOL] cursor_loc = len ( belstr [ [number] : replace_span [ [number] ] ] + [string] + r [ [string] ] ) [EOL] [comment] [EOL] elif r [ [string] ] == [string] and replace_span [ [number] ] >= belstr_end : [EOL] replacement = belstr [ [number] : replace_span [ [number] ] ] + f"{ r [ [string] ] } [string] " [EOL] cursor_loc = len ( replacement ) - [number] [comment] [EOL] log . debug ( f" [string] { replacement }" ) [EOL] [comment] [EOL] else : [EOL] replacement = ( belstr [ [number] : replace_span [ [number] ] ] + r [ [string] ] + belstr [ replace_span [ [number] ] + [number] : ] ) [EOL] cursor_loc = len ( belstr [ [number] : replace_span [ [number] ] ] + r [ [string] ] ) [comment] [EOL] [EOL] completions . append ( { [string] : replacement , [string] : cursor_loc , [string] : r [ [string] ] , [string] : r [ [string] ] , } ) [EOL] [EOL] return completions [EOL] [EOL] [EOL] def get_completions ( belstr , cursor_loc , bel_spec , bel_comp , bel_fmt , species_id , size , ) : [EOL] [docstring] [EOL] [EOL] ast , errors = pparse . get_ast_dict ( belstr ) [EOL] [EOL] spans = pparse . collect_spans ( ast ) [EOL] [EOL] completion_text = [string] [EOL] completions = [ ] [EOL] function_help = [ ] [EOL] [EOL] log . debug ( f" [string] { belstr } [string] { cursor_loc }" ) [EOL] cursor_results = cursor ( belstr , ast , cursor_loc ) [EOL] log . debug ( f" [string] { cursor_results }" ) [EOL] [EOL] if not cursor_results : [EOL] log . debug ( [string] ) [EOL] return ( completion_text , completions , function_help , spans ) [EOL] [EOL] completion_text = cursor_results . get ( [string] , [string] ) [EOL] [EOL] replace_span = cursor_results [ [string] ] [EOL] namespace = cursor_results . get ( [string] , None ) [EOL] [EOL] if [string] in cursor_results : [EOL] parent_function = cursor_results [ [string] ] [EOL] function_help = bel_specification . get_function_help ( cursor_results [ [string] ] , bel_spec ) [EOL] [EOL] args = cursor_results . get ( [string] , [ ] ) [EOL] arg_idx = cursor_results . get ( [string] ) [EOL] [EOL] replace_list = arg_completions ( completion_text , parent_function , args , arg_idx , bel_spec , bel_fmt , species_id , namespace , size , ) [EOL] elif cursor_results [ [string] ] == [string] : [EOL] function_list = None [EOL] replace_list = function_completions ( completion_text , bel_spec , function_list , bel_fmt , size ) [EOL] elif cursor_results [ [string] ] == [string] : [EOL] replace_list = relation_completions ( completion_text , bel_spec , bel_fmt , size ) [EOL] [EOL] completions . extend ( add_completions ( replace_list , belstr , replace_span , completion_text ) ) [EOL] [EOL] return completion_text , completions , function_help , spans [EOL] [EOL] [EOL] def bel_completion ( belstr , cursor_loc = - [number] , bel_version = default_bel_version , bel_comp = None , bel_fmt = [string] , species_id = None , size = [number] , ) : [EOL] [docstring] [EOL] [EOL] [docstring] [EOL] bel_spec = bel_specification . get_specification ( bel_version ) [EOL] [EOL] log . info ( [string] ) [EOL] [EOL] belstrlen = len ( belstr ) [EOL] if cursor_loc == - [number] : [EOL] cursor_loc = belstrlen - [number] [EOL] elif cursor_loc >= belstrlen : [EOL] cursor_loc = belstrlen - [number] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] ( completion_text , completions , function_help , spans ) = get_completions ( belstr , cursor_loc , bel_spec , bel_comp , bel_fmt , species_id , size ) [EOL] [EOL] return { [string] : completion_text , [string] : completions , [string] : function_help , [string] : spans , } [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] bel_version = [string] [EOL] bel_spec = bel_specification . get_specification ( bel_version ) [EOL] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] [comment] [EOL] [EOL] cursor_loc = [number] [EOL] completions = bel_completion ( belstr , cursor_loc , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] [EOL] quit ( ) [EOL] ast , errors = pparse . get_ast_dict ( belstr ) [EOL] [comment] [EOL] [comment] [EOL] cursor_loc = [number] [EOL] results = cursor ( belstr , ast , cursor_loc ) [EOL] print ( f" [string] { cursor_loc } [string] " , json . dumps ( results , indent = [number] ) ) [EOL] quit ( ) [EOL] [EOL] bel_comp = [string] [EOL] bel_fmt = [string] [EOL] species_id = [string] [EOL] completions = get_completions ( belstr , cursor_loc , functions , bel_spec , bel_comp , bel_fmt , species_id ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] quit ( ) [EOL] [EOL] completions = ns_completions ( [string] , [ [string] ] , [string] , [number] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] quit ( ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] completions = bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Mapping[builtins.str,typing.Any]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] from typing import List , Any , Dict , Optional [EOL] import builtins [EOL] import bel [EOL] import typing [EOL] import json [EOL] [EOL] [comment] [EOL] import structlog [EOL] [EOL] [comment] [EOL] import bel [EOL] import bel . lang . ast [EOL] import bel . lang . partialparse [EOL] from bel import BEL [EOL] from bel . Config import config [EOL] from bel . lang . ast import BELAst , Function , NSArg , StrArg [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] bo = BEL ( [string] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] spec = bo . spec [EOL] [EOL] [EOL] def migrate ( belstr ) : [EOL] [docstring] [EOL] [EOL] bo . ast = bel . lang . partialparse . get_ast_obj ( belstr , [string] ) [EOL] [EOL] return migrate_ast ( bo . ast ) . to_string ( ) [EOL] [EOL] [EOL] def migrate_into_triple ( belstr ) : [EOL] [docstring] [EOL] [EOL] bo . ast = bel . lang . partialparse . get_ast_obj ( belstr , [string] ) [EOL] [EOL] return migrate_ast ( bo . ast ) . to_triple ( ) [EOL] [EOL] [EOL] def migrate_ast ( ast ) : [EOL] [EOL] [comment] [EOL] bo . ast . bel_subject = convert ( bo . ast . bel_subject ) [EOL] [EOL] if bo . ast . bel_object : [EOL] if bo . ast . bel_object . type == [string] : [EOL] bo . ast . bel_object . bel_subject = convert ( bo . ast . bel_object . bel_subject ) [EOL] if bo . ast . bel_object . bel_object : [EOL] bo . ast . bel_object . bel_object = convert ( bo . ast . bel_object . bel_object ) [EOL] else : [EOL] bo . ast . bel_object = convert ( bo . ast . bel_object ) [EOL] [EOL] return bo . ast [EOL] [EOL] [EOL] def convert ( ast ) : [EOL] [docstring] [EOL] [EOL] if ast and ast . type == [string] : [EOL] [comment] [EOL] if ast . name != [string] and ast . name in spec [ [string] ] [ [string] ] [ [string] ] : [EOL] print ( [string] , ast . name , [string] , ast . type ) [EOL] ast = convert_activity ( ast ) [EOL] return ast [comment] [EOL] [EOL] [comment] [EOL] elif ast . name in [ [string] , [string] ] : [EOL] ast = convert_tloc ( ast ) [EOL] [EOL] fus_flag = False [EOL] for idx , arg in enumerate ( ast . args ) : [EOL] if arg . __class__ . __name__ == [string] : [EOL] [EOL] [comment] [EOL] if arg . name in [ [string] , [string] ] : [EOL] ast . args [ idx ] = convert_sub ( arg ) [EOL] [EOL] elif arg . name in [ [string] , [string] ] : [EOL] ast . args [ idx ] = convert_trunc ( arg ) [EOL] [EOL] elif arg . name in [ [string] , [string] ] : [EOL] ast . args [ idx ] = convert_pmod ( arg ) [EOL] [EOL] elif arg . name in [ [string] , [string] ] : [EOL] fus_flag = True [EOL] [EOL] [comment] [EOL] ast . args [ idx ] = convert ( ast . args [ idx ] ) [EOL] [EOL] if fus_flag : [EOL] ast = convert_fus ( ast ) [EOL] [EOL] return ast [EOL] [EOL] [EOL] def convert_tloc ( ast ) : [EOL] [docstring] [EOL] [EOL] from_loc_arg = ast . args [ [number] ] [EOL] to_loc_arg = ast . args [ [number] ] [EOL] from_loc = Function ( [string] , spec , parent_function = ast ) [EOL] from_loc . add_argument ( NSArg ( from_loc_arg . namespace , from_loc_arg . value , parent_function = from_loc ) ) [EOL] to_loc = Function ( [string] , spec , parent_function = ast ) [EOL] to_loc . add_argument ( NSArg ( to_loc_arg . namespace , to_loc_arg . value , parent_function = to_loc ) ) [EOL] [EOL] ast . args [ [number] ] = from_loc [EOL] ast . args [ [number] ] = to_loc [EOL] [EOL] return ast [EOL] [EOL] [EOL] def convert_activity ( ast ) : [EOL] [docstring] [EOL] [EOL] if len ( ast . args ) > [number] : [EOL] log . error ( f" [string] { ast . to_string ( ) }" ) [EOL] [EOL] p_arg = ast . args [ [number] ] [comment] [EOL] print ( [string] , p_arg ) [EOL] ma_arg = Function ( [string] , bo . spec ) [EOL] ma_arg . add_argument ( StrArg ( ast . name , ma_arg ) ) [EOL] p_arg . change_parent_fn ( ma_arg ) [EOL] ast = Function ( [string] , bo . spec ) [EOL] p_arg . change_parent_fn ( ast ) [EOL] ast . add_argument ( p_arg ) [EOL] ast . add_argument ( ma_arg ) [EOL] [EOL] return ast [EOL] [EOL] [EOL] def convert_pmod ( pmod ) : [EOL] [docstring] [EOL] [EOL] if pmod . args [ [number] ] . value in spec [ [string] ] [ [string] ] : [EOL] pmod . args [ [number] ] . value = spec [ [string] ] [ [string] ] [ pmod . args [ [number] ] . value ] [EOL] [EOL] return pmod [EOL] [EOL] [EOL] def convert_fus ( ast ) : [EOL] [docstring] [EOL] [EOL] parent_fn_name = ast . name_short [EOL] prefix_list = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] prefix = prefix_list [ parent_fn_name ] [EOL] [EOL] fus1_ns = ast . args [ [number] ] . namespace [EOL] fus1_val = ast . args [ [number] ] . value [EOL] [EOL] arg_fus = ast . args [ [number] ] [EOL] fus_args = [ None , [string] , [string] ] [EOL] for idx , arg in enumerate ( arg_fus . args ) : [EOL] fus_args [ idx ] = arg [EOL] [EOL] fus2_ns = fus_args [ [number] ] . namespace [EOL] fus2_val = fus_args [ [number] ] . value [EOL] [EOL] if fus_args [ [number] ] == [string] : [EOL] fus1_range = fus_args [ [number] ] [EOL] else : [EOL] fus1_range = f' [string] { prefix } [string] { fus_args [ [number] ] . value } [string] ' [EOL] [EOL] if fus_args [ [number] ] == [string] : [EOL] fus2_range = fus_args [ [number] ] [EOL] else : [EOL] fus2_range = f' [string] { prefix }{ fus_args [ [number] ] . value } [string] ' [EOL] [EOL] fus = Function ( [string] , spec , parent_function = ast ) [EOL] fus . args = [ NSArg ( fus1_ns , fus1_val , fus ) , StrArg ( fus1_range , fus ) , NSArg ( fus2_ns , fus2_val , fus ) , StrArg ( fus2_range , fus ) , ] [EOL] [EOL] [comment] [EOL] ast_args = ast . args [EOL] ast_args . pop ( [number] ) [EOL] ast_args . pop ( [number] ) [EOL] [EOL] if ast_args == [ None ] : [EOL] ast_args = [ ] [EOL] [EOL] ast . args = [ ] [EOL] ast . add_argument ( fus ) [EOL] [EOL] if len ( ast_args ) > [number] : [EOL] ast . args . extend ( ast_args ) [EOL] [EOL] return ast [EOL] [EOL] [EOL] def convert_sub ( sub ) : [EOL] [docstring] [EOL] [EOL] args = sub . args [EOL] ( ref_aa , pos , new_aa ) = args [EOL] [EOL] parent_fn_name = sub . parent_function . name_short [EOL] prefix_list = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] prefix = prefix_list [ parent_fn_name ] [EOL] [EOL] new_var_arg = f' [string] { prefix }{ spec [ [string] ] [ [string] ] [ [string] ] [ ref_aa . value ] }{ pos . value }{ spec [ [string] ] [ [string] ] [ [string] ] [ new_aa . value ] } [string] ' [EOL] [EOL] new_var = bel . lang . ast . Function ( [string] , bo . spec ) [EOL] [EOL] new_var . add_argument ( StrArg ( new_var_arg , new_var ) ) [EOL] [EOL] return new_var [EOL] [EOL] [EOL] def convert_trunc ( trunc ) : [EOL] [docstring] [EOL] [EOL] parent_fn_name = trunc . parent_function . name_short [EOL] prefix_list = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] prefix = prefix_list [ parent_fn_name ] [EOL] [EOL] new_var_arg = f' [string] { trunc . args [ [number] ] . value } [string] ' [EOL] [EOL] new_var = bel . lang . ast . Function ( [string] , bo . spec ) [EOL] [EOL] new_var . add_argument ( StrArg ( new_var_arg , new_var ) ) [EOL] [EOL] return new_var [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] import bel . lang . migrate_1_2 [EOL] [EOL] bel1 = [string] [EOL] [EOL] bel1 = [string] [EOL] [comment] [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] bel2 = bel . lang . migrate_1_2 . migrate ( bel1 ) [EOL] [EOL] print ( [string] , bel2 ) [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Match , Tuple , Any , List , Optional [EOL] import builtins [EOL] import bel [EOL] import typing [EOL] import re [EOL] from typing import List , Tuple [EOL] [EOL] [comment] [EOL] import structlog [EOL] [EOL] [comment] [EOL] from bel . lang . ast import BELAst , Function , NSArg , StrArg [EOL] from bel . utils import http_client , url_path_param_quoting [EOL] [EOL] log = structlog . getLogger ( ) [EOL] [EOL] [EOL] def validate ( bo , error_level = [string] ) : [EOL] [docstring] [EOL] [EOL] if bo . ast : [EOL] bo = validate_functions ( bo . ast , bo ) [comment] [EOL] if error_level == [string] : [EOL] bo = validate_arg_values ( bo . ast , bo ) [comment] [EOL] [EOL] else : [EOL] [comment] [EOL] errors = [ error for error in bo . validation_messages if error [ [number] ] == [string] ] [EOL] if not errors : [EOL] bo . validation_messages . append ( ( [string] , [string] ) ) [EOL] [EOL] for msg in bo . validation_messages : [EOL] if msg [ [number] ] == [string] : [EOL] bo . parse_valid = False [EOL] break [EOL] [EOL] return bo [EOL] [EOL] [EOL] def validate_functions ( ast , bo ) : [EOL] [docstring] [EOL] [EOL] if isinstance ( ast , Function ) : [EOL] log . debug ( f" [string] { ast . name } [string] { ast . function_type } [string] { ast . args }" ) [EOL] function_signatures = bo . spec [ [string] ] [ [string] ] [ ast . name ] [ [string] ] [EOL] [EOL] function_name = ast . name [EOL] ( valid_function , messages ) = check_function_args ( ast . args , function_signatures , function_name ) [EOL] if not valid_function : [EOL] message = [string] . join ( messages ) [EOL] bo . validation_messages . append ( ( [string] , [string] . format ( ast . to_string ( ) , message ) , ) ) [EOL] bo . parse_valid = False [EOL] [EOL] [comment] [EOL] if hasattr ( ast , [string] ) : [EOL] for arg in ast . args : [EOL] validate_functions ( arg , bo ) [EOL] [EOL] return bo [EOL] [EOL] [EOL] def check_function_args ( args , signatures , function_name ) : [EOL] [docstring] [EOL] [EOL] messages = [ ] [EOL] [EOL] arg_types = [ ] [EOL] for arg in args : [EOL] arg_type = arg . __class__ . __name__ [EOL] if arg_type == [string] : [EOL] arg_types . append ( ( arg . name , [string] ) ) [EOL] elif arg_type == [string] : [EOL] arg_types . append ( ( arg_type , f"{ arg . namespace } [string] { arg . value }" ) ) [EOL] elif arg_type == [string] : [EOL] arg_types . append ( ( arg_type , arg . value ) ) [EOL] log . debug ( f" [string] { arg_types }" ) [EOL] [EOL] matched_signature_idx = - [number] [EOL] valid_function = False [EOL] for sig_argset_idx , sig_argset in enumerate ( signatures ) : [EOL] sig_req_args = sig_argset [ [string] ] [comment] [EOL] sig_pos_args = sig_argset [ [string] ] [comment] [EOL] sig_opt_args = sig_argset [ [string] ] [comment] [EOL] sig_mult_args = sig_argset [ [string] ] [comment] [EOL] [EOL] log . debug ( f"{ sig_argset_idx } [string] { sig_req_args }" ) [EOL] log . debug ( f"{ sig_argset_idx } [string] { sig_pos_args }" ) [EOL] log . debug ( f"{ sig_argset_idx } [string] { sig_opt_args }" ) [EOL] log . debug ( f"{ sig_argset_idx } [string] { sig_mult_args }" ) [EOL] [EOL] [comment] [EOL] reqs_mismatch_flag = False [EOL] for sig_idx , sig_req in enumerate ( sig_req_args ) : [EOL] if len ( arg_types ) > sig_idx : [EOL] log . debug ( [string] . format ( arg_types [ sig_idx ] [ [number] ] , sig_req ) ) [EOL] if arg_types [ sig_idx ] [ [number] ] not in sig_req : [EOL] reqs_mismatch_flag = True [EOL] msg = f" [string] { function_name } [string] { sig_argset_idx }" [EOL] messages . append ( msg ) [EOL] log . debug ( msg ) [EOL] break [EOL] [EOL] if reqs_mismatch_flag : [EOL] continue [comment] [EOL] [EOL] [comment] [EOL] pos_dep_arg_types = arg_types [ len ( sig_req_args ) : ] [EOL] log . debug ( f" [string] { pos_dep_arg_types }" ) [EOL] log . debug ( f"{ sig_argset_idx } [string] { sig_pos_args }" ) [EOL] pos_mismatch_flag = False [EOL] for sig_pos_idx , sig_pos in enumerate ( sig_pos_args ) : [EOL] if sig_pos_idx == len ( pos_dep_arg_types ) : [EOL] break [comment] [EOL] if pos_dep_arg_types [ sig_pos_idx ] [ [number] ] not in sig_pos : [EOL] pos_mismatch_flag = True [EOL] msg = f" [string] { function_name } [string] { sig_argset_idx }" [EOL] messages . append ( msg ) [EOL] log . debug ( msg ) [EOL] break [EOL] if pos_mismatch_flag : [EOL] continue [comment] [EOL] [EOL] reqpos_arglen = len ( sig_req_args ) + len ( sig_pos_args ) [EOL] optional_arg_types = arg_types [ reqpos_arglen : ] [EOL] [EOL] [comment] [EOL] optional_types = [ ( opt_type , opt_val ) for opt_type , opt_val in optional_arg_types if opt_type not in sig_mult_args ] [EOL] log . debug ( f" [string] { optional_types }" ) [EOL] [EOL] [comment] [EOL] if len ( optional_types ) != len ( set ( optional_types ) ) : [EOL] msg = f" [string] { optional_types } [string] { function_name } [string] { sig_argset_idx }" [EOL] messages . append ( msg ) [EOL] log . debug ( msg ) [EOL] continue [EOL] [EOL] optional_types = [ ( opt_type , opt_val ) for opt_type , opt_val in optional_types if opt_type not in sig_opt_args ] [EOL] if len ( optional_types ) > [number] : [EOL] msg = f" [string] { optional_types } [string] { function_name } [string] { sig_argset_idx }" [EOL] messages . append ( msg ) [EOL] log . debug ( msg ) [EOL] continue [EOL] [EOL] matched_signature_idx = sig_argset_idx [EOL] messages = [ ] [comment] [EOL] valid_function = True [EOL] break [EOL] [EOL] [comment] [EOL] if matched_signature_idx > - [number] : [EOL] [comment] [EOL] log . debug ( f' [string] { signatures [ matched_signature_idx ] [ [string] ] } [string] { args }' ) [EOL] for arg_idx , arg in enumerate ( args ) : [EOL] log . debug ( f" [string] { arg . type }" ) [EOL] for sig_idx , sig_arg in enumerate ( signatures [ matched_signature_idx ] [ [string] ] ) : [EOL] if arg . type == [string] or sig_arg [ [string] ] in [ [string] , [string] ] : [EOL] pass [comment] [EOL] elif sig_arg . get ( [string] , None ) : [EOL] if sig_arg [ [string] ] == arg_idx + [number] : [EOL] arg . add_value_types ( sig_arg [ [string] ] ) [EOL] log . debug ( f' [string] { arg } [string] { sig_arg [ [string] ] }' ) [EOL] elif arg . type in [ [string] , [string] , [string] ] : [EOL] log . debug ( f" [string] { arg }" ) [EOL] arg . add_value_types ( sig_arg [ [string] ] ) [EOL] log . debug ( f' [string] { arg } [string] { sig_arg [ [string] ] }' ) [EOL] [EOL] for arg in args : [EOL] if arg . __class__ . __name__ in [ [string] , [string] ] : [EOL] log . debug ( f" [string] { arg . to_string ( ) } [string] { arg . value_types }" ) [EOL] [EOL] return ( valid_function , messages ) [EOL] [EOL] [EOL] def validate_arg_values ( ast , bo ) : [EOL] [docstring] [EOL] [EOL] if not bo . api_url : [EOL] log . info ( [string] ) [EOL] return bo [EOL] [EOL] log . debug ( f" [string] { ast }" ) [EOL] [EOL] [comment] [EOL] if isinstance ( ast , NSArg ) : [EOL] term_id = [string] . format ( ast . namespace , ast . value ) [EOL] value_types = ast . value_types [EOL] log . debug ( f" [string] { value_types } [string] { ast . value }" ) [EOL] [comment] [EOL] if ast . namespace == [string] : [comment] [EOL] for value_type in value_types : [EOL] default_namespace = [ ns [ [string] ] for ns in bo . spec [ [string] ] [ value_type ] [ [string] ] ] + [ ns [ [string] ] for ns in bo . spec [ [string] ] [ value_type ] [ [string] ] ] [EOL] [EOL] if ast . value in default_namespace : [EOL] log . debug ( [string] . format ( term_id ) ) [EOL] break [EOL] else : [comment] [EOL] log . debug ( [string] . format ( term_id ) ) [EOL] bo . validation_messages . append ( ( [string] , f" [string] { term_id } [string] " ) ) [EOL] [EOL] [comment] [EOL] else : [EOL] request_url = bo . api_url + [string] . format ( url_path_param_quoting ( term_id ) ) [EOL] log . info ( f" [string] { request_url }" ) [EOL] r = http_client . get ( request_url ) [EOL] if r and r . status_code == [number] : [EOL] result = r . json ( ) [EOL] [comment] [EOL] [EOL] log . debug ( f' [string] { ast . value_types } [string] { result . get ( [string] , [ ] ) }' ) [EOL] [EOL] [comment] [EOL] if len ( set ( ast . value_types ) . intersection ( result . get ( [string] , [ ] ) ) ) == [number] : [EOL] log . debug ( [string] . format ( term_id , ast . value_types , result . get ( [string] , [ ] ) ) ) [EOL] bo . validation_messages . append ( ( [string] , [string] . format ( term_id , ast . value_types , result . get ( [string] , [ ] ) ) , ) ) [EOL] [EOL] if term_id in result . get ( [string] , [ ] ) : [EOL] bo . validation_messages . append ( ( [string] , f' [string] { term_id } [string] { result [ [string] ] }' ) ) [EOL] [EOL] elif r . status_code == [number] : [EOL] bo . validation_messages . append ( ( [string] , f" [string] { term_id } [string] " ) ) [EOL] else : [EOL] log . error ( f" [string] { r . status_code } [string] { request_url }" ) [EOL] [EOL] [comment] [EOL] if isinstance ( ast , StrArg ) : [EOL] log . debug ( f" [string] { ast . value } [string] { ast . value_types }" ) [EOL] for value_type in ast . value_types : [EOL] [comment] [EOL] if re . match ( [string] , value_type ) : [EOL] value_type = re . sub ( [string] , [string] , value_type ) [EOL] value_type = re . sub ( [string] , [string] , value_type ) [EOL] match = re . match ( value_type , ast . value ) [EOL] if match : [EOL] break [EOL] if value_type in bo . spec [ [string] ] : [EOL] default_namespace = [ ns [ [string] ] for ns in bo . spec [ [string] ] [ value_type ] [ [string] ] ] + [ ns [ [string] ] for ns in bo . spec [ [string] ] [ value_type ] [ [string] ] ] [EOL] if ast . value in default_namespace : [EOL] break [EOL] else : [comment] [EOL] bo . validation_messages . append ( ( [string] , f" [string] { ast . value } [string] { ast . value_types }" , ) ) [EOL] [EOL] [comment] [EOL] if hasattr ( ast , [string] ) : [EOL] for arg in ast . args : [EOL] validate_arg_values ( arg , bo ) [EOL] [EOL] return bo [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Tuple[builtins.bool,typing.List[typing.Tuple[builtins.str,builtins.str]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import Match , ValuesView , MutableMapping , Tuple , Any , Dict , Literal , Type , Set , Pattern , List , Mapping , Optional [EOL] import builtins [EOL] import bel [EOL] import typing [EOL] import typing_extensions [EOL] [docstring] [EOL] [comment] [EOL] import copy [EOL] import logging [EOL] import logging . config [EOL] import re [EOL] from typing import Any , List , Mapping , MutableMapping , Optional , Tuple [EOL] [EOL] [comment] [EOL] import structlog [EOL] [EOL] [comment] [EOL] import bel . lang . bel_specification as bel_specification [EOL] from bel . Config import config [EOL] from bel . lang . ast import BELAst , Function , NSArg , StrArg [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] start_arg_chars = [ [string] , [string] ] [EOL] end_arg_chars = [ [string] , [string] ] [EOL] [EOL] relations_pattern_middle = re . compile ( [string] ) [EOL] relations_pattern_end = re . compile ( [string] ) [EOL] [EOL] Errors = List [ Tuple [ str , str , Optional [ Tuple [ int , int ] ] ] ] [comment] [EOL] Parsed = MutableMapping [ str , Any ] [EOL] AST = MutableMapping [ str , Any ] [EOL] CharLocs = Mapping [ str , Any ] [EOL] [EOL] [docstring] [EOL] [EOL] [EOL] def parse_chars ( bels , errors ) : [EOL] [docstring] [EOL] pstack , qstack , nested_pstack = [ ] , [ ] , [ ] [EOL] parens , nested_parens , quotes , commas = { } , { } , { } , { } [EOL] [EOL] notquoted_flag = True [EOL] [EOL] for i , c in enumerate ( bels ) : [EOL] prior_char = i - [number] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if c == [string] and bels [ prior_char ] != [string] and len ( qstack ) == [number] : [EOL] qstack . append ( i ) [EOL] notquoted_flag = False [EOL] [EOL] [comment] [EOL] elif c == [string] and bels [ prior_char ] != [string] : [EOL] quotes [ qstack . pop ( ) ] = i [EOL] notquoted_flag = True [EOL] [EOL] [comment] [EOL] elif c == [string] and bels [ prior_char ] == [string] and len ( qstack ) == [number] : [EOL] errors . append ( ( [string] , f" [string] { i - [number] }" , ( i - [number] , i - [number] ) , ) ) [EOL] [EOL] [comment] [EOL] elif notquoted_flag and c == [string] and bels [ prior_char ] == [string] : [EOL] if len ( nested_pstack ) > [number] : [EOL] errors . append ( ( [string] , f" [string] " , ( i , i ) , ) ) [EOL] [EOL] nested_pstack . append ( i ) [EOL] [EOL] [comment] [EOL] elif notquoted_flag and c == [string] and bels [ prior_char ] not in [ [string] ] : [EOL] pstack . append ( i ) [EOL] [EOL] [comment] [EOL] elif notquoted_flag and c == [string] and bels [ prior_char ] != [string] : [EOL] if len ( pstack ) : [EOL] if len ( pstack ) > [number] : [EOL] parens [ pstack . pop ( ) ] = ( i , [string] ) [EOL] else : [EOL] parens [ pstack . pop ( ) ] = ( i , [string] ) [EOL] elif len ( nested_pstack ) : [EOL] nested_parens [ nested_pstack . pop ( ) ] = ( i , [string] ) [EOL] else : [EOL] errors . append ( ( [string] , f" [string] { i }" , ( i , i ) , ) ) [EOL] [comment] [EOL] elif notquoted_flag and c == [string] and len ( qstack ) == [number] : [EOL] sparen = pstack [ - [number] ] [EOL] if sparen not in commas : [EOL] commas [ sparen ] = [ i ] [EOL] else : [EOL] commas [ sparen ] . append ( i ) [EOL] [EOL] while len ( pstack ) : [EOL] errors . append ( ( [string] , f" [string] { pstack [ - [number] ] }" , ( pstack [ - [number] ] , pstack [ - [number] ] ) , ) ) [EOL] if len ( pstack ) > [number] : [EOL] parens [ pstack . pop ( ) ] = ( - [number] , [string] ) [EOL] else : [EOL] parens [ pstack . pop ( ) ] = ( - [number] , [string] ) [EOL] [EOL] while len ( nested_pstack ) : [EOL] errors . append ( ( [string] , f" [string] { nested_pstack [ - [number] ] }" , ( nested_pstack [ - [number] ] , nested_pstack [ - [number] ] ) , ) ) [EOL] nested_parens [ nested_pstack . pop ( ) ] = ( - [number] , [string] ) [EOL] [EOL] if len ( qstack ) : [EOL] missing_quote = qstack . pop ( ) [EOL] errors . append ( ( [string] , f" [string] { missing_quote }" , ( missing_quote , missing_quote ) , ) ) [EOL] [EOL] return ( { [string] : parens , [string] : nested_parens , [string] : quotes , [string] : commas } , errors , ) [EOL] [EOL] [EOL] def parse_functions ( bels , char_locs , parsed , errors ) : [EOL] [docstring] [EOL] parens = char_locs [ [string] ] [EOL] [EOL] [comment] [EOL] if not parens : [EOL] bels_len = len ( bels ) - [number] [EOL] span = ( [number] , bels_len ) [EOL] parsed [ span ] = { [string] : [string] . join ( bels ) , [string] : [string] , [string] : span , [string] : (span) , [string] : [string] , } [EOL] return parsed , errors [EOL] [EOL] for sp in sorted ( parens ) : [comment] [EOL] ep , function_level = parens [ sp ] [EOL] [EOL] [comment] [EOL] if bels [ sp - [number] ] == [string] : [EOL] continue [EOL] [EOL] [comment] [EOL] for i in range ( sp - [number] , [number] , - [number] ) : [EOL] if bels [ i ] in [ [string] , [string] , [string] ] : [comment] [EOL] if i < sp - [number] : [EOL] if ep == - [number] : [EOL] span = ( i + [number] , len ( bels ) - [number] ) [EOL] else : [EOL] span = ( i + [number] , ep ) [EOL] [EOL] parsed [ span ] = { [string] : [string] . join ( bels [ i + [number] : sp ] ) , [string] : [string] , [string] : span , [string] : ( i + [number] , sp - [number] ) , [string] : ( sp , ep ) , [string] : function_level , } [EOL] break [EOL] else : [EOL] if ep == - [number] : [EOL] span = ( [number] , len ( bels ) - [number] ) [EOL] else : [EOL] span = ( [number] , ep ) [EOL] [EOL] parsed [ span ] = { [string] : [string] . join ( bels [ [number] : sp ] ) , [string] : [string] , [string] : span , [string] : ( [number] , sp - [number] ) , [string] : ( sp , ep ) , [string] : function_level , } [EOL] [EOL] return parsed , errors [EOL] [EOL] [EOL] def parse_args ( bels , char_locs , parsed , errors ) : [EOL] [docstring] [EOL] [EOL] commas = char_locs [ [string] ] [EOL] [EOL] [comment] [EOL] for span in parsed : [EOL] if parsed [ span ] [ [string] ] != [string] or [string] not in parsed [ span ] : [EOL] continue [comment] [EOL] sp , ep = parsed [ span ] [ [string] ] [EOL] [EOL] [comment] [EOL] if ep == - [number] : [comment] [EOL] args_end = len ( bels ) - [number] [comment] [EOL] else : [EOL] args_end = ep - [number] [comment] [EOL] [EOL] [comment] [EOL] args = [ ] [EOL] arg_start = sp + [number] [EOL] each_arg_end_list = sorted ( [ end - [number] for end in commas . get ( sp , [ ] ) ] + [ args_end ] ) [EOL] for arg_end in each_arg_end_list : [EOL] [comment] [EOL] [EOL] [comment] [EOL] while arg_start < args_end and bels [ arg_start ] == [string] : [EOL] arg_start += [number] [EOL] [EOL] [comment] [EOL] trimmed_arg_end = arg_end [EOL] while trimmed_arg_end > arg_start and bels [ trimmed_arg_end ] == [string] : [EOL] trimmed_arg_end -= [number] [EOL] [EOL] if trimmed_arg_end < arg_start : [EOL] trimmed_arg_end = arg_start [EOL] [EOL] arg = [string] . join ( bels [ arg_start : trimmed_arg_end + [number] ] ) [EOL] [EOL] [comment] [EOL] args . append ( { [string] : arg , [string] : ( arg_start , trimmed_arg_end ) } ) [EOL] arg_start = arg_end + [number] [EOL] [EOL] parsed [ span ] [ [string] ] = args [EOL] [EOL] return parsed , errors [EOL] [EOL] [EOL] def arg_types ( parsed , errors ) : [EOL] [docstring] [EOL] [EOL] func_pattern = re . compile ( [string] ) [EOL] nsarg_pattern = re . compile ( [string] ) [EOL] [EOL] for span in parsed : [EOL] if parsed [ span ] [ [string] ] != [string] or [string] not in parsed [ span ] : [EOL] continue [EOL] [EOL] for i , arg in enumerate ( parsed [ span ] [ [string] ] ) : [EOL] nsarg_matches = nsarg_pattern . match ( arg [ [string] ] ) [EOL] if func_pattern . match ( arg [ [string] ] ) : [EOL] parsed [ span ] [ [string] ] [ i ] . update ( { [string] : [string] } ) [EOL] elif nsarg_matches : [EOL] ( start , end ) = arg [ [string] ] [EOL] ns = nsarg_matches . group ( [number] ) [EOL] ns_val = nsarg_matches . group ( [number] ) [EOL] ns_span = nsarg_matches . span ( [number] ) [EOL] ns_span = ( ns_span [ [number] ] + start , ns_span [ [number] ] + start - [number] ) [EOL] ns_val_span = nsarg_matches . span ( [number] ) [EOL] ns_val_span = ( ns_val_span [ [number] ] + start , ns_val_span [ [number] ] + start - [number] ) [EOL] [EOL] parsed [ span ] [ [string] ] [ i ] . update ( { [string] : [string] , [string] : ns , [string] : ns_span , [string] : ns_val , [string] : ns_val_span , } ) [EOL] else : [EOL] parsed [ span ] [ [string] ] [ i ] . update ( { [string] : [string] } ) [EOL] [EOL] return parsed , errors [EOL] [EOL] [EOL] def parse_relations ( belstr , char_locs , parsed , errors ) : [EOL] [docstring] [EOL] quotes = char_locs [ [string] ] [EOL] quoted_range = set ( [ i for start , end in quotes . items ( ) for i in range ( start , end ) ] ) [EOL] [EOL] for match in relations_pattern_middle . finditer ( belstr ) : [EOL] ( start , end ) = match . span ( [number] ) [EOL] [comment] [EOL] end = end - [number] [comment] [EOL] if start != end : [EOL] test_range = set ( range ( start , end ) ) [EOL] else : [EOL] test_range = set ( start ) [EOL] [EOL] [comment] [EOL] if test_range . intersection ( quoted_range ) : [EOL] continue [EOL] [EOL] span_key = ( start , end ) [EOL] parsed [ span_key ] = { [string] : [string] , [string] : match . group ( [number] ) , [string] : ( start , end ) } [EOL] [EOL] for match in relations_pattern_end . finditer ( belstr ) : [EOL] ( start , end ) = match . span ( [number] ) [EOL] log . debug ( f" [string] { match }" ) [EOL] end = end - [number] [comment] [EOL] if start != end : [EOL] test_range = set ( range ( start , end ) ) [EOL] else : [EOL] test_range = set ( start ) [EOL] [EOL] [comment] [EOL] if test_range . intersection ( quoted_range ) : [EOL] continue [EOL] [EOL] span_key = ( start , end ) [EOL] parsed [ span_key ] = { [string] : [string] , [string] : match . group ( [number] ) , [string] : ( start , end ) } [EOL] [EOL] return parsed , errors [EOL] [EOL] [EOL] def parse_nested ( bels , char_locs , parsed , errors ) : [EOL] [docstring] [EOL] [EOL] for sp in char_locs [ [string] ] : [comment] [EOL] ep , level = char_locs [ [string] ] [ sp ] [EOL] if ep == - [number] : [EOL] ep = len ( bels ) + [number] [EOL] parsed [ ( sp , ep ) ] = { [string] : [string] , [string] : ( sp , ep ) } [EOL] [EOL] return parsed , errors [EOL] [EOL] [EOL] def dump_json ( d ) : [EOL] [docstring] [EOL] [EOL] import json [EOL] [EOL] k = d . keys ( ) [EOL] v = d . values ( ) [EOL] k1 = [ str ( i ) for i in k ] [EOL] [EOL] return json . dumps ( dict ( zip ( * [ k1 , v ] ) ) , indent = [number] ) [EOL] [EOL] [EOL] def collect_spans ( ast ) : [EOL] [docstring] [EOL] [EOL] spans = [ ] [EOL] [EOL] if ast . get ( [string] , False ) : [EOL] spans . extend ( collect_spans ( ast [ [string] ] ) ) [EOL] [EOL] if ast . get ( [string] , False ) : [EOL] spans . extend ( collect_spans ( ast [ [string] ] ) ) [EOL] [EOL] if ast . get ( [string] , False ) : [EOL] spans . extend ( collect_spans ( ast [ [string] ] ) ) [EOL] [EOL] if ast . get ( [string] , False ) : [EOL] log . debug ( f" [string] " ) [EOL] spans . append ( ( [string] , ast [ [string] ] [ [string] ] ) ) [EOL] log . debug ( f" [string] { spans }" ) [EOL] [EOL] if ast . get ( [string] , False ) : [EOL] for idx , arg in enumerate ( ast [ [string] ] ) : [EOL] log . debug ( f" [string] { arg }" ) [EOL] [EOL] if arg . get ( [string] , False ) : [EOL] log . debug ( f" [string] " ) [EOL] results = collect_spans ( arg ) [EOL] log . debug ( f" [string] { results }" ) [EOL] spans . extend ( results ) [comment] [EOL] elif arg . get ( [string] , False ) : [EOL] log . debug ( f" [string] { arg }" ) [EOL] spans . append ( ( [string] , arg [ [string] ] ) ) [EOL] spans . append ( ( [string] , arg [ [string] ] [ [string] ] ) ) [EOL] spans . append ( ( [string] , arg [ [string] ] [ [string] ] ) ) [EOL] elif arg [ [string] ] == [string] : [EOL] spans . append ( ( [string] , arg [ [string] ] ) ) [EOL] [EOL] log . debug ( f" [string] { spans }" ) [EOL] return spans [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def print_spans ( spans , max_idx ) : [EOL] [docstring] [EOL] [EOL] bel_spans = [ [string] ] * ( max_idx + [number] ) [EOL] for val , span in spans : [EOL] if val in [ [string] , [string] ] : [EOL] continue [EOL] for i in range ( span [ [number] ] , span [ [number] ] + [number] ) : [EOL] bel_spans [ i ] = val [ [number] ] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] bel_spans = [ [string] ] * ( max_idx + [number] ) [EOL] for val , span in spans : [EOL] if val not in [ [string] ] : [EOL] continue [EOL] for i in range ( span [ [number] ] , span [ [number] ] + [number] ) : [EOL] bel_spans [ i ] = val [ [number] ] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def parsed_function_to_ast ( parsed , parsed_key ) : [EOL] [docstring] [EOL] [EOL] sub = parsed [ parsed_key ] [EOL] [EOL] subtree = { [string] : [string] , [string] : sub [ [string] ] , [string] : { [string] : sub [ [string] ] , [string] : sub [ [string] ] , [string] : sub . get ( [string] , [ ] ) , } , } [EOL] [EOL] args = [ ] [EOL] for arg in parsed [ parsed_key ] . get ( [string] , [ ] ) : [EOL] [EOL] [comment] [EOL] [EOL] if arg [ [string] ] == [string] : [EOL] args . append ( parsed_function_to_ast ( parsed , arg [ [string] ] ) ) [EOL] elif arg [ [string] ] == [string] : [EOL] args . append ( { [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : { [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : arg [ [string] ] , } , } ) [EOL] elif arg [ [string] ] == [string] : [EOL] args . append ( { [string] : arg [ [string] ] , [string] : arg [ [string] ] , [string] : arg [ [string] ] } ) [EOL] [EOL] subtree [ [string] ] = copy . deepcopy ( args ) [EOL] [EOL] return subtree [EOL] [EOL] [EOL] def parsed_top_level_errors ( parsed , errors , component_type = [string] ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] fn_cnt = [number] [EOL] rel_cnt = [number] [EOL] nested_cnt = [number] [EOL] for key in parsed : [EOL] if parsed [ key ] [ [string] ] == [string] : [EOL] fn_cnt += [number] [EOL] if parsed [ key ] [ [string] ] == [string] : [EOL] rel_cnt += [number] [EOL] if parsed [ key ] [ [string] ] == [string] : [EOL] nested_cnt += [number] [EOL] [EOL] if not component_type : [EOL] if nested_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] [EOL] if nested_cnt : [EOL] if rel_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] elif fn_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] [EOL] else : [EOL] if rel_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] elif fn_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] [EOL] elif component_type == [string] : [EOL] if rel_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] elif fn_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] [EOL] elif component_type == [string] : [EOL] if nested_cnt : [EOL] if rel_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] elif fn_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] else : [EOL] if rel_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] elif fn_cnt > [number] : [EOL] errors . append ( ( [string] , [string] ) ) [EOL] [EOL] return errors [EOL] [EOL] [EOL] def parsed_to_ast ( parsed , errors , component_type = [string] ) : [EOL] [docstring] [EOL] [EOL] ast = { } [EOL] sorted_keys = sorted ( parsed . keys ( ) ) [EOL] [EOL] [comment] [EOL] for key in sorted_keys : [EOL] if parsed [ key ] [ [string] ] == [string] : [EOL] nested_component_stack = [ [string] , [string] ] [EOL] [EOL] if component_type : [EOL] component_stack = [ component_type ] [EOL] else : [EOL] component_stack = [ [string] , [string] ] [EOL] [EOL] for key in sorted_keys : [EOL] if parsed [ key ] [ [string] ] == [string] and parsed [ key ] [ [string] ] == [string] : [EOL] ast [ component_stack . pop ( [number] ) ] = parsed_function_to_ast ( parsed , key ) [EOL] elif parsed [ key ] [ [string] ] == [string] and [string] not in ast : [EOL] ast [ [string] ] = { [string] : parsed [ key ] [ [string] ] , [string] : [string] , [string] : key } [EOL] elif parsed [ key ] [ [string] ] == [string] : [EOL] ast [ [string] ] = { } [EOL] for nested_key in sorted_keys : [EOL] if nested_key <= key : [EOL] continue [EOL] [EOL] if ( parsed [ nested_key ] [ [string] ] == [string] [EOL] and parsed [ nested_key ] [ [string] ] == [string] ) : [EOL] ast [ [string] ] [ nested_component_stack . pop ( [number] ) ] = parsed_function_to_ast ( parsed , nested_key ) [EOL] elif parsed [ nested_key ] [ [string] ] == [string] and [string] not in ast [ [string] ] : [EOL] ast [ [string] ] [ [string] ] = { [string] : parsed [ nested_key ] [ [string] ] , [string] : [string] , [string] : parsed [ nested_key ] [ [string] ] , } [EOL] [EOL] return ast , errors [EOL] [EOL] return ast , errors [EOL] [EOL] [EOL] def get_ast_dict ( belstr , component_type = [string] ) : [EOL] [docstring] [EOL] [EOL] errors = [ ] [EOL] parsed = { } [EOL] bels = list ( belstr ) [EOL] char_locs , errors = parse_chars ( bels , errors ) [EOL] parsed , errors = parse_functions ( belstr , char_locs , parsed , errors ) [EOL] parsed , errors = parse_args ( bels , char_locs , parsed , errors ) [EOL] parsed , errors = arg_types ( parsed , errors ) [EOL] parsed , errors = parse_relations ( belstr , char_locs , parsed , errors ) [EOL] parsed , errors = parse_nested ( bels , char_locs , parsed , errors ) [EOL] errors = parsed_top_level_errors ( parsed , errors ) [EOL] [EOL] ast , errors = parsed_to_ast ( parsed , errors , component_type = component_type ) [EOL] [EOL] return ast , errors [EOL] [EOL] [EOL] def get_ast_obj ( belstr , bel_version , component_type = [string] ) : [EOL] [docstring] [EOL] [EOL] ast_dict , errors = get_ast_dict ( belstr , component_type ) [EOL] [EOL] spec = bel_specification . get_specification ( bel_version ) [EOL] [EOL] subj = ast_dict [ [string] ] [EOL] subj_ast = add_ast_fn ( subj , spec ) [EOL] [EOL] relation = None [EOL] obj = None [EOL] [EOL] if [string] in ast_dict : [EOL] relation = ast_dict [ [string] ] [ [string] ] [EOL] [EOL] if [string] in ast_dict : [EOL] obj = ast_dict [ [string] ] [EOL] obj_ast = add_ast_fn ( obj , spec ) [EOL] [EOL] return BELAst ( subj_ast , relation , obj_ast , spec ) [EOL] elif [string] in ast_dict : [EOL] nested_subj = ast_dict [ [string] ] [ [string] ] [EOL] nested_subj_ast = add_ast_fn ( nested_subj , spec ) [EOL] nested_relation = ast_dict [ [string] ] [ [string] ] [ [string] ] [EOL] nested_obj = ast_dict [ [string] ] [ [string] ] [EOL] nested_obj_ast = add_ast_fn ( nested_obj , spec ) [EOL] [EOL] return BELAst ( subj_ast , relation , BELAst ( nested_subj_ast , nested_relation , nested_obj_ast , spec ) , spec ) [EOL] [EOL] return BELAst ( subj_ast , None , None , spec ) [EOL] [EOL] [EOL] def add_ast_fn ( d , spec , parent_function = None ) : [EOL] [docstring] [EOL] [EOL] if d [ [string] ] == [string] : [EOL] ast_fn = Function ( d [ [string] ] [ [string] ] , spec , parent_function = parent_function ) [EOL] for arg in d [ [string] ] : [EOL] if arg [ [string] ] == [string] : [EOL] ast_fn . add_argument ( add_ast_fn ( arg , spec , parent_function = ast_fn ) ) [EOL] elif arg [ [string] ] == [string] : [EOL] ast_fn . add_argument ( NSArg ( arg [ [string] ] [ [string] ] , arg [ [string] ] [ [string] ] , ast_fn ) ) [EOL] elif arg [ [string] ] == [string] : [EOL] ast_fn . add_argument ( StrArg ( arg [ [string] ] , ast_fn ) ) [EOL] return ast_fn [EOL] [EOL] [EOL] def main ( ) : [EOL] [EOL] import json [EOL] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] [comment] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] belstr = [string] [EOL] [comment] [EOL] [comment] [EOL] [EOL] ast , errors = get_ast_dict ( belstr ) [EOL] [EOL] spans = collect_spans ( ast ) [EOL] [EOL] print ( [string] , belstr ) [EOL] print ( [string] , json . dumps ( spans , indent = [number] ) ) [EOL] [EOL] [comment] [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[typing.Tuple[builtins.str,typing.Tuple[builtins.int,builtins.int]]]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $None$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $Errors$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] from typing import Union , Any , Dict , List , Mapping , MutableSequence [EOL] import builtins [EOL] import bel [EOL] import _importlib_modulespec [EOL] import datetime [EOL] import typing [EOL] import datetime [EOL] import importlib [EOL] import os [EOL] import sys [EOL] from typing import Any , List , Mapping , Union [EOL] [EOL] [comment] [EOL] import structlog [EOL] from tatsu . exceptions import FailedParse [EOL] [EOL] [comment] [EOL] import bel . edge . computed [EOL] import bel . lang . ast as bel_ast [EOL] import bel . lang . bel_specification as bel_specification [EOL] import bel . lang . exceptions as bel_ex [EOL] import bel . lang . semantics as semantics [EOL] from bel . Config import config [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] sys . path . append ( [string] ) [EOL] [EOL] [EOL] class BEL ( object ) : [EOL] [docstring] [EOL] [EOL] def __init__ ( self , version = None , api_url = None ) : [EOL] [docstring] [EOL] [EOL] bel_versions = bel_specification . get_bel_versions ( ) [EOL] [EOL] [comment] [EOL] if not version : [EOL] self . version = config [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] self . version = version [EOL] [EOL] if self . version not in bel_versions : [EOL] log . warning ( f" [string] { self . version } [string] { bel_versions }" ) [EOL] [EOL] if not api_url : [EOL] self . api_url = config [ [string] ] [ [string] ] [ [string] ] [EOL] else : [EOL] self . api_url = api_url [EOL] [EOL] [comment] [EOL] [comment] [EOL] self . validation_messages = [ ] [EOL] [EOL] [comment] [EOL] self . spec = bel_specification . get_specification ( self . version ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] try : [EOL] parser_fn = self . spec [ [string] ] [ [string] ] [EOL] [EOL] parser_name = os . path . basename ( parser_fn ) . replace ( [string] , [string] ) [EOL] module_spec = importlib . util . spec_from_file_location ( parser_name , parser_fn ) [EOL] imported_parser = importlib . util . module_from_spec ( module_spec ) [EOL] module_spec . loader . exec_module ( imported_parser ) [EOL] self . parser = imported_parser . BELParser ( ) [EOL] except Exception as e : [EOL] [comment] [EOL] raise bel_ex . NoParserFound ( f" [string] { self . version } [string] { e }" ) [EOL] [EOL] def parse ( self , assertion , strict = False , parseinfo = False , rule_name = [string] , error_level = [string] , ) : [EOL] [docstring] [EOL] [EOL] self . ast = None [EOL] self . parse_valid = False [EOL] self . parse_visualize_error = [string] [EOL] self . validation_messages = [ ] [comment] [EOL] [EOL] if isinstance ( assertion , dict ) : [EOL] if assertion . get ( [string] , False ) and assertion . get ( [string] , False ) : [EOL] statement = f"{ assertion [ [string] ] } [string] { assertion [ [string] ] } [string] { assertion [ [string] ] }" [EOL] elif assertion . get ( [string] ) : [EOL] statement = f"{ assertion [ [string] ] }" [EOL] else : [EOL] statement = [string] [EOL] else : [EOL] statement = assertion [EOL] [EOL] self . original_bel_stmt = statement [EOL] [EOL] [comment] [EOL] self . bel_stmt = bel_ast . preprocess_bel_stmt ( statement ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] if len ( self . bel_stmt ) == [number] : [EOL] self . validation_messages . append ( ( [string] , [string] ) ) [EOL] return self [EOL] [EOL] try : [EOL] [comment] [EOL] [EOL] ast_dict = self . parser . parse ( self . bel_stmt , rule_name = rule_name , trace = False , parseinfo = parseinfo ) [EOL] self . ast = bel_ast . ast_dict_to_objects ( ast_dict , self ) [EOL] [EOL] self . parse_valid = True [EOL] [EOL] except FailedParse as e : [EOL] [comment] [EOL] error , visualize_error = bel_ast . handle_parser_syntax_error ( e ) [EOL] self . parse_visualize_error = visualize_error [EOL] if visualize_error : [EOL] self . validation_messages . append ( ( [string] , f"{ error } [string] { visualize_error }" ) ) [EOL] else : [EOL] self . validation_messages . append ( ( [string] , f"{ error } [string] { self . bel_stmt }" ) ) [EOL] self . ast = None [EOL] [EOL] except Exception as e : [EOL] log . exception ( [string] . format ( e , type ( e ) ) ) [EOL] self . validation_messages . append ( ( [string] , [string] . format ( e , type ( e ) ) ) ) [EOL] [EOL] return self [EOL] [EOL] def semantic_validation ( self , error_level = [string] ) : [EOL] [docstring] [EOL] [EOL] semantics . validate ( self , error_level ) [EOL] [EOL] return self [EOL] [EOL] def canonicalize ( self , namespace_targets = None ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [EOL] if not self . ast : [EOL] return self [EOL] [EOL] [comment] [EOL] if not self . ast . collected_nsarg_norms : [EOL] self = self . collect_nsarg_norms ( ) [EOL] [EOL] [comment] [EOL] self . ast . canonicalize ( ) [EOL] [EOL] [comment] [EOL] [EOL] return self [EOL] [EOL] def decanonicalize ( self , namespace_targets = None ) : [EOL] [docstring] [EOL] [EOL] if not self . ast : [EOL] return self [EOL] [EOL] [comment] [EOL] if not self . ast . collected_nsarg_norms : [EOL] self = self . collect_nsarg_norms ( ) [EOL] [EOL] self . ast . decanonicalize ( ) [EOL] [EOL] [comment] [EOL] return self [EOL] [EOL] def collect_nsarg_norms ( self ) : [EOL] [docstring] [EOL] start_time = datetime . datetime . now ( ) [EOL] [EOL] self . ast = bel_ast . populate_ast_nsarg_defaults ( self . ast , self . ast ) [EOL] self . ast . collected_nsarg_norms = True [EOL] if ( hasattr ( self . ast , [string] ) [EOL] and self . ast . bel_object [EOL] and self . ast . bel_object . type == [string] ) : [EOL] self . ast . bel_object . collected_nsarg_norms = True [EOL] [EOL] end_time = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time - start_time ) . total_seconds ( ) * [number] : [string] }" [EOL] [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] return self [EOL] [EOL] def orthologize ( self , species_id ) : [EOL] [docstring] [EOL] [EOL] if not self . ast : [EOL] return self [EOL] [EOL] [comment] [EOL] if not self . ast . collected_orthologs : [EOL] self = self . collect_orthologs ( [ species_id ] ) [EOL] [EOL] self . ast . species = set ( ) [EOL] self . ast = bel_ast . orthologize ( self . ast , self , species_id ) [EOL] [EOL] return self [EOL] [EOL] def collect_orthologs ( self , species ) : [EOL] [docstring] [EOL] [EOL] if not species : [EOL] return self [EOL] [EOL] species_labels = bel . terms . terms . get_labels ( species ) [EOL] [EOL] [comment] [EOL] if not self . ast . collected_nsarg_norms : [EOL] self = self . collect_nsarg_norms ( ) [EOL] [EOL] start_time = datetime . datetime . now ( ) [EOL] [EOL] self . ast = bel_ast . populate_ast_nsarg_orthologs ( self . ast , species_labels ) [EOL] self . ast . collected_orthologs = True [EOL] if ( hasattr ( self . ast , [string] ) [EOL] and self . ast . bel_object [EOL] and self . ast . bel_object . type == [string] ) : [EOL] self . ast . bel_object . collected_orthologs = True [EOL] [EOL] end_time = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time - start_time ) . total_seconds ( ) * [number] : [string] }" [EOL] [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] return self [EOL] [EOL] def compute_edges ( self , rules = None , ast_result = False , fmt = [string] ) : [EOL] [docstring] [EOL] [EOL] if not self . ast : [EOL] return self [EOL] [EOL] edges_asts = bel . edge . computed . compute_edges ( self . ast , self . spec ) [EOL] [EOL] if ast_result : [EOL] return edges_asts [EOL] [EOL] edges = [ ] [EOL] for ast in edges_asts : [EOL] edges . append ( { [string] : ast . bel_subject . to_string ( ) , [string] : ast . bel_relation , [string] : ast . bel_object . to_string ( ) , } ) [EOL] [EOL] return edges [EOL] [EOL] def to_string ( self , fmt = [string] ) : [EOL] [docstring] [EOL] [EOL] if self . ast : [EOL] return f"{ self . ast . to_string ( ast_obj = self . ast , fmt = fmt ) }" [EOL] [EOL] def to_triple ( self , fmt = [string] ) : [EOL] [docstring] [EOL] [EOL] if self . ast : [EOL] return self . ast . to_triple ( ast_obj = self . ast , fmt = fmt ) [EOL] else : [EOL] return { } [EOL] [EOL] def print_tree ( self ) : [EOL] [docstring] [EOL] [EOL] if self . ast : [EOL] return self . ast . print_tree ( ast_obj = self . ast ) [EOL] else : [EOL] return [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.dict$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import typing [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import collections [EOL] import json [EOL] import math [EOL] import os [EOL] import pprint [EOL] import random [EOL] import re [EOL] import string [EOL] from typing import Any , List , Mapping [EOL] [EOL] [comment] [EOL] import yaml [EOL] [EOL] [comment] [EOL] import bel . lang . exceptions as bel_ex [EOL] from bel . lang . ast import Arg , BELAst , Function , NSArg , StrArg [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class InvalidStatementObject ( object ) : [EOL] def __init__ ( self , s , r , o ) : [EOL] self . subject = s [EOL] self . relation = r [EOL] self . object = o [EOL] self . string_form = self . to_string_form ( s , r , o ) [EOL] [EOL] def to_string_form ( self , s , r , o ) : [EOL] [EOL] sub = self . stmt_creation_decode ( s ) [EOL] rlt = r [EOL] obj = self . stmt_creation_decode ( o ) [EOL] [EOL] return [string] . format ( sub , rlt , obj ) [EOL] [EOL] def stmt_creation_decode ( self , ast_dict ) : [EOL] [EOL] arg_type = ast_dict . get ( [string] , False ) [EOL] arg_value = ast_dict . get ( [string] , False ) [EOL] [EOL] if arg_type == [string] : [EOL] f_name = ast_dict . get ( [string] , None ) [EOL] [EOL] tmp = self . stmt_creation_decode ( arg_value [ [number] ] ) [EOL] [EOL] for arg in arg_value [ [number] : ] : [EOL] tmp += [string] . format ( self . stmt_creation_decode ( arg ) ) [EOL] [EOL] return [string] . format ( f_name , tmp ) [EOL] [EOL] elif arg_type == [string] : [EOL] return arg_value [EOL] elif arg_type == [string] : [EOL] return arg_value [EOL] else : [EOL] return [string] [EOL] [EOL] [EOL] [comment] [EOL] def create_invalid ( bel_obj , count , max_args ) : [EOL] [EOL] list_of_statement_objs = [ ] [EOL] [EOL] for _ in range ( count ) : [EOL] stmt_obj = make_statement ( bel_obj , max_args ) [EOL] list_of_statement_objs . append ( stmt_obj ) [EOL] [EOL] return list_of_statement_objs [EOL] [EOL] [EOL] def make_statement ( bel_obj , max_args ) : [EOL] [EOL] s = choose_and_make_function ( bel_obj , max_args ) [EOL] r = choose_rand_relation ( bel_obj . relations ) [EOL] o = choose_and_make_function ( bel_obj , max_args ) [EOL] [EOL] return InvalidStatementObject ( s , r , o ) [EOL] [EOL] [EOL] def choose_and_make_function ( bel_obj , max_args ) : [EOL] [EOL] full_func = { [string] : choose_rand_function ( bel_obj . function_signatures ) , [string] : [string] , [string] : [ ] , } [EOL] [EOL] num_args = random . randint ( [number] , max_args ) [comment] [EOL] for _ in range ( num_args ) : [EOL] [EOL] t = random . choice ( [ [string] , [string] , [string] ] ) [EOL] arg = { [string] : t } [EOL] [EOL] if t == [string] : [EOL] arg [ [string] ] = random_namespace_arg ( ) [EOL] elif t == [string] : [EOL] arg [ [string] ] = random_quoted_string ( ) [EOL] elif t == [string] : [EOL] arg = choose_and_make_function ( bel_obj , max_args ) [EOL] else : [EOL] pass [EOL] [EOL] full_func [ [string] ] . append ( arg ) [EOL] [EOL] return full_func [EOL] [EOL] [EOL] def choose_rand_relation ( relations ) : [EOL] [EOL] return random . choice ( relations ) [EOL] [EOL] [EOL] def choose_rand_function ( func_sigs ) : [EOL] [EOL] return random . choice ( list ( func_sigs . keys ( ) ) ) [EOL] [EOL] [EOL] def random_namespace_arg ( ) : [EOL] ascii_letters = string . ascii_uppercase + string . ascii_lowercase [EOL] ascii_alphanumeric_upper = string . ascii_uppercase + string . digits [EOL] ascii_alphanumeric = ascii_letters + string . digits [EOL] [EOL] i = random . randint ( [number] , [number] ) [EOL] rand_nspace = [string] + [string] . join ( random . choice ( ascii_alphanumeric_upper ) for _ in range ( i ) ) [EOL] [EOL] j = random . randint ( [number] , [number] ) [EOL] [EOL] if random . random ( ) < [number] : [comment] [EOL] rand_nsvalue = [string] . join ( random . choice ( ascii_alphanumeric + [string] ) for _ in range ( j ) ) [EOL] rand_nsvalue = [string] . format ( rand_nsvalue ) [EOL] else : [comment] [EOL] rand_nsvalue = [string] . join ( random . choice ( ascii_alphanumeric ) for _ in range ( j ) ) [EOL] [EOL] return [string] . format ( rand_nspace , rand_nsvalue ) [EOL] [EOL] [EOL] def random_quoted_string ( ) : [EOL] ascii_letters = string . ascii_uppercase + string . ascii_lowercase [EOL] ascii_alphanumeric = ascii_letters + string . digits [EOL] [EOL] j = random . randint ( [number] , [number] ) [EOL] [EOL] rand_nsvalue = [string] . join ( random . choice ( ascii_alphanumeric + [string] ) for _ in range ( j ) ) [EOL] return [string] . format ( rand_nsvalue ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] class Colors : [EOL] PINK = [string] [EOL] BLUE = [string] [EOL] GREEN = [string] [EOL] YELLOW = [string] [EOL] RED = [string] [EOL] END = [string] [EOL] BOLD = [string] [EOL] UNDERLINE = [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 $typing.Any$ 0 0 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 $typing.Any$ 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0
class InvalidArgeter ( Exception ) : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] class ArgeterMissing ( Exception ) : [EOL] def __init__ ( self , function ) : [EOL] self . message = [string] . format ( function ) [EOL] [EOL] [EOL] class NoValidSignature ( Exception ) : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] class InvalidRelationship ( Exception ) : [EOL] def __init__ ( self , given_r ) : [EOL] self . message = [string] . format ( given_r ) [EOL] [EOL] [EOL] class MissingParenthesis ( Exception ) : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] class InvalidCharacter ( Exception ) : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] class MissingQuotation ( Exception ) : [EOL] def __init__ ( self , message ) : [EOL] self . message = message [EOL] [EOL] [EOL] class NoParserFound ( Exception ) : [EOL] def __init__ ( self , version ) : [EOL] self . message = [string] . format ( version ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
	0
[comment] [EOL] from typing import Any [EOL] import builtins [EOL] import typing [EOL] import copy [EOL] import gzip [EOL] import json [EOL] [EOL] [comment] [EOL] import timy [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] import bel . db . arangodb as arangodb [EOL] import bel . db . elasticsearch as elasticsearch [EOL] import bel . resources . namespace [EOL] import bel . resources . ortholog [EOL] import bel . utils [EOL] from bel . Config import config [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] [comment] [EOL] timy . timy_config . tracking_mode = timy . TrackingMode . LOGGING [EOL] [EOL] [EOL] def load_resource ( resource_url , forceupdate = False ) : [EOL] [docstring] [EOL] [EOL] log . info ( f" [string] { resource_url }" ) [EOL] [EOL] try : [EOL] [comment] [EOL] fo = bel . utils . download_file ( resource_url ) [EOL] [EOL] if not fo : [EOL] log . error ( f" [string] { resource_url }" ) [EOL] return [string] [EOL] [EOL] [comment] [EOL] fo . seek ( [number] ) [EOL] with gzip . open ( fo , [string] ) as f : [EOL] metadata = json . loads ( f . __next__ ( ) ) [EOL] [EOL] if [string] not in metadata : [EOL] log . error ( f" [string] { resource_url }" ) [EOL] return [string] [EOL] [EOL] [comment] [EOL] if metadata [ [string] ] [ [string] ] == [string] : [EOL] bel . resources . namespace . load_terms ( fo , metadata , forceupdate ) [EOL] [EOL] elif metadata [ [string] ] [ [string] ] == [string] : [EOL] bel . resources . ortholog . load_orthologs ( fo , metadata ) [EOL] [EOL] finally : [EOL] fo . close ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , IO [EOL] import builtins [EOL] import typing [EOL] import gzip [EOL] import json [EOL] from typing import IO [EOL] [EOL] [comment] [EOL] import timy [EOL] from arango import ArangoError [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] import bel . db . arangodb as arangodb [EOL] import bel . utils [EOL] from bel . Config import config [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] [EOL] def load_orthologs ( fo , metadata ) : [EOL] [docstring] [EOL] [EOL] version = metadata [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] with timy . Timer ( [string] ) as timer : [EOL] [EOL] arango_client = arangodb . get_client ( ) [EOL] if not arango_client : [EOL] print ( [string] ) [EOL] quit ( ) [EOL] belns_db = arangodb . get_belns_handle ( arango_client ) [EOL] arangodb . batch_load_docs ( belns_db , orthologs_iterator ( fo , version ) , on_duplicate = [string] ) [EOL] [EOL] log . info ( [string] , elapsed = timer . elapsed , source = metadata [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] remove_old_ortholog_edges = f""" [string] { metadata [ [string] ] [ [string] ] } [string] { version } [string] """ [EOL] remove_old_ortholog_nodes = f""" [string] { metadata [ [string] ] [ [string] ] } [string] { version } [string] """ [EOL] arangodb . aql_query ( belns_db , remove_old_ortholog_edges ) [EOL] arangodb . aql_query ( belns_db , remove_old_ortholog_nodes ) [EOL] [EOL] [comment] [EOL] metadata [ [string] ] = f" [string] { metadata [ [string] ] [ [string] ] }" [EOL] try : [EOL] belns_db . collection ( arangodb . belns_metadata_name ) . insert ( metadata ) [EOL] except ArangoError as ae : [EOL] belns_db . collection ( arangodb . belns_metadata_name ) . replace ( metadata ) [EOL] [EOL] [EOL] def orthologs_iterator ( fo , version ) : [EOL] [docstring] [EOL] [EOL] species_list = config [ [string] ] . get ( [string] , [ ] ) [EOL] [EOL] fo . seek ( [number] ) [EOL] with gzip . open ( fo , [string] ) as f : [EOL] for line in f : [EOL] edge = json . loads ( line ) [EOL] if [string] in edge : [EOL] source = edge [ [string] ] [ [string] ] [EOL] continue [EOL] [EOL] if [string] in edge : [EOL] edge = edge [ [string] ] [EOL] subj_tax_id = edge [ [string] ] [ [string] ] [EOL] obj_tax_id = edge [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] if species_list and subj_tax_id and subj_tax_id not in species_list : [EOL] continue [EOL] if species_list and obj_tax_id and obj_tax_id not in species_list : [EOL] continue [EOL] [EOL] [comment] [EOL] subj_key = arangodb . arango_id_to_key ( edge [ [string] ] [ [string] ] ) [EOL] subj_id = edge [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] obj_key = arangodb . arango_id_to_key ( edge [ [string] ] [ [string] ] ) [EOL] obj_id = edge [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] yield ( arangodb . ortholog_nodes_name , { [string] : subj_key , [string] : subj_id , [string] : edge [ [string] ] [ [string] ] , [string] : source , [string] : version , } , ) [EOL] [comment] [EOL] yield ( arangodb . ortholog_nodes_name , { [string] : obj_key , [string] : obj_id , [string] : edge [ [string] ] [ [string] ] , [string] : source , [string] : version , } , ) [EOL] [EOL] arango_edge = { [string] : f"{ arangodb . ortholog_nodes_name } [string] { subj_key }" , [string] : f"{ arangodb . ortholog_nodes_name } [string] { obj_key }" , [string] : bel . utils . _create_hash ( f"{ subj_id } [string] { obj_id }" ) , [string] : [string] , [string] : source , [string] : version , } [EOL] [EOL] yield ( arangodb . ortholog_edges_name , arango_edge ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict , Set , IO [EOL] import builtins [EOL] import typing [EOL] import copy [EOL] import gzip [EOL] import json [EOL] from typing import IO [EOL] [EOL] [comment] [EOL] import timy [EOL] from arango import ArangoError [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] import bel . db . arangodb as arangodb [EOL] import bel . db . elasticsearch as elasticsearch [EOL] import bel . utils [EOL] from bel . Config import config [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] terms_alias = [string] [EOL] [EOL] [EOL] def load_terms ( fo , metadata , forceupdate ) : [EOL] [docstring] [EOL] [EOL] version = metadata [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] with timy . Timer ( [string] ) as timer : [EOL] es = bel . db . elasticsearch . get_client ( ) [EOL] [EOL] es_version = version . replace ( [string] , [string] ) . replace ( [string] , [string] ) . replace ( [string] , [string] ) [EOL] index_prefix = f" [string] { metadata [ [string] ] [ [string] ] . lower ( ) }" [EOL] index_name = f"{ index_prefix } [string] { es_version }" [EOL] [EOL] [comment] [EOL] if not elasticsearch . index_exists ( es , index_name ) : [EOL] elasticsearch . create_terms_index ( es , index_name ) [EOL] elif forceupdate : [comment] [EOL] index_name += [string] [EOL] elasticsearch . create_terms_index ( es , index_name ) [EOL] else : [EOL] return [comment] [EOL] [EOL] terms_iterator = terms_iterator_for_elasticsearch ( fo , index_name ) [EOL] elasticsearch . bulk_load_docs ( es , terms_iterator ) [EOL] [EOL] [comment] [EOL] index_names = elasticsearch . get_all_index_names ( es ) [EOL] for name in index_names : [EOL] if name != index_name and index_prefix in name : [EOL] elasticsearch . delete_index ( es , name ) [EOL] [EOL] [comment] [EOL] elasticsearch . add_index_alias ( es , index_name , terms_alias ) [EOL] [EOL] log . info ( [string] , elapsed = timer . elapsed , namespace = metadata [ [string] ] [ [string] ] , ) [EOL] [EOL] [comment] [EOL] with timy . Timer ( [string] ) as timer : [EOL] arango_client = arangodb . get_client ( ) [EOL] if not arango_client : [EOL] print ( [string] ) [EOL] quit ( ) [EOL] belns_db = arangodb . get_belns_handle ( arango_client ) [EOL] arangodb . batch_load_docs ( belns_db , terms_iterator_for_arangodb ( fo , version ) , on_duplicate = [string] ) [EOL] [EOL] log . info ( [string] , elapsed = timer . elapsed , namespace = metadata [ [string] ] [ [string] ] , ) [EOL] [EOL] [comment] [EOL] remove_old_equivalence_edges = f""" [string] { metadata [ [string] ] [ [string] ] } [string] { version } [string] """ [EOL] remove_old_equivalence_nodes = f""" [string] { metadata [ [string] ] [ [string] ] } [string] { version } [string] """ [EOL] arangodb . aql_query ( belns_db , remove_old_equivalence_edges ) [EOL] arangodb . aql_query ( belns_db , remove_old_equivalence_nodes ) [EOL] [EOL] [comment] [EOL] metadata [ [string] ] = f" [string] { metadata [ [string] ] [ [string] ] }" [EOL] try : [EOL] belns_db . collection ( arangodb . belns_metadata_name ) . insert ( metadata ) [EOL] except ArangoError as ae : [EOL] belns_db . collection ( arangodb . belns_metadata_name ) . replace ( metadata ) [EOL] [EOL] [EOL] def terms_iterator_for_arangodb ( fo , version ) : [EOL] [EOL] species_list = config [ [string] ] . get ( [string] , [ ] ) [EOL] [EOL] fo . seek ( [number] ) [EOL] with gzip . open ( fo , [string] ) as f : [EOL] for line in f : [EOL] term = json . loads ( line ) [EOL] [comment] [EOL] if [string] not in term : [EOL] continue [EOL] term = term [ [string] ] [EOL] [EOL] species_id = term . get ( [string] , None ) [EOL] [comment] [EOL] if species_list and species_id and species_id not in species_list : [EOL] continue [EOL] [EOL] source = term [ [string] ] [EOL] term_id = term [ [string] ] [EOL] term_key = arangodb . arango_id_to_key ( term_id ) [EOL] [EOL] ( ns , val ) = term_id . split ( [string] , maxsplit = [number] ) [EOL] [EOL] [comment] [EOL] yield ( arangodb . equiv_nodes_name , { [string] : term_key , [string] : term_id , [string] : True , [string] : ns , [string] : source , [string] : version , } , ) [EOL] [EOL] [comment] [EOL] if [string] in term : [EOL] for alt_id in term [ [string] ] : [EOL] [comment] [EOL] alt_id_key = arangodb . arango_id_to_key ( alt_id ) [EOL] yield ( arangodb . equiv_nodes_name , { [string] : alt_id_key , [string] : alt_id , [string] : ns , [string] : source , [string] : version , } , ) [EOL] [EOL] arango_edge = { [string] : f"{ arangodb . equiv_nodes_name } [string] { term_key }" , [string] : f"{ arangodb . equiv_nodes_name } [string] { alt_id_key }" , [string] : bel . utils . _create_hash ( f"{ term_id } [string] { alt_id }" ) , [string] : [string] , [string] : source , [string] : version , } [EOL] yield ( arangodb . equiv_edges_name , arango_edge ) [EOL] [EOL] [comment] [EOL] if [string] in term : [EOL] for eqv in term [ [string] ] : [EOL] ( ns , val ) = eqv . split ( [string] , maxsplit = [number] ) [EOL] eqv_key = arangodb . arango_id_to_key ( eqv ) [EOL] [EOL] yield ( arangodb . equiv_nodes_name , { [string] : eqv_key , [string] : eqv , [string] : ns , [string] : source , [string] : version , } , ) [EOL] [EOL] arango_edge = { [string] : f"{ arangodb . equiv_nodes_name } [string] { term_key }" , [string] : f"{ arangodb . equiv_nodes_name } [string] { eqv_key }" , [string] : bel . utils . _create_hash ( f"{ term_id } [string] { eqv }" ) , [string] : [string] , [string] : source , [string] : version , } [EOL] yield ( arangodb . equiv_edges_name , arango_edge ) [EOL] [EOL] [EOL] def terms_iterator_for_elasticsearch ( fo , index_name ) : [EOL] [docstring] [EOL] [EOL] species_list = config [ [string] ] . get ( [string] , [ ] ) [EOL] [EOL] fo . seek ( [number] ) [comment] [EOL] with gzip . open ( fo , [string] ) as f : [EOL] for line in f : [EOL] term = json . loads ( line ) [EOL] [comment] [EOL] if [string] not in term : [EOL] continue [EOL] term = term [ [string] ] [EOL] [EOL] [comment] [EOL] species_id = term . get ( [string] , None ) [EOL] if species_list and species_id and species_id not in species_list : [EOL] continue [EOL] [EOL] all_term_ids = set ( ) [EOL] for term_id in [ term [ [string] ] ] + term . get ( [string] , [ ] ) : [EOL] all_term_ids . add ( term_id ) [EOL] all_term_ids . add ( lowercase_term_id ( term_id ) ) [EOL] [EOL] term [ [string] ] = copy . copy ( list ( all_term_ids ) ) [EOL] [EOL] yield { [string] : [string] , [string] : index_name , [string] : [string] , [string] : term [ [string] ] , [string] : copy . deepcopy ( term ) , } [EOL] [EOL] [EOL] def lowercase_term_id ( term_id ) : [EOL] [docstring] [EOL] ( ns , val ) = term_id . split ( [string] , maxsplit = [number] ) [EOL] term_id = f"{ ns } [string] { val . lower ( ) }" [EOL] [EOL] return term_id [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
	0
[comment] [EOL] [EOL] [comment] [EOL] from typing import Any , Dict , Type , List , Mapping , MutableSequence [EOL] import builtins [EOL] import bel [EOL] import typing [EOL] import copy [EOL] from typing import Any , List , Mapping , MutableSequence [EOL] [EOL] [comment] [EOL] from structlog import get_logger [EOL] [EOL] [comment] [EOL] from bel . lang . ast import BELAst , Function , NSArg [EOL] [EOL] log = get_logger ( ) [EOL] [EOL] [comment] [EOL] Edges = MutableSequence [ Mapping [ str , Any ] ] [EOL] BELSpec = Mapping [ str , Any ] [EOL] ComputeRules = List [ str ] [EOL] [EOL] locations = { [string] : NSArg ( [string] , [string] ) , [string] : NSArg ( [string] , [string] ) , } [EOL] [EOL] [EOL] def compute_edges ( ast , spec ) : [EOL] [docstring] [EOL] [EOL] edges = [ ] [EOL] if ast . bel_object . __class__ . __name__ == [string] : [EOL] edges . append ( ast . bel_object ) [EOL] [EOL] process_ast ( edges , ast , spec ) [EOL] return edges [EOL] [EOL] [EOL] def process_ast ( edges , ast , spec ) : [EOL] [EOL] if isinstance ( ast , BELAst ) : [EOL] pass [EOL] [EOL] [comment] [EOL] [comment] [EOL] elif isinstance ( ast , Function ) : [EOL] if ast . name in ( [string] , [string] ) : [EOL] for arg in ast . args : [EOL] edges . append ( BELAst ( ast , [string] , arg , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] for arg in ast . args : [EOL] edges . append ( BELAst ( ast , [string] , arg , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] subject = ast . args [ [number] ] [EOL] edge = BELAst ( subject , [string] , ast , spec ) [EOL] edges . append ( edge ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( parent . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( parent . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( parent . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( parent . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] src_abundance = ast . args [ [number] ] [EOL] from_abundance = copy . deepcopy ( src_abundance ) [EOL] from_loc = Function ( [string] , spec ) [EOL] from_loc . add_argument ( ast . args [ [number] ] . args [ [number] ] ) [EOL] from_abundance . add_argument ( from_loc ) [EOL] [EOL] to_abundance = copy . deepcopy ( src_abundance ) [EOL] to_loc = Function ( [string] , spec ) [EOL] to_loc . add_argument ( ast . args [ [number] ] . args [ [number] ] ) [EOL] to_abundance . add_argument ( to_loc ) [EOL] [EOL] edges . append ( BELAst ( ast , [string] , from_abundance , spec ) ) [EOL] edges . append ( BELAst ( ast , [string] , to_abundance , spec ) ) [EOL] edges . append ( BELAst ( src_abundance , [string] , from_abundance , spec ) ) [EOL] edges . append ( BELAst ( src_abundance , [string] , to_abundance , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] , [string] , [string] ) : [EOL] target_loc = locations [ [string] ] [EOL] if ast . name in ( [string] , [string] ) : [EOL] target_loc = locations [ [string] ] [EOL] [EOL] src_abundance = ast . args [ [number] ] [EOL] to_abundance = copy . deepcopy ( src_abundance ) [EOL] to_loc = Function ( [string] , spec ) [EOL] to_loc . add_argument ( target_loc ) [EOL] to_abundance . add_argument ( to_loc ) [EOL] edges . append ( BELAst ( ast , [string] , to_abundance , spec ) ) [EOL] edges . append ( BELAst ( src_abundance , [string] , to_abundance , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] edges . append ( BELAst ( ast , [string] , ast . args [ [number] ] , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( ast . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( ast . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] [EOL] relation = [string] [EOL] if ast . name == [string] : [EOL] relation = [string] [EOL] [EOL] for arg in ast . args : [EOL] edges . append ( BELAst ( parent , relation , arg , spec ) ) [EOL] [EOL] elif ast . name in ( [string] , [string] ) : [EOL] parent = ast . parent_function [EOL] [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( ast . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] src_abundance = Function ( parent . name , spec ) [EOL] src_abundance . add_argument ( ast . args [ [number] ] ) [EOL] edges . append ( BELAst ( src_abundance , [string] , parent , spec ) ) [EOL] [EOL] [comment] [EOL] if hasattr ( ast , [string] ) : [EOL] for arg in ast . args : [EOL] process_ast ( edges , arg , spec ) [EOL] [EOL] [EOL] [comment] [EOL] def process_rule ( edges , ast , rule , spec ) : [EOL] [docstring] [EOL] ast_type = ast . __class__ . __name__ [EOL] trigger_functions = rule . get ( [string] , [ ] ) [EOL] trigger_types = rule . get ( [string] , [ ] ) [EOL] rule_subject = rule . get ( [string] ) [EOL] rule_relation = rule . get ( [string] ) [EOL] rule_object = rule . get ( [string] ) [EOL] [EOL] log . debug ( f" [string] { rule_relation } [string] { ast_type }" ) [EOL] [EOL] if isinstance ( ast , Function ) : [EOL] function_name = ast . name [EOL] args = ast . args [EOL] parent_function = ast . parent_function [EOL] [EOL] if function_name in trigger_functions : [EOL] if rule_subject == [string] : [EOL] subject = ast [EOL] [EOL] if rule_object == [string] : [EOL] for arg in args : [EOL] log . debug ( f" [string] { subject } [string] { arg }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , arg , spec ) [EOL] edges . append ( edge_ast ) [EOL] elif rule_object == [string] and parent_function : [EOL] log . debug ( f" [string] { subject } [string] { parent_function }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , parent_function , spec ) [EOL] edges . append ( edge_ast ) [EOL] [EOL] elif ast_type in trigger_types : [EOL] if rule_subject == [string] : [EOL] subject = ast [EOL] [EOL] if rule_object == [string] : [EOL] for arg in args : [EOL] log . debug ( f" [string] { subject } [string] { arg }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , arg , spec ) [EOL] edges . append ( edge_ast ) [EOL] elif rule_object == [string] and parent_function : [EOL] log . debug ( f" [string] { subject } [string] { parent_function }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , parent_function , spec ) [EOL] edges . append ( edge_ast ) [EOL] [EOL] if isinstance ( ast , NSArg ) : [EOL] term = [string] . format ( ast . namespace , ast . value ) [EOL] parent_function = ast . parent_function [EOL] [EOL] if ast_type in trigger_types : [EOL] if rule_subject == [string] : [EOL] subject = term [EOL] [EOL] if rule_object == [string] : [EOL] for arg in args : [EOL] log . debug ( f" [string] { subject } [string] { arg }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , arg , spec ) [EOL] edges . append ( edge_ast ) [EOL] elif rule_object == [string] and parent_function : [EOL] log . debug ( f" [string] { subject } [string] { parent_function }" ) [EOL] edge_ast = BELAst ( subject , rule_relation , parent_function , spec ) [EOL] edges . append ( edge_ast ) [EOL] [EOL] [comment] [EOL] if hasattr ( ast , [string] ) : [EOL] for arg in ast . args : [EOL] process_rule ( edges , arg , rule , spec ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [EOL] from typing import List , Any , Dict [EOL] import builtins [EOL] import datetime [EOL] import typing [EOL] import urllib [EOL] [docstring] [EOL] [EOL] [comment] [EOL] import copy [EOL] import datetime [EOL] import itertools [EOL] import json [EOL] import os . path [EOL] import urllib [EOL] [EOL] [comment] [EOL] import structlog [EOL] [EOL] [comment] [EOL] import bel . db . arangodb as arangodb [EOL] import bel . edge . edges [EOL] import bel . nanopub . files as files [EOL] import bel . utils as utils [EOL] from bel . utils import http_client [EOL] [EOL] log = structlog . getLogger ( __name__ ) [EOL] [EOL] [EOL] client = arangodb . get_client ( ) [EOL] edgestore_db = arangodb . get_edgestore_handle ( client ) [EOL] [EOL] edges_coll_name = arangodb . edgestore_edges_name [EOL] nodes_coll_name = arangodb . edgestore_nodes_name [EOL] [EOL] [EOL] def get_edges_for_nanopub ( nanopub_id ) : [EOL] query = f""" [string] { nanopub_id } [string] """ [EOL] try : [EOL] result = [ edge for edge in edgestore_db . aql . execute ( query ) ] [EOL] return result [ [number] ] [EOL] except Exception : [EOL] return None [EOL] [EOL] [EOL] def process_nanopub ( nanopub_url , orthologize_targets = [ ] , overwrite = False , token = None ) : [EOL] [EOL] log . debug ( [string] , nanopub_url = nanopub_url , orthologize_targets = orthologize_targets , overwrite = overwrite , ) [EOL] log . info ( [string] , nanopub_url = nanopub_url ) [EOL] [EOL] url_comps = urllib . parse . urlparse ( nanopub_url ) [EOL] nanopub_id = os . path . basename ( url_comps . path ) [EOL] [comment] [EOL] [EOL] start_time = datetime . datetime . now ( ) [EOL] [EOL] [comment] [EOL] headers = { } [EOL] if token : [EOL] headers = { [string] : f" [string] { token }" } [EOL] [EOL] r = http_client . get ( nanopub_url , headers = headers ) [EOL] [EOL] nanopub = r . json ( ) [EOL] [EOL] end_time1 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time1 - start_time ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms , nanopub = nanopub ) [EOL] [EOL] assertions = [ ] [EOL] for assertion in nanopub [ [string] ] . get ( [string] , [ ] ) : [EOL] assertions . append ( f"{ assertion [ [string] ] } [string] { assertion [ [string] ] } [string] { assertion [ [string] ] }" ) [EOL] [EOL] if not nanopub : [EOL] log . error ( f" [string] { nanopub_url }" ) [EOL] [EOL] return { [string] : f" [string] { nanopub_url }" , [string] : [number] , [string] : [number] , [string] : assertions , [string] : False , [string] : [ ] , } [EOL] [EOL] nanopub [ [string] ] = nanopub_url [EOL] [EOL] [comment] [EOL] if not overwrite : [EOL] [comment] [EOL] edge = get_edges_for_nanopub ( nanopub_id ) [EOL] if edge : [EOL] [comment] [EOL] [comment] [EOL] if edge [ [string] ] . get ( [string] , None ) : [EOL] if nanopub [ [string] ] [ [string] ] [ [string] ] <= edge [ [string] ] [ [string] ] : [EOL] log . info ( [string] , nanopub_dt = nanopub [ [string] ] [ [string] ] [ [string] ] , edge_dt = edge [ [string] ] [ [string] ] , ) [EOL] return { [string] : [string] , [string] : True , [string] : [string] } [EOL] [EOL] end_time2 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time2 - end_time1 ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] results = bel . edge . edges . nanopub_to_edges ( nanopub , orthologize_targets = orthologize_targets ) [EOL] [EOL] end_time3 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time3 - end_time2 ) . total_seconds ( ) * [number] : [string] }" [EOL] [EOL] if results [ [string] ] : [EOL] [EOL] db_results = load_edges_into_db ( nanopub_id , nanopub [ [string] ] , edges = results [ [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] end_time4 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time4 - end_time3 ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] delta_ms = f"{ ( end_time4 - start_time ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] return { [string] : f" [string] { len ( results [ [string] ] ) } [string] " , [string] : len ( results [ [string] ] ) , [string] : len ( nanopub [ [string] ] [ [string] ] ) , [string] : assertions , [string] : True , [string] : results [ [string] ] , } [EOL] [EOL] else : [EOL] log . error ( f' [string] { nanopub_id } [string] { results [ [string] ] }' ) [EOL] return { [string] : f' [string] { results [ [string] ] }' , [string] : [number] , [string] : len ( nanopub [ [string] ] [ [string] ] ) , [string] : assertions , [string] : False , [string] : results [ [string] ] , } [EOL] [EOL] [EOL] def load_edges_into_db ( nanopub_id , nanopub_url , edges = [ ] , edges_coll_name = edges_coll_name , nodes_coll_name = nodes_coll_name , ) : [EOL] [docstring] [EOL] [EOL] start_time = datetime . datetime . now ( ) [EOL] [EOL] [comment] [EOL] query = f""" [string] { edges_coll_name } [string] { nanopub_id } [string] """ [EOL] [EOL] try : [EOL] edgestore_db . aql . execute ( query ) [EOL] except Exception as e : [EOL] log . debug ( f" [string] { query } [string] { e }" ) [EOL] [EOL] end_time1 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time1 - start_time ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] [comment] [EOL] node_list , edge_list = [ ] , [ ] [EOL] for doc in edge_iterator ( edges = edges ) : [EOL] if doc : [comment] [EOL] if doc [ [number] ] == [string] : [EOL] node_list . append ( doc [ [number] ] ) [EOL] else : [EOL] edge_list . append ( doc [ [number] ] ) [EOL] else : [EOL] log . error ( [string] , doc = doc ) [EOL] [EOL] end_time2 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time2 - end_time1 ) . total_seconds ( ) * [number] : [string] }" [EOL] [EOL] [comment] [EOL] [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] try : [EOL] edgestore_db . collection ( edges_coll_name ) . import_bulk ( edge_list , on_duplicate = [string] , halt_on_error = False ) [EOL] [EOL] except Exception as e : [EOL] log . exception ( f" [string] { e }" ) [EOL] [EOL] end_time3 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time3 - end_time2 ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] try : [EOL] edgestore_db . collection ( nodes_coll_name ) . import_bulk ( node_list , on_duplicate = [string] , halt_on_error = False ) [EOL] except Exception as e : [EOL] log . exception ( f" [string] { e }" ) [EOL] [EOL] end_time4 = datetime . datetime . now ( ) [EOL] delta_ms = f"{ ( end_time4 - end_time3 ) . total_seconds ( ) * [number] : [string] }" [EOL] log . debug ( [string] , delta_ms = delta_ms ) [EOL] [EOL] [EOL] def edge_iterator ( edges = [ ] , edges_fn = None ) : [EOL] [docstring] [EOL] [EOL] for edge in itertools . chain ( edges , files . read_edges ( edges_fn ) ) : [EOL] [EOL] subj = copy . deepcopy ( edge [ [string] ] [ [string] ] ) [EOL] subj_id = str ( utils . _create_hash_from_doc ( subj ) ) [EOL] subj [ [string] ] = subj_id [EOL] obj = copy . deepcopy ( edge [ [string] ] [ [string] ] ) [EOL] [EOL] obj_id = str ( utils . _create_hash_from_doc ( obj ) ) [EOL] obj [ [string] ] = obj_id [EOL] relation = copy . deepcopy ( edge [ [string] ] [ [string] ] ) [EOL] [EOL] relation [ [string] ] = f" [string] { subj_id }" [EOL] relation [ [string] ] = f" [string] { obj_id }" [EOL] [EOL] [comment] [EOL] relation_hash = copy . deepcopy ( relation ) [EOL] keep = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] , ] [EOL] for key in list ( relation_hash . keys ( ) ) : [EOL] if key not in keep : [EOL] relation_hash . pop ( key , None ) [EOL] [EOL] relation_id = str ( utils . _create_hash_from_doc ( relation_hash ) ) [EOL] relation [ [string] ] = relation_id [EOL] [EOL] if edge . get ( [string] , None ) : [EOL] if [string] not in relation : [EOL] relation [ [string] ] = { } [EOL] relation [ [string] ] [ [string] ] = edge [ [string] ] [EOL] [EOL] yield ( [string] , subj ) [EOL] yield ( [string] , obj ) [EOL] yield ( [string] , relation ) [EOL] [EOL] [EOL] def main ( ) : [EOL] pass [EOL] [EOL] [EOL] if __name__ == [string] : [EOL] main ( ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any , Dict , Mapping [EOL] import typing [EOL] import bel . Config as Config [EOL] [EOL] [EOL] def test_config ( ) : [EOL] [EOL] config = Config . load_configuration ( ) [EOL] assert config [ [string] ] [ [string] ] >= [string] [EOL] [EOL] [EOL] def test_merge_config ( ) : [EOL] [EOL] config = Config . load_configuration ( ) [EOL] override_config = { [string] : { [string] : { [string] : [string] } } } [EOL] new_config = Config . merge_config ( config , override_config = override_config ) [EOL] [EOL] assert ( config [ [string] ] [ [string] ] [ [string] ] != new_config [ [string] ] [ [string] ] [ [string] ] ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Union [EOL] import typing [EOL] import re [EOL] [EOL] [comment] [EOL] import bel . utils as utils [EOL] [EOL] [EOL] def test_first_true ( ) : [EOL] [EOL] test1 = [ False , [number] , [string] , None ] [EOL] test2 = [ None , [string] , [string] , None ] [EOL] test3 = [ None , False , [string] ] [EOL] [EOL] result = utils . first_true ( test1 ) [EOL] assert result == [number] [EOL] [EOL] result = utils . first_true ( test2 ) [EOL] assert result == [string] [EOL] [EOL] [comment] [EOL] result = utils . first_true ( test3 , [string] ) [EOL] assert result == [string] [EOL] [EOL] [EOL] def test_create_hash ( ) : [EOL] [EOL] h = utils . _create_hash ( [string] ) [EOL] assert h == [string] [EOL] [EOL] [EOL] def test_generate_id ( ) : [EOL] [EOL] _id = utils . _generate_id ( ) [EOL] assert re . match ( [string] , str ( _id ) ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import bel [EOL] import typing [EOL] import json [EOL] import os [EOL] [EOL] [comment] [EOL] import bel . nanopub . nanopubs as nb [EOL] import pytest [EOL] [EOL] local_dir = os . path . dirname ( __file__ ) [EOL] [EOL] [EOL] def remove_dt_keys ( edges ) : [EOL] [docstring] [EOL] for edge in edges : [EOL] if ( [string] in edge [ [string] ] [ [string] ] ) : [comment] [EOL] del edge [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] return edges [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_simple_nanopub ( ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] nanopub = json . load ( f ) [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] edges_result = json . load ( f ) [EOL] [EOL] N = nb . Nanopub ( ) [EOL] edges = N . bel_edges ( nanopub ) [EOL] [EOL] print ( [string] , json . dumps ( edges , indent = [number] ) ) [EOL] edges = remove_dt_keys ( edges ) [EOL] assert edges_result == edges [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_multiple_nanopub ( ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] nanopub = json . load ( f ) [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] edges_result = json . load ( f ) [EOL] [EOL] N = nb . Nanopub ( ) [EOL] edges = N . bel_edges ( nanopub ) [EOL] [EOL] print ( [string] , json . dumps ( edges , indent = [number] ) ) [EOL] edges = remove_dt_keys ( edges ) [EOL] assert edges_result == edges [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_nested_nanopub ( ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] nanopub = json . load ( f ) [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] edges_result = json . load ( f ) [EOL] [EOL] N = nb . Nanopub ( ) [EOL] edges = N . bel_edges ( nanopub ) [EOL] [EOL] print ( [string] , json . dumps ( edges , indent = [number] ) ) [EOL] edges = remove_dt_keys ( edges ) [EOL] assert edges_result == edges [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_degradation_nanopub ( ) : [EOL] [docstring] [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] nanopub = json . load ( f ) [EOL] [EOL] with open ( f"{ local_dir } [string] " , [string] ) as f : [EOL] edges_result = json . load ( f ) [EOL] [EOL] N = nb . Nanopub ( ) [EOL] edges = N . bel_edges ( nanopub ) [EOL] [EOL] print ( [string] , json . dumps ( edges , indent = [number] ) ) [EOL] edges = remove_dt_keys ( edges ) [EOL] assert edges_result == edges [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] [comment] [EOL] [comment] [EOL] import os [EOL] [EOL] [comment] [EOL] import pytest [EOL] [EOL] local_dir = os . path . dirname ( __file__ ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_valid_schema ( ) : [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Mapping [EOL] import typing [EOL] import json [EOL] import time [EOL] [EOL] [comment] [EOL] import bel . nanopub . pubmed [EOL] [EOL] [EOL] def test_get_pubmed1 ( ) : [EOL] [docstring] [EOL] [EOL] pmid = [string] [EOL] [EOL] doc = bel . nanopub . pubmed . get_pubmed ( pmid ) [EOL] [EOL] print ( [string] , json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] assert doc [ [string] ] == pmid [EOL] [EOL] [EOL] def test_get_pubmed2 ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pmid = [string] [EOL] [EOL] doc = bel . nanopub . pubmed . get_pubmed ( pmid ) [EOL] [EOL] print ( [string] , json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] assert doc [ [string] ] == pmid [EOL] assert ( doc [ [string] ] == [string] ) [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def test_get_pubmed3 ( ) : [EOL] [docstring] [EOL] [EOL] pmid = [string] [EOL] [EOL] doc = bel . nanopub . pubmed . get_pubmed ( pmid ) [EOL] [EOL] print ( [string] , json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] assert doc [ [string] ] == pmid [EOL] assert doc [ [string] ] == [string] [EOL] assert doc [ [string] ] == [string] [EOL] [EOL] [EOL] def test_get_pubmed4 ( ) : [EOL] [docstring] [EOL] [EOL] pmid = [string] [EOL] [EOL] doc = bel . nanopub . pubmed . get_pubmed ( pmid ) [EOL] [EOL] print ( [string] , json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] assert doc [ [string] ] == pmid [EOL] assert doc [ [string] ] == [string] [EOL] [EOL] time . sleep ( [number] ) [EOL] [EOL] [EOL] def test_get_pubmed_structured_abstract ( ) : [EOL] [docstring] [EOL] [EOL] pmid = [string] [EOL] [EOL] doc = bel . nanopub . pubmed . get_pubmed ( pmid ) [EOL] [EOL] print ( [string] , json . dumps ( doc , indent = [number] ) ) [EOL] [EOL] assert doc [ [string] ] == pmid [EOL] assert [string] in doc [ [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Dict [EOL] import typing [EOL] import bel . terms . terms [EOL] [EOL] [EOL] def test_terms ( ) : [EOL] [EOL] term_id = [string] [EOL] check = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] result = bel . terms . terms . get_normalized_terms ( term_id ) [EOL] [EOL] assert check == result [EOL] [EOL] [EOL] def test_obsolete_term ( ) : [EOL] [EOL] term_id = [string] [EOL] [EOL] check_id = [string] [EOL] [EOL] result = bel . terms . terms . get_terms ( term_id ) [EOL] [EOL] print ( [string] , result ) [EOL] [EOL] assert check_id == result [ [number] ] [ [string] ] [EOL] [EOL] result = bel . terms . terms . get_normalized_terms ( term_id ) [EOL] [EOL] print ( [string] , result ) [EOL] [EOL] check = { [string] : [string] , [string] : [string] , [string] : [string] } [EOL] [EOL] assert check == result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import bel . lang . bel_utils as bel_utils [EOL] [EOL] [EOL] def test_quoting_nsarg ( ) : [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL] [EOL] test_arg = [string] [EOL] correct_arg = [string] [EOL] [EOL] assert correct_arg == bel_utils . quoting_nsarg ( test_arg ) [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any , Mapping [EOL] import typing [EOL] import json [EOL] [EOL] [comment] [EOL] import bel . lang . completion [EOL] import bel . utils [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] [EOL] [comment] [EOL] def test_completion_populationAbundance ( ) : [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] , bel_version = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert ( [string] == [ c [ [string] ] for c in completions [ [string] ] if c [ [string] ] == [string] ] [ [number] ] ) [EOL] [EOL] [EOL] [comment] [EOL] def test_completion_complex ( ) : [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert len ( completions [ [string] ] ) == [number] [EOL] [EOL] [EOL] [comment] [EOL] def test_completion_loc ( ) : [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert [ [string] ] == [ c [ [string] ] for c in completions [ [string] ] if c [ [string] ] == [string] ] [EOL] [EOL] [EOL] def test_completion_empty_start ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert [ [string] ] == [ c [ [string] ] for c in completions [ [string] ] if c [ [string] ] == [string] ] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_fn_start_paren ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_fn_start_paren_f ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_fn_name_start_long ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_fn_name_start_medium ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_fn_name_start_medium_2 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_arg_fn ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_fn_2 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_fn_3 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert len ( completions [ [string] ] ) > [number] [EOL] [EOL] [EOL] def test_completion_arg_fn_4 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert len ( completions [ [string] ] ) > [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_fn_5 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_ns_prefix ( ) : [EOL] [EOL] if ( bel . http_client . get ( f"{ config [ [string] ] [ [string] ] [ [string] ] } [string] " ) . status_code != [number] ) : [EOL] pytest . xfail ( [string] ) [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_ns_val ( ) : [EOL] [EOL] if ( bel . http_client . get ( f"{ config [ [string] ] [ [string] ] [ [string] ] } [string] " ) . status_code != [number] ) : [EOL] pytest . xfail ( [string] ) [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert [string] in completions [ [string] ] [ [number] ] [ [string] ] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_StrArgNSArg_1 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_arg_StrArgNSArg_2 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_relation_end ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert ( completions [ [string] ] [ [number] ] [ [string] ] == [string] ) [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_relation_end_short ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_relation_end_short_cursorloc ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert [ [string] , [string] , [string] ] == sorted ( [ c [ [string] ] for c in completions [ [string] ] ] ) [EOL] assert [ [string] ] == [ c [ [string] ] for c in completions [ [string] ] if c [ [string] ] == [string] ] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_nested_relation_end ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert ( completions [ [string] ] [ [number] ] [ [string] ] == [string] ) [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] def test_completion_nested_relation ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] , ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert ( completions [ [string] ] [ [number] ] [ [string] ] == [string] ) [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] == [ ] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_completion_error_1 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] , cursor_loc = [number] , bel_fmt = [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [number] [EOL] assert completions [ [string] ] != [ ] [EOL] assert completions [ [string] ] != [ ] [EOL] [EOL] [EOL] def test_completion_activity_fn_1 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert completions [ [string] ] [ [number] ] [ [string] ] == [string] [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_completion_complex_fn_1 ( ) : [EOL] [EOL] completions = bel . lang . completion . bel_completion ( [string] ) [EOL] print ( [string] , json . dumps ( completions , indent = [number] ) ) [EOL] assert [ [string] ] == [ c [ [string] ] for c in completions [ [string] ] if c [ [string] ] == [string] ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import Any [EOL] import bel [EOL] import typing [EOL] import bel . Config [EOL] import bel . lang . bel_utils [EOL] import bel . lang . belobj [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [EOL] [EOL] def test_convert_nsarg ( ) : [EOL] [docstring] [EOL] [EOL] nsarg = [string] [EOL] [EOL] expected_nsarg = [string] [EOL] [EOL] canon_nsarg = bel . lang . bel_utils . convert_nsarg ( nsarg ) [EOL] [EOL] assert canon_nsarg == expected_nsarg [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_canon_one ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . canonicalize ( ) [EOL] [EOL] print ( f" [string] { bo . ast . to_string ( fmt = [string] ) }" ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_canon_two ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . canonicalize ( ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_canon_nested ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . canonicalize ( ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_canonicalization ( ) : [EOL] [docstring] [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] result = bo . parse ( assertion ) . canonicalize ( ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_canonicalization_NSArg ( ) : [EOL] [docstring] [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] result = bo . parse ( assertion ) . canonicalize ( ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_decanon_one ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . decanonicalize ( ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_decanon_two ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . decanonicalize ( ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_decanon_nested ( ) : [EOL] [EOL] statement = [string] [EOL] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] [EOL] bo . decanonicalize ( ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_decanonicalization ( ) : [EOL] [docstring] [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] [EOL] result = bo . parse ( assertion ) . decanonicalize ( ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] [EOL] result = bo . parse ( assertion ) . decanonicalize ( ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
import bel [EOL] import bel [EOL] [EOL] SPECIFIED_VERSION = [string] [EOL] SPECIFIED_VERSION_UNDERLINED = [string] [EOL] [EOL] SPECIFIED_ENDPOINT = [string] [EOL] [EOL] bel_obj = bel . BEL ( version = SPECIFIED_VERSION , api_url = SPECIFIED_ENDPOINT ) [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_correct_instantiation ( ) : [EOL] assert bel_obj . version == SPECIFIED_VERSION [EOL] assert bel_obj . api_url == SPECIFIED_ENDPOINT [EOL]	0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 $builtins.str$ 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $builtins.str$ 0 0 0 $builtins.str$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 $builtins.str$ 0 0 $bel.lang.belobj.BEL$ 0 0 0 $builtins.str$ 0
[comment] [EOL] from typing import List , Any [EOL] import typing [EOL] from bel . lang . bel_utils import _default_to_version [EOL] [EOL] EXAMPLE_AVAILABLE_VERSIONS = [ [string] , [string] , [string] , [string] , [string] , [string] , [string] ] [EOL] [EOL] [EOL] def test_version_one_digit ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = [string] [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_one_digit_dot ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_two_digits ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = [string] [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_two_digits_dot ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = [string] [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_three_digits ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_three_digits_dot ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_more_than_three_digits ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [comment] [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_string ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_empty_string ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_string_with_digits_begin ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_string_with_digits_mid ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL] [EOL] [EOL] def test_version_string_with_digits_end ( ) : [EOL] [EOL] version_given = [string] [EOL] [EOL] expected_version = None [EOL] actual_version = _default_to_version ( version_given , EXAMPLE_AVAILABLE_VERSIONS ) [EOL] [EOL] assert expected_version == actual_version [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.List[builtins.str]$ 0 0 0 0 0 0 0 0
import bel . lang . migrate_1_2 [EOL] import pytest [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_migrate_naked_entities ( ) : [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [EOL] def test_migrate ( ) : [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL] [EOL] [comment] [EOL] bel1 = [string] [EOL] bel2 = [string] [EOL] [EOL] assert bel . lang . migrate_1_2 . migrate ( bel1 ) == bel2 [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import bel [EOL] import bel . db . arangodb [EOL] import bel . lang . ast [EOL] import bel . lang . bel_utils [EOL] import bel . lang . belobj [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def test_bel_semantic_validation ( ) : [EOL] [EOL] obsolete_NSArg = [string] [EOL] [EOL] bo . parse ( obsolete_NSArg ) . semantic_validation ( ) [EOL] [EOL] print ( [string] , bo . validation_messages ) [EOL] [EOL] assert bo . validation_messages [ [number] ] [ [number] ] == [string] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] import bel [EOL] import bel . lang . ast [EOL] import bel . lang . bel_utils [EOL] import bel . lang . belobj [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_nsarg_normalization ( ) : [EOL] [docstring] [EOL] [EOL] canonical = [string] [EOL] decanonical = [string] [EOL] [EOL] obj_canonical = [string] [EOL] obj_decanonical = [string] [EOL] [EOL] bo . parse ( [string] ) [EOL] bo . collect_nsarg_norms ( ) [EOL] [EOL] print ( bo . ast . bel_subject . args [ [number] ] . canonical ) [EOL] print ( bo . ast . bel_subject . args [ [number] ] . decanonical ) [EOL] [EOL] bo . print_tree ( ) [EOL] [EOL] assert canonical == bo . ast . bel_subject . args [ [number] ] . canonical [EOL] assert decanonical == bo . ast . bel_subject . args [ [number] ] . decanonical [EOL] assert obj_canonical == bo . ast . bel_object . args [ [number] ] . canonical [EOL] assert obj_decanonical == bo . ast . bel_object . args [ [number] ] . decanonical [EOL] [EOL] assert bo . ast . collected_nsarg_norms [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_nested_nsarg_normalization ( ) : [EOL] [docstring] [EOL] [EOL] subj_canonical = [string] [EOL] subj_decanonical = [string] [EOL] [EOL] nested_subj_canonical = [string] [EOL] nested_subj_decanonical = [string] [EOL] [EOL] bo . parse ( [string] ) [EOL] bo . collect_nsarg_norms ( ) [EOL] [EOL] print ( bo . ast . bel_subject . args [ [number] ] . canonical ) [EOL] print ( bo . ast . bel_subject . args [ [number] ] . decanonical ) [EOL] [EOL] bo . print_tree ( ) [EOL] [EOL] assert subj_canonical == bo . ast . bel_subject . args [ [number] ] . canonical [EOL] assert subj_decanonical == bo . ast . bel_subject . args [ [number] ] . decanonical [EOL] assert nested_subj_canonical == bo . ast . bel_object . bel_subject . args [ [number] ] . canonical [EOL] assert nested_subj_decanonical == bo . ast . bel_object . bel_subject . args [ [number] ] . decanonical [EOL] [EOL] assert bo . ast . collected_nsarg_norms [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_appending_orthologs_to_nsargs ( ) : [EOL] [docstring] [EOL] [EOL] bo . parse ( [string] ) [EOL] bo . collect_orthologs ( [ [string] , [string] , [string] ] ) [EOL] [EOL] print ( [string] , bo . ast . bel_subject . args [ [number] ] . orthologs ) [EOL] print ( [string] , bo . ast . bel_object . args [ [number] ] . orthologs ) [EOL] [EOL] orthologs = bo . ast . bel_subject . args [ [number] ] . orthologs [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] [EOL] orthologs = bo . ast . bel_object . args [ [number] ] . orthologs [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] [EOL] assert bo . ast . collected_orthologs [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_nested_appending_orthologs_to_nsargs ( ) : [EOL] [docstring] [EOL] [EOL] bo . parse ( [string] ) [EOL] bo . collect_orthologs ( [ [string] , [string] , [string] ] ) [EOL] [EOL] print ( [string] , bo . ast . bel_subject . args [ [number] ] . orthologs ) [EOL] print ( [string] , bo . ast . bel_object . bel_subject . args [ [number] ] . orthologs ) [EOL] print ( [string] , bo . ast . bel_object . bel_object . args [ [number] ] . orthologs ) [EOL] [EOL] orthologs = bo . ast . bel_subject . args [ [number] ] . orthologs [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] [EOL] orthologs = bo . ast . bel_object . bel_subject . args [ [number] ] . orthologs [EOL] assert orthologs [ [string] ] [ [string] ] == [string] [EOL] [EOL] assert bo . ast . collected_orthologs [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import bel [EOL] import typing [EOL] import bel . lang . belobj [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] SPECIFIED_VERSION_UNDERLINED = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_extra_right_paren ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] print ( bo . validation_messages ) [EOL] [EOL] [EOL] def test_extra_left_paren ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] print ( bo . validation_messages ) [EOL] [EOL] [EOL] def test_missing_parens ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] print ( bo . validation_messages ) [EOL] [EOL] [EOL] def test_bad_namespace ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] def test_arg_outside ( ) : [EOL] s = [string] [EOL] bo . parse ( s ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] def test_no_comma_between_args ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] def test_no_func_given ( ) : [EOL] s = [string] [EOL] [EOL] bo . parse ( s ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_valid_statements ( ) : [EOL] stmts = [ [string] , [string] , [string] , ] [EOL] [EOL] for s in stmts : [EOL] bo . parse ( s ) [EOL] assert bo . parse_valid [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0
[comment] [EOL] from typing import Any , Set [EOL] import bel [EOL] import typing [EOL] import bel . lang . belobj [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_species ( ) : [EOL] [EOL] assertion = [string] [EOL] bo . parse ( assertion ) [EOL] bo . collect_nsarg_norms ( ) [EOL] [EOL] print ( f" [string] { bo . ast . species }" ) [EOL] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] def test_multi_species ( ) : [EOL] [EOL] assertion = [string] [EOL] bo . parse ( assertion ) [EOL] bo . collect_nsarg_norms ( ) [EOL] [EOL] print ( f" [string] { bo . ast . species }" ) [EOL] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_obsolete_term_orthologization ( ) : [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] [EOL] result = bo . parse ( assertion ) . orthologize ( [string] ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [comment] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) [comment] [EOL] def test_obsolete_term_NSArg_orthologization ( ) : [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] [EOL] result = bo . parse ( assertion ) . orthologize ( [string] ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [comment] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_orthologization ( ) : [EOL] [docstring] [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] result = bo . parse ( assertion ) . orthologize ( [string] ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [comment] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_multi_orthologization ( ) : [EOL] [docstring] [EOL] [EOL] assertion = [string] [EOL] correct = [string] [EOL] result = bo . parse ( assertion ) . orthologize ( [string] ) . to_string ( ) [EOL] print ( [string] , result ) [EOL] [EOL] assert correct == result [EOL] [EOL] [comment] [EOL] correct = set ( ) [EOL] correct . add ( ( [string] , [string] ) ) [EOL] [EOL] assert correct == bo . ast . species [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_ortho_one ( ) : [EOL] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] [EOL] print ( bo . ast . to_string ( fmt = [string] ) ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_ortho_two ( ) : [EOL] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_ortho_nested ( ) : [EOL] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_ortho_three ( ) : [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] assert bo . to_string ( ) == expected [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_ortho_partial ( ) : [EOL] [comment] [EOL] [EOL] [comment] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] [EOL] print ( bo . ast . to_string ( fmt = [string] ) ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] assert len ( bo . ast . species ) == [number] [EOL] [EOL] [comment] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] [EOL] print ( [string] , bo . ast . to_string ( fmt = [string] ) ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] [EOL] print ( [string] , bo . ast . species ) [EOL] [EOL] assert len ( bo . ast . species ) > [number] [EOL] [EOL] [comment] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] bo . orthologize ( [string] ) [EOL] [EOL] print ( bo . ast . to_string ( fmt = [string] ) ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] assert len ( bo . ast . species ) == [number] [EOL] [EOL] [comment] [EOL] statement = [string] [EOL] expected = [string] [EOL] [EOL] bo . parse ( statement ) [EOL] print ( [string] , bo . ast . species ) [EOL] bo . orthologize ( [string] ) [EOL] [EOL] print ( bo . ast . to_string ( fmt = [string] ) ) [EOL] [EOL] assert bo . ast . to_string ( fmt = [string] ) == expected [EOL] print ( [string] , bo . ast . species ) [EOL] assert len ( bo . ast . species ) == [number] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0
[comment] [EOL] import bel [EOL] import bel . lang . belobj [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def test_empty_string ( ) : [EOL] [EOL] statement = [string] [EOL] bo . parse ( statement ) [EOL] [EOL] assert bo . ast is None [EOL] assert ( [string] in bo . validation_messages [ [number] ] [ [number] ] ) [EOL] [EOL] [EOL] def test_bad_string_start ( ) : [EOL] [EOL] statement = [string] [EOL] bo . parse ( statement ) [EOL] [EOL] assert bo . ast is None [EOL] assert [string] in bo . validation_messages [ [number] ] [ [number] ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_complex_parse ( ) : [EOL] [docstring] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] pass [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
from typing import Any [EOL] import typing [EOL] import bel . lang . partialparse [EOL] import pytest [EOL] [EOL] [EOL] def test_parse ( ) : [EOL] [EOL] bel_version = [string] [EOL] belstr = [string] [EOL] ast = bel . lang . partialparse . get_ast_obj ( belstr , bel_version ) [EOL] [EOL] print ( ast . to_string ( ) ) [EOL] [EOL] assert ast . to_string ( ) == [string] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_parse_bad_tloc ( ) : [EOL] [EOL] [comment] [EOL] belstr = [string] [EOL] [EOL] bel_version = [string] [EOL] ast = bel . lang . partialparse . get_ast_obj ( belstr , bel_version ) [EOL] [EOL] print ( ast . to_string ( ) ) [EOL] [EOL] assert False [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any [EOL] import bel [EOL] import typing [EOL] import bel . lang . belobj [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] SPECIFIED_VERSION_UNDERLINED = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] [EOL] [EOL] def test_term_validation ( ) : [EOL] [EOL] s = [string] [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] print ( [string] , bo . parse_valid , [string] , bo . validation_messages ) [EOL] assert bo . parse_valid [EOL] [EOL] [EOL] def test_bad_function ( ) : [EOL] s = [string] [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] print ( [string] , bo . parse_valid , [string] , bo . validation_messages ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] def test_bad_relation ( ) : [EOL] s = [string] [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] assert not bo . parse_valid [EOL] print ( [string] , bo . validation_messages ) [EOL] [EOL] [EOL] def test_bad_subject ( ) : [EOL] s = [string] [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] print ( [string] , bo . parse_valid , [string] , bo . validation_messages ) [EOL] assert not bo . parse_valid [EOL] [EOL] [EOL] def test_bad_object ( ) : [EOL] s = [string] [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] assert not bo . parse_valid [EOL] print ( [string] , bo . validation_messages ) [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] def test_valid_statements ( ) : [EOL] stmts = [ [string] , [string] , [string] , ] [EOL] [EOL] for s in stmts : [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] error_msgs = [ msg for msg_level , msg in bo . validation_messages if msg_level == [string] ] [EOL] assert error_msgs == [ ] [EOL] [EOL] [EOL] [comment] [EOL] [comment] [EOL] [comment] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_complex_nsarg ( ) : [EOL] stmts = [ [string] ] [EOL] [EOL] for s in stmts : [EOL] bo . parse ( s ) . semantic_validation ( ) [EOL] print ( bo . validation_messages ) [EOL] error_msgs = [ msg for msg_level , msg in bo . validation_messages if msg_level == [string] ] [EOL] warning_msgs = [ msg for msg_level , msg in bo . validation_messages if msg_level == [string] ] [EOL] assert error_msgs == [ ] [EOL] assert warning_msgs == [ ] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Mapping , MutableSequence [EOL] import bel [EOL] import typing [EOL] import bel . edge . computed [EOL] import bel . lang . belobj [EOL] from bel . Config import config [EOL] [EOL] bo = bel . lang . belobj . BEL ( config [ [string] ] [ [string] ] [ [string] ] , config [ [string] ] [ [string] ] [ [string] ] ) [EOL] [EOL] [EOL] def test_complex ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] [EOL] for edge in edges : [EOL] print ( str ( edge ) ) [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_act ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_pmod ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_var ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_frag ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_loc ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_tloc ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] [EOL] assert str ( edges [ [number] ] ) == check_edges [ [number] ] [EOL] [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_surf_and_sec ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_fus ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_deg ( ) : [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL] [EOL] [EOL] def test_rxn ( ) : [EOL] [EOL] belstr = [string] [EOL] check_edges = [ [string] , [string] , [string] , ] [EOL] [EOL] parsed = bo . parse ( belstr ) [EOL] [EOL] edges = bel . edge . computed . compute_edges ( parsed . ast , bo . spec ) [EOL] for edge in edges : [EOL] assert str ( edge ) in check_edges [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $bel.lang.belobj.BEL$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
[comment] [EOL] from typing import List , Any , Dict , Union [EOL] import typing [EOL] import bel . edge . edges [EOL] import pytest [EOL] from bel . Config import config [EOL] [EOL] api_url = config [ [string] ] [ [string] ] [ [string] ] [EOL] [EOL] [EOL] [comment] [EOL] def test_assertion_edge_info_dup_computed ( ) : [EOL] [docstring] [EOL] [EOL] bel_version = config [ [string] ] [ [string] ] [ [string] ] [EOL] orthologize_targets = [ [string] , [string] ] [EOL] [EOL] assertions = [ { [string] : [string] , [string] : [string] , [string] : [string] , } ] [EOL] [EOL] nanopub_type = [string] [comment] [EOL] [EOL] r = bel . edge . edges . generate_assertion_edge_info ( assertions , orthologize_targets , bel_version , api_url , nanopub_type ) [EOL] edge_info_list = r [ [string] ] [EOL] [EOL] print ( [string] ) [EOL] for idx , edge in enumerate ( edge_info_list ) : [EOL] try : [EOL] print ( f'{ idx } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] }' ) [EOL] except Exception : [EOL] print ( f'{ idx } [string] { edge [ [string] ] }' ) [EOL] [EOL] edges = [ edge for edge in edge_info_list if [string] not in edge [ [string] ] ] [EOL] assert len ( edges ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_generate_assertion_edge_info1 ( ) : [EOL] [docstring] [EOL] [EOL] bel_version = config [ [string] ] [ [string] ] [ [string] ] [EOL] orthologize_targets = [ [string] , [string] ] [EOL] [EOL] assertions = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] nanopub_type = [string] [comment] [EOL] [EOL] r = bel . edge . edges . generate_assertion_edge_info ( assertions , orthologize_targets , bel_version , api_url , nanopub_type ) [EOL] edge_info_list = r [ [string] ] [EOL] [EOL] print ( [string] ) [EOL] for idx , edge in enumerate ( edge_info_list ) : [EOL] try : [EOL] print ( f'{ idx } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] }' ) [EOL] except Exception : [EOL] print ( f'{ idx } [string] { edge [ [string] ] }' ) [EOL] [EOL] bad_ns_flag = False [EOL] for idx , edge in enumerate ( edge_info_list ) : [EOL] for ns in [ [string] , [string] ] : [EOL] if ns in [ edge [ [string] ] [ [string] ] , edge [ [string] ] [ [string] ] , edge [ [string] ] [ [string] ] , ] : [EOL] bad_ns_flag = True [EOL] assert not bad_ns_flag [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert len ( edge_info_list ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_generate_assertion_edge_info2 ( ) : [EOL] [docstring] [EOL] [EOL] bel_version = config [ [string] ] [ [string] ] [ [string] ] [EOL] orthologize_targets = [ [string] , [string] ] [EOL] [EOL] assertions = [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , ] [EOL] [EOL] nanopub_type = [string] [comment] [EOL] [EOL] r = bel . edge . edges . generate_assertion_edge_info ( assertions , orthologize_targets , bel_version , api_url , nanopub_type ) [EOL] edge_info_list = r [ [string] ] [EOL] [EOL] [comment] [EOL] [EOL] print ( [string] ) [EOL] for idx , edge in enumerate ( edge_info_list ) : [EOL] try : [EOL] print ( f'{ idx } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] } [string] { edge [ [string] ] }' ) [EOL] except Exception : [EOL] print ( f'{ idx } [string] { edge [ [string] ] }' ) [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] assert edge_info_list [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == [ [string] ] [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == { [string] : [string] , [string] : [string] , [string] : [string] , } [EOL] [EOL] assert edge_info_list [ [number] ] [ [string] ] == [string] [EOL] [EOL] errors = [ edge [ [string] ] for edge in edge_info_list if edge [ [string] ] ] [EOL] [EOL] assert len ( errors ) == [number] [EOL] [EOL] assert len ( edge_info_list ) == [number] [EOL] [EOL] [EOL] @ pytest . mark . skip ( reason = [string] ) def test_nanopub_to_edges ( ) : [EOL] [EOL] nanopub = { [string] : False , [string] : [string] , [string] : True , [string] : None , [string] : [string] , [string] : [string] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] } , { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] } , ] , [string] : { [string] : [string] , [string] : { [string] : [string] , [string] : [string] } , } , [string] : [ { [string] : [string] , [string] : [string] , [string] : [string] , } , { [string] : [string] , [string] : [string] , [string] : [string] , } , ] , [string] : [string] , [string] : { [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , [string] : [string] , } , } , } [EOL] [EOL] orthologize_targets = [ [string] , [string] ] [EOL] r = bel . edge . edges . nanopub_to_edges ( nanopub , orthologize_targets = orthologize_targets ) [EOL] [EOL] print ( [string] ) [EOL] for edge in r [ [string] ] : [EOL] [comment] [EOL] print ( f'{ edge [ [string] ] [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] [ [string] ] } [string] { edge [ [string] ] [ [string] ] [ [string] ] }' ) [EOL] [EOL] [comment] [EOL] [EOL] assert len ( r [ [string] ] ) == [number] [EOL] [EOL] assert r [ [string] ] [ [number] ] [ [string] ] [ [string] ] [ [string] ] == [string] [EOL] [EOL] [comment] [EOL]	0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 $typing.Any$ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0